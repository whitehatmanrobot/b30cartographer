, (void **) ppIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    pRule = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pRule)
    {
        delete pRule;
    }
    return hr;
}

STDMETHODIMP COERule::GetClassID(CLSID * pclsid)
{
    HRESULT     hr = S_OK;

    if (NULL == pclsid)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *pclsid = CLSID_OERule;

    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP COERule::IsDirty(void)
{
    HRESULT     hr = S_OK;

    hr = (RULE_STATE_DIRTY == (m_dwState & RULE_STATE_DIRTY)) ? S_OK : S_FALSE;
    
    return hr;
}

STDMETHODIMP COERule::Load(IStream * pStm)
{
    HRESULT             hr = S_OK;
    ULONG               cbData = 0;
    ULONG               cbRead = 0;
    DWORD               dwData = 0;
    LPSTR               pszName = NULL;
    BOOL                fDisabled = FALSE;
    IOECriteria *       pICriteria = NULL;
    IPersistStream *    pIPStm = NULL;
    IOEActions *        pIActions = NULL;
    
    // Check incoming param
    if (NULL == pStm)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Verify we have the correct version
    hr = pStm->Read(&dwData, sizeof(dwData), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }

    if ((cbRead != sizeof(dwData)) || (dwData != RULE_VERSION))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get the size of the rule name
    hr = pStm->Read(&cbData, sizeof(cbData), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }

    if (cbRead != sizeof(cbData))
    {
        hr = E_FAIL;
        goto exit;
    }

    if (0 != cbData)
    {
        // Allocate space to hold the rule name
        hr = HrAlloc((void **) &pszName, cbData);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Get the rule name
        hr = pStm->Read(pszName, cbData, &cbRead);
        if (FAILED(hr))
        {
            goto exit;
        }

        if (cbRead != cbData)
        {
            hr = E_FAIL;
            goto exit;
        }
    }
    
    // Get the enabled state
    hr = pStm->Read(&dwData, sizeof(dwData), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }

    if (cbRead != sizeof(dwData))
    {
        hr = E_FAIL;
        goto exit;
    }

    fDisabled = ! (BOOL) dwData;

    // Create a new criteria object
    hr = HrCreateCriteria(&pICriteria);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the persistance interface for the criteria
    hr = pICriteria->QueryInterface(IID_IPersistStream, (void **) &pIPStm);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the criteria
    hr = pIPStm->Load(pStm);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create a new actions object
    hr = HrCreateActions(&pIActions);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the persistance interface for the actions
    pIPStm->Release();
    pIPStm = NULL;
    hr = pIActions->QueryInterface(IID_IPersistStream, (void **) &pIPStm);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the actions
    hr = pIPStm->Load(pStm);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Free up the current values
    SafeMemFree(m_pszName);
    SafeRelease(m_pICrit);
    SafeRelease(m_pIAct);

    // Save the new values
    m_pszName = pszName;
    pszName = NULL;
    if (FALSE == fDisabled)
    {
        m_dwState &= ~RULE_STATE_DISABLED;
    }
    else
    {
        m_dwState |= RULE_STATE_DISABLED;
    }
    m_pICrit = pICriteria;
    pICriteria = NULL;
    m_pIAct = pIActions;
    pIActions = NULL;

    // Make sure we clear the dirty bit
    m_dwState &= ~RULE_STATE_DIRTY;

    // Note that we have been loaded
    m_dwState |= RULE_STATE_LOADED;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeRelease(pIActions);
    SafeRelease(pICriteria);
    SafeRelease(pIPStm);
    SafeMemFree(pszName);
    return hr;
}

STDMETHODIMP COERule::Save(IStream * pStm, BOOL fClearDirty)
{
    HRESULT             hr = S_OK;
    ULONG               cbData = 0;
    ULONG               cbWritten = 0;
    DWORD               dwData = 0;
    ULONG               ulIndex = 0;
    IPersistStream *    pIPStm = NULL;

    // Check incoming param
    if (NULL == pStm)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Can't write out a rule if we don't have criteria or actions
    // or a rule name
    if ((NULL == m_pICrit) || (NULL == m_pIAct))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Write out the version
    dwData = RULE_VERSION;
    hr = pStm->Write(&dwData, sizeof(dwData), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(dwData));
    
    // Write out the size of the rule name
    if (NULL != m_pszName)
    {
        cbData = lstrlen(m_pszName) + 1;
    }
    else
    {
        cbData = 0;
    }
    
    hr = pStm->Write(&cbData, sizeof(cbData), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(cbData));

    if (NULL != m_pszName)
    {
        // Write out the rule name
        hr = pStm->Write(m_pszName, cbData, &cbWritten);
        if (FAILED(hr))
        {
            goto exit;
        }
        Assert(cbWritten == cbData);
    }
    
    // Write out the enabled state
    dwData = !(m_dwState & RULE_STATE_DISABLED);
    hr = pStm->Write(&dwData, sizeof(dwData), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(dwData));

    // Get the persistance interface for the criteria
    hr = m_pICrit->QueryInterface(IID_IPersistStream, (void **) &pIPStm);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Write out the criteria
    hr = pIPStm->Save(pStm, fClearDirty);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the persistance interface for the actions
    pIPStm->Release();
    pIPStm = NULL;
    hr = m_pIAct->QueryInterface(IID_IPersistStream, (void **) &pIPStm);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Write out the actions
    hr = pIPStm->Save(pStm, fClearDirty);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Should we clear out the dirty bit
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~RULE_STATE_DIRTY;
    }

    // Set the return value
    hr = S_OK;
    
exit:
    SafeRelease(pIPStm);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\rule.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Rule.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"

class COERule : public IOERule, IPersistStream
{
  private:  
    enum
    {
        RULE_STATE_UNINIT   = 0x00000000,
        RULE_STATE_INIT     = 0x00000001,
        RULE_STATE_LOADED   = 0x00000002,
        RULE_STATE_DIRTY    = 0x00000004,
        RULE_STATE_DISABLED = 0x00000008,
        RULE_STATE_INVALID  = 0x00000010
    };    

    enum {RULE_VERSION = 0x00050000};
        
  private:
    LONG            m_cRef;
    DWORD           m_dwState;
    LPSTR           m_pszName;
    IOECriteria *   m_pICrit;
    IOEActions *    m_pIAct;
    DWORD           m_dwVersion;
    
  public:
    // Constructor/destructor
    COERule();
    ~COERule();

    // IUnknown members
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IRule members
    STDMETHODIMP Reset(void);
    STDMETHODIMP GetState(DWORD * pdwState);
    STDMETHODIMP Validate(DWORD dwFlags);
    
    STDMETHODIMP GetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarResult);
    STDMETHODIMP SetProp(RULE_PROP prop, DWORD dwFlags, PROPVARIANT * pvarValue);

    STDMETHODIMP Evaluate(LPCSTR pszAcct, MESSAGEINFO * pMsgInfo, IMessageFolder * pFolder, 
                            IMimePropertySet * pIMPropSet, IMimeMessage * pIMMsg, ULONG cbMsgSize,
                            ACT_ITEM ** ppActions, ULONG * pcActions);

    STDMETHODIMP LoadReg(LPCSTR szRegPath);
    STDMETHODIMP SaveReg(LPCSTR szRegPath, BOOL fClearDirty);
    STDMETHODIMP Clone(IOERule ** ppIRule);
                            
    // IPersistStream members
    STDMETHODIMP GetClassID(CLSID * pclsid);
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(IStream * pStm);
    STDMETHODIMP Save(IStream * pStm, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize) { return E_NOTIMPL; }    
};

HRESULT HrCreateRule(IOERule ** ppIRule);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\ruledesc.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  RuleDesc.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"

#define NM_RULE_CHANGED   (WMN_FIRST + 1)

typedef struct tagRULEDESCRIPT_LIST
{
    ULONG                           ulIndex;
    BOOL                            fError;
    ULONG                           ulStart;
    ULONG                           ulEnd;
    LPSTR                           pszText;
    DWORD                           dwFlags;
    PROPVARIANT                     propvar;
    ULONG                           ulStartLogic;
    ULONG                           ulEndLogic;
    struct tagRULEDESCRIPT_LIST *   pNext;
} RULEDESCRIPT_LIST, * PRULEDESCRIPT_LIST;

const int RDF_READONLY      = 0x00000001;
const int RDF_APPLYDLG      = 0x00000002;

// Class definitions
class CRuleDescriptUI
{
  private:
    enum
    {
        STATE_UNINIT        = 0x00000000,
        STATE_INITIALIZED   = 0x00000001,
        STATE_DIRTY         = 0x00000002,
        STATE_READONLY      = 0x00000004,
        STATE_HASRULE       = 0x00000008,
        STATE_APPLYDLG      = 0x00000010,
        STATE_ENABLED       = 0x00000020
    };

  private:
    HWND                m_hwndOwner;
    DWORD               m_dwFlags;
    DWORD               m_dwState;
    RULE_TYPE           m_typeRule;
    RULEDESCRIPT_LIST * m_pDescriptListCrit;
    ULONG               m_cDescriptListCrit;
    RULEDESCRIPT_LIST * m_pDescriptListAct;
    ULONG               m_cDescriptListAct;
    HFONT               m_hfont;
    WNDPROC             m_wpcOld;
    CRIT_LOGIC          m_logicCrit;
    BOOL                m_fErrorLogic;
    
  public:
    CRuleDescriptUI();
    ~CRuleDescriptUI();

    // The main UI methods
    HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
    HRESULT HrIsDirty(void) { return (0 == (m_dwState & STATE_DIRTY)) ? S_FALSE : S_OK; }
    HRESULT HrClearDirty(void)
    {
        HRESULT hr = (0 == (m_dwState & STATE_DIRTY)) ? S_FALSE : S_OK;
        m_dwState &= ~STATE_DIRTY;
        return hr;
    }
    HRESULT HrIsReadOnly(void) { return (0 == (m_dwState & STATE_READONLY)) ? S_FALSE : S_OK; }
    HRESULT HrSetReadOnly(BOOL fSet)
    {
        if (fSet)
        {
            m_dwState |= STATE_READONLY;
        }
        else
        {
            m_dwState &= ~STATE_READONLY;
        }
        return S_OK;
    }

    HRESULT HrIsEnabled(void) { return (0 == (m_dwState & STATE_ENABLED)) ? S_FALSE : S_OK; }
    HRESULT HrSetEnabled(BOOL fSet)
    {
        if (fSet)
        {
            m_dwState |= STATE_ENABLED;
        }
        else
        {
            m_dwState &= ~STATE_ENABLED;
        }
        return S_OK;
    }

    HRESULT HrSetRule(RULE_TYPE typeRule, IOERule * pIRule);
    HRESULT HrVerifyRule(void);
    
    HRESULT HrEnableCriteria(CRIT_TYPE type, BOOL fEnable);
    HRESULT HrEnableActions(ACT_TYPE type, BOOL fEnable);
            
    HRESULT HrGetCriteria(CRIT_ITEM ** ppCritList, ULONG * pcCritList);
    HRESULT HrGetActions(ACT_ITEM ** ppActList, ULONG * pcActList);
    
    // Message handling functions
    void ShowDescriptionString(VOID);

  private:
    // Utility functions
    void _ShowLinkedString(ULONG ulText, RULEDESCRIPT_LIST * pruilist,  BOOL fFirst, BOOL fCrit);
    
    BOOL _FChangeLogicValue(RULEDESCRIPT_LIST * pDescriptList);
    
    HRESULT _HrBuildCriteriaList(IOERule * pIRule, RULEDESCRIPT_LIST ** ppDescriptList,
            ULONG * pcDescriptList, CRIT_LOGIC * plogicCrit);
    BOOL _FChangeCriteriaValue(RULEDESCRIPT_LIST * pCritList);
    BOOL _FBuildCriteriaText(CRIT_TYPE type, DWORD dwFlags, PROPVARIANT * ppropvar, LPSTR * ppszText);
    BOOL _FVerifyCriteria(RULEDESCRIPT_LIST * pDescriptList);
    
    HRESULT _HrBuildActionList(IOERule * pIRule,
            RULEDESCRIPT_LIST ** ppDescriptList, ULONG * pcDescriptList);
    BOOL _FChangeActionValue(RULEDESCRIPT_LIST * pActList);
    BOOL _FBuildActionText(ACT_TYPE type, PROPVARIANT * ppropvar, LPSTR * ppszText);
    BOOL _FVerifyAction(RULEDESCRIPT_LIST * pDescriptList);
    
    void _UpdateRanges(LONG lDiff, ULONG ulStart);
    void _InsertDescription(RULEDESCRIPT_LIST ** ppDescriptList, RULEDESCRIPT_LIST * pDescriptListNew);
    BOOL _FRemoveDescription(RULEDESCRIPT_LIST ** ppDescriptList, ULONG ulIndex,
            RULEDESCRIPT_LIST ** ppDescriptListRemove);
    void _FreeDescriptionList(RULEDESCRIPT_LIST * pDescriptList);

    BOOL _FOnDescriptClick(UINT uiMsg, RULEDESCRIPT_LIST * pDescriptList, BOOL fCrit, BOOL fLogic);
    BOOL _FInLink(int chPos, RULEDESCRIPT_LIST ** ppDescriptList, BOOL * pfCrit, BOOL * pfLogic);
    BOOL _FMoveToLink(UINT uiKeyCode);
    
    static LRESULT CALLBACK _DescriptWndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
    
    // The Change Subject dialog function
    static INT_PTR CALLBACK _FSelectTextDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectAddrDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectAcctDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectColorDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectSizeDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectLinesDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectAgeDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectPriorityDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectSecureDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectThreadStateDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectShowDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectLogicDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectFlagDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectDownloadedDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectReadDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK _FSelectWatchDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\rulesmgr.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  RulesMgr.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "rulesmgr.h"
#include "ruleutil.h"
#include "rule.h"
#include "junkrule.h"
#include <msgfldr.h>
#include <goptions.h>
#include <instance.h>
#include "demand.h"

CRulesManager::CRulesManager() : m_cRef(0), m_dwState(STATE_LOADED_INIT),
                m_pMailHead(NULL), m_pNewsHead(NULL), m_pFilterHead(NULL),
                m_pIRuleSenderMail(NULL),m_pIRuleSenderNews(NULL),
                m_pIRuleJunk(NULL)
{
    // Thread Safety
    InitializeCriticalSection(&m_cs);
}

CRulesManager::~CRulesManager()
{
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");
    if (NULL != m_pMailHead)
    {
        _HrFreeRules(RULE_TYPE_MAIL);
    }

    if (NULL != m_pNewsHead)
    {
        _HrFreeRules(RULE_TYPE_NEWS);
    }

    if (NULL != m_pFilterHead)
    {
        _HrFreeRules(RULE_TYPE_FILTER);
    }

    SafeRelease(m_pIRuleSenderMail);
    SafeRelease(m_pIRuleSenderNews);
    SafeRelease(m_pIRuleJunk);

    // Thread Safety
    DeleteCriticalSection(&m_cs);
}

STDMETHODIMP_(ULONG) CRulesManager::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CRulesManager::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP CRulesManager::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOERulesManager))
    {
        *ppvObject = static_cast<IOERulesManager *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CRulesManager::Initialize(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (0 != dwFlags)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CRulesManager::GetRule(RULEID ridRule, RULE_TYPE type, DWORD dwFlags, IOERule ** ppIRule)
{
    HRESULT     hr = S_OK;
    RULENODE *  pNodeWalk = NULL;
    IOERule *   pIRule = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Check the incoming params
    if (RULEID_INVALID == ridRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the ougoing params
    if (NULL != ppIRule)
    {
        *ppIRule = NULL;
    }

    // Check to see if we already loaded the rules
    hr = _HrLoadRules(type);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Check the special types
    if (RULEID_SENDERS == ridRule)
    {
        if (RULE_TYPE_MAIL == type)
        {
            pIRule = m_pIRuleSenderMail;
        }
        else if (RULE_TYPE_NEWS == type)
        {
            pIRule = m_pIRuleSenderNews;
        }
        else
        {
            hr = E_INVALIDARG;
            goto exit;
        }
    }
    else if (RULEID_JUNK == ridRule)
    {
        
        if (RULE_TYPE_MAIL != type)
        {
            hr = E_INVALIDARG;
            goto exit;
        }

        pIRule = m_pIRuleJunk;
    }
    else
    {
        // Walk the proper list
        if (RULE_TYPE_MAIL == type)
        {
            pNodeWalk = m_pMailHead;
        }
        else if (RULE_TYPE_NEWS == type)

        {
            pNodeWalk = m_pNewsHead;
        }
        else if (RULE_TYPE_FILTER == type)
        {
            pNodeWalk = m_pFilterHead;
        }
        else
        {
            hr = E_INVALIDARG;
            goto exit;
        }

        for (; NULL != pNodeWalk; pNodeWalk = pNodeWalk->pNext)
        {
            if (ridRule == pNodeWalk->ridRule)
            {
                pIRule = pNodeWalk->pIRule;
                break;
            }
        }
    }

    // Did we find something?
    if (NULL == pIRule)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the outgoing param
    if (NULL != ppIRule)
    {
        *ppIRule = pIRule;
        (*ppIRule)->AddRef();
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    return hr;
}

STDMETHODIMP CRulesManager::FindRule(LPCSTR pszRuleName, RULE_TYPE type, IOERule ** ppIRule)
{
    HRESULT     hr = S_OK;
    RULENODE *  pNodeWalk = NULL;
    PROPVARIANT propvar;

    ZeroMemory(&propvar, sizeof(propvar));
    
    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Check the incoming params
    if ((NULL == pszRuleName) || (NULL == ppIRule))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the ougoing params
    *ppIRule = NULL;

    // Check to see if we already loaded the rules
    hr = _HrLoadRules(type);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Walk the proper list
    if (RULE_TYPE_MAIL == type)
    {
        pNodeWalk = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        pNodeWalk = m_pNewsHead;
    }
    else if (RULE_TYPE_FILTER == type)
    {
        pNodeWalk = m_pFilterHead;
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    while (NULL != pNodeWalk)
    {
        // Check to see if the name of the rule is the same
        hr = pNodeWalk->pIRule->GetProp(RULE_PROP_NAME , 0, &propvar);
        if (FAILED(hr))
        {
            continue;
        }

        if (0 == lstrcmpi(propvar.pszVal, pszRuleName))
        {
            *ppIRule = pNodeWalk->pIRule;
            (*ppIRule)->AddRef();
            break;
        }

        // Move to the next one
        PropVariantClear(&propvar);
        pNodeWalk = pNodeWalk->pNext;
    }
    
    // Set the proper return value
    if (NULL == pNodeWalk)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = S_OK;
    }
    
exit:
    PropVariantClear(&propvar);
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    return hr;
}

STDMETHODIMP CRulesManager::GetRules(DWORD dwFlags, RULE_TYPE typeRule, RULEINFO ** ppinfoRule, ULONG * pcpinfoRule)
{
    HRESULT     hr = S_OK;
    ULONG       cpinfoRule = 0;
    RULEINFO *  pinfoRuleAlloc = NULL;
    IOERule *   pIRuleSender = NULL;
    RULENODE *  prnodeList = NULL;
    RULENODE *  prnodeWalk = NULL;
    ULONG       ulIndex = 0;
    
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check the incoming params
    if (NULL == ppinfoRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing param
    *ppinfoRule = NULL;
    if (NULL != pcpinfoRule)
    {
        *pcpinfoRule = 0;
    }

    // Check to see if we already loaded the rules
    hr = _HrLoadRules(typeRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Figure out which type of rules to work on
    switch (typeRule)
    {
        case RULE_TYPE_MAIL:
            prnodeList = m_pMailHead;
            break;

        case RULE_TYPE_NEWS:
            prnodeList = m_pNewsHead;
            break;

        case RULE_TYPE_FILTER:
            prnodeList = m_pFilterHead;
            break;

        default:
            hr = E_INVALIDARG;
            goto exit;
    }
    
    // Count the number of rules
    prnodeWalk = prnodeList;
    for (cpinfoRule = 0; NULL != prnodeWalk; prnodeWalk = prnodeWalk->pNext)
    {
        // Check to see if we should add this item
        if (RULE_TYPE_FILTER == typeRule)
        {
            if (0 != (dwFlags & GETF_POP3))
            {
                if (RULEID_VIEW_DOWNLOADED == prnodeWalk->ridRule)
                {
                    continue;
                }
            }
        }
        
        cpinfoRule++;
    }

    // Allocate space to hold the rules
    if (0 != cpinfoRule)
    {
        hr = HrAlloc((VOID **) &pinfoRuleAlloc, cpinfoRule * sizeof(*pinfoRuleAlloc));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize it to known values
        ZeroMemory(pinfoRuleAlloc, cpinfoRule * sizeof(*pinfoRuleAlloc));

        // Fill up the info
        for (ulIndex = 0, prnodeWalk = prnodeList; NULL != prnodeWalk; prnodeWalk = prnodeWalk->pNext)
        {
            // Check to see if we should add this item
            if (RULE_TYPE_FILTER == typeRule)
            {
                if (0 != (dwFlags & GETF_POP3))
                {
                    if (RULEID_VIEW_DOWNLOADED == prnodeWalk->ridRule)
                    {
                        continue;
                    }
                }
            }
            
            pinfoRuleAlloc[ulIndex].ridRule = prnodeWalk->ridRule;
            
            pinfoRuleAlloc[ulIndex].pIRule = prnodeWalk->pIRule;
            pinfoRuleAlloc[ulIndex].pIRule->AddRef();
            ulIndex++;
        }
    }

    // Set the outgoing values
    *ppinfoRule = pinfoRuleAlloc;
    pinfoRuleAlloc = NULL;
    if (NULL != pcpinfoRule)
    {
        *pcpinfoRule = cpinfoRule;
    }

    // Set the proper return type
    hr = S_OK;
    
exit:
    SafeMemFree(pinfoRuleAlloc);
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    return S_OK;
}

STDMETHODIMP CRulesManager::SetRules(DWORD dwFlags, RULE_TYPE typeRule, RULEINFO * pinfoRule, ULONG cpinfoRule)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;
    IOERule *   pIRuleSender = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Check the incoming params
    if ((NULL == pinfoRule) && (0 != cpinfoRule))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Check to see if we already loaded the rules
    hr = _HrLoadRules(typeRule);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Do we have to free all the current rules
    if (0 != (dwFlags & SETF_SENDER))
    {
        if (RULE_TYPE_MAIL == typeRule)
        {
            SafeRelease(m_pIRuleSenderMail);
            m_pIRuleSenderMail = pinfoRule->pIRule;
            if (NULL != m_pIRuleSenderMail)
            {
                m_pIRuleSenderMail->AddRef();
            }
        }
        else if (RULE_TYPE_NEWS == typeRule)
        {
            SafeRelease(m_pIRuleSenderNews);
            m_pIRuleSenderNews = pinfoRule->pIRule;
            if (NULL != m_pIRuleSenderNews)
            {
                m_pIRuleSenderNews->AddRef();
            }
        }
        else
        {
            hr = E_INVALIDARG;
            goto exit;
        }
    }
    else if (0 != (dwFlags & SETF_JUNK))
    {
        if (RULE_TYPE_MAIL != typeRule)
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        SafeRelease(m_pIRuleJunk);
        m_pIRuleJunk = pinfoRule->pIRule;
        if (NULL != m_pIRuleJunk)
        {
            m_pIRuleJunk->AddRef();
        }
    }
    else
    {
        if (0 != (dwFlags & SETF_CLEAR))
        {
            _HrFreeRules(typeRule);
        }

        // for each new rule
        for (ulIndex = 0; ulIndex < cpinfoRule; ulIndex++)
        {        
            if (0 != (dwFlags & SETF_REPLACE))
            {
                // Add the rule to the list
                hr = _HrReplaceRule(pinfoRule[ulIndex].ridRule, pinfoRule[ulIndex].pIRule, typeRule);
                if (FAILED(hr))
                {
                    goto exit;
                }
            }
            else
            {
                // Add the rule to the list
                hr = _HrAddRule(pinfoRule[ulIndex].ridRule, pinfoRule[ulIndex].pIRule, typeRule);
                if (FAILED(hr))
                {
                    goto exit;
                }
            }
        }
    }
    
    // Save the rules
    hr = _HrSaveRules(typeRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    if ((0 == (dwFlags & SETF_SENDER)) && (0 == (dwFlags & SETF_JUNK)))
    {
        // Fix up the rule ids
        hr = _HrFixupRuleInfo(typeRule, pinfoRule, cpinfoRule);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    return hr;
}

STDMETHODIMP CRulesManager::EnumRules(DWORD dwFlags, RULE_TYPE type, IOEEnumRules ** ppIEnumRules)
{
    HRESULT         hr = S_OK;
    CEnumRules *    pEnumRules = NULL;
    RULENODE        rnode;
    RULENODE *      prnode = NULL;
    IOERule *       pIRuleSender = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Check the incoming params
    if (NULL == ppIEnumRules)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppIEnumRules = NULL;

    // Check to see if we already loaded the rules
    hr = _HrLoadRules(type);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the rules enumerator object
    pEnumRules = new CEnumRules;
    if (NULL == pEnumRules)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the rules enumerator
    if (0 != (dwFlags & ENUMF_SENDER))
    {
        if (RULE_TYPE_MAIL == type)
        {
            pIRuleSender = m_pIRuleSenderMail;
        }
        else if (RULE_TYPE_NEWS == type)
        {
            pIRuleSender = m_pIRuleSenderNews;
        }
        else
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        
        if (NULL != pIRuleSender)
        {
            ZeroMemory(&rnode, sizeof(rnode));

            rnode.pIRule = pIRuleSender;
            prnode = &rnode;
        }
        else
        {
            prnode = NULL;
        }
    }
    else
    {
        if (RULE_TYPE_MAIL == type)
        {
            prnode = m_pMailHead;
        }
        else if (RULE_TYPE_NEWS == type)
        {
            prnode = m_pNewsHead;
        }
        else if (RULE_TYPE_FILTER == type)
        {
            prnode = m_pFilterHead;
        }
        else
        {
            hr = E_INVALIDARG;
            goto exit;
        }
    }

    hr = pEnumRules->_HrInitialize(0, type, prnode);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the rules enumerator interface
    hr = pEnumRules->QueryInterface(IID_IOEEnumRules, (void **) ppIEnumRules);
    if (FAILED(hr))
    {
        goto exit;
    }
    pEnumRules = NULL;

    hr = S_OK;
    
exit:
    if (NULL != pEnumRules)
    {
        delete pEnumRules;
    }
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    return hr;
}

STDMETHODIMP CRulesManager::ExecRules(DWORD dwFlags, RULE_TYPE type, IOEExecRules ** ppIExecRules)
{
    HRESULT         hr = S_OK;
    CExecRules *    pExecRules = NULL;
    RULENODE        rnode;
    RULENODE *      prnodeList = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Check the incoming params
    if (NULL == ppIExecRules)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppIExecRules = NULL;

    // Check to see if we already loaded the rules
    hr = _HrLoadRules(type);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the rules enumerator object
    pExecRules = new CExecRules;
    if (NULL == pExecRules)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (RULE_TYPE_MAIL == type)
    {
        prnodeList = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        prnodeList = m_pNewsHead;
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the rules enumerator
    hr = pExecRules->_HrInitialize(ERF_ONLY_ENABLED | ERF_ONLY_VALID, prnodeList);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the rules enumerator interface
    hr = pExecRules->QueryInterface(IID_IOEExecRules, (void **) ppIExecRules);
    if (FAILED(hr))
    {
        goto exit;
    }
    pExecRules = NULL;

    hr = S_OK;
    
exit:
    if (NULL != pExecRules)
    {
        delete pExecRules;
    }
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    return hr;
}

STDMETHODIMP CRulesManager::ExecuteRules(RULE_TYPE typeRule, DWORD dwFlags, HWND hwndUI, IOEExecRules * pIExecRules,
                    MESSAGEINFO * pMsgInfo, IMessageFolder * pFolder, IMimeMessage * pIMMsg)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;
    RULENODE *  prnodeHead = NULL;
    PROPVARIANT propvar = {0};
    ACT_ITEM *  pActions = NULL;
    ULONG       cActions = 0;
    ACT_ITEM *  pActionsList = NULL;
    ULONG       cActionsList = 0;
    ACT_ITEM *  pActionsNew = NULL;
    ULONG       cActionsNew = 0;
    BOOL        fStopProcessing = FALSE;
    BOOL        fMatch = FALSE;
    
    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Check incoming params
    if ((NULL == pIExecRules) || (NULL == pMsgInfo))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Check to see if we already loaded the rules
    hr = _HrLoadRules(typeRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Figure out which list to use
    switch (typeRule)
    {
        case RULE_TYPE_MAIL:
            prnodeHead = m_pMailHead;
            break;

        case RULE_TYPE_NEWS:
            prnodeHead = m_pNewsHead;
            break;

        default:
            Assert(FALSE);
            hr = E_INVALIDARG;
            goto exit;
    }

    // For each rule
    for (; NULL != prnodeHead; prnodeHead = prnodeHead->pNext)
    {
        // Skip if we don't have a rule
        if (NULL == prnodeHead)
        {
            continue;
        }
        
        // Skip if it isn't enabled
        hr = prnodeHead->pIRule->GetProp(RULE_PROP_DISABLED, 0, &propvar);
        Assert(VT_BOOL == propvar.vt);
        if (FAILED(hr) || (FALSE != propvar.boolVal))
        {
            continue;
        }
        
        // Execute rule
        hr = prnodeHead->pIRule->Evaluate(pMsgInfo->pszAcctId, pMsgInfo, pFolder,
                                NULL, pIMMsg, pMsgInfo->cbMessage, &pActions, &cActions);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Did we have a match
        if (S_OK == hr)
        {
            // We've matched at least once
            fMatch = TRUE;

            // If these are server actions
            if ((1 == cActions) && ((ACT_TYPE_DELETESERVER == pActions[ulIndex].type) ||
                        (ACT_TYPE_DONTDOWNLOAD == pActions[ulIndex].type)))
            {
                // If this is our only action
                if (0 == cActionsList)
                {
                    // Save the action
                    pActionsList = pActions;
                    pActions = NULL;
                    cActionsList = cActions;

                    // We are done
                    fStopProcessing = TRUE;
                }
                else
                {
                    // We already have to do something with it
                    // so skip over this action
                    RuleUtil_HrFreeActionsItem(pActions, cActions);
                    SafeMemFree(pActions);
                    continue;
                }
            }
            else
            {
                // Should we stop after merging these?
                for (ulIndex = 0; ulIndex < cActions; ulIndex++)
                {
                    if (ACT_TYPE_STOP == pActions[ulIndex].type)
                    {
                        fStopProcessing = TRUE;
                        break;
                    }
                }
                
                // Merge these items with the previous ones
                hr = RuleUtil_HrMergeActions(pActionsList, cActionsList, pActions, cActions, &pActionsNew, &cActionsNew);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Free up the previous ones
                RuleUtil_HrFreeActionsItem(pActionsList, cActionsList);
                SafeMemFree(pActionsList);
                RuleUtil_HrFreeActionsItem(pActions, cActions);
                SafeMemFree(pActions);

                // Save off the new ones
                pActionsList = pActionsNew;
                pActionsNew = NULL;
                cActionsList = cActionsNew;
            }

            // Should we continue...
            if (FALSE != fStopProcessing)
            {
                break;
            }
        }
    }

    // Apply the actions if need be
    if ((FALSE != fMatch) && (NULL != pActionsList) && (0 != cActionsList))
    {
        if (FAILED(RuleUtil_HrApplyActions(hwndUI, pIExecRules, pMsgInfo, pFolder, pIMMsg,
                        (RULE_TYPE_MAIL != typeRule) ? DELETE_MESSAGE_NOTRASHCAN : 0, pActionsList, cActionsList, NULL, NULL)))
        {
            hr = E_FAIL;
            goto exit;
        }
    }
    
    // Set the return value
    hr = (FALSE != fMatch) ? S_OK : S_FALSE;
    
exit:
    // Thread Safety
    RuleUtil_HrFreeActionsItem(pActionsNew, cActionsNew);
    SafeMemFree(pActionsNew);
    RuleUtil_HrFreeActionsItem(pActions, cActions);
    SafeMemFree(pActions);
    RuleUtil_HrFreeActionsItem(pActionsList, cActionsList);
    SafeMemFree(pActionsList);
    LeaveCriticalSection(&m_cs);
    return hr;
}

HRESULT CRulesManager::_HrLoadRules(RULE_TYPE type)
{
    HRESULT     hr = S_OK;
    LPCSTR      pszSubKey = NULL;
    LPSTR       pszOrderAlloc = NULL;
    LPSTR       pszOrder = NULL;
    LPSTR       pszWalk = NULL;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    LONG        lErr = 0;
    ULONG       cbData = 0;
    IOERule *   pIRule = NULL;
    DWORD       dwData = 0;
    CHAR        rgchRulePath[MAX_PATH];
    ULONG       cchRulePath = 0;
    PROPVARIANT propvar = {0};
    RULEID      ridRule = RULEID_INVALID;
    CHAR        rgchTagBuff[CCH_INDEX_MAX + 2];

    // Check to see if we're already initialized
    if (RULE_TYPE_MAIL == type)
    {
        if (0 != (m_dwState & STATE_LOADED_MAIL))
        {
            hr = S_FALSE;
            goto exit;
        }

        // Make sure we loaded the sender rules
        _HrLoadSenders();
    
        // Make sure we loaded the junk rule
        if (0 != (g_dwAthenaMode & MODE_JUNKMAIL))
        {
            _HrLoadJunk();
        }
        
        // Set the key path
        pszSubKey = c_szRulesMail;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        if (0 != (m_dwState & STATE_LOADED_NEWS))
        {
            hr = S_FALSE;
            goto exit;
        }
        
        // Make sure we loaded the sender rules
        _HrLoadSenders();
        
        // Set the key path
        pszSubKey = c_szRulesNews;
    }
    else if (RULE_TYPE_FILTER == type)
    {
        if (0 != (m_dwState & STATE_LOADED_FILTERS))
        {
            hr = S_FALSE;
            goto exit;
        }
        
        // Set the key path
        pszSubKey = c_szRulesFilter;
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Check to see if the Rule node already exists
    lErr = AthUserCreateKey(pszSubKey, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Check the current version
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyRoot, c_szRulesVersion, NULL, NULL, (BYTE *) &dwData, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        // Push out the correct rules manager version
        dwData = RULESMGR_VERSION;
        lErr = RegSetValueEx(hkeyRoot, c_szRulesVersion, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));
        if (ERROR_SUCCESS != lErr)
        {
            hr = HRESULT_FROM_WIN32(lErr);
            goto exit;
        }
    }

    Assert(RULESMGR_VERSION == dwData);
    
    // Create the default rules if needed
    hr = RuleUtil_HrUpdateDefaultRules(type);
    if (FAILED(hr))
    {
        goto exit;
    }
        
    // Figure out the size of the order
    lErr = AthUserGetValue(pszSubKey, c_szRulesOrder, NULL, NULL, &cbData);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        hr = E_FAIL;
        goto exit;
    }

    if (ERROR_FILE_NOT_FOUND != lErr)
    {
        // Allocate the space to hold the order
        hr = HrAlloc((void **) &pszOrderAlloc, cbData);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Get the order from the registry
        lErr = AthUserGetValue(pszSubKey, c_szRulesOrder, NULL, (LPBYTE) pszOrderAlloc, &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Build up the rule registry path
        lstrcpy(rgchRulePath, pszSubKey);
        lstrcat(rgchRulePath, g_szBackSlash);
        cchRulePath = lstrlen(rgchRulePath);

        // Initialize the rule tag buffer
        rgchTagBuff[0] = '0';
        rgchTagBuff[1] = 'X';
        
        // Parse the order string to create the rules
        pszOrder = pszOrderAlloc;
        while ('\0' != *pszOrder)
        {
            SafeRelease(pIRule);
            
            // Create a new rule
            hr = HrCreateRule(&pIRule);
            if (FAILED(hr))
            {
                goto exit;
            }

            // Find the name of the new rule
            pszWalk = StrStr(pszOrder, g_szSpace);
            if (NULL != pszWalk)
            {
                *pszWalk = '\0';
                pszWalk++;
            }

            // Build the path to the rule
            lstrcpy(rgchRulePath + cchRulePath, pszOrder);
            
            // Load the rule
            hr = pIRule->LoadReg(rgchRulePath);
            if (SUCCEEDED(hr))
            {
                // Build the correct hex string
                lstrcpy(rgchTagBuff + 2, pszOrder);
                
                // Get the new rule handle
                ridRule = ( ( RULEID  ) 0);
                SideAssert(FALSE != StrToIntEx(rgchTagBuff, STIF_SUPPORT_HEX, (INT *) &ridRule));
                
                // Add the new rule to the manager
                hr = _HrAddRule(ridRule, pIRule, type);
                if (FAILED(hr))
                {
                    goto exit;
                }
            }
            
            // Move to the next item in the order
            if (NULL == pszWalk)
            {
                pszOrder += lstrlen(pszOrder);
            }
            else
            {
                pszOrder = pszWalk;
            }
        }
    }
       
    // We've loaded the rules successfully
    if (RULE_TYPE_MAIL == type)
    {
        m_dwState |= STATE_LOADED_MAIL;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        m_dwState |= STATE_LOADED_NEWS;
    }
    else
    {
        m_dwState |= STATE_LOADED_FILTERS;
    }

    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszOrderAlloc);
    SafeRelease(pIRule);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

HRESULT CRulesManager::_HrLoadSenders(VOID)
{
    HRESULT     hr = S_OK;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    DWORD       dwData = 0;
    LONG        lErr = 0;
    ULONG       cbData = 0;
    IOERule *   pIRule = NULL;
    CHAR        rgchSenderPath[MAX_PATH];

    // Do we have anything to do?
    if (0 != (m_dwState & STATE_LOADED_SENDERS))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Let's get access to the sender root key
    lErr = AthUserCreateKey(c_szSenders, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Are the senders the correct version?
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyRoot, c_szSendersVersion, 0, NULL, (BYTE *) &dwData, &cbData);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        hr = E_FAIL;
        goto exit;
    }
    if (ERROR_FILE_NOT_FOUND == lErr)
    {
        dwData = RULESMGR_VERSION;
        cbData = sizeof(dwData);
        lErr = RegSetValueEx(hkeyRoot, c_szSendersVersion, 0, REG_DWORD, (BYTE *) &dwData, cbData);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }
    }
    
    Assert(dwData == RULESMGR_VERSION);

    // Is there anything to do?
    if (REG_CREATED_NEW_KEY != dwDisp)
    {
        // Create the path to the sender
        lstrcpy(rgchSenderPath, c_szSenders);
        lstrcat(rgchSenderPath, g_szBackSlash);
        lstrcat(rgchSenderPath, c_szMailDir);
        
        // Create the mail sender rule
        hr = RuleUtil_HrLoadSender(rgchSenderPath, 0, &pIRule);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Save the loaded rule
        if (S_OK == hr)
        {
            m_pIRuleSenderMail = pIRule;
            pIRule = NULL;
        }
        
        // Create the path to the sender
        lstrcpy(rgchSenderPath, c_szSenders);
        lstrcat(rgchSenderPath, g_szBackSlash);
        lstrcat(rgchSenderPath, c_szNewsDir);
        
        // Create the news sender rule
        hr = RuleUtil_HrLoadSender(rgchSenderPath, 0, &pIRule);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Save the loaded rule
        if (S_OK == hr)
        {
            m_pIRuleSenderNews = pIRule;
            pIRule = NULL;
        }
    }
    
    // Note that we've loaded the senders
    m_dwState |= STATE_LOADED_SENDERS;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeRelease(pIRule);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

HRESULT CRulesManager::_HrLoadJunk(VOID)
{
    HRESULT     hr = S_OK;
    HKEY        hkeyRoot = NULL;
    DWORD       dwDisp = 0;
    DWORD       dwData = 0;
    ULONG       cbData = 0;
    LONG        lErr = 0;
    IOERule *   pIRule = NULL;

    // Do we have anything to do?
    if (0 != (m_dwState & STATE_LOADED_JUNK))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Let's get access to the Junk mail root key
    lErr = AthUserCreateKey(c_szRulesJunkMail, KEY_ALL_ACCESS, &hkeyRoot, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Is the junk mail the correct version?
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyRoot, c_szRulesVersion, 0, NULL, (BYTE *) &dwData, &cbData);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        hr = E_FAIL;
        goto exit;
    }
    if (ERROR_FILE_NOT_FOUND == lErr)
    {
        dwData = RULESMGR_VERSION;
        cbData = sizeof(dwData);
        lErr = RegSetValueEx(hkeyRoot, c_szRulesVersion, 0, REG_DWORD, (BYTE *) &dwData, cbData);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }
    }
    
    Assert(dwData == RULESMGR_VERSION);

    // Create the rule
    hr = HrCreateJunkRule(&pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Load the junk rule
    hr = pIRule->LoadReg(c_szRulesJunkMail);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    m_pIRuleJunk = pIRule;
    pIRule = NULL;
    
    // Note that we've loaded the junk rule
    m_dwState |= STATE_LOADED_JUNK;
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeRelease(pIRule);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

HRESULT CRulesManager::_HrSaveRules(RULE_TYPE type)
{
    HRESULT     hr = S_OK;
    LPCSTR      pszRegPath = NULL;
    DWORD       dwData = 0;
    LONG        lErr = 0;
    RULENODE *  pRuleNode = NULL;
    RULENODE *  pNodeWalk = NULL;
    ULONG       cpIRule = 0;
    LPSTR       pszOrder = NULL;
    HKEY        hkeyRoot = NULL;
    DWORD       dwIndex = 0;
    CHAR        rgchOrder[CCH_INDEX_MAX];
    ULONG       cchOrder = 0;
    CHAR        rgchRulePath[MAX_PATH];
    ULONG       cchRulePath = 0;
    BOOL        fNewRule = FALSE;
    ULONG       ulRuleID = 0;
    HKEY        hkeyDummy = NULL;
    LONG        cSubKeys = 0;

    // Make sure we loaded the sender rules
    _HrSaveSenders();
    
    // Make sure we loaded the junk rules
    if (0 != (g_dwAthenaMode & MODE_JUNKMAIL))
    {
        _HrSaveJunk();
    }
    
    // Check to see if we have anything to save
    if (RULE_TYPE_MAIL == type)
    {
        if (0 == (m_dwState & STATE_LOADED_MAIL))
        {
            hr = S_FALSE;
            goto exit;
        }

        // Set the key path
        pszRegPath = c_szRulesMail;

        pRuleNode = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        if (0 == (m_dwState & STATE_LOADED_NEWS))
        {
            hr = S_FALSE;
            goto exit;
        }
        
        // Set the key path
        pszRegPath = c_szRulesNews;

        pRuleNode = m_pNewsHead;
    }
    else if (RULE_TYPE_FILTER == type)
    {
        if (0 == (m_dwState & STATE_LOADED_FILTERS))
        {
            hr = S_FALSE;
            goto exit;
        }
        
        // Set the key path
        pszRegPath = c_szRulesFilter;

        pRuleNode = m_pFilterHead;
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    lErr = AthUserCreateKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot, &dwData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Save out the rules version
    dwData = RULESMGR_VERSION;
    lErr = RegSetValueEx(hkeyRoot, c_szRulesVersion, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Get the number of rules
    cpIRule = 0;
    for (pNodeWalk = pRuleNode; NULL != pNodeWalk; pNodeWalk = pNodeWalk->pNext)
    {
        cpIRule++;
    }

    // Allocate space to hold the order
    hr = HrAlloc((void **) &pszOrder, (cpIRule * CCH_INDEX_MAX) + 1);
    if (FAILED(hr))
    {
        goto exit;
    }

    pszOrder[0] = '\0';

    // Delete all the old rules
    lErr = SHQueryInfoKey(hkeyRoot, (LPDWORD) (&cSubKeys), NULL, NULL, NULL);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Delete all the old rules
    for (cSubKeys--; cSubKeys >= 0; cSubKeys--)
    {
        cchOrder = sizeof(rgchOrder);
        lErr = SHEnumKeyEx(hkeyRoot, cSubKeys, rgchOrder, &cchOrder);
        
        if (ERROR_NO_MORE_ITEMS == lErr)
        {
            break;
        }

        if (ERROR_SUCCESS != lErr)
        {
            continue;
        }

        SHDeleteKey(hkeyRoot, rgchOrder);
    }

    // Delete the old order string
    RegDeleteValue(hkeyRoot, c_szRulesOrder);
    
    // Build up the rule registry path
    lstrcpy(rgchRulePath, pszRegPath);
    lstrcat(rgchRulePath, g_szBackSlash);
    cchRulePath = lstrlen(rgchRulePath);
    
    // Write out the rules with good tags
    for (dwIndex = 0, pNodeWalk = pRuleNode; NULL != pNodeWalk; pNodeWalk = pNodeWalk->pNext, dwIndex++)
    {        
        if (RULEID_INVALID == pNodeWalk->ridRule)
        {
            fNewRule = TRUE;
            continue;
        }
        
        // Get a new index from the order
        wsprintf(rgchOrder, "%03X", pNodeWalk->ridRule);
        
        // Build the path to the rule
        lstrcpy(rgchRulePath + cchRulePath, rgchOrder);
            
        // Save the rule
        hr = pNodeWalk->pIRule->SaveReg(rgchRulePath, TRUE);
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // Fill in the new tags
    if (FALSE != fNewRule)
    {
        ulRuleID = 0;
        
        // Write out the updated rule
        for (dwIndex = 0, pNodeWalk = pRuleNode; NULL != pNodeWalk; pNodeWalk = pNodeWalk->pNext, dwIndex++)
        {        
            if (RULEID_INVALID != pNodeWalk->ridRule)
            {
                continue;
            }

            // Find the first open entry
            for (; ulRuleID < PtrToUlong(RULEID_JUNK); ulRuleID++)
            {
                // Get a new index from the order
                wsprintf(rgchOrder, "%03X", ulRuleID);
                
                lErr = RegOpenKeyEx(hkeyRoot, rgchOrder, 0, KEY_READ, &hkeyDummy);
                if (ERROR_SUCCESS == lErr)
                {
                    RegCloseKey(hkeyDummy);
                }
                else 
                {
                    break;
                }
            }

            if (ERROR_FILE_NOT_FOUND != lErr)
            {
                hr = E_FAIL;
                goto exit;
            }

            // Set the rule tag
            pNodeWalk->ridRule = (RULEID) IntToPtr(ulRuleID);

            // Build the path to the rule
            lstrcpy(rgchRulePath + cchRulePath, rgchOrder);
            
            // Save the rule
            hr = pNodeWalk->pIRule->SaveReg(rgchRulePath, TRUE);
            if (FAILED(hr))
            {
                goto exit;
            }
        }
    }
    
    //  Write out the new order string
    for (dwIndex = 0, pNodeWalk = pRuleNode; NULL != pNodeWalk; pNodeWalk = pNodeWalk->pNext, dwIndex++)
    {        
        // Get a new index from the order
        wsprintf(rgchOrder, "%03X", pNodeWalk->ridRule);
        
        // Add rule to the order
        if ('\0' != pszOrder[0])
        {
            lstrcat(pszOrder, g_szSpace);
        }
        lstrcat(pszOrder, rgchOrder);
    }

    // Save the order string
    if (ERROR_SUCCESS != AthUserSetValue(pszRegPath, c_szRulesOrder, REG_SZ, (CONST BYTE *) pszOrder, lstrlen(pszOrder) + 1))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszOrder);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

HRESULT CRulesManager::_HrSaveSenders(VOID)
{
    HRESULT     hr = S_OK;
    DWORD       dwData = 0;
    LONG        lErr = 0;
    HKEY        hkeyRoot = NULL;
    DWORD       dwIndex = 0;
    CHAR        rgchSenderPath[MAX_PATH];

    // Check to see if we have anything to save
    if (0 == (m_dwState & STATE_LOADED_SENDERS))
    {
        hr = S_FALSE;
        goto exit;
    }

    lErr = AthUserCreateKey(c_szSenders, KEY_ALL_ACCESS, &hkeyRoot, &dwData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Save out the senders version
    dwData = RULESMGR_VERSION;
    lErr = RegSetValueEx(hkeyRoot, c_szSendersVersion, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Delete the old sender list
    SHDeleteKey(hkeyRoot, c_szMailDir);
    
    // Build up the sender registry path
    lstrcpy(rgchSenderPath, c_szSenders);
    lstrcat(rgchSenderPath, g_szBackSlash);
    lstrcat(rgchSenderPath, c_szMailDir);
    
    // Save the rule
    if (NULL != m_pIRuleSenderMail)
    {
        hr = m_pIRuleSenderMail->SaveReg(rgchSenderPath, TRUE);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Delete the old sender list
    SHDeleteKey(hkeyRoot, c_szNewsDir);
    
    // Build up the sender registry path
    lstrcpy(rgchSenderPath, c_szSenders);
    lstrcat(rgchSenderPath, g_szBackSlash);
    lstrcat(rgchSenderPath, c_szNewsDir);
    
    // Save the rule
    if (NULL != m_pIRuleSenderNews)
    {
        hr = m_pIRuleSenderNews->SaveReg(rgchSenderPath, TRUE);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

HRESULT CRulesManager::_HrSaveJunk(VOID)
{
    HRESULT     hr = S_OK;
    DWORD       dwData = 0;
    LONG        lErr = 0;
    HKEY        hkeyRoot = NULL;
    DWORD       dwIndex = 0;
    CHAR        rgchSenderPath[MAX_PATH];

    // Check to see if we have anything to save
    if (0 == (m_dwState & STATE_LOADED_JUNK))
    {
        hr = S_FALSE;
        goto exit;
    }

    lErr = AthUserCreateKey(c_szRulesJunkMail, KEY_ALL_ACCESS, &hkeyRoot, &dwData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Save out the senders version
    dwData = RULESMGR_VERSION;
    lErr = RegSetValueEx(hkeyRoot, c_szRulesVersion, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));
    if (ERROR_SUCCESS != lErr)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Save the rule
    if (NULL != m_pIRuleJunk)
    {
        hr = m_pIRuleJunk->SaveReg(c_szRulesJunkMail, TRUE);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
        
    // Set the return value
    hr = S_OK;
    
exit:
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

HRESULT CRulesManager::_HrFreeRules(RULE_TYPE type)
{
    HRESULT     hr = S_OK;
    RULENODE *  pNodeWalk = NULL;
    RULENODE *  pNodeNext = NULL;

    // Initialize the params
    if (RULE_TYPE_MAIL == type)
    {
        pNodeWalk = m_pMailHead;
        pNodeNext = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        pNodeWalk = m_pNewsHead;
        pNodeNext = m_pNewsHead;
    }
    else if (RULE_TYPE_FILTER == type)
    {
        pNodeWalk = m_pFilterHead;
        pNodeNext = m_pFilterHead;
    }
    else
    {
        hr = E_FAIL;
        goto exit;
    }

    // Walk the list and free each item
    while (NULL != pNodeWalk)
    {
        // Save off the next item
        pNodeNext = pNodeWalk->pNext;

        // Release the rule
        AssertSz(NULL != pNodeWalk->pIRule, "Where the heck is the rule???");
        pNodeWalk->pIRule->Release();
        
        // Free up the node
        delete pNodeWalk;

        // Move to the next item
        pNodeWalk = pNodeNext;
    }

    // Clear out the list head
    if (RULE_TYPE_MAIL == type)
    {
        m_pMailHead = NULL;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        m_pNewsHead = NULL;
    }
    else
    {
        m_pFilterHead = NULL;
    }

exit:
    // Set the return param
    return hr;
}

HRESULT CRulesManager::_HrAddRule(RULEID ridRule, IOERule * pIRule, RULE_TYPE type)
{
    HRESULT     hr = S_OK;
    RULENODE *  pRuleNode = NULL;
    RULENODE *  pNodeWalk = NULL;
    
    // Check incoming params
    if (NULL == pIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create a new rule node
    pRuleNode = new RULENODE;
    if (NULL == pRuleNode)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the node
    pRuleNode->pNext = NULL;
    pRuleNode->ridRule = ridRule;
    pRuleNode->pIRule = pIRule;
    pRuleNode->pIRule->AddRef();

    // Add the node to the proper list
    if (RULE_TYPE_MAIL == type)
    {
        pNodeWalk = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        pNodeWalk = m_pNewsHead;
    }
    else
    {
        pNodeWalk = m_pFilterHead;
    }

    if (NULL == pNodeWalk)
    {
        if (RULE_TYPE_MAIL == type)
        {
            m_pMailHead = pRuleNode;
        }
        else if (RULE_TYPE_NEWS == type)
        {
            m_pNewsHead = pRuleNode;
        }
        else
        {
            m_pFilterHead = pRuleNode;
        }
        pRuleNode = NULL;
    }
    else
    {
        while (NULL != pNodeWalk->pNext)
        {
            pNodeWalk = pNodeWalk->pNext;
        }

        pNodeWalk->pNext = pRuleNode;
        pRuleNode = NULL;
    }

    // Set return values
    hr = S_OK;
    
exit:
    if (NULL != pRuleNode)
    {
        pRuleNode->pIRule->Release();
        delete pRuleNode;
    }
    return hr;
}

HRESULT CRulesManager::_HrReplaceRule(RULEID ridRule, IOERule * pIRule, RULE_TYPE type)
{
    HRESULT     hr = S_OK;
    RULENODE *  pNodeWalk = NULL;
    RULENODE *  pNodePrev = NULL;

    // Nothing to do if we don't have a rule
    if (NULL == pIRule)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Initialize the params
    if (RULE_TYPE_MAIL == type)
    {
        pNodeWalk = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        pNodeWalk = m_pNewsHead;
    }
    else
    {
        pNodeWalk = m_pFilterHead;
    }

    // Walk the list and free each item
    for (; NULL != pNodeWalk; pNodeWalk = pNodeWalk->pNext)
    {
        if (pNodeWalk->ridRule == ridRule)
        {
            // We found it
            break;
        }
    }

    // Couldn't find the rule in the list
    if (NULL == pNodeWalk)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Replace the rule
    SafeRelease(pNodeWalk->pIRule);
    pNodeWalk->pIRule = pIRule;
    pNodeWalk->pIRule->AddRef();

    // Set the return param
    hr = S_OK;
    
exit:
    return hr;
}

HRESULT CRulesManager::_HrRemoveRule(IOERule * pIRule, RULE_TYPE type)
{
    HRESULT     hr = S_OK;
    RULENODE *  pNodeWalk = NULL;
    RULENODE *  pNodePrev = NULL;

    // Initialize the params
    if (RULE_TYPE_MAIL == type)
    {
        pNodeWalk = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == type)
    {
        pNodeWalk = m_pNewsHead;
    }
    else
    {
        pNodeWalk = m_pFilterHead;
    }

    // Walk the list and free each item
    pNodePrev = NULL;
    while (NULL != pNodeWalk)
    {
        if (pNodeWalk->pIRule == pIRule)
        {
            // We found it
            break;
        }
        
        // Save off the next item
        pNodePrev = pNodeWalk;

        // Move to the next item
        pNodeWalk = pNodeWalk->pNext;
    }

    // Couldn't find the rule in the list
    if (NULL == pNodeWalk)
    {
        hr = E_FAIL;
        goto exit;
    }

    if (NULL == pNodePrev)
    {
        // Clear out the list head
        if (RULE_TYPE_MAIL == type)
        {
            m_pMailHead = pNodeWalk->pNext;
        }
        else if (RULE_TYPE_NEWS == type)
        {
            m_pNewsHead = pNodeWalk->pNext;
        }
        else
        {
            m_pFilterHead = pNodeWalk->pNext;
        }
    }
    else
    {
        pNodePrev->pNext = pNodeWalk->pNext;
    }
    
    // Free up the node
    pNodeWalk->pIRule->Release();
    pNodeWalk->pNext = NULL;
    delete pNodeWalk;

    // Set the return param
    hr = S_OK;
    
exit:
    return hr;
}

HRESULT CRulesManager::_HrFixupRuleInfo(RULE_TYPE typeRule, RULEINFO * pinfoRule, ULONG cpinfoRule)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;
    RULENODE *  pNodeHead = NULL;
    RULENODE *  pNodeWalk = NULL;

    // Check incoming args
    if ((NULL == pinfoRule) && (0 != cpinfoRule))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Walk the proper list
    if (RULE_TYPE_MAIL == typeRule)
    {
        pNodeHead = m_pMailHead;
    }
    else if (RULE_TYPE_NEWS == typeRule)
    {
        pNodeHead = m_pNewsHead;
    }
    else if (RULE_TYPE_FILTER == typeRule)
    {
        pNodeHead = m_pFilterHead;
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Search the rule info list for an unknown ruleid
    for (ulIndex = 0; ulIndex < cpinfoRule; ulIndex++)
    {
        // If the rule id is invalid try to find it
        if (RULEID_INVALID == pinfoRule[ulIndex].ridRule)
        {
            
            for (pNodeWalk = pNodeHead; NULL != pNodeWalk; pNodeWalk = pNodeWalk->pNext)
            {
                // Check to see if the rule is the same
                if (pNodeWalk->pIRule == pinfoRule[ulIndex].pIRule)
                {
                    pinfoRule[ulIndex].ridRule = pNodeWalk->ridRule;
                    break;
                }
            }

            if (NULL == pNodeWalk)
            {
                hr = E_FAIL;
                goto exit;
            }
        }
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

CEnumRules::CEnumRules()
{
    m_cRef = 0;
    m_pNodeHead = NULL;
    m_pNodeCurr = NULL;
    m_dwFlags = 0;
    m_typeRule = RULE_TYPE_MAIL;
}

CEnumRules::~CEnumRules()
{
    RULENODE *  pNodeNext = NULL;
    
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");
    
    // Walk the list and free each item
    while (NULL != m_pNodeHead)
    {
        // Save off the next item
        pNodeNext = m_pNodeHead->pNext;

        // Release the rule
        AssertSz(NULL != m_pNodeHead->pIRule, "Where the heck is the rule???");
        m_pNodeHead->pIRule->Release();
        
        // Free up the node
        delete m_pNodeHead;

        // Move to the next item
        m_pNodeHead = pNodeNext;
    }

}

STDMETHODIMP_(ULONG) CEnumRules::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CEnumRules::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP CEnumRules::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOEEnumRules))
    {
        *ppvObject = static_cast<IOEEnumRules *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CEnumRules::Next(ULONG cpIRule, IOERule ** rgpIRule, ULONG * pcpIRuleFetched)
{
    HRESULT     hr = S_OK;
    ULONG       cpIRuleRet = 0;

    // Check incoming params
    if (NULL == rgpIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *rgpIRule = NULL;
    if (NULL != pcpIRuleFetched)
    {
        *pcpIRuleFetched = 0;
    }

    // If we're at the end then just return
    if (NULL == m_pNodeCurr)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    for (cpIRuleRet = 0; cpIRuleRet < cpIRule; cpIRuleRet++)
    {
        rgpIRule[cpIRuleRet] = m_pNodeCurr->pIRule;
        (rgpIRule[cpIRuleRet])->AddRef();
        
        m_pNodeCurr = m_pNodeCurr->pNext;

        if (NULL == m_pNodeCurr)
        {
            cpIRuleRet++;
            break;
        }
    }

    // Set outgoing params
    if (NULL != pcpIRuleFetched)
    {
        *pcpIRuleFetched = cpIRuleRet;
    }

    // Set return value
    hr = (cpIRuleRet == cpIRule) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

STDMETHODIMP CEnumRules::Skip(ULONG cpIRule)
{
    HRESULT     hr = S_OK;
    ULONG       cpIRuleWalk = 0;

    for (cpIRuleWalk = 0; cpIRuleWalk < cpIRule; cpIRuleWalk++)
    {
        if (NULL == m_pNodeCurr)
        {
            break;
        }

        m_pNodeCurr = m_pNodeCurr->pNext;
    }

    hr = (cpIRuleWalk == cpIRule) ? S_OK : S_FALSE;
    return hr;
}

STDMETHODIMP CEnumRules::Reset(void)
{
    HRESULT     hr = S_OK;

    m_pNodeCurr = m_pNodeHead;
    
    return hr;
}

STDMETHODIMP CEnumRules::Clone(IOEEnumRules ** ppIEnumRules)
{
    HRESULT         hr = S_OK;
    CEnumRules *    pEnumRules = NULL;

    // Check incoming params
    if (NULL == ppIEnumRules)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppIEnumRules = NULL;

    pEnumRules = new CEnumRules;
    if (NULL == pEnumRules)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the rules enumerator
    hr = pEnumRules->_HrInitialize(m_dwFlags, m_typeRule, m_pNodeHead);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the state of the new one to match the current one
    pEnumRules->m_pNodeCurr = m_pNodeHead;
    
    // Get the rules enumerator interface
    hr = pEnumRules->QueryInterface(IID_IOEEnumRules, (void **) ppIEnumRules);
    if (FAILED(hr))
    {
        goto exit;
    }
    pEnumRules = NULL;

    hr = S_OK;
    
exit:
    if (NULL != pEnumRules)
    {
        delete pEnumRules;
    }
    return hr;
}

HRESULT CEnumRules::_HrInitialize(DWORD dwFlags, RULE_TYPE typeRule, RULENODE * pNodeHead)
{
    HRESULT     hr = S_OK;
    RULENODE *  pNodeNew = NULL;
    RULENODE *  pNodeWalk = NULL;

    if (NULL == pNodeHead)
    {
        hr = S_FALSE;
        goto exit;
    }

    m_dwFlags = dwFlags;
    m_typeRule = typeRule;
    
    for (pNodeWalk = m_pNodeHead; NULL != pNodeHead; pNodeHead = pNodeHead->pNext)
    {
        // Check to see if we should add this item
        if (RULE_TYPE_FILTER == m_typeRule)
        {
            if (0 != (dwFlags & ENUMF_POP3))
            {
                if (RULEID_VIEW_DOWNLOADED == pNodeHead->ridRule)
                {
                    continue;
                }
            }
        }
        
        pNodeNew = new RULENODE;
        if (NULL == pNodeNew)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        // Initialize new node
        pNodeNew->pNext = NULL;
        pNodeNew->pIRule = pNodeHead->pIRule;
        pNodeNew->pIRule->AddRef();

        // Add the new node to the list
        if (NULL == pNodeWalk)
        {
            m_pNodeHead = pNodeNew;
            pNodeWalk = pNodeNew;
        }
        else
        {
            pNodeWalk->pNext = pNodeNew;
            pNodeWalk = pNodeNew;
        }
        pNodeNew = NULL;
    }

    // Set the current to the front of the chain
    m_pNodeCurr = m_pNodeHead;
    
    // Set return value
    hr = S_OK;
    
exit:
    if (pNodeNew)
        delete pNodeNew;
    return hr;
}

// The Rule Executor object
CExecRules::~CExecRules()
{
    RULENODE *  pNodeNext = NULL;
    
    AssertSz(m_cRef == 0, "Somebody still has a hold of us!!");
    
    // Walk the list and free each item
    while (NULL != m_pNodeHead)
    {
        // Save off the next item
        pNodeNext = m_pNodeHead->pNext;

        // Release the rule
        AssertSz(NULL != m_pNodeHead->pIRule, "Where the heck is the rule???");
        m_pNodeHead->pIRule->Release();
        
        // Free up the node
        delete m_pNodeHead;

        // Move to the next item
        m_pNodeHead = pNodeNext;
    }

    // Free up the cached objects
    _HrReleaseFolderObjects();
    _HrReleaseFileObjects();
    _HrReleaseSoundFiles();

    // Free the folder list
    SafeMemFree(m_pRuleFolder);
    m_cRuleFolderAlloc = 0;

    // Free the file list
    SafeMemFree(m_pRuleFile);
    m_cRuleFileAlloc = 0;
    
    // Free the file list
    SafeMemFree(m_ppszSndFile);
    m_cpszSndFileAlloc = 0;
}

STDMETHODIMP_(ULONG) CExecRules::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CExecRules::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP CExecRules::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOEExecRules))
    {
        *ppvObject = static_cast<IOEExecRules *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CExecRules::GetState(DWORD * pdwState)
{
    HRESULT hr = S_OK;
    
    // Check incoming params
    if (NULL == pdwState)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *pdwState = m_dwState;

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CExecRules::ExecuteRules(DWORD dwFlags, LPCSTR pszAcct, MESSAGEINFO * pMsgInfo,
                                    IMessageFolder * pFolder, IMimePropertySet * pIMPropSet,
                                    IMimeMessage * pIMMsg, ULONG cbMsgSize,
                                    ACT_ITEM ** ppActions, ULONG * pcActions)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;
    RULENODE *  pNodeWalk = NULL;
    ACT_ITEM *  pActions = NULL;
    ULONG       cActions = 0;
    ACT_ITEM *  pActionsList = NULL;
    ULONG       cActionsList = 0;
    ACT_ITEM *  pActionsNew = NULL;
    ULONG       cActionsNew = 0;
    BOOL        fStopProcessing = FALSE;
    BOOL        fMatch = FALSE;
    DWORD       dwState = 0;

    // Check incoming params
    if (((NULL == pMsgInfo) && (NULL == pIMPropSet)) ||
                    (0 == cbMsgSize) || (NULL == ppActions) || (NULL == pcActions))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppActions = NULL;
    *pcActions = 0;
    
    // Should we skip partial messages?
    if ((NULL != pIMPropSet) &&
                (S_OK == pIMPropSet->IsContentType(STR_CNT_MESSAGE, STR_SUB_PARTIAL)) &&
                (0 != (dwFlags & ERF_SKIPPARTIALS)))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Walk the list of rules executing each one
    pNodeWalk = m_pNodeHead;
    while (NULL != pNodeWalk)
    {
        Assert(NULL != pNodeWalk->pIRule);
        
        // If we are only checking server rules
        // Bail if we need more information...
        if (0 != (dwFlags & ERF_ONLYSERVER))
        {
            hr = pNodeWalk->pIRule->GetState(&dwState);
            if (FAILED(hr))
            {
                goto exit;
            }

            // Do we need more information...
            if (0 != (dwState & CRIT_STATE_ALL))
            {
                hr = S_FALSE;
                break;
            }
        }
        
        // Evaluate the rule
        hr = pNodeWalk->pIRule->Evaluate(pszAcct, pMsgInfo, pFolder, pIMPropSet, pIMMsg, cbMsgSize, &pActions, &cActions);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Did we have a match
        if (S_OK == hr)
        {
            // We've matched at least once
            fMatch = TRUE;
            ulIndex = 0;

            // If these are server actions
            if ((1 == cActions) && ((ACT_TYPE_DELETESERVER == pActions[ulIndex].type) ||
                        (ACT_TYPE_DONTDOWNLOAD == pActions[ulIndex].type)))
            {
                // If this is our only action
                if (0 == cActionsList)
                {
                    // Save the action
                    pActionsList = pActions;
                    pActions = NULL;
                    cActionsList = cActions;

                    // We are done
                    fStopProcessing = TRUE;
                }
                else
                {
                    // We already have to do something with it
                    // so skip over this action
                    RuleUtil_HrFreeActionsItem(pActions, cActions);
                    SafeMemFree(pActions);

                    // Move to the next rule
                    pNodeWalk = pNodeWalk->pNext;
                    continue;
                }
            }
            else
            {
                // Should we stop after merging these?
                for (ulIndex = 0; ulIndex < cActions; ulIndex++)
                {
                    if (ACT_TYPE_STOP == pActions[ulIndex].type)
                    {
                        fStopProcessing = TRUE;
                        break;
                    }
                }
                
                // Merge these items with the previous ones
                hr = RuleUtil_HrMergeActions(pActionsList, cActionsList, pActions, cActions, &pActionsNew, &cActionsNew);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Free up the previous ones
                RuleUtil_HrFreeActionsItem(pActionsList, cActionsList);
                SafeMemFree(pActionsList);
                RuleUtil_HrFreeActionsItem(pActions, cActions);
                SafeMemFree(pActions);

                // Save off the new ones
                pActionsList = pActionsNew;
                pActionsNew = NULL;
                cActionsList = cActionsNew;
            }
            
            // Should we continue...
            if (FALSE != fStopProcessing)
            {
                break;
            }
        }

        // Move to the next rule
        pNodeWalk = pNodeWalk->pNext;
    }
    
    // Set outgoing param
    *ppActions = pActionsList;
    pActionsList = NULL;
    *pcActions = cActionsList;
    
    // Set the return value
    hr = (FALSE != fMatch) ? S_OK : S_FALSE;
    
exit:
    RuleUtil_HrFreeActionsItem(pActionsNew, cActionsNew);
    SafeMemFree(pActionsNew);
    RuleUtil_HrFreeActionsItem(pActions, cActions);
    SafeMemFree(pActions);
    RuleUtil_HrFreeActionsItem(pActionsList, cActionsList);
    SafeMemFree(pActionsList);
    return hr;
}

STDMETHODIMP CExecRules::ReleaseObjects(VOID)
{
    // Free up the folders
    _HrReleaseFolderObjects();

    // Free up the files
    _HrReleaseFileObjects();

    // Free up the sound files
    _HrReleaseSoundFiles();
    
    return S_OK;
}

STDMETHODIMP CExecRules::GetRuleFolder(FOLDERID idFolder, DWORD_PTR * pdwFolder)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    RULE_FOLDER *        pRuleFolderWalk = NULL;
    IMessageFolder     *pFolder = NULL;
    
    // Check incoming param
    if ((FOLDERID_INVALID == idFolder) || (NULL == pdwFolder))
    {
        hr =E_INVALIDARG;
        goto exit;
    }
    
    // Initialize outgoing param
    *pdwFolder = NULL;

    // Let's search for the folder
    for (ulIndex = 0; ulIndex < m_cRuleFolder; ulIndex++)
    {
        pRuleFolderWalk = &(m_pRuleFolder[ulIndex]);
        if (idFolder == pRuleFolderWalk->idFolder)
        {
            Assert(NULL != pRuleFolderWalk->pFolder);
            break;
        }
    }

    // If we didn't find it then let's open it and lock it...
    if (ulIndex >= m_cRuleFolder)
    {
        // Do we need to alloc any more spaces
        if (m_cRuleFolder >= m_cRuleFolderAlloc)
        {
            hr = HrRealloc((LPVOID *) &m_pRuleFolder, sizeof(*m_pRuleFolder) * (m_cRuleFolderAlloc + RULE_FOLDER_ALLOC));
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Initialize the new rule folders
            ZeroMemory(m_pRuleFolder + m_cRuleFolderAlloc, sizeof(*m_pRuleFolder) * RULE_FOLDER_ALLOC);
            for (ulIndex = m_cRuleFolderAlloc; ulIndex < (m_cRuleFolderAlloc + RULE_FOLDER_ALLOC); ulIndex++)
            {
                m_pRuleFolder[ulIndex].idFolder = FOLDERID_INVALID;
            }
            m_cRuleFolderAlloc += RULE_FOLDER_ALLOC;
        }

        // Open the folder
        hr = g_pStore->OpenFolder(idFolder, NULL, NOFLAGS, &pFolder);
        if (FAILED(hr))
        {
            goto exit;
        }

        m_pRuleFolder[m_cRuleFolder].idFolder = idFolder;
        m_pRuleFolder[m_cRuleFolder].pFolder = pFolder;
        pFolder = NULL;
        pRuleFolderWalk = &(m_pRuleFolder[m_cRuleFolder]);
        m_cRuleFolder++;
    }
        
    *pdwFolder = (DWORD_PTR) (pRuleFolderWalk->pFolder);

    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pFolder)
        pFolder->Release();
    return hr;
}

STDMETHODIMP CExecRules::GetRuleFile(LPCSTR pszFile, IStream ** ppstmFile, DWORD * pdwType)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    RULE_FILE *         pRuleFileWalk = NULL;
    IStream *           pIStmFile = NULL;
    LPSTR               pszExt = NULL;
    DWORD               dwType = RFT_FILE;
    
    // Check incoming param
    if ((NULL == pszFile) || (NULL == ppstmFile) || (NULL == pdwType))
    {
        hr =E_INVALIDARG;
        goto exit;
    }
    
    // Initialize outgoing param
    *ppstmFile = NULL;
    *pdwType = NULL;

    // Let's search for the file
    for (ulIndex = 0; ulIndex < m_cRuleFile; ulIndex++)
    {
        pRuleFileWalk = &(m_pRuleFile[ulIndex]);
        if (0 == lstrcmpi(pRuleFileWalk->pszFile, pszFile))
        {
            Assert(NULL != pRuleFileWalk->pstmFile);
            break;
        }
    }

    // If we didn't find it then let's open it...
    if (ulIndex >= m_cRuleFile)
    {
        // Do we need to alloc any more space
        if (m_cRuleFile >= m_cRuleFileAlloc)
        {
            hr = HrRealloc((LPVOID *) &m_pRuleFile, sizeof(*m_pRuleFile) * (m_cRuleFileAlloc + RULE_FILE_ALLOC));
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Initialize the new rule file
            ZeroMemory(m_pRuleFile + m_cRuleFileAlloc, sizeof(*m_pRuleFile) * RULE_FILE_ALLOC);
            m_cRuleFileAlloc += RULE_FILE_ALLOC;
        }

        // Open a stream on the file
        hr = CreateStreamOnHFile((LPTSTR) pszFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
                                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL, &pIStmFile);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Lets split the file name and get the extension
        pszExt = PathFindExtension(pszFile);
        if ((0 == lstrcmpi(pszExt, c_szHtmExt)) || (0 == lstrcmpi(pszExt, c_szHtmlExt)))
        {
            dwType = RFT_HTML;
        }
        // Text File...
        else if (0 == lstrcmpi(pszExt, c_szTxtExt))
        {
            dwType = RFT_TEXT;
        }
        // Else .nws or .eml file...
        else if ((0 == lstrcmpi(pszExt, c_szEmlExt)) || (0 == lstrcmpi(pszExt, c_szNwsExt)))
        {
            dwType = RFT_MESSAGE;
        }
        // Otherwise, its an attachment
        else
        {
            dwType = RFT_FILE;
        }
        
        // Save off the info
        m_pRuleFile[m_cRuleFile].pszFile = PszDupA(pszFile);
        if (NULL == m_pRuleFile[m_cRuleFile].pszFile)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        
        m_pRuleFile[m_cRuleFile].pstmFile = pIStmFile;
        pIStmFile = NULL;
        m_pRuleFile[m_cRuleFile].dwType = dwType;
        
        pRuleFileWalk = &(m_pRuleFile[m_cRuleFile]);
        m_cRuleFile++;
    }
        
    *ppstmFile = pRuleFileWalk->pstmFile;
    (*ppstmFile)->AddRef();
    *pdwType = pRuleFileWalk->dwType;

    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeRelease(pIStmFile);
    return hr;
}

STDMETHODIMP CExecRules::AddSoundFile(DWORD dwFlags, LPCSTR pszSndFile)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    
    // Check incoming param
    if (NULL == pszSndFile)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Let's search for the file
    for (ulIndex = 0; ulIndex < m_cpszSndFile; ulIndex++)
    {
        Assert(NULL != m_ppszSndFile[ulIndex]);
        if (0 == lstrcmpi(m_ppszSndFile[ulIndex], pszSndFile))
        {
            break;
        }
    }

    // If we didn't find it then let's open it...
    if (ulIndex >= m_cpszSndFile)
    {
        // Do we need to alloc any more space
        if (m_cpszSndFile >= m_cpszSndFileAlloc)
        {
            hr = HrRealloc((LPVOID *) &m_ppszSndFile, sizeof(*m_ppszSndFile) * (m_cpszSndFileAlloc + SND_FILE_ALLOC));
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Initialize the new rule file
            ZeroMemory(m_ppszSndFile + m_cpszSndFileAlloc, sizeof(*m_ppszSndFile) * SND_FILE_ALLOC);
            m_cpszSndFileAlloc += SND_FILE_ALLOC;
        }

        // Save off the info
        m_ppszSndFile[m_cpszSndFile] = PszDupA(pszSndFile);
        if (NULL == m_ppszSndFile[m_cpszSndFile])
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        
        // Should we play it?
        if (0 != (dwFlags & ASF_PLAYIFNEW))
        {
            sndPlaySound(m_ppszSndFile[m_cpszSndFile], SND_NODEFAULT | SND_SYNC);
        }
        
        m_cpszSndFile++;

    }
        
    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CExecRules::PlaySounds(DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;

    // Let's search for the file
    for (ulIndex = 0; ulIndex < m_cpszSndFile; ulIndex++)
    {
        Assert(NULL != m_ppszSndFile[ulIndex]);
        sndPlaySound(m_ppszSndFile[ulIndex], SND_NODEFAULT | SND_SYNC);
    }

    return hr;
}

HRESULT CExecRules::_HrReleaseFolderObjects(VOID)
{
    RULE_FOLDER *    pRuleFolder = NULL;
    ULONG           ulIndex = 0;

    for (ulIndex = 0; ulIndex < m_cRuleFolder; ulIndex++)
    {
        pRuleFolder = &(m_pRuleFolder[ulIndex]);
        
        Assert(FOLDERID_INVALID != pRuleFolder->idFolder);
        
        // If we have the folder opened then close it
        SafeRelease(pRuleFolder->pFolder);

        // Reset the folder list
        pRuleFolder->idFolder = FOLDERID_INVALID;
    }

    // Let's clear out the number of messages
    m_cRuleFolder = 0;

    return S_OK;
}

HRESULT CExecRules::_HrReleaseFileObjects(VOID)
{
    RULE_FILE *     pRuleFile = NULL;
    ULONG           ulIndex = 0;

    for (ulIndex = 0; ulIndex < m_cRuleFile; ulIndex++)
    {
        pRuleFile = &(m_pRuleFile[ulIndex]);
        
        Assert(NULL != pRuleFile->pszFile);
        
        // If we have the file opened then close it
        SafeRelease(pRuleFile->pstmFile);

        // Clear the file
        SafeMemFree(pRuleFile->pszFile);
        pRuleFile->dwType = RFT_FILE;
    }

    // Let's clear out the number of file
    m_cRuleFile = 0;

    return S_OK;
}

HRESULT CExecRules::_HrReleaseSoundFiles(VOID)
{
    ULONG           ulIndex = 0;

    for (ulIndex = 0; ulIndex < m_cpszSndFile; ulIndex++)
    {
        Assert(NULL != m_ppszSndFile[ulIndex]);
        
        // Clear the file
        SafeMemFree(m_ppszSndFile[ulIndex]);
    }

    // Let's clear out the number of file
    m_cpszSndFile = 0;

    return S_OK;
}

HRESULT CExecRules::_HrInitialize(DWORD dwFlags, RULENODE * pNodeHead)
{
    HRESULT     hr = S_OK;
    RULENODE *  pNodeNew = NULL;
    RULENODE *  pNodeWalk = NULL;
    DWORD       dwState = 0;
    PROPVARIANT propvar;

    if (NULL == pNodeHead)
    {
        hr = S_FALSE;
        goto exit;
    }  
    
    for (pNodeWalk = m_pNodeHead; NULL != pNodeHead; pNodeHead = pNodeHead->pNext)
    {
        // Skip rules that are disabled
        if (0 != (dwFlags & ERF_ONLY_ENABLED))
        {
            hr = pNodeHead->pIRule->GetProp(RULE_PROP_DISABLED, 0, &propvar);
            Assert(VT_BOOL == propvar.vt);
            if (FAILED(hr) || (FALSE != propvar.boolVal))
            {
                continue;
            }
        }
        
        // Skip rules that are invalid
        if (0 != (dwFlags & ERF_ONLY_VALID))
        {
            hr = pNodeHead->pIRule->Validate(dwFlags);
            if (FAILED(hr) || (S_FALSE == hr))
            {
                continue;
            }
        }
        
        pNodeNew = new RULENODE;
        if (NULL == pNodeNew)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        // Initialize new node
        pNodeNew->pNext = NULL;
        pNodeNew->pIRule = pNodeHead->pIRule;
        pNodeNew->pIRule->AddRef();

        // Add the new node to the list
        if (NULL == pNodeWalk)
        {
            m_pNodeHead = pNodeNew;
            pNodeWalk = pNodeNew;
        }
        else
        {
            pNodeWalk->pNext = pNodeNew;
            pNodeWalk = pNodeNew;
        }
        pNodeNew = NULL;

        // Calculate state from message
        if (SUCCEEDED(pNodeWalk->pIRule->GetState(&dwState)))
        {
            // Let's set the proper Criteria state
            if ((m_dwState & CRIT_STATE_MASK) < (dwState & CRIT_STATE_MASK))
            {
                m_dwState = (m_dwState & ~CRIT_STATE_MASK) | (dwState & CRIT_STATE_MASK);
            }
            
            // Let's set the proper Action state
            if (0 != (dwState & ACT_STATE_MASK))
            {
                m_dwState |= (dwState & ACT_STATE_MASK);
            }
        }        
    }
    
    // Set return value
    hr = S_OK;
    
exit:
    if (pNodeNew)
        delete pNodeNew;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\ruledesc.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  RuleDesc.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "ruledesc.h"
#include "editrule.h"
#include "ruleutil.h"
#include <rulesdlg.h>
#include <newfldr.h>
#include <richedit.h>
#include <fontnsc.h>
#include <wabdefs.h>
#include <mimeolep.h>
#include <xpcomm.h>
#include "reutil.h"
#include "shlwapip.h"
#include <demand.h>

typedef struct tagSELECTADDR
{
    LONG            lRecipType;
    UINT            uidsWell;
    LPWSTR          pwszAddr;
} SELECTADDR, * PSELECTADDR;

typedef struct tagSELECTACCT
{
    RULE_TYPE       typeRule;
    LPSTR           pszAcct;
} SELECTACCT, * PSELECTACCT;


class CEditLogicUI
{
  private:
    enum
    {
        STATE_UNINIT        = 0x00000000,
        STATE_INITIALIZED   = 0x00000001,
        STATE_DIRTY         = 0x00000002
    };

  private:
    HWND                m_hwndOwner;
    DWORD               m_dwFlags;
    DWORD               m_dwState;
    HWND                m_hwndDlg;
    RULE_TYPE           m_typeRule;
    HWND                m_hwndDescript;
    IOERule *           m_pIRule;
    CRuleDescriptUI *   m_pDescriptUI;
    
  public:
    CEditLogicUI();
    ~CEditLogicUI();

    // The main UI methods
    HRESULT HrInit(HWND hwndOwner, DWORD dwFlags, RULE_TYPE typeRule, IOERule * pIRule);
    HRESULT HrShow(void);
            
    // The Rules Manager dialog function
    static INT_PTR CALLBACK FEditLogicDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);    

    // Message handling functions
    BOOL FOnInitDialog(HWND hwndDlg);
    BOOL FOnOK(void);
    BOOL FOnLogicChange(HWND hwndName);

};

// Constants
static const int c_cCritItemGrow = 16;
static const int c_cActItemGrow = 16;
  
static const int PUI_WORDS  = 0x00000001;
                       
HRESULT _HrCriteriaEditPeople(HWND hwnd, CRIT_ITEM * pCritItem);
HRESULT _HrCriteriaEditWords(HWND hwnd, CRIT_ITEM * pCritItem);

CRuleDescriptUI::CRuleDescriptUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
            m_typeRule(RULE_TYPE_MAIL),
            m_pDescriptListCrit(NULL), m_cDescriptListCrit(0),
            m_pDescriptListAct(NULL), m_cDescriptListAct(0),
            m_hfont(NULL), m_wpcOld(NULL), m_logicCrit(CRIT_LOGIC_AND),
            m_fErrorLogic(FALSE)
{
}

CRuleDescriptUI::~CRuleDescriptUI()
{
    _FreeDescriptionList(m_pDescriptListCrit);
    m_pDescriptListCrit = NULL;
    m_cDescriptListCrit = 0;
    
    _FreeDescriptionList(m_pDescriptListAct);
    m_pDescriptListAct = NULL;
    m_cDescriptListAct = 0;
    
    if ((NULL != m_hwndOwner) && (FALSE != IsWindow(m_hwndOwner)) && (NULL != m_wpcOld))
    {
        SetWindowLongPtr(m_hwndOwner, GWLP_WNDPROC, (LONG_PTR) m_wpcOld);
        m_wpcOld = NULL;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes us with the owner window and any flags we might have
//
//  hwndOwner   - handle to the owner window
//  dwFlags     - flags to use for this instance
//  typeRule    - the type of rule editor to create
//
//  Returns:    S_OK
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT         hr = S_OK;
    
    // If we're already initialized, then fail
    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Save off the owner window
    m_hwndOwner = hwndOwner;
    
    // Make sure we set the correct font into the control
    m_hfont = HGetSystemFont(FNT_SYS_ICON);
    if (NULL != m_hfont)
    {
        SetFontOnRichEdit(m_hwndOwner, m_hfont);
    }

    // Save off the flags
    m_dwFlags = dwFlags;

    if (0 != (m_dwFlags & RDF_READONLY))
    {
        m_dwState |= STATE_READONLY;
    }
    
    // Subclass the original dialog
    if ((NULL != m_hwndOwner) && (0 == (m_dwFlags & RDF_READONLY)))
    {
        // Save off the object pointer
        SetWindowLongPtr(m_hwndOwner, GWLP_USERDATA, (LONG_PTR) this);
        
        m_wpcOld = (WNDPROC) SetWindowLongPtr(m_hwndOwner, GWLP_WNDPROC, (LONG_PTR) CRuleDescriptUI::_DescriptWndProc);
    }
    
    // We're done
    m_dwState |= STATE_INITIALIZED;

    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrSetRule
//
//  This initializes us with the owner window and any flags we might have
//
//  hwndOwner   - handle to the owner window
//  dwFlags     - flags to use for this instance
//  typeRule    - the type of rule editor to create
//
//  Returns:    S_OK
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::HrSetRule(RULE_TYPE typeRule, IOERule * pIRule)
{
    HRESULT             hr = S_OK;
    RULEDESCRIPT_LIST * pDescriptListCrit = NULL;
    ULONG               cDescriptListCrit = 0;
    CRIT_LOGIC          logicCrit = CRIT_LOGIC_AND;
    RULEDESCRIPT_LIST * pDescriptListAct = NULL;
    ULONG               cDescriptListAct = 0;
    BOOL                fDisabled = FALSE;
    PROPVARIANT         propvar = {0};
    
    // Are we in a good state?
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_FAIL;
        goto exit;
    }

    if (NULL != pIRule)
    {
        // Create the criteria list
        hr = _HrBuildCriteriaList(pIRule, &pDescriptListCrit, &cDescriptListCrit, &logicCrit);
        if (FAILED(hr))
        {
            goto exit;
        }
        
        // Create the actions list
        hr = _HrBuildActionList(pIRule, &pDescriptListAct, &cDescriptListAct);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Get the enabled state
        if (SUCCEEDED(pIRule->GetProp(RULE_PROP_DISABLED, 0, &propvar)))
        {
            Assert(VT_BOOL == propvar.vt);
            fDisabled = propvar.boolVal;
        }
    }

    m_typeRule = typeRule;
    
    _FreeDescriptionList(m_pDescriptListCrit);
    m_pDescriptListCrit = pDescriptListCrit;
    pDescriptListCrit = NULL;
    m_cDescriptListCrit = cDescriptListCrit;
    
    m_logicCrit = logicCrit;
    m_fErrorLogic = FALSE;
    
    _FreeDescriptionList(m_pDescriptListAct);
    m_pDescriptListAct = pDescriptListAct;
    pDescriptListAct = NULL;
    m_cDescriptListAct = cDescriptListAct;

    // Make sure we verify the rule
    HrVerifyRule();
    
    // Clear the dirty state
    m_dwState &= ~STATE_DIRTY;
    
    // Set the rule state
    if (NULL != pIRule)
    {
        m_dwState |= STATE_HASRULE;
    }
    else
    {
        m_dwState &= ~STATE_HASRULE;
    }
    if (FALSE == fDisabled)
    {
        m_dwState |= STATE_ENABLED;
    }
    else
    {
        m_dwState &= ~STATE_ENABLED;
    }
    
    hr = S_OK;
    
exit:
    _FreeDescriptionList(pDescriptListCrit);
    _FreeDescriptionList(pDescriptListAct);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrVerifyRule
//
//  This verifies the rule string
//
//  Returns:    S_OK, if the rule state is valid
//              S_FALSE, if the rule state is invalid
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::HrVerifyRule(void)
{
    HRESULT             hr = S_OK;
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    BOOL                fBad = FALSE;

    // If we have nothing, then the rule is still in error
    if ((NULL == m_pDescriptListCrit) && (NULL == m_pDescriptListAct))
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Validate the logic operation
    if (1 < m_cDescriptListCrit)
    {
        m_fErrorLogic = (CRIT_LOGIC_NULL == m_logicCrit);
        if (FALSE != m_fErrorLogic)
        {
            fBad = TRUE;
        }
    }

    // Validate the criteria
    for (pDescriptListWalk = m_pDescriptListCrit;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        pDescriptListWalk->fError = !_FVerifyCriteria(pDescriptListWalk);
        if (FALSE != pDescriptListWalk->fError)
        {
            fBad = TRUE;
        }
    }
    
    // Build up the actions
    for (pDescriptListWalk = m_pDescriptListAct;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        pDescriptListWalk->fError = !_FVerifyAction(pDescriptListWalk);
        if (FALSE != pDescriptListWalk->fError)
        {
            fBad = TRUE;
        }
    }

    // Set the correct return value
    hr = (FALSE == fBad) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrEnableCriteria
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::HrEnableCriteria(CRIT_TYPE type, BOOL fEnable)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    RULEDESCRIPT_LIST * pDescriptListAlloc = NULL;

    // Find the index of the criteria
    for (ulIndex = 0; ulIndex < ARRAYSIZE(c_rgEditCritList); ulIndex++)
    {
        if (type == c_rgEditCritList[ulIndex].typeCrit)
        {
            break;
        }
    }

    // Did we find the criteria item?
    if (ulIndex >= ARRAYSIZE(c_rgEditCritList))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Are we trying to remove the item
    if (FALSE == fEnable)
    {

        if (FALSE == _FRemoveDescription(&m_pDescriptListCrit, ulIndex, &pDescriptListAlloc))
        {
            hr = E_FAIL;
            goto exit;
        }
        
        // Free up the description
        pDescriptListAlloc->pNext = NULL;
        _FreeDescriptionList(pDescriptListAlloc);
        m_cDescriptListCrit--;
    }
    else
    {
        // Create the description list
        hr = HrAlloc((VOID **) &pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize the description list
        ZeroMemory(pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));

        // Save of the criteria type info
        pDescriptListAlloc->ulIndex = ulIndex;

        _InsertDescription(&m_pDescriptListCrit, pDescriptListAlloc);
        m_cDescriptListCrit++;
    }
            
    m_dwState |= STATE_DIRTY;
    
    ShowDescriptionString();
    
    hr = S_OK;

exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrEnableActions
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::HrEnableActions(ACT_TYPE type, BOOL fEnable)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    RULEDESCRIPT_LIST * pDescriptListAlloc = NULL;

    // Find the index of the actions
    for (ulIndex = 0; ulIndex < ARRAYSIZE(c_rgEditActList); ulIndex++)
    {
        if (type == c_rgEditActList[ulIndex].typeAct)
        {
            break;
        }
    }

    // Did we find the action item?
    if (ulIndex >= ARRAYSIZE(c_rgEditActList))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Are we trying to remove the item
    if (FALSE == fEnable)
    {
        if (FALSE == _FRemoveDescription(&m_pDescriptListAct, ulIndex, &pDescriptListAlloc))
        {
            hr = E_FAIL;
            goto exit;
        }
        
        // Free up the description
        pDescriptListAlloc->pNext = NULL;
        _FreeDescriptionList(pDescriptListAlloc);
        m_cDescriptListAct--;
    }
    else
    {
        // Create the description list
        hr = HrAlloc((VOID **) &pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize the description list
        ZeroMemory(pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));

        // Save of the actions type info
        pDescriptListAlloc->ulIndex = ulIndex;

        _InsertDescription(&m_pDescriptListAct, pDescriptListAlloc);
        m_cDescriptListAct++;
    }
            
    m_dwState |= STATE_DIRTY;
    
    ShowDescriptionString();
    
    hr = S_OK;

exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrGetCriteria
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::HrGetCriteria(CRIT_ITEM ** ppCritList, ULONG * pcCritList)
{
    HRESULT             hr = S_OK;
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    CRIT_ITEM *         pCritItem = NULL;
    ULONG               cCritItem = 0;
    ULONG               cCritItemAlloc = 0;

    if (NULL == ppCritList)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *ppCritList = NULL;
    if (NULL != pcCritList)
    {
        *pcCritList = 0;
    }

    // If we don't have any criteria then return
    if (NULL == m_pDescriptListCrit)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    for (pDescriptListWalk = m_pDescriptListCrit;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        // Do we need more room?
        if (cCritItem == cCritItemAlloc)
        {
            if (FAILED(HrRealloc((void **) &pCritItem,
                            sizeof(*pCritItem) * (cCritItemAlloc + c_cCritItemGrow))))
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            ZeroMemory(pCritItem + cCritItemAlloc, sizeof(*pCritItem) * c_cCritItemGrow);
            cCritItemAlloc += c_cCritItemGrow;
        }

        // Set the criteria type
        pCritItem[cCritItem].type = c_rgEditCritList[pDescriptListWalk->ulIndex].typeCrit;
        
        // Set the flags
        pCritItem[cCritItem].dwFlags = pDescriptListWalk->dwFlags;

        if (VT_EMPTY != pDescriptListWalk->propvar.vt)
        {
            if (FAILED(PropVariantCopy(&(pCritItem[cCritItem].propvar), &(pDescriptListWalk->propvar))))
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }

        // Set the logic operator 
        if (0 != cCritItem)
        {
            pCritItem[cCritItem - 1].logic = m_logicCrit;
        }

        // Move to the next item
        cCritItem++;
    }

    *ppCritList = pCritItem;
    pCritItem = NULL;
    
    if (NULL != pcCritList)
    {
        *pcCritList = cCritItem;
    }
    
    hr = S_OK;
    
exit:
    RuleUtil_HrFreeCriteriaItem(pCritItem, cCritItem);
    SafeMemFree(pCritItem);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrGetActions
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::HrGetActions(ACT_ITEM ** ppActList, ULONG * pcActList)
{
    HRESULT             hr = S_OK;
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    ACT_ITEM *          pActItem = NULL;
    ULONG               cActItem = 0;
    ULONG               cActItemAlloc = 0;

    if (NULL == ppActList)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *ppActList = NULL;
    if (NULL != pcActList)
    {
        *pcActList = 0;
    }

    // If we don't have any criteria then return
    if (NULL == m_pDescriptListAct)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    for (pDescriptListWalk = m_pDescriptListAct;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        // Do we need more room?
        if (cActItem == cActItemAlloc)
        {
            if (FAILED(HrRealloc((void **) &pActItem,
                            sizeof(*pActItem) * (cActItemAlloc + c_cActItemGrow))))
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            ZeroMemory(pActItem + cActItemAlloc, sizeof(*pActItem) * c_cActItemGrow);
            cActItemAlloc += c_cActItemGrow;
        }

        // Set the action type
        pActItem[cActItem].type = c_rgEditActList[pDescriptListWalk->ulIndex].typeAct;
        
        // Set the flags
        pActItem[cActItem].dwFlags = pDescriptListWalk->dwFlags;
        
        if (VT_EMPTY != pDescriptListWalk->propvar.vt)
        {
            if (FAILED(PropVariantCopy(&(pActItem[cActItem].propvar), &(pDescriptListWalk->propvar))))
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }
        
        // Move to the next item
        cActItem++;
    }

    *ppActList = pActItem;
    pActItem = NULL;
    
    if (NULL != pcActList)
    {
        *pcActList = cActItem;
    }
    
    hr = S_OK;
    
exit:
    RuleUtil_HrFreeActionsItem(pActItem, cActItem);
    SafeMemFree(pActItem);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  ShowDescriptionString
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
void CRuleDescriptUI::ShowDescriptionString(VOID)
{
    WCHAR               wszRes[CCHMAX_STRINGRES + 3];
    ULONG               cchRes = 0;
    BOOL                fError = FALSE;
    CHARFORMAT          chFmt = {0};
    PARAFORMAT          paraFmt = {0};
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    BOOL                fFirst = FALSE;
    UINT                uiText = 0;
    BOOL                fErrorFwdSec = FALSE;
    CHARRANGE           chrg = {0};
    
    Assert(NULL != m_hwndOwner);

    // Let's clear the redraw state to reduce flicker.
    SendMessage(m_hwndOwner, WM_SETREDRAW, 0, 0);
    
    // Clear text
    SetRichEditText(m_hwndOwner, NULL, FALSE, NULL, TRUE);
    
    // Set default CHARFORMAT
    chFmt.cbSize = sizeof(chFmt);
    chFmt.dwMask = CFM_BOLD | CFM_UNDERLINE | CFM_COLOR;
    chFmt.dwEffects = CFE_AUTOCOLOR;
    SendMessage(m_hwndOwner, EM_SETCHARFORMAT, (WPARAM)SCF_ALL, (LPARAM)&chFmt);

    paraFmt.cbSize = sizeof(paraFmt);
    paraFmt.dwMask = PFM_ALIGNMENT;
    
    if (0 == (m_dwState & STATE_HASRULE))
    {

        // Set up the empty string paragraph style
        paraFmt.wAlignment = PFA_CENTER;

        uiText = (RULE_TYPE_FILTER != m_typeRule) ? 
                    idsRulesDescriptionEmpty : 
                    idsViewDescriptionEmpty;
    }
    else
    {
        paraFmt.wAlignment = PFA_LEFT;

        // Determine if the rule is in error
        if (m_fErrorLogic)
        {
            fError = TRUE;
        }
        
        if (!fError)
        {
            // Walk the criteria looking for errors
            for (pDescriptListWalk = m_pDescriptListCrit;
                        pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
            {
                if (pDescriptListWalk->fError)
                {
                    fError = TRUE;
                    break;
                }
            }
        }
        
        if (!fError)
        {
            // Walk the actions looking for errors
            for (pDescriptListWalk = m_pDescriptListAct;
                        pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
            {
                if (pDescriptListWalk->fError)
                {
                    // Note that we are in error
                    fError = TRUE;

                    // Is we have a FWD action
                    if (ACT_TYPE_FWD == c_rgEditActList[pDescriptListWalk->ulIndex].typeAct)
                    {
                        // If security is turned then note it
                        if ((0 != DwGetOption(OPT_MAIL_DIGSIGNMESSAGES)) || (0 != DwGetOption(OPT_MAIL_ENCRYPTMESSAGES)))
                        {
                            fErrorFwdSec = TRUE;
                        }
                        break;
                    }
                }
            }
        }
    
        if (fError)
        {
            uiText = fErrorFwdSec ? idsRulesErrorFwdHeader : idsRulesErrorHeader;
        }
        else if (0 != (m_dwFlags & RDF_APPLYDLG))
        {
            uiText = idsRulesApplyHeader;
        }
        else if (RULE_TYPE_FILTER != m_typeRule)
        {
            uiText = (0 != (m_dwState & STATE_ENABLED)) ? idsRuleHeader : idsRulesOffHeader;
        }
    }
    
    // Set default PARAFORMAT
    SendMessage(m_hwndOwner, EM_SETPARAFORMAT, 0, (LPARAM)&paraFmt);

    // Load help text
    wszRes[0] = L'\0';
    cchRes = LoadStringWrapW(g_hLocRes, uiText, wszRes, ARRAYSIZE(wszRes));

    // If error, make sure help text is bolded
    if (fError)
    {
        chFmt.dwMask = CFM_BOLD;
        chFmt.dwEffects = CFE_BOLD;
    }

    // Set help text into the richedit control
    RuleUtil_AppendRichEditText(m_hwndOwner, 0, wszRes, &chFmt);
    
    // Build up the criteria
    fFirst = TRUE;
    for (pDescriptListWalk = m_pDescriptListCrit;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        if (0 != (pDescriptListWalk->dwFlags & CRIT_FLAG_INVERT))
        {
            uiText = c_rgEditCritList[pDescriptListWalk->ulIndex].uiTextAlt;
        }
        else
        {
            uiText = c_rgEditCritList[pDescriptListWalk->ulIndex].uiText;
        }
        
        _ShowLinkedString(uiText, pDescriptListWalk, fFirst, TRUE);
        fFirst = FALSE;

        // Only need to do this once for the block sender rule
        if (CRIT_TYPE_SENDER == c_rgEditCritList[pDescriptListWalk->ulIndex].typeCrit)
        {
            break;
        }
    }
    
    // Build up the actions
    fFirst = TRUE;
    for (pDescriptListWalk = m_pDescriptListAct;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        if (0 != (pDescriptListWalk->dwFlags & ACT_FLAG_INVERT))
        {
            uiText = c_rgEditActList[pDescriptListWalk->ulIndex].uiTextAlt;
        }
        else
        {
            uiText = c_rgEditActList[pDescriptListWalk->ulIndex].uiText;
        }
        
        _ShowLinkedString(uiText, pDescriptListWalk, fFirst, FALSE);
        fFirst = FALSE;
    }

    // Restore the selection
    RichEditExSetSel(m_hwndOwner, &chrg);
    
    // Let's set back the redraw state and invalidate the rect to
    // get the string drawn
    SendMessage(m_hwndOwner, WM_SETREDRAW, 1, 0);
    InvalidateRect(m_hwndOwner, NULL, TRUE);
    
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _ShowLinkedString
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
void CRuleDescriptUI::_ShowLinkedString(ULONG ulText, RULEDESCRIPT_LIST * pDescriptListWalk,
            BOOL fFirst, BOOL fCrit)
{
    HRESULT             hr = S_OK;
    WCHAR               wszRes[CCHMAX_STRINGRES + 2];
    ULONG               uiStrId = 0;
    ULONG               cchText = 0;
    CHARFORMAT          chFmt = {0};
    CHARRANGE           chrg = {0};
    LPWSTR              lpwsz = NULL;

    if ((0 == ulText) || (NULL == pDescriptListWalk))
    {
        Assert(FALSE);
        goto exit;
    }

    // Figure out where we're supposed to start
    cchText = GetRichEditTextLen(m_hwndOwner);

    // So richedit 2 and 3 need to have each beginning line
    // have the default charformat reset. It actually only matters
    // if you are showing both criteria and actions. In that case, if
    // this isn't done, then the default charformat might be incorretly
    // set to one of the other charformats that have been used. So, there
    // is obviously something amiss here, but I can't figure
    // it out, this is what we use to do, and this works.
    // See raid 78472 in IE/OE 5.0 database
    chrg.cpMin = cchText;
    chrg.cpMax = cchText;
    RichEditExSetSel(m_hwndOwner, &chrg);

    // Set default CHARFORMAT
    chFmt.cbSize = sizeof(chFmt);
    chFmt.dwMask = CFM_BOLD | CFM_UNDERLINE | CFM_COLOR;
    chFmt.dwEffects = CFE_AUTOCOLOR;
    SendMessage(m_hwndOwner, EM_SETCHARFORMAT, (WPARAM)SCF_SELECTION, (LPARAM)&chFmt);

    // Should we use a logical op?
    if (!fFirst)
    {
        // Which string should we load?
        if (fCrit)
        {
            if (CRIT_LOGIC_AND == m_logicCrit)
            {
                uiStrId = idsCriteriaAnd;
            }
            else if (CRIT_LOGIC_OR == m_logicCrit)
            {
                uiStrId =  idsCriteriaOr;
            }
            else
            {
                uiStrId =  idsCriteriaAndOr;
            }
        }
        else
        {
            uiStrId = idsActionsAnd;
        }
        
        wszRes[0] = L'\0';
        if (0 == LoadStringWrapW(g_hLocRes, uiStrId, wszRes, ARRAYSIZE(wszRes)))
        {
            goto exit;
        }

        // Write out the linked logic string
        IF_FAILEXIT(hr = RuleUtil_HrShowLinkedString(m_hwndOwner, m_fErrorLogic,
                    (0 != (m_dwState & STATE_READONLY)), wszRes, NULL, cchText,
                    &(pDescriptListWalk->ulStartLogic), &(pDescriptListWalk->ulEndLogic), &cchText));
    }

    // Get the description string
    wszRes[0] = L'\0';
    if (0 == LoadStringWrapW(g_hLocRes, ulText, wszRes, ARRAYSIZE(wszRes)))
    {
        goto exit;
    }

    // Write out the linked string
    if(pDescriptListWalk->pszText)
        IF_NULLEXIT(lpwsz = PszToUnicode(CP_ACP, pDescriptListWalk->pszText));

    IF_FAILEXIT(hr = RuleUtil_HrShowLinkedString(m_hwndOwner, pDescriptListWalk->fError,
                (0 != (m_dwState & STATE_READONLY)), wszRes, lpwsz,
                cchText, &(pDescriptListWalk->ulStart), &(pDescriptListWalk->ulEnd), &cchText));
    
    // Hack for HyperLinks to work without having to measure text (was broken for BiDi)
    RuleUtil_AppendRichEditText(m_hwndOwner, cchText, g_wszSpace, NULL);
    // Terminate the string
    RuleUtil_AppendRichEditText(m_hwndOwner, cchText + 1, g_wszCRLF, NULL);    
    
exit:
    MemFree(lpwsz);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FChangeLogicValue
//
//  This changes the value of the logic op
//
//  Returns:    TRUE, if the criteria value was changed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FChangeLogicValue(RULEDESCRIPT_LIST * pDescriptList)
{
    BOOL            fRet = FALSE;
    int             iRet = 0;
    CRIT_LOGIC      logicCrit = CRIT_LOGIC_NULL;
    
    // Bring up the choose logic op dialog
    if (NULL != m_logicCrit)
    {
        logicCrit = m_logicCrit;
    }
    
    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaLogic),
                                        m_hwndOwner,  _FSelectLogicDlgProc,
                                        (LPARAM) &logicCrit);

    fRet = (iRet == IDOK);

    // Update the description field if neccessary
    if (FALSE != fRet)
    {            
        m_logicCrit = logicCrit;

        // ZIFF
        // Can we be sure we are really OK??
        m_fErrorLogic = FALSE;
        
        ShowDescriptionString();
    }
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FBuildCriteriaList
//
//  This builds the criteria list
//
//  Returns:    TRUE, if the criteria list was created
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::_HrBuildCriteriaList(IOERule * pIRule,
            RULEDESCRIPT_LIST ** ppDescriptList, ULONG * pcDescriptList,
            CRIT_LOGIC * plogicCrit)
{
    HRESULT             hr = S_OK;
    PROPVARIANT         propvar = {0};
    CRIT_ITEM *         pCritItem = NULL;
    ULONG               cCritItem = 0;
    ULONG               ulIndex = 0;
    RULEDESCRIPT_LIST * pDescriptList = NULL;
    ULONG               ulList = 0;
    ULONG               cDescriptList = 0;
    RULEDESCRIPT_LIST * pDescriptListAlloc = NULL;
    LPSTR               pszText = NULL;
    CRIT_LOGIC          logicCrit = CRIT_LOGIC_NULL;
    
    Assert((NULL != pIRule) && (NULL != ppDescriptList) &&
                    (NULL != pcDescriptList) && (NULL != plogicCrit));

    // Initialize the outgoing param
    *ppDescriptList = NULL;
    *pcDescriptList = 0;
    *plogicCrit = CRIT_LOGIC_AND;
    
    // Get the list of criteria
    hr = pIRule->GetProp(RULE_PROP_CRITERIA, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Do we have anything to do?
    if (0 == propvar.blob.cbSize)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Grab the criteria list
    Assert(NULL != propvar.blob.pBlobData);
    cCritItem = propvar.blob.cbSize / sizeof(CRIT_ITEM);
    pCritItem = (CRIT_ITEM *) (propvar.blob.pBlobData);
    propvar.blob.pBlobData = NULL;
    propvar.blob.cbSize = 0;

    // For each criteria, add it to the description list
    for (ulIndex = 0; ulIndex < cCritItem; ulIndex++)
    {
        // Create the description list
        hr = HrAlloc((VOID **) &pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize the description list
        ZeroMemory(pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));

        // Search for the criteria type
        for (ulList = 0; ulList < ARRAYSIZE(c_rgEditCritList); ulList++)
        {
            if (pCritItem[ulIndex].type == c_rgEditCritList[ulList].typeCrit)
            {
                // Save of the criteria type info
                pDescriptListAlloc->ulIndex = ulList;

                // Save off the flags
                pDescriptListAlloc->dwFlags = pCritItem[ulIndex].dwFlags;

                // Do we have any data?
                if (VT_EMPTY != pCritItem[ulIndex].propvar.vt)
                {
                    // Copy the data
                    SideAssert(SUCCEEDED(PropVariantCopy(&propvar, &(pCritItem[ulIndex].propvar))));
                    pDescriptListAlloc->propvar = propvar;
                    ZeroMemory(&propvar, sizeof(propvar));

                    // Build up the description text
                    if (FALSE != _FBuildCriteriaText(pCritItem[ulIndex].type, pDescriptListAlloc->dwFlags,
                                            &(pDescriptListAlloc->propvar), &pszText))
                    {
                        // Save off the string
                        pDescriptListAlloc->pszText = pszText;
                        pszText = NULL;
                    }

                }

                // We're done searching
                break;
            }
        }

        // Did we find anything?
        if (ulList >= ARRAYSIZE(c_rgEditCritList))
        {
            // Free up the description
            _FreeDescriptionList(pDescriptListAlloc);
        }
        else
        {
            // Save the rule description
            _InsertDescription(&pDescriptList, pDescriptListAlloc);
            pDescriptListAlloc = NULL;                           
            cDescriptList++;
        }

        SafeMemFree(pszText);
    }

    // Get the logic op
    logicCrit = (cDescriptList > 1) ? pCritItem->logic : CRIT_LOGIC_AND;

    // Set the outgoing params
    *ppDescriptList = pDescriptList;
    pDescriptList = NULL;
    *pcDescriptList = cDescriptList;
    *plogicCrit = logicCrit;

    // Set the return value
    hr = S_OK;
    
exit:
    _FreeDescriptionList(pDescriptList);
    RuleUtil_HrFreeCriteriaItem(pCritItem, cCritItem);
    SafeMemFree(pCritItem);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FChangeCriteriaValue
//
//  This changes the value of the criteria value
//
//  Returns:    TRUE, if the criteria value was changed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FChangeCriteriaValue(RULEDESCRIPT_LIST * pCritList)
{
    BOOL                fRet = FALSE;
    HRESULT             hr = S_OK;
    LPSTR               pszText = NULL;
    ULONG               cchText = 0;
    int                 iRet = 0;
    LONG                lDiff = 0;
    FOLDERID            idFolder = FOLDERID_ROOT;
    CHARRANGE           chrg;
    LPSTR               pszVal = NULL;
    ULONG               ulVal = 0;
    SELECTACCT          selAcct;
    IImnAccount *       pAccount = NULL;
    CHARFORMAT          chfmtLink;
    CHARFORMAT          chfmtNormal;
    CRIT_ITEM           critItem;
    RULEFOLDERDATA *    prfdData = NULL;

    ZeroMemory(&critItem, sizeof(critItem));
    
    switch(c_rgEditCritList[pCritList->ulIndex].typeCrit)
    {
      case CRIT_TYPE_NEWSGROUP:
        // Bring up the select newsgroup dialog
        if ((0 != pCritList->propvar.blob.cbSize) && (NULL != pCritList->propvar.blob.pBlobData))
        {
            // Validate the rule folder data
            if (S_OK == RuleUtil_HrValidateRuleFolderData((RULEFOLDERDATA *) (pCritList->propvar.blob.pBlobData)))
            {
                idFolder = ((RULEFOLDERDATA *) (pCritList->propvar.blob.pBlobData))->idFolder;
            }
        }
        
        hr = SelectFolderDialog(m_hwndOwner, SFD_SELECTFOLDER, idFolder, 
                                TREEVIEW_NOLOCAL | TREEVIEW_NOIMAP | TREEVIEW_NOHTTP | FD_NONEWFOLDERS | FD_DISABLEROOT | FD_DISABLESERVERS | FD_FORCEINITSELFOLDER,
                                MAKEINTRESOURCE(idsSelectNewsgroup), MAKEINTRESOURCE(idsSelectNewsgroupCaption), &idFolder);

        fRet = (S_OK == hr);
        if (FALSE != fRet)
        {
            STOREUSERDATA   UserData = {0};

            // Create space for the data structure
            hr = HrAlloc((VOID **) &prfdData, sizeof(*prfdData));
            if (FAILED(hr))
            {
                goto exit;
            }

            // Initialize the data struct
            ZeroMemory(prfdData, sizeof(*prfdData));
            
            // Get the timestamp for the store
            hr = g_pStore->GetUserData(&UserData, sizeof(STOREUSERDATA));
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Set the timestamp
            prfdData->ftStamp = UserData.ftCreated;
            prfdData->idFolder = idFolder;

            // Set the folder id
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_BLOB;
            pCritList->propvar.blob.cbSize = sizeof(*prfdData);
            pCritList->propvar.blob.pBlobData = (BYTE *) prfdData;
            prfdData = NULL;
        }
        break;
        
      case CRIT_TYPE_SUBJECT:
      case CRIT_TYPE_BODY:
        // Duplicate the data
        critItem.type = c_rgEditCritList[pCritList->ulIndex].typeCrit;
        critItem.dwFlags = pCritList->dwFlags;
        critItem.propvar.vt = VT_BLOB;

        // Copy over the blob data if it is there
        if ((0 != pCritList->propvar.blob.cbSize) &&
                (NULL != pCritList->propvar.blob.pBlobData))
        {
            hr = HrAlloc((VOID **) &(critItem.propvar.blob.pBlobData), pCritList->propvar.blob.cbSize);
            if (SUCCEEDED(hr))
            {
                critItem.propvar.blob.cbSize = pCritList->propvar.blob.cbSize;
                CopyMemory(critItem.propvar.blob.pBlobData,
                            pCritList->propvar.blob.pBlobData, critItem.propvar.blob.cbSize);
            }
        }
        
        // Edit the words
        hr = _HrCriteriaEditWords(m_hwndOwner, &critItem);
        if (FAILED(hr))
        {
            fRet = FALSE;
            goto exit;
        }
        
        fRet = (S_OK == hr);
        if (FALSE != fRet)
        {            
            PropVariantClear(&(pCritList->propvar));
            pCritList->dwFlags = critItem.dwFlags;
            pCritList->propvar = critItem.propvar;
            critItem.propvar.blob.pBlobData = NULL;
            critItem.propvar.blob.cbSize = 0;
        }
        break;

      case CRIT_TYPE_TO:
      case CRIT_TYPE_CC:
      case CRIT_TYPE_TOORCC:
      case CRIT_TYPE_FROM:
        // Duplicate the data
        critItem.type = c_rgEditCritList[pCritList->ulIndex].typeCrit;
        critItem.dwFlags = pCritList->dwFlags;
        critItem.propvar.vt = VT_BLOB;

        // Copy over the blob data if it is there
        if ((0 != pCritList->propvar.blob.cbSize) &&
                (NULL != pCritList->propvar.blob.pBlobData))
        {
            hr = HrAlloc((VOID **) &(critItem.propvar.blob.pBlobData), pCritList->propvar.blob.cbSize);
            if (SUCCEEDED(hr))
            {
                critItem.propvar.blob.cbSize = pCritList->propvar.blob.cbSize;
                CopyMemory(critItem.propvar.blob.pBlobData,
                            pCritList->propvar.blob.pBlobData, critItem.propvar.blob.cbSize);
            }
        }
        
        // Edit the people
        hr = _HrCriteriaEditPeople(m_hwndOwner, &critItem);
        if (FAILED(hr))
        {
            fRet = FALSE;
            goto exit;
        }
        
        fRet = (S_OK == hr);
        if (FALSE != fRet)
        {            
            PropVariantClear(&(pCritList->propvar));
            pCritList->dwFlags = critItem.dwFlags;
            pCritList->propvar = critItem.propvar;
            critItem.propvar.blob.pBlobData = NULL;
            critItem.propvar.blob.cbSize = 0;
        }
        break;

      case CRIT_TYPE_ACCOUNT:
        // Bring up the rename rule dialog
        if (NULL != pCritList->propvar.pszVal)
        {
            pszVal = PszDupA(pCritList->propvar.pszVal);
        }
        
        selAcct.typeRule = m_typeRule;
        selAcct.pszAcct = pszVal;
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaAcct),
                                            m_hwndOwner, _FSelectAcctDlgProc,
                                            (LPARAM) &selAcct);

        pszVal = selAcct.pszAcct;
        
        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            // Figure out account name
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_LPSTR;
            pCritList->propvar.pszVal = pszVal;
            pszVal = NULL;
            
        }
        break;

      case CRIT_TYPE_SIZE:
        // Bring up the rename rule dialog
        if (NULL != pCritList->propvar.ulVal)
        {
            ulVal = pCritList->propvar.ulVal;
        }
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaSize),
                                            m_hwndOwner, _FSelectSizeDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_UI4;
            pCritList->propvar.ulVal = ulVal;
        }
        break;
      
      case CRIT_TYPE_LINES:
        // Bring up the line rule dialog
        if (NULL != pCritList->propvar.ulVal)
        {
            ulVal = pCritList->propvar.ulVal;
        }
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaLines),
                                            m_hwndOwner, _FSelectLinesDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_UI4;
            pCritList->propvar.ulVal = ulVal;
        }
        break;
      
      case CRIT_TYPE_AGE:
        // Bring up the age rule dialog
        if (NULL != pCritList->propvar.ulVal)
        {
            ulVal = pCritList->propvar.ulVal;
        }
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaAge),
                                            m_hwndOwner, _FSelectAgeDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_UI4;
            pCritList->propvar.ulVal = ulVal;
        }
        break;
      
      case CRIT_TYPE_PRIORITY:
        // Bring up the priority rule dialog
        if (NULL != pCritList->propvar.ulVal)
        {
            ulVal = pCritList->propvar.ulVal;
        }
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaPriority),
                                            m_hwndOwner,  _FSelectPriorityDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_UI4;
            pCritList->propvar.ulVal = ulVal;
        }
        break;
      
      case CRIT_TYPE_SECURE:
        // Bring up the secure rule dialog
        if (NULL != pCritList->propvar.ulVal)
        {
            ulVal = pCritList->propvar.ulVal;
        }
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaSecure),
                                            m_hwndOwner,  _FSelectSecureDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_UI4;
            pCritList->propvar.ulVal = ulVal;
        }
        break;
      
      case CRIT_TYPE_THREADSTATE:
        // Bring up the thread state rule dialog
        if (NULL != pCritList->propvar.ulVal)
        {
            ulVal = pCritList->propvar.ulVal;
        }
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaThreadState),
                                            m_hwndOwner,  _FSelectThreadStateDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->propvar.vt = VT_UI4;
            pCritList->propvar.ulVal = ulVal;
        }
        break;
        
      case CRIT_TYPE_FLAGGED:
        // Bring up the flag dialog
        ulVal = (ULONG) (pCritList->dwFlags);
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaFlag),
                                            m_hwndOwner,  _FSelectFlagDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->dwFlags = (DWORD) ulVal;
            pCritList->propvar.vt = VT_EMPTY;
        }
        break;
        
      case CRIT_TYPE_DOWNLOADED:
        // Bring up the deletion dialog
        ulVal = (ULONG) (pCritList->dwFlags);
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaDownloaded),
                                            m_hwndOwner,  _FSelectDownloadedDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->dwFlags = (DWORD) ulVal;
            pCritList->propvar.vt = VT_EMPTY;
        }
        break;
                
      case CRIT_TYPE_READ:
        // Bring up the deletion dialog
        ulVal = (ULONG) (pCritList->dwFlags);
        
        iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddCriteriaRead),
                                            m_hwndOwner,  _FSelectReadDlgProc,
                                            (LPARAM) &ulVal);

        fRet = (iRet == IDOK);
        if (FALSE != fRet)
        {
            PropVariantClear(&(pCritList->propvar));
            pCritList->dwFlags = (DWORD) ulVal;
            pCritList->propvar.vt = VT_EMPTY;
        }
        break;
                
      default:
        fRet = FALSE;
        break;
    }

    // Update the description field if neccessary
    if (FALSE != fRet)
    {
        // ZIFF
        // Can we be sure we are really OK??
        pCritList->fError = FALSE;
        
        // If we have something to build up
        if (VT_EMPTY != pCritList->propvar.vt)
        {
            if (FALSE == _FBuildCriteriaText(c_rgEditCritList[pCritList->ulIndex].typeCrit,
                            pCritList->dwFlags, &(pCritList->propvar), &pszText))
            {
                goto exit;
            }
            
            SafeMemFree(pCritList->pszText);
            pCritList->pszText = pszText;
            pszText = NULL;
        }
        
        ShowDescriptionString();
    }
    
exit:
    SafeMemFree(prfdData);
    SafeMemFree(critItem.propvar.blob.pBlobData);
    SafeRelease(pAccount);
    SafeMemFree(pszVal);
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FBuildCriteriaText
//
//  This changes the value of the criteria value
//
//  Returns:    TRUE, if the criteria value was changed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FBuildCriteriaText(CRIT_TYPE type, DWORD dwFlags, 
                    PROPVARIANT * ppropvar, LPSTR * ppszText)
{
    BOOL                fRet = FALSE;
    LPSTR               pszText = NULL;
    ULONG               cchText = 0;
    HRESULT             hr = S_OK;
    IImnAccount *       pAccount = NULL;
    FOLDERINFO          Folder = {0};
    UINT                uiId = 0;
    TCHAR               rgchFirst[CCHMAX_STRINGRES];
    ULONG               cchFirst = 0;
    TCHAR               rgchSecond[CCHMAX_STRINGRES];
    ULONG               cchSecond = 0;
    LPTSTR              pszString = NULL;
    LPTSTR              pszWalk = NULL;
    UINT                uiID = 0;
    RULEFOLDERDATA *    prfdData = NULL;

    if ((NULL == ppropvar) || (NULL == ppszText))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch(type)
    {
        case CRIT_TYPE_NEWSGROUP:
            if ((0 == ppropvar->blob.cbSize) || (NULL == ppropvar->blob.pBlobData))
            {
                fRet = FALSE;
                goto exit;
            }
            
            prfdData = (RULEFOLDERDATA *) (ppropvar->blob.pBlobData);
            
            // Validate the rule folder data
            if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
            {
                fRet = FALSE;
                goto exit;
            }
            
            hr = g_pStore->GetFolderInfo(prfdData->idFolder, &Folder);
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Are we subscribed?
            if (0 == (Folder.dwFlags & FOLDER_SUBSCRIBED))
            {
                fRet = FALSE;
                goto exit;
            }
            
            pszText = PszDupA(Folder.pszName);
            if (NULL == pszText)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
            
        case CRIT_TYPE_SUBJECT:
        case CRIT_TYPE_BODY:
        case CRIT_TYPE_TO:
        case CRIT_TYPE_CC:
        case CRIT_TYPE_TOORCC:
        case CRIT_TYPE_FROM:
            if ((VT_BLOB != ppropvar->vt) ||
                (0 == ppropvar->blob.cbSize) ||
                (NULL == ppropvar->blob.pBlobData) ||
                ('\0' == ppropvar->blob.pBlobData[0]))
            {
                fRet = FALSE;
                goto exit;
            }
            
            pszString = (LPTSTR) ppropvar->blob.pBlobData;
            
            // Load up the first template
            if (0 != (dwFlags & CRIT_FLAG_INVERT))
            {
                uiID = idsCriteriaMultFirstNot;
            }
            else
            {
                uiID = idsCriteriaMultFirst;
            }
            
            cchFirst = LoadString(g_hLocRes, uiID, rgchFirst, sizeof(rgchFirst));
            if (0 == cchFirst)
            {
                fRet = FALSE;
                goto exit;
            }
            
            cchText = cchFirst + 1;
            
            // How many strings do we have?
            if ((lstrlen(pszString) + 3) != (int) ppropvar->blob.cbSize)
            {
                if (0 != (dwFlags & CRIT_FLAG_MULTIPLEAND))
                {
                    uiID = idsCriteriaMultAnd;
                }
                else
                {
                    uiID = idsCriteriaMultOr;
                }
                
                // Load up the second template
                cchSecond = LoadString(g_hLocRes, uiID, rgchSecond, sizeof(rgchSecond));
                if (0 == cchSecond)
                {
                    fRet = FALSE;
                    goto exit;
                }
                
                // Add in the second string for each other string
                for (pszWalk = pszString; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
                {
                    cchText += cchSecond;
                }
            }
            else
            {
                rgchSecond[0] = '\0';
            }
            
            // Total up the space
            cchText += ppropvar->blob.cbSize;
            
            // Allocate the space
            if (FAILED(HrAlloc((void **) &pszText, cchText)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Copy in the first string
            wsprintf(pszText, rgchFirst, pszString);
            pszString += lstrlen(pszString) + 1;
            
            // For each string
            pszWalk = pszText + lstrlen(pszText);
            for (; '\0' != pszString[0]; pszString += lstrlen(pszString) + 1)
            {
                // Build up the string
                wsprintf(pszWalk, rgchSecond, pszString);
                pszWalk += lstrlen(pszWalk);
            }
            break;
            
        case CRIT_TYPE_ACCOUNT:
            Assert(g_pAcctMan);
            if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, ppropvar->pszVal, &pAccount)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_ACCOUNT_NAME)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            if (FAILED(pAccount->GetPropSz(AP_ACCOUNT_NAME, pszText, CCHMAX_ACCOUNT_NAME)))
            {
                fRet = FALSE;
                goto exit;
            }        
            break;
            
        case CRIT_TYPE_SIZE:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            wsprintf(pszText, "%d ", ppropvar->ulVal);
            cchText = lstrlen(pszText);
            
            LoadString(g_hLocRes, idsKB, pszText + cchText, CCHMAX_STRINGRES - cchText);
            break;
            
        case CRIT_TYPE_LINES:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            wsprintf(pszText, "%d ", ppropvar->ulVal);
            cchText = lstrlen(pszText);
            
            LoadString(g_hLocRes, idsLines, pszText + cchText, CCHMAX_STRINGRES - cchText);
            break;
            
        case CRIT_TYPE_AGE:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            wsprintf(pszText, "%d ", ppropvar->ulVal);
            cchText = lstrlen(pszText);
            
            LoadString(g_hLocRes, idsDays, pszText + cchText, CCHMAX_STRINGRES - cchText);
            break;
            
        case CRIT_TYPE_PRIORITY:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Figure out which string to use
            if (CRIT_DATA_HIPRI == ppropvar->ulVal)
            {
                uiId = idsHighPri;
            }
            else if (CRIT_DATA_LOPRI == ppropvar->ulVal)
            {
                uiId = idsLowPri;
            }
            else
            {
                uiId = idsNormalPri;
            }
            
            LoadString(g_hLocRes, uiId, pszText, CCHMAX_STRINGRES);
            break;
            
        case CRIT_TYPE_SECURE:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Figure out which string to use
            if (0 != (ppropvar->ulVal & CRIT_DATA_ENCRYPTSECURE))
            {
                uiId = idsSecureEncrypt;
            }
            else if (0 != (ppropvar->ulVal & CRIT_DATA_SIGNEDSECURE))
            {
                uiId = idsSecureSigned;
            }
            else
            {
                uiId = idsSecureNone;
            }
            
            LoadString(g_hLocRes, uiId, pszText, CCHMAX_STRINGRES);
            break;
            
        case CRIT_TYPE_THREADSTATE:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Figure out which string to use
            if (0 != (ppropvar->ulVal & CRIT_DATA_WATCHTHREAD))
            {
                uiId = idsThreadWatch;
            }
            else if (0 != (ppropvar->ulVal & CRIT_DATA_IGNORETHREAD))
            {
                uiId = idsThreadIgnore;
            }
            else
            {
                uiId = idsThreadNone;
            }
            
            LoadString(g_hLocRes, uiId, pszText, CCHMAX_STRINGRES);
            break;
            
        default:
            fRet = FALSE;
            goto exit;
            break;
    }

    *ppszText = pszText;
    pszText = NULL;

    fRet = TRUE;
    
exit:
    g_pStore->FreeRecord(&Folder);
    SafeRelease(pAccount);
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FVerifyCriteria
//
//  This verifies the value of the criteria
//
//  Returns:    TRUE, if the criteria value was valid
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FVerifyCriteria(RULEDESCRIPT_LIST * pDescriptList)
{
    BOOL                fRet = FALSE;
    LPSTR               pszText = NULL;
    ULONG               cchText = 0;
    HRESULT             hr = S_OK;
    IImnAccount *       pAccount = NULL;
    FOLDERINFO          Folder = {0};
    LPSTR               pszWalk = NULL;
    RULEFOLDERDATA *    prfdData = NULL;

    if (NULL == pDescriptList)
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch(c_rgEditCritList[pDescriptList->ulIndex].typeCrit)
    {
        case CRIT_TYPE_NEWSGROUP:
            if ((VT_BLOB != pDescriptList->propvar.vt) ||
                (0 == pDescriptList->propvar.blob.cbSize))
            {
                hr = S_FALSE;
                goto exit;
            }
            
            // Make life simpler
            prfdData = (RULEFOLDERDATA *) (pDescriptList->propvar.blob.pBlobData);
            
            // Validate the rule folder data
            if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
            {
                hr = S_FALSE;
                goto exit;
            }
            
            // Does the folder exist
            hr = g_pStore->GetFolderInfo(prfdData->idFolder, &Folder);
            if (FAILED(hr))
            {
                hr = S_FALSE;
                goto exit;
            }        
            
            // Are we subscribed?
            if (0 == (Folder.dwFlags & FOLDER_SUBSCRIBED))
            {
                hr = S_FALSE;
                goto exit;
            }        
            break;
            
        case CRIT_TYPE_ALL:
        case CRIT_TYPE_JUNK:
        case CRIT_TYPE_READ:
        case CRIT_TYPE_REPLIES:
        case CRIT_TYPE_DOWNLOADED:
        case CRIT_TYPE_DELETED:
        case CRIT_TYPE_ATTACH:
        case CRIT_TYPE_FLAGGED:
            if (VT_EMPTY != pDescriptList->propvar.vt)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
            
        case CRIT_TYPE_SUBJECT:
        case CRIT_TYPE_BODY:
        case CRIT_TYPE_TO:
        case CRIT_TYPE_CC:
        case CRIT_TYPE_TOORCC:
        case CRIT_TYPE_FROM:
            if ((VT_BLOB != pDescriptList->propvar.vt) ||
                (0 == pDescriptList->propvar.blob.cbSize) ||
                (NULL == pDescriptList->propvar.blob.pBlobData) ||
                ('\0' == pDescriptList->propvar.blob.pBlobData[0]))
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Spin through each item making sure it is perfect
            cchText = 0;
            for (pszWalk = (LPTSTR) pDescriptList->propvar.blob.pBlobData;
            '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
            {
                cchText += lstrlen(pszWalk) + 1;
            }
            
            // For the terminator
            if ('\0' == pszWalk[0])
            {
                cchText++;
            }
            if ('\0' == pszWalk[1])
            {
                cchText++;
            }
            
            if (cchText != pDescriptList->propvar.blob.cbSize)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
            
        case CRIT_TYPE_SIZE:
        case CRIT_TYPE_THREADSTATE:
        case CRIT_TYPE_LINES:
        case CRIT_TYPE_PRIORITY:
        case CRIT_TYPE_AGE:
        case CRIT_TYPE_SECURE:
            if (VT_UI4 != pDescriptList->propvar.vt)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
            
        case CRIT_TYPE_ACCOUNT:
            if ((VT_LPSTR != pDescriptList->propvar.vt) ||
                (NULL == pDescriptList->propvar.pszVal))
            {
                fRet = FALSE;
                goto exit;
            }
            
            Assert(g_pAcctMan);
            if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pDescriptList->propvar.pszVal, &pAccount)))
            {
                fRet = FALSE;
                goto exit;
            }
            break;
            
        case CRIT_TYPE_SENDER:
        {
            LPWSTR  pwszText = NULL,
                    pwszVal = NULL;

            if ((VT_LPSTR != pDescriptList->propvar.vt) ||
                (NULL == pDescriptList->propvar.pszVal))
            {
                AssertSz(VT_LPWSTR != pDescriptList->propvar.vt, "We are getting UNICODE here.");
                fRet = FALSE;
                goto exit;
            }
            
            // Verify the email string
            pwszVal = PszToUnicode(CP_ACP, pDescriptList->propvar.pszVal);
            if (!pwszVal)
            {
                hr = S_FALSE;
                goto exit;
            }
            hr = RuleUtil_HrParseEmailString(pwszVal, 0, &pwszText, NULL);
            MemFree(pwszVal);
            MemFree(pwszText);
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }    
            break;
        }
            
        default:
            fRet = FALSE;
            goto exit;
            break;
    }

    fRet = TRUE;
    
exit:
    g_pStore->FreeRecord(&Folder);
    SafeRelease(pAccount);
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _HrBuildActionList
//
//  This builds the actions list
//
//  Returns:    TRUE, if the criteria list was created
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CRuleDescriptUI::_HrBuildActionList(IOERule * pIRule,
            RULEDESCRIPT_LIST ** ppDescriptList, ULONG * pcDescriptList)
{
    HRESULT             hr = S_OK;
    PROPVARIANT         propvar = {0};
    ACT_ITEM *          pActItem = NULL;
    ULONG               cActItem = 0;
    ULONG               ulIndex = 0;
    RULEDESCRIPT_LIST * pDescriptList = NULL;
    ULONG               ulList = 0;
    ULONG               cDescriptList = 0;
    RULEDESCRIPT_LIST * pDescriptListAlloc = NULL;
    LPSTR               pszText = NULL;
    
    Assert((NULL != pIRule) &&
                (NULL != ppDescriptList) && (NULL != pcDescriptList));

    // Initialize the outgoing param
    *ppDescriptList = NULL;
    *pcDescriptList = 0;
    
    // Get the list of actions
    hr = pIRule->GetProp(RULE_PROP_ACTIONS, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Do we have anything to do?
    if (0 == propvar.blob.cbSize)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Grab the actions list
    Assert(NULL != propvar.blob.pBlobData);
    cActItem = propvar.blob.cbSize / sizeof(ACT_ITEM);
    pActItem = (ACT_ITEM *) (propvar.blob.pBlobData);
    propvar.blob.pBlobData = NULL;
    propvar.blob.cbSize = 0;

    // For each action, add it to the description list
    for (ulIndex = 0; ulIndex < cActItem; ulIndex++)
    {
        // Create the description list
        hr = HrAlloc((VOID **) &pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));
        if (FAILED(hr))
        {
            goto exit;
        }

        // Initialize the description list
        ZeroMemory(pDescriptListAlloc, sizeof(RULEDESCRIPT_LIST));

        // Search for the criteria type
        for (ulList = 0; ulList < ARRAYSIZE(c_rgEditActList); ulList++)
        {
            if (pActItem[ulIndex].type == c_rgEditActList[ulList].typeAct)
            {
                // Save of the criteria type info
                pDescriptListAlloc->ulIndex = ulList;

                // Save off the flags
                pDescriptListAlloc->dwFlags = pActItem[ulIndex].dwFlags;

                // Do we have any data?
                if (VT_EMPTY != pActItem[ulIndex].propvar.vt)
                {
                    // Copy the data
                    SideAssert(SUCCEEDED(PropVariantCopy(&propvar, &(pActItem[ulIndex].propvar))));
                    pDescriptListAlloc->propvar = propvar;
                    ZeroMemory(&propvar, sizeof(propvar));

                    // Build up the description text
                    if (FALSE != _FBuildActionText(pActItem[ulIndex].type,
                                            &(pDescriptListAlloc->propvar), &pszText))
                    {
                        pDescriptListAlloc->pszText = pszText;
                        pszText = NULL;
                    }
                }

                // We're done searching
                break;
            }
        }

        // Did we find anything?
        if (ulList >= ARRAYSIZE(c_rgEditActList))
        {
            // Free up the description
            _FreeDescriptionList(pDescriptListAlloc);
        }
        else
        {
            // Save the rule description
            _InsertDescription(&pDescriptList, pDescriptListAlloc);
            pDescriptListAlloc = NULL;                           
            cDescriptList++;
        }
        
        SafeMemFree(pszText);
    }

    // Set the outgoing params
    *ppDescriptList = pDescriptList;
    pDescriptList = NULL;
    *pcDescriptList = cDescriptList;

    // Set the return value
    hr = S_OK;
    
exit:
    _FreeDescriptionList(pDescriptList);
    RuleUtil_HrFreeActionsItem(pActItem, cActItem);
    SafeMemFree(pActItem);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FChangeActionValue
//
//  This changes the value of the action value
//
//  Returns:    TRUE, if the criteria value was changed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FChangeActionValue(RULEDESCRIPT_LIST * pActList)
{
    BOOL                fRet = FALSE;
    LPSTR               pszText = NULL;
    int                 iRet = 0;
    LONG                lDiff = 0;
    CHARRANGE           chrg;
    FOLDERID            idFolder = FOLDERID_ROOT;
    LPSTR               pszVal = NULL;
    ULONG               ulVal = 0;
    SELECTADDR          selAddr;
    HRESULT             hr = S_OK;
    OPENFILENAME        ofn = {0};
    TCHAR               szFilter[MAX_PATH] = _T("");
    TCHAR               szDefExt[20] = _T("");
    RULEFOLDERDATA *    prfdData = NULL;
    UINT                uiID = 0;

    switch(c_rgEditActList[pActList->ulIndex].typeAct)
    {
        case ACT_TYPE_HIGHLIGHT:
            // Bring up the rename rule dialog
            if (NULL != pActList->propvar.ulVal)
            {
                ulVal = pActList->propvar.ulVal;
            }
        
            iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddActionColor),
                m_hwndOwner,  _FSelectColorDlgProc,
                (LPARAM) &ulVal);
        
            fRet = (iRet == IDOK);
            if (FALSE != fRet)
            {
                PropVariantClear(&(pActList->propvar));
                pActList->propvar.vt = VT_UI4;
                pActList->propvar.ulVal = ulVal;
            }
            break;
        
        case ACT_TYPE_WATCH:
            // Bring up the watch or ignore dialog
            if (NULL != pActList->propvar.ulVal)
            {
                ulVal = pActList->propvar.ulVal;
            }
        
            iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddActionWatch),
                m_hwndOwner,  _FSelectWatchDlgProc,
                (LPARAM) &ulVal);
        
            fRet = (iRet == IDOK);
            if (FALSE != fRet)
            {
                PropVariantClear(&(pActList->propvar));
                pActList->propvar.vt = VT_UI4;
                pActList->propvar.ulVal = ulVal;
            }
            break;
        
        case ACT_TYPE_COPY:
        case ACT_TYPE_MOVE:
            // Bring up the change folder dialog
            if ((0 != pActList->propvar.blob.cbSize) && (NULL != pActList->propvar.blob.pBlobData))
            {
                // Validate the rule folder data
                if (S_OK == RuleUtil_HrValidateRuleFolderData((RULEFOLDERDATA *) (pActList->propvar.blob.pBlobData)))
                {
                    idFolder = ((RULEFOLDERDATA *) (pActList->propvar.blob.pBlobData))->idFolder;
                }
            }
        
            hr = SelectFolderDialog(m_hwndOwner, SFD_SELECTFOLDER, idFolder, 
                TREEVIEW_NONEWS | TREEVIEW_NOIMAP | TREEVIEW_NOHTTP | FD_DISABLEROOT | FD_DISABLEOUTBOX | FD_DISABLEINBOX | FD_DISABLESENTITEMS | FD_DISABLESERVERS | FD_FORCEINITSELFOLDER,
                (c_rgEditActList[pActList->ulIndex].typeAct == ACT_TYPE_COPY) ? MAKEINTRESOURCE(idsCopy) : MAKEINTRESOURCE(idsMove),
                (c_rgEditActList[pActList->ulIndex].typeAct == ACT_TYPE_COPY) ? MAKEINTRESOURCE(idsCopyCaption) : MAKEINTRESOURCE(idsMoveCaption),
                &idFolder);
        
            fRet = (S_OK == hr);
            if (FALSE != fRet)
            {
                STOREUSERDATA   UserData = {0};
            
                // Create space for the data structure
                hr = HrAlloc((VOID **) &prfdData, sizeof(*prfdData));
                if (FAILED(hr))
                {
                    goto exit;
                }
            
                // Initialize the data struct
                ZeroMemory(prfdData, sizeof(*prfdData));
            
                // Get the timestamp for the store
                hr = g_pStore->GetUserData(&UserData, sizeof(STOREUSERDATA));
                if (FAILED(hr))
                {
                    goto exit;
                }
            
                // Set the timestamp
                prfdData->ftStamp = UserData.ftCreated;
                prfdData->idFolder = idFolder;
            
                // Set the folder id
                PropVariantClear(&(pActList->propvar));
                pActList->propvar.vt = VT_BLOB;
                pActList->propvar.blob.cbSize = sizeof(*prfdData);
                pActList->propvar.blob.pBlobData = (BYTE *) prfdData;
                prfdData = NULL;
            }
            break;
        
        case ACT_TYPE_REPLY:
        case ACT_TYPE_NOTIFYSND:
            // Bring up the select file dialog
            hr = HrAlloc((void **) &pszVal, MAX_PATH * sizeof(*pszVal));
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }
        
            pszVal[0] = '\0';
            if (NULL != pActList->propvar.pszVal)
            {
                lstrcpyn(pszVal, pActList->propvar.pszVal, MAX_PATH * sizeof(*pszVal));
            }
        
            if (ACT_TYPE_NOTIFYSND == c_rgEditActList[pActList->ulIndex].typeAct)
            {
                uiID = idsRuleNtfySndFilter;
            }
            else
            {
                uiID = idsRuleReplyWithFilter;
            }
        
            // Load Res Strings
            LoadStringReplaceSpecial(uiID, szFilter, sizeof(szFilter));
        
            // Setup Save file struct
            ofn.lStructSize = sizeof (ofn);
            ofn.hwndOwner = m_hwndOwner;
            ofn.lpstrFilter = szFilter;
            ofn.nFilterIndex = 2;
            ofn.lpstrFile = pszVal;
            ofn.nMaxFile = MAX_PATH * sizeof(*pszVal);
            ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_NOCHANGEDIR;
            hr = HrAthGetFileName(&ofn, TRUE);
        
            fRet = (S_OK == hr);
            if (FALSE != fRet)
            {
                PropVariantClear(&(pActList->propvar));
                pActList->propvar.vt = VT_LPSTR;
                pActList->propvar.pszVal = pszVal;
                pszVal = NULL;
            }
            break;
        
        case ACT_TYPE_FWD:
        {
            LPWSTR pwszVal = NULL;
            if (NULL != pActList->propvar.pszVal)
            {
                pwszVal = PszToUnicode(CP_ACP, pActList->propvar.pszVal);
                if (!pwszVal)
                {
                    fRet = FALSE;
                    break;
                }
            }
            
            // Bring up the address picker
            selAddr.lRecipType = MAPI_TO;
            selAddr.uidsWell = idsRulePickForwardTo;
            selAddr.pwszAddr = pwszVal;
            iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddActionFwd),
                m_hwndOwner,  _FSelectAddrDlgProc,
                (LPARAM) &selAddr);
            pwszVal = selAddr.pwszAddr;
            
            fRet = (iRet == IDOK);        
            if (FALSE != fRet)
            {
                PropVariantClear(&(pActList->propvar));
                pActList->propvar.vt = VT_LPSTR;
                pActList->propvar.pszVal = PszToANSI(CP_ACP, pwszVal);
                pwszVal = NULL;                
            }
            MemFree(pwszVal);
            break;
        }
        
        case ACT_TYPE_SHOW:
            // Bring up the watch or ignore dialog
            if (NULL != pActList->propvar.ulVal)
            {
                ulVal = pActList->propvar.ulVal;
            }
        
            iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddActionsShow),
                m_hwndOwner,  _FSelectShowDlgProc,
                (LPARAM) &ulVal);
        
            fRet = (iRet == IDOK);
            if (FALSE != fRet)
            {
                PropVariantClear(&(pActList->propvar));
                pActList->propvar.vt = VT_UI4;
                pActList->propvar.ulVal = ulVal;
            }
            break;
        
        default:
            fRet = FALSE;
            break;
    }
    
    // Update the description field if neccessary
    if (FALSE != fRet)
    {
        // ZIFF
        // Can we be sure we are really OK??
        pActList->fError = FALSE;
        
        // If we have something to build up
        if (VT_EMPTY != pActList->propvar.vt)
        {
            if (FALSE == _FBuildActionText(c_rgEditActList[pActList->ulIndex].typeAct, &(pActList->propvar), &pszText))
            {
                goto exit;
            }
            
            SafeMemFree(pActList->pszText);
            pActList->pszText = pszText;
            pszText = NULL;
        }
        ShowDescriptionString();
    }
    
exit:
    SafeMemFree(prfdData);
    SafeMemFree(pszVal);
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FBuildActionText
//
//  This changes the value of the action value
//
//  Returns:    TRUE, if the criteria value was changed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FBuildActionText(ACT_TYPE type, PROPVARIANT * ppropvar, LPSTR * ppszText)
{
    BOOL                fRet = FALSE;
    LPSTR               pszText = NULL;
    TCHAR               szRes[CCHMAX_STRINGRES];
    HRESULT             hr = S_OK;
    FOLDERINFO          Folder={0};
    UINT                uiId = 0;
    RULEFOLDERDATA *    prfdData = NULL;

    if ((NULL == ppropvar) || (NULL == ppszText))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch(type)
    {
        case ACT_TYPE_HIGHLIGHT:
            LoadString(g_hLocRes, ppropvar->ulVal + idsAutoColor,
                szRes, sizeof(szRes)/sizeof(TCHAR));
            pszText = PszDupA(szRes);
            if (NULL == pszText)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
        
        case ACT_TYPE_WATCH:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
        
            // Figure out which string to use
            switch (ppropvar->ulVal)
            {
                case ACT_DATA_WATCHTHREAD:
                    uiId = idsThreadWatch;
                    break;
            
                case ACT_DATA_IGNORETHREAD:
                    uiId = idsThreadIgnore;
                    break;
            
                default:
                    uiId = idsThreadNone;
                    break;
            }
        
            LoadString(g_hLocRes, uiId, pszText, CCHMAX_STRINGRES);
            break;
        
        case ACT_TYPE_COPY:
        case ACT_TYPE_MOVE:
            if ((0 == ppropvar->blob.cbSize) || (NULL == ppropvar->blob.pBlobData))
            {
                fRet = FALSE;
                goto exit;
            }
            
            prfdData = (RULEFOLDERDATA *) (ppropvar->blob.pBlobData);
            
            // Validate the rule folder data
            if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
            {
                fRet = FALSE;
                goto exit;
            }
            
            hr = g_pStore->GetFolderInfo(prfdData->idFolder, &Folder);
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }
            
            pszText = PszDupA(Folder.pszName);
            if (NULL == pszText)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
            
        case ACT_TYPE_REPLY:
        case ACT_TYPE_NOTIFYSND:
            pszText = PszDupA(ppropvar->pszVal);
            if (NULL == pszText)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
            
        case ACT_TYPE_FWD:
        {
            LPWSTR  pwszVal = PszToUnicode(CP_ACP, ppropvar->pszVal),
                    pwszText = NULL;

            if (ppropvar->pszVal && !pwszVal)
            {
                fRet = FALSE;
                goto exit;
            }

            // Update the display string
            hr = RuleUtil_HrParseEmailString(pwszVal, 0, &pwszText, NULL);
            MemFree(pwszVal);

            pszText = PszToANSI(CP_ACP, pwszText);
            if (pwszText && !pszText)
            {
                fRet = FALSE;
                goto exit;
            }

            MemFree(pwszText);
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }
            break;
        }
            
        case ACT_TYPE_SHOW:
            if (FAILED(HrAlloc((void **) &pszText, CCHMAX_STRINGRES)))
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Figure out which string to use
            switch (ppropvar->ulVal)
            {
                case ACT_DATA_SHOW:
                    uiId = idsShowMessages;
                    break;
                
                case ACT_DATA_HIDE:
                    uiId = idsHideMessages;
                    break;
                
                default:
                    uiId = idsShowHideMessages;
                    break;
            }
            
            LoadString(g_hLocRes, uiId, pszText, CCHMAX_STRINGRES);
            break;
            
        default:
            fRet = FALSE;
            goto exit;
            break;
    }
    
    *ppszText = pszText;
    pszText = NULL;

    fRet = TRUE;
    
exit:
    SafeMemFree(pszText);
    g_pStore->FreeRecord(&Folder);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FVerifyAction
//
//  This verifies the value of the action value
//
//  Returns:    TRUE, if the criteria value was changed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FVerifyAction(RULEDESCRIPT_LIST * pDescriptList)
{
    BOOL                fRet = FALSE;
    LPSTR               pszText = NULL;
    HRESULT             hr = S_OK;
    FOLDERINFO          Folder={0};
    RULEFOLDERDATA *    prfdData = NULL;

    if (NULL == pDescriptList)
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch(c_rgEditActList[pDescriptList->ulIndex].typeAct)
    {
        // These ones are always valid
        case ACT_TYPE_DELETESERVER:
        case ACT_TYPE_DONTDOWNLOAD:
        case ACT_TYPE_FLAG:
        case ACT_TYPE_READ:
        case ACT_TYPE_MARKDOWNLOAD:
        case ACT_TYPE_DELETE:
        case ACT_TYPE_JUNKMAIL:
        case ACT_TYPE_STOP:
            if (VT_EMPTY != pDescriptList->propvar.vt)
            {
                fRet = FALSE;
                goto exit;
            }
            break;
        
        case ACT_TYPE_HIGHLIGHT:
            if (VT_UI4 != pDescriptList->propvar.vt)
            {
                hr = S_FALSE;
                goto exit;
            }
            break;
        
        case ACT_TYPE_WATCH:
        case ACT_TYPE_SHOW:
            if (VT_UI4 != pDescriptList->propvar.vt)
            {
                hr = S_FALSE;
                goto exit;
            }
        
            if (ACT_DATA_NULL == pDescriptList->propvar.ulVal)
            {
                hr = S_FALSE;
                goto exit;
            }
            break;
        
        case ACT_TYPE_COPY:
        case ACT_TYPE_MOVE:
            if ((VT_BLOB != pDescriptList->propvar.vt) ||
                (0 == pDescriptList->propvar.blob.cbSize))
            {
                hr = S_FALSE;
                goto exit;
            }
        
            // Make life simpler
            prfdData = (RULEFOLDERDATA *) (pDescriptList->propvar.blob.pBlobData);
        
            // Validate the rule folder data
            if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
            {
                hr = S_FALSE;
                goto exit;
            }
        
            hr = g_pStore->GetFolderInfo(prfdData->idFolder, &Folder);
            if (FAILED(hr))
            {
                hr = S_FALSE;
                goto exit;
            }        
            else
                g_pStore->FreeRecord(&Folder);
            break;
        
        case ACT_TYPE_REPLY:
        case ACT_TYPE_NOTIFYSND:
            if ((VT_LPSTR != pDescriptList->propvar.vt) ||
                (NULL == pDescriptList->propvar.pszVal))
            {
                fRet = FALSE;
                goto exit;
            }
        
            Assert(lstrlen(pDescriptList->propvar.pszVal) <= MAX_PATH)
                if (0xFFFFFFFF == GetFileAttributes(pDescriptList->propvar.pszVal))
                {
                    hr = S_FALSE;
                    goto exit;
                }
                break;
            
        case ACT_TYPE_FWD:
        {
            LPWSTR  pwszVal = NULL,
                    pwszText = NULL;
            if ((VT_LPSTR != pDescriptList->propvar.vt) ||
                (NULL == pDescriptList->propvar.pszVal))
            {
                AssertSz(VT_LPWSTR != pDescriptList->propvar.vt, "We have UNICODE coming in.");
                fRet = FALSE;
                goto exit;
            }
        
            // Update the display string
            pwszVal = PszToUnicode(CP_ACP, pDescriptList->propvar.pszVal);
            if (!pwszVal)
            {
                fRet = FALSE;
                goto exit;
            }
            hr = RuleUtil_HrParseEmailString(pwszVal, 0, &pwszText, NULL);
            MemFree(pwszText);
            MemFree(pwszVal);
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }
        
            // If either always encrypt or always sign is turned on
            // we can't do anything
            if ((0 != DwGetOption(OPT_MAIL_DIGSIGNMESSAGES)) || (0 != DwGetOption(OPT_MAIL_ENCRYPTMESSAGES)))
            {
                hr = S_FALSE;
                goto exit;
            }
            break;
        }
        
        default:
            fRet = FALSE;
            goto exit;
            break;
    }
    
    fRet = TRUE;
    
exit:
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _UpdateRanges
//
//  This initializes the actions list view with the list of actions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
void CRuleDescriptUI::_UpdateRanges(LONG lDiff, ULONG ulStart)
{
    TCHAR               szRes[CCHMAX_STRINGRES + 3];
    ULONG               cchRes = 0;
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;

    if (0 == lDiff)
    {
        goto exit;
    }
    
    // Update the criteria ranges
    for (pDescriptListWalk = m_pDescriptListCrit;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        if (pDescriptListWalk->ulStartLogic > ulStart)
        {
            pDescriptListWalk->ulStartLogic += lDiff;
            pDescriptListWalk->ulEndLogic += lDiff;
            
            pDescriptListWalk->ulStart += lDiff;
            pDescriptListWalk->ulEnd += lDiff;
        }
        else if (pDescriptListWalk->ulStart > ulStart)
        {
            pDescriptListWalk->ulStart += lDiff;
            pDescriptListWalk->ulEnd += lDiff;
        }
    }

    // Update the action ranges
    for (pDescriptListWalk = m_pDescriptListAct;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        if (pDescriptListWalk->ulStart > ulStart)
        {
            pDescriptListWalk->ulStart += lDiff;
            pDescriptListWalk->ulEnd += lDiff;
        }
    }
    
exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _InsertDescription
//
//  This adds a description node to the list of descriptions
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void CRuleDescriptUI::_InsertDescription(RULEDESCRIPT_LIST ** ppDescriptList,
            RULEDESCRIPT_LIST * pDescriptListNew)
{
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    RULEDESCRIPT_LIST * pDescriptListPrev = NULL;
    
    Assert(NULL != ppDescriptList);

    // Search for the proper place to place the new item
    for (pDescriptListWalk = *ppDescriptList;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        if (pDescriptListWalk->ulIndex > pDescriptListNew->ulIndex)
        {
            break;
        }

        // Save off the old description
        pDescriptListPrev = pDescriptListWalk;
    }

    // If it's supposed to go at the top
    if (NULL == pDescriptListPrev)
    {
        *ppDescriptList = pDescriptListNew;
        pDescriptListNew->pNext = pDescriptListWalk;
    }
    else
    {
        pDescriptListNew->pNext = pDescriptListWalk;
        pDescriptListPrev->pNext = pDescriptListNew;
    }
        
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FRemoveDescription
//
//  This adds a description node to the list of descriptions
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FRemoveDescription(RULEDESCRIPT_LIST ** ppDescriptList, ULONG ulIndex,
            RULEDESCRIPT_LIST ** ppDescriptListRemove)
{
    BOOL                fRet = FALSE;
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    RULEDESCRIPT_LIST * pDescriptListPrev = NULL;
    
    Assert((NULL != ppDescriptList) && (NULL != ppDescriptListRemove));

    *ppDescriptListRemove = NULL;
    
    // Find the criteria item in the list
    for (pDescriptListWalk = *ppDescriptList;
                pDescriptListWalk != NULL; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        if (ulIndex == pDescriptListWalk->ulIndex)
        {
            break;
        }

        // Save off the old description
        pDescriptListPrev = pDescriptListWalk;
    }

    // Did we find the criteria item?
    if (NULL == pDescriptListWalk)
    {
        fRet = FALSE;
        goto exit;
    }

    // Remove the criteria item from the list
    if (NULL == pDescriptListPrev)
    {
        *ppDescriptList = pDescriptListWalk->pNext;
    }
    else
    {
        pDescriptListPrev->pNext = pDescriptListWalk->pNext;
    }
    pDescriptListWalk->pNext = NULL;

    // Set the outgoing params
    *ppDescriptListRemove = pDescriptListWalk;
    
    // Set the return value
    fRet = TRUE;
    
exit:        
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FreeDescriptionLists
//
//  This frees the list of descriptions
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void CRuleDescriptUI::_FreeDescriptionList(RULEDESCRIPT_LIST * pDescriptList)
{
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    
    while (NULL != pDescriptList)
    {
        pDescriptListWalk = pDescriptList;
        
        SafeMemFree(pDescriptListWalk->pszText);
        PropVariantClear(&(pDescriptListWalk->propvar));

        pDescriptList = pDescriptListWalk->pNext;
        MemFree(pDescriptListWalk);
    }
    
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnDescriptClick
//
//  This handles clicking on the links in the description field
//
//  uiMsg   - the type of click
//  ulIndex - which criteria/action to change
//  fCrit   - did we click on a criteria?
//  fLogic  - did we click on a logic op?
//
//  Returns:    TRUE, we changed the criteria/action
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FOnDescriptClick(UINT uiMsg, RULEDESCRIPT_LIST * pDescriptList, BOOL fCrit, BOOL fLogic)
{
    BOOL            fRet = FALSE;
    CHARRANGE       chrg;
    NMHDR           nmhdr;

    if ((WM_LBUTTONUP == uiMsg) || (WM_KEYDOWN == uiMsg))
    {
        // Release the capture if there is one
        if (NULL != GetCapture())
        {
            ReleaseCapture();
        }
        
        // Did we click in the logic op?
        if (fLogic)
        {
            fRet = _FChangeLogicValue(pDescriptList);
        }
        // Did we click in the criteria list?
        else if (fCrit)
        {
            fRet = _FChangeCriteriaValue(pDescriptList);
        }
        else
        {
            fRet = _FChangeActionValue(pDescriptList);
        }

        if (fRet)
        {
            m_dwState |= STATE_DIRTY;

            // Tell the parent dialog something has changed
            nmhdr.hwndFrom = m_hwndOwner;
            nmhdr.idFrom = GetDlgCtrlID(m_hwndOwner);
            nmhdr.code = NM_RULE_CHANGED;
            SendMessage(GetParent(m_hwndOwner), WM_NOTIFY, (WPARAM) (nmhdr.idFrom), (LPARAM) &nmhdr);
        }

        fRet = TRUE;
    }

    if (((WM_LBUTTONDOWN == uiMsg) || (WM_LBUTTONDBLCLK == uiMsg)) &&
                                (0 == (GetAsyncKeyState(VK_CONTROL) & 0x8000)))
    {
        if (fLogic)
        {
            chrg.cpMin = pDescriptList->ulStartLogic;
            chrg.cpMax = pDescriptList->ulEndLogic;
        }
        else
        {
            chrg.cpMin = pDescriptList->ulStart;
            chrg.cpMax = pDescriptList->ulEnd;
        }

        // Need to make sure we show the selection
        SendMessage(m_hwndOwner, EM_HIDESELECTION, (WPARAM) FALSE, (LPARAM) FALSE);
        RichEditExSetSel(m_hwndOwner, &chrg);

        fRet = TRUE;
    }
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInLink
//
//  Given a point in the control, this will tell us whether or not the point
//  is in a link
//
//  ppt         - the point to check
//  pulIndex    - which criteria/action is the point in
//  pfCrit      - is the point over a criteria?
//  pfLogic     - is the point over a logic op?
//
//  Returns:    TRUE, if the point is over a criteria/action
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FInLink(int chPos, RULEDESCRIPT_LIST ** ppDescriptList,
            BOOL * pfCrit, BOOL * pfLogic)
{
    BOOL    fFound = FALSE;
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;
    POINT   pt;
    ULONG   ulIndex = 0;
    BOOL    fCrit = FALSE;
    BOOL    fLogic = FALSE;
    LONG    idxLine = 0;
    LPSTR   pszBuff = NULL;
    ULONG   cchBuff = 0;
    HDC     hdc = NULL;
    HFONT   hfont = NULL;
    HFONT   hfontOld = NULL;
    SIZE    size;
    LONG    idxPosLine = 0;

    // If we're read only then we can't be in a link
    if ((0 != (m_dwState & STATE_READONLY)) || (0 == chPos))
    {
        fFound = FALSE;
        goto exit;
    }
    
    // Did we click in the criteria list?
    for (pDescriptListWalk = m_pDescriptListCrit;
                NULL != pDescriptListWalk; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        if (((LONG) pDescriptListWalk->ulStart <= chPos) &&
                        ((LONG) pDescriptListWalk->ulEnd >= chPos))
        {
            fCrit = TRUE;
            fFound = TRUE;
            break;
        }

        if (((LONG) pDescriptListWalk->ulStartLogic <= chPos) &&
                        ((LONG) pDescriptListWalk->ulEndLogic >= chPos))
        {
            fLogic = TRUE;
            fFound = TRUE;
            break;
        }
    }

    if (!fFound)
    {
        // Did we click in the actions list
        for (pDescriptListWalk = m_pDescriptListAct;
                    NULL != pDescriptListWalk; pDescriptListWalk = pDescriptListWalk->pNext)
        {
            if (((LONG) pDescriptListWalk->ulStart <= chPos) &&
                            ((LONG) pDescriptListWalk->ulEnd >= chPos))
            {
                fFound = TRUE;
                break;
            }
        }
    }

    if (ppDescriptList)
    {
        *ppDescriptList = pDescriptListWalk;
    }
    
    if (pfCrit)
    {
        *pfCrit = fCrit;
    }
    
    if (pfLogic)
    {
        *pfLogic = fLogic;
    }
    goto exit; 
    
exit:
    if (NULL != hdc)
    {
        ReleaseDC(m_hwndOwner, hdc);
    }
    MemFree(pszBuff);
    return fFound;
}

VOID _SearchForLink(RULEDESCRIPT_LIST * pDescriptList, BOOL fUp, LONG lPos, CHARRANGE * pcrPos)
{
    RULEDESCRIPT_LIST * pDescriptListWalk = NULL;

    Assert(NULL != pcrPos);
    
    // Find the closest link...
    for (pDescriptListWalk = pDescriptList;
                NULL != pDescriptListWalk; pDescriptListWalk = pDescriptListWalk->pNext)
    {
        // Do we have a criteria link?
        if (0 != pDescriptListWalk->ulStart)
        {
            // Are we going down?
            if (FALSE == fUp)
            {
                // Is the link past the current position?
                if ((LONG) pDescriptListWalk->ulEnd > lPos)
                {
                    // Save off the closest link to the current position
                    if ((0 == pcrPos->cpMin) || ((LONG) pDescriptListWalk->ulStart < pcrPos->cpMin))
                    {
                        pcrPos->cpMin = (LONG) pDescriptListWalk->ulStart;
                        pcrPos->cpMax = (LONG) pDescriptListWalk->ulEnd;
                    }
                }
            }
            else
            {
                // Is the link before the current position?
                if ((LONG) pDescriptListWalk->ulEnd < lPos)
                {
                    // Save off the closest link to the current position
                    if ((0 == pcrPos->cpMin) || ((LONG) pDescriptListWalk->ulStart > pcrPos->cpMin))
                    {
                        pcrPos->cpMin = (LONG) pDescriptListWalk->ulStart;
                        pcrPos->cpMax = (LONG) pDescriptListWalk->ulEnd;
                    }
                }
            }
        }

        // Do we have a logic link?
        if (0 != pDescriptListWalk->ulStartLogic)
        {
            // Are we going down?
            if (FALSE == fUp)
            {
                // Is the link past the current position?
                if ((LONG) pDescriptListWalk->ulEndLogic > lPos)
                {
                    // Save off the closest link to the current position
                    if ((0 == pcrPos->cpMin) || ((LONG) pDescriptListWalk->ulStartLogic < pcrPos->cpMin))
                    {
                        pcrPos->cpMin = (LONG) pDescriptListWalk->ulStartLogic;
                        pcrPos->cpMax = (LONG) pDescriptListWalk->ulEndLogic;
                    }
                }
            }
            else
            {
                // Is the link before the current position?
                if ((LONG) pDescriptListWalk->ulEndLogic < lPos)
                {
                    // Save off the closest link to the current position
                    if ((0 == pcrPos->cpMin) || ((LONG) pDescriptListWalk->ulStartLogic > pcrPos->cpMin))
                    {
                        pcrPos->cpMin = (LONG) pDescriptListWalk->ulStartLogic;
                        pcrPos->cpMax = (LONG) pDescriptListWalk->ulEndLogic;
                    }
                }
            }
        }
    }

    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FMoveToLink
//
//  Given a point in the control, this will tell us whether or not the point
//  is in a link
//
//  ppt         - the point to check
//  pulIndex    - which criteria/action is the point in
//  pfCrit      - is the point over a criteria?
//  pfLogic     - is the point over a logic op?
//
//  Returns:    TRUE, if the point is over a criteria/action
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CRuleDescriptUI::_FMoveToLink(UINT uiKeyCode)
{
    BOOL                fRet = FALSE;
    BOOL                fUp = FALSE;
    CHARRANGE           crPos = {0};
    CHARRANGE           crLink = {0};

    // Figure out which way we are going
    fUp = ((VK_LEFT == uiKeyCode) || (VK_UP == uiKeyCode));
    
    // Get the current character position
    RichEditExGetSel(m_hwndOwner, &crPos);

    // Find the closest link in the criteria
    _SearchForLink(m_pDescriptListCrit, fUp, crPos.cpMax, &crLink);
    
    // Find the closest link in the actions
    _SearchForLink(m_pDescriptListAct, fUp, crPos.cpMax, &crLink);

    // Do we have anything to do?
    if (0 != crLink.cpMin)
    {
        // Set the new selection
        RichEditExSetSel(m_hwndOwner, &crLink);
        SendMessage(m_hwndOwner, EM_SCROLLCARET, (WPARAM) 0, (LPARAM) 0);

        fRet = TRUE;
    }
    
    return fRet;
}

LRESULT CALLBACK CRuleDescriptUI::_DescriptWndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT             lRes = 0;
    POINT               ptCur;
    CRuleDescriptUI *   pDescriptUI = NULL;
    HCURSOR             hcursor = NULL;
    RULEDESCRIPT_LIST * pDescriptList = NULL;
    BOOL                fCrit = FALSE;
    BOOL                fLogic = FALSE;
    CHARRANGE           crPos = {0};
    int                 chPos = 0;
    
    pDescriptUI = (CRuleDescriptUI *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_SETCURSOR:
            if((FALSE != IsWindowVisible(hwnd)) && ((HWND) wParam == hwnd))
            {
                lRes = DefWindowProc(hwnd, uiMsg, wParam, lParam);
                if(0 == lRes)
                {
                    GetCursorPos(&ptCur);
                    ScreenToClient(hwnd, &ptCur);
                    chPos = (int) SendMessage(hwnd, EM_CHARFROMPOS, (WPARAM)0, (LPARAM)&ptCur);
                    chPos = RichEditNormalizeCharPos(hwnd, chPos, NULL);
                    if (FALSE != pDescriptUI->_FInLink(chPos, NULL, NULL, NULL))
                    {
                        hcursor = LoadCursor(g_hLocRes, MAKEINTRESOURCE(idcurBrHand));
                        SetCursor(hcursor);
                        lRes = TRUE;
                    }
                }
            }                
            break;
        
        case WM_LBUTTONDOWN:
        case WM_LBUTTONDBLCLK:
        case WM_LBUTTONUP:
            GetCursorPos(&ptCur);
            ScreenToClient(hwnd, &ptCur);
            chPos = (int) SendMessage(hwnd, EM_CHARFROMPOS, (WPARAM)0, (LPARAM)&ptCur);
            chPos = RichEditNormalizeCharPos(hwnd, chPos, NULL);
            if (FALSE != pDescriptUI->_FInLink(chPos, &pDescriptList, &fCrit, &fLogic))
            {
                // Change the proper value
                lRes = pDescriptUI->_FOnDescriptClick(uiMsg, pDescriptList, fCrit, fLogic);
            }
            break;
        
        case WM_KEYDOWN:
            switch (wParam)
            {
                case VK_RETURN:
                    RichEditExGetSel(hwnd, &crPos);
                    if (FALSE != pDescriptUI->_FInLink(crPos.cpMin, &pDescriptList, &fCrit, &fLogic))
                    {
                        // Change the proper value
                        lRes = pDescriptUI->_FOnDescriptClick(uiMsg, pDescriptList, fCrit, fLogic);
                    }
                    break;
            
                case VK_LEFT:
                case VK_UP:
                case VK_RIGHT:
                case VK_DOWN:
                    lRes = pDescriptUI->_FMoveToLink((UINT) wParam);
                    break;
            }
            break;
    }
    
    if (0 == lRes)
    {
        lRes = CallWindowProc(pDescriptUI->m_wpcOld, hwnd, uiMsg, wParam, lParam);
    }
    
    return lRes;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectAddrDlgProc
//
//  This is the main dialog proc for changing addresses
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectAddrDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    SELECTADDR *    pseladdr = NULL;
    HWND            hwndAddr = NULL;
    LPWSTR          pwszText = NULL,
                    pwszAddr = NULL;
    ULONG           cchText = 0,
                    cchAddr = 0;
    HRESULT         hr = S_OK;

    pseladdr = (SELECTADDR *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pseladdr = (SELECTADDR *) lParam;
            if (NULL == pseladdr)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
                goto exit;
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pseladdr);

            hwndAddr = GetDlgItem(hwndDlg, idedtCriteriaAddr);
            
            SetIntlFont(hwndAddr);
            
            // Set the name of the rule into the edit well
            if (NULL == pseladdr->pwszAddr)
            {
                Edit_SetText(hwndAddr, c_szEmpty);
            }
            else
            {
                if (FAILED(RuleUtil_HrParseEmailString(pseladdr->pwszAddr, 0, &pwszText, NULL)))
                {
                    fRet = FALSE;
                    EndDialog(hwndDlg, -1);
                    goto exit;
                }
                SetWindowTextWrapW(hwndAddr, pwszText);
                SafeMemFree(pwszText);
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case idedtCriteriaAddr:
                    if (EN_CHANGE == HIWORD(wParam))
                    {
                        hwndAddr = (HWND) lParam;
                        Assert(NULL != hwndAddr);

                        RuleUtil_FEnDisDialogItem(hwndDlg, IDOK, 0 != Edit_GetTextLength(hwndAddr));
                    }
                    break;
                
                case idbCriteriaAddr:
                    hwndAddr = GetDlgItem(hwndDlg, idedtCriteriaAddr);
                    
                    // Get the name of the rule from the edit well
                    cchText = Edit_GetTextLength(hwndAddr) + 1;
                    if (FAILED(HrAlloc((void **) &pwszText, cchText * sizeof(*pwszText))))
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    pwszText[0] = L'\0';
                    cchText = GetWindowTextWrapW(hwndAddr, pwszText, cchText);
                    
                    hr = RuleUtil_HrBuildEmailString(pwszText, cchText, &pwszAddr, &cchAddr);
                    SafeMemFree(pwszText);
                    if (FAILED(hr))
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    hr = RuleUtil_HrPickEMailNames(hwndDlg, pseladdr->lRecipType, pseladdr->uidsWell, &pwszAddr);
                    if (S_OK != hr)
                    {
                        fRet = FALSE;
                        SafeMemFree(pwszAddr);
                        goto exit;
                    }
                    
                    if (S_OK != RuleUtil_HrParseEmailString(pwszAddr, 0, &pwszText, NULL))
                    {
                        fRet = FALSE;
                        SafeMemFree(pwszAddr);
                        goto exit;
                    }

                    SetWindowTextWrapW(hwndAddr, pwszText);
                    SafeMemFree(pwszText);
                    SafeMemFree(pwszAddr);
                    break;
                
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    hwndAddr = GetDlgItem(hwndDlg, idedtCriteriaAddr);
                    
                    // Get the name of the rule from the edit well
                    cchText = Edit_GetTextLength(hwndAddr) + 1;
                    if (FAILED(HrAlloc((void **) &pwszText, cchText * sizeof(*pwszText))))
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    pwszText[0] = L'\0';
                    cchText = GetWindowTextWrapW(hwndAddr, pwszText, cchText);
                    
                    // Check to see if the rule name is valid
                    if ((FAILED(RuleUtil_HrBuildEmailString(pwszText, cchText, &pwszAddr, &cchAddr))) ||
                                    (0 == cchAddr))
                    {
                        // Put up a message saying something is busted
                        AthMessageBoxW(hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                                        MAKEINTRESOURCEW(idsRulesErrorNoAddr), NULL,
                                        MB_OK | MB_ICONINFORMATION);
                        SafeMemFree(pwszText);
                        SafeMemFree(pwszAddr);
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    SafeMemFree(pseladdr->pwszAddr);
                    pseladdr->pwszAddr = pwszAddr;
                    SafeMemFree(pwszText);
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

exit:
    return fRet;
}
///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectAcctDlgProc
//
//  This is the main dialog proc for selecting an account dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectAcctDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                fRet = FALSE;
    SELECTACCT *        pselacct = NULL;
    LPSTR               pszAcct = NULL;
    ULONG               cchAcct = 0;
    HWND                hwndAcct = NULL;
    CHAR                szAccount[CCHMAX_ACCOUNT_NAME];
    IImnAccount *       pAccount = NULL;
    IImnEnumAccounts *  pEnumAcct = NULL;
    DWORD               dwSrvTypes = 0;
    ULONG               ulIndex = 0;
    BOOL                fSelected = FALSE;
    
    pselacct = (SELECTACCT *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pselacct = (SELECTACCT *) lParam;
            if (NULL == pselacct)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
                goto exit;
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pselacct);

            hwndAcct = GetDlgItem(hwndDlg, idcCriteriaAcct);
            
            SetIntlFont(hwndAcct);
            
            // Set the name of the rule into the edit well
            Assert(g_pAcctMan);

            switch (pselacct->typeRule)
            {
                case RULE_TYPE_MAIL:
                    dwSrvTypes = SRV_POP3;
                    break;

                case RULE_TYPE_NEWS:
                    dwSrvTypes = SRV_NNTP;
                    break;

                case RULE_TYPE_FILTER:
                    dwSrvTypes = SRV_MAIL | SRV_NNTP;
                    break;
            }
            
            // Grab the enumerator from the account manager
            if (FAILED(g_pAcctMan->Enumerate(dwSrvTypes, &pEnumAcct)))
            {
                fRet = FALSE;
                goto exit;
            }
        
            // Insert each account into the combobox
            while(SUCCEEDED(pEnumAcct->GetNext(&pAccount)))
            {
                // We can get back NULL accounts
                if (NULL == pAccount)
                {
                    break;
                }
                
                // Add the account string to the combobox
                if (FAILED(pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccount, sizeof(szAccount))))
                {
                    SafeRelease(pAccount);
                    continue;
                }

                ulIndex = ComboBox_AddString(hwndAcct, szAccount);
                if (CB_ERR == ulIndex)
                {
                    fRet = FALSE;
                    SafeRelease(pEnumAcct);
                    SafeRelease(pAccount);
                    EndDialog(hwndDlg, -1);
                    goto exit;
                }
                
                if (FAILED(pAccount->GetPropSz(AP_ACCOUNT_ID, szAccount, sizeof(szAccount))))
                {
                    SafeRelease(pAccount);
                    continue;
                }

                // Set the default selection if we have one
                if ((NULL != pselacct->pszAcct) && (0 == lstrcmp(pselacct->pszAcct, szAccount)))
                {
                    Assert(FALSE == fSelected);
                    ComboBox_SetCurSel(hwndAcct, ulIndex);
                    fSelected = TRUE;
                }

                // Release it
                SafeRelease(pAccount);
            }

            SafeRelease(pEnumAcct);
            
            if (FALSE == fSelected)
            {
                ComboBox_SetCurSel(hwndAcct, 0);
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {            
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    hwndAcct = GetDlgItem(hwndDlg, idcCriteriaAcct);
                    
                    // Get the account name that was selected
                    ulIndex = ComboBox_GetCurSel(hwndAcct);
                    if (CB_ERR == ulIndex)
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    cchAcct = ComboBox_GetLBText(hwndAcct, ulIndex, szAccount);
                    if (0 == cchAcct)
                    {
                        fRet = FALSE;
                        goto exit;
                    }

                    Assert(g_pAcctMan);
                    if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount)))
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    if (FAILED(pAccount->GetPropSz(AP_ACCOUNT_ID, szAccount, sizeof(szAccount))))
                    {
                        fRet = FALSE;
                        SafeRelease(pAccount);
                        goto exit;
                    }

                    // Release it
                    SafeRelease(pAccount);
                    
                    pszAcct = PszDupA(szAccount);
                    if (NULL == pszAcct)
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    SafeMemFree(pselacct->pszAcct);
                    pselacct->pszAcct = pszAcct;
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectColorDlgProc
//
//  This is the main dialog proc for selecting a color dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectColorDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                fRet = FALSE;
    ULONG *             pulColor = NULL;
    ULONG               ulColor = NULL;
    HWND                hwndColor = NULL;
    HDC                 hdc = NULL;
    LPMEASUREITEMSTRUCT pmis = NULL;
    LPDRAWITEMSTRUCT    pdis = NULL;
    
    pulColor = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulColor = (ULONG *) lParam;
            if (NULL == pulColor)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
                goto exit;
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulColor);

            hwndColor = GetDlgItem(hwndDlg, idcCriteriaColor);
            
            SetIntlFont(hwndColor);
            
            // Let's create the color control
            if (FAILED(HrCreateComboColor(hwndColor)))
            {
                fRet = FALSE;
                goto exit;
            }    
            
            if (0 != *pulColor)
            {
                ulColor = *pulColor;
            }
            
            ComboBox_SetCurSel(hwndColor, ulColor);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
            
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {            
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    hwndColor = GetDlgItem(hwndDlg, idcCriteriaColor);
                    
                    // Get the account name that was selected
                    ulColor = ComboBox_GetCurSel(hwndColor);
                    if (CB_ERR == ulColor)
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    *pulColor = ulColor;
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
        
        case WM_DRAWITEM:
            pdis = (LPDRAWITEMSTRUCT)lParam;
            Assert(pdis);
            Color_WMDrawItem(pdis, iColorCombo);
            fRet = FALSE;
            break;

        case WM_MEASUREITEM:
            pmis = (LPMEASUREITEMSTRUCT)lParam;
            hwndColor = GetDlgItem(hwndDlg, idcCriteriaColor);
            hdc = GetDC(hwndColor);
            if(hdc)
            {
                Color_WMMeasureItem(hdc, pmis, iColorCombo);
                ReleaseDC(hwndColor, hdc);
            }
            fRet = TRUE;
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectSizeDlgProc
//
//  This is the main dialog proc for selecting the size dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectSizeDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulSize = NULL;
    HWND            hwndSize = NULL;
    HWND            hwndText = NULL;
    ULONG           ulSize = 0;

    pulSize = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulSize = (ULONG *) lParam;
            if (NULL == pulSize)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulSize);

            hwndSize = GetDlgItem(hwndDlg, idspnCriteriaSize);
            hwndText = GetDlgItem(hwndDlg, idcCriteriaSize);
            
            SetIntlFont(hwndText);
            SendMessage(hwndSize, UDM_SETRANGE, 0, MAKELONG( (short) UD_MAXVAL, 0));
            
            // Set the name of the rule into the edit well
            if (NULL != *pulSize)
            {
                SendMessage(hwndSize, UDM_SETPOS, 0, MAKELONG( (short) *pulSize, 0));
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case idcCriteriaSize:
                    if (EN_CHANGE == HIWORD(wParam))
                    {
                        hwndText = (HWND) lParam;
                        Assert(NULL != hwndText);

                        RuleUtil_FEnDisDialogItem(hwndDlg, IDOK, 0 != Edit_GetTextLength(hwndText));
                    }
                    break;
                
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    hwndSize = GetDlgItem(hwndDlg, idspnCriteriaSize);
                    
                    // Get the name of the rule from the edit well
                    ulSize = (INT) SendMessage(hwndSize, UDM_GETPOS, 0, 0);
                    if (0 != HIWORD(ulSize))
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    *pulSize = LOWORD(ulSize);
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectLinesDlgProc
//
//  This is the main dialog proc for selecting the count of lines dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectLinesDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulLines = NULL;
    HWND            hwndLines = NULL;
    HWND            hwndText = NULL;
    ULONG           ulLines = 0;

    pulLines = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulLines = (ULONG *) lParam;
            if (NULL == pulLines)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulLines);

            hwndLines = GetDlgItem(hwndDlg, idspnCriteriaLines);
            hwndText = GetDlgItem(hwndDlg, idcCriteriaLines);
            
            SetIntlFont(hwndText);
            SendMessage(hwndLines, UDM_SETRANGE, 0, MAKELONG( (short) UD_MAXVAL, 0));
            
            // Set the name of the rule into the edit well
            if (NULL != *pulLines)
            {
                SendMessage(hwndLines, UDM_SETPOS, 0, MAKELONG( (short) *pulLines, 0));
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case idcCriteriaLines:
                    if (EN_CHANGE == HIWORD(wParam))
                    {
                        hwndText = (HWND) lParam;
                        Assert(NULL != hwndText);

                        RuleUtil_FEnDisDialogItem(hwndDlg, IDOK, 0 != Edit_GetTextLength(hwndText));
                    }
                    break;
                    
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    hwndLines = GetDlgItem(hwndDlg, idspnCriteriaLines);
                    
                    // Get the name of the rule from the edit well
                    ulLines = (INT) SendMessage(hwndLines, UDM_GETPOS, 0, 0);
                    if (0 != HIWORD(ulLines))
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    *pulLines = LOWORD(ulLines);
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectAgeDlgProc
//
//  This is the main dialog proc for selecting the count of lines dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectAgeDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulDays = NULL;
    HWND            hwndDays = NULL;
    HWND            hwndText = NULL;
    ULONG           ulDays = 0;

    pulDays = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulDays = (ULONG *) lParam;
            if (NULL == pulDays)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulDays);

            hwndDays = GetDlgItem(hwndDlg, idspnCriteriaAge);
            hwndText = GetDlgItem(hwndDlg, idcCriteriaAge);
            
            SetIntlFont(hwndText);
            SendMessage(hwndDays, UDM_SETRANGE, 0, MAKELONG( (short) UD_MAXVAL, 0));
            
            // Set the name of the rule into the edit well
            if (NULL != *pulDays)
            {
                SendMessage(hwndDays, UDM_SETPOS, 0, MAKELONG( (short) *pulDays, 0));
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case idcCriteriaLines:
                    if (EN_CHANGE == HIWORD(wParam))
                    {
                        hwndText = (HWND) lParam;
                        Assert(NULL != hwndText);

                        RuleUtil_FEnDisDialogItem(hwndDlg, IDOK, 0 != Edit_GetTextLength(hwndText));
                    }
                    break;
                
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    hwndDays = GetDlgItem(hwndDlg, idspnCriteriaAge);
                    
                    // Get the name of the rule from the edit well
                    ulDays = (INT) SendMessage(hwndDays, UDM_GETPOS, 0, 0);
                    if (0 != HIWORD(ulDays))
                    {
                        fRet = FALSE;
                        goto exit;
                    }
                    
                    *pulDays = LOWORD(ulDays);
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectPriorityDlgProc
//
//  This is the main dialog proc for selecting the priority dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectPriorityDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulPri = NULL;
    ULONG           ulPri = 0;

    pulPri = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulPri = (ULONG *) lParam;
            if (NULL == pulPri)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulPri);

            // Set the default item
            CheckDlgButton(hwndDlg, (CRIT_DATA_LOPRI == *pulPri) ? idcCriteriaLowPri : idcCriteriaHighPri, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
            
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaLowPri))
                    {
                        ulPri = CRIT_DATA_LOPRI;
                    }
                    else
                    {
                        ulPri = CRIT_DATA_HIPRI;
                    }
                    
                    *pulPri = ulPri;
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectSecureDlgProc
//
//  This is the main dialog proc for selecting the security dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectSecureDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulSec = NULL;
    ULONG           ulSec = 0;
    UINT            uiId = 0;

    pulSec = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulSec = (ULONG *) lParam;
            if (NULL == pulSec)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulSec);

            // Set the default item
            if (0 != ((*pulSec) & CRIT_DATA_ENCRYPTSECURE))
            {
                uiId = idcCriteriaEncrypt;
            }
            else
            {
                uiId = idcCriteriaSigned;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaSigned))
                    {
                        ulSec = CRIT_DATA_SIGNEDSECURE;
                    }
                    else
                    {
                        ulSec = CRIT_DATA_ENCRYPTSECURE;
                    }
                    
                    *pulSec = ulSec;
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectThreadStateDlgProc
//
//  This is the main dialog proc for selecting the thread state dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectThreadStateDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulThread = NULL;
    ULONG           ulThread = 0;
    UINT            uiId = 0;

    pulThread = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulThread = (ULONG *) lParam;
            if (NULL == pulThread)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulThread);

            // Set the default item
            if (0 != ((*pulThread) & CRIT_DATA_IGNORETHREAD))
            {
                uiId = idcCriteriaIgnoreThread;
            }
            else
            {
                uiId = idcCriteriaWatchThread;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
            
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaWatchThread))
                    {
                        ulThread = CRIT_DATA_WATCHTHREAD;
                    }
                    else
                    {
                        ulThread = CRIT_DATA_IGNORETHREAD;
                    }
                    
                    *pulThread = ulThread;
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectShowDlgProc
//
//  This is the main dialog proc for selecting the security dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectShowDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulVal = NULL;
    UINT            uiId = 0;

    pulVal = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulVal = (ULONG *) lParam;
            if (NULL == pulVal)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulVal);

            // Set the default item
            if (ACT_DATA_HIDE == *pulVal)
            {
                uiId = idcCriteriaHide;
            }
            else
            {
                uiId = idcCriteriaShow;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaHide))
                    {
                        *pulVal = ACT_DATA_HIDE;
                    }
                    else
                    {
                        *pulVal = ACT_DATA_SHOW;
                    }
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectShowDlgProc
//
//  This is the main dialog proc for selecting the security dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectLogicDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    CRIT_LOGIC *    plogicCrit = NULL;
    UINT            uiId = 0;

    plogicCrit = (CRIT_LOGIC *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            plogicCrit = (CRIT_LOGIC *) lParam;
            if (NULL == plogicCrit)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) plogicCrit);

            // Set the default item
            if (CRIT_LOGIC_OR == (*plogicCrit))
            {
                uiId = idcCriteriaOr;
            }
            else
            {
                uiId = idcCriteriaAnd;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
            
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaAnd))
                    {
                        *plogicCrit = CRIT_LOGIC_AND;
                    }
                    else
                    {
                        *plogicCrit = CRIT_LOGIC_OR;
                    }
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectFlagDlgProc
//
//  This is the main dialog proc for selecting the security dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectFlagDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulVal = NULL;
    UINT            uiId = 0;

    pulVal = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulVal = (ULONG *) lParam;
            if (NULL == pulVal)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulVal);

            // Set the default item
            if (0 != ((*pulVal) & CRIT_FLAG_INVERT))
            {
                uiId = idcCriteriaNoFlag;
            }
            else
            {
                uiId = idcCriteriaFlag;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaNoFlag))
                    {
                        *pulVal |= CRIT_FLAG_INVERT;
                    }
                    else
                    {
                        *pulVal &= ~CRIT_FLAG_INVERT;
                    }
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectDownloadedDlgProc
//
//  This is the main dialog proc for selecting the downloaded dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectDownloadedDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulVal = NULL;
    UINT            uiId = 0;

    pulVal = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulVal = (ULONG *) lParam;
            if (NULL == pulVal)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulVal);

            // Set the default item
            if (0 != ((*pulVal) & CRIT_FLAG_INVERT))
            {
                uiId = idcCriteriaNotDownloaded;
            }
            else
            {
                uiId = idcCriteriaDownloaded;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
            
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaNotDownloaded))
                    {
                        *pulVal |= CRIT_FLAG_INVERT;
                    }
                    else
                    {
                        *pulVal &= ~CRIT_FLAG_INVERT;
                    }
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectReadDlgProc
//
//  This is the main dialog proc for selecting the read state dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectReadDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulVal = NULL;
    UINT            uiId = 0;

    pulVal = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulVal = (ULONG *) lParam;
            if (NULL == pulVal)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulVal);

            // Set the default item
            if (0 != ((*pulVal) & CRIT_FLAG_INVERT))
            {
                uiId = idcCriteriaNotRead;
            }
            else
            {
                uiId = idcCriteriaRead;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
            
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcCriteriaNotRead))
                    {
                        *pulVal |= CRIT_FLAG_INVERT;
                    }
                    else
                    {
                        *pulVal &= ~CRIT_FLAG_INVERT;
                    }
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSelectWatchDlgProc
//
//  This is the main dialog proc for selecting the thread state dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CRuleDescriptUI::_FSelectWatchDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    ULONG *         pulThread = NULL;
    ULONG           ulThread = 0;
    UINT            uiId = 0;

    pulThread = (ULONG *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pulThread = (ULONG *) lParam;
            if (NULL == pulThread)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pulThread);

            // Set the default item
            if (ACT_DATA_IGNORETHREAD == *pulThread)
            {
                uiId = idcActionsIgnoreThread;
            }
            else
            {
                uiId = idcActionsWatchThread;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcActionsWatchThread))
                    {
                        ulThread = ACT_DATA_WATCHTHREAD;
                    }
                    else
                    {
                        ulThread = ACT_DATA_IGNORETHREAD;
                    }
                    
                    *pulThread = ulThread;
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}

// Class definitions
class CEditPeopleOptionsUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_DIRTY         = 0x00000002
        };

    private:
        HWND                m_hwndOwner;
        DWORD               m_dwFlags;
        DWORD               m_dwState;
        HWND                m_hwndDlg;
        HWND                m_hwndList;
        CRIT_ITEM *         m_pCritItem;
    
    public:
        CEditPeopleOptionsUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
                                m_hwndDlg(NULL), m_hwndList(NULL), m_pCritItem(NULL) {}
        ~CEditPeopleOptionsUI();

        // The main UI methods
        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
        HRESULT HrShow(CRIT_ITEM * pCritItem);
                
        // The Rules Manager dialog function
        static INT_PTR CALLBACK FEditPeopleOptionsDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);    

        // Message handling functions
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnMeasureItem(HWND hwndDlg, UINT uiCtlId, MEASUREITEMSTRUCT * pmis);
        BOOL FOnDrawItem(UINT uiCtlId, DRAWITEMSTRUCT * pdis);

    private:
        BOOL _FLoadCtrls(VOID);
        BOOL _FOnOK(DWORD * pdwFlags);
        BOOL _AddTagLineToList(VOID);
        BOOL _FAddWordToList(DWORD dwFlags, LPCTSTR pszItem);
};

typedef struct tagPEOPLEEDITTAG
{
    CRIT_TYPE   type;
    UINT        uiNormal;
    UINT        uiInverted;
} PEOPLEEDITTAG, * PPEOPLEEDITTAG;

static const PEOPLEEDITTAG g_rgpetTagLines[] =
{
    {CRIT_TYPE_TO,      idsCriteriaToEdit,      idsCriteriaToNotEdit},
    {CRIT_TYPE_CC,      idsCriteriaCCEdit,      idsCriteriaCCNotEdit},
    {CRIT_TYPE_FROM,     idsCriteriaFromEdit,    idsCriteriaFromNotEdit},
    {CRIT_TYPE_TOORCC,  idsCriteriaToOrCCEdit,  idsCriteriaToOrCCNotEdit},
    {CRIT_TYPE_SUBJECT, idsCriteriaSubjectEdit, idsCriteriaSubjectNotEdit},
    {CRIT_TYPE_BODY,    idsCriteriaBodyEdit,    idsCriteriaBodyNotEdit}
};

static const int g_cpetTagLines = sizeof(g_rgpetTagLines) / sizeof(g_rgpetTagLines[0]);

class CEditPeopleUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_DIRTY         = 0x00000002
        };

    private:
        HWND            m_hwndOwner;
        DWORD           m_dwFlags;
        DWORD           m_dwState;
        HWND            m_hwndDlg;
        HWND            m_hwndPeople;
        HWND            m_hwndList;
        ULONG           m_cxMaxPixels;
        CRIT_ITEM *     m_pCritItem;

    public:
        CEditPeopleUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
                        m_hwndDlg(NULL), m_hwndPeople(NULL), m_hwndList(NULL),
                        m_cxMaxPixels(0), m_pCritItem(NULL) {}
        ~CEditPeopleUI();

        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
        HRESULT HrShow(CRIT_ITEM * pCritItem);

        static INT_PTR CALLBACK FEditPeopleDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnMeasureItem(HWND hwndDlg, UINT uiCtlId, MEASUREITEMSTRUCT * pmis);
        BOOL FOnDrawItem(UINT uiCtlId, DRAWITEMSTRUCT * pdis);

    private:
        BOOL _FLoadListCtrl(VOID);
        VOID _AddItemToList(VOID);
        VOID _AddItemsFromWAB(VOID);
        VOID _RemoveItemFromList(VOID);
        VOID _ChangeOptions(VOID);
        BOOL _FOnNameChange(VOID);
        BOOL _FOnOK(CRIT_ITEM * pCritItem);
        VOID _UpdateButtons(VOID);
        BOOL _AddTagLineToList(VOID);
        BOOL _FAddWordToList(DWORD dwFlags, LPCTSTR pszItem);
};

CEditPeopleOptionsUI::~CEditPeopleOptionsUI()
{
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes us with the owner window and any flags we might have
//
//  hwndOwner   - handle to the owner window
//  dwFlags     - flags to use for this instance
//  pBlob       - the data to edit
//
//  Returns:    S_OK
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditPeopleOptionsUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT         hr = S_OK;
    CHARFORMAT      cf;
    
    // If we're already initialized, then fail
    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Save off the owner window
    m_hwndOwner = hwndOwner;
    
    // Save off the flags
    m_dwFlags = dwFlags;

    // We're done
    m_dwState |= STATE_INITIALIZED;

    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrShow
//
//  This initializes us with the owner window and any flags we might have
//
//  hwndOwner   - handle to the owner window
//  dwFlags     - flags to use for this instance
//  pBlob       - the data to edit
//
//  Returns:    S_OK
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditPeopleOptionsUI::HrShow(CRIT_ITEM * pCritItem)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;
    UINT        uiID = 0;

    // Check incoming params
    if (NULL == pCritItem)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // Save off the data
    m_pCritItem = pCritItem;
    
    // Figure out which dialog template to use
    if (0 != (m_dwFlags & PUI_WORDS))
    {
        uiID = iddCriteriaWordsOptions;
    }
    else
    {
        uiID = iddCriteriaPeopleOptions;
    }
    
    // Bring up the editor dialog
    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(uiID),
                                        m_hwndOwner,  CEditPeopleOptionsUI::FEditPeopleOptionsDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

INT_PTR CALLBACK CEditPeopleOptionsUI::FEditPeopleOptionsDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    CEditPeopleOptionsUI *  pOptionsUI = NULL;

    pOptionsUI = (CEditPeopleOptionsUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pOptionsUI = (CEditPeopleOptionsUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pOptionsUI);

            if (FALSE == pOptionsUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We set the focus
            fRet = TRUE;
            break;

        case WM_COMMAND:
            fRet = pOptionsUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;
            
        case WM_MEASUREITEM:
            fRet = pOptionsUI->FOnMeasureItem(hwndDlg, (UINT) wParam, (MEASUREITEMSTRUCT *) lParam);
            break;

        case WM_DRAWITEM:
            fRet = pOptionsUI->FOnDrawItem((UINT) wParam, (DRAWITEMSTRUCT *) lParam);
            break;
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the edit people UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndList = GetDlgItem(hwndDlg, idcCriteriaList);
    if (NULL == m_hwndList)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Load the list view
    fRet = _FLoadCtrls();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the view manager UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    INT     iSelected = 0;

    switch (iCtl)
    {
        case IDOK:
            if (FALSE != _FOnOK(&(m_pCritItem->dwFlags)))
            {
                EndDialog(m_hwndDlg, IDOK);
                fRet = TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(m_hwndDlg, IDCANCEL);
            fRet = TRUE;
            break;

        case idcCriteriaNotCont:
        case idcCriteriaContains:
        case idcCriteriaAnd:
        case idcCriteriaOr:
            if (BN_CLICKED == uiNotify)
            {
                // Make sure the list is redrawn
                InvalidateRect(m_hwndList, NULL, TRUE);
            }
            break;

    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnMeasureItem
//
//  This handles the WM_MEASUREITEM message for the view manager UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::FOnMeasureItem(HWND hwndDlg, UINT uiCtlId, MEASUREITEMSTRUCT * pmis)
{
    BOOL        fRet = FALSE;
    HWND        hwndList = NULL;
    HDC         hdcList = NULL;
    TEXTMETRIC  tm = {0};
    
    // Get the window handle
    hwndList = GetDlgItem(hwndDlg, uiCtlId);
    if (NULL == hwndList)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the device context
    hdcList = GetDC(hwndList);
    if (NULL == hdcList)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the text metrics for the device context
    GetTextMetrics(hdcList, &tm);

    // Set the item height
    pmis->itemHeight = tm.tmHeight;

    fRet = TRUE;

exit:
    if (NULL != hdcList)
    {
        ReleaseDC(hwndList, hdcList);
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnDrawItem
//
//  This handles the WM_DRAWITEM message for the people editor UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::FOnDrawItem(UINT uiCtlId, DRAWITEMSTRUCT * pdis)
{
    BOOL        fRet = FALSE;
    DWORD       dwFlags = 0;
    INT         cchText = 0;
    LPTSTR      pszText = NULL;
    LPTSTR      pszString = NULL;
    UINT        uiID = 0;
    TCHAR       rgchRes[CCHMAX_STRINGRES];
    COLORREF    crfBack = NULL;
    COLORREF    crfText = NULL;
    ULONG       ulIndex = 0;
    LPTSTR      pszPrint = NULL;

    // Make sure this is the correct control
    if (ODT_LISTBOX != pdis->CtlType)
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the flags from the dialog
    if (FALSE == _FOnOK(&dwFlags))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Nothing else to do if it's the first item
    if (0 == pdis->itemID)
    {
        for (ulIndex = 0; ulIndex < g_cpetTagLines; ulIndex++)
        {
            if (g_rgpetTagLines[ulIndex].type == m_pCritItem->type)
            {
                if (0 != (dwFlags & CRIT_FLAG_INVERT))
                {
                    uiID = g_rgpetTagLines[ulIndex].uiInverted;
                }
                else
                {
                    uiID = g_rgpetTagLines[ulIndex].uiNormal;
                }
                break;
            }
        }
        
        // Did we find anything?
        if (ulIndex >= g_cpetTagLines)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Load the item template
        if (NULL == AthLoadString(uiID, rgchRes, sizeof(rgchRes)))
        {
            fRet = FALSE;
            goto exit;
        }

        pszPrint = rgchRes;
    }
    else
    {
        // Get the size of the string for the item
        cchText = (INT) SendMessage(m_hwndList, LB_GETTEXTLEN, (WPARAM) (pdis->itemID), (LPARAM) 0);
        if (LB_ERR == cchText)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Allocate enough space to hold the the string for the item
        if (FAILED(HrAlloc((VOID **) &pszText, sizeof(*pszText) * (cchText + 1))))
        {
            fRet = FALSE;
            goto exit;
        }

        // Get the string for the item
        cchText = (INT) SendMessage(m_hwndList, LB_GETTEXT, (WPARAM) (pdis->itemID), (LPARAM) pszText);
        if (LB_ERR == cchText)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Figure out which string template to use
        if (1 == pdis->itemID)
        {
            uiID = idsCriteriaEditFirst;
        }
        else
        {
            if (0 != (dwFlags & CRIT_FLAG_MULTIPLEAND))
            {
                uiID = idsCriteriaEditAnd;
            }
            else
            {
                uiID = idsCriteriaEditOr;
            }
        }
        
        // Load the proper string template for the item
        if (NULL == AthLoadString(uiID, rgchRes, sizeof(rgchRes)))
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Allocate enough space to hold the final string
        if (FAILED(HrAlloc((VOID **) &pszString, sizeof(*pszString) * (cchText + CCHMAX_STRINGRES + 1))))
        {
            fRet = FALSE;
            goto exit;
        }

        // Create the final string
        wsprintf(pszString, rgchRes, pszText);

        pszPrint = pszString;
    }
    
    // Determine Colors
    crfBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
    crfText = SetTextColor(pdis->hDC, GetSysColor(COLOR_WINDOWTEXT));

    // Clear the item
    ExtTextOut(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top, ETO_OPAQUE, &(pdis->rcItem), NULL, 0, NULL);

    // Draw the new item
    DrawTextEx(pdis->hDC, pszPrint, lstrlen(pszPrint), &(pdis->rcItem), DT_BOTTOM | DT_NOPREFIX | DT_SINGLELINE, NULL);

    if (pdis->itemState & ODS_FOCUS)
    {
        DrawFocusRect(pdis->hDC, &(pdis->rcItem));
    }
    
    // Reset Text Colors
    SetTextColor (pdis->hDC, crfText);
    SetBkColor (pdis->hDC, crfBack);

    // Set return value
    fRet = TRUE;
    
exit:
    SafeMemFree(pszString);
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadListCtrl
//
//  This loads the list view with the current Mail rules
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::_FLoadCtrls(VOID)
{
    BOOL    fRet = FALSE;
    UINT    uiID = 0;
    LPTSTR  pszWalk = NULL; 
    
    Assert(NULL != m_hwndList);

    // Set the contains option
    if (0 != (m_pCritItem->dwFlags & CRIT_FLAG_INVERT))
    {
        uiID = idcCriteriaNotCont;
    }
    else
    {
        uiID = idcCriteriaContains;
    }

    CheckRadioButton(m_hwndDlg, idcCriteriaContains, idcCriteriaNotCont, uiID);

    // Set the logic option
    if (0 != (m_pCritItem->dwFlags & CRIT_FLAG_MULTIPLEAND))
    {
        uiID = idcCriteriaAnd;
    }
    else
    {
        uiID = idcCriteriaOr;
    }

    CheckRadioButton(m_hwndDlg, idcCriteriaAnd, idcCriteriaOr, uiID);
    
    // Remove all the items from the list control
    SendMessage(m_hwndList, LB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0);

    // Add the tag line to the top of the list
    _AddTagLineToList();
    
    // If we have some items, let's add them to the list
    if (0 != m_pCritItem->propvar.blob.cbSize)
    {
        // Add each item into the list
        for (pszWalk = (LPSTR) (m_pCritItem->propvar.blob.pBlobData);
                    '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
        {
            if (FALSE == _FAddWordToList(0, pszWalk))
            {
                fRet = FALSE;
                goto exit;
            }
        }
    }

    // If we don't have at least two names in the list
    if (3 > SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0))
    {
        // Disable the And/Or buttons
        RuleUtil_FEnDisDialogItem(m_hwndDlg, idcCriteriaAnd, FALSE);
        RuleUtil_FEnDisDialogItem(m_hwndDlg, idcCriteriaOr, FALSE);
    }
    
    fRet = TRUE;

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnOK
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::_FOnOK(DWORD * pdwFlags)
{
    BOOL    fRet = FALSE;
    
    Assert(NULL != m_hwndList);

    // Get the contains option
    if (BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, idcCriteriaContains))
    {
        *pdwFlags &= ~CRIT_FLAG_INVERT;
    }
    else
    {
        *pdwFlags |= CRIT_FLAG_INVERT;
    }
    
    // Get the logic option
    if (BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, idcCriteriaAnd))
    {
        *pdwFlags |= CRIT_FLAG_MULTIPLEAND;
    }
    else
    {
        *pdwFlags &= ~CRIT_FLAG_MULTIPLEAND;
    }
    
    // Set the return value
    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _AddTagLineToList
//
//  This enables or disables the buttons in the people editor UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::_AddTagLineToList(VOID)
{
    BOOL            fRet = FALSE;
    
    Assert(NULL != m_hwndList);

    fRet = _FAddWordToList(0, " ");
    if (FALSE == fRet)
    {
        goto exit;
    }
    
    // Set the proper return value
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddWordToList
//
//  This enables or disables the buttons in the people editor UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleOptionsUI::_FAddWordToList(DWORD dwFlags, LPCTSTR pszItem)
{
    BOOL            fRet = FALSE;
    int             cItems = 0;
    INT             iRet = 0;
    
    Assert(NULL != m_hwndList);

    // Is there anything to do?
    if ((NULL == pszItem) || ('\0' == pszItem[0]))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the number of items in the list
    cItems = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == cItems)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the data into the list 
    iRet = (INT) SendMessage(m_hwndList, LB_ADDSTRING, (WPARAM) cItems, (LPARAM) pszItem);
    if ((LB_ERR == iRet) || (LB_ERRSPACE == iRet))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the proper return value
    fRet = TRUE;
    
exit:
    return fRet;
}

CEditPeopleUI::~CEditPeopleUI()
{
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes us with the owner window and any flags we might have
//
//  hwndOwner   - handle to the owner window
//  dwFlags     - flags to use for this instance
//  pBlob       - the data to edit
//
//  Returns:    S_OK
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditPeopleUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT         hr = S_OK;
    CHARFORMAT      cf;
    
    // If we're already initialized, then fail
    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Save off the owner window
    m_hwndOwner = hwndOwner;
    
    // Save off the flags
    m_dwFlags = dwFlags;

    // We're done
    m_dwState |= STATE_INITIALIZED;

    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes us with the owner window and any flags we might have
//
//  hwndOwner   - handle to the owner window
//  dwFlags     - flags to use for this instance
//  pBlob       - the data to edit
//
//  Returns:    S_OK
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditPeopleUI::HrShow(CRIT_ITEM * pCritItem)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;
    UINT        uiID = 0;

    // Check incoming params
    if (NULL == pCritItem)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // Save off the data
    m_pCritItem = pCritItem;
    
    // Figure out which dialog template to use
    if (0 != (m_dwFlags & PUI_WORDS))
    {
        uiID = iddCriteriaWords;
    }
    else
    {
        uiID = iddCriteriaPeople;
    }
    
    // Bring up the editor dialog
    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(uiID),
                                        m_hwndOwner,  CEditPeopleUI::FEditPeopleDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

INT_PTR CALLBACK CEditPeopleUI::FEditPeopleDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    CEditPeopleUI *         pPeopleUI = NULL;

    pPeopleUI = (CEditPeopleUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pPeopleUI = (CEditPeopleUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pPeopleUI);

            if (FALSE == pPeopleUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We set the focus
            fRet = TRUE;
            break;

        case WM_COMMAND:
            fRet = pPeopleUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;

        case WM_MEASUREITEM:
            fRet = pPeopleUI->FOnMeasureItem(hwndDlg, (UINT) wParam, (MEASUREITEMSTRUCT *) lParam);
            break;

        case WM_DRAWITEM:
            fRet = pPeopleUI->FOnDrawItem((UINT) wParam, (DRAWITEMSTRUCT *) lParam);
            break;            
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the edit people UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndList = GetDlgItem(hwndDlg, idcCriteriaList);
    m_hwndPeople = GetDlgItem(hwndDlg, idcCriteriaEdit);
    if ((NULL == m_hwndList) || (NULL == m_hwndPeople))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Load the list view
    fRet = _FLoadListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the view manager UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    INT     iSelected = 0;

    switch (iCtl)
    {
        case IDOK:
            if (FALSE != _FOnOK(m_pCritItem))
            {
                EndDialog(m_hwndDlg, IDOK);
                fRet = TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(m_hwndDlg, IDCANCEL);
            fRet = TRUE;
            break;
            
        case idcCriteriaEdit:
            if (EN_CHANGE == uiNotify)
            {
                _FOnNameChange();
            }
            fRet = FALSE;
            break;
    
        case idcCriteriaAdd:
            _AddItemToList();
            break;

        case idcCriteriaAddrBook:
            _AddItemsFromWAB();
            break;

        case idcCriteriaRemove:
            _RemoveItemFromList();
            break;
            
        case idcCriteriaOptions:
            _ChangeOptions();
            break;

        case idcCriteriaList:   
            if (LBN_SELCHANGE == uiNotify)
            {
                // Update the buttons
                _UpdateButtons();
            }
            break;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnMeasureItem
//
//  This handles the WM_MEASUREITEM message for the view manager UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::FOnMeasureItem(HWND hwndDlg, UINT uiCtlId, MEASUREITEMSTRUCT * pmis)
{
    BOOL        fRet = FALSE;
    HWND        hwndList = NULL;
    HDC         hdcList = NULL;
    TEXTMETRIC  tm = {0};
    
    // Get the window handle
    hwndList = GetDlgItem(hwndDlg, uiCtlId);
    if (NULL == hwndList)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the device context
    hdcList = GetDC(hwndList);
    if (NULL == hdcList)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the text metrics for the device context
    GetTextMetrics(hdcList, &tm);

    // Set the item height
    pmis->itemHeight = tm.tmHeight;

    fRet = TRUE;

exit:
    if (NULL != hdcList)
    {
        ReleaseDC(hwndList, hdcList);
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnDrawItem
//
//  This handles the WM_DRAWITEM message for the people editor UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::FOnDrawItem(UINT uiCtlId, DRAWITEMSTRUCT * pdis)
{
    BOOL        fRet = FALSE;
    INT         cchText = 0;
    LPTSTR      pszText = NULL;
    LPTSTR      pszString = NULL;
    UINT        uiID = 0;
    TCHAR       rgchRes[CCHMAX_STRINGRES];
    COLORREF    crfBack = NULL;
    COLORREF    crfText = NULL;
    ULONG       ulIndex = 0;
    LPTSTR      pszPrint = NULL;

    // Make sure this is the correct control
    if (ODT_LISTBOX != pdis->CtlType)
    {
        fRet = FALSE;
        goto exit;
    }

    // Nothing else to do if it's the first item
    if (0 == pdis->itemID)
    {
        for (ulIndex = 0; ulIndex < g_cpetTagLines; ulIndex++)
        {
            if (g_rgpetTagLines[ulIndex].type == m_pCritItem->type)
            {
                if (0 != (m_pCritItem->dwFlags & CRIT_FLAG_INVERT))
                {
                    uiID = g_rgpetTagLines[ulIndex].uiInverted;
                }
                else
                {
                    uiID = g_rgpetTagLines[ulIndex].uiNormal;
                }
                break;
            }
        }
        
        // Did we find anything?
        if (ulIndex >= g_cpetTagLines)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Load the item template
        if (NULL == AthLoadString(uiID, rgchRes, sizeof(rgchRes)))
        {
            fRet = FALSE;
            goto exit;
        }

        pszPrint = rgchRes;
    }
    else
    {
        // Get the size of the string for the item
        cchText = (INT) SendMessage(m_hwndList, LB_GETTEXTLEN, (WPARAM) (pdis->itemID), (LPARAM) 0);
        if (LB_ERR == cchText)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Allocate enough space to hold the the string for the item
        if (FAILED(HrAlloc((VOID **) &pszText, sizeof(*pszText) * (cchText + 1))))
        {
            fRet = FALSE;
            goto exit;
        }

        // Get the string for the item
        cchText = (INT) SendMessage(m_hwndList, LB_GETTEXT, (WPARAM) (pdis->itemID), (LPARAM) pszText);
        if (LB_ERR == cchText)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Figure out which string template to use
        if (1 == pdis->itemID)
        {
            uiID = idsCriteriaEditFirst;
        }
        else
        {
            if (0 != (m_pCritItem->dwFlags & CRIT_FLAG_MULTIPLEAND))
            {
                uiID = idsCriteriaEditAnd;
            }
            else
            {
                uiID = idsCriteriaEditOr;
            }
        }
        
        // Load the proper string template for the item
        if (NULL == AthLoadString(uiID, rgchRes, sizeof(rgchRes)))
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Allocate enough space to hold the final string
        if (FAILED(HrAlloc((VOID **) &pszString, sizeof(*pszString) * (cchText + CCHMAX_STRINGRES + 1))))
        {
            fRet = FALSE;
            goto exit;
        }

        // Create the final string
        wsprintf(pszString, rgchRes, pszText);

        pszPrint = pszString;
    }
    
    // Determine Colors
    if (pdis->itemState & ODS_SELECTED)
    {
        crfBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
        crfText = SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        crfBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
        crfText = SetTextColor(pdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    // Clear the item
    ExtTextOut(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top, ETO_OPAQUE, &(pdis->rcItem), NULL, 0, NULL);

    // Draw the new item
    DrawTextEx(pdis->hDC, pszPrint, lstrlen(pszPrint), &(pdis->rcItem), DT_BOTTOM | DT_NOPREFIX | DT_SINGLELINE, NULL);

    if (pdis->itemState & ODS_FOCUS)
    {
        DrawFocusRect(pdis->hDC, &(pdis->rcItem));
    }
    
    // Reset Text Colors
    SetTextColor (pdis->hDC, crfText);
    SetBkColor (pdis->hDC, crfBack);

    // Set return value
    fRet = TRUE;
    
exit:
    SafeMemFree(pszString);
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadListCtrl
//
//  This loads the list view with the current Mail rules
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::_FLoadListCtrl(VOID)
{
    BOOL            fRet = FALSE;
    LPSTR           pszWalk = NULL;

    Assert(NULL != m_hwndList);

    // Remove all the items from the list control
    SendMessage(m_hwndList, LB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0);

    // Add the tag line to the top of the list
    _AddTagLineToList();
    
    // If we have some items, let's add them to the list
    if (0 != m_pCritItem->propvar.blob.cbSize)
    {
        // Add each item into the list
        for (pszWalk = (LPSTR) (m_pCritItem->propvar.blob.pBlobData);
                    '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
        {
            fRet = _FAddWordToList(0, pszWalk);
            if (FALSE == fRet)
                goto exit;
        }
    }
    
    SendMessage(m_hwndDlg, DM_SETDEFID, IDOK, 0);
    
    // Enable the dialog buttons.
    _UpdateButtons();

    fRet = TRUE;

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _AddItemToList
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
VOID CEditPeopleUI::_AddItemToList(VOID)
{
    ULONG       cchName = 0;
    LPTSTR      pszItem = NULL;
    
    // Get the item from the edit well
    cchName = Edit_GetTextLength(m_hwndPeople) + 1;
    if (FAILED(HrAlloc((void **) &pszItem, cchName * sizeof(*pszItem))))
    {
        goto exit;
    }
    
    pszItem[0] = '\0';
    cchName = Edit_GetText(m_hwndPeople, pszItem, cchName);
    
    // Check to see if the name is valid
    if (0 == UlStripWhitespace(pszItem, TRUE, TRUE, NULL))
    {
        // Put up a message saying something is busted
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        MAKEINTRESOURCEW(idsEditPeopleErrorNoName),
                        NULL, MB_OK | MB_ICONINFORMATION);
        goto exit;
    }

    _FAddWordToList(0, pszItem);

    // Clear out the edit well
    Edit_SetText(m_hwndPeople, "");
    
    _UpdateButtons();
    
exit:
    SafeMemFree(pszItem);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _AddItemsFromWAB
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
VOID CEditPeopleUI::_AddItemsFromWAB(VOID)
{
    ULONG       cchName = 0;
    LPWSTR      pwszAddrs = NULL;
    LPWSTR      pwszWalk = NULL;
    LONG        lRecipType = 0;
    UINT        uidsWell = 0;
    
    // Set the proper tags
    switch(m_pCritItem->type)
    {
      case CRIT_TYPE_TO:
        lRecipType = MAPI_TO;
        uidsWell = idsRulePickTo;
        break;
        
      case CRIT_TYPE_CC:
        lRecipType = MAPI_CC;
        uidsWell = idsRulePickCC;
        break;
        
      case CRIT_TYPE_FROM:
        lRecipType = MAPI_ORIG;
        uidsWell = idsRulePickFrom;
        break;

      case CRIT_TYPE_TOORCC:
        lRecipType = MAPI_TO;
        uidsWell = idsRulePickToOrCC;
        break;

      default:
        goto exit;
        break;
    }
    
    if (FAILED(RuleUtil_HrGetAddressesFromWAB(m_hwndDlg, lRecipType, uidsWell, &pwszAddrs)))
    {
        goto exit;
    }

    // Loop through each of the addresses
    for (pwszWalk = pwszAddrs; '\0' != pwszWalk[0]; pwszWalk += lstrlenW(pwszWalk) + 1)
    {
        LPSTR pszWalk = NULL;
        // Addresses only have to be US ASCII so won't loose anything in this conversion.
        pszWalk = PszToANSI(CP_ACP, pwszWalk);
        if (!pszWalk)
        {
            TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        _FAddWordToList(0, pszWalk);
        MemFree(pszWalk);
    }

    _UpdateButtons();
    
exit:
    MemFree(pwszAddrs);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _RemoveItemFromList
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
VOID CEditPeopleUI::_RemoveItemFromList(VOID)
{
    INT         iSelected = 0;
    INT         cItems = 0;
    
    Assert(NULL != m_hwndList);

    // Figure out which item is selected in the list
    iSelected = (INT) SendMessage(m_hwndList, LB_GETCURSEL, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == iSelected)
    {
        goto exit;
    }

    // If it's the tag line, then fail
    if (0 == iSelected)
    {
        goto exit;
    }

    // Get the current number of items
    cItems = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == cItems)
    {
        goto exit;
    }

    // Remove the item
    if (LB_ERR == (INT) SendMessage(m_hwndList, LB_DELETESTRING, (WPARAM) iSelected, (LPARAM) 0))
    {
        goto exit;
    }
    
    // If we deleted the last item, select the new last item
    if (iSelected == (cItems - 1))
    {
        iSelected--;
    }

    // Set the new selection
    if (0 != iSelected)
    {
        SideAssert(LB_ERR != (INT) SendMessage(m_hwndList, LB_SETCURSEL, (WPARAM) iSelected, (LPARAM) 0));
    }

    _UpdateButtons();
    
exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _ChangeOptions
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
VOID CEditPeopleUI::_ChangeOptions(VOID)
{
    HRESULT                 hr = S_OK;
    CEditPeopleOptionsUI *  pOptionUI = NULL;
    CRIT_ITEM               critItem;
    
    Assert(NULL != m_pCritItem);

    // Initialize local variables
    ZeroMemory(&critItem, sizeof(critItem));
    
    // Create the options UI object
    pOptionUI = new CEditPeopleOptionsUI;
    if (NULL == pOptionUI)
    {
        goto exit;
    }
    
    // Initialize the options UI object
    hr = pOptionUI->HrInit(m_hwndDlg, m_dwFlags);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the parameters to pass to the options dialog
    critItem.type = m_pCritItem->type;
    critItem.dwFlags = m_pCritItem->dwFlags;
    critItem.propvar.vt = VT_BLOB;

    // Get the parameter from the dialog
    if (FALSE == _FOnOK(&critItem))
    {
        goto exit;
    }
    
    // Show the options UI
    hr = pOptionUI->HrShow(&critItem);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // If anything changed
    if (S_OK == hr)
    {
        // Set the new value
        m_pCritItem->dwFlags = critItem.dwFlags;
        
        // Make sure the list is redrawn
        InvalidateRect(m_hwndList, NULL, TRUE);
        
        // Mark us as dirty
        m_dwState |= STATE_DIRTY;
    }
    
exit:
    PropVariantClear(&(critItem.propvar));
    if (NULL != pOptionUI)
    {
        delete pOptionUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnNameChange
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::_FOnNameChange(VOID)
{
    BOOL    fRet = FALSE;
    BOOL    fIsText = FALSE;

    Assert(NULL != m_hwndPeople);

    // Note that we're dirty
    m_dwState |= STATE_DIRTY;
    
    fIsText = (0 != Edit_GetTextLength(m_hwndPeople));

    // Disable the Add button if the name is empty
    fRet = RuleUtil_FEnDisDialogItem(m_hwndDlg, idcCriteriaAdd, fIsText);

    SendMessage(m_hwndDlg, DM_SETDEFID, (FALSE != fIsText) ? idcCriteriaAdd : IDOK, 0);

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnOK
//
//  This handles the user typing into the name field
//
//  Returns:    TRUE, we handled the edit message
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::_FOnOK(CRIT_ITEM * pCritItem)
{
    BOOL    fRet = FALSE;
    INT     cItems = 0;
    INT     iIndex = 0;
    INT     iRet = 0;
    ULONG   cchText = 0;
    LPTSTR  pszText = NULL;
    LPTSTR  pszWalk = NULL;
    
    Assert(NULL != m_hwndList);

    // Get the total number of items in the list
    cItems = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
    if ((LB_ERR == cItems) || (2 > cItems))
    {
        fRet = FALSE;
        goto exit;
    }

    // Loop through each item, calculating the space each would take
    for (iIndex = 1; iIndex < cItems; iIndex++)
    {
        // Get the space for the item
        iRet = (INT) SendMessage(m_hwndList, LB_GETTEXTLEN, (WPARAM) iIndex, (LPARAM) 0);
        if ((LB_ERR == iRet) || (0 == iRet))
        {
            continue;
        }

        // Count the space needed
        cchText += iRet + 1;
    }

    // Add in space for the terminator
    cchText += 2;

    // Allocate space to hold the item
    if (FAILED(HrAlloc((VOID **) &pszText, sizeof(*pszText) * cchText)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Loop through each item, calculating the space each would take
    pszWalk = pszText;
    for (iIndex = 1; iIndex < cItems; iIndex++)
    {
        // Get the space for the item
        iRet = (INT) SendMessage(m_hwndList, LB_GETTEXT, (WPARAM) iIndex, (LPARAM) pszWalk);
        if ((LB_ERR == iRet) || (0 == iRet))
        {
            continue;
        }

        // Count the space needed
        pszWalk += iRet + 1;
    }

    // Add in space for the terminator
    pszWalk[0] = '\0';
    pszWalk[1] = '\0';

    // Set the new string in the blob
    SafeMemFree(pCritItem->propvar.blob.pBlobData);
    pCritItem->propvar.blob.pBlobData = (BYTE *) pszText;
    pszText = NULL;
    pCritItem->propvar.blob.cbSize = sizeof(*pszText) * cchText;
    
    // Set the return value
    fRet = TRUE;
    
exit:
    SafeMemFree(pszText);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _UpdateButtons
//
//  This enables or disables the buttons in the people editor UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void CEditPeopleUI::_UpdateButtons(VOID)
{
    INT         iSelected = 0;
    BOOL        fSelected = FALSE;
    BOOL        fEditable = FALSE;
    INT         cItems = 0;

    Assert(NULL != m_hwndList);

    // Get the currently selected item
    iSelected = (INT) SendMessage(m_hwndList, LB_GETCURSEL, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == iSelected)
    {
        iSelected = -1;
    }
    
    fSelected = (-1 != iSelected);
    fEditable = ((FALSE != fSelected) && (0 != iSelected));
    cItems = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
    
    // Enable the rule action buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcCriteriaRemove, fSelected && fEditable);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcCriteriaOptions, cItems > 1);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, IDOK, cItems > 1);
        
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _AddTagLineToList
//
//  This enables or disables the buttons in the people editor UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::_AddTagLineToList(VOID)
{
    BOOL            fRet = FALSE;
    
    Assert(NULL != m_hwndList);

    fRet = _FAddWordToList(0, " ");
    if (FALSE == fRet)
    {
        goto exit;
    }
    
    // Set the proper return value
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddWordToList
//
//  This enables or disables the buttons in the people editor UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditPeopleUI::_FAddWordToList(DWORD dwFlags, LPCTSTR pszItem)
{
    BOOL            fRet = FALSE;
    int             cItems = 0;
    INT             iRet = 0;
    
    Assert(NULL != m_hwndList);

    // Is there anything to do?
    if ((NULL == pszItem) || (L'\0' == pszItem[0]))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the number of items in the list
    cItems = (INT) SendMessage(m_hwndList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR == cItems)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the data into the list 
    iRet = (INT) SendMessage(m_hwndList, LB_ADDSTRING, (WPARAM) cItems, (LPARAM) pszItem);
    if ((LB_ERR == iRet) || (LB_ERRSPACE == iRet))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the proper return value
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _HrCriteriaEditPeople
//
//  This creates a people editor.
//
//  ppViewMenu - pointer to return the view menu
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the View Menu object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT _HrCriteriaEditPeople(HWND hwnd, CRIT_ITEM * pCritItem)
{
    HRESULT         hr = S_OK;
    CEditPeopleUI * pPeopleUI = NULL;

    // Check the incoming params
    if (NULL == pCritItem)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create the view menu object
    pPeopleUI = new CEditPeopleUI;
    if (NULL == pPeopleUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the view menu
    hr = pPeopleUI->HrInit(hwnd, 0);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Show the UI
    hr = pPeopleUI->HrShow(pCritItem);
    if (FAILED(hr))
    {
        goto exit;
    }

exit:
    if (NULL != pPeopleUI)
    {
        delete pPeopleUI;
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _HrCriteriaEditWords
//
//  This creates a words editor.
//
//  ppViewMenu - pointer to return the view menu
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the View Menu object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT _HrCriteriaEditWords(HWND hwnd, CRIT_ITEM * pCritItem)
{
    HRESULT         hr = S_OK;
    CEditPeopleUI * pPeopleUI = NULL;

    // Check the incoming params
    if (NULL == pCritItem)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create the view menu object
    pPeopleUI = new CEditPeopleUI;
    if (NULL == pPeopleUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the view menu
    hr = pPeopleUI->HrInit(hwnd, PUI_WORDS);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Show the UI
    hr = pPeopleUI->HrShow(pCritItem);
    if (FAILED(hr))
    {
        goto exit;
    }

exit:
    if (NULL != pPeopleUI)
    {
        delete pPeopleUI;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\rulesui.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  RulesUI.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "rulesmgr.h"

// Rules Manager UI Page Base Class
class COERulesPageUI
{
    protected:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_DIRTY         = 0x00000002
        };

    protected:
        UINT    m_uiDlgRscId;
        UINT    m_uiTabLabelId;
        DWORD   m_dwFlags;
        DWORD   m_dwState;
        
    public:
        COERulesPageUI();
        COERulesPageUI(UINT uiDlgRscId, UINT uiTabLabelId, DWORD dwFlags, DWORD dwState) :
                    m_uiDlgRscId(uiDlgRscId), m_uiTabLabelId(uiTabLabelId), m_dwFlags(dwFlags), m_dwState(dwState) {}
        virtual ~COERulesPageUI() {};

        virtual HRESULT HrInit(HWND hwndOwner, DWORD dwFlags) = 0;
        virtual HRESULT HrCommitChanges(DWORD dwFlags, BOOL fClearDirty) = 0;

        // Accessor functions
        UINT UiGetDlgRscId(VOID) {return m_uiDlgRscId;}
        UINT UiGetTabLabelId(VOID) {return m_uiTabLabelId;}
        virtual DLGPROC DlgProcGetPageDlgProc(VOID) = 0;
        BOOL FIsDirty(VOID) {return (0 != (m_dwState & STATE_DIRTY));}
        virtual BOOL FGetRules(RULE_TYPE typeRule, RULENODE ** pprnode) = 0;
};

enum RULEMGR_FLAGS
{
    RMF_MAIL    = 0x00000000,
    RMF_NEWS    = 0x00000001,
    RMF_JUNK    = 0x00000002,
    RMF_SENDERS = 0x00000003
};

// Rules Manager UI Class
class COERulesMgrUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001
        };

        enum
        {
            RULE_DIALOG_PAD     = 0x00000004
        };
        
        enum
        {
            RULE_PAGE_MAIL      = 0x00000000,
            RULE_PAGE_NEWS      = 0x00000001,
            RULE_PAGE_JUNK      = 0x00000002,
            RULE_PAGE_SENDERS   = 0x00000003,
            RULE_PAGE_MAX       = 0x00000004,
            RULE_PAGE_MASK      = 0x000000FF
        };
        
    private:
        HWND                m_hwndOwner;
        DWORD               m_dwFlags;
        DWORD               m_dwState;
        HWND                m_hwndDlg;
        HWND                m_hwndTab;

        COERulesPageUI *    m_rgRuleTab[RULE_PAGE_MAX];
        
    public:
        // Constructor/destructor
        COERulesMgrUI();
        ~COERulesMgrUI();

        // Main UI methods
        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
        HRESULT HrShow(VOID);
        
        // Dialog methods
        static INT_PTR CALLBACK FOERuleMgrDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnNotify(INT iCtl, NMHDR * pnmhdr);
        BOOL FOnDestroy(VOID);
        BOOL FOnGetRules(RULE_TYPE typeRule, RULENODE ** pprnode);
        
    private:
        BOOL _FOnOK(VOID);
        BOOL _FOnCancel(VOID);
        BOOL _FInitTabCtrl(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\rulesmgr.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  RulesMgr.h
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _RULESMGR_H_
#define _RULESMGR_H_

// Bring in only once
#if _MSC_VER > 1000
#pragma once
#endif

#include "oerules.h"

typedef struct tagRULENODE
{
    RULEID                  ridRule;
    IOERule *               pIRule;
    struct tagRULENODE *    pNext;        
} RULENODE, * PRULENODE;
        
const int CCH_REGKEY_MAX    = 4;
const int CCH_RULENAME_MAX  = 256;

class CRulesManager : public IOERulesManager
{
    private:
        enum
        {
            STATE_LOADED_INIT       = 0x00000000,
            STATE_LOADED_MAIL       = 0x00000001,
            STATE_LOADED_NEWS       = 0x00000002,
            STATE_LOADED_SENDERS    = 0x00000004,
            STATE_LOADED_JUNK       = 0x00000008,
            STATE_LOADED_FILTERS    = 0x00000010
        };

        enum
        {
            RTF_INIT            = 0x00000000,
            RTF_DISABLED        = 0x00000001
        };
        
        enum
        {
            ARTF_PREPEND        = 0x00000001,
            ARTF_SENDER         = 0x00000002
        };
        
    private:
        LONG                m_cRef;
        BOOL                m_dwState;
        RULENODE *          m_pMailHead;
        RULENODE *          m_pNewsHead;
        RULENODE *          m_pFilterHead;
        IOERule *           m_pIRuleSenderMail;
        IOERule *           m_pIRuleSenderNews;
        IOERule *           m_pIRuleJunk;
        CRITICAL_SECTION    m_cs;
        
    public:
        // Constructor/destructor
        CRulesManager();
        ~CRulesManager();
        
        // IUnknown members
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IOERulesManager members
        STDMETHODIMP Initialize(DWORD dwFlags);
        STDMETHODIMP GetRule(RULEID ridRule, RULE_TYPE type, DWORD dwFlags, IOERule ** ppIRule);
        STDMETHODIMP FindRule(LPCSTR pszRuleName, RULE_TYPE type, IOERule ** ppIRule);
        STDMETHODIMP GetRules(DWORD dwFlags, RULE_TYPE typeRule, RULEINFO ** ppinfoRule, ULONG * pcpinfoRule);
        STDMETHODIMP SetRules(DWORD dwFlags, RULE_TYPE typeRule, RULEINFO * pinfoRule, ULONG cpinfoRule);
        STDMETHODIMP EnumRules(DWORD dwFlags, RULE_TYPE type, IOEEnumRules ** ppIEnumRules);
        
        STDMETHODIMP GetState(RULE_TYPE type, DWORD dwFlags, DWORD * pdwState) { return E_NOTIMPL; }

        STDMETHODIMP ExecRules(DWORD dwFlags, RULE_TYPE type, IOEExecRules ** ppIExecRules);

        STDMETHODIMP ExecuteRules(RULE_TYPE typeRule, DWORD dwFlags, HWND hwndUI,
                            IOEExecRules * pIExecRules, MESSAGEINFO * pMsgInfo,
                            IMessageFolder * pFolder, IMimeMessage * pIMMsg);
                            
    private:
        HRESULT _HrLoadRules(RULE_TYPE type);
        HRESULT _HrLoadSenders(VOID);
        HRESULT _HrLoadJunk(VOID);
        HRESULT _HrSaveRules(RULE_TYPE type);
        HRESULT _HrSaveSenders(VOID);
        HRESULT _HrSaveJunk(VOID);
        HRESULT _HrFreeRules(RULE_TYPE type);
        HRESULT _HrAddRule(RULEID ridRule, IOERule * pIRule, RULE_TYPE type);
        HRESULT _HrReplaceRule(RULEID ridRule, IOERule * pIRule, RULE_TYPE type);
        HRESULT _HrRemoveRule(IOERule * pIRule, RULE_TYPE type);
        HRESULT _HrFixupRuleInfo(RULE_TYPE typeRule, RULEINFO * pinfoRule, ULONG cpinfoRule);
};

class CEnumRules : public IOEEnumRules
{
    private:
        LONG        m_cRef;
        RULENODE *  m_pNodeHead;
        RULENODE *  m_pNodeCurr;
        DWORD       m_dwFlags;
        RULE_TYPE   m_typeRule;
        
    public:
        // Constructor/destructor
        CEnumRules();
        ~CEnumRules();

        // IUnknown members
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IOEEnumRules members
        STDMETHODIMP Next(ULONG cpIRule, IOERule ** rgpIRule, ULONG * pcpIRuleFetched);
        STDMETHODIMP Skip(ULONG cpIRule);
        STDMETHODIMP Reset(void);
        STDMETHODIMP Clone(IOEEnumRules ** ppIEnumRules);

        HRESULT _HrInitialize(DWORD dwFlags, RULE_TYPE typeRule, RULENODE * pNodeHead);
};

const DWORD ERF_ONLY_ENABLED    = 0x00000001;
const DWORD ERF_ONLY_VALID      = 0x00000002;

class CExecRules : public IOEExecRules
{
    private:
        enum
        {
            RULE_FOLDER_ALLOC = 16   
        };

        struct RULE_FOLDER
        {
            FOLDERID            idFolder;
            IMessageFolder *    pFolder;
        };
        
        enum
        {
            RULE_FILE_ALLOC = 16   
        };

        struct RULE_FILE
        {
            LPSTR       pszFile;
            IStream *   pstmFile;
            DWORD       dwType;
        };
        
        enum
        {
            SND_FILE_ALLOC = 16   
        };

    private:
        LONG            m_cRef;
        RULENODE *      m_pNodeHead;
        ULONG           m_cNode;
        DWORD           m_dwState;
        RULE_FOLDER *   m_pRuleFolder;
        ULONG           m_cRuleFolder;
        ULONG           m_cRuleFolderAlloc;
        RULE_FILE *     m_pRuleFile;
        ULONG           m_cRuleFile;
        ULONG           m_cRuleFileAlloc;
        LPSTR *         m_ppszSndFile;
        ULONG           m_cpszSndFile;
        ULONG           m_cpszSndFileAlloc;
        
    public:
        // Constructor/destructor
        CExecRules() : m_cRef(0), m_pNodeHead(NULL), m_cNode(0), m_dwState(RULE_STATE_NULL),
                        m_pRuleFolder(NULL), m_cRuleFolder(0), m_cRuleFolderAlloc(0),
                        m_pRuleFile(NULL), m_cRuleFile(0), m_cRuleFileAlloc(0),
                        m_ppszSndFile(NULL), m_cpszSndFile(0), m_cpszSndFileAlloc(0) {}
        ~CExecRules();

        // IUnknown members
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IOEExecRules members
        STDMETHODIMP GetState(DWORD * pdwState);

        STDMETHODIMP ExecuteRules(DWORD dwFlags, LPCSTR pszAcct, MESSAGEINFO * pMsgInfo,
                            IMessageFolder * pFolder, IMimePropertySet * pIMPropSet,
                            IMimeMessage * pIMMsg, ULONG cbMsgSize,
                            ACT_ITEM ** ppActions, ULONG * pcActions);
        STDMETHODIMP ReleaseObjects(VOID);
                                            
        STDMETHODIMP GetRuleFolder(FOLDERID idFolder, DWORD_PTR * pdwFolder);
        STDMETHODIMP GetRuleFile(LPCSTR pszFile, IStream ** pstmFile, DWORD * pdwType);
        
        STDMETHODIMP AddSoundFile(DWORD dwFlags, LPCSTR pszSndFile);
        STDMETHODIMP PlaySounds(DWORD dwFlags);

        HRESULT _HrInitialize(DWORD dwFlags, RULENODE * pNodeHead);

    private:
        HRESULT _HrReleaseFolderObjects(VOID);
        HRESULT _HrReleaseFileObjects(VOID);
        HRESULT _HrReleaseSoundFiles(VOID);
};
#endif  // !_RULESMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\rulesui.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  RulesUI.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "rulesui.h"
#include "aplyrule.h"
#include "editrule.h"
#include "ruledesc.h"
#include "ruleutil.h"
#include "rulesmgr.h"
#include "rule.h"
#include "spamui.h"
#include "reutil.h"
#include <rulesdlg.h>
#include <imagelst.h>
#include <newfldr.h>
#include <instance.h>
#include "shlwapip.h" 
#include <demand.h>

// Constants
class COEMailRulesPageUI : public COERulesPageUI
{
    private:
        enum MOVE_DIR {MOVE_RULE_UP = 0, MOVE_RULE_DOWN = 1};

    private:
        HWND                m_hwndOwner;
        HWND                m_hwndDlg;
        HWND                m_hwndList;
        HWND                m_hwndDescript;
        RULE_TYPE           m_typeRule;
        CRuleDescriptUI *   m_pDescriptUI;

    public:
        COEMailRulesPageUI();

        enum INIT_TYPE
        {
            INIT_MAIL   = 0x00000000,
            INIT_NEWS   = 0x00000001
        };
        
        COEMailRulesPageUI(DWORD dwFlagsInit) :
                            COERulesPageUI(iddRulesMail,
                                           (0 != (dwFlagsInit & INIT_NEWS)) ? idsRulesNews : idsRulesMail, 0, 0), 
                            m_hwndOwner(NULL), m_hwndDlg(NULL), m_hwndList(NULL),
                            m_hwndDescript(NULL),
                            m_typeRule((0 != (dwFlagsInit & INIT_NEWS)) ? RULE_TYPE_NEWS : RULE_TYPE_MAIL),
                            m_pDescriptUI(NULL) {}
        virtual ~COEMailRulesPageUI();

        virtual HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
        virtual HRESULT HrCommitChanges(DWORD dwFlags, BOOL fClearDirty);

        static INT_PTR CALLBACK FMailRulesPageDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);

        DLGPROC DlgProcGetPageDlgProc(VOID) {return FMailRulesPageDlgProc;}

        BOOL FGetRules(RULE_TYPE typeRule, RULENODE ** pprnode);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnNotify(INT iCtl, NMHDR * pnmhdr);
        BOOL FOnDestroy(VOID);

    private:
        BOOL _FInitListCtrl(VOID);
        BOOL _FLoadListCtrl(VOID);
        BOOL _FAddRuleToList(DWORD dwIndex, RULEID ridRule, IOERule * pIRule);
        VOID _EnableButtons(INT iSelected);
        VOID _EnableRule(INT iSelected);

        // For dealing with the description field
        VOID _LoadRule(INT iSelected);
        BOOL _FSaveRule(INT iSelected);

        // Functions to deal with the basic actions
        VOID _NewRule(VOID);
        VOID _EditRule(INT iSelected);
        VOID _MoveRule(INT iSelected, MOVE_DIR dir);
        VOID _RemoveRule(INT iSelected);
        VOID _CopyRule(INT iSelected);
        VOID _OnApplyTo(INT iSelected);

        BOOL _FOnLabelEdit(BOOL fBegin, NMLVDISPINFO * pdi);
        BOOL _FOnRuleDescValid(VOID);
};

// Global data
const static HELPMAP g_rgCtxMapRulesMgr[] = {
                       {0, 0}};
                       
const static HELPMAP g_rgCtxMapMailRules[] = {
                        {idbNewRule,            idhNewRule},
                        {idbModifyRule,         idhModifyRule},
                        {idbCopyRule,           idhCopyRule},
                        {idbDeleteRule,         idhRemoveRule},
                        {idbRulesApplyTo,       idhRuleApply},
                        {idbMoveUpRule,         idhRuleUp},
                        {idbMoveDownRule,       idhRuleDown},
                        {idredtRuleDescription, idhRuleDescription},
                        {0, 0}};
                       
COERulesMgrUI::COERulesMgrUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(0), m_hwndDlg(NULL), m_hwndTab(NULL)
{
    ZeroMemory(m_rgRuleTab, sizeof(m_rgRuleTab));
}

COERulesMgrUI::~COERulesMgrUI()
{
    ULONG    ulIndex = 0;
    
    for (ulIndex = 0; ulIndex < RULE_PAGE_MAX; ulIndex++)
    {
        if (NULL != m_rgRuleTab[ulIndex])
        {
            delete m_rgRuleTab[ulIndex];
        }
    }
}

HRESULT COERulesMgrUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == hwndOwner)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    // Create each of the rule pages

    if (!(g_dwAthenaMode & MODE_NEWSONLY))
    {
        // Create the mail page
        m_rgRuleTab[RULE_PAGE_MAIL] = new COEMailRulesPageUI(COEMailRulesPageUI::INIT_MAIL);
        if (NULL == m_rgRuleTab[RULE_PAGE_MAIL])
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }

    // Create the news page
    m_rgRuleTab[RULE_PAGE_NEWS] = new COEMailRulesPageUI(COEMailRulesPageUI::INIT_NEWS);
    if (NULL == m_rgRuleTab[RULE_PAGE_NEWS])
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Create the junk page
    if ((0 == (g_dwAthenaMode & MODE_NEWSONLY)) && (0 != (g_dwAthenaMode & MODE_JUNKMAIL)))
    {
        m_rgRuleTab[RULE_PAGE_JUNK] = new COEJunkRulesPageUI();
        if (NULL == m_rgRuleTab[RULE_PAGE_JUNK])
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }

    // Create the senders page
    m_rgRuleTab[RULE_PAGE_SENDERS] = new COESendersRulesPageUI();
    if (NULL == m_rgRuleTab[RULE_PAGE_SENDERS])
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

HRESULT COERulesMgrUI::HrShow(VOID)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;

    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // We need to load richedit
    if (FALSE == FInitRichEdit(TRUE))
    {
        hr = E_FAIL;
        goto exit;
    }

    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddRulesManager),
                                        m_hwndOwner, (DLGPROC) COERulesMgrUI::FOERuleMgrDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

INT_PTR CALLBACK COERulesMgrUI::FOERuleMgrDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    COERulesMgrUI *         pRulesUI = NULL;

    pRulesUI = (COERulesMgrUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pRulesUI = (COERulesMgrUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pRulesUI);

            if (FALSE == pRulesUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We set the focus
            fRet = FALSE;
            break;

        case WM_COMMAND:
            fRet = pRulesUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;

        case WM_NOTIFY:
            fRet = pRulesUI->FOnNotify((INT) LOWORD(wParam), (NMHDR *) lParam);
            break;

        case WM_DESTROY:
            fRet = pRulesUI->FOnDestroy();
            break;
            
        case WM_OE_GET_RULES:
            fRet = pRulesUI->FOnGetRules((RULE_TYPE) wParam, (RULENODE **) lParam);
            break;
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            fRet = OnContextHelp(hwndDlg, uiMsg, wParam, lParam, g_rgCtxMapRulesMgr);
            break;
    }
    
    exit:
        return fRet;
}

BOOL COERulesMgrUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndTab = GetDlgItem(hwndDlg, idtbRulesTab);
    if (NULL == m_hwndTab)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize tab control
    fRet = _FInitTabCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

BOOL COERulesMgrUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    INT     iSel = 0;
    TCITEM  tcitem = {0};

    switch (iCtl)
    {
        case IDOK:
            if (FALSE != _FOnOK())
            {
                EndDialog(m_hwndDlg, IDOK);
                fRet = TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(m_hwndDlg, IDCANCEL);
            fRet = TRUE;
            break;

        default:
            iSel = TabCtrl_GetCurSel(m_hwndTab);
            if (-1 == iSel)
            {
                fRet = FALSE;
                goto exit;
            }

            tcitem.mask = TCIF_PARAM;
            if (FALSE == TabCtrl_GetItem(m_hwndTab, iSel, &tcitem))
            {
                fRet = FALSE;
                goto exit;
            }

            fRet = !!SendMessage((HWND) (tcitem.lParam), WM_COMMAND, MAKEWPARAM(iCtl, uiNotify), (LPARAM) hwndCtl);
            break;
    }

exit:
    return fRet;
}

BOOL COERulesMgrUI::FOnNotify(INT iCtl, NMHDR * pnmhdr)
{
    BOOL    fRet = FALSE;
    INT     iSel = 0;
    TCITEM  tcitem = {0};
    HWND    hwndDlg = NULL;
    HWND    hwndFocus = NULL;

    switch (pnmhdr->code)
    {
        case TCN_SELCHANGING:
            // Get the window handle for the currently
            // selected tab
            iSel = TabCtrl_GetCurSel(m_hwndTab);
            if (-1 == iSel)
            {
                fRet = FALSE;
                goto exit;
            }

            tcitem.mask = TCIF_PARAM;            
            if (FALSE == TabCtrl_GetItem(m_hwndTab, iSel, &tcitem))
            {
                fRet = FALSE;
                goto exit;
            }

            hwndDlg = (HWND) tcitem.lParam;
            Assert(NULL != hwndDlg);
            
            // Hide and disable the current dialog
            ShowWindow(hwndDlg, SW_HIDE);
            EnableWindow(hwndDlg, FALSE);

            SetDlgMsgResult(hwndDlg, WM_NOTIFY, FALSE);
            
            fRet = TRUE;
            break;

        case TCN_SELCHANGE:
            // Get the window handle for the currently
            // selected tab
            iSel = TabCtrl_GetCurSel(m_hwndTab);
            if (-1 == iSel)
            {
                fRet = FALSE;
                goto exit;
            }

            tcitem.mask = TCIF_PARAM;            
            if (FALSE == TabCtrl_GetItem(m_hwndTab, iSel, &tcitem))
            {
                fRet = FALSE;
                goto exit;
            }

            hwndDlg = (HWND) tcitem.lParam;
            Assert(NULL != hwndDlg);
            
            // Hide and disable the current dialog
            ShowWindow(hwndDlg, SW_SHOW);
            EnableWindow(hwndDlg, TRUE);

            // Set the focus to the first control
            // if the focus isn't in the tab
            hwndFocus = GetFocus();
            if (hwndFocus != m_hwndTab)
            {
                SendMessage(hwndDlg, WM_NEXTDLGCTL, (WPARAM) GetNextDlgTabItem(hwndDlg, NULL, FALSE), (LPARAM) TRUE);
            }
            
            fRet = TRUE;
            break;            
    }

exit:
    return fRet;
}

BOOL COERulesMgrUI::FOnDestroy(VOID)
{
    BOOL    fRet = FALSE;
    UINT    cTabs = 0;
    UINT    uiIndex = 0;
    TC_ITEM tcitem;
    
    // Get the number of tabs
    cTabs = TabCtrl_GetItemCount(m_hwndTab);

    // Initialize the Tab control structure...
    ZeroMemory(&tcitem, sizeof(tcitem));
    tcitem.mask = TCIF_PARAM;

    // Destroy the dialogs from each page
    for (uiIndex = 0; uiIndex < cTabs; uiIndex++)
    {
        // Get the window handle for the dialog
        if (FALSE != TabCtrl_GetItem(m_hwndTab, uiIndex, &tcitem))
        {
            // Destroy the dialog
            DestroyWindow((HWND) tcitem.lParam);
        }
    }

    fRet = TRUE;
    
    return fRet;
}

BOOL COERulesMgrUI::FOnGetRules(RULE_TYPE typeRule, RULENODE ** pprnode)
{
    BOOL        fRet = FALSE;
    RULENODE *  prnodeList = NULL;
    RULENODE *  prnodeSender = NULL;
    RULENODE *  prnodeJunk = NULL;
    RULENODE *  prnodeWalk = NULL;
    
    if (NULL == pprnode)
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize the outgoing param
    *pprnode = NULL;
    
    // Forward the message to the correct dialog
    switch(typeRule)
    {
        case RULE_TYPE_MAIL:
            // Get the rules from the senders page
            if (NULL != m_rgRuleTab[RULE_PAGE_SENDERS])
            {
                fRet = m_rgRuleTab[RULE_PAGE_SENDERS]->FGetRules(RULE_TYPE_MAIL, &prnodeSender);
            }
            
            // Get the rules from the mail rules page
            if (NULL != m_rgRuleTab[RULE_PAGE_MAIL])
            {
                fRet = m_rgRuleTab[RULE_PAGE_MAIL]->FGetRules(RULE_TYPE_MAIL, &prnodeList);
            }
            
            // Get the rules from the junk mail page
            if (NULL != m_rgRuleTab[RULE_PAGE_JUNK])
            {
                fRet = m_rgRuleTab[RULE_PAGE_JUNK]->FGetRules(RULE_TYPE_MAIL, &prnodeJunk);
            }

            break;
            
        case RULE_TYPE_NEWS:
            // Get the rules from the senders page
            if (NULL != m_rgRuleTab[RULE_PAGE_SENDERS])
            {
                fRet = m_rgRuleTab[RULE_PAGE_SENDERS]->FGetRules(RULE_TYPE_NEWS, &prnodeSender);
            }

            // Get the rules from the news rules page
            if (NULL != m_rgRuleTab[RULE_PAGE_NEWS])
            {
                fRet = m_rgRuleTab[RULE_PAGE_NEWS]->FGetRules(RULE_TYPE_NEWS, &prnodeList);
            }
            break;

        default:
            Assert(FALSE);
            fRet = FALSE;
            goto exit;
            break;
    }

    // Set up the list
    if (NULL != prnodeJunk)
    {
        Assert(NULL == prnodeJunk->pNext);

        if (NULL == prnodeList)
        {
            prnodeList = prnodeJunk;
        }
        else
        {
            prnodeWalk = prnodeList;
            while (NULL != prnodeWalk->pNext)
            {
                prnodeWalk = prnodeWalk->pNext;
            }

            prnodeWalk->pNext = prnodeJunk;
        }
        prnodeJunk = NULL;
    }
    
    if (NULL != prnodeSender)
    {
        Assert(NULL == prnodeSender->pNext);

        prnodeSender->pNext = prnodeList;
        prnodeList = prnodeSender;
        prnodeSender = NULL;
    }
    
    // Set the outgoing param
    *pprnode = prnodeList;
    prnodeList = NULL;
    
    // Tell the dialog it's aok to proceed
    SetDlgMsgResult(m_hwndDlg, WM_OE_GET_RULES, TRUE);

    fRet = TRUE;

exit:
    while (NULL != prnodeList)
    {
        prnodeWalk = prnodeList;
        if (NULL != prnodeWalk->pIRule)
        {
            prnodeWalk->pIRule->Release();
        }
        prnodeList = prnodeList->pNext;
        delete prnodeWalk; //MemFree(prnodeWalk);
    }
    if (NULL != prnodeJunk)
    {
        if (NULL != prnodeJunk->pIRule)
        {
            prnodeJunk->pIRule->Release();
        }
        delete prnodeJunk; // MemFree(prnodeJunk);
    }
    if (NULL != prnodeSender)
    {
        if (NULL != prnodeSender->pIRule)
        {
            prnodeSender->pIRule->Release();
        }
        delete prnodeSender; //MemFree(prnodeSender);
    }
    return fRet;
}

BOOL COERulesMgrUI::_FOnOK(VOID)
{
    BOOL    fRet = FALSE;
    UINT    uiRuleTab = 0;
    HRESULT hr = S_OK;

    // Add the tabs to the tab control
    for (uiRuleTab = 0; uiRuleTab < RULE_PAGE_MAX; uiRuleTab++)
    {
        if (NULL == m_rgRuleTab[uiRuleTab])
        {
            continue;
        }
        
        hr = m_rgRuleTab[uiRuleTab]->HrCommitChanges(0, TRUE);
        if ((FAILED(hr)) && (E_UNEXPECTED != hr))
        {
            fRet = FALSE;
            goto exit;
        }
    }

    fRet = TRUE;
    
exit:
    return fRet;
}

BOOL COERulesMgrUI::_FOnCancel(VOID)
{
    return TRUE;
}

BOOL COERulesMgrUI::_FInitTabCtrl(VOID)
{
    BOOL    fRet = FALSE;
    TCITEM  tcitem;
    TCHAR   szRes[CCHMAX_STRINGRES];
    UINT    uiRuleTab = 0;
    HWND    hwndDlg = NULL;
    UINT    cRuleTab = 0;
    UINT    uiDefaultTab = 0;
    NMHDR   nmhdr;

    // Make sure we have a resource dll
    Assert(g_hLocRes);
    
    // Initialize the Tab control structure...
    ZeroMemory(&tcitem, sizeof(tcitem));
    tcitem.mask = TCIF_PARAM | TCIF_TEXT;
    tcitem.pszText = szRes;
    tcitem.iImage = -1;
        

    // Add the tabs to the tab control
    for (uiRuleTab = 0; uiRuleTab < RULE_PAGE_MAX; uiRuleTab++)
    {
        // Initialize each of the pages
        if ((NULL == m_rgRuleTab[uiRuleTab]) || (FAILED(m_rgRuleTab[uiRuleTab]->HrInit(m_hwndDlg, m_dwFlags))))
        {
            continue;
        }
        
        // Create the child dialog for the tab
        hwndDlg = CreateDialogParam(g_hLocRes, MAKEINTRESOURCE(m_rgRuleTab[uiRuleTab]->UiGetDlgRscId()),
                                        m_hwndDlg, m_rgRuleTab[uiRuleTab]->DlgProcGetPageDlgProc(),
                                        (LPARAM) (m_rgRuleTab[uiRuleTab]));
        if (NULL == hwndDlg)
        {
            continue;
        }
        tcitem.lParam = (LPARAM) hwndDlg;
        
        // Load in the display string for the tab
        LoadString(g_hLocRes, m_rgRuleTab[uiRuleTab]->UiGetTabLabelId(), szRes, ARRAYSIZE(szRes));
        
        // Insert the tab
        TabCtrl_InsertItem(m_hwndTab, cRuleTab, &tcitem);

        // Save off the default tab
        if (uiRuleTab == (m_dwFlags & RULE_PAGE_MASK))
        {
            uiDefaultTab = cRuleTab;
        }
        
        cRuleTab++;
    }    

    if (0 == cRuleTab)
    {
        fRet = FALSE;
        goto exit;
    }

    // Select the proper tab
    if (-1 != TabCtrl_SetCurSel(m_hwndTab, uiDefaultTab))
    {
        nmhdr.hwndFrom = m_hwndTab;
        nmhdr.idFrom = idtbRulesTab;
        nmhdr.code = TCN_SELCHANGE;
        SideAssert(FALSE != FOnNotify(idtbRulesTab, &nmhdr));
    }

    // Need to set the tab control to the bottom of the Z-order
    // to prevent overlapping redraws
    SetWindowPos(m_hwndTab, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

    // We worked
    fRet = TRUE;

exit:
    return fRet;
}

// Default destructor for the Mail Rules UI
COEMailRulesPageUI::~COEMailRulesPageUI()
{
    if (NULL != m_pDescriptUI)
    {
        delete m_pDescriptUI;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes the mail rules UI dialog
//
//  hwndOwner   - the handle to the owner window of this dialog
//  dwFlags     - modifiers on how this dialog should act
//
//  Returns:    S_OK, if it was successfully initialized
//
///////////////////////////////////////////////////////////////////////////////
HRESULT COEMailRulesPageUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == hwndOwner)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    // Setup the description field
    m_pDescriptUI = new CRuleDescriptUI;
    if (NULL == m_pDescriptUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrCommitChanges
//
//  This commits the changes to the rules
//
//  dwFlags     - modifiers on how we should commit the changes
//  fClearDirty - should we clear the dirty state
//
//  Returns:    S_OK, if it was successfully committed
//
///////////////////////////////////////////////////////////////////////////////
HRESULT COEMailRulesPageUI::HrCommitChanges(DWORD dwFlags, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    LONG        cRules = 0;
    INT         iSelected = 0;
    RULEINFO *  pinfoRule = NULL;
    ULONG       cpinfoRule = 0;
    LVITEM      lvitem = {0};

    Assert(NULL != m_hwndList);
    
    // Check incoming params
    if (0 != dwFlags)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Fail if we weren't initialized
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // If we aren't dirty, then there's
    // nothing to do
    if ((0 == (m_dwState & STATE_DIRTY)) && (S_OK != m_pDescriptUI->HrIsDirty()))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Get the number of rules in the list view
    cRules = ListView_GetItemCount(m_hwndList);

    if (0 != cRules)
    {
        // Let's make sure the selected rule is saved...
        iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
        if (-1 != iSelected)
        {
            _FSaveRule(iSelected);
        }

        // Allocate space to hold the rules        
        hr = HrAlloc( (void **) &pinfoRule, cRules * sizeof(*pinfoRule));
        if (FAILED(hr))
        {
            goto exit;
        }

        ZeroMemory(pinfoRule, cRules * sizeof(*pinfoRule));

        lvitem.mask = LVIF_PARAM;
        
        cpinfoRule = 0;
        for (lvitem.iItem = 0; lvitem.iItem < cRules; lvitem.iItem++)
        {
            // Grab the rule from the list view
            if (FALSE != ListView_GetItem(m_hwndList, &lvitem))
            {
                if (NULL == lvitem.lParam)
                {
                    continue;
                }
                
                pinfoRule[cpinfoRule] = *((RULEINFO *) (lvitem.lParam));
                cpinfoRule++;
            }   
        }
    }
    
    // Set the rules into the rules manager
    hr = g_pRulesMan->SetRules(SETF_CLEAR, m_typeRule, pinfoRule, cpinfoRule);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Should we clear the dirty state
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~STATE_DIRTY;
    }
    
    hr = S_OK;
    
exit:
    SafeMemFree(pinfoRule);
    return hr;
}

INT_PTR CALLBACK COEMailRulesPageUI::FMailRulesPageDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    COEMailRulesPageUI *    pMailUI = NULL;
    HWND                    hwndRE = 0;

    pMailUI = (COEMailRulesPageUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pMailUI = (COEMailRulesPageUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pMailUI);

            hwndRE = CreateREInDialogA(hwndDlg, idredtRuleDescription);

            if (!hwndRE || (FALSE == pMailUI->FOnInitDialog(hwndDlg)))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;

        case WM_COMMAND:
            fRet = pMailUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;

        case WM_NOTIFY:
            fRet = pMailUI->FOnNotify((INT) LOWORD(wParam), (NMHDR *) lParam);
            break;

        case WM_DESTROY:
            fRet = pMailUI->FOnDestroy();
            break;

        case WM_HELP:
        case WM_CONTEXTMENU:
            fRet = OnContextHelp(hwndDlg, uiMsg, wParam, lParam, g_rgCtxMapMailRules);
            break;
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FGetRules
//
//  This brings up the edit UI for the selected rule from the mail rules list
//
//  fBegin  - is this for the LVN_BEGINLABELEDIT notification
//  pdi     - the display info for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::FGetRules(RULE_TYPE typeRule, RULENODE ** pprnode)
{
    BOOL            fRet = FALSE;
    INT             iSelected = 0;
    INT             cRules = 0;
    LVITEM          lvitem;
    IOERule *       pIRule = NULL;
    RULENODE *      prnodeNew = NULL;
    RULENODE *      prnodeList = NULL;
    RULENODE *      prnodeWalk = NULL;
    HRESULT         hr = S_OK;
    RULEINFO *      pinfoRule = NULL;

    Assert(NULL != m_hwndList);

    if (NULL == pprnode)
    {
        fRet = FALSE;
        goto exit;
    }

    // Fail if we weren't initialized
    if ((0 == (m_dwState & STATE_INITIALIZED)) || (NULL == m_hwndList))
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize the outgoing param
    *pprnode = NULL;
    
    // Get the selected item
    iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);

    // Make sure we don't loose any changes
    _FSaveRule(iSelected);
    
    // Check the count of items in the list view
    cRules = ListView_GetItemCount(m_hwndList);
    if (0 == cRules)
    {
        fRet = TRUE;
        goto exit;
    }
    
    // Initialize the list view item
    ZeroMemory(&lvitem, sizeof(lvitem));
    lvitem.mask = LVIF_PARAM | LVIF_STATE;
    lvitem.stateMask = LVIS_STATEIMAGEMASK;

    // Create the list of rules
    for (lvitem.iItem = 0; lvitem.iItem < cRules; lvitem.iItem++)
    {
        // Grab the rule from the listview
        if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
        {
            fRet = FALSE;
            goto exit;
        }
        pinfoRule = (RULEINFO *) (lvitem.lParam);

        if ((NULL == pinfoRule) || (NULL == pinfoRule->pIRule))
        {
            continue;
        }

        
        // Skip over invalid rules
        hr = pinfoRule->pIRule->Validate(0);
        if (FAILED(hr) || (S_FALSE == hr))
        {
            continue;
        }

        // Create a new rule node
        prnodeNew = new RULENODE;
        if (NULL == prnodeNew)
        {
            fRet = FALSE;
            goto exit;
        }

        prnodeNew->pNext = NULL;
        prnodeNew->pIRule = pinfoRule->pIRule;
        prnodeNew->pIRule->AddRef();

        // Add the new node to the list
        if (NULL == prnodeWalk)
        {
            prnodeList = prnodeNew;
        }
        else
        {
            prnodeWalk->pNext = prnodeNew;
        }
        prnodeWalk = prnodeNew;
        prnodeNew = NULL;        
    }

    // Set the outgoing param
    *pprnode = prnodeList;
    prnodeList = NULL;
    
    fRet = TRUE;
    
exit:
    while (NULL != prnodeList)
    {
        prnodeWalk = prnodeList;
        if (NULL != prnodeWalk->pIRule)
        {
            prnodeWalk->pIRule->Release();
        }
        prnodeList = prnodeList->pNext;
        delete prnodeWalk; //MemFree(prnodeWalk);
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the mail rules UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    TCHAR           szRes[CCHMAX_STRINGRES];
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we haven't been initialized yet...
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndList = GetDlgItem(hwndDlg, idlvRulesList);
    m_hwndDescript = GetDlgItem(hwndDlg, idredtRuleDescription);
    if ((NULL == m_hwndList) || (NULL == m_hwndDescript))
    {
        fRet = FALSE;
        goto exit;
    }

    // We need to change the title if we are a news page
    if (RULE_TYPE_NEWS == m_typeRule)
    {
        if (0 == LoadString(g_hLocRes, idsRuleTitleNews, szRes, ARRAYSIZE(szRes)))
        {
            goto exit;
        }

        SetDlgItemText(m_hwndDlg, idcRuleTitle, szRes);
    }
    else
    {
        if (FALSE != FIsIMAPOrHTTPAvailable())
        {
            AthLoadString(idsRulesNoIMAP, szRes, sizeof(szRes));

            SetDlgItemText(m_hwndDlg, idcRuleTitle, szRes);
        }
    }
    
    if (FAILED(m_pDescriptUI->HrInit(m_hwndDescript, 0)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize the list view
    fRet = _FInitListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Load the list view
    fRet = _FLoadListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Check to see if the list is empty
    if (0 == ListView_GetItemCount(m_hwndList))
    {
        if (((m_typeRule == RULE_TYPE_MAIL) && (RMF_MAIL == m_dwFlags)) ||
                    ((m_typeRule == RULE_TYPE_NEWS) && (RMF_NEWS == m_dwFlags)))
        {
            PostMessage(m_hwndDlg, WM_COMMAND, MAKEWPARAM(idbNewRule, 0), (LPARAM) (GetDlgItem(m_hwndDlg, idbNewRule)));
        }
    }

    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the mail rules UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    LVITEM  lvitem;
    INT     iSelected = 0;

    // We only handle menu and accelerator commands
    if ((0 != uiNotify) && (1 != uiNotify))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch (iCtl)
    {
        case idbNewRule:
            _NewRule();
            fRet = TRUE;
            break;

        case idbModifyRule:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Bring up the rule editor for that item
                _EditRule(iSelected);
                fRet = TRUE;
            }
            break;

        case idbMoveUpRule:
        case idbMoveDownRule:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Move the rule in the desired direction
                _MoveRule(iSelected, (idbMoveUpRule == iCtl) ? MOVE_RULE_UP : MOVE_RULE_DOWN);
                fRet = TRUE;
            }
            break;

        case idbDeleteRule:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Remove the rule from the list
                _RemoveRule(iSelected);
                fRet = TRUE;
            }
            break;
            
        case idbCopyRule:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Copy the rule from the list
                _CopyRule(iSelected);
                fRet = TRUE;
            }
            break;
            
        case idbRulesApplyTo:
            // Apply the rule from the list
            _OnApplyTo(ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED));
            fRet = TRUE;
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnNotify
//
//  This handles the WM_NOTIFY message for the mail rules UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::FOnNotify(INT iCtl, NMHDR * pnmhdr)
{
    BOOL            fRet = FALSE;
    NMLISTVIEW *    pnmlv = NULL;
    NMLVKEYDOWN *   pnmlvkd = NULL;
    INT             iSelected = 0;
    LVHITTESTINFO   lvh;

    // We only handle notifications for the list control
    // or the desscription field
    if ((idlvRulesList != pnmhdr->idFrom) && (idredtRuleDescription != pnmhdr->idFrom))
    {
        fRet = FALSE;
        goto exit;
    }
    
    pnmlv = (LPNMLISTVIEW) pnmhdr;

    switch (pnmlv->hdr.code)
    {
        case NM_CLICK:
            // Did we click on an item?
            if (-1 != pnmlv->iItem)
            {
                ZeroMemory(&lvh, sizeof(lvh));
                lvh.pt = pnmlv->ptAction;
                iSelected = ListView_HitTest(m_hwndList, &lvh);
                if (-1 != iSelected)
                {
                    // Did we click on the enable field?
                    if ((0 != (lvh.flags & LVHT_ONITEMSTATEICON)) &&
                            (0 == (lvh.flags & LVHT_ONITEMLABEL)))
                    
                    {
                        // Make sure this item is selected
                        ListView_SetItemState(m_hwndList, iSelected,
                                        LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                        
                        // Set the proper enable state                        
                        _EnableRule(iSelected);
                    }
                }
            }
            else
            {
                // We clicked outside the list

                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
          
        case NM_DBLCLK:
            // Did we click on an item?
            if (-1 != pnmlv->iItem)
            {
                ZeroMemory(&lvh, sizeof(lvh));
                lvh.pt = pnmlv->ptAction;
                iSelected = ListView_HitTest(pnmlv->hdr.hwndFrom, &lvh);
                if (-1 != iSelected)
                {
                    // Did we click on the rule name?
                    if (0 != (lvh.flags & LVHT_ONITEMLABEL))
                    {
                        // Edit the rule
                        _EditRule(iSelected);
                    }
                }
            }
            else
            {
                // We clicked outside the list
                
                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
        case LVN_ITEMCHANGED:
            // If an item's state changed to selected..
            if ((-1 != pnmlv->iItem) &&
                        (0 != (pnmlv->uChanged & LVIF_STATE)) &&
                        (0 == (pnmlv->uOldState & LVIS_SELECTED)) &&
                        (0 != (pnmlv->uNewState & LVIS_SELECTED)))
            {
                // Enable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
        case LVN_ITEMCHANGING:
            // If an item's state changed to unselected..
            if ((-1 != pnmlv->iItem) &&
                        (0 != (pnmlv->uChanged & LVIF_STATE)) &&
                        (0 != (pnmlv->uOldState & LVIS_SELECTED)) &&
                        (0 == (pnmlv->uNewState & LVIS_SELECTED)))
            {
                // Save off the rule changes
                _FSaveRule(pnmlv->iItem);
            }
            break;
            
        case LVN_KEYDOWN:
            pnmlvkd = (NMLVKEYDOWN *) pnmhdr;

            // The space key changes the enable state of a rule
            if (VK_SPACE == pnmlvkd->wVKey)
            {
                // Are we on a rule?
                iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (-1 != iSelected)
                {
                    // Change the enable state of the rule
                    _EnableRule(iSelected);
                }
            }
            // The delete key removes the rule from the list view
            else if (VK_DELETE == pnmlvkd->wVKey)
            {
                // Are we on a rule?
                iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (-1 != iSelected)
                {
                    // Remove the rule from the list
                    _RemoveRule(iSelected);
                }
            }
            break;
            
        case LVN_BEGINLABELEDIT:
        case LVN_ENDLABELEDIT:
            fRet = _FOnLabelEdit((LVN_BEGINLABELEDIT == pnmlv->hdr.code), (NMLVDISPINFO *) pnmhdr);
            break;

        case NM_RULE_CHANGED:
            fRet = _FOnRuleDescValid();
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnDestroy
//
//  This handles the WM_DESTROY message for the mail rules UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::FOnDestroy(VOID)
{
    BOOL        fRet = FALSE;
    UINT        cRules = 0;
    UINT        uiIndex = 0;
    LVITEM      lvitem = {0};
    UNALIGNED   RULEINFO *  pIRuleInfo = NULL;

    Assert(m_hwndList);
    
    // Get the number of rules in the list view
    cRules = ListView_GetItemCount(m_hwndList);

    // Initialize to get the rule interface from the list view
    lvitem.mask = LVIF_PARAM;

    // Release each of the rules from the list view
    for (uiIndex = 0; uiIndex < cRules; uiIndex++)
    {
        lvitem.iItem = uiIndex;
        
        // Get the rule interface
        if (FALSE != ListView_GetItem(m_hwndList, &lvitem))
        {
            pIRuleInfo = (UNALIGNED RULEINFO *) (lvitem.lParam);

            if (NULL != pIRuleInfo)
            {
                // Release the rule
                if (NULL != pIRuleInfo->pIRule)
                {
                    pIRuleInfo->pIRule->Release();
                }
                delete pIRuleInfo; // MemFree(pIRuleInfo);
            }
        }
    }

    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInitListCtrl
//
//  This initializes the list view control in the mail rules dialog
//
//  Returns:    TRUE, on successful initialization
//              FALSE, otherwise.
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::_FInitListCtrl(VOID)
{
    BOOL        fRet = FALSE;
    LVCOLUMN    lvc;
    RECT        rc;
    HIMAGELIST  himl = NULL;

    Assert(NULL != m_hwndList);
    
    // Initialize the list view structure
    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask = LVCF_WIDTH;

    // Calculate the size of the list view
    GetClientRect(m_hwndList, &rc);
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    ListView_InsertColumn(m_hwndList, 0, &lvc);
    
    // Set the state image list
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idb16x16st), 16, 0, RGB(255, 0, 255));
    if (NULL != himl)
    {
        ListView_SetImageList(m_hwndList, himl, LVSIL_STATE);
    }

    // Full row selection on listview
    ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT);

    // We worked
    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadListCtrl
//
//  This loads the list view with the current Mail rules
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::_FLoadListCtrl(VOID)
{
    BOOL            fRet = FALSE;
    HRESULT         hr =    S_OK;
    DWORD           dwListIndex = 0;
    RULEINFO *      pinfoRules = NULL;
    ULONG           cpinfoRules = 0;
    ULONG           ulIndex = 0;
    IOERule *       pIRule = NULL;

    Assert(NULL != m_hwndList);

    // Get the Rules enumerator
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->GetRules(GETF_EDIT, m_typeRule, &pinfoRules, &cpinfoRules);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Remove all the items from the list control
    ListView_DeleteAllItems(m_hwndList);

    // Add each filter to the list
    dwListIndex = 0;

    for (ulIndex = 0; ulIndex < cpinfoRules; ulIndex++)
    {
        // Make a copy of the rule
        hr = pinfoRules[ulIndex].pIRule->Clone(&pIRule);
        if (FAILED(hr))
        {
            continue;
        }
        
        // Add filter to the list
        if (FALSE != _FAddRuleToList(dwListIndex, pinfoRules[ulIndex].ridRule, pIRule))
        {
            dwListIndex++;
        }

        SafeRelease(pIRule);
    }

    // Select the first item in the list
    if (0 != dwListIndex)
    {
        ListView_SetItemState(m_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
    
    // Enable the dialog buttons.
    _EnableButtons((0 != dwListIndex) ? 0 : -1);

    fRet = TRUE;
    
exit:
    SafeRelease(pIRule);
    if (NULL != pinfoRules)
    {
        for (ulIndex = 0; ulIndex < cpinfoRules; ulIndex++)
        {
            pinfoRules[ulIndex].pIRule->Release();
        }
        MemFree(pinfoRules);
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddRuleToList
//
//  This adds the filter passed in to the list view
//
//  dwIndex - the index on where to add the filter to into the list
//  rhdlTag - the rule handle for the new rule
//  pIRule  - the actual rule
//
//  Returns:    TRUE, if it was successfully added
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::_FAddRuleToList(DWORD dwIndex, RULEID ridRule, IOERule * pIRule)
{
    BOOL        fRet = FALSE;
    HRESULT     hr = S_OK;
    PROPVARIANT propvar = {0};
    LVITEM      lvitem = {0};
    BOOL        fNotValid = FALSE;
    BOOL        fDisabled = FALSE;
    RULEINFO *  pinfoRule = NULL;

    Assert(NULL != m_hwndList);

    // If there's nothing to do...
    if (NULL == pIRule)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Is it disabled?    
    hr = pIRule->GetProp(RULE_PROP_DISABLED, 0, &propvar);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    fDisabled = !!propvar.boolVal;
    
    // Need to check if the rule is valid
    hr = pIRule->Validate(0);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    fNotValid = (hr == S_FALSE);

    // Find out the name of the filter
    hr = pIRule->GetProp(RULE_PROP_NAME , 0, &propvar);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Allocate space for the rule
    pinfoRule = new RULEINFO;
    if (NULL == pinfoRule)
    {
        fRet = FALSE;
        goto exit;
    }

    // Set up the value
    pinfoRule->ridRule = ridRule;
    pinfoRule->pIRule = pIRule;
    pinfoRule->pIRule->AddRef();
    
    // Add in the image and rule interface
    lvitem.mask = LVIF_PARAM | LVIF_STATE | LVIF_TEXT;
    lvitem.iItem = dwIndex;
    // Need to change the state to mark the rule as invalid
    if (FALSE != fNotValid)
    {
        lvitem.state = INDEXTOSTATEIMAGEMASK(iiconStateInvalid + 1);
    }
    else
    {
        lvitem.state = fDisabled ? INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1) :
                                INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1);
    }
    lvitem.stateMask = LVIS_STATEIMAGEMASK;
    lvitem.pszText = propvar.pszVal;
    lvitem.cchTextMax = lstrlen(propvar.pszVal) + 1;
    lvitem.lParam = (LPARAM) pinfoRule;

    if (-1 == ListView_InsertItem(m_hwndList, &lvitem))
    {
        fRet = FALSE;
        goto exit;
    }

    fRet = TRUE;
    
exit:
    PropVariantClear(&propvar);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableButtons
//
//  This enables or disables the buttons in the Mail rules UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEMailRulesPageUI::_EnableButtons(INT iSelected)
{
    int         cRules = 0;
    BOOL        fSelected = FALSE;
    BOOL        fEnDisUp = FALSE;
    BOOL        fEnDisDown = FALSE;
    LVITEM      lvitem = {0};
    IOERule *   pIRule = NULL;

    Assert(NULL != m_hwndList);

    // Load the description field
    _LoadRule(iSelected);
    
    // Check the count of items in the list view
    cRules = ListView_GetItemCount(m_hwndList);

    fSelected = (-1 != iSelected);
    
    // If we have rules and the top rule isn't selected
    fEnDisUp = ((1 < cRules) &&  (0 != iSelected) && (FALSE != fSelected));

    // If we have rules and the bottom rule ins't selected
    fEnDisDown = ((1 < cRules) &&  ((cRules - 1) != iSelected) && (FALSE != fSelected));

    // Enable the up/down buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbMoveDownRule, fEnDisDown);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbMoveUpRule, fEnDisUp);

    // Enable the rule action buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbDeleteRule, fSelected);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbCopyRule, fSelected);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbModifyRule, fSelected);
        
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableRule
//
//  This switches the current enabled state of the list view item
//  and updates the UI
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEMailRulesPageUI::_EnableRule(int iSelected)
{
    HRESULT     hr = S_OK;
    LVITEM      lvi = {0};
    IOERule *   pIRule = NULL;
    BOOL        fEnabled = FALSE;
    PROPVARIANT propvar;

    // Grab the list view item
    lvi.mask = LVIF_PARAM | LVIF_STATE;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    lvi.iItem = iSelected;
    if (FALSE == ListView_GetItem(m_hwndList, &lvi))
    {
        goto exit;
    }
    
    pIRule = ((RULEINFO *) (lvi.lParam))->pIRule;

    // Let's make sure we can enable this rule
    hr = m_pDescriptUI->HrVerifyRule();
    if (S_OK != hr)
    {
        // Put up a message saying something is busted
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        MAKEINTRESOURCEW(idsRulesErrorEnable), NULL,
                        MB_OK | MB_ICONINFORMATION);
        goto exit;
    }

    // Get the new enabled value
    fEnabled = (lvi.state != INDEXTOSTATEIMAGEMASK(iiconStateChecked+1));

    // Set the UI to the opposite enabled state
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_STATE;
    lvi.iItem = iSelected;
    lvi.state = fEnabled ? INDEXTOSTATEIMAGEMASK(iiconStateChecked+1) :
                            INDEXTOSTATEIMAGEMASK(iiconStateUnchecked+1);
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    ListView_SetItem(m_hwndList, &lvi);
    
    // Set the enabled property
    ZeroMemory(&propvar, sizeof(propvar));
    propvar.vt = VT_BOOL;
    propvar.boolVal = !fEnabled;
    hr = pIRule->SetProp(RULE_PROP_DISABLED, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Tell the description field about it
    m_pDescriptUI->HrSetEnabled(fEnabled);
    
    // Redraw the string the new rule
    m_pDescriptUI->ShowDescriptionString();
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _LoadRule
//
//  This loads the selected rule into the description field.
//  If there isn't a selected rule, then the description field is cleared.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEMailRulesPageUI::_LoadRule(INT iSelected)
{
    LVITEM      lvi = {0};
    IOERule *   pIRule = NULL;

    Assert(NULL != m_hwndList);
    Assert(NULL != m_pDescriptUI);

    // Grab the rule from the list view
    if (-1 != iSelected)
    {
        lvi.iItem = iSelected;
        lvi.mask = LVIF_PARAM;
        if (FALSE != ListView_GetItem(m_hwndList, &lvi))
        {
            pIRule = ((RULEINFO *) (lvi.lParam))->pIRule;
        }        
    }

    // Have the description field load this rule
    m_pDescriptUI->HrSetRule(m_typeRule, pIRule);

    // Display the new rule
    m_pDescriptUI->ShowDescriptionString();

    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSaveRule
//
//  This checks to see if the rule has been changed in the description
//  area and if it has, then it warns the user and changes the text
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    TRUE, if the rule either didn't change or did change without problems
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::_FSaveRule(int iSelected)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    LVITEM          lvi = {0};
    IOERule *       pIRule = NULL;
    PROPVARIANT     propvar = {0};
    CRIT_ITEM *     pCritItem = NULL;
    ULONG           cCritItem = 0;
    ACT_ITEM *      pActItem = NULL;
    ULONG           cActItem = 0;

    // If the rule didn't change, then we're done
    hr = m_pDescriptUI->HrIsDirty();
    if (S_OK != hr)
    {
        fRet = (S_FALSE == hr);
        goto exit;
    }
    
    // Grab the list view item
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iSelected;
    if (FALSE == ListView_GetItem(m_hwndList, &lvi))
    {
        fRet = FALSE;
        goto exit;
    }
    
    pIRule = ((RULEINFO *) (lvi.lParam))->pIRule;

    // Get the criteria from the rule
    hr = m_pDescriptUI->HrGetCriteria(&pCritItem, &cCritItem);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the actions for the rule
    hr = m_pDescriptUI->HrGetActions(&pActItem, &cActItem);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the criteria from the rule
    PropVariantClear(&propvar);
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cCritItem * sizeof(CRIT_ITEM);
    propvar.blob.pBlobData = (BYTE *) pCritItem;
    hr = pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the actions for the rule
    PropVariantClear(&propvar);
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cActItem * sizeof(ACT_ITEM);
    propvar.blob.pBlobData = (BYTE *) pActItem;
    hr = pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
    
    // Make sure we clear out the fact that we saved the rule
    m_pDescriptUI->HrClearDirty();
    
    // Set the proper return value
    fRet = TRUE;

exit:
    RuleUtil_HrFreeCriteriaItem(pCritItem, cCritItem);
    SafeMemFree(pCritItem);
    RuleUtil_HrFreeActionsItem(pActItem, cActItem);
    SafeMemFree(pActItem);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _NewRule
//
//  This brings up a fresh rules editor
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEMailRulesPageUI::_NewRule(VOID)
{
    HRESULT         hr = S_OK;
    IOERule *       pIRule = NULL;
    TCHAR           szRes[CCHMAX_STRINGRES + 5];
    ULONG           cchRes = 0;
    ULONG           ulIndex = 0;
    TCHAR           szName[CCHMAX_STRINGRES + 5];
    LVFINDINFO      lvfinfo = {0};
    PROPVARIANT     propvar = {0};
    CEditRuleUI *   pEditRuleUI = NULL;
    LONG            cRules = 0;
    UINT            uiStrId = 0;
       
    // Create a new rule object
    if (FAILED(HrCreateRule(&pIRule)))
    {
        goto exit;
    }

    // Figure out the string Id
    if (RULE_TYPE_NEWS == m_typeRule)
    {
        uiStrId = idsRuleNewsDefaultName;
    }
    else
    {
        uiStrId = idsRuleMailDefaultName;
    }
    
    // Figure out the name of the new rule ...
    cchRes = LoadString(g_hLocRes, uiStrId, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    ulIndex = 1;
    wsprintf(szName, szRes, ulIndex);

    lvfinfo.flags = LVFI_STRING;
    lvfinfo.psz = szName;
    while (-1 != ListView_FindItem(m_hwndList, -1, &lvfinfo))
    {
        ulIndex++;
        wsprintf(szName, szRes, ulIndex);
    }

    propvar.vt = VT_LPSTR;
    propvar.pszVal = szName;

    hr = pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create a rules editor object
    pEditRuleUI = new CEditRuleUI;
    if (NULL == pEditRuleUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditRuleUI->HrInit(m_hwndDlg, ERF_NEWRULE, m_typeRule, pIRule, NULL)))
    {
        goto exit;
    }

    // Bring up the rules editor UI
    hr = pEditRuleUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    if (S_OK == hr)
    {
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;
        
        // Add the rule to the manager UI
        cRules = ListView_GetItemCount(m_hwndList);
        
        _FAddRuleToList(cRules, RULEID_INVALID, pIRule);

        // Make sure the new item is selected
        ListView_SetItemState(m_hwndList, cRules, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

        // Make sure the new item is visible
        ListView_EnsureVisible(m_hwndList, cRules, FALSE);
    }
    
exit:
    SafeRelease(pIRule);
    if (NULL != pEditRuleUI)
    {
        delete pEditRuleUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EditRule
//
//  This brings up the edit UI for the selected rule from the mail rules list
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEMailRulesPageUI::_EditRule(int iSelected)
{
    HRESULT         hr = S_OK;
    LVITEM          lvitem = {0};
    IOERule *       pIRule = NULL;
    CEditRuleUI *   pEditRuleUI = NULL;
    PROPVARIANT     propvar = {0};
    BOOL            fNotValid = FALSE;
    BOOL            fDisabled = FALSE;

    Assert(NULL != m_hwndList);
    
    // Make sure we don't loose any changes
    _FSaveRule(iSelected);

    // Grab the rule from the list view
    lvitem.iItem = iSelected;
    lvitem.mask = LVIF_PARAM;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }   

    pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
    if (NULL == pIRule)
    {
        goto exit;
    }

    // Create the rules editor
    pEditRuleUI = new CEditRuleUI;
    if (NULL == pEditRuleUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditRuleUI->HrInit(m_hwndDlg, 0, m_typeRule, pIRule, NULL)))
    {
        goto exit;
    }

    // Bring up the rules editor UI
    hr = pEditRuleUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    // If the rule changed, make sure we reload the description field
    if (S_OK == hr)
    {
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;

        ZeroMemory(&lvitem, sizeof(lvitem));
        lvitem.mask = LVIF_STATE;
        lvitem.stateMask = LVIS_STATEIMAGEMASK;
        lvitem.iItem = iSelected;
        
        // Is it disabled?    
        hr = pIRule->GetProp(RULE_PROP_DISABLED , 0, &propvar);
        if (FAILED(hr))
        {
            goto exit;
        }

        fDisabled = !!propvar.boolVal;
        
        // Need to check if the rule is valid
        hr = pIRule->Validate(0);
        if (FAILED(hr))
        {
            goto exit;
        }

        fNotValid = (hr == S_FALSE);

        // Grab the rule name
        PropVariantClear(&propvar);
        hr = pIRule->GetProp(RULE_PROP_NAME, 0, &propvar);
        if (FAILED(hr))
        {
            goto exit;
        }

        if ((VT_LPSTR == propvar.vt) && (NULL != propvar.pszVal) && ('\0' != propvar.pszVal[0]))
        {
            lvitem.mask |= LVIF_TEXT;
            lvitem.pszText = propvar.pszVal;
            lvitem.cchTextMax = lstrlen(propvar.pszVal) + 1;
        }

        // Grab the rule state
        
        // Need to change the state to mark the rule as invalid
        if (FALSE != fNotValid)
        {
            lvitem.state = INDEXTOSTATEIMAGEMASK(iiconStateInvalid + 1);
        }
        else
        {
            lvitem.state = fDisabled ? INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1) :
                                    INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1);
        }
        
        if (-1 == ListView_SetItem(m_hwndList, &lvitem))
        {
            goto exit;
        }
        
        _EnableButtons(iSelected);
    }
    
exit:
    PropVariantClear(&propvar);
    if (NULL != pEditRuleUI)
    {
        delete pEditRuleUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _MoveRule
//
//  This moves the selected rule in the desired direction
//
//  iSelected   - index of the item in the listview to work on
//  dir         - the direction to move the item
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEMailRulesPageUI::_MoveRule(INT iSelected, MOVE_DIR dir)
{
    LVITEM      lvitem = {0};
    TCHAR       szName[CCHMAX_STRINGRES];
    IOERule *   pIRule = NULL;
    int         nIndexNew = 0;
    
    Assert(NULL != m_hwndList);

    // Grab the rule from the list view
    szName[0] = '\0';
    lvitem.iItem = iSelected;
    lvitem.mask = LVIF_STATE | LVIF_PARAM | LVIF_TEXT;
    lvitem.stateMask = LVIS_SELECTED | LVIS_FOCUSED | LVIS_STATEIMAGEMASK;
    lvitem.pszText = szName;
    lvitem.cchTextMax = ARRAYSIZE(szName);
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }

    pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
    
    // Update the item in the list view

    // Get the info for the new index
    nIndexNew = iSelected;
    nIndexNew += (MOVE_RULE_UP == dir) ? -1 : 2;

    // Insert the new index
    lvitem.iItem = nIndexNew;
    if (-1 == ListView_InsertItem(m_hwndList, &lvitem))
    {
        goto exit;
    }

    // Ensure the new item is visible
    ListView_EnsureVisible(m_hwndList, nIndexNew, FALSE);
    ListView_RedrawItems(m_hwndList, nIndexNew, nIndexNew);

    // If we moved up, then the old item is now one lower than before
    if (MOVE_RULE_UP == dir)
    {
        iSelected++;
    }

    // Remove the old item
    if (FALSE == ListView_DeleteItem(m_hwndList, iSelected))
    {
        goto exit;
    }

    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _RemoveRule
//
//  This removes the selected rule from the mail rules list
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEMailRulesPageUI::_RemoveRule(int iSelected)
{
    LVITEM      lvitem = {0};
    RULEINFO *  pinfoRule = NULL;
    PROPVARIANT propvar = {0};
    int         cRules = 0;
    TCHAR       szRes[CCHMAX_STRINGRES];
    UINT        cchRes = 0;
    LPTSTR      pszMessage = NULL;

    Assert(NULL != m_hwndList);

    // Grab the rule from the list view
    lvitem.iItem = iSelected;
    lvitem.mask = LVIF_PARAM;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }

    pinfoRule = (RULEINFO *) (lvitem.lParam);
    if ((NULL == pinfoRule) || (NULL == pinfoRule->pIRule))
    {
        goto exit;
    }
    
    // Warn the user to make sure they know we are going to remove the rule
    if (FAILED(pinfoRule->pIRule->GetProp(RULE_PROP_NAME, 0, &propvar)))
    {
        goto exit;
    }

    // Get the string template to display
    cchRes = LoadString(g_hLocRes, idsRulesWarnDelete, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    // Allocate space to hold the final display string
    if (FAILED(HrAlloc((void ** ) &pszMessage, cchRes + lstrlen(propvar.pszVal) + 1)))
    {
        goto exit;
    }

    // Build up the string and display it
    wsprintf(pszMessage, szRes, propvar.pszVal);
    if (IDNO == AthMessageBox(m_hwndDlg, MAKEINTRESOURCE(idsAthenaMail), pszMessage,
                            NULL, MB_YESNO | MB_ICONINFORMATION))
    {
        goto exit;
    }
    
    // Remove the item from the list
    ListView_DeleteItem(m_hwndList, iSelected);

    // Let's make sure we have a selection in the list
    cRules = ListView_GetItemCount(m_hwndList);
    if (cRules > 0)
    {
        // Did we delete the last item in the list
        if (iSelected >= cRules)
        {
            // Move the selection to the new last item in the list
            iSelected = cRules - 1;
        }

        // Set the new selection
        ListView_SetItemState(m_hwndList, iSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

        // Let's make sure we can see this new item
        ListView_EnsureVisible(m_hwndList, iSelected, FALSE);
    }
    else
    {
        // Make sure we clear out all of the buttons
        _EnableButtons(-1);
    }

    // Release the rule
    SafeRelease(pinfoRule->pIRule);

    // Free up the memory
    delete pinfoRule; // SafeMemFree(pinfoRule);
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    PropVariantClear(&propvar);
    SafeMemFree(pszMessage);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  CopyRule
//
//  This copies the selected rule from the rules manager
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEMailRulesPageUI::_CopyRule(INT iSelected)
{
    LVITEM          lvitem = {0};
    IOERule *       pIRule = NULL;
    HRESULT         hr = S_OK;
    IOERule *       pIRuleNew = NULL;
    PROPVARIANT     propvar = {0};
    UINT            cRules = 0;
    TCHAR           szRes[CCHMAX_STRINGRES];
    UINT            cchRes = 0;
    LPTSTR          pszName = NULL;

    Assert(NULL != m_hwndList);
    
    // Make sure we don't loose any changes
    _FSaveRule(iSelected);
    
    // Grab the rule from the list view
    lvitem.iItem = iSelected;
    lvitem.mask = LVIF_PARAM;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }

    pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
    if (NULL == pIRule)
    {
        goto exit;
    }

    // Create a new rule object
    hr = pIRule->Clone(&pIRuleNew);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Let's set the name

    // Get the name from the source rule
    hr = pIRule->GetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the string template to display
    cchRes = LoadString(g_hLocRes, idsRulesCopyName, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    // Allocate space to hold the final display string
    if (FAILED(HrAlloc((void ** ) &pszName, cchRes + lstrlen(propvar.pszVal) + 1)))
    {
        goto exit;
    }

    // Build up the string and set it
    wsprintf(pszName, szRes, propvar.pszVal);

    PropVariantClear(&propvar);
    propvar.vt = VT_LPSTR;
    propvar.pszVal = pszName;
    pszName = NULL;
    
    // Set the name into the new rule
    Assert(VT_LPSTR == propvar.vt);
    Assert(NULL != propvar.pszVal);
    hr = pIRuleNew->SetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Clear the version of the new rule
    PropVariantClear(&propvar);
    propvar.vt = VT_UI4;
    propvar.ulVal = 0;
    hr = pIRuleNew->SetProp(RULE_PROP_VERSION, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Add the rule to the rules list right below
    // the original rule
    iSelected++;
    _FAddRuleToList(iSelected, RULEID_INVALID, pIRuleNew);

    // Make sure the new item is selected
    ListView_SetItemState(m_hwndList, iSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

    // Make sure the new item is visible
    ListView_EnsureVisible(m_hwndList, iSelected, FALSE);
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    SafeMemFree(pszName);
    SafeRelease(pIRuleNew);
    PropVariantClear(&propvar);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnApplyTo
//
//  This applies the rules into a folder
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEMailRulesPageUI::_OnApplyTo(INT iSelected)
{
    COEApplyRulesUI *   pApplyRulesUI = NULL;
    RULENODE *          prnodeList = NULL;
    RULENODE *          prnodeWalk = NULL;
    LVITEM              lvitem = {0};
    IOERule *           pIRule = NULL;
    HRESULT             hr = S_OK;

    // Create the rules UI object
    pApplyRulesUI = new COEApplyRulesUI;
    if (NULL == pApplyRulesUI)
    {
        goto exit;
    }

    // Get the rules from the page
    if (FALSE == SendMessage(m_hwndOwner, WM_OE_GET_RULES, (WPARAM) m_typeRule, (LPARAM) &prnodeList))
    {
        goto exit;
    }

    if (NULL == prnodeList)
    {
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        (RULE_TYPE_NEWS == m_typeRule) ? MAKEINTRESOURCEW(idsErrorApplyRulesNews) : MAKEINTRESOURCEW(idsErrorApplyRulesMail),
                        NULL, MB_OK | MB_ICONERROR);
        goto exit;
    }
    
    // Get the rule associated with the item
    if (-1 != iSelected)
    {
        lvitem.iItem = iSelected;
        lvitem.mask = LVIF_PARAM;
        if (FALSE != ListView_GetItem(m_hwndList, &lvitem))
        {
            pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
            if (NULL != pIRule)
            {
                // Verify that it is valid
                hr = pIRule->Validate(0);
                if ((FAILED(hr)) || (S_FALSE == hr))
                {
                    pIRule = NULL;
                }
            }
        }
    }
    
    if (FAILED(pApplyRulesUI->HrInit(m_hwndDlg, 0, m_typeRule, prnodeList, pIRule)))
    {
        goto exit;
    }
    prnodeList = NULL;
  
    if (FAILED(pApplyRulesUI->HrShow()))
    {
        goto exit;
    }
    
exit:
    while (NULL != prnodeList)
    {
        prnodeWalk = prnodeList;
        if (NULL != prnodeWalk->pIRule)
        {
            prnodeWalk->pIRule->Release();
        }
        prnodeList = prnodeList->pNext;
        MemFree(prnodeWalk);
    }
    if (NULL != pApplyRulesUI)
    {
        delete pApplyRulesUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnLabelEdit
//
//  This brings up the edit UI for the selected rule from the mail rules list
//
//  fBegin  - is this for the LVN_BEGINLABELEDIT notification
//  pdi     - the display info for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::_FOnLabelEdit(BOOL fBegin, NMLVDISPINFO * pdi)
{
    BOOL            fRet = FALSE;
    HWND            hwndEdit;
    ULONG           cchName = 0;
    IOERule *       pIRule = NULL;
    LVITEM          lvitem;
    PROPVARIANT     propvar;

    Assert(NULL != m_hwndList);

    if (NULL == pdi)
    {
        fRet = FALSE;
        goto exit;
    }

    Assert(m_hwndList == pdi->hdr.hwndFrom);
    
    if (FALSE != fBegin)
    {
        // Get the edit control
        hwndEdit = ListView_GetEditControl(m_hwndList);

        if (NULL == hwndEdit)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Limit the amount of text for the name
        SendMessage(hwndEdit, EM_LIMITTEXT, c_cchNameMax - 1, 0);

        // Tell the dialog it's aok to proceed
        SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
    }
    else
    {            
        // Did something change?
        if ((-1 != pdi->item.iItem) && (NULL != pdi->item.pszText))
        {
            cchName = lstrlen(pdi->item.pszText);
            
            // Check to see if the rule name is valid
            if ((0 == cchName) || (0 == UlStripWhitespace(pdi->item.pszText, TRUE, TRUE, &cchName)))
            {
                // Put up a message saying something is busted
                AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                                MAKEINTRESOURCEW(idsRulesErrorNoName), NULL,
                                MB_OK | MB_ICONINFORMATION);
                SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
                fRet = TRUE;
                goto exit;
            }
            
            // Get the rule for the item
            ZeroMemory(&lvitem, sizeof(lvitem));
            lvitem.iItem = pdi->item.iItem;
            lvitem.mask = LVIF_PARAM;
            if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
            {
                SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
                fRet = TRUE;
                goto exit;
            }

            pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
            if (NULL == pIRule)
            {
                SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
                fRet = TRUE;
                goto exit;
            }
            
            // Set the new name into the rule
            
            ZeroMemory(&propvar, sizeof(propvar));
            propvar.vt = VT_LPSTR;
            propvar.pszVal = pdi->item.pszText;
            
            SideAssert(S_OK == pIRule->SetProp(RULE_PROP_NAME, 0, &propvar));

            // Mark the rule list as dirty
            m_dwState |= STATE_DIRTY;
        
            SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, TRUE);
        }
    }

    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnRuleDescValid
//
//  This brings up the edit UI for the selected rule from the mail rules list
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEMailRulesPageUI::_FOnRuleDescValid(VOID)
{
    BOOL        fRet = FALSE;
    INT         iSelected = 0;
    LVITEM      lvitem;
    IOERule *   pIRule = NULL;
    HRESULT     hr = S_OK;
    PROPVARIANT propvar;

    Assert(NULL != m_hwndList);
    
    // Get the selected item
    iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
    if (-1 == iSelected)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the current state of the rule
    ZeroMemory(&lvitem, sizeof(lvitem));
    lvitem.mask = LVIF_PARAM | LVIF_STATE;
    lvitem.stateMask = LVIS_STATEIMAGEMASK;
    lvitem.iItem = iSelected;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        fRet = FALSE;
        goto exit;
    }
    
    pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
    
    // If the rule already valid, then bail
    if (lvitem.state != INDEXTOSTATEIMAGEMASK(iiconStateInvalid + 1))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // If we are still, invalid then bail
    hr = m_pDescriptUI->HrVerifyRule();
    if (S_OK != hr)
    {
        fRet = FALSE;
        goto exit;
    }

    // Figure out the new enabled value
    hr = pIRule->GetProp(RULE_PROP_DISABLED, 0, &propvar);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the UI to the proper enabled state
    ZeroMemory(&lvitem, sizeof(lvitem));
    lvitem.mask = LVIF_STATE;
    lvitem.iItem = iSelected;
    lvitem.state = (!!propvar.boolVal) ? INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1) :
                            INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1);
    lvitem.stateMask = LVIS_STATEIMAGEMASK;
    
    ListView_SetItem(m_hwndList, &lvitem);

    fRet = TRUE;
    
exit:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\ruleutil.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "ruleutil.h"
#include "rulesmgr.h"
#include "rulesui.h"
#include "editrule.h"
#include "spamui.h"
#include "viewsui.h"
#include "rule.h"
#include <msoeobj.h>
#include <xpcomm.h>
#include <ipab.h>
#include <pop3task.h>
#include <msgfldr.h>
#include <mimeolep.h>
#include <storecb.h>
#include <menures.h>
#include <hotlinks.h>
#include <menuutil.h>
#include <mru.h>
#include <options.h>
#include <mailutil.h>
#include <secutil.h>
#include "shlwapip.h"
#include "reutil.h"
#include <demand.h>

// Typedefs
typedef enum tagDEF_CRIT_TYPE
{
    DEF_CRIT_ALLMSGS    = 0,
    DEF_CRIT_READ,
    DEF_CRIT_DWNLDMSGS,
    DEF_CRIT_IGNTHDS
} DEF_CRIT_TYPE;

typedef enum tagDEF_ACT_TYPE
{
    DEF_ACT_SHOWMSGS    = 0,
    DEF_ACT_HIDEMSGS
} DEF_ACT_TYPE;

typedef struct tagDEFAULT_RULE
{
    // The rule handle
    RULEID              ridRule;
    // The rule name
    UINT                idName;
    // Which type of criteria for the rule
    DEF_CRIT_TYPE       critType;
    // Which type of actions for the rule
    DEF_ACT_TYPE        actType;
    // The current version number for the rule
    DWORD               dwVersion;
} DEFAULT_RULE, * PDEFAULT_RULE;

// Constants
static const ULONG CDEF_CRIT_ITEM_MAX = 2;
static const ULONG CDEF_ACT_ITEM_MAX = 1;

static const DWORD DEFAULT_RULE_VERSION = 0x00000004;

static const DEFAULT_RULE   g_defruleFilters[] =
{
    {RULEID_VIEW_ALL,           idsViewAllMessages, DEF_CRIT_ALLMSGS,       DEF_ACT_SHOWMSGS,   DEFAULT_RULE_VERSION},
    {RULEID_VIEW_UNREAD,        idsViewUnread,      DEF_CRIT_READ,          DEF_ACT_HIDEMSGS,   DEFAULT_RULE_VERSION},
    {RULEID_VIEW_DOWNLOADED,    idsViewDownloaded,  DEF_CRIT_DWNLDMSGS,     DEF_ACT_SHOWMSGS,   DEFAULT_RULE_VERSION},
    {RULEID_VIEW_IGNORED,       idsViewNoIgnored,   DEF_CRIT_IGNTHDS,       DEF_ACT_HIDEMSGS,   DEFAULT_RULE_VERSION}
};

static const CHAR g_szOrderFilterDef[] =    "FFA FFB FFC FFF";

static const ULONG RULE_FILE_VERSION =      0x00050000;

static const char c_szLeftParen[] =         "(";
static const char c_szRightParen[] =        ")";
static const char c_szDoubleQuote[] =       "\"";
static const char c_szLogicalAnd[] =        " && ";
static const char c_szLogicalOr[] =         " || ";

static const char c_szFilterRead[] =            "(0 != (MSGCOL_FLAGS & ARF_READ))";
static const char c_szFilterNotRead[] =         "(0 == (MSGCOL_FLAGS & ARF_READ))";
static const char c_szFilterDeleted[] =         "(0 != (MSGCOL_FLAGS & ARF_ENDANGERED))";
static const char c_szFilterNotDeleted[] =      "(0 == (MSGCOL_FLAGS & ARF_ENDANGERED))";
static const char c_szFilterDownloaded[] =      "(0 != (MSGCOL_FLAGS & ARF_HASBODY))";
static const char c_szFilterNotDownloaded[] =   "(0 == (MSGCOL_FLAGS & ARF_HASBODY))";
static const char c_szFilterWatched[] =         "(0 != (MSGCOL_FLAGS & ARF_WATCH))";
static const char c_szFilterIgnored[] =         "(0 != (MSGCOL_FLAGS & ARF_IGNORE))";
static const char c_szFilterAttach[] =          "(0 != (MSGCOL_FLAGS & ARF_HASATTACH))";
static const char c_szFilterSigned[] =          "(0 != (MSGCOL_FLAGS & ARF_SIGNED))";
static const char c_szFilterEncrypt[] =         "(0 != (MSGCOL_FLAGS & ARF_ENCRYPTED))";
static const char c_szFilterFlagged[] =         "(0 != (MSGCOL_FLAGS & ARF_FLAGGED))";
static const char c_szFilterNotFlagged[] =      "(0 == (MSGCOL_FLAGS & ARF_FLAGGED))";
static const char c_szFilterPriorityHi[] =      "(MSGCOL_PRIORITY == IMSG_PRI_HIGH)";
static const char c_szFilterPriorityLo[] =      "(MSGCOL_PRIORITY == IMSG_PRI_LOW)";
static const char c_szFilterReplyPost[] =       "(0 != IsReplyPostVisible)";
static const char c_szFilterNotReplyPost[] =    "(0 == IsReplyPostVisible)";
static const char c_szFilterShowAll[] =         "(0 == 0)";
static const char c_szFilterHideAll[] =         "(0 != 0)";

static const char c_szFilterHide[] =            "0 == ";
static const char c_szFilterShow[] =            "0 != ";

static const char c_szEmailFromAddrPrefix[] =   "(MSGCOL_EMAILFROM containsi ";
static const char c_szEmailSubjectPrefix[] =    "(MSGCOL_SUBJECT containsi ";
static const char c_szEmailAcctPrefix[] =       "(MSGCOL_ACCOUNTID containsi ";
static const char c_szEmailFromPrefix[] =       "(MSGCOL_DISPLAYFROM containsi ";
static const char c_szEmailLinesPrefix[] =      "(MSGCOL_LINECOUNT > ";
static const char c_szFilterReplyChild[] =      "(0 != (MSGCOL_FLAGS & ARF_HASCHILDREN))";
static const char c_szFilterReplyRoot[] =       "(0 != MSGCOL_PARENT)";
static const char c_szEmailAgePrefix[] =        "(MessageAgeInDays > ";

void DoMessageRulesDialog(HWND hwnd, DWORD dwFlags)
{
    COERulesMgrUI *   pRulesMgrUI = NULL;

    if (NULL == hwnd)
    {
        goto exit;
    }

    // Create the rules UI object
    pRulesMgrUI = new COERulesMgrUI;
    if (NULL == pRulesMgrUI)
    {
        goto exit;
    }

    if (FAILED(pRulesMgrUI->HrInit(hwnd, dwFlags)))
    {
        goto exit;
    }

    pRulesMgrUI->HrShow();
    
exit:
    if (NULL != pRulesMgrUI)
    {
        delete pRulesMgrUI;
    }
    return;
}

HRESULT HrDoViewsManagerDialog(HWND hwnd, DWORD dwFlags, RULEID * pridRule, BOOL * pfApplyAll)
{
    HRESULT             hr = S_OK;
    COEViewsMgrUI *     pViewsMgrUI = NULL;

    if ((NULL == hwnd) || (NULL == pfApplyAll))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create the rules UI object
    pViewsMgrUI = new COEViewsMgrUI;
    if (NULL == pViewsMgrUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pViewsMgrUI->HrInit(hwnd, dwFlags, pridRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pViewsMgrUI->HrShow(pfApplyAll);
    
exit:
    if (NULL != pViewsMgrUI)
    {
        delete pViewsMgrUI;
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateRuleFromMessage
//
//  This creates a rules editor of the proper type.
//
//  hwnd        - The owner dialog
//  dwFlags     - What type of editor to bring up
//  pmsginfo    - The message information
//  pMsgList    - The owner of the message
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the Rules Manager object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateRuleFromMessage(HWND hwnd, DWORD dwFlags, MESSAGEINFO * pmsginfo, IMimeMessage * pMessage)
{
    HRESULT         hr = S_OK;
    CEditRuleUI *   pEditRuleUI = NULL;
    IOERule *       pIRule = NULL;
    UINT            uiStrId = 0;
    TCHAR           szRes[CCHMAX_STRINGRES + 5];
    ULONG           cchRes = 0;
    ULONG           ulIndex = 0;
    TCHAR           szName[CCHMAX_STRINGRES + 5];
    RULE_TYPE       typeRule = RULE_TYPE_MAIL;
    IOERule *       pIRuleFound = NULL;
    PROPVARIANT     propvar = {0};
    LPSTR           pszEmailFrom = NULL;
    ADDRESSPROPS    rSender = {0};
    RULEINFO        infoRule = {0};
    BYTE *          pBlobData = NULL;
    ULONG           cbSize = 0;

    Assert(NULL != g_pMoleAlloc);
    Assert(NULL != g_pRulesMan);
    
    // Check incoming params
    if ((NULL == hwnd) || (NULL == pmsginfo))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create a rules editor object
    pEditRuleUI = new CEditRuleUI;
    if (NULL == pEditRuleUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Create a new rule object
    hr = HrCreateRule(&pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

   // Figure out the string Id
    if (0 != (dwFlags & CRFMF_NEWS))
    {
        uiStrId = idsRuleNewsDefaultName;
        typeRule = RULE_TYPE_NEWS;
    }
    else
    {
        uiStrId = idsRuleMailDefaultName;
        typeRule = RULE_TYPE_MAIL;
    }
    
    // Figure out the name of the new rule ...
    cchRes = LoadString(g_hLocRes, uiStrId, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        hr = E_FAIL;
        goto exit;
    }

    ulIndex = 1;
    wsprintf(szName, szRes, ulIndex);
    
    // Make sure the name is unique
    while (S_OK == g_pRulesMan->FindRule(szName, typeRule, &pIRuleFound))
    {
        pIRuleFound->Release();
        pIRuleFound = NULL;
        ulIndex++;
        wsprintf(szName, szRes, ulIndex);
    }

    ZeroMemory(&propvar, sizeof(propvar));
    propvar.vt = VT_LPSTR;
    propvar.pszVal = szName;

    // Set the rule name
    hr = pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    if ((NULL == pmsginfo->pszEmailFrom) || (FALSE != FIsEmpty(pmsginfo->pszEmailFrom)))
    {
        // Get the load interface from the preview pane object
        if (NULL != pMessage)
        {
            rSender.dwProps = IAP_EMAIL;
            pMessage->GetSender(&rSender);
            Assert(rSender.pszEmail && ISFLAGSET(rSender.dwProps, IAP_EMAIL));
            pszEmailFrom = rSender.pszEmail;
        }
    }
    else
    {
        pszEmailFrom = pmsginfo->pszEmailFrom;
    }

    if (NULL != pszEmailFrom)
    {
        // Create space to hold the email address
        if (FALSE == FIsEmpty(pszEmailFrom))
        {
            cbSize = lstrlen(pszEmailFrom) + 3;
            
            if (SUCCEEDED(HrAlloc((VOID **) &pBlobData, cbSize)))
            {
                lstrcpy((LPSTR) pBlobData, pszEmailFrom);
                pBlobData[cbSize - 2] = '\0';
                pBlobData[cbSize - 1] = '\0';
            }
            else
            {
                cbSize = 0;
            }
        }
    }
    
    if (0 != cbSize)
    {
        CRIT_ITEM       citemFrom;
        
        // Set the default criteria on the rule
        ZeroMemory(&citemFrom, sizeof(citemFrom));
        citemFrom.type = CRIT_TYPE_FROM;
        citemFrom.logic = CRIT_LOGIC_NULL;
        citemFrom.dwFlags = CRIT_FLAG_DEFAULT;
        citemFrom.propvar.vt = VT_BLOB;
        citemFrom.propvar.blob.cbSize = cbSize;
        citemFrom.propvar.blob.pBlobData = pBlobData;

        ZeroMemory(&propvar, sizeof(propvar));
        propvar.vt = VT_BLOB;
        propvar.blob.cbSize = sizeof(citemFrom);
        propvar.blob.pBlobData = (BYTE *) &citemFrom;

        hr = pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Initialize the editor object
    hr = pEditRuleUI->HrInit(hwnd, ERF_NEWRULE, typeRule, pIRule, NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Bring up the rules editor UI
    hr = pEditRuleUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    if (S_OK == hr)
    {
        // Initialize the rule info
        infoRule.pIRule = pIRule;
        infoRule.ridRule = RULEID_INVALID;
        
        // Add the rule to the list of rules
        hr = g_pRulesMan->SetRules(SETF_APPEND, typeRule, &infoRule, 1);
        
        if(FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    SafeMemFree(pBlobData);
    g_pMoleAlloc->FreeAddressProps(&rSender);
    SafeRelease(pIRule);
    if (NULL != pEditRuleUI)
    {
        delete pEditRuleUI;
    }
    if (S_OK == hr)
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), 
                      MAKEINTRESOURCEW(idsRuleAdded), NULL, MB_OK | MB_ICONINFORMATION);
    }
    else if (FAILED(hr))
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), 
                      MAKEINTRESOURCEW(idsCreateRuleError), NULL, MB_OK | MB_ICONERROR);
    }
    return hr;
}

HRESULT HrBlockSendersFromFolder(HWND hwnd, DWORD dwFlags, FOLDERID idFolder, LPSTR * ppszSender, ULONG cpszSender)
{
    HRESULT             hr = S_OK;
    IMessageFolder *    pFolder = NULL;
    FOLDERINFO          infoFolder = {0};
    CProgress *         pProgress = NULL;
    IOERule *           pIRule = NULL;
    CRIT_ITEM *         pCritItem = NULL;
    ULONG               cCritItem = 0;
    ULONG               ulIndex = 0;
    PROPVARIANT         propvar = {0};
    CExecRules *        pExecRules = NULL;
    RULENODE            rnode = {0};
    IOEExecRules *      pIExecRules = NULL;
    CHAR                rgchTmpl[CCHMAX_STRINGRES];
    LPSTR               pszText = NULL;

    // Check incoming params
    if ((NULL == hwnd) || (FOLDERID_INVALID == idFolder) || (NULL == ppszSender) || (0 == cpszSender))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Open up the folder
    hr = g_pStore->OpenFolder(idFolder, NULL, NOFLAGS, &pFolder);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = g_pStore->GetFolderInfo(idFolder, &infoFolder);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Create the progress dialog
    pProgress = new CProgress;
    if (NULL == pProgress)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pProgress->Init(hwnd, MAKEINTRESOURCE(idsAthena), MAKEINTRESOURCE(idsSendersApplyProgress), infoFolder.cMessages, 0, TRUE, FALSE);

    // Create the Block Sender rule
    hr = RuleUtil_HrCreateSendersRule(0, &pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Allocate space to hold all the senders
    hr = HrAlloc((VOID **) &pCritItem, sizeof(*pCritItem) * cpszSender);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize it
    ZeroMemory(pCritItem, sizeof(*pCritItem) * cpszSender);

    // Add in each of the criteria
    for (ulIndex = 0; ulIndex < cpszSender; ulIndex++, ppszSender++)
    {
        if ((NULL != *ppszSender) && ('\0' != (*ppszSender)[0]))
        {
            pCritItem[cCritItem].type = CRIT_TYPE_SENDER;
            pCritItem[cCritItem].logic = CRIT_LOGIC_OR;
            pCritItem[cCritItem].dwFlags = CRIT_FLAG_DEFAULT;
            pCritItem[cCritItem].propvar.vt = VT_LPSTR;
            pCritItem[cCritItem].propvar.pszVal = *ppszSender;
            cCritItem++;
        }
    }

    // Do we need to do anything?
    if (0 == cCritItem)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the senders into the rule
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = sizeof(*pCritItem) * cCritItem;
    propvar.blob.pBlobData = (BYTE *) pCritItem;
    hr = pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the rule executor
    pExecRules = new CExecRules;
    if (NULL == pExecRules)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the rule executor
    rnode.pIRule = pIRule;
    hr = pExecRules->_HrInitialize(0, &rnode);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the rule executor interface
    hr = pExecRules->QueryInterface(IID_IOEExecRules, (void **) &pIExecRules);
    if (FAILED(hr))
    {
        goto exit;
    }
    pExecRules = NULL;

    // Show dialog in 2 second
    pProgress->Show(0);

    hr = RuleUtil_HrApplyRulesToFolder(RULE_APPLY_SHOWUI, (FOLDER_LOCAL != infoFolder.tyFolder) ? DELETE_MESSAGE_NOTRASHCAN : 0,
                    pIExecRules, pFolder, pProgress->GetHwnd(), pProgress);
    // Close the progress window
    pProgress->Close();
    if (FAILED(hr))
    {
        goto exit;
    }

    // Show confirmation dialog
    AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsSendersApplySuccess), NULL, MB_OK | MB_ICONINFORMATION);

    hr = S_OK;
    
exit:
    SafeMemFree(pszText);
    SafeRelease(pIExecRules);
    if (NULL != pExecRules)
    {
        delete pExecRules;
    }
    SafeMemFree(pCritItem);
    SafeRelease(pIRule);
    SafeRelease(pProgress);
    g_pStore->FreeRecord(&infoFolder);
    SafeRelease(pFolder);
    if (FAILED(hr))
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), 
                      MAKEINTRESOURCEW(idsSendersApplyFail), NULL, MB_OK | MB_ICONERROR);
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateRulesManager
//
//  This creates a rules manager.
//
//  pIUnkOuter  - For aggregation, it must be NULL
//  ppIUnknown  - The interface the was created
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the Rules Manager object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateRulesManager(IUnknown * pIUnkOuter, IUnknown ** ppIUnknown)
{
    HRESULT             hr = S_OK;
    CRulesManager *     pRulesManager = NULL;
    IOERulesManager *   pIRulesMgr = NULL;

    // Check the incoming params
    if (NULL == ppIUnknown)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    Assert(NULL == pIUnkOuter);
    
    // Initialize outgoing params
    *ppIUnknown = NULL;

    // Create the rules manager object
    pRulesManager = new CRulesManager;
    if (NULL == pRulesManager)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the rules manager interface
    hr = pRulesManager->QueryInterface(IID_IOERulesManager, (void **) &pIRulesMgr);
    if (FAILED(hr))
    {
        goto exit;
    }

    pRulesManager = NULL;

    *ppIUnknown = static_cast<IUnknown *>(pIRulesMgr);
    pIRulesMgr = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeRelease(pIRulesMgr);
    if (NULL != pRulesManager)
    {
        delete pRulesManager;
    }
    
    return hr;
}

HRESULT RuleUtil_HrBuildEmailString(LPWSTR pwszText, ULONG cchText, LPWSTR * ppwszEmail, ULONG * pcchEmail)
{
    HRESULT     hr = S_OK;
    WCHAR       wszParseSep[16];
    LPWSTR      pwszAddr = NULL,
                pwszTerm = NULL,
                pwszWalk = NULL,
                pwszStrip = NULL;
    ULONG       cchParse = 0;

    // Check incoming params
    if ((NULL == pwszText) || (NULL == ppwszEmail))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppwszEmail = NULL;
    if (NULL != pcchEmail)
    {
        *pcchEmail = 0;
    }

    // Grab the terminator
    cchParse = LoadStringWrapW(g_hLocRes, idsEmailParseSep, wszParseSep, ARRAYSIZE(wszParseSep));
    Assert(cchParse != 0);
    
    // The output string is at least as long as the imput string
    pwszAddr = PszDupW(pwszText);
    if (NULL == pwszAddr)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pwszAddr[0] = L'\0';
    pwszTerm = pwszText;
    pwszWalk = pwszAddr;
    while (NULL != pwszTerm)
    {
        pwszStrip = pwszWalk;
        pwszTerm = StrStrW(pwszText, wszParseSep);
        if (L'\0' != pwszAddr[0])
        {
            StrCpyW(pwszWalk, g_wszComma);
            pwszStrip++;
        }

        if (NULL == pwszTerm)
        {
            StrCatW(pwszWalk, pwszText);
        }
        else
        {
            StrNCatW(pwszWalk, pwszText, (int)(pwszTerm - pwszText + 1));
            pwszTerm += cchParse;
            pwszText = pwszTerm;
        }
        
        if (0 == UlStripWhitespaceW(pwszStrip, TRUE, TRUE, NULL))
        {
            *pwszWalk = '\0';
        }

        pwszWalk += lstrlenW(pwszWalk);
    }
    
    // Set the outgoing params
    if (NULL != pcchEmail)
    {
        *pcchEmail = lstrlenW(pwszAddr);
    }
    
    *ppwszEmail = pwszAddr;
    pwszAddr = NULL;

    // Set proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pwszAddr);
    return hr;
}

HRESULT RuleUtil_HrParseEmailString(LPWSTR pwszEmail, ULONG cchEmail, LPWSTR *ppwszOut, ULONG * pcchOut)
{
    HRESULT     hr = S_OK;
    LPWSTR      pwszText = NULL,
                pwszTerm = NULL;
    ULONG       cchText = 0;
    ULONG       ulIndex = 0;
    ULONG       ulTerm = 0;
    WCHAR       wszSep[16];
    ULONG       cchSep = 0;

    // Check incoming params
    if ((NULL == pwszEmail) || (NULL == ppwszOut))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppwszOut = NULL;
    if (NULL != pcchOut)
    {
        *pcchOut = 0;
    }

    // Make sure we know how big the input string is
    if (0 == cchEmail)
    {
        cchEmail = (ULONG) lstrlenW(pwszEmail);
    }

    cchText = cchEmail;
    pwszTerm = pwszEmail;
    // Figure out the space needed to hold the new addresses
    while (NULL != pwszTerm)
    {
        pwszTerm = StrStrW(pwszTerm, g_wszComma);
        if (NULL != pwszTerm)
        {
            cchText++;
            pwszTerm++;
        }
    }
    
    // Grab the terminator
    LoadStringWrapW(g_hLocRes, idsEmailSep, wszSep, ARRAYSIZE(wszSep));
    cchSep = lstrlenW(wszSep);
    
    // The output string is at least as long as the imput string
    hr = HrAlloc((void **) &pwszText, (cchText + 1)*sizeof(*pwszText));
    if (FAILED(hr))
    {
        goto exit;
    }

    pwszText[0] = L'\0';
    pwszTerm = pwszEmail;
    cchText = 0;
    while (NULL != pwszTerm)
    {
        pwszTerm = StrStrW(pwszEmail, g_wszComma);
        if (NULL != pwszTerm)
        {
            pwszTerm++;
            StrNCatW(pwszText, pwszEmail, (int)(pwszTerm - pwszEmail));
            StrCatW(pwszText, wszSep);
            pwszEmail = pwszTerm;
        }
        else
        {
            StrCatW(pwszText, pwszEmail);
        }
    }
    
    // Terminate the string
    cchText = lstrlenW(pwszText);

    // Set the outgoing param
    *ppwszOut = pwszText;
    pwszText = NULL;
    if (NULL != pcchOut)
    {
        *pcchOut = cchText;
    }

    // Set proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pwszText);
    return hr;
}

HRESULT RuleUtil_HrBuildTextString(LPTSTR pszIn, ULONG cchIn, LPTSTR * ppszText, ULONG * pcchText)
{
    HRESULT     hr = S_OK;
    LPTSTR      pszText = NULL;
    LPTSTR      pszTerm = NULL;
    LPTSTR      pszWalk = NULL;
    LPTSTR      pszStrip = NULL;
    ULONG       cchSpace = 0;

    // Check incoming params
    if ((NULL == pszIn) || (NULL == ppszText))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppszText = NULL;
    if (NULL != pcchText)
    {
        *pcchText = 0;
    }

    // The output string is at least as long as the imput string
    pszText = PszDupA(pszIn);
    if (NULL == pszText)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pszText[0] = '\0';
    pszTerm = pszIn;
    pszWalk = pszText;
    cchSpace = lstrlen(g_szSpace);
    while ('\0' != *pszTerm)
    {
        pszStrip = pszWalk;
        pszTerm = pszIn;
        while(('\0' != *pszTerm) && (FALSE == FIsSpaceA(pszTerm)))
        {
            pszTerm = CharNext(pszTerm);
        }
        
        if ('\0' != pszText[0])
        {
            lstrcpy(pszWalk, g_szSpace);
            pszStrip += cchSpace;
        }

        if ('\0' == *pszTerm)
        {
            lstrcat(pszWalk, pszIn);
        }
        else
        {
            pszTerm = CharNext(pszTerm);
            StrNCat(pszWalk, pszIn, (int)(pszTerm - pszIn));
            pszIn = pszTerm;
        }
        
        if (0 == UlStripWhitespace(pszStrip, TRUE, TRUE, NULL))
        {
            *pszWalk = '\0';
        }

        pszWalk += lstrlen(pszWalk);
    }
    
    // Set the outgoing params
    if (NULL != pcchText)
    {
        *pcchText = lstrlen(pszText);
    }
    
    *ppszText = pszText;
    pszText = NULL;

    // Set proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszText);
    return hr;
}

// -------------------------------------------------------------------------------------------
// HrDlgRuleGetString
// -------------------------------------------------------------------------------------------
HRESULT RuleUtil_HrGetDlgString(HWND hwndDlg, UINT uiCtlId, LPTSTR *ppszText, ULONG * pcchText)
{
    HRESULT         hr = S_OK;
    HWND            hwndCtl = NULL;
    LPTSTR          pszText = NULL;
    ULONG           cchText = 0;

    // Check the incoming params
    if ((NULL == hwndDlg) || (NULL == ppszText))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    Assert(FALSE != IsWindow(hwndDlg));
    
    // Init the output params
    *ppszText = NULL;
    if (NULL != pcchText)
    {
        *pcchText = 0;
    }
    
    // Get the dialog control
    hwndCtl = GetDlgItem(hwndDlg, uiCtlId);
    if (NULL == hwndCtl)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get text length
    cchText = (ULONG) SendMessage(hwndCtl, WM_GETTEXTLENGTH, 0, 0);
    
    hr = HrAlloc((void **) &pszText, cchText + 1);
    if (FAILED(hr))
    {
        goto exit;
    }

    GetDlgItemText(hwndDlg, uiCtlId, pszText, cchText + 1);

    // Set the output params
    *ppszText = pszText;
    pszText = NULL;
    if (NULL != pcchText)
    {
        *pcchText = cchText;
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszText);
    return hr;
}

HRESULT RuleUtil_HrGetRegValue(HKEY hkey, LPCSTR pszValueName, DWORD * pdwType, BYTE ** ppbData, ULONG * pcbData)
{
    HRESULT     hr = S_OK;
    LONG        lErr = ERROR_SUCCESS;
    ULONG       cbData = 0;
    BYTE *      pbData = NULL;

    // Check incoming params
    if (NULL == ppbData)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Figure out the space to hold the criteria order
    lErr = SHQueryValueEx(hkey, pszValueName, 0, pdwType, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }
    
    // Allocate the space to hold the criteria order
    hr = HrAlloc((void **) &pbData, cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the criteria order
    lErr = SHQueryValueEx(hkey, pszValueName, 0, pdwType, pbData, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Return the values
    *ppbData = pbData;
    pbData = NULL;
    if (NULL != pcbData)
    {
        *pcbData = cbData;
    }
    
exit:
    SafeMemFree(pbData);
    return hr;
}

// -------------------------------------------------------------------------------------------
// RuleUtil_HrGetAddressesFromWAB
// -------------------------------------------------------------------------------------------
HRESULT RuleUtil_HrGetAddressesFromWAB(HWND hwndDlg, LONG lRecipType, UINT uidsWellButton, LPWSTR *ppwszAddrs)
{
    HRESULT     hr = S_OK;
    CWabal     *pWabal = NULL,
               *pWabalExpand = NULL;
    LPWSTR      pwszText = NULL,
                pwszLoop = NULL;
    BOOL        fFound = FALSE,
                fBadAddrs = FALSE;
    ULONG       cchText = 0;
    ADRINFO     adrInfo = {0};

    
    // Check the incoming params
    if ((NULL == hwndDlg) || (NULL == ppwszAddrs))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    Assert(FALSE != IsWindow(hwndDlg));

    // Create Wabal Object
    hr = HrCreateWabalObject(&pWabal);
    if (FAILED(hr))
    {
        goto exit;
    }

    // If we have a string then add it to the wabal object
    if (NULL != *ppwszAddrs)
    {
        for (pwszLoop = *ppwszAddrs; L'\0' != pwszLoop[0]; pwszLoop += lstrlenW(pwszLoop) + 1)
            pWabal->HrAddEntry(pwszLoop, pwszLoop, lRecipType);
    }

    // Let's go pick some new names
    hr = pWabal->HrRulePickNames(hwndDlg, lRecipType, idsRuleAddrCaption, idsRuleAddrWell, uidsWellButton);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Figure out the space needed to hold the new addresses

    // Create the expanded Wabal Object
    hr = HrCreateWabalObject(&pWabalExpand);
    if (FAILED(hr))
    {
        goto exit;
    }

    //Expand the groups to addresses...
    hr = pWabal->HrExpandTo(pWabalExpand);
    if (FAILED(hr))
    {
        goto exit;
    }

    SafeRelease(pWabal);
    
    cchText = 0;
    fFound = pWabalExpand->FGetFirst(&adrInfo);
    while(FALSE != fFound)
    {
        if ((NULL != adrInfo.lpwszAddress) && (L'\0' != adrInfo.lpwszAddress[0]))
        {
            cchText += lstrlenW(adrInfo.lpwszAddress) + 1;
        }
        else
        {
            fBadAddrs = TRUE;
        }

        // Get the next address
        fFound = pWabalExpand->FGetNext(&adrInfo);
    }

    // Add space for the terminator
    cchText += 2;
        
    // Allocate the new space
    hr = HrAlloc((void **) &pwszText, cchText*sizeof(WCHAR));
    if (FAILED(hr))
    {
        goto exit;
    }
    pwszText[0] = L'\0';

    // Build up the new string
    pwszLoop = pwszText;
    fFound = pWabalExpand->FGetFirst(&adrInfo);
    while(FALSE != fFound)
    {
        if ((NULL != adrInfo.lpwszAddress) && (L'\0' != adrInfo.lpwszAddress[0]))
        {
            StrCpyW(pwszLoop, adrInfo.lpwszAddress);
            pwszLoop += lstrlenW(adrInfo.lpwszAddress) + 1;
        }
        else
        {
            fBadAddrs = TRUE;
        }
        
        // Get the next address
        fFound = pWabalExpand->FGetNext(&adrInfo);
    }

    // Terminate the string
    pwszLoop[0] = L'\0';
    pwszLoop[1] = L'\0';
    
    // Set the outgoing param
    if (NULL != *ppwszAddrs)
    {
        MemFree(*ppwszAddrs);
    }
    *ppwszAddrs = pwszText;
    pwszText = NULL;

    // Set the proper return value
    hr = S_OK;

exit:
    if (FALSE != fBadAddrs)
    {
        AthMessageBoxW(hwndDlg, MAKEINTRESOURCEW(idsAthena),
                    MAKEINTRESOURCEW(idsRulesWarnEmptyEmail), NULL, MB_ICONINFORMATION | MB_OK);
    }
    MemFree(pwszText);
    ReleaseObj(pWabal);
    ReleaseObj(pWabalExpand);
    return hr;
}

// -------------------------------------------------------------------------------------------
// FPickEMailNames
// -------------------------------------------------------------------------------------------
HRESULT RuleUtil_HrPickEMailNames(HWND hwndDlg, LONG lRecipType, UINT uidsWellButton, LPWSTR *ppwszAddrs)
{
    HRESULT     hr = S_OK;
    CWabal     *pWabal = NULL,
               *pWabalExpand = NULL;
    LPWSTR      pwszText = NULL,
                pwszNames = NULL,
                pwszLoop = NULL,
                pwszTerm = NULL;
    ULONG       cchText = 0,
                cchSep = 0;
    BOOL        fFound = FALSE,
                fAddSep = FALSE,
                fBadAddrs = FALSE;
    ADRINFO     adrInfo;

    
    // Check the incoming params
    if ((NULL == hwndDlg) || (NULL == ppwszAddrs))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    Assert(FALSE != IsWindow(hwndDlg));

    // Create Wabal Object
    hr = HrCreateWabalObject(&pWabal);
    if (FAILED(hr))
    {
        goto exit;
    }

    // If we have a string then add it to the wabal object
    if ((NULL != *ppwszAddrs) && (L'\0' != **ppwszAddrs))
    {
        pwszNames = PszDupW(*ppwszAddrs);
        pwszTerm = pwszNames;
        for (pwszLoop = pwszNames; NULL != pwszTerm; pwszLoop += lstrlenW(pwszLoop) + 1)
        {
            // Terminate the address
            pwszTerm = StrStrW(pwszLoop, g_wszComma);
            if (NULL != pwszTerm)
            {
                *pwszTerm = L'\0';
            }
            
            pWabal->HrAddEntry(pwszLoop, pwszLoop, lRecipType);
        }
        
        SafeMemFree(pwszNames);
    }

    // Let's go pick some new names
    hr = pWabal->HrRulePickNames(hwndDlg, lRecipType, idsRuleAddrCaption, idsRuleAddrWell, uidsWellButton);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Figure out the space needed to hold the new addresses

    // Create the expanded Wabal Object
    hr = HrCreateWabalObject(&pWabalExpand);
    if (FAILED(hr))
    {
        goto exit;
    }

    //Expand the groups to addresses...
    hr = pWabal->HrExpandTo(pWabalExpand);
    if (FAILED(hr))
    {
        goto exit;
    }

    SafeRelease(pWabal);
    
    // Load the email seperator
    cchSep = lstrlenW(g_wszComma);
    
    cchText = 0;
    fFound = pWabalExpand->FGetFirst(&adrInfo);
    while(FALSE != fFound)
    {
        if (NULL != adrInfo.lpwszAddress)
        {
            cchText += lstrlenW(adrInfo.lpwszAddress) + cchSep;
        }
        else
        {
            fBadAddrs = TRUE;
        }

        // Get the next address
        fFound = pWabalExpand->FGetNext(&adrInfo);
    }

    // Allocate the new space
    hr = HrAlloc((void **) &pwszText, (cchText + 1)*sizeof(*pwszText));
    if (FAILED(hr))
    {
        goto exit;
    }
    pwszText[0] = L'\0';

    // Build up the new string
    cchText = 0;
    fFound = pWabalExpand->FGetFirst(&adrInfo);
    while(FALSE != fFound)
    {
        if (NULL != adrInfo.lpwszAddress)
        {
            if (FALSE == fAddSep)
            {
                fAddSep = TRUE;
            }
            else
            {
                StrCatW(pwszText, g_wszComma);
                cchText += cchSep;
            }

            StrCatW(pwszText, adrInfo.lpwszAddress);
            cchText += lstrlenW(adrInfo.lpwszAddress);
        }
        else
        {
            fBadAddrs = TRUE;
        }
        
        // Get the next address
        fFound = pWabalExpand->FGetNext(&adrInfo);
    }

    // Set the outgoing param
    if (NULL != *ppwszAddrs)
    {
        MemFree(*ppwszAddrs);
    }
    *ppwszAddrs = pwszText;
    pwszText = NULL;

    // Set the proper return value
    hr = S_OK;

exit:
    if (FALSE != fBadAddrs)
    {
        AthMessageBoxW(hwndDlg, MAKEINTRESOURCEW(idsAthena),
                    MAKEINTRESOURCEW(idsRulesWarnEmptyEmail), NULL, MB_ICONINFORMATION | MB_OK);
    }
    SafeMemFree(pwszText);
    SafeRelease(pWabal);
    SafeRelease(pWabalExpand);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_FEnDisDialogItem
//
//  This enables or disables a control in a dialog.
//  The real special thing this function does is make sure
//  the focus of the dialog isn't stuck in a disabled control
//
//  Returns:    TRUE, if the enabled state was changed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL RuleUtil_FEnDisDialogItem(HWND hwndDlg, UINT idcItem, BOOL fEnable)
{
    BOOL    fRet = FALSE;
    HWND    hwndFocus = NULL;
    HWND    hwndItem = NULL;

    // check params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    hwndItem = GetDlgItem(hwndDlg, idcItem);
    
    // Make sure we aren't disabling the window with the focus
    if ((FALSE == fEnable) && (hwndItem == GetFocus()))
    {        
        SendMessage(hwndDlg, WM_NEXTDLGCTL, (WPARAM) 0, (LPARAM) LOWORD(FALSE)); 
    }

    // Enable or disable the window
    EnableWindow(hwndItem, fEnable);

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_AppendRichEditText
//
//  This sets a string into a richedit control with the proper style.
//
//  Returns:    S_OK, if the string was set
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_AppendRichEditText(HWND hwndRedit, ULONG ulStart, LPCWSTR pwszText, CHARFORMAT *pchfmt)
{
    CHARFORMAT  chFmtDef = {0};
    HRESULT     hr = S_OK;
    ULONG       cchText = 0;
    CHARRANGE   chrg = {0};

    // check params
    Assert(hwndRedit);
    Assert(pwszText);

    // Set the string into the richedit control
    chrg.cpMin = ulStart;
    chrg.cpMax = ulStart;
    RichEditExSetSel(hwndRedit, &chrg);

    // Figure out the string length
    cchText = lstrlenW(pwszText);
    SetRichEditText(hwndRedit, (LPWSTR)pwszText, TRUE, NULL, TRUE);

    chrg.cpMax = ulStart + cchText;
    RichEditExSetSel(hwndRedit, &chrg);

    // If we have a style to set on the string let's do it
    if (pchfmt)
    {
        SendMessage(hwndRedit, EM_SETCHARFORMAT, (WPARAM) SCF_SELECTION, (LPARAM)pchfmt);

        // Reset default settings for CHARFORMAT
        chrg.cpMin = ulStart + cchText;
        RichEditExSetSel(hwndRedit, &chrg);
        chFmtDef.cbSize = sizeof(chFmtDef);
        chFmtDef.dwMask = CFM_BOLD | CFM_UNDERLINE | CFM_COLOR;
        chFmtDef.dwEffects = CFE_AUTOCOLOR;
        SendMessage(hwndRedit, EM_SETCHARFORMAT, (WPARAM) SCF_SELECTION, (LPARAM)&chFmtDef);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_HrShowLinkedString
//
//  This writes a format string into a richedit control
//
//  Returns:    S_OK, if it was successfully written
//              E_FAIL, otherwise
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_HrShowLinkedString(HWND hwndEdit, BOOL fError, BOOL fReadOnly, 
                                LPWSTR pwszFmt, LPCWSTR pwszData, ULONG ulStart,
                                ULONG * pulStartLink, ULONG * pulEndLink, ULONG * pulEnd)
{
    HRESULT         hr = S_OK;
    CHARFORMAT      chfmt = {0};
    COLORREF        clr = 0;
    LPWSTR          pwszMark = NULL;
    ULONG           ulStartLink = 0;
    ULONG           ulEndLink = 0;

    if ((NULL == hwndEdit) || (NULL == pwszFmt) || (L'\0' == *pwszFmt))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing param
    if (pulStartLink)
    {
        *pulStartLink = 0;
    }
    if (pulEndLink)
    {
        *pulEndLink = 0;
    }
    if (pulEnd)
    {
        *pulEnd = 0;
    }
    
    // Find the underline mark
    pwszMark = StrStrW(pwszFmt, c_wszRuleMarkStart);
    if (NULL != pwszMark)
    {
        *pwszMark = L'\0';
    }

    // Write out the normal string
    RuleUtil_AppendRichEditText(hwndEdit, ulStart, pwszFmt, NULL);
    ulStart += lstrlenW(pwszFmt);
    
    // If we didn't have anything to underline
    // then we're done.
    if (NULL == pwszMark)
    {
        // Save off the new end
        if (NULL != pulEnd)
        {
            *pulEnd = ulStart;
        }

        // Return
        hr = S_OK;
        goto exit;
    }
    
    // Skip over the mark
    pwszFmt = pwszMark + lstrlenW(c_wszRuleMarkStart);

    // Find the mark end
    pwszMark = StrStrW(pwszFmt, c_wszRuleMarkEnd);
    if (NULL == pwszMark)
    {
        hr = E_FAIL;
        goto exit;
    }

    // If we don't have some data then 
    // just underline the original string
    if (NULL == pwszData)
    {
        *pwszMark = L'\0';
        pwszData = pwszFmt;
    }
    
    // Save off the character positions
    ulStartLink = ulStart;
    ulEndLink = ulStart + lstrlenW(pwszData);

    // If readonly, then don't add links
    if (fReadOnly)
        RuleUtil_AppendRichEditText(hwndEdit, ulStart, pwszData, NULL);
    else
    {
        if (fError)
            clr = RGB(255, 0, 0);
        else
            LookupLinkColors(&clr, NULL);

        // Which color should we use for underlining
        chfmt.crTextColor = clr;

        chfmt.cbSize = sizeof(chfmt);
        chfmt.dwMask = CFM_UNDERLINE | CFM_COLOR;
        chfmt.dwEffects = CFE_UNDERLINE;
        RuleUtil_AppendRichEditText(hwndEdit, ulStart, pwszData, &chfmt);
    }

    // Write out the linked string
    ulStart = ulEndLink;

    // Move to the next part of the string
    pwszFmt = pwszMark + lstrlenW(c_wszRuleMarkEnd);

    // If we have more of the string to write out
    if (L'\0' != *pwszFmt)
    {
        // Write out the rest of the string string
        RuleUtil_AppendRichEditText(hwndEdit, ulStart, pwszFmt, NULL);
        ulStart += lstrlenW(pwszFmt);
    }
    
    // Set the outgoing param
    if (pulStartLink)
    {
        *pulStartLink = ulStartLink;
    }
    if (pulEndLink)
    {
        *pulEndLink = ulEndLink;
    }
    if (pulEnd)
    {
        *pulEnd = ulStart;
    }
    
    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

HRESULT RuleUtil_HrDupCriteriaItem(CRIT_ITEM * pItemIn, ULONG cItemIn, CRIT_ITEM ** ppItemOut)
{
    HRESULT         hr = S_OK;
    ULONG           ulIndex = 0;
    CRIT_ITEM *     pItem = NULL;

    // Check incoming params
    if ((NULL == pItemIn) || (NULL == ppItemOut) || (0 == cItemIn))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing param
    *ppItemOut = NULL;
    
    // Allocate the initial list of criteria
    hr = HrAlloc((void **) &pItem, cItemIn * sizeof(*pItem));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the entire new criteria list
    ZeroMemory(pItem, cItemIn * sizeof(*pItem));
    
    // Walk over the list of criteria and set up the propvar for each one
    for (ulIndex = 0; ulIndex < cItemIn; ulIndex++)
    {
        // Copy over the criteria info
        pItem[ulIndex].type = pItemIn[ulIndex].type;
        pItem[ulIndex].dwFlags = pItemIn[ulIndex].dwFlags;
        pItem[ulIndex].logic = pItemIn[ulIndex].logic;
        
        // Copy over the propvar
        hr = PropVariantCopy(&(pItem[ulIndex].propvar), &(pItemIn[ulIndex].propvar));
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // Set the outgoing param
    *ppItemOut = pItem;
    pItem = NULL;
    
    // Set proper return value
    hr = S_OK;

exit:
    if (NULL != pItem)
    {
        RuleUtil_HrFreeCriteriaItem(pItem, cItemIn);
        MemFree(pItem);
    }
    return hr;
}

HRESULT RuleUtil_HrFreeCriteriaItem(CRIT_ITEM * pItem, ULONG cItem)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;

    // Check incoming params
    if ((NULL == pItem) || (0 == cItem))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Walk over the list of criteria and free each one
    for (ulIndex = 0; ulIndex < cItem; ulIndex++)
    {
        PropVariantClear(&(pItem[ulIndex].propvar));
    }

    // Set proper return value
    hr = S_OK;

exit:
    return hr;
}

HRESULT RuleUtil_HrDupActionsItem(ACT_ITEM * pItemIn, ULONG cItemIn, ACT_ITEM ** ppItemOut)
{
    HRESULT         hr = S_OK;
    ULONG           ulIndex = 0;
    ACT_ITEM *      pItem = NULL;

    // Check incoming params
    if ((NULL == pItemIn) || (NULL == ppItemOut) || (0 == cItemIn))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing param
    *ppItemOut = NULL;
    
    // Allocate the initial list of actions
    hr = HrAlloc((void **) &pItem, cItemIn * sizeof(*pItem));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the entire new actions list
    ZeroMemory(pItem, cItemIn * sizeof(*pItem));
    
    // Walk over the list of actions and set up the propvar for each one
    for (ulIndex = 0; ulIndex < cItemIn; ulIndex++)
    {
        // Copy over the actions info
        pItem[ulIndex].type = pItemIn[ulIndex].type;
        pItem[ulIndex].dwFlags = pItemIn[ulIndex].dwFlags;
        
        // Copy over the propvar
        hr = PropVariantCopy(&(pItem[ulIndex].propvar), &(pItemIn[ulIndex].propvar));
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // Set the outgoing param
    *ppItemOut = pItem;
    pItem = NULL;
    
    // Set proper return value
    hr = S_OK;

exit:
    SafeMemFree(pItem);
    return hr;
}

HRESULT RuleUtil_HrFreeActionsItem(ACT_ITEM * pItem, ULONG cItem)
{
    HRESULT     hr = S_OK;
    ULONG       ulIndex = 0;

    // Check incoming params
    if ((NULL == pItem) || (0 == cItem))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Walk over the list of criteria and free each one
    for (ulIndex = 0; ulIndex < cItem; ulIndex++)
    {
        PropVariantClear(&(pItem[ulIndex].propvar));
    }

    // Set proper return value
    hr = S_OK;

exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_HrAddBlockSender
//
//  This adds the address/domain name to the list of senders we will block
//
//  hwndOwner   - the window the owns this UI
//  pszAddr     - the address/domain name to add
//  dwFlags     - modifiers on how to add the address/domain name 
//
//  Returns:    S_OK, if the address/domain name was added
//              S_FALSE, if the address/domain name was already in the list
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_HrAddBlockSender(RULE_TYPE type, LPCSTR pszAddr)
{
    HRESULT         hr = S_OK;
    IOERule *       pIRuleOrig = NULL;
    IOERule *       pIRule = NULL;
    PROPVARIANT     propvar = {0};
    ACT_ITEM        aitem;
    CRIT_ITEM *     pcitem = NULL;
    ULONG           ccitem = 0;
    ULONG           ulIndex = 0;
    BOOL            fFound = FALSE;
    LPSTR           pszAddrNew = NULL;
    RULEINFO        infoRule = {0};

    // Check incoming params
    if ((NULL == pszAddr) || ('\0' == pszAddr[0]))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Get the block sender rule from the rules manager
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->GetRule(RULEID_SENDERS, type, 0, &pIRuleOrig);
    if (FAILED(hr))
    {
        // Create the new rule
        hr = RuleUtil_HrCreateSendersRule(0, &pIRule);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    // If the block sender rule exist
    else
    {
        // Clone it so we can make a change
        hr = pIRuleOrig->Clone(&pIRule);
        if (FAILED(hr))
        {
            goto exit;
        }

        SafeRelease(pIRuleOrig);
    }

    // Get the criteria list from the rules object
    hr = pIRule->GetProp(RULE_PROP_CRITERIA, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    Assert(VT_BLOB == propvar.vt);
    ccitem = propvar.blob.cbSize / sizeof(CRIT_ITEM);
    pcitem = (CRIT_ITEM *) propvar.blob.pBlobData;
    ZeroMemory(&propvar, sizeof(propvar));
    
    // Search for the address/domain name in the criteria list
    if (NULL != pcitem)
    {
        for (ulIndex = 0; ulIndex < ccitem; ulIndex++)
        {
            Assert(CRIT_TYPE_SENDER == pcitem[ulIndex].type)
            Assert(CRIT_LOGIC_OR == pcitem[ulIndex].logic)
            if ((VT_LPSTR != pcitem[ulIndex].propvar.vt) || (NULL == pcitem[ulIndex].propvar.pszVal))
            {
                continue;
            }
            
            if (0 == lstrcmpi(pszAddr, pcitem[ulIndex].propvar.pszVal))
            {
                fFound = TRUE;
                break;
            }
        }
    }
    
    // Did we find it?
    if (FALSE != fFound)
    {
        hr = S_FALSE;
        goto exit;
    }
    // Allocate space to hold the new criteria
    hr = HrRealloc((void **) &pcitem, (ccitem + 1) * sizeof(CRIT_ITEM));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Copy over the name
    pszAddrNew = PszDupA(pszAddr);
    if (NULL == pszAddrNew)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    // Add in to the end of the criteria list
    pcitem[ccitem].type =  CRIT_TYPE_SENDER;  
    pcitem[ccitem].dwFlags = CRIT_FLAG_DEFAULT;
    pcitem[ccitem].logic =  CRIT_LOGIC_OR;  
    pcitem[ccitem].propvar.vt =  VT_LPSTR;
    pcitem[ccitem].propvar.pszVal =  pszAddrNew;
    pszAddrNew = NULL;
    ccitem++;

    // Set the criteria back into the rule
    PropVariantClear(&propvar);
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = ccitem * sizeof(CRIT_ITEM);
    propvar.blob.pBlobData = (BYTE *) pcitem;
    hr = pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Initialize the rule info
    infoRule.ridRule = RULEID_SENDERS;
    infoRule.pIRule = pIRule;
    
    // Set the rule back into the rules manager
    hr = g_pRulesMan->SetRules(SETF_SENDER, type, &infoRule, 1);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszAddrNew);
    RuleUtil_HrFreeCriteriaItem(pcitem, ccitem);
    SafeMemFree(pcitem);
    PropVariantClear(&propvar);
    SafeRelease(pIRule);
    SafeRelease(pIRuleOrig);
    return hr;
}

HRESULT RuleUtil_HrMergeActions(ACT_ITEM * pActionsOrig, ULONG cActionsOrig,
                                ACT_ITEM * pActionsNew, ULONG cActionsNew,
                                ACT_ITEM ** ppActionsDest, ULONG * pcActionsDest)
{
    HRESULT     hr = S_OK;
    ACT_ITEM *  pActions = NULL;
    ULONG       cActions = 0;
    ULONG       ulIndex = 0;
    ULONG       ulAction = 0;
    ULONG       cActionsAdded = 0;
    ULONG       ulAdd = 0;
    
    // Verify incoming params
    if (((NULL == pActionsOrig) && (0 != cActionsOrig)) || (NULL == pActionsNew) || (0 == cActionsNew) ||
            (NULL == ppActionsDest) || (NULL == pcActionsDest))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    *ppActionsDest = NULL;
    *pcActionsDest = 0;
    
    // Allocate the maximum space to hold the destination actions
    hr = HrAlloc((VOID **) &pActions, (cActionsOrig + cActionsNew) * sizeof(*pActions));
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Initialize the destination actions list
    ZeroMemory(pActions, (cActionsOrig + cActionsNew) * sizeof(*pActions));
    
    // Copy over the original list to the destination actions list
    for (ulIndex = 0; ulIndex < cActionsOrig; ulIndex++)
    {
        // Copy over the actions info
        pActions[ulIndex].type = pActionsOrig[ulIndex].type;
        pActions[ulIndex].dwFlags = pActionsOrig[ulIndex].dwFlags;
        
        // Copy over the propvar
        hr = PropVariantCopy(&(pActions[ulIndex].propvar), &(pActionsOrig[ulIndex].propvar));
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // For each item in the new actions list
    cActionsAdded = cActionsOrig;
    for (ulIndex = 0; ulIndex < cActionsNew; ulIndex++)
    {

        // if it's a copy, fwd or reply
        if ((ACT_TYPE_COPY == pActionsNew->type) ||
                (ACT_TYPE_FWD == pActionsNew->type) ||
                (ACT_TYPE_REPLY == pActionsNew->type))
        {
            // Append it to the list
            ulAdd = cActionsAdded;
        }
        else
        {
            // Find the item in the new list
            for (ulAction = 0; ulAction < cActionsAdded; ulAction++)
            {
                // If we have a match, the replace it
                if (pActionsNew[ulIndex].type == pActions[ulAction].type)
                {
                    break;
                }
                // else, if we have some type of move operation
                // then replace it
                else if (((ACT_TYPE_MOVE == pActionsNew[ulIndex].type) ||
                        (ACT_TYPE_DELETE == pActionsNew[ulIndex].type) ||
                        (ACT_TYPE_JUNKMAIL == pActionsNew[ulIndex].type)) &&
                            ((ACT_TYPE_MOVE == pActions[ulAction].type) ||
                            (ACT_TYPE_DELETE == pActions[ulAction].type) ||
                            (ACT_TYPE_JUNKMAIL == pActions[ulAction].type)))
                {
                    break;
                }
            }

            // Did we find anything
            if (ulAction >= cActionsAdded)
            {
                ulAdd = cActionsAdded;
            }
            else
            {
                ulAdd = ulAction;
            }
        }

        // Replace the item
        pActions[ulAdd].type = pActionsNew[ulIndex].type;
        pActions[ulAdd].dwFlags = pActionsNew[ulIndex].dwFlags;

        // Clear out the old propvar
        PropVariantClear(&(pActions[ulAdd].propvar));
        
        // Copy over the propvar
        hr = PropVariantCopy(&(pActions[ulAdd].propvar), &(pActionsNew[ulIndex].propvar));
        if (FAILED(hr))
        {
            goto exit;
        }

        // If we added something
        if (ulAdd == cActionsAdded)
        {
            cActionsAdded++;
        }
    }
    
    // Set the outgoing params
    *ppActionsDest = pActions;
    pActions = NULL;
    *pcActionsDest = cActionsAdded;
    
    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

HRESULT RuleUtil_HrGetOldFormatString(HKEY hkeyRoot, LPCSTR pszValue, LPCSTR pszSep, LPSTR * ppszString, ULONG * pcchString)
{
    HRESULT     hr = S_OK;
    DWORD       dwType = 0;
    LPSTR       pszData = NULL;
    ULONG       cbData = 0;
    LPSTR       pszWalk = NULL;
    ULONG       ulIndex = 0;
    LPSTR       pszTerm = NULL;
    ULONG       cchLen = 0;
    ULONG       cchString = 0;
    LPSTR       pszString = NULL;
    LPSTR       pszOld = NULL;

    // Check incoming params
    if ((NULL == hkeyRoot) || (NULL == pszValue) || (NULL == pszSep) || (NULL == ppszString))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    *ppszString = NULL;
    if (NULL != pcchString)
    {
        *pcchString = 0;
    }

    // Get the old value from the registry
    hr = RuleUtil_HrGetRegValue(hkeyRoot, pszValue, &dwType, (BYTE **) &pszData, &cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Figure out the number of bytes needed
    pszWalk = pszData;
    cchString = 0;
    for (ulIndex = 0; ulIndex < cbData; ulIndex += cchLen, pszWalk += cchLen)
    {
        // Search for terminator
        pszTerm = StrStr(pszWalk, pszSep);

        // If we have a terminator
        if (NULL != pszTerm)
        {
            cchLen = (ULONG)(pszTerm - pszWalk + 1);
        }
        else
        {
            cchLen = lstrlen(pszWalk) + 1;
        }

        // If this isn't a null string
        if (1 != cchLen)
        {
            // Add the number of characters    
            cchString += cchLen;
        }
    }

    // Add in space to hold the terminator
    cchString += 2;

    // Allocate space to hold the final string
    hr = HrAlloc((VOID **) &pszString, cchString * sizeof(*pszString));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Copy over each string
    pszWalk = pszString;
    pszOld = pszData;
    for (ulIndex = 0; ulIndex < cbData; ulIndex += cchLen, pszOld += cchLen)
    {
        // Search for terminator
        pszTerm = StrStr(pszOld, pszSep);

        // If we have a terminator
        if (NULL != pszTerm)
        {
            cchLen = (ULONG)(pszTerm - pszOld + 1);
        }
        else
        {
            cchLen = lstrlen(pszOld) + 1;
        }

        // If this isn't a null string
        if (1 != cchLen)
        {
            // Copy over the string
            lstrcpyn(pszWalk, pszOld, cchLen);
            
            // Move to the next string
            pszWalk += lstrlen(pszWalk) + 1;
        }
    }

    // Terminate the string
    pszWalk[0] = '\0';
    pszWalk[1] = '\0';
    
    // Set the outgoing params
    *ppszString = pszString;
    pszString = NULL;
    if (NULL != pcchString)
    {
        *pcchString = cchString;
    }

    // Set the return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszString);
    SafeMemFree(pszData);
    return hr;
}

// ------------------------------------------------------------------------------------
// _FIsLoopingAddress
// ------------------------------------------------------------------------------------
BOOL _FIsLoopingAddress(LPCSTR pszAddressTo)
{
    // Locals
    HRESULT             hr=S_OK;
    LPSTR               pszAddress=NULL;
    CHAR                szFrom[CCHMAX_EMAIL_ADDRESS];
    BOOL                fResult=FALSE;
    IImnEnumAccounts   *pEnum=NULL;
    IImnAccount        *pAccount=NULL;

    // Check State
    Assert(pszAddressTo);

    // Enumerate the user's SMTP and POP3 Accounts
    CHECKHR(hr = g_pAcctMan->Enumerate(SRV_POP3 | SRV_SMTP, &pEnum));

    // Duplicate the To Address
    CHECKALLOC(pszAddress = PszDupA(pszAddressTo));

    // Make it lower case
    CharLower(pszAddress);

    // Enumerate
    while(SUCCEEDED(pEnum->GetNext(&pAccount)))
    {
        // Get Email Address
        if (SUCCEEDED(pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szFrom, ARRAYSIZE(szFrom))))
        {
            // Lower it
            CharLower(szFrom);

            // Is this to myself
            if (StrStr(pszAddress, szFrom) || StrStr(szFrom, pszAddress))
            {
                fResult = TRUE;
                goto exit;
            }
        }

        // Done
        SafeRelease(pAccount);
    }

exit:
    // Cleanup
    SafeRelease(pEnum);
    SafeRelease(pAccount);
    SafeMemFree(pszAddress);

    // Done
    return fResult;
}

// ------------------------------------------------------------------------------------
// _HrAutoForwardMessage
// ------------------------------------------------------------------------------------
HRESULT _HrAutoForwardMessage(HWND hwndUI, LPCSTR pszForwardTo, LPCSTR pszAcctId, IStream *pstmMsg, BOOL *pfLoop)
{
    // Locals
    HRESULT              hr=S_OK;
    IMimeMessage        *pMessage=NULL;
    PROPVARIANT          rUserData;
    IMimeAddressTable   *pAddrTable=NULL;
    CHAR                 szDisplayName[CCHMAX_DISPLAY_NAME];
    CHAR                 szEmailAddress[CCHMAX_EMAIL_ADDRESS];
    HTMLOPT              rHtmlOpt;
    PLAINOPT             rPlainOpt;
    BOOL                 fHTML;
    IImnAccount         *pAccount=NULL;
    PROPVARIANT          rOption;
    CHAR                 szId[CCHMAX_ACCOUNT_NAME];
    BOOL                 fUseDefaultAcct = FALSE;
    BOOL                 fSendImmediate = FALSE;

    // check Params
    Assert(pstmMsg && pszForwardTo && pfLoop);

    // Init
    *pfLoop = FALSE;

    // Is the new recipient the same as my current email address
    if (NULL == pszForwardTo || _FIsLoopingAddress(pszForwardTo))
    {
        *pfLoop = TRUE;
        return TrapError(E_FAIL);
    }

    // Open the Account
    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAcctId, &pAccount);

    // If we couldn't find the account, then just use the default
    if (FAILED(hr))
    {
        CHECKHR(hr = g_pAcctMan->GetDefaultAccount(ACCT_MAIL, &pAccount));
        fUseDefaultAcct = TRUE;
    }

    // Create a Message
    CHECKHR(hr = HrCreateMessage(&pMessage));

    // Lets rewind pstmReplyWith
    CHECKHR(hr = HrRewindStream(pstmMsg));

    // Load String into my message object
    CHECKHR(hr = pMessage->Load(pstmMsg));

    // Get the wabal
    CHECKHR(hr = pMessage->GetAddressTable(&pAddrTable));

    // Remove all of the recipients...
    CHECKHR(hr = pAddrTable->DeleteTypes(IAT_ALL));

    // Get Originator Display Name
    CHECKHR(hr = pAccount->GetPropSz(AP_SMTP_DISPLAY_NAME, szDisplayName, ARRAYSIZE(szDisplayName)));

    // Get Originator Email Name
    CHECKHR(hr = pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmailAddress, ARRAYSIZE(szEmailAddress)));

    // Add Sender...
    CHECKHR(hr = pAddrTable->Append(IAT_FROM, IET_DECODED, szDisplayName, szEmailAddress, NULL));

    // Add Recipient
    CHECKHR(hr = pAddrTable->AppendRfc822(IAT_TO, IET_DECODED, pszForwardTo));

    // Save the AccountID
    rUserData.vt = VT_LPSTR;
    if (FALSE == fUseDefaultAcct)
    {
        rUserData.pszVal = (LPSTR) pszAcctId;
    }
    else
    {
        if (SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_ID, szId, sizeof(szId))))
        {
            rUserData.pszVal = szId;
        }
        else
        {
            rUserData.pszVal = (LPSTR) pszAcctId;
        }
    }
    pMessage->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), 0, &rUserData);

    // Save the Account
    CHECKHR(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, szId, sizeof(szId)))
    rUserData.pszVal = szId;
    pMessage->SetProp(STR_ATT_ACCOUNTNAME, 0, &rUserData);
    
    // Raid-33842: Set the date
    CHECKHR(hr = HrSetSentTimeProp(pMessage, NULL));

    // Get Mail Options
    GetDefaultOptInfo(&rHtmlOpt, &rPlainOpt, &fHTML, FMT_MAIL);

    // Store the options on the messaage
    CHECKHR(hr = HrSetMailOptionsOnMessage(pMessage, &rHtmlOpt, &rPlainOpt, NULL, fHTML));

    // Raid-63259: MIMEOLE - Creating message ID causes autodialer to fire
    // Raid-50793: Athena: Should be setting message-ID's in email
#if 0
    rOption.vt = VT_BOOL;
    rOption.boolVal = TRUE;
    pMessage->SetOption(OID_GENERATE_MESSAGE_ID, &rOption);
#endif

    // Should we send it immediately?
    fSendImmediate = DwGetOption(OPT_SENDIMMEDIATE);
    
    // Send the message
    CHECKHR(hr = HrSendMailToOutBox(hwndUI, pMessage, fSendImmediate, TRUE));

exit:
    // Cleanup
    SafeRelease(pMessage);
    SafeRelease(pAddrTable);
    SafeRelease(pAccount);

    // done
    return hr;
}

// ------------------------------------------------------------------------------------
// _HrAutoReplyMessage
// ------------------------------------------------------------------------------------
HRESULT _HrAutoReplyMessage(HWND hwndUI, DWORD dwType, LPCSTR pszFilename, IStream * pstmFile,
    LPCSTR pszAcctId, IMimeMessage *pMsgIn, BOOL *pfLoop)
{
    // Locals
    HRESULT             hr=S_OK;
    CHAR                szRe[20];
    IMimeMessage       *pMsgOut=NULL;
    LPSTR               pszNewSubj=NULL,
                        pszCurSubj=NULL,
                        pszNormal;
    IMimeAddressTable  *pTable=NULL;
    ADDRESSPROPS        rSender;
    HBODY               hBody;
    CHAR                szDisplayName[CCHMAX_DISPLAY_NAME];
    CHAR                szEmailAddress[CCHMAX_EMAIL_ADDRESS];
    PROPVARIANT         rUserData;
    HTMLOPT             rHtmlOpt;
    PLAINOPT            rPlainOpt;
    BOOL                fHTML;
    IImnAccount         *pAccount=NULL;
    PROPVARIANT         rOption;
    CHAR                szId[CCHMAX_ACCOUNT_NAME];
    BOOL                fUseDefaultAcct = FALSE;
    BOOL                fSendImmediate = FALSE;

    // Problems
    // PMsgIn can be NULL in here (Access Dineied for S/MIME messages.
    // shoul return immediatelly
    if(!pMsgIn)
        return(hr);

    Assert(pszFilename && pstmFile && pMsgIn && pfLoop);

    // Init
    *pfLoop = FALSE;

    // Init
    ZeroMemory(&rSender, sizeof(ADDRESSPROPS));

    // Open the Account
    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAcctId, &pAccount);

    // If we couldn't find the account, then just use the default
    if (FAILED(hr))
    {
        CHECKHR(hr = g_pAcctMan->GetDefaultAccount(ACCT_MAIL, &pAccount));
        fUseDefaultAcct = TRUE;
    }

    // Create a Message
    CHECKHR(hr = HrCreateMessage(&pMsgOut));

    // Lets rewind pstmFile
    CHECKHR(hr = HrRewindStream(pstmFile));

    // RW_HTML
    switch (dwType)
    {
        case RFT_HTML:
            // Use the stream as the message body
            CHECKHR(hr = pMsgOut->SetTextBody(TXT_HTML, IET_DECODED, NULL, pstmFile, NULL));
            break;

        case RFT_TEXT:
            // Use the stream as the message body
            CHECKHR(hr = pMsgOut->SetTextBody(TXT_PLAIN, IET_DECODED, NULL, pstmFile, NULL));
            break;

        case RFT_MESSAGE:
            // Use the stream as a message attachment
            CHECKHR(hr = pMsgOut->AttachObject(IID_IStream, pstmFile, &hBody));

            // Note that the attachment is a message
            MimeOleSetBodyPropA(pMsgOut, hBody, PIDTOSTR(PID_HDR_CNTTYPE), NOFLAGS, STR_MIME_MSG_RFC822);
            break;

        case RFT_FILE:
            // Attach File
            CHECKHR(hr = pMsgOut->AttachFile(pszFilename, pstmFile, NULL));
            break;

        default:
            Assert(FALSE);
            hr = E_FAIL;
            goto exit;
            break;
    }
    
    // Get Re:
    AthLoadString(idsPrefixReply, szRe, ARRAYSIZE(szRe));

    // Get the normalized subject
    if (SUCCEEDED(MimeOleGetBodyPropA(pMsgIn, HBODY_ROOT, STR_ATT_NORMSUBJ, NOFLAGS, &pszCurSubj)))
        pszNormal = pszCurSubj;

    // Fixup if null...
    pszNormal = pszNormal ? pszNormal : (LPTSTR)c_szEmpty;

    // Allocate the subject...
    CHECKALLOC(pszNewSubj = PszAllocA(lstrlen(szRe) + lstrlen(pszNormal) + 5));

    // Build the subject
    wsprintf(pszNewSubj, "%s%s", szRe, pszNormal);

    // Set the subject
    CHECKHR(hr = MimeOleSetBodyPropA(pMsgOut, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, pszNewSubj));

    // Get the message Wabal
    rSender.dwProps = IAP_EMAIL | IAP_FRIENDLY;
    CHECKHR(hr = pMsgIn->GetSender(&rSender));
    Assert(rSender.pszEmail && ISFLAGSET(rSender.dwProps, IAP_EMAIL));

    // Is the new recipient the same as my current email address
    if (_FIsLoopingAddress(rSender.pszEmail))
    {
        *pfLoop = TRUE;
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Add to recipient list of autgen message
    CHECKHR(hr = pMsgOut->GetAddressTable(&pTable));

    // Modify rSender Address Type
    rSender.dwAdrType = IAT_TO;
    FLAGSET(rSender.dwProps, IAP_ADRTYPE);

    // Append Sender as the recipient
    CHECKHR(hr = pTable->Insert(&rSender, NULL));

    // Get Originator Display Name
    CHECKHR(hr = pAccount->GetPropSz(AP_SMTP_DISPLAY_NAME, szDisplayName, ARRAYSIZE(szDisplayName)));

    // Get Originator Email Name
    CHECKHR(hr = pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmailAddress, ARRAYSIZE(szEmailAddress)));

    // Append Sender
    CHECKHR(hr = pTable->Append(IAT_FROM, IET_DECODED, szDisplayName, szEmailAddress, NULL));

    // Save the AccountID
    rUserData.vt = VT_LPSTR;
    if (FALSE == fUseDefaultAcct)
    {
        rUserData.pszVal = (LPSTR) pszAcctId;
    }
    else
    {
        if (SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_ID, szId, sizeof(szId))))
        {
            rUserData.pszVal = szId;
        }
        else
        {
            rUserData.pszVal = (LPSTR) pszAcctId;
        }
    }
    pMsgOut->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), 0, &rUserData);

    // Save the Account
    CHECKHR(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, szId, sizeof(szId)))
    rUserData.pszVal = szId;
    pMsgOut->SetProp(STR_ATT_ACCOUNTNAME, 0, &rUserData);
    
    // Raid-33842: Set the date
    CHECKHR(hr = HrSetSentTimeProp(pMsgOut, NULL));

    // Get Mail Options
    GetDefaultOptInfo(&rHtmlOpt, &rPlainOpt, &fHTML, FMT_MAIL);

    // Store the options on the messaage
    CHECKHR(hr = HrSetMailOptionsOnMessage(pMsgOut, &rHtmlOpt, &rPlainOpt, NULL, fHTML));

    // Raid-63259: MIMEOLE - Creating message ID causes autodialer to fire
    // Raid-50793: Athena: Should be setting message-ID's in email
#if 0
    rOption.vt = VT_BOOL;
    rOption.boolVal = TRUE;
    pMsgOut->SetOption(OID_GENERATE_MESSAGE_ID, &rOption);
#endif

    // Should we send it immediately?
    fSendImmediate = DwGetOption(OPT_SENDIMMEDIATE);
    
    // Send the message
    CHECKHR(hr = HrSendMailToOutBox(hwndUI, pMsgOut, fSendImmediate, TRUE));

exit:
    // Cleanup
    SafeRelease(pTable);
    SafeMemFree(pszCurSubj);
    SafeMemFree(pszNewSubj);
    SafeRelease(pMsgOut);
    SafeRelease(pAccount);
    g_pMoleAlloc->FreeAddressProps(&rSender);

    // Done
    return hr;
}

HRESULT _HrRecurseSetFilter(FOLDERINFO * pfldinfo, BOOL fSubFolders, DWORD cIndent, DWORD_PTR dwCookie)
{
    RULEID              ridRule = RULEID_INVALID;
    IMessageFolder *    pFolder = NULL;
    FOLDERUSERDATA      UserData = {0};

    ridRule = (RULEID) dwCookie;

    if (RULEID_INVALID == ridRule)
    {
        goto exit;
    }

    // If not hidden
    if ((0 != (pfldinfo->dwFlags & FOLDER_HIDDEN)) || (FOLDERID_ROOT == pfldinfo->idFolder))
    {
        goto exit;
    }

    // Not Subscribed
    if (0 == (pfldinfo->dwFlags & FOLDER_SUBSCRIBED))
    {
        goto exit;
    }

    // Server node
    if (0 != (pfldinfo->dwFlags & FOLDER_SERVER))
    {
        goto exit;
    }

    if (FAILED(g_pStore->OpenFolder(pfldinfo->idFolder, NULL, OPEN_FOLDER_NOCREATE, &pFolder)))
    {
        goto exit;
    }

    if ((FOLDER_LOCAL == pfldinfo->tyFolder) && (RULEID_VIEW_DOWNLOADED == ridRule))
    {
        ridRule = RULEID_VIEW_ALL;
    }
    
    // Create the struct to insert
    if (FAILED(pFolder->GetUserData(&UserData, sizeof(FOLDERUSERDATA))))
    {
        goto exit;
    }

    UserData.ridFilter = ridRule;
    UserData.dwFilterVersion = 0xFFFFFFFF;
    
    if (FAILED(pFolder->SetUserData(&UserData, sizeof(FOLDERUSERDATA))))
    {
        goto exit;
    }

exit:
    SafeRelease(pFolder);
    return S_OK;
}

HRESULT RuleUtil_HrApplyRulesToFolder(DWORD dwFlags, DWORD dwDeleteFlags,
            IOEExecRules * pIExecRules, IMessageFolder * pFolder, HWND hwndUI, CProgress * pProgress)
{
    HRESULT             hr = S_OK;
    HCURSOR             hcursor = NULL;
    FOLDERID            idFolder = FOLDERID_ROOT;
    HLOCK               hLockNotify = NULL;
    HROWSET             hRowset = NULL;
    MESSAGEINFO         Message = {0};
    IMimeMessage *      pIMMsg = NULL;
    IMimePropertySet *  pIMPropSet = NULL;
    ACT_ITEM *          pActions = NULL;
    ULONG               cActions = 0;
    DWORD               dwExecFlags = 0;
    
    // Wait Cursor
    if (NULL == pProgress)
    {
        hcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    }

    // Check incoming params
    if ((NULL == pIExecRules) || (NULL == pFolder))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Get the Folder Id
    hr = pFolder->GetFolderId(&idFolder);
    if (FAILED(hr))
    {
        goto exit;
    }

    // We handle partial messages for News
    if (FOLDER_NEWS != GetFolderType(idFolder))
    {
        dwExecFlags |= ERF_SKIPPARTIALS;
    }
    
    // This forces all notifications to be queued (this is good since you do segmented deletes)
    pFolder->LockNotify(0, &hLockNotify);

    // Create a Rowset
    hr = pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Loop
    while (S_OK == pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        // Do we need to only handle partial messages?
        if ((0 == (dwFlags & RULE_APPLY_PARTIALS)) || (MESSAGE_COMBINED == Message.dwPartial))
        {
            // Open the message object if it's available
            if (Message.faStream)
            {
                if (SUCCEEDED(pFolder->OpenMessage(Message.idMessage, 0, &pIMMsg, NOSTORECALLBACK)))
                {
                    pIMMsg->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pIMPropSet);
                }
            }

            // Get the Actions for this rule
            hr = pIExecRules->ExecuteRules(dwExecFlags, Message.pszAcctId, &Message, pFolder, pIMPropSet,
                                    pIMMsg, Message.cbMessage, &pActions, &cActions);

            // Free up the stuff we're not using anymore
            SafeRelease(pIMPropSet);

            // Did we find anything?
            if (S_OK == hr)
            {
                // Apply this action
                SideAssert(SUCCEEDED(RuleUtil_HrApplyActions(hwndUI, pIExecRules, &Message, 
                                    pFolder, pIMMsg, dwDeleteFlags, pActions, cActions, NULL, NULL)));

                // Free up the actions
                RuleUtil_HrFreeActionsItem(pActions, cActions);
                SafeMemFree(pActions);
            }
            
            SafeRelease(pIMMsg);
        }
        
        pFolder->FreeRecord(&Message);
        
        // Update progress
        if (NULL != pProgress)
        {
            if (S_OK != pProgress->HrUpdate(1))
            {
                hr = S_FALSE;
                goto exit;
            }
        }        
    }
    
    hr = S_OK;
    
exit:
    RuleUtil_HrFreeActionsItem(pActions, cActions);
    SafeMemFree(pActions);
    SafeRelease(pIMPropSet);
    SafeRelease(pIMMsg);
    pFolder->FreeRecord(&Message);
    pFolder->CloseRowset(&hRowset);
    if (NULL != hLockNotify)
    {
        pFolder->UnlockNotify(&hLockNotify);
    }
    if (NULL == pProgress)
    {
        SetCursor(hcursor);
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_HrImportRules
//
//  This imports the rules from a file
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_HrImportRules(HWND hwnd)
{
    HRESULT             hr = S_OK;
    OPENFILENAME        ofn;
    CHAR                szFilename[MAX_PATH] = _T("");
    CHAR                szFilter[MAX_PATH] = _T("");
    CHAR                szDefExt[20] = _T("");
    IStream *           pIStm = NULL;
    CLSID               clsid = {0};
    ULONG               cbRead = 0;
    ULONG               cRules = 0;
    RULEINFO *          pinfoRule = NULL;
    CProgress *         pProgress = NULL;
    ULONG               ulIndex = 0;
    IOERule *           pIRule = NULL;
    IPersistStream *    pIPStm = NULL;
    DWORD               dwData = 0;
    RULE_TYPE           type;
    
    // Load Res Strings
    LoadStringReplaceSpecial(idsRulesFilter, szFilter, sizeof(szFilter));
    AthLoadString(idsDefRulesExt, szDefExt, sizeof(szDefExt));
    
    // Setup Save file struct
    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFilename;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrDefExt = szDefExt;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;
    
    hr = HrAthGetFileName(&ofn, TRUE);
    if (S_OK != hr)
    {
        goto exit;
    }
    
    hr = CreateStreamOnHFile(szFilename, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
                            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL, &pIStm);
    if (FAILED(hr))
    {
        goto exit;
    }

    // MAke sure we have a file using our Rules Manager
    hr = pIStm->Read(&clsid, sizeof(clsid), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbRead == sizeof(clsid));
    
    if (clsid != CLSID_OERulesManager)
    {
        Assert("Ahhhhh This is a bogus file!!!!!");
        hr = E_FAIL;
        goto exit;
    }

    // Read in the version of the rules file format
    hr = pIStm->Read(&dwData, sizeof(dwData), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbRead == sizeof(dwData));

    // Check the file format version
    if (dwData != RULE_FILE_VERSION)
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena),
                    MAKEINTRESOURCEW(idsRulesErrBadFileFormat), NULL, MB_ICONINFORMATION | MB_OK);
        hr = E_FAIL;
        goto exit;
    }
    
    // Get the count of rules in the file
    hr = pIStm->Read(&cRules, sizeof(cRules), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbRead == sizeof(cRules));

    // Allocate space to hold all of the rules
    hr = HrAlloc((void **) &pinfoRule, cRules * sizeof(*pinfoRule));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize it to a known value
    ZeroMemory(pinfoRule, cRules * sizeof(*pinfoRule));
    
    // Get the type of rules in the file
    hr = pIStm->Read(&dwData, sizeof(dwData), &cbRead);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbRead == sizeof(dwData));

    type = (RULE_TYPE) dwData;
    
    // Set up the progress dialog
    pProgress = new CProgress;
    if (NULL == pProgress)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pProgress->Init(hwnd, MAKEINTRESOURCE(idsAthena),
                            MAKEINTRESOURCE(idsApplyingRules), cRules, 0, TRUE, FALSE);

    // Show progress in 2 second
    pProgress->Show(0);
        
    for (ulIndex = 0; ulIndex < cRules; ulIndex++)
    {
        SafeRelease(pIRule);
        
        // Create a new rule
        hr = HrCreateRule(&pIRule);
        if (FAILED(hr))
        {
            continue;
        }

        SafeRelease(pIPStm);

        // Get the persistance interface from the rule
        hr = pIRule->QueryInterface(IID_IPersistStream, (void **) &pIPStm);
        if (FAILED(hr))
        {
            continue;
        }

        // Load in the rule from the file
        hr = pIPStm->Load(pIStm);
        if (FAILED(hr))
        {
            continue;
        }
        
        // Add the rule to the list
        pinfoRule[ulIndex].ridRule = RULEID_INVALID;
        pinfoRule[ulIndex].pIRule = pIRule;
        pIRule = NULL;
        
        // Bump up the progress dialog
        hr = pProgress->HrUpdate(1);
        if (S_OK != hr)
        {
            break;
        }        
    }

    // Add the rules to the rules manager
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->SetRules(SETF_APPEND, type, pinfoRule, cRules);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    hr = S_OK;
    
exit:
    SafeRelease(pIRule);
    SafeRelease(pProgress);
    SafeRelease(pIPStm);
    if (NULL != pinfoRule)
    {
        for (ulIndex = 0; ulIndex < cRules; ulIndex++)
        {
            SafeRelease(pinfoRule[ulIndex].pIRule);
        }
        MemFree(pinfoRule);
    }
    SafeRelease(pIStm);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_HrExportRules
//
//  This exports the rules into a file
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_HrExportRules(HWND hwnd)
{
    HRESULT             hr = S_OK;
    OPENFILENAME        ofn;
    CHAR                szFilename[MAX_PATH] = _T("");
    CHAR                szFilter[MAX_PATH] = _T("");
    CHAR                szDefExt[20] = _T("");
    IStream *           pIStm = NULL;
    ULONG               cbWritten = 0;
    IOEEnumRules *      pIEnumRules = NULL;
    ULONG               cpIRule = 0;
    IPersistStream *    pIPStm = NULL;
    CProgress *         pProgress = NULL;
    ULONG               ulIndex = 0;
    IOERule *           pIRule = NULL;
    LARGE_INTEGER       liSeek = {0};
    DWORD               dwData = 0;
    
    // Load Res Strings
    LoadStringReplaceSpecial(idsRulesFilter, szFilter, sizeof(szFilter));
    AthLoadString(idsDefRulesExt, szDefExt, sizeof(szDefExt));
    AthLoadString(idsRulesDefFile, szFilename, sizeof(szFilename));
    
    // Setup Save file struct
    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFilename;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrDefExt = szDefExt;
    ofn.Flags = OFN_NOCHANGEDIR | OFN_NOREADONLYRETURN | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    
    hr = HrAthGetFileName(&ofn, FALSE);
    if (S_OK != hr)
    {
        goto exit;
    }
    
    hr = CreateStreamOnHFile(szFilename, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
                           CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL, &pIStm);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Write out the class id for the Rules Manager
    hr = pIStm->Write(&CLSID_OERulesManager, sizeof(CLSID_OERulesManager), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(CLSID_OERulesManager));

    // Write out the version of the rules format
    dwData = RULE_FILE_VERSION;
    hr = pIStm->Write(&dwData, sizeof(dwData), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(dwData));
    
    // Get the list of rules
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->EnumRules(ENUMF_EDIT, RULE_TYPE_MAIL, &pIEnumRules);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Figure out the total number of rules
    cpIRule = 0;
    while (S_OK == pIEnumRules->Next(1, &pIRule, NULL))
    {
        cpIRule++;
        SafeRelease(pIRule);
    }

    hr = pIEnumRules->Reset();
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Write out the number of rules going to be exported
    hr = pIStm->Write(&cpIRule, sizeof(cpIRule), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(cpIRule));
    
    // Write out the type of rules going to be exported
    dwData = RULE_TYPE_MAIL;
    hr = pIStm->Write(&dwData, sizeof(dwData), &cbWritten);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(cbWritten == sizeof(dwData));
    
    // Set up the progress dialog
    pProgress = new CProgress;
    if (NULL == pProgress)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pProgress->Init(hwnd, MAKEINTRESOURCE(idsAthena),
                            MAKEINTRESOURCE(idsApplyingRules), cpIRule, 0, TRUE, FALSE);

    // Show progress in 2 seconds
    pProgress->Show(0);
        
    for (ulIndex = 0; ulIndex < cpIRule; ulIndex++)
    {
        // Get the next rule
        SafeRelease(pIRule);
        hr = pIEnumRules->Next(1, &pIRule, NULL);
        if (FAILED(hr))
        {
            continue;
        }
        Assert(S_OK == hr);
        
        SafeRelease(pIPStm);
        if (FAILED(pIRule->QueryInterface(IID_IPersistStream, (void **) &pIPStm)))
        {
            continue;
        }

        if (FAILED(pIPStm->Save(pIStm, FALSE)))
        {
            continue;
        }
        
        // Update progress
        if (S_OK != pProgress->HrUpdate(1))
        {
            // Change the rule count to the proper total
            liSeek.QuadPart = sizeof(CLSID_OERulesManager);
            if (SUCCEEDED(pIStm->Seek(liSeek, STREAM_SEEK_SET, NULL)))
            {
                ulIndex++;
                SideAssert(SUCCEEDED(pIStm->Write(&ulIndex, sizeof(ulIndex), &cbWritten)));
                Assert(cbWritten == sizeof(ulIndex));
            }
            break;
        }        
    }

    hr = S_OK;
    
exit:
    SafeRelease(pIPStm);
    SafeRelease(pIRule);
    SafeRelease(pProgress);
    SafeRelease(pIEnumRules);
    SafeRelease(pIStm);
    return hr;
}

typedef struct _tagFOLDERIDMAP
{
    FOLDERID   dwFldIdOld;
    FOLDERID   dwFldIdNew;
} FOLDERIDMAP, * PFOLDERIDMAP;

HRESULT RuleUtil_HrMapFldId(DWORD dwFlags, BYTE * pbFldIdMap, FOLDERID fldidOld, FOLDERID * pfldidNew)
{
    HRESULT         hr = S_OK;
    ULONG           cmpfldid = 0;
    FOLDERIDMAP *   pmpfldid;
    ULONG           ulIndex = 0;

    // Verify incoming params
    if ((NULL == pbFldIdMap) || (FOLDERID_INVALID == fldidOld) || (NULL == pfldidNew))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Initialize the outgoing param
    *pfldidNew = FOLDERID_INVALID;

    cmpfldid = *((DWORD *) pbFldIdMap);

    if (0 == cmpfldid)
    {
        goto exit;
    }

    pmpfldid = (FOLDERIDMAP *) (pbFldIdMap + sizeof(cmpfldid));

    for (ulIndex = 0; ulIndex < cmpfldid; ulIndex++)
    {
        if (fldidOld == pmpfldid[ulIndex].dwFldIdOld)
        {
            *pfldidNew = pmpfldid[ulIndex].dwFldIdNew;
            break;
        }
    }
    
    // Set the return value
    hr = (FOLDERID_INVALID != *pfldidNew) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

HRESULT RuleUtil_HrGetUserData(DWORD dwFlags, LPSTR * ppszFirstName, LPSTR * ppszLastName, LPSTR * ppszCompanyName)
{
    HRESULT         hr = S_OK;
    LPWAB           pWab = NULL;
    LPWABOBJECT     pWabObj = NULL;
    SBinary         sbEID = {0};
    IAddrBook *     pIAddrBook = NULL;
    ULONG           ulObjType = 0;
    IMailUser *     pIMailUser = NULL;
    SizedSPropTagArray(3, ptaDefMailUser) = {3, {PR_GIVEN_NAME_A, PR_SURNAME_A, PR_COMPANY_NAME_A}};
    ULONG           cProps = 0;
    LPSPropValue    pProps = NULL;
    LPSPropValue    pPropsWalk = NULL;
    
    if ((NULL == ppszFirstName) || (NULL == ppszLastName) || (NULL == ppszCompanyName))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *ppszFirstName = NULL;
    *ppszLastName = NULL;
    *ppszCompanyName = NULL;

    // Get Wab object
    hr = HrCreateWabObject(&pWab);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pWab->HrGetWabObject(&pWabObj);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pWab->HrGetAdrBook(&pIAddrBook);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Do we already have a concept of me?
    hr = pWabObj->GetMe(pIAddrBook, AB_NO_DIALOG | WABOBJECT_ME_NOCREATE, NULL, &sbEID, NULL);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Open the entry
    hr = pIAddrBook->OpenEntry(sbEID.cb, (ENTRYID *)(sbEID.lpb), NULL, 0, &ulObjType, (IUnknown **) &pIMailUser);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the relevant info
    hr = pIMailUser->GetProps((LPSPropTagArray) &ptaDefMailUser, 0, &cProps, &pProps);
    if (FAILED(hr))
    {
        goto exit;
    }

    pPropsWalk = pProps;
    
    // Grab the first name if it exists
    if ((PR_GIVEN_NAME_A == pPropsWalk->ulPropTag) && (NULL != pPropsWalk->Value.lpszA))
    {
        *ppszFirstName = PszDupA(pPropsWalk->Value.lpszA);
    }

    pPropsWalk++;
    
    // Grab the last name if it exists
    if ((PR_SURNAME_A == pPropsWalk->ulPropTag) && (NULL != pPropsWalk->Value.lpszA))
    {
        *ppszLastName = PszDupA(pPropsWalk->Value.lpszA);
    }

    pPropsWalk++;
    
    // Grab the company name if it exists
    if ((PR_COMPANY_NAME_A == pPropsWalk->ulPropTag) && (NULL != pPropsWalk->Value.lpszA))
    {
        *ppszCompanyName = PszDupA(pPropsWalk->Value.lpszA);
    }

    hr = S_OK;
    
exit:
    SafeRelease(pIMailUser);
    if (NULL != pWabObj)
    {
        if (NULL != pProps)
        {
            pWabObj->FreeBuffer(pProps);
        }
        
        if (NULL != sbEID.lpb)
        {
            pWabObj->FreeBuffer(sbEID.lpb);
        }
    }
    SafeRelease(pWab);
    return hr;
}

HRESULT _HrMarkThreadAsWatched(MESSAGEID idMessage, IMessageFolder * pFolder, ADJUSTFLAGS * pflgWatch)
{
    HRESULT             hr = S_OK;
    MESSAGEINFO         infoMessage = {0};

    // Check incoming param
    if ((MESSAGEID_INVALID == idMessage) || (NULL == pFolder) || (NULL == pflgWatch))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Get the message info
    hr = GetMessageInfo(pFolder, idMessage, &infoMessage);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Add Flags
    FLAGSET(infoMessage.dwFlags, pflgWatch->dwAdd);

    // ClearFlags
    FLAGCLEAR(infoMessage.dwFlags, pflgWatch->dwRemove);

    // Update the Message
    IF_FAILEXIT(hr = pFolder->UpdateRecord(&infoMessage));

    // Set the return value
    hr = S_OK;
    
exit:
    pFolder->FreeRecord(&infoMessage);
    return hr;
}

HRESULT RuleUtil_HrApplyActions(HWND hwndUI, IOEExecRules * pIExecRules, MESSAGEINFO * pMsgInfo,
                                IMessageFolder * pFolder, IMimeMessage * pIMMsg, DWORD dwDeleteFlags,
                                ACT_ITEM * pActions, ULONG cActions, ULONG * pcInfiniteLoops, BOOL *pfDeleteOffServer)
{
    HRESULT             hr = S_OK;
    ULONG               ulIndex = 0;
    FOLDERID            idFolder = 0;
    ACT_ITEM *          pActionsList = NULL;
    IMessageFolder *    pFolderNew = NULL;
    MESSAGEIDLIST       List = {0};
    ADJUSTFLAGS         Flags = {0};
    DWORD               dwType = RFT_HTML;
    IStream *           pIStm = NULL;
    LPSTR               pszExt = NULL;
    BOOL                fLoop = FALSE;
    DWORD               dwFlag = 0;
    FOLDERID            idFolderJunkMail = FOLDERID_INVALID;
    RULEFOLDERDATA *    prfdData = NULL;
    BOOL                fSetFlags = FALSE;
    DWORD               dwFlagRemove = 0;
    BOOL                fDoWatch = FALSE;
    ADJUSTFLAGS         WatchFlags = {0};
    
    // Check incoming params
    if ((NULL == pIExecRules) || (NULL == pMsgInfo) || (NULL == pActions) || (NULL == pFolder))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Init
    if (pfDeleteOffServer)
        *pfDeleteOffServer = FALSE;
    
    // Initialize the list
    List.cMsgs = 1;
    List.prgidMsg = &(pMsgInfo->idMessage);
    
    // Get the folder id of the message
    hr = pFolder->GetFolderId(&idFolder);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Do all modification operations first
    for (pActionsList = pActions, ulIndex = 0; ulIndex < cActions; ulIndex++, pActionsList++)
    {
        switch(pActionsList->type)
        {
        case ACT_TYPE_HIGHLIGHT:
            Assert(pActionsList->propvar.vt == VT_UI4);
            // Is there something to do?
            if (pMsgInfo->wHighlight != (WORD) (pActionsList->propvar.ulVal))
            {
                pMsgInfo->wHighlight = (WORD) (pActionsList->propvar.ulVal);
                pFolder->UpdateRecord(pMsgInfo);
            }
            break;
            
        case ACT_TYPE_WATCH:
            Assert(pActionsList->propvar.vt == VT_UI4);
            // Is there something to do?
            if (ACT_DATA_WATCHTHREAD == pActions[ulIndex].propvar.ulVal)
            {
                dwFlag = ARF_WATCH;
                dwFlagRemove = ARF_IGNORE;
            }
            else
            {
                Assert(ACT_DATA_IGNORETHREAD == pActions[ulIndex].propvar.ulVal);
                dwFlag = ARF_IGNORE;
                dwFlagRemove = ARF_WATCH;
            }
            
            // Is there something to do?
            if (0 == (pMsgInfo->dwFlags & dwFlag))
            {
                // Init flags
                WatchFlags.dwAdd |= dwFlag;
                WatchFlags.dwRemove |= dwFlagRemove;
                
                // Mark as watched/ignored
                fDoWatch = TRUE;
            }
            break;
            
        case ACT_TYPE_FLAG:
            Assert(pActionsList->propvar.vt == VT_EMPTY);
            // Is there something to do?
            if (0 == (pMsgInfo->dwFlags & ARF_FLAGGED))
            {
                // Init flags
                Flags.dwAdd |= ARF_FLAGGED;
                
                // Flag the message
                fSetFlags = TRUE;
            }
            break;
            
        case ACT_TYPE_READ:
            Assert(pActionsList->propvar.vt == VT_EMPTY);
            // Is there something to do?
            if (0 == (pMsgInfo->dwFlags & ARF_READ))
            {
                // Init flags
                Flags.dwAdd |= ARF_READ;
                Flags.dwRemove = 0;
                
                // Mark as read
                fSetFlags = TRUE;
            }
            break;
            
        case ACT_TYPE_MARKDOWNLOAD:
            Assert(pActionsList->propvar.vt == VT_EMPTY);
            // Is there something to do?
            if (0 == (pMsgInfo->dwFlags & ARF_DOWNLOAD))
            {
                // Init flags
                Flags.dwAdd |= ARF_DOWNLOAD;
                Flags.dwRemove = 0;
                
                // Mark as downloaded
                fSetFlags = TRUE;
            }
            break;
            
        case ACT_TYPE_FWD:
            Assert(VT_LPSTR == pActionsList->propvar.vt);
            SafeRelease(pIStm);
            // Check message secure or not
            if(NULL != pIMMsg)
            {
                pIMMsg->GetFlags(&dwFlag);
                
                // Get the message source
                if (!(IMF_SECURE & dwFlag) &&
                    (SUCCEEDED(pIMMsg->GetMessageSource(&pIStm, 0))))
                {
                    // Auto Forward
                    fLoop = FALSE;
                    if ((FAILED(_HrAutoForwardMessage(hwndUI, pActionsList->propvar.pszVal,
                        pMsgInfo->pszAcctId, pIStm, &fLoop))) && (FALSE != fLoop))
                    {
                        if (NULL != pcInfiniteLoops)
                        {
                            (*pcInfiniteLoops)++;
                        }
                    }
                    else
                    {
                        // Is there something to do?
                        if (0 == (pMsgInfo->dwFlags & ARF_FORWARDED))
                        {
                            // Init flags
                            Flags.dwAdd |= ARF_FORWARDED;
                            Flags.dwRemove = 0;
                            
                            // Mark as forwarded
                            fSetFlags = TRUE;
                        }
                    }
                }
            }
            break;
            
        case ACT_TYPE_REPLY:
            Assert(VT_LPSTR == pActionsList->propvar.vt);
            // Auto Reply
            fLoop = FALSE;
            SafeRelease(pIStm);
            if (SUCCEEDED(pIExecRules->GetRuleFile(pActionsList->propvar.pszVal, &pIStm, &dwType)))
            {
                if ((FAILED(_HrAutoReplyMessage(hwndUI, dwType, pActionsList->propvar.pszVal, pIStm,
                    pMsgInfo->pszAcctId, pIMMsg, &fLoop))) && (FALSE != fLoop))
                {
                    if (NULL != pcInfiniteLoops)
                    {
                        (*pcInfiniteLoops)++;
                    }
                }
                else
                {
                    // Is there something to do?
                    if (0 == (pMsgInfo->dwFlags & ARF_REPLIED))
                    {
                        // Init flags
                        Flags.dwAdd |= ARF_REPLIED;
                        Flags.dwRemove = 0;
                        
                        // Mark as replied
                        fSetFlags = TRUE;
                    }
                }
            }
            break;
        }
    }
    
    // Should we set the flags?
    if (FALSE != fSetFlags)
    {
        SetMessageFlagsProgress(hwndUI, pFolder, &Flags, &List);
    }
    
    // Should we watch the message?
    if (FALSE != fDoWatch)
    {
        _HrMarkThreadAsWatched(pMsgInfo->idMessage, pFolder, &WatchFlags);
    }
    
    // Do all non-modification operations next
    for (pActionsList = pActions, ulIndex = 0; ulIndex < cActions; ulIndex++, pActionsList++)
    {
        switch(pActionsList->type)
        {
        case ACT_TYPE_COPY:
        case ACT_TYPE_MOVE:
            Assert(VT_BLOB == pActionsList->propvar.vt);
            
            if (0 == pActionsList->propvar.blob.cbSize)
            {
                hr = S_FALSE;
                goto exit;
            }
            
            // Make life simpler
            prfdData = (RULEFOLDERDATA *) (pActionsList->propvar.blob.pBlobData);
            
            // Validate the rule folder data
            if (S_OK != RuleUtil_HrValidateRuleFolderData(prfdData))
            {
                hr = S_FALSE;
                goto exit;
            }
            
            // Is there something to do?
            if (idFolder != prfdData->idFolder)
            {
                hr = pIExecRules->GetRuleFolder(prfdData->idFolder, (DWORD_PTR *) (&pFolderNew));
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Move/copy the messages
                CopyMessagesProgress(hwndUI, pFolder, pFolderNew,
                    (pActionsList->type != ACT_TYPE_COPY) ? COPY_MESSAGE_MOVE : NOFLAGS,
                    &List, NULL);
            }
            break;
            
        case ACT_TYPE_NOTIFYMSG:
            // Nothing to do for now
            break;
            
        case ACT_TYPE_NOTIFYSND:
            Assert(VT_LPSTR == pActionsList->propvar.vt);
            hr = pIExecRules->AddSoundFile(ASF_PLAYIFNEW, pActionsList->propvar.pszVal);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
            
        case ACT_TYPE_DELETE:
            Assert(pActionsList->propvar.vt == VT_EMPTY);
            DeleteMessagesProgress(hwndUI, pFolder, dwDeleteFlags | DELETE_MESSAGE_NOPROMPT, &List);
            break;
            
        case ACT_TYPE_JUNKMAIL:
            Assert(pActionsList->propvar.vt == VT_EMPTY);
            
            // Get the Junk Mail folder id, if we don't already have it
            if (FOLDERID_INVALID == idFolderJunkMail)
            {
                FOLDERINFO Folder;
                
                hr = g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_JUNK, &Folder);
                if (FAILED(hr))
                {
                    goto exit;;
                }
                
                idFolderJunkMail = Folder.idFolder;
                
                g_pStore->FreeRecord(&Folder);
            }
            
            hr = pIExecRules->GetRuleFolder(idFolderJunkMail, (DWORD_PTR *) (&pFolderNew));
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Move the messages
            CopyMessagesProgress(hwndUI, pFolder, pFolderNew, COPY_MESSAGE_MOVE, &List, NULL);
            break;
            
        case ACT_TYPE_DELETESERVER:
            if (pfDeleteOffServer)
                *pfDeleteOffServer = TRUE;
            break;
            
        case ACT_TYPE_DONTDOWNLOAD:
            // Nothing to do for now
            break;
            
        case ACT_TYPE_STOP:
            // Nothing to do for now
            break;
        }
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeRelease(pIStm);
    return hr;
}

HRESULT RuleUtil_HrCreateSendersRule(DWORD dwFlags, IOERule ** ppIRule)
{
    HRESULT     hr = S_OK;
    IOERule *   pIRule = NULL;
    PROPVARIANT propvar = {0};
    TCHAR       szRes[CCHMAX_STRINGRES];
    ACT_ITEM    aitem;
    
    // Check incoming params
    if (NULL == ppIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the list
    *ppIRule = NULL;

    // Create the new rule
    hr = HrCreateRule(&pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the name
    if (0 != LoadString(g_hLocRes, idsBlockSender, szRes, ARRAYSIZE(szRes)))
    {
        propvar.vt = VT_LPSTR;
        propvar.pszVal = szRes;
        
        // Set the name
        hr = pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);
        ZeroMemory(&propvar, sizeof(propvar));
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    
    // Set the normal action
    ZeroMemory(&aitem, sizeof(aitem));
    aitem.type = ACT_TYPE_DELETE;
    aitem.dwFlags = ACT_FLAG_DEFAULT;
    
    PropVariantClear(&propvar);
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = sizeof(ACT_ITEM);
    propvar.blob.pBlobData = (BYTE *) &aitem;
    hr = pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the outgoing param
    *ppIRule  = pIRule;
    pIRule = NULL;

    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeRelease(pIRule);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _HrLoadSender
//
//  This creates the sender rule
//
//
//  Returns:    S_OK, if it was rules were successfully created
//              S_FALSE, if the rules were already created
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_HrLoadSender(LPCSTR pszRegPath, DWORD dwFlags, IOERule ** ppIRule)
{
    HRESULT     hr = S_OK;
    HKEY        hkeyRoot = NULL;
    LONG        lErr = ERROR_SUCCESS;
    DWORD       dwData = 0;
    ULONG       cbData = 0;
    TCHAR       szRes[CCHMAX_STRINGRES];
    IOERule *   pIRule = NULL;

    Assert(NULL != pszRegPath);
    Assert(NULL != ppIRule);
    
    // Let's get access to the sender root key
    lErr = AthUserOpenKey(pszRegPath, KEY_ALL_ACCESS, &hkeyRoot);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        hr = E_FAIL;
        goto exit;
    }

    // If we don't have it saved, then we're done
    if (ERROR_FILE_NOT_FOUND == lErr)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Make sure we have a name
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyRoot, c_szRuleName, 0, NULL, NULL, &cbData);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Do we have to set the name?
    if (ERROR_FILE_NOT_FOUND == lErr)
    {
        // Get the name
        if (0 == LoadString(g_hLocRes, idsBlockSender, szRes, ARRAYSIZE(szRes)))
        {
            hr = E_FAIL;
            goto exit;
        }
        
        // Set the name
        lErr = RegSetValueEx(hkeyRoot, c_szRuleName, 0, REG_SZ, (BYTE *) szRes, lstrlen(szRes) + 1);
        if (ERROR_SUCCESS != lErr)
        {
            hr = E_FAIL;
            goto exit;
        }
    }

    // Create the rule
    hr = HrCreateRule(&pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Load in the rule
    hr = pIRule->LoadReg(pszRegPath);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the outgoing param
    *ppIRule = pIRule;
    pIRule = NULL;
    
    // Set the return value
    hr = S_OK;
    
exit:    
    SafeRelease(pIRule);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_FMatchSender
//
//  This match the sender to the message
//
//
//  Returns:    S_OK, if it was in the sender of the message
//              S_FALSE, if it was not the sender of the message
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_HrMatchSender(LPCSTR pszSender, MESSAGEINFO * pMsgInfo,
                        IMimeMessage * pIMMsg, IMimePropertySet * pIMPropSet)
{
    HRESULT             hr = S_OK;
    LPSTR               pszAddr = NULL;
    ADDRESSPROPS        rSender = {0};
    IMimeAddressTable * pIAddrTable = NULL;
    BOOL                fMatch = FALSE;
    ULONG               cchVal = 0;
    ULONG               cchEmail = 0;
    CHAR                chTest = 0;

    // Do we have good values
    if ((NULL == pszSender) || ((NULL == pMsgInfo) && (NULL == pIMMsg) && (NULL == pIMPropSet)))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Check to make sure that there's something to match
    if ('\0' == pszSender[0])
    {
        hr = S_FALSE;
        goto exit;
    }

    // Get the address
    if ((NULL != pMsgInfo) && (NULL != pMsgInfo->pszEmailFrom))
    {
        pszAddr = pMsgInfo->pszEmailFrom;
    }
    else if (NULL != pIMMsg)
    {
        rSender.dwProps = IAP_EMAIL;
        if (SUCCEEDED(pIMMsg->GetSender(&rSender)))
        {
            pszAddr = rSender.pszEmail;
        }
    }
    else if ((NULL != pIMPropSet) && (SUCCEEDED(pIMPropSet->BindToObject(IID_IMimeAddressTable, (LPVOID *)&pIAddrTable))))
    {
        rSender.dwProps = IAP_EMAIL;
        if (SUCCEEDED(pIAddrTable->GetSender(&rSender)))
        {
            pszAddr = rSender.pszEmail;
        }

        pIAddrTable->Release();
    }

    // Did we find anything?
    if (NULL == pszAddr)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Check to see if it is an address
    if (NULL != StrStrI(pszSender, "@"))
    {
        fMatch = (0 == lstrcmpi(pszSender, pszAddr));
    }
    else
    {
        cchVal = lstrlen(pszSender);
        cchEmail = lstrlen(pszAddr);
        if (cchVal <= cchEmail)
        {
            fMatch = (0 == lstrcmpi(pszSender, pszAddr + (cchEmail - cchVal)));
            if ((FALSE != fMatch) && (cchVal != cchEmail))
            {
                chTest = *(pszAddr + (cchEmail - cchVal - 1));
                if (('@' != chTest) && ('.' != chTest))
                {
                    fMatch = FALSE;
                }
            }
        }
    }

    // Set the proper return value
    hr = (FALSE != fMatch) ? S_OK : S_FALSE;
    
exit:
    g_pMoleAlloc->FreeAddressProps(&rSender);
    return hr;
}

HRESULT RuleUtil_HrValidateRuleFolderData(RULEFOLDERDATA * prfdData)
{
    HRESULT         hr = S_OK;
    STOREUSERDATA   UserData = {0};

    // Check incoming params
    if (NULL == prfdData)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Get the timestamp for the store
    hr = g_pStore->GetUserData(&UserData, sizeof(STOREUSERDATA));
    if (FAILED(hr))
    {
        goto exit;
    }
        
    // Is the stamp correct
    if ((UserData.ftCreated.dwLowDateTime != prfdData->ftStamp.dwLowDateTime) ||
            (UserData.ftCreated.dwHighDateTime != prfdData->ftStamp.dwHighDateTime))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Set the proper return value
    hr = S_OK;

exit:
    return hr;
}       

///////////////////////////////////////////////////////////////////////////////
//
//  _HrSetDefaultCriteria
//
//  This creates a default rule in the specified location
//
//
//  Returns:    S_OK, if it was rules were successfully created
//              S_FALSE, if the rules were already created
//
///////////////////////////////////////////////////////////////////////////////
HRESULT _HrSetDefaultCriteria(IOERule * pIRule, const DEFAULT_RULE * pdefRule)
{
    HRESULT     hr = S_OK;
    PROPVARIANT propvar = {0};
    CRIT_ITEM   rgCritItem[CDEF_CRIT_ITEM_MAX];
    ULONG       cCritItem = 0;
    
    Assert(NULL != pIRule);
    Assert(NULL != pdefRule);

    // Initialize the criteria
    ZeroMemory(rgCritItem, sizeof(*rgCritItem) * CDEF_CRIT_ITEM_MAX);
    
    // Set the criteria
    switch (pdefRule->critType)
    {
        case DEF_CRIT_ALLMSGS:
            cCritItem = 1;
            rgCritItem[0].type = CRIT_TYPE_ALL;
            rgCritItem[0].dwFlags = CRIT_FLAG_DEFAULT;
            rgCritItem[0].propvar.vt = VT_EMPTY;
            rgCritItem[0].logic = CRIT_LOGIC_NULL;
            break;

        case DEF_CRIT_READ:
            cCritItem = 1;
            rgCritItem[0].type = CRIT_TYPE_READ;
            rgCritItem[0].dwFlags = CRIT_FLAG_DEFAULT;
            rgCritItem[0].propvar.vt = VT_EMPTY;
            rgCritItem[0].logic = CRIT_LOGIC_NULL;
            break;
            
        case DEF_CRIT_DWNLDMSGS:
            cCritItem = 1;
            rgCritItem[0].type = CRIT_TYPE_DOWNLOADED;
            rgCritItem[0].dwFlags = CRIT_FLAG_DEFAULT;
            rgCritItem[0].propvar.vt = VT_EMPTY;
            rgCritItem[0].logic = CRIT_LOGIC_NULL;
            break;
    
        case DEF_CRIT_IGNTHDS:
            cCritItem = 2;
            rgCritItem[0].type = CRIT_TYPE_THREADSTATE;
            rgCritItem[0].dwFlags = CRIT_FLAG_DEFAULT;
            rgCritItem[0].propvar.vt = VT_UI4;
            rgCritItem[0].propvar.ulVal = CRIT_DATA_IGNORETHREAD;
            rgCritItem[0].logic = CRIT_LOGIC_OR;
            rgCritItem[1].type = CRIT_TYPE_READ;
            rgCritItem[1].dwFlags = CRIT_FLAG_DEFAULT;
            rgCritItem[1].propvar.vt = VT_EMPTY;
            rgCritItem[1].logic = CRIT_LOGIC_NULL;
            break;
    
        default:
            hr = E_INVALIDARG;
            goto exit;
    }
    
    // Set the rule criteria
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cCritItem * sizeof(CRIT_ITEM);
    propvar.blob.pBlobData = (BYTE *) rgCritItem;
    
    hr = pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _HrSetDefaultActions
//
//  This creates a default rule in the specified location
//
//
//  Returns:    S_OK, if it was rules were successfully created
//              S_FALSE, if the rules were already created
//
///////////////////////////////////////////////////////////////////////////////
HRESULT _HrSetDefaultActions(IOERule * pIRule, const DEFAULT_RULE * pdefRule)
{
    HRESULT     hr = S_OK;
    PROPVARIANT propvar = {0};
    ACT_ITEM    rgActItem[CDEF_ACT_ITEM_MAX];
    ULONG       cActItem = 0;
    
    Assert(NULL != pIRule);
    Assert(NULL != pdefRule);

    // Initialize the actions
    ZeroMemory(rgActItem, sizeof(*rgActItem) * CDEF_ACT_ITEM_MAX);
    
    // Set the actions
    switch (pdefRule->actType)
    {
        case DEF_ACT_SHOWMSGS:
            cActItem = 1;
            rgActItem[0].type = ACT_TYPE_SHOW;
            rgActItem[0].dwFlags = ACT_FLAG_DEFAULT;
            rgActItem[0].propvar.vt = VT_UI4;
            rgActItem[0].propvar.ulVal = ACT_DATA_SHOW;
            break;

        case DEF_ACT_HIDEMSGS:
            cActItem = 1;
            rgActItem[0].type = ACT_TYPE_SHOW;
            rgActItem[0].dwFlags = ACT_FLAG_DEFAULT;
            rgActItem[0].propvar.vt = VT_UI4;
            rgActItem[0].propvar.ulVal = ACT_DATA_HIDE;
            break;

        default:
            hr = E_INVALIDARG;
            goto exit;
    }
    
    // Set the rule actions
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cActItem * sizeof(ACT_ITEM);
    propvar.blob.pBlobData = (BYTE *) rgActItem;
    
    hr = pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _HrUpdateDefaultRule
//
//  This creates a default rule in the specified location
//
//
//  Returns:    S_OK, if it was rules were successfully created
//              S_FALSE, if the rules were already created
//
///////////////////////////////////////////////////////////////////////////////
HRESULT _HrUpdateDefaultRule(LPCSTR pszRegPath, const DEFAULT_RULE * pdefRule)
{
    HRESULT     hr = S_OK;
    IOERule *   pIRule = NULL;
    TCHAR       szFullPath[CCHMAX_STRINGRES];
    TCHAR       szName[CCHMAX_STRINGRES];
    PROPVARIANT propvar = {0};
    
    Assert(NULL != pszRegPath);
    Assert(NULL != pdefRule);

    // Whip up a rule
    hr = HrCreateRule(&pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Build up the rule path
    if(lstrlen(pszRegPath) >= sizeof(szFullPath) / sizeof(szFullPath[0]))
    {
        hr = E_FAIL;
        goto exit;
    }

    lstrcpy(szFullPath, pszRegPath);
    lstrcat(szFullPath, g_szBackSlash);
    wsprintf(szFullPath + lstrlen(szFullPath), "%03X", pdefRule->ridRule);
    
    // Do we need to do anything?
    hr = pIRule->LoadReg(szFullPath);
    if (SUCCEEDED(hr))
    {
        // Get the version from the rule
        hr = pIRule->GetProp(RULE_PROP_VERSION, 0, &propvar);
        if (SUCCEEDED(hr))
        {
            Assert(VT_UI4 == propvar.vt);
            // Is the rule too old?
            if (pdefRule->dwVersion <= propvar.ulVal)
            {
                //Bug# 67782
                //We reload the name of the string every time in case, a localized version of OE is installed.
                if (SUCCEEDED(hr = RuleUtil_SetName(pIRule, pdefRule->idName)))
                {
                    if (SUCCEEDED(pIRule->SaveReg(szFullPath, TRUE)))
                        hr = S_FALSE;
                }
                goto exit;
            }
        }
    }

    //Bug# 67782
    //We reload the name of the string every time in case, a localized version of OE is installed.
    hr = RuleUtil_SetName(pIRule, pdefRule->idName);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the rule version
    propvar.vt = VT_UI4;
    propvar.ulVal = pdefRule->dwVersion - 1;
    
    hr = pIRule->SetProp(RULE_PROP_VERSION, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the rule criteria
    hr = _HrSetDefaultCriteria(pIRule, pdefRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the rule actions
    hr = _HrSetDefaultActions(pIRule, pdefRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Save the rule
    hr = pIRule->SaveReg(szFullPath, TRUE);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeRelease(pIRule);
    return hr;
}

HRESULT RuleUtil_SetName(IOERule    *pIRule, int idRes)
{
    HRESULT     hr = S_OK;
    TCHAR       szName[CCHMAX_STRINGRES];
    PROPVARIANT propvar = {0};

    if (0 == AthLoadString(idRes, szName, ARRAYSIZE(szName)))
    {
        hr = E_FAIL;
        goto exit;
    }
        
    // Set the rule name
    ZeroMemory(&propvar, sizeof(propvar));
    propvar.vt = VT_LPSTR;
    propvar.pszVal = szName;
    
    hr = pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);

exit:
    return hr;

}


///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil_HrUpdateDefaultRules
//
//  This updates the default rules for the specified rule type
//  when the version in the registry is older than the current
//  version
//
//  Returns:    S_OK, if it was rules were successfully updated
//              S_FALSE, if the rules were already at the correct version
//
///////////////////////////////////////////////////////////////////////////////
HRESULT RuleUtil_HrUpdateDefaultRules(RULE_TYPE typeRule)
{
    HRESULT                 hr = S_OK;
    LPCSTR                  pszSubKey = NULL;
    LONG                    lErr = ERROR_SUCCESS;
    HKEY                    hkeyRoot = NULL;
    DWORD                   dwData = 0;
    ULONG                   cbData = 0;
    const DEFAULT_RULE *    pdefrule = NULL;
    ULONG                   cpdefrule = 0;
    LPCSTR                  pszOrderDef = NULL;
    ULONG                   ulIndex = 0;
    
    // If we're already loaded then
    // there's nothing to do
    switch(typeRule)
    {
        case RULE_TYPE_FILTER:
            pszSubKey = c_szRulesFilter;
            pdefrule = g_defruleFilters;
            cpdefrule = ARRAYSIZE(g_defruleFilters);
            pszOrderDef = g_szOrderFilterDef;
            break;
            
        default:
            // Nothing to do..
            hr = S_FALSE;
            goto exit;
    }
    
    // Check to see if the Rule node already exists
    lErr = AthUserOpenKey(pszSubKey, KEY_ALL_ACCESS, &hkeyRoot);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    // Check the current version
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyRoot, c_szRulesVersion, NULL, NULL, (BYTE *) &dwData, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        hr = HRESULT_FROM_WIN32(lErr);
        goto exit;
    }

    Assert(RULESMGR_VERSION == dwData);

    // Update out the default rules
    for (ulIndex = 0; ulIndex < cpdefrule; ulIndex++, pdefrule++)
    {
        hr = _HrUpdateDefaultRule(pszSubKey, pdefrule);
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // Write out the default order
    if (NULL != pszOrderDef)
    {
        // If the order already exists, then leave it alone
        lErr = RegQueryValueEx(hkeyRoot, c_szRulesOrder, NULL, NULL, NULL, &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            lErr = RegSetValueEx(hkeyRoot, c_szRulesOrder, 0,
                                REG_SZ, (CONST BYTE *) pszOrderDef, lstrlen(pszOrderDef) + 1);
            if (ERROR_SUCCESS != lErr)
            {
                hr = HRESULT_FROM_WIN32(lErr);
                goto exit;
            }
        }
    }
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return hr;
}

//--------------------------------------------------------------------------
// RuleUtil_HrGetFilterVersion
//--------------------------------------------------------------------------
HRESULT RuleUtil_HrGetFilterVersion(RULEID ridFilter, DWORD * pdwVersion)
{
    HRESULT     hr = S_OK;
    IOERule *   pIRule = NULL;
    PROPVARIANT propvar = {0};
    
    TraceCall("_GetFilterVersion");

    Assert(NULL != pdwVersion);

    // Is there something to do
    if (RULEID_INVALID == ridFilter)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Initialize the outgoing param
    *pdwVersion = 0;

    // Get the rule from the rules manager
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->GetRule(ridFilter, RULE_TYPE_FILTER, 0, &pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the version from the rule
    hr = pIRule->GetProp(RULE_PROP_VERSION, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Set the outgoing param
    Assert(VT_UI4 == propvar.vt);
    *pdwVersion = propvar.ulVal;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    PropVariantClear(&propvar);
    SafeRelease(pIRule);
    return hr;
}

//--------------------------------------------------------------------------
// _HrWriteClause
//--------------------------------------------------------------------------
HRESULT _HrWriteClause(IStream * pStm, ULONG cClauses, BOOL fAnd, LPCSTR pszClause)
{
    HRESULT     hr = S_OK;
    LPCSTR      pszLogic = NULL;

    // Do we have something to write
    if (NULL != pszClause)
    {
        // Add the proper logical operation
        if (cClauses > 0)
        {
            if (FALSE != fAnd)
            {
                pszLogic = c_szLogicalAnd;
            }
            else
            {
                pszLogic = c_szLogicalOr;
            }
            
            // Write Logical And
            IF_FAILEXIT(hr = pStm->Write(pszLogic, lstrlen(pszLogic), NULL));
        }

        // Write out the clause
        IF_FAILEXIT(hr = pStm->Write(pszClause, lstrlen(pszClause), NULL));

        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }
    
exit:
    return hr;
}

//--------------------------------------------------------------------------
// _HrWriteFromClause
//--------------------------------------------------------------------------
HRESULT _HrWriteFromClause(IStream * pStream, ULONG cClauses, BOOL fAnd, DWORD dwFlags, LPCSTR pszText, ULONG * pcClausesNew)
{
    HRESULT     hr = S_OK;
    ULONG       cClausesOld = 0;
    LPCSTR      pszLogic = NULL;
    LPCTSTR     pszContains = NULL;

    Assert(pStream && pszText && pcClausesNew);
    
    // Add the proper logical operation
    if (cClauses > 0)
    {
        if (FALSE != fAnd)
        {
            pszLogic = c_szLogicalAnd;
        }
        else
        {
            pszLogic = c_szLogicalOr;
        }
        
        // Write Logical And
        IF_FAILEXIT(hr = pStream->Write(pszLogic, lstrlen(pszLogic), NULL));
    }

    // Figure out the logical operation
    if (0 != (dwFlags & CRIT_FLAG_MULTIPLEAND))
    {
        pszLogic = c_szLogicalAnd;
    }
    else
    {
        pszLogic = c_szLogicalOr;
    }
    
    // Write the proper comparison op
    if (0 == (dwFlags & CRIT_FLAG_INVERT))
    {
        pszContains = c_szFilterShow;
    }
    else
    {
        pszContains = c_szFilterHide;
    }
    
    // Write the left parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szLeftParen, lstrlen(c_szLeftParen), NULL));

    // Write Logical And
    IF_FAILEXIT(hr = pStream->Write(pszContains, lstrlen(pszContains), NULL));
    
    // Write the left parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szLeftParen, lstrlen(c_szLeftParen), NULL));

    // Add each of the addresses to the stream
    cClausesOld = cClauses;
    for (; '\0' != pszText[0]; pszText += lstrlen(pszText) + 1)
    {
        if ((cClauses - cClausesOld) > 0)
        {
            // Write Logical And
            IF_FAILEXIT(hr = pStream->Write(pszLogic, lstrlen(pszLogic), NULL));
        }

        // Open the criteria
        IF_FAILEXIT(hr = pStream->Write(c_szLeftParen, lstrlen(c_szLeftParen), NULL));
        
        // Write (MSGCOL_EMAILFROM containsi 
        IF_FAILEXIT(hr = pStream->Write(c_szEmailFromAddrPrefix, lstrlen(c_szEmailFromAddrPrefix), NULL));

        // Write a Quote
        IF_FAILEXIT(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));

        // Write a Email Address
        IF_FAILEXIT(hr = pStream->Write(pszText, lstrlen(pszText), NULL));

        // Write a Quote
        IF_FAILEXIT(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));

        // Close the MSGCOL_EMAILFROM
        IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));
        
        // Write Logical Or
        IF_FAILEXIT(hr = pStream->Write(c_szLogicalOr, lstrlen(c_szLogicalOr), NULL));
        
        // Write (MSGCOL_DISPLAYFROM containsi 
        IF_FAILEXIT(hr = pStream->Write(c_szEmailFromPrefix, lstrlen(c_szEmailFromPrefix), NULL));

        // Write a Quote
        IF_FAILEXIT(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));

        // Write a Email Address
        IF_FAILEXIT(hr = pStream->Write(pszText, lstrlen(pszText), NULL));

        // Write a Quote
        IF_FAILEXIT(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));

        // Close the MSGCOL_DISPLAYFROM
        IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));
        
        // Close the criteria
        IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));

        cClauses++;
    }

    // Write the right parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));
    
    // Write the right parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));
    
    // Set the outgoing param
    *pcClausesNew = cClauses - cClausesOld;
    
    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

//--------------------------------------------------------------------------
// _HrWriteTextClause
//--------------------------------------------------------------------------
HRESULT _HrWriteTextClause(IStream * pStream, ULONG cClauses, BOOL fAnd, DWORD dwFlags, LPCSTR pszHeader, LPCSTR pszText, ULONG * pcClausesNew)
{
    HRESULT     hr = S_OK;
    ULONG       cClausesOld = 0;
    LPCSTR      pszLogic = NULL;
    LPCTSTR     pszContains = NULL;

    Assert(pStream && pszText && pcClausesNew);

    // Add the proper logical operation
    if (cClauses > 0)
    {
        if (FALSE != fAnd)
        {
            pszLogic = c_szLogicalAnd;
        }
        else
        {
            pszLogic = c_szLogicalOr;
        }
        
        // Write Logical And
        IF_FAILEXIT(hr = pStream->Write(pszLogic, lstrlen(pszLogic), NULL));
    }

    // Figure out the logical operation
    if (0 != (dwFlags & CRIT_FLAG_MULTIPLEAND))
    {
        pszLogic = c_szLogicalAnd;
    }
    else
    {
        pszLogic = c_szLogicalOr;
    }
    
    // Write the proper comparison op
    if (0 == (dwFlags & CRIT_FLAG_INVERT))
    {
        pszContains = c_szFilterShow;
    }
    else
    {
        pszContains = c_szFilterHide;
    }
    
    // Write the left parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szLeftParen, lstrlen(c_szLeftParen), NULL));

    // Write Logical And
    IF_FAILEXIT(hr = pStream->Write(pszContains, lstrlen(pszContains), NULL));
    
    // Write the left parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szLeftParen, lstrlen(c_szLeftParen), NULL));

    // Add each of the words to the stream
    cClausesOld = cClauses;
    for (; '\0' != pszText[0]; pszText += lstrlen(pszText) + 1)
    {
        if ((cClauses - cClausesOld) > 0)
        {
            // Write Logical And
            IF_FAILEXIT(hr = pStream->Write(pszLogic, lstrlen(pszLogic), NULL));
        }

        // Write (MSGCOL_EMAILFROM containsi 
        IF_FAILEXIT(hr = pStream->Write(pszHeader, lstrlen(pszHeader), NULL));

        // Write a Quote
        IF_FAILEXIT(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));

        // Write a Email Address
        IF_FAILEXIT(hr = pStream->Write(pszText, lstrlen(pszText), NULL));

        // Write a Quote
        IF_FAILEXIT(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));

        // Write Left Paren
        IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));

        cClauses++;
    }

    // Write the right parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));
    
    // Write the right parenthesis
    IF_FAILEXIT(hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL));
    
    // Set the outgoing param
    *pcClausesNew = cClauses - cClausesOld;
    
    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

//--------------------------------------------------------------------------
// _HrWriteAccountClause
//--------------------------------------------------------------------------
HRESULT _HrWriteAccountClause(IStream * pStream, ULONG cClauses, BOOL fAnd, LPCSTR pszAcctId, ULONG * pcClausesNew)
{
    HRESULT     hr = S_OK;

    Assert(pStream && pszAcctId && pcClausesNew);

    // Write the header 
    hr = _HrWriteClause(pStream, cClauses, fAnd, c_szEmailAcctPrefix);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Write a Quote
    hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Write the account ID
    hr = pStream->Write(pszAcctId, lstrlen(pszAcctId), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Write a Quote
    hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Close the criteria query
    hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the outgoing param
    *pcClausesNew = 1;

    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

//--------------------------------------------------------------------------
// _HrWriteUlongClause
//--------------------------------------------------------------------------
HRESULT _HrWriteUlongClause(IStream * pStream, ULONG cClauses, BOOL fAnd, LPCSTR pszHeader, ULONG ulVal, ULONG * pcClausesNew)
{
    HRESULT     hr = S_OK;
    CHAR        rgchBuff[10];

    Assert(pStream && pszHeader && pcClausesNew);

    // Write the header 
    hr = _HrWriteClause(pStream, cClauses, fAnd, pszHeader);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Convert the number to a string
    rgchBuff[0] = '\0';
    wsprintf(rgchBuff, "%d", ulVal);
    
    // Write the account ID
    hr = pStream->Write(rgchBuff, lstrlen(rgchBuff), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Close the criteria query
    hr = pStream->Write(c_szRightParen, lstrlen(c_szRightParen), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the outgoing param
    *pcClausesNew = 1;
    
    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

//--------------------------------------------------------------------------
// _HrWriteClauseFromCriteria
//--------------------------------------------------------------------------
HRESULT _HrWriteClauseFromCriteria(CRIT_ITEM *pCritItem, ULONG cClauses, BOOL fAnd, BOOL fShow, IStream *pStm, ULONG * pcClausesNew)
{
    // Locals
    HRESULT     hr = S_OK;
    LPCSTR      pszClause = NULL;
    ULONG       cClausesNew = 0;
    
    // Trace
    TraceCall("WriteClauseFromCriteria");

    // Invalid Args
    Assert(pCritItem && pStm && pcClausesNew);

    // Do we have something to do?
    switch(pCritItem->type)
    {            
        case CRIT_TYPE_SUBJECT:      
            Assert(VT_BLOB == pCritItem->propvar.vt);
            hr = _HrWriteTextClause(pStm, cClauses, fAnd, pCritItem->dwFlags,
                            c_szEmailSubjectPrefix, (LPTSTR) (pCritItem->propvar.blob.pBlobData), &cClausesNew);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
            
        case CRIT_TYPE_ACCOUNT:      
            Assert(VT_LPSTR == pCritItem->propvar.vt);
            hr = _HrWriteAccountClause(pStm, cClauses, fAnd, pCritItem->propvar.pszVal, &cClausesNew);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
            
        case CRIT_TYPE_FROM:      
            Assert(VT_BLOB == pCritItem->propvar.vt);
            hr = _HrWriteFromClause(pStm, cClauses, fAnd, pCritItem->dwFlags,
                            (LPTSTR) (pCritItem->propvar.blob.pBlobData), &cClausesNew);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
            
        case CRIT_TYPE_PRIORITY:
            Assert(VT_UI4 == pCritItem->propvar.vt);
            switch (pCritItem->propvar.ulVal)
            {
                case CRIT_DATA_HIPRI:
                    pszClause = c_szFilterPriorityHi;
                    break;

                case CRIT_DATA_LOPRI:
                    pszClause = c_szFilterPriorityLo;
                    break;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_ATTACH:
            Assert(VT_EMPTY == pCritItem->propvar.vt);
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, c_szFilterAttach));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_READ:
            Assert(VT_EMPTY == pCritItem->propvar.vt);
            if (0 != (pCritItem->dwFlags & CRIT_FLAG_INVERT))
            {
                pszClause = c_szFilterNotRead;
            }
            else
            {
                pszClause = c_szFilterRead;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_DOWNLOADED:
            Assert(VT_EMPTY == pCritItem->propvar.vt);
            if (0 != (pCritItem->dwFlags & CRIT_FLAG_INVERT))
            {
                pszClause = c_szFilterNotDownloaded;
            }
            else
            {
                pszClause = c_szFilterDownloaded;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_DELETED:
            Assert(VT_EMPTY == pCritItem->propvar.vt);
            if (0 != (pCritItem->dwFlags & CRIT_FLAG_INVERT))
            {
                pszClause = c_szFilterNotDeleted;
            }
            else
            {
                pszClause = c_szFilterDeleted;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_FLAGGED:
            Assert(VT_EMPTY == pCritItem->propvar.vt);
            if (0 != (pCritItem->dwFlags & CRIT_FLAG_INVERT))
            {
                pszClause = c_szFilterNotFlagged;
            }
            else
            {
                pszClause = c_szFilterFlagged;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_THREADSTATE:
            Assert(VT_UI4 == pCritItem->propvar.vt);
            switch (pCritItem->propvar.ulVal)
            {
                case CRIT_DATA_IGNORETHREAD:
                    pszClause = c_szFilterIgnored;
                    break;

                case CRIT_DATA_WATCHTHREAD:
                    pszClause = c_szFilterWatched;
                    break;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_LINES:
            Assert(VT_UI4 == pCritItem->propvar.vt);
            hr = _HrWriteUlongClause(pStm, cClauses, fAnd, c_szEmailLinesPrefix, pCritItem->propvar.ulVal, &cClausesNew);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
            
        case CRIT_TYPE_AGE:
            Assert(VT_UI4 == pCritItem->propvar.vt);
            hr = _HrWriteUlongClause(pStm, cClauses, fAnd, c_szEmailAgePrefix, pCritItem->propvar.ulVal, &cClausesNew);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
            
        case CRIT_TYPE_SECURE:
            Assert(VT_UI4 == pCritItem->propvar.vt);
            switch (pCritItem->propvar.ulVal)
            {
                case CRIT_DATA_ENCRYPTSECURE:
                    pszClause = c_szFilterEncrypt;
                    break;

                case CRIT_DATA_SIGNEDSECURE:
                    pszClause = c_szFilterSigned;
                    break;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_REPLIES:
            Assert(VT_EMPTY == pCritItem->propvar.vt);
            if (0 != (pCritItem->dwFlags & CRIT_FLAG_INVERT))
            {
                pszClause = c_szFilterNotReplyPost;
            }
            else
            {
                pszClause = c_szFilterReplyPost;
            }
            IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, pszClause));
            cClausesNew = 1;
            break;
            
        case CRIT_TYPE_ALL:
            Assert(VT_EMPTY == pCritItem->propvar.vt);
            if (FALSE == fShow)
            {
                IF_FAILEXIT(hr = _HrWriteClause(pStm, cClauses, fAnd, c_szFilterShowAll));
                cClausesNew = 1;
            }
            break;
    }
    
    // Set the outgoing param
    *pcClausesNew = cClausesNew;
    
exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// _HrBuildQueryFromFilter
//--------------------------------------------------------------------------
HRESULT _HrBuildQueryFromFilter(CRIT_ITEM * pCritList, ULONG cCritList, BOOL fShow,
            LPSTR * ppszQuery, ULONG * pcchQuery,
            ULONG * pcClauses)
{
    HRESULT         hr = S_OK;
    BOOL            fAnd = FALSE;
    CByteStream     stmQuery;
    DWORD           cClauses = 0;
    ULONG           ulIndex = 0;
    LPSTR           pszQuery = NULL;
    ULONG           cchQuery = 0;
    BOOL            fUnread = FALSE;
    ULONG           cClausesNew = 0;

    Assert((NULL != ppszQuery) && (NULL != pcchQuery) && (NULL != pcClauses));
    
    // Initialize all outgoing params
    *ppszQuery = NULL;
    *pcchQuery = 0;
    *pcClauses = 0;
    
    // Figure out the logic op
    if (1 < cCritList)
    {
        fAnd = (CRIT_LOGIC_AND == pCritList->logic);
    }
    
    // Start the query string
    hr = stmQuery.Write(c_szLeftParen, lstrlen(c_szLeftParen), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Write out the proper action
    if (FALSE == fShow)
    {
        // End the query string
        IF_FAILEXIT(hr = stmQuery.Write(c_szFilterHide, lstrlen(c_szFilterHide), NULL));
    }
    else
    {
        // End the query string
        IF_FAILEXIT(hr = stmQuery.Write(c_szFilterShow, lstrlen(c_szFilterShow), NULL));
    }
        
    // Start the criteria string
    hr = stmQuery.Write(c_szLeftParen, lstrlen(c_szLeftParen), NULL);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // For each of the criteria
    for (ulIndex = 0; ulIndex < cCritList; ulIndex++)
    {
        // Write out the clause
        hr = _HrWriteClauseFromCriteria(pCritList + ulIndex, cClauses, fAnd, fShow, &stmQuery, &cClausesNew);
        if (FAILED(hr))
        {
            goto exit;
        }

        // If we did something
        if (S_OK == hr)
        {
            cClauses += cClausesNew;
        }
    }
    
    // Clauses
    if (cClauses > 0)
    {
        // End the criteria string
        hr = stmQuery.Write(c_szRightParen, lstrlen(c_szRightParen), NULL);
        if (FAILED(hr))
        {
            goto exit;
        }
    
        // End the query string
        hr = stmQuery.Write(c_szRightParen, lstrlen(c_szRightParen), NULL);
        if (FAILED(hr))
        {
            goto exit;
        }
    
        // Return the Query
        IF_FAILEXIT(hr = stmQuery.HrAcquireStringA(&cchQuery, &pszQuery, ACQ_DISPLACE));
    }

    // Set the outgoing param
    *ppszQuery = pszQuery;
    *pcchQuery = cchQuery;
    *pcClauses = cClauses;

    // Set the return value
    hr = S_OK;
    
exit:
    // Cleanup

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// RuleUtil_HrBuildQuerysFromFilter
//--------------------------------------------------------------------------
HRESULT RuleUtil_HrBuildQuerysFromFilter(RULEID ridFilter,
        QUERYINFO * pqinfoFilter)
{
    HRESULT         hr = S_OK;
    IOERule *       pIRule = NULL;
    PROPVARIANT     propvar = {0};
    CRIT_ITEM *     pCritList = NULL;
    ULONG           cCritList = 0;
    ACT_ITEM *      pActList = NULL;
    ULONG           cActList = 0;
    DWORD           cClauses = 0;
    LPSTR           pszQuery = NULL;
    ULONG           cchQuery = 0;

    // Initialize
    ZeroMemory(pqinfoFilter, sizeof(pqinfoFilter));

    // Get the rule
    hr = g_pRulesMan->GetRule(ridFilter, RULE_TYPE_FILTER, 0, &pIRule);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(NULL != pIRule);
    
    // Get criteria from filter
    hr = pIRule->GetProp(RULE_PROP_CRITERIA, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(VT_BLOB == propvar.vt);

    // Save off the criteria list
    pCritList = (CRIT_ITEM *) propvar.blob.pBlobData;
    cCritList = propvar.blob.cbSize / sizeof(CRIT_ITEM);
    Assert(cCritList * sizeof(CRIT_ITEM) == propvar.blob.cbSize);
    ZeroMemory(&propvar, sizeof(propvar));

    // Get actions from filter
    hr = pIRule->GetProp(RULE_PROP_ACTIONS, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
    Assert(VT_BLOB == propvar.vt);
    
    // Save off the actions list
    pActList = (ACT_ITEM *) propvar.blob.pBlobData;
    cActList = propvar.blob.cbSize / sizeof(ACT_ITEM);
    Assert(cActList * sizeof(ACT_ITEM) == propvar.blob.cbSize);
    ZeroMemory(&propvar, sizeof(propvar));
    
    // Write out the proper action
    Assert(1 == cActList);
    Assert(ACT_TYPE_SHOW == pActList->type);
    Assert(VT_UI4 == pActList->propvar.vt);

    // Get the query string
    hr = _HrBuildQueryFromFilter(pCritList, cCritList, (ACT_DATA_SHOW == pActList->propvar.ulVal),
            &pszQuery, &cchQuery, &cClauses);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Set the outgoing param
    pqinfoFilter->pszQuery = pszQuery;
    pszQuery = NULL;
    pqinfoFilter->cchQuery = cchQuery;

    // Set the return value
    hr = S_OK;
    
exit:
    // Cleanup
    if (NULL != pActList)
    {
        RuleUtil_HrFreeActionsItem(pActList, cActList);
        MemFree(pActList);
    }
    if (NULL != pCritList)
    {
        RuleUtil_HrFreeCriteriaItem(pCritList, cCritList);
        MemFree(pCritList);
    }
    SafeRelease(pIRule);
    SafeMemFree(pszQuery);
    // Done
    return(hr);
}

typedef struct tagVIEWMENUMAP
{
    RULEID  ridFilter;
    DWORD   dwMenuID;
} VIEWMENUMAP, * PVIEWMENUMAP;

static const VIEWMENUMAP    g_vmmDefault[] =
{
    {RULEID_VIEW_ALL,           ID_VIEW_ALL},
    {RULEID_VIEW_UNREAD,        ID_VIEW_UNREAD},
    {RULEID_VIEW_DOWNLOADED,    ID_VIEW_DOWNLOADED},
    {RULEID_VIEW_IGNORED,       ID_VIEW_IGNORED}
};

static const int g_cvmmDefault = sizeof(g_vmmDefault) / sizeof(g_vmmDefault[0]);
static const int VMM_ALL = 0;
static const int VMM_UNREAD = 1;
static const int VMM_DOWNLOADED = 2;
static const int VMM_IGNORED = 3;

///////////////////////////////////////////////////////////////////////////////
//
//  HrCustomizeCurrentView
//
//  This creates a rules editor of the proper type.
//
//  hwnd        - The owner dialog
//  dwFlags     - What type of editor to bring up
//  ridFilter   - The current filter to customize
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the Rules Manager object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCustomizeCurrentView(HWND hwnd, DWORD dwFlags, RULEID * pridFilter)
{
    HRESULT         hr = S_OK;
    CEditRuleUI *   pEditRuleUI = NULL;
    IOERule *       pIFilter = NULL;
    IOERule *       pIFilterNew = NULL;
    TCHAR           szRes[CCHMAX_STRINGRES + 5];
    ULONG           cchRes = 0;
    LPSTR           pszName = NULL;
    PROPVARIANT     propvar = {0};
    RULEINFO        infoRule = {0};
    DWORD           dwFlagsSet = 0;
    
    // Check incoming params
    if ((NULL == hwnd) || (NULL == pridFilter) || (RULEID_INVALID == *pridFilter))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create a rule editor object
    pEditRuleUI = new CEditRuleUI;
    if (NULL == pEditRuleUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the filter
    hr = g_pRulesMan->GetRule(*pridFilter, RULE_TYPE_FILTER, 0, &pIFilter);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Clone the rule
    hr = pIFilter->Clone(&pIFilterNew);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Is this filter a read only filter?
    if (FALSE != FIsFilterReadOnly(*pridFilter))
    {
        // Get the name from the source rule
        hr = pIFilterNew->GetProp(RULE_PROP_NAME, 0, &propvar);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Get the string template to display
        cchRes = LoadString(g_hLocRes, idsRulesCopyName, szRes, ARRAYSIZE(szRes));
        if (0 == cchRes)
        {
            goto exit;
        }

        // Allocate space to hold the final display string
        hr = HrAlloc((void ** ) &pszName, cchRes + lstrlen(propvar.pszVal) + 1);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Build up the string and set it
        wsprintf(pszName, szRes, propvar.pszVal);

        PropVariantClear(&propvar);
        propvar.vt = VT_LPSTR;
        propvar.pszVal = pszName;
        pszName = NULL;
        
        // Set the name into the new rule
        Assert(VT_LPSTR == propvar.vt);
        Assert(NULL != propvar.pszVal);
        hr = pIFilterNew->SetProp(RULE_PROP_NAME, 0, &propvar);
        if (FAILED(hr))
        {
            goto exit;
        }
        
        // Clear the version of the new rule
        PropVariantClear(&propvar);
        propvar.vt = VT_UI4;
        propvar.ulVal = 0;
        hr = pIFilterNew->SetProp(RULE_PROP_VERSION, 0, &propvar);
        if (FAILED(hr))
        {
            goto exit;
        }
    
        // Set the rule id to invalid
        *pridFilter = RULEID_INVALID;

        // Note that we want to append the rule
        dwFlagsSet = SETF_APPEND;
    }
    else
    {
        dwFlagsSet = SETF_REPLACE;
    }
    
    // Initialize the rule editor object
    hr = pEditRuleUI->HrInit(hwnd, ERF_CUSTOMIZEVIEW, RULE_TYPE_FILTER, pIFilterNew, NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Bring up the rules editor UI
    hr = pEditRuleUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    // Did anything change
    if (S_OK == hr)
    {
        // Initialize the rule info
        infoRule.pIRule = pIFilterNew;
        infoRule.ridRule = *pridFilter;
        
        // Add the rule to the list of rules
        hr = g_pRulesMan->SetRules(dwFlagsSet, RULE_TYPE_FILTER, &infoRule, 1);
        if(FAILED(hr))
        {
            goto exit;
        }

        *pridFilter = infoRule.ridRule;
    }

exit:
    PropVariantClear(&propvar);
    SafeMemFree(pszName);
    SafeRelease(pIFilterNew);
    SafeRelease(pIFilter);
    if (NULL != pEditRuleUI)
    {
        delete pEditRuleUI;
    }
    return hr;
}

CViewMenu::~CViewMenu()
{
    if (NULL != m_pmruList)
    {
        delete m_pmruList;
    }
}

ULONG CViewMenu::AddRef(VOID)
{
    return ++m_cRef;
}

ULONG CViewMenu::Release(VOID)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT CViewMenu::HrInit(DWORD dwFlags)
{
    HRESULT         hr = S_OK;

    m_dwFlags = dwFlags;

    // Create the MRU list
    m_pmruList = new CMRUList;
    if (NULL == m_pmruList)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    m_pmruList->CreateList(5, 0, c_szRulesFilterMRU);
    
    // Make sure the MRU list is up to date
    SideAssert(FALSE != _FValiadateMRUList());
        
    m_dwState |= STATE_INIT;

    hr = S_OK;

exit:
    return hr;
}

HRESULT CViewMenu::HrReplaceMenu(DWORD dwFlags, HMENU hmenu)
{
    HRESULT         hr = S_OK;
    HMENU           hmenuView = NULL;
    MENUITEMINFO    mii = {0};

    // Load in the real view menu
    hmenuView = LoadPopupMenu(IDR_VIEW_POPUP);
    if (NULL == hmenuView)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Add in the default views
    _AddDefaultViews(hmenuView);
    
    // Set the real view menu in
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_SUBMENU;
    
    mii.hSubMenu = hmenuView;
    SetMenuItemInfo(hmenu, ID_POPUP_FILTER, FALSE, &mii);

    // Mark the menu as dirty
    m_dwState |= STATE_DIRTY;

    hr = S_OK;

exit:
    return hr;
}

HRESULT CViewMenu::UpdateViewMenu(DWORD dwFlags, HMENU hmenuView, IMessageList * pMsgList)
{
    HRESULT             hr = S_OK;
    IOEMessageList *    pIMsgList = NULL;
    ULONGLONG           ullFolder = 0;
    FOLDERID            idFolder = FOLDERID_INVALID;
    FOLDERINFO          infoFolder = {0};
    MENUITEMINFO        mii = {0};
    BOOL                fDeletedExists = FALSE;
    BOOL                fDownloadedExists = FALSE;
    BOOL                fRepliesExists = FALSE;
    CHAR                szName[CCHMAX_STRINGRES];

    // Check incoming params
    if (NULL == pMsgList)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Have we been initialized yet?
    if (0 == (m_dwState & STATE_INIT))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // If we don't have a menu, we got problems
    if ((NULL == hmenuView) || (FALSE == IsMenu(hmenuView)))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Get the folder type from the list
    
    // Get the OE message list interface
    if (FAILED(pMsgList->QueryInterface(IID_IOEMessageList, (VOID **) &pIMsgList)))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Get the folder id from the list
    hr = pIMsgList->get_Folder(&ullFolder);
    if (FAILED(hr))
    {
        goto exit;
    }
    idFolder = (FOLDERID) ullFolder;

    // Get the folder info from the folder id
    Assert(NULL != g_pStore);
    hr = g_pStore->GetFolderInfo(idFolder, &infoFolder);
    if (FAILED(hr))
    {
        goto exit;
    }        
    
    // Figure out if we're supposed to remove/add IMAP specific menus
    
    // Initialize the menu info for searching
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_DATA;

    // Does the ID_SHOW_DELETED menu item exist?
    if (FALSE != GetMenuItemInfo(hmenuView, ID_SHOW_DELETED, FALSE, &mii))
    {
        fDeletedExists = TRUE;
    }
    
    // Does the ID_SHOW_REPLIES menu item exist?
    if (FALSE != GetMenuItemInfo(hmenuView, ID_SHOW_REPLIES, FALSE, &mii))
    {
        fRepliesExists = TRUE;
    }
    
    // Does the ID_VIEW_DOWNLOADED menu item exist?
    if (FALSE != GetMenuItemInfo(hmenuView, ID_VIEW_DOWNLOADED, FALSE, &mii))
    {
        fDownloadedExists = TRUE;
    }
    
    // If the folder is not a LOCAL folder or it is a find folder and
    // the menu item item does not exist
    if (((FOLDER_LOCAL != infoFolder.tyFolder) || (0 != (m_dwFlags & VMF_FINDER)))&& (FALSE == fDownloadedExists))
    {
        // Insert the downloaded menu after the replies menu
        hr = _HrInsertViewMenu(hmenuView, g_vmmDefault[VMM_DOWNLOADED].ridFilter,
                            g_vmmDefault[VMM_DOWNLOADED].dwMenuID, ID_VIEW_IGNORED);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    // else if the folder is a LOCAL folder and not a find folder and
    // the menu item does exist
    else if ((FOLDER_LOCAL == infoFolder.tyFolder) && (0 == (m_dwFlags & VMF_FINDER)) && (FALSE != fDownloadedExists))
    {
        // Remove the Deleted Items menu
        RemoveMenu(hmenuView, ID_VIEW_DOWNLOADED, MF_BYCOMMAND);
    }

    // If the folder is an NNTP folder and
    // the menu item item does not exist
    if ((FOLDER_NEWS == infoFolder.tyFolder) && (FALSE == fRepliesExists))
    {
        // Get the name of the deleted item string
        AthLoadString(idsViewReplies, szName, sizeof(szName));
        
        // Initialize the menu info
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_STRING;
        mii.fState = MFS_ENABLED;
        mii.wID = ID_SHOW_REPLIES;
        mii.dwTypeData = szName;
        mii.cch = lstrlen(szName);

        // Insert the menu item
        if (FALSE == InsertMenuItem(hmenuView, ID_THREAD_MESSAGES, FALSE, &mii))
        {
            hr = E_FAIL;
            goto exit;
        }
    }
    // else if the folder is not an NNTP folder and
    // the menu item does exist
    else if ((FOLDER_NEWS != infoFolder.tyFolder) && (FALSE != fRepliesExists))
    {
        // Remove the Deleted Items menu
        RemoveMenu(hmenuView, ID_SHOW_REPLIES, MF_BYCOMMAND);
    }

    // If the folder is an IMAP folder or a find folder and
    // the menu item item does not exist
    if (((FOLDER_IMAP == infoFolder.tyFolder) || (0 != (m_dwFlags & VMF_FINDER))) && (FALSE == fDeletedExists))
    {
        // Get the name of the deleted item string
        AthLoadString(idsShowDeleted, szName, sizeof(szName));
        
        // Initialize the menu info
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_STRING;
        mii.fState = MFS_ENABLED;
        mii.wID = ID_SHOW_DELETED;
        mii.dwTypeData = szName;
        mii.cch = lstrlen(szName);

        // Insert the menu item
        if (FALSE == InsertMenuItem(hmenuView, ID_THREAD_MESSAGES, FALSE, &mii))
        {
            hr = E_FAIL;
            goto exit;
        }
    }
    // else if the folder is not an IMAP folder and not a Find folder and
    // the menu item does exist
    else if ((FOLDER_IMAP != infoFolder.tyFolder) && (0 == (m_dwFlags & VMF_FINDER)) && (FALSE != fDeletedExists))
    {
        // Remove the Deleted Items menu
        RemoveMenu(hmenuView, ID_SHOW_DELETED, MF_BYCOMMAND);
    }

    // if we're dirty
    if (0 != (m_dwState & STATE_DIRTY))
    {
        // Load in the MRU filter list
        hr = _HrReloadMRUViewMenu(hmenuView);
        if (FAILED(hr))
        {
            goto exit;
        }
        
        // Note that we've reloaded ourselves
        m_dwState &= ~STATE_DIRTY;
    }

    // See if we need to add the extra view menu
    hr = _HrAddExtraViewMenu(hmenuView, pIMsgList);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the return value
    hr = S_OK;
    
exit:
    g_pStore->FreeRecord(&infoFolder);
    SafeRelease(pIMsgList);
    return hr;
}

HRESULT CViewMenu::QueryStatus(IMessageList * pMsgList, OLECMD  * prgCmds)
{
    HRESULT             hr = S_OK;
    IOEMessageList *    pIMsgList = NULL;
    BOOL                fThreading = FALSE;
    BOOL                fShowDeleted = FALSE;
    BOOL                fShowReplies = FALSE;
    MENUITEMINFO        mii = {0};
    CHAR                rgchFilterTag[CCH_FILTERTAG_MAX];
    ULONGLONG           ullFilter = 0;
    RULEID              ridFilter = RULEID_INVALID;
    RULEID              ridFilterTag = RULEID_INVALID;
    
    // Check incoming params
    if ((NULL == pMsgList) || (NULL == prgCmds))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Get the OE message list interface
    if (FAILED(pMsgList->QueryInterface(IID_IOEMessageList, (VOID **) &pIMsgList)))
    {
        hr = E_FAIL;
        goto exit;
    }
            
    // Get the current filter on the message list
    pIMsgList->get_FilterMessages(&ullFilter);
    ridFilter = (RULEID) ullFilter;
    
    // Set the flags on the correct menu item
    switch(prgCmds->cmdID)
    {
        case ID_VIEW_ALL:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_ALL].ridFilter == ridFilter)
            {
                prgCmds->cmdf |= OLECMDF_NINCHED;
            }
            break;
            
        case ID_VIEW_UNREAD:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_UNREAD].ridFilter == ridFilter)
            {
                prgCmds->cmdf |= OLECMDF_NINCHED;
            }
            break;
            
        case ID_VIEW_DOWNLOADED:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_DOWNLOADED].ridFilter == ridFilter)
            {
                prgCmds->cmdf |= OLECMDF_NINCHED;
            }
            break;
            
        case ID_VIEW_IGNORED:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_IGNORED].ridFilter == ridFilter)
            {
                prgCmds->cmdf |= OLECMDF_NINCHED;
            }
            break;
            
        case ID_VIEW_CURRENT:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // If this filter is turned on, make sure the item is checked
            if (m_ridCurrent == ridFilter)
            {
                prgCmds->cmdf |= OLECMDF_NINCHED;
            }
            break;
            
        case ID_VIEW_RECENT_0:
        case ID_VIEW_RECENT_1:
        case ID_VIEW_RECENT_2:
        case ID_VIEW_RECENT_3:
        case ID_VIEW_RECENT_4:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            if (NULL != m_pmruList)
            {
                if (-1 == m_pmruList->EnumList(prgCmds->cmdID - ID_VIEW_RECENT_0, rgchFilterTag, ARRAYSIZE(rgchFilterTag)))
                {
                    break;
                }

                if (FALSE == StrToIntEx(rgchFilterTag, STIF_SUPPORT_HEX, (int *) &ridFilterTag))
                {
                    break;
                }
        
                // If this filter is turned on, make sure the item is checked
                if (ridFilterTag == ridFilter)
                {
                    prgCmds->cmdf |= OLECMDF_NINCHED;
                }
            }
            break;
            
        case ID_VIEW_APPLY:
        case ID_VIEW_CUSTOMIZE:
        case ID_VIEW_MANAGER:
            // If we have a Rules Manager, 
            // then we are enabled
            if (NULL != g_pRulesMan)
            {
                prgCmds->cmdf |= OLECMDF_ENABLED;
            }
            break;
            
        case ID_SHOW_REPLIES:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // Check to see if show replies is turned on
            if (SUCCEEDED(pIMsgList->get_ShowReplies(&fShowReplies)))
            {
                // If replies is turned on, make sure the item is checked
                if (FALSE != fShowReplies)
                {
                    prgCmds->cmdf |= OLECMDF_LATCHED;
                }
            }
            break;

        case ID_SHOW_DELETED:
            // These menu item are always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // Check to see if show deleted is turned on
            if (SUCCEEDED(pIMsgList->get_ShowDeleted(&fShowDeleted)))
            {
                // If threading is turned on, make sure the item is checked
                if (FALSE != fShowDeleted)
                {
                    prgCmds->cmdf |= OLECMDF_LATCHED;
                }
            }
            break;

        case ID_THREAD_MESSAGES:
            // This menu item is always enabled
            prgCmds->cmdf |= OLECMDF_ENABLED;

            // Check to see if threading is turned on
            if (SUCCEEDED(pIMsgList->get_GroupMessages(&fThreading)))
            {
                // If threading is turned on, make sure the item is checked
                if (FALSE != fThreading)
                {
                    prgCmds->cmdf |= OLECMDF_LATCHED;
                }
            }
            break;
    }
    
    // Set the proper return value
    hr = S_OK;

exit:
    SafeRelease(pIMsgList);
    return hr;
}

HRESULT CViewMenu::Exec(HWND hwndUI, DWORD nCmdID, IMessageList * pMsgList, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT             hr = S_OK;
    IOEMessageList *    pIMsgList = NULL;
    BOOL                fThreading = FALSE;
    BOOL                fShowDeleted = FALSE;
    BOOL                fShowReplies = FALSE;
    MENUITEMINFO        mii = {0};
    ULONGLONG           ullFilter = 0;
    RULEID              ridFilter = RULEID_INVALID;
    TCHAR               rgchFilterTag[CCH_FILTERTAG_MAX];
    RULEID              ridFilterTag = RULEID_INVALID;
    FOLDERID            idFolder = FOLDERID_INVALID;
    ULONGLONG           ullFolder = 0;
    FOLDERTYPE          typeFolder = FOLDER_INVALID;
    DWORD               dwFlags = 0;
    BOOL                fApplyAll = FALSE;
        
    // Check incoming params
    if (NULL == pMsgList)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Get the OE message list interface
    hr = pMsgList->QueryInterface(IID_IOEMessageList, (VOID **) &pIMsgList);
    if (FAILED(hr))
    {
        goto exit;
    }
            
    // Get the current filter on the message list
    hr = pIMsgList->get_FilterMessages(&ullFilter);
    if (FAILED(hr))
    {
        goto exit;
    }
    ridFilter = (RULEID) ullFilter;

    // Execute the actions for the correct menu item
    switch(nCmdID)
    {
        case ID_VIEW_ALL:
            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_ALL].ridFilter != ridFilter)
            {
                // Set the new filter on the item
                hr = pIMsgList->put_FilterMessages((ULONGLONG) g_vmmDefault[VMM_ALL].ridFilter);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Mark the menu as dirty
                m_dwState |= STATE_DIRTY;                
            }
            break;
            
        case ID_VIEW_UNREAD:
            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_UNREAD].ridFilter != ridFilter)
            {
                // Set the new filter on the item
                hr = pIMsgList->put_FilterMessages((ULONGLONG) g_vmmDefault[VMM_UNREAD].ridFilter);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Mark the menu as dirty
                m_dwState |= STATE_DIRTY;                
            }
            break;
            
        case ID_VIEW_DOWNLOADED:
            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_DOWNLOADED].ridFilter != ridFilter)
            {
                // Set the new filter on the item
                hr = pIMsgList->put_FilterMessages((ULONGLONG) g_vmmDefault[VMM_DOWNLOADED].ridFilter);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Mark the menu as dirty
                m_dwState |= STATE_DIRTY;                
            }
            break;
            
        case ID_VIEW_IGNORED:
            // If this filter is turned on, make sure the item is checked
            if (g_vmmDefault[VMM_IGNORED].ridFilter != ridFilter)
            {
                // Set the new filter on the item
                hr = pIMsgList->put_FilterMessages((ULONGLONG) g_vmmDefault[VMM_IGNORED].ridFilter);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Mark the menu as dirty
                m_dwState |= STATE_DIRTY;                
            }
            break;
            
        case ID_VIEW_CURRENT:
            // Make sure we add the filter to the MRU list
            _AddViewToMRU(m_ridCurrent);
            
            // If this filter is turned on, make sure the item is checked
            if (m_ridCurrent != ridFilter)
            {
                // Set the new filter on the item
                hr = pIMsgList->put_FilterMessages((ULONGLONG) m_ridCurrent);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Mark the menu as dirty
                m_dwState |= STATE_DIRTY;                
            }
            break;
            
        case ID_VIEW_RECENT_0:
        case ID_VIEW_RECENT_1:
        case ID_VIEW_RECENT_2:
        case ID_VIEW_RECENT_3:
        case ID_VIEW_RECENT_4:
            if (NULL != m_pmruList)
            {
                if (-1 == m_pmruList->EnumList(nCmdID - ID_VIEW_RECENT_0, rgchFilterTag, ARRAYSIZE(rgchFilterTag)))
                {
                    break;
                }

                if (FALSE == StrToIntEx(rgchFilterTag, STIF_SUPPORT_HEX, (int *) &ridFilterTag))
                {
                    break;
                }
        
                // Make sure we add the filter to the MRU list
                _AddViewToMRU(ridFilterTag);
                
                // If this filter is turned on, make sure the item is checked
                if (ridFilterTag != ridFilter)
                {
                    // Set the new filter on the item
                    hr = pIMsgList->put_FilterMessages((ULONGLONG) ridFilterTag);
                    if (FAILED(hr))
                    {
                        goto exit;
                    }
                    
                    // Mark the menu as dirty
                    m_dwState |= STATE_DIRTY;                
                }
            }
            break;
            
        case ID_VIEW_APPLY:
            if ((NULL != pvaIn) && (VT_I4 == pvaIn->vt))
            {
                // Make sure we add the filter to the MRU list
                _AddViewToMRU((RULEID) IntToPtr(pvaIn->lVal));
                
                // If threading is turned on, make sure the item is checked
                if (ridFilter != (RULEID) IntToPtr(pvaIn->lVal))
                {                
                    // Set the new filter on the item
                    hr = pIMsgList->put_FilterMessages((long) pvaIn->lVal);
                    if (FAILED(hr))
                    {
                        goto exit;
                    }
                    
                    // Mark the menu as dirty
                    m_dwState |= STATE_DIRTY;                
                }

            }
            break;
            
        case ID_VIEW_CUSTOMIZE:
            hr = HrCustomizeCurrentView(hwndUI, 0, &ridFilter);
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // If the views list changed, then apply the filter to the list
            if (S_OK == hr)
            {
                // Make sure we add the filter to the MRU list
                _AddViewToMRU(ridFilter);
                
                // Get the current threading state
                hr = pIMsgList->put_FilterMessages((ULONGLONG) ridFilter);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Mark the menu as dirty
                m_dwState |= STATE_DIRTY;                
            }
            break;

        case ID_VIEW_MANAGER:
            if (0 == (m_dwFlags & VMF_FINDER))
            {
                // Get the current folder id
                hr = pIMsgList->get_Folder(&ullFolder);
                if (FAILED(hr))
                {
                    goto exit;
                }
                idFolder = (FOLDERID) ullFolder;
                
                // Get the folder info for this folder
                typeFolder = GetFolderType(idFolder);
                if (FOLDER_LOCAL == typeFolder)
                {
                    dwFlags = VRDF_POP3;
                }
                else if (FOLDER_NEWS == typeFolder)
                {
                    dwFlags = VRDF_NNTP;
                }
                else if (FOLDER_IMAP == typeFolder)
                {
                    dwFlags = VRDF_IMAP;
                }
                else if (FOLDER_HTTPMAIL == typeFolder)
                {
                    dwFlags = VRDF_HTTPMAIL;
                }
            }
            
            hr = HrDoViewsManagerDialog(hwndUI, dwFlags, &ridFilter, &fApplyAll);
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // If the views list changed, then apply the filter to the list
            if (S_OK == hr)
            {
                // Make sure the MRU list is up to date
                SideAssert(FALSE != _FValiadateMRUList());
                
                // Make sure we add the filter to the MRU list
                _AddViewToMRU(ridFilter);
                
                // Get the current threading state
                hr = pIMsgList->put_FilterMessages((ULONGLONG) ridFilter);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                if (FALSE != fApplyAll)
                {
                    // Set the global view
                    SetDwOption(OPT_VIEW_GLOBAL, PtrToUlong(ridFilter), NULL, 0);

                    // Set the new view on all the subscribed folders
                    hr = RecurseFolderHierarchy(FOLDERID_ROOT, RECURSE_SUBFOLDERS | RECURSE_INCLUDECURRENT,
                                        0, (DWORD_PTR) ridFilter, _HrRecurseSetFilter);
                    if (FAILED(hr))
                    {
                        goto exit;
                    }
                }
                
                // Mark the menu as dirty
                m_dwState |= STATE_DIRTY;                
            }
            break;
            
        case ID_SHOW_REPLIES:
            // Get the current deleted state
            hr = pIMsgList->get_ShowReplies(&fShowReplies);
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Switch it to the opposite state
            fShowReplies = !fShowReplies;

            // Set the current deleted state
            hr = pIMsgList->put_ShowReplies(fShowReplies);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
                        
        case ID_SHOW_DELETED:
            // Get the current deleted state
            hr = pIMsgList->get_ShowDeleted(&fShowDeleted);
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Switch it to the opposite state
            fShowDeleted = !fShowDeleted;

            // Set the current deleted state
            hr = pIMsgList->put_ShowDeleted(fShowDeleted);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
            
        case ID_THREAD_MESSAGES:
            // Get the current threading state
            hr = pIMsgList->get_GroupMessages(&fThreading);
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Switch it to the opposite state
            fThreading = !fThreading;

            // Set the current threading state
            hr = pIMsgList->put_GroupMessages(fThreading);
            if (FAILED(hr))
            {
                goto exit;
            }
            break;
    }
    
    // Set the proper return value
    hr = S_OK;

exit:
    SafeRelease(pIMsgList);
    return hr;
}

VOID CViewMenu::_AddDefaultViews(HMENU hmenu)
{
    HRESULT         hr = S_OK;
    ULONG           ulIndex = 0;
    PROPVARIANT     propvar = {0};
    IOERule *       pIFilter = NULL;
    MENUITEMINFO    mii = {0};
    ULONG           ulMenu = 0;

    Assert(NULL != hmenu);
    
    // If we don't have a rules manager then fail
    if (NULL == g_pRulesMan)
    {
        goto exit;
    }

    // Initialize the menu info
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_ID | MIIM_DATA | MIIM_TYPE;
    mii.fType = MFT_STRING;
    mii.fState = MFS_ENABLED;
    
    // Add each one of the default views
    for (ulIndex = 0; ulIndex < g_cvmmDefault; ulIndex++)
    {
        // Get the view from the rules manager
        if (FAILED(g_pRulesMan->GetRule(g_vmmDefault[ulIndex].ridFilter, RULE_TYPE_FILTER, 0, &pIFilter)))
        {
            continue;
        }
        
        // Get the name from the rule
        ZeroMemory(&propvar, sizeof(propvar));
        if ((SUCCEEDED(pIFilter->GetProp(RULE_PROP_NAME, 0, &propvar))) &&
                    (NULL != propvar.pszVal))
        {
            // Add the name to the rule
            Assert(VT_LPSTR == propvar.vt);
            mii.wID = g_vmmDefault[ulIndex].dwMenuID;
            mii.dwItemData = (DWORD_PTR) g_vmmDefault[ulIndex].ridFilter;
            mii.dwTypeData = propvar.pszVal;
            mii.cch = lstrlen(propvar.pszVal);
            if (FALSE != InsertMenuItem(hmenu, ulMenu, TRUE, &mii))
            {
                ulMenu++;
            }
        }

        PropVariantClear(&propvar);
        SafeRelease(pIFilter);
    }

    // Add in the default separator if we added at least one item
    if (0 != ulMenu)
    {
        // Set up the menu items
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_SEPARATOR;
        mii.fState = MFS_ENABLED;
        mii.wID = ID_VIEW_DEFAULT_SEPERATOR;
        mii.dwItemData = 0;
        mii.dwTypeData = 0;
        mii.cch = 0;

        // Insert the separator
        InsertMenuItem(hmenu, ulMenu, TRUE, &mii);
    }
    
exit:
    PropVariantClear(&propvar);
    SafeRelease(pIFilter);
    return;
}

HRESULT CViewMenu::_HrInsertViewMenu(HMENU hmenuView, RULEID ridFilter, DWORD dwMenuID, DWORD dwMenuIDInsert)
{
    HRESULT         hr = S_OK;
    IOERule *       pIFilter = NULL;
    PROPVARIANT     propvar = {0};
    MENUITEMINFO    mii = {0};
    
    // Get the view from the rules manager
    hr = g_pRulesMan->GetRule(ridFilter, RULE_TYPE_FILTER, 0, &pIFilter);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Get the name from the view
    hr = pIFilter->GetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Nothing to do if we don't have a name
    if (NULL == propvar.pszVal)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Initialize the menu info
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_ID | MIIM_DATA | MIIM_TYPE;
    mii.fType = MFT_STRING;
    mii.fState = MFS_ENABLED;
    mii.wID = dwMenuID;
    mii.dwItemData = (DWORD_PTR) ridFilter;
    mii.dwTypeData = propvar.pszVal;
    mii.cch = lstrlen(propvar.pszVal);

    // Insert the menu item
    if (FALSE == InsertMenuItem(hmenuView, dwMenuIDInsert, FALSE, &mii))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the return value
    hr = S_OK;

exit:
    PropVariantClear(&propvar);
    SafeRelease(pIFilter);
    return hr;
}

HRESULT CViewMenu::_HrReloadMRUViewMenu(HMENU hmenuView)
{
    HRESULT         hr = S_OK;
    ULONG           ulMenu = 0;
    INT             nItem = 0;
    CHAR            rgchFilterTag[CCH_FILTERTAG_MAX];
    RULEID          ridFilter = RULEID_INVALID;
    MENUITEMINFO    mii = {0};

    // Set up the menu items
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_ID;
    
    // Delete the old items
    for (ulMenu = ID_VIEW_RECENT_0; ulMenu < ID_VIEW_CUSTOMIZE; ulMenu++)
    {
        if (FALSE != GetMenuItemInfo(hmenuView, ulMenu, FALSE, &mii))
        {
            RemoveMenu(hmenuView, ulMenu, MF_BYCOMMAND);
        }
    }
    
    // Add in each of the filters from the mru list
    for (nItem = 0, ulMenu = ID_VIEW_RECENT_0;
                ((-1 != m_pmruList->EnumList(nItem, rgchFilterTag, ARRAYSIZE(rgchFilterTag))) &&
                            (ulMenu < ID_VIEW_RECENT_SEPERATOR)); nItem++)
    {
        // Convert the tag string to a rule id
        if (FALSE == StrToIntEx(rgchFilterTag, STIF_SUPPORT_HEX, (int *) &ridFilter))
        {
            continue;
        }
        
        // Insert the menu item
        if (SUCCEEDED(_HrInsertViewMenu(hmenuView, ridFilter, ulMenu, ID_VIEW_CUSTOMIZE)))
        {
            ulMenu++;
        }
    }

    // Add in the MRU separator if we added at least one item
    if (ID_VIEW_RECENT_0 != ulMenu)
    {
        // Set up the menu items
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_SEPARATOR;
        mii.fState = MFS_ENABLED;
        mii.wID = ID_VIEW_RECENT_SEPERATOR;
        mii.dwItemData = 0;
        mii.dwTypeData = 0;
        mii.cch = 0;

        // Insert the separator
        InsertMenuItem(hmenuView, ID_VIEW_CUSTOMIZE, FALSE, &mii);
    }
    
    // Set the proper return value
    hr = S_OK;
     
    return hr;
}

HRESULT CViewMenu::_HrAddExtraViewMenu(HMENU hmenuView, IOEMessageList * pIMsgList)
{
    HRESULT         hr = S_OK;
    ULONGLONG       ullFilter = 0;
    RULEID          ridFilter = RULEID_INVALID;
    MENUITEMINFO    mii = {0};
    BOOL            fExtraMenu = FALSE;
    IOERule *       pIFilter = NULL;
    PROPVARIANT     propvar = {0};
    DWORD           dwMenuID = 0;

    Assert(NULL != pIMsgList);

    // Get the current filter on the message list
    hr = pIMsgList->get_FilterMessages(&ullFilter);
    if (FAILED(hr))
    {
        goto exit;
    }
    ridFilter = (RULEID) ullFilter;

    // Initialize the menu info
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_DATA;

    // Does the ID_VIEW_CURRENT menu item exist?
    fExtraMenu = !!GetMenuItemInfo(hmenuView, ID_VIEW_CURRENT, FALSE, &mii);
    
    // Is the view filter one of the defaults or in the MRU list?
    if ((FALSE != FIsFilterReadOnly(ridFilter)) || (FALSE != _FViewInMRUList(ridFilter, NULL)))
    {
        // Does the ID_VIEW_CURRENT menu item exist?
        if (FALSE != fExtraMenu)
        {
            // Remove the ID_VIEW_CURRENT menu item
            RemoveMenu(hmenuView, ID_VIEW_CURRENT, MF_BYCOMMAND);

            // Remove the ID_VIEW_CURRENT_SEPERATOR menu item separator
            RemoveMenu(hmenuView, ID_VIEW_CURRENT_SEPERATOR, MF_BYCOMMAND);

            // Clear out the saved current id
            m_ridCurrent = RULEID_INVALID;
        }
    }
    else
    {
        // Does the ID_VIEW_CURRENT menu item exist?
        if (FALSE != fExtraMenu)
        {
            // Is it different than the current view filter
            if (ridFilter != (RULEID) mii.dwItemData)
            {
                // Get the view from the rules manager
                hr = g_pRulesMan->GetRule(ridFilter, RULE_TYPE_FILTER, 0, &pIFilter);
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                // Get the name from the view
                hr = pIFilter->GetProp(RULE_PROP_NAME, 0, &propvar);
                if (FAILED(hr))
                {
                    goto exit;
                }

                // Nothing to do if we don't have a name
                if (NULL == propvar.pszVal)
                {
                    hr = E_FAIL;
                    goto exit;
                }
                
                // Initialize the menu info
                mii.cbSize = sizeof(mii);
                mii.fMask = MIIM_DATA | MIIM_TYPE;
                mii.fType = MFT_STRING;
                mii.dwItemData = (DWORD_PTR) ridFilter;
                mii.dwTypeData = propvar.pszVal;
                mii.cch = lstrlen(propvar.pszVal);

                // Reset the menu name and data
                SetMenuItemInfo(hmenuView, ID_VIEW_CURRENT, FALSE, &mii);
            }
        }
        else
        {
            // Initialize the menu item info
            mii.fMask = MIIM_DATA;
            
            // Figure out which menu to add it before
            dwMenuID = (FALSE != GetMenuItemInfo(hmenuView, ID_VIEW_RECENT_0, FALSE, &mii)) ? ID_VIEW_RECENT_0: ID_VIEW_CUSTOMIZE;
            
            // Add the extra menu item
            hr = _HrInsertViewMenu(hmenuView, ridFilter, ID_VIEW_CURRENT, dwMenuID);
            if (FAILED(hr))
            {
                goto exit;
            }
            
            // Set up the menu item info
            mii.fMask = MIIM_ID | MIIM_TYPE;
            mii.fType = MFT_SEPARATOR;
            mii.fState = MFS_ENABLED;
            mii.wID = ID_VIEW_CURRENT_SEPERATOR;
            mii.dwItemData = 0;
            mii.dwTypeData = 0;
            mii.cch = 0;
            
            // Add the extra menu item separator
            InsertMenuItem(hmenuView, dwMenuID, FALSE, &mii);
        }

        // Save the current rule id
        m_ridCurrent = ridFilter;
     }

     // Set the proper return value
     hr = S_OK;
     
exit:
    PropVariantClear(&propvar);
    SafeRelease(pIFilter);
    return hr;
}

VOID CViewMenu::_AddViewToMRU(RULEID ridFilter)
{
    CHAR    rgchFilterTag[CCH_FILTERTAG_MAX];
    
    // Is there anything to do?
    if (RULEID_INVALID == ridFilter)
    {
        goto exit;
    }

    // If this isn't a default view
    if (FALSE == FIsFilterReadOnly(ridFilter))
    {
        // Format the rule id as a hex string
        wsprintf(rgchFilterTag, "0X%08X", PtrToUlong(ridFilter));

        // Add the string into the MRU list
        m_pmruList->AddString(rgchFilterTag);
    }
        
exit:
    return;
}

BOOL CViewMenu::_FViewInMRUList(RULEID ridFilter, DWORD * pdwID)
{
    BOOL    fRet = FALSE;
    INT     nItem = 0;
    CHAR    rgchFilterTag[CCH_FILTERTAG_MAX];
    RULEID  ridFilterMRU = RULEID_INVALID;

    // Initialize the return value
    if (NULL != pdwID)
    {
        *pdwID = -1;
    }

    // Add in each of the filters from the mru list
    for (nItem = 0; -1 != m_pmruList->EnumList(nItem, rgchFilterTag, ARRAYSIZE(rgchFilterTag)); nItem++)
    {
        // Convert the tag string to a rule id
        if (FALSE == StrToIntEx(rgchFilterTag, STIF_SUPPORT_HEX, (int *) &ridFilterMRU))
        {
            continue;
        }

        if (ridFilterMRU == ridFilter)
        {
            fRet = TRUE;
            break;
        }
    }

    return fRet;
}

BOOL CViewMenu::_FValiadateMRUList(VOID)
{
    BOOL        fRet = FALSE;
    INT         nItem = 0;
    CHAR        rgchFilterTag[CCH_FILTERTAG_MAX];
    RULEID      ridFilterMRU = RULEID_INVALID;
    IOERule *   pIFilter = NULL;

    Assert(NULL != m_pmruList);
    Assert(NULL != g_pRulesMan);

    // Add in each of the filters from the mru list
    for (nItem = 0; -1 != m_pmruList->EnumList(nItem, rgchFilterTag, ARRAYSIZE(rgchFilterTag)); nItem++)
    {
        // Convert the tag string to a rule id
        if (FALSE == StrToIntEx(rgchFilterTag, STIF_SUPPORT_HEX, (int *) &ridFilterMRU))
        {
            continue;
        }

        // Get the view from the rules manager
        if (FAILED(g_pRulesMan->GetRule(ridFilterMRU, RULE_TYPE_FILTER, 0, &pIFilter)))
        {
            if (-1 == m_pmruList->RemoveString(rgchFilterTag))
            {
                fRet = FALSE;
                goto exit;
            }
        }
        SafeRelease(pIFilter);
    }

    // Set the return value
    fRet = TRUE;

exit:
    SafeRelease(pIFilter);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateViewMenu
//
//  This creates a view menu.
//
//  ppViewMenu - pointer to return the view menu
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the View Menu object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateViewMenu(DWORD dwFlags, CViewMenu ** ppViewMenu)
{
    CViewMenu * pViewMenu = NULL;
    HRESULT     hr = S_OK;

    // Check the incoming params
    if (NULL == ppViewMenu)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppViewMenu = NULL;

    // Create the view menu object
    pViewMenu = new CViewMenu;
    if (NULL == pViewMenu)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize the view menu
    hr = pViewMenu->HrInit(dwFlags);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the outgoing param
    *ppViewMenu = pViewMenu;
    pViewMenu = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pViewMenu)
    {
        delete pViewMenu;
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\ruleutil.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  RuleUtil.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#if _MSC_VER > 1000
#pragma once
#endif

#include "oerules.h"

// Forward definitions
interface IOEMessageList;
interface IMessageList;
class CProgress;
class CMRUList;

const DWORD RULE_DEFAULT_MAIL   = 0x00000000;
const DWORD RULE_DEFAULT_NEWS   = 0x00000001;

const DWORD CCH_INDEX_MAX   = 4;
const DWORD DWORD_INDEX_MIN = 0;
const DWORD DWORD_INDEX_MAX = 0x1000;

const DWORD MRDF_MAIL       = 0x00000000;
const DWORD MRDF_NEWS       = 0x00000001;
const DWORD MRDF_JUNK       = 0x00000002;
const DWORD MRDF_SENDERS    = 0x00000003;

void DoMessageRulesDialog(HWND hwnd, DWORD dwFlags);

// For creating a rule from a message
const DWORD CRFMF_MAIL = 0x00000000;
const DWORD CRFMF_NEWS = 0x00000001;

HRESULT HrCreateRuleFromMessage(HWND hwnd, DWORD dwFlags, MESSAGEINFO * pmsginfo, IMimeMessage * pMessage);

// Utility functions for the Block Sender object
const DWORD ABSF_MAIL = 0x00000001;
const DWORD ABSF_NEWS = 0x00000002;

HRESULT HrBlockSendersFromFolder(HWND hwnd, DWORD dwFlags, FOLDERID idFolder, LPSTR * ppszSender, ULONG cpszSender);

const DWORD VRDF_POP3       = 0x00000001;
const DWORD VRDF_NNTP       = 0x00000002;
const DWORD VRDF_IMAP       = 0x00000004;
const DWORD VRDF_HTTPMAIL   = 0x00000008;

HRESULT HrDoViewsManagerDialog(HWND hwnd, DWORD dwFlags, RULEID * pridRule, BOOL * pfApplyAll);

HRESULT HrCreateRulesManager(IUnknown * pIUnkOuter, IUnknown ** ppIUnknown);

// Functions to deal with the address criteria/actions
HRESULT RuleUtil_HrBuildEmailString(LPWSTR pwszText, ULONG cchText, LPWSTR * ppwszEmail, ULONG * pcchEmail);
HRESULT RuleUtil_HrParseEmailString(LPWSTR pwszEmail, ULONG cchEmail, LPWSTR * ppwszOut, ULONG * pcchOut);

// Functions to deal with the text criteria/actions
HRESULT RuleUtil_HrBuildTextString(LPTSTR pszIn, ULONG cchIn, LPTSTR * ppszText, ULONG * pcchText);
HRESULT RuleUtil_HrParseTextString(LPTSTR pszText, ULONG cchText, LPTSTR * ppszOut, ULONG * pcchOut);

// Utility functions to get values with allocations
HRESULT RuleUtil_HrGetDlgString(HWND hwndDlg, UINT uiCtlId, LPTSTR *ppszText, ULONG * pcchText);
HRESULT RuleUtil_HrGetRegValue(HKEY hkey, LPCSTR pszValueName, DWORD * pdwType, BYTE ** ppbData, ULONG * pcbData);

HRESULT RuleUtil_HrPickEMailNames(HWND hwndDlg, LONG lRecipType, UINT uidsWellButton, LPWSTR *ppwszAddrs);
HRESULT RuleUtil_HrGetAddressesFromWAB(HWND hwndDlg, LONG lRecipType, UINT uidsWellButton, LPWSTR *ppwszAddrs);

BOOL RuleUtil_FEnDisDialogItem(HWND hwndDlg, UINT idcItem, BOOL fEnable);
HRESULT RuleUtil_AppendRichEditText(HWND hwndRedit, ULONG ulStart, LPCWSTR pszText, CHARFORMAT *pchfmt);
HRESULT RuleUtil_HrShowLinkedString(HWND hwndEdit, BOOL fError, BOOL fReadOnly, 
                                    LPWSTR pszFmt, LPCWSTR pszData, ULONG ulStart, 
                                    ULONG * pulStartLink, ULONG * pulEndLink, ULONG * pulEnd);

// Utility functions for the COECriteria object
HRESULT RuleUtil_HrDupCriteriaItem(CRIT_ITEM * pItemIn, ULONG cItemIn, CRIT_ITEM ** ppItemOut);
HRESULT RuleUtil_HrFreeCriteriaItem(CRIT_ITEM * pItem, ULONG cItem);

// Utility functions for the COEActions object
HRESULT RuleUtil_HrDupActionsItem(ACT_ITEM * pItemIn, ULONG cItemIn, ACT_ITEM ** ppItemOut);
HRESULT RuleUtil_HrFreeActionsItem(ACT_ITEM * pItem, ULONG cItem);

HRESULT RuleUtil_HrAddBlockSender(RULE_TYPE type, LPCSTR pszAddr);
HRESULT RuleUtil_SetName(IOERule    *pIRule, int idRes);

// Utility functions for merge between old and new rules design

// Migration IBA_MOVE=1000 to ACT_MOVE
#define ACT_MOVETO              FLAG01
#define ACT_COPYTO              FLAG02
#define ACT_FORWARDTO           FLAG03
#define ACT_REPLYWITH           FLAG04
#define ACT_DONTDOWNLOAD        FLAG05
#define ACT_DELETEOFFSERVER     FLAG06
#define ACT_ACCOUNT             FLAG07
#define ACT_HIGHLIGHT           FLAG08
#define ACT_FLAG                FLAG09
#define ACT_READ                FLAG10
#define ACT_MARKDOWNLOAD        FLAG11
#define ACT_WATCH               FLAG12
#define ACT_IGNORE              FLAG13

HRESULT RuleUtil_HrMergeActions(ACT_ITEM * pActionsOrig, ULONG cActionsOrig,
                                ACT_ITEM * pActionsNew, ULONG cActionsNew,
                                ACT_ITEM ** ppActionsDest, ULONG * pcActionsDest);
                                
HRESULT RuleUtil_HrGetOldFormatString(HKEY hkeyRoot, LPCSTR pszValue, LPCSTR pszSep, LPSTR * ppszString, ULONG * pcchString);

// Functions to import/export messages
HRESULT RuleUtil_HrImportRules(HWND hwnd);
HRESULT RuleUtil_HrExportRules(HWND hwnd);

const int RULE_APPLY_PARTIALS = 0x00000001;
const int RULE_APPLY_SHOWUI   = 0x00000002;

HRESULT RuleUtil_HrApplyRulesToFolder(DWORD dwFlags, DWORD dwDeleteFlags,
                IOEExecRules * pExecRules, IMessageFolder * pFolder, HWND hwndUI, CProgress * pProgress);

HRESULT RuleUtil_HrFindAction(ACT_ITEM * pActions, ULONG cActions, ACT_TYPE typeAct, ACT_ITEM ** ppActFound);

HRESULT RuleUtil_HrMapFldId(DWORD dwFlags, BYTE * pbFldIdMap, FOLDERID fldidOld, FOLDERID * pfldidNew);

HRESULT RuleUtil_HrGetUserData(DWORD dwFlags, LPSTR * ppszFirstName, LPSTR * ppszLastName, LPSTR * ppszCompanyName);
HRESULT RuleUtil_HrApplyActions(HWND hwndUI, IOEExecRules * pIExecRules, MESSAGEINFO * pMsgInfo,
                                IMessageFolder * pFolder, IMimeMessage * pIMMsg, DWORD dwDeleteFlags,
                                ACT_ITEM * pActions, ULONG cActions, ULONG * pcInfiniteLoops, BOOL *pfDeleteOffServer);

HRESULT RuleUtil_HrCreateSendersRule(DWORD dwFlags, IOERule ** ppIRule);
HRESULT RuleUtil_HrLoadSender(LPCSTR pszRegPath, DWORD dwFlags, IOERule ** ppIRule);
HRESULT RuleUtil_HrMatchSender(LPCSTR pszSender, MESSAGEINFO * pMsgInfo,
                        IMimeMessage * pIMMsg, IMimePropertySet * pIMPropSet);
HRESULT RuleUtil_HrUpdateDefaultRules(RULE_TYPE typeRule);

HRESULT RuleUtil_HrGetFilterVersion(RULEID ridFilter, DWORD * pdwVersion);
HRESULT RuleUtil_HrValidateRuleFolderData(RULEFOLDERDATA * prfdData);

typedef struct tagQUERYINFO
{
    BOOL    fThreaded;
    LPSTR   pszQuery;
    ULONG   cchQuery;
} QUERYINFO, * PQUERYINFO;

HRESULT RuleUtil_HrBuildQuerysFromFilter(RULEID ridFilter, QUERYINFO * pqinfoFilter);

const int VMF_FINDER    = 0x00000001;

class CViewMenu
{
    private:
        struct VIEW_ITEM
        {
            RULEID              ridRule;
            struct VIEW_ITEM *  pNext;
        };
        
        enum
        {
            STATE_UNINIT   = 0x00000000,
            STATE_INIT     = 0x00000001,
            STATE_LOADED   = 0x00000002,
            STATE_DIRTY    = 0x00000004,
        };

        enum
        {
            CCH_FILTERTAG_MAX   = 11
        };
        
    private:
        ULONG       m_cRef;
        DWORD       m_dwFlags;
        DWORD       m_dwState;
        RULEID      m_ridCurrent;
        CMRUList *  m_pmruList;
        
    public:
        CViewMenu() : m_cRef(1), m_dwFlags(0), m_dwState(STATE_UNINIT),
                    m_ridCurrent(RULEID_INVALID), m_pmruList(NULL) {}
        ~CViewMenu();

        ULONG AddRef(VOID);
        ULONG Release(VOID);
        
        HRESULT HrInit(DWORD dwFlags);
        HRESULT HrReplaceMenu(DWORD dwFlags, HMENU hmenuView);
        HRESULT UpdateViewMenu(DWORD dwFlags, HMENU hmenuView, IMessageList * pMsgList);

        HRESULT QueryStatus(IMessageList * pMsgList, OLECMD * prgCmds);
        HRESULT Exec(HWND hwndUI, DWORD nCmdID, IMessageList * pMsgList, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
        HRESULT HrAddView(DWORD dwFlags, RULEID ridRule) {return E_NOTIMPL; }

    private:
        VOID _AddDefaultViews(HMENU hmenuView);
        HRESULT _HrInsertViewMenu(HMENU hmenuView, RULEID ridFilter, DWORD dwMenuID, DWORD dwMenuIDInsert);
        HRESULT _HrReloadMRUViewMenu(HMENU hmenuView);
        HRESULT _HrAddExtraViewMenu(HMENU hmenuView, IOEMessageList * pIMsgList);
        VOID _AddViewToMRU(RULEID ridFilter);
        BOOL _FViewInMRUList(RULEID ridFilter, DWORD * pdwID);
        BOOL _FValiadateMRUList(VOID);
};

HRESULT HrCreateViewMenu(DWORD dwFlags, CViewMenu ** ppViewMenu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\spamui.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  SpamUI.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "oerules.h"
#include "spamui.h"
#include "junkrule.h"
#include "rule.h"
#include "ruleutil.h"
#include <rulesdlg.h>
#include <imagelst.h>
#include <msoejunk.h>
#include "shlwapip.h" 
#include <ipab.h>
#include <demand.h>

// Type definitions
typedef struct tagEDIT_EXCPT
{
    DWORD       dwFlags;
    LPSTR       pszExcpt;
} EDIT_EXCPT, * PEDIT_EXCPT;

// Class definitions
class CEditExceptionUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_DIRTY         = 0x00000002
        };

    private:
        HWND            m_hwndOwner;
        DWORD           m_dwFlags;
        DWORD           m_dwState;
        HWND            m_hwndDlg;
        HWND            m_hwndExcpt;

        EDIT_EXCPT *    m_pEditExcpt;

    public:
        CEditExceptionUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
                        m_hwndDlg(NULL), m_hwndExcpt(NULL), m_pEditExcpt(NULL) {}
        ~CEditExceptionUI();

        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags, EDIT_EXCPT * pEditExcpt);
        HRESULT HrShow(VOID);

        static INT_PTR CALLBACK FEditExcptDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
};

// global data
const static HELPMAP g_rgCtxMapJunkRules[] = {
                        {idcJunkMail,       idhJunkMail},
                        {idbExceptions,     idhExceptions},
                        {idcJunkSlider,     idhJunkSlider},
                        {idcJunkDelete,     idhJunkDelete},
                        {0, 0}};
                       
const static HELPMAP g_rgCtxMapSenderRules[] = {
                        {idbAddSender,      idhAddSender},
                        {idbModifySender,   idhModifySender},
                        {idbRemoveSender,   idhRemoveSender},
                        {0, 0}};
                       
CEditSenderUI::~CEditSenderUI()
{
    if ((NULL != m_pEditSender) && (NULL != m_pEditSender->pszSender))
    {
        MemFree(m_pEditSender->pszSender);
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes the edit sender UI dialog
//
//  hwndOwner   - the handle to the owner window of this dialog
//  dwFlags     - modifiers on how this dialog should act
//  pEditSender - the edit sender parameters
//
//  Returns:    S_OK, if it was successfully initialized
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditSenderUI::HrInit(HWND hwndOwner, DWORD dwFlags, EDIT_SENDER * pEditSender)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if ((NULL == hwndOwner) || (NULL == pEditSender))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    m_pEditSender = pEditSender;
    
    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrShow
//
//  This brings up the edit sender UI dialog
//
//  Returns:    S_OK, if the sender was successfully entered
//              S_FALSE, if the dialog was canceled
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditSenderUI::HrShow(VOID)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;

    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddEditSender),
                                        m_hwndOwner, CEditSenderUI::FEditSendersDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FEditSendersDlgProc
//
//  This is the main dialog proc for entering a sender
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CEditSenderUI::FEditSendersDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    CEditSenderUI * pEditSenderUI = NULL;

    pEditSenderUI = (CEditSenderUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            pEditSenderUI = (CEditSenderUI *) lParam;
            if (NULL == pEditSenderUI)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
                goto exit;
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM) pEditSenderUI);

            if (FALSE == pEditSenderUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;

        case WM_COMMAND:
            fRet = pEditSenderUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the edit senders dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditSenderUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL    fRet = FALSE;
    UINT    uiCtrl = 0;
    HWND    hwndCtrl = NULL;
    CHAR    szRes[CCHMAX_STRINGRES];
    UINT    uiTitle = 0;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we haven't been initialized yet...
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndSender = GetDlgItem(hwndDlg, idedtSender);
    if (NULL == m_hwndSender)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we have a sender, then set it into the list
    if (NULL != m_pEditSender->pszSender)
    {
        // Misformatted sender?
        if (SNDF_NONE == m_pEditSender->dwFlags)
        {
            fRet = FALSE;
            goto exit;
        }

        // Set the sender into the dialog
        Edit_SetText(m_hwndSender, m_pEditSender->pszSender);

        // Set the proper 
        if ((SNDF_MAIL | SNDF_NEWS) == m_pEditSender->dwFlags)
        {
            uiCtrl = idcBlockBoth;
        }
        else if (SNDF_NEWS == m_pEditSender->dwFlags)
        {
            uiCtrl = idcBlockNews;
        }
        else
        {
            uiCtrl = idcBlockMail;
        }

        uiTitle = idsEditBlockSender;
    }
    else
    {
        Edit_SetText(m_hwndSender, c_szEmpty);

        uiCtrl = idcBlockMail;

        uiTitle = idsAddBlockSender;
    }

    // Get the window title
    AthLoadString(uiTitle, szRes, sizeof(szRes));
    
    // Set the window title
    SetWindowText(m_hwndDlg, szRes);
    
    hwndCtrl = GetDlgItem(m_hwndDlg, uiCtrl);
    if (NULL == hwndCtrl)
    {
        fRet = FALSE;
        goto exit;
    }

    SendMessage(hwndCtrl, BM_SETCHECK, (WPARAM) BST_CHECKED, (LPARAM) 0);
    
    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the senders UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditSenderUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    ULONG   cchSender = 0;
    LPSTR   pszSender = NULL;
    CHAR    szRes[CCHMAX_STRINGRES];
    LPSTR   pszText = NULL;

    // Deal with the edit control notifications
    if ((EN_CHANGE == uiNotify) && (idedtSender == iCtl))
    {
        Assert(NULL != m_hwndSender);
        Assert((HWND) hwndCtl == m_hwndSender);

        RuleUtil_FEnDisDialogItem(m_hwndDlg, IDOK, 0 != Edit_GetTextLength(m_hwndSender));
        goto exit;
    }
    
    // We only handle menu and accelerator commands
    if ((0 != uiNotify) && (1 != uiNotify))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch (iCtl)
    {
        case IDCANCEL:
            EndDialog(m_hwndDlg, IDCANCEL);
            fRet = TRUE;
            break;
            
        case IDOK:
            // Get the sender from the edit well
            cchSender = Edit_GetTextLength(m_hwndSender) + 1;
            if (FAILED(HrAlloc((void **) &pszSender, cchSender * sizeof(*pszSender))))
            {
                fRet = FALSE;
                goto exit;
            }
            
            pszSender[0] = '\0';
            cchSender = Edit_GetText(m_hwndSender, pszSender, cchSender);
            
            // Check to see if the sender is valid
            if (0 == UlStripWhitespace(pszSender, TRUE, TRUE, NULL))
            {
                // Put up a message saying something is busted
                AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                                MAKEINTRESOURCEW(idsSenderBlank), NULL,
                                MB_OK | MB_ICONINFORMATION);
                fRet = FALSE;
                goto exit;
            }

            if (FALSE != SendMessage(m_hwndOwner, WM_OE_FIND_DUP, (WPARAM) (m_pEditSender->lSelected), (LPARAM) pszSender))
            {
                AthLoadString(idsSenderDupWarn, szRes, sizeof(szRes));
                
                if (FAILED(HrAlloc((VOID **) &pszText, (lstrlen(pszSender) * 2 + lstrlen(szRes) + 1) * sizeof(*pszText))))
                {
                    fRet = FALSE;
                    goto exit;
                }

                wsprintf(pszText, szRes, pszSender, pszSender);
                
                // Put up a message saying something is busted
                if (IDYES != AthMessageBox(m_hwndDlg, MAKEINTRESOURCE(idsAthenaMail),
                                pszText, NULL, MB_YESNO | MB_ICONINFORMATION))
                {
                    fRet = FALSE;
                    goto exit;
                }
            }
            
            // Save off the sender
            SafeMemFree(m_pEditSender->pszSender);
            m_pEditSender->pszSender = pszSender;
            pszSender = NULL;

            if (BST_CHECKED == SendMessage(GetDlgItem(m_hwndDlg, idcBlockMail),
                                                BM_GETCHECK, (WPARAM) 0, (LPARAM) 0))
            {
                m_pEditSender->dwFlags = SNDF_MAIL;
            }
            else if (BST_CHECKED == SendMessage(GetDlgItem(m_hwndDlg, idcBlockNews),
                                                BM_GETCHECK, (WPARAM) 0, (LPARAM) 0))
            {
                m_pEditSender->dwFlags = SNDF_NEWS;
            }
            else if (BST_CHECKED == SendMessage(GetDlgItem(m_hwndDlg, idcBlockBoth),
                                                BM_GETCHECK, (WPARAM) 0, (LPARAM) 0))
            {
                m_pEditSender->dwFlags = SNDF_MAIL | SNDF_NEWS;
            }
            
            EndDialog(m_hwndDlg, IDOK);
            fRet = TRUE;
            break;
    }
    
exit:
    SafeMemFree(pszText);
    SafeMemFree(pszSender);
    return fRet;
}

// This is for editing the exceptions from the exceptions list UI

///////////////////////////////////////////////////////////////////////////////
//
//  ~CEditExceptionUI
//
//  This is the default destructor for the Exception editor
//
//  Returns:    None
//
///////////////////////////////////////////////////////////////////////////////
CEditExceptionUI::~CEditExceptionUI()
{
    if ((NULL != m_pEditExcpt) && (NULL != m_pEditExcpt->pszExcpt))
    {
        MemFree(m_pEditExcpt->pszExcpt);
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes the edit exception UI dialog
//
//  hwndOwner   - the handle to the owner window of this dialog
//  dwFlags     - modifiers on how this dialog should act
//  pEditExcpt - the edit exception parameters
//
//  Returns:    S_OK, if it was successfully initialized
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditExceptionUI::HrInit(HWND hwndOwner, DWORD dwFlags, EDIT_EXCPT * pEditExcpt)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if ((NULL == hwndOwner) || (NULL == pEditExcpt))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    m_pEditExcpt = pEditExcpt;
    
    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrShow
//
//  This brings up the edit exception UI dialog
//
//  Returns:    S_OK, if the sender was successfully entered
//              S_FALSE, if the dialog was canceled
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CEditExceptionUI::HrShow(VOID)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;

    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddEditException),
                                        m_hwndOwner, CEditExceptionUI::FEditExcptDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FEditExcptDlgProc
//
//  This is the main dialog proc for entering an exception
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CEditExceptionUI::FEditExcptDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                fRet = FALSE;
    CEditExceptionUI *  pEditExcptUI = NULL;

    pEditExcptUI = (CEditExceptionUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            pEditExcptUI = (CEditExceptionUI *) lParam;
            if (NULL == pEditExcptUI)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
                goto exit;
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM) pEditExcptUI);

            if (FALSE == pEditExcptUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;

        case WM_COMMAND:
            fRet = pEditExcptUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the edit exception dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditExceptionUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL    fRet = FALSE;
    UINT    uiCtrl = 0;
    HWND    hwndCtrl = NULL;
    CHAR    szRes[CCHMAX_STRINGRES];
    UINT    uiTitle = 0;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we haven't been initialized yet...
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndExcpt = GetDlgItem(hwndDlg, idedtException);
    if (NULL == m_hwndExcpt)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we have a sender, then set it into the list
    if (NULL != m_pEditExcpt->pszExcpt)
    {
        // Set the sender into the dialog
        Edit_SetText(m_hwndExcpt, m_pEditExcpt->pszExcpt);

        uiTitle = idsEditException;
    }
    else
    {
        Edit_SetText(m_hwndExcpt, c_szEmpty);
        
        uiTitle = idsAddException;
    }
    
    // Get the window title
    AthLoadString(uiTitle, szRes, sizeof(szRes));
    
    // Set the window title
    SetWindowText(m_hwndDlg, szRes);
    
    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the exception UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CEditExceptionUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    ULONG   cchExcpt = 0;
    LPSTR   pszExcpt = NULL;

    // Deal with the edit control notifications
    if ((EN_CHANGE == uiNotify) && (idedtException == iCtl))
    {
        Assert(NULL != m_hwndExcpt);
        Assert((HWND) hwndCtl == m_hwndExcpt);

        RuleUtil_FEnDisDialogItem(m_hwndDlg, IDOK, 0 != Edit_GetTextLength(m_hwndExcpt));
        goto exit;
    }
    
    // We only handle menu and accelerator commands
    if ((0 != uiNotify) && (1 != uiNotify))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch (iCtl)
    {
        case IDCANCEL:
            EndDialog(m_hwndDlg, IDCANCEL);
            fRet = TRUE;
            break;
            
        case IDOK:
            // Get the sender from the edit well
            cchExcpt = Edit_GetTextLength(m_hwndExcpt) + 1;
            if (FAILED(HrAlloc((void **) &pszExcpt, cchExcpt * sizeof(*pszExcpt))))
            {
                fRet = FALSE;
                goto exit;
            }
            
            pszExcpt[0] = '\0';
            cchExcpt = Edit_GetText(m_hwndExcpt, pszExcpt, cchExcpt);
            
            // Check to see if the sender is valid
            if (0 == UlStripWhitespace(pszExcpt, TRUE, TRUE, NULL))
            {
                // Put up a message saying something is busted
                AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                                MAKEINTRESOURCEW(idsExceptionBlank), NULL,
                                MB_OK | MB_ICONINFORMATION);
                MemFree(pszExcpt);
                fRet = FALSE;
                goto exit;
            }

            // Save off the sender
            SafeMemFree(m_pEditExcpt->pszExcpt);
            m_pEditExcpt->pszExcpt = pszExcpt;

            EndDialog(m_hwndDlg, IDOK);
            fRet = TRUE;
            break;
    }
    
exit:
    return fRet;
}

// Default destructor for the Junk Rules UI
COEJunkRulesPageUI::~COEJunkRulesPageUI()
{
    if (NULL != m_himl)
    {
        ImageList_Destroy(m_himl);
    }
    
    if (NULL != m_pExceptionsUI)
    {
        delete m_pExceptionsUI;
        m_pExceptionsUI = NULL;
    }
    SafeRelease(m_pIRuleJunk);
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes the junk UI dialog
//
//  hwndOwner   - the handle to the owner window of this dialog
//  dwFlags     - modifiers on how this dialog should act
//
//  Returns:    S_OK, if it was successfully initialized
//
///////////////////////////////////////////////////////////////////////////////
HRESULT COEJunkRulesPageUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == hwndOwner)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    // Let's create the Exception List UI
    m_pExceptionsUI = new CExceptionsListUI;
    if (NULL == m_pExceptionsUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrCommitChanges
//
//  This commits the changes to the rules
//
//  dwFlags     - modifiers on how we should commit the changes
//  fClearDirty - should we clear the dirty state
//
//  Returns:    S_OK, if it was successfully committed
//
///////////////////////////////////////////////////////////////////////////////
HRESULT COEJunkRulesPageUI::HrCommitChanges(DWORD dwFlags, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    BOOL        fJunkEnable = FALSE;
    DWORD       dwVal = 0;
    RULEINFO    infoRule = {0};
    
    // Check incoming params
    if (0 != dwFlags)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Fail if we weren't initialized
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // If we aren't dirty, then there's
    // nothing to do
    if (0 == (m_dwState & STATE_DIRTY))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Save the junk mail rule settings
    if (FALSE == _FSaveJunkSettings())
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Initialize the rule info
    infoRule.ridRule = RULEID_JUNK;
    infoRule.pIRule = m_pIRuleJunk;
    
    // Set the rules into the rules manager
    hr = g_pRulesMan->SetRules(SETF_JUNK, RULE_TYPE_MAIL, &infoRule, 1);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Should we delete items from the Junk folder
    dwVal = (BST_CHECKED == Button_GetCheck(GetDlgItem(m_hwndDlg, idcJunkDelete))) ? 1 : 0;
    
    SetDwOption(OPT_DELETEJUNK, dwVal, NULL, 0);

    // How many days should we wait?
    dwVal = (DWORD) SendMessage(GetDlgItem(m_hwndDlg, idcJunkDeleteSpin), UDM_GETPOS, (WPARAM) 0, (LPARAM) 0);

    if (0 == HIWORD(dwVal))
    {
        SetDwOption(OPT_DELETEJUNKDAYS, dwVal, NULL, 0);
    }

    // Should we clear the dirty state
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~STATE_DIRTY;
    }
    
    hr = S_OK;
    
exit:
    return hr;
}

INT_PTR CALLBACK COEJunkRulesPageUI::FJunkRulesPageDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    COEJunkRulesPageUI *    pJunkUI = NULL;

    pJunkUI = (COEJunkRulesPageUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pJunkUI = (COEJunkRulesPageUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM) pJunkUI);

            if (FALSE == pJunkUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;

        case WM_COMMAND:
            if (NULL != pJunkUI)
            {
                fRet = pJunkUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            }
            break;

        case WM_NOTIFY:
            if (NULL != pJunkUI)
            {
                fRet = pJunkUI->FOnNotify((INT) LOWORD(wParam), (NMHDR *) lParam);
            }
            break;

        case WM_HSCROLL:
            if (NULL != pJunkUI)
            {
                fRet = pJunkUI->FOnHScroll((INT) LOWORD(wParam), (short int) HIWORD(wParam), (HWND) lParam);
            }
            break;

        case WM_DESTROY:
            if (NULL != pJunkUI)
            {
                fRet = pJunkUI->FOnDestroy();
            }
            break;  
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            fRet =  OnContextHelp(hwndDlg, uiMsg, wParam, lParam, g_rgCtxMapJunkRules);
            break;
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FGetRules
//
//  This brings up the edit UI for the selected rule from the mail rules list
//
//  fBegin  - is this for the LVN_BEGINLABELEDIT notification
//  pdi     - the display info for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::FGetRules(RULE_TYPE typeRule, RULENODE ** pprnode)
{
    BOOL            fRet = FALSE;
    IOERule *       pIRule = NULL;
    RULENODE *      prnodeNew = NULL;
    HRESULT         hr = S_OK;
    PROPVARIANT     propvar = {0};

    if (NULL == pprnode)
    {
        fRet = FALSE;
        goto exit;
    }

    // Fail if we weren't initialized
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize the outgoing param
    *pprnode = NULL;
    
    // Make sure we don't lose any changes

    // Get the correct rule
    if (RULE_TYPE_MAIL == typeRule)
    {
        if (FALSE != _FSaveJunkSettings())
        {
            pIRule = m_pIRuleJunk;
        }
    }
    else
    {
        fRet = FALSE;
        goto exit;
    }

    // Nothing to do if we don't have a rule
    if (NULL == pIRule)
    {
        fRet = TRUE;
        goto exit;
    }

    // Skip over invalid rules
    hr = pIRule->Validate(0);
    if (FAILED(hr) || (S_FALSE == hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Skip over the junk rule if it is disabled
    hr = pIRule->GetProp(RULE_PROP_DISABLED, 0, &propvar);
    if ((FAILED(hr)) || (FALSE != propvar.boolVal))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Create a new rule node
    prnodeNew = new RULENODE;
    if (NULL == prnodeNew)
    {
        fRet = FALSE;
        goto exit;
    }

    prnodeNew->pNext = NULL;
    prnodeNew->pIRule = pIRule;
    prnodeNew->pIRule->AddRef();
    
    // Set the outgoing param
    *pprnode = prnodeNew;
    prnodeNew = NULL;
    
    fRet = TRUE;
    
exit:
    PropVariantClear(&propvar);
    if (NULL != prnodeNew)
    {
        if (NULL != prnodeNew->pIRule)
        {
            prnodeNew->pIRule->Release();
        }
        delete prnodeNew; // MemFree(prnodeNew);
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the junk UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    CHAR            szRes[CCHMAX_STRINGRES];
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we haven't been initialized yet...
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Initialize the controls
    fRet = _FInitCtrls();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Initialize the Exceptions List
    if (FAILED(m_pExceptionsUI->HrInit(m_hwndDlg, m_dwFlags)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    if (FALSE != FIsIMAPOrHTTPAvailable())
    {
        AthLoadString(idsJunkMailNoIMAP, szRes, sizeof(szRes));

        SetDlgItemText(m_hwndDlg, idcJunkTitle, szRes);
    }
    
    // Update the buttons
    _EnableButtons();
    
    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the junk UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL        fRet = FALSE;
    HRESULT     hr = S_OK;
    
    switch (iCtl)
    {
        case idcJunkMail:
            if (BST_CHECKED == Button_GetCheck(GetDlgItem(m_hwndDlg, idcJunkMail)))
            {
                if (NULL == m_pIRuleJunk)
                {
                    hr = HrCreateJunkRule(&m_pIRuleJunk);
                    if (FAILED(hr))
                    {
                        fRet = FALSE;
                        SafeRelease(m_pIRuleJunk);
                        goto exit;
                    }
                }
            }
            // Fall through
            
        case idcJunkDelete:
            // Update the buttons
            _EnableButtons();
            
            // Note that the state has changed
            m_dwState |= STATE_DIRTY;
            fRet = FALSE;
            break;
            
        case idedtJunkDelete:
            if ((0 != (m_dwState & STATE_CTRL_INIT)) && (EN_CHANGE == uiNotify))
            {
                // Note that the state has changed
                m_dwState |= STATE_DIRTY;
                fRet = FALSE;
            }
            break;

        case idbExceptions:
            if (S_OK == m_pExceptionsUI->HrShow(m_pIRuleJunk))
            {
                // Note that the state has changed
                m_dwState |= STATE_DIRTY;
                fRet = FALSE;
            }
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnNotify
//
//  This handles the WM_NOTIFY message for the junk UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::FOnNotify(INT iCtl, NMHDR * pnmhdr)
{
    BOOL            fRet = FALSE;
    NMLISTVIEW *    pnmlv = NULL;
    NMLVKEYDOWN *   pnmlvkd = NULL;
    INT             iSelected = 0;
    LVHITTESTINFO   lvh;

    // We only handle notifications for the list control
    if (idcJunkDeleteSpin != pnmhdr->idFrom)
    {
        fRet = FALSE;
        goto exit;
    }
    
    pnmlv = (LPNMLISTVIEW) pnmhdr;

    switch (pnmlv->hdr.code)
    {
        case UDN_DELTAPOS:
            // Note that the state has changed
            m_dwState |= STATE_DIRTY;
            fRet = FALSE;
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnHScroll
//
//  This handles the WM_NOTIFY message for the junk UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::FOnHScroll(INT iScrollCode, short int iPos, HWND hwndCtl)
{
    BOOL            fRet = FALSE;

    // We only handle messags for the slider control
    if (GetDlgItem(m_hwndDlg, idcJunkSlider) != hwndCtl)
    {
        fRet = FALSE;
        goto exit;
    }

    // Note that the state has changed
    m_dwState |= STATE_DIRTY;
    fRet = FALSE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInitCtrls
//
//  This initializes the controls in the junk UI dialog
//
//  Returns:    TRUE, on successful initialization
//              FALSE, otherwise.
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::_FInitCtrls(VOID)
{
    BOOL        fRet = FALSE;
    DWORD       dwJunkPct = 0;
    BOOL        fEnableDelete = FALSE;
    HICON       hIcon = NULL;
    IOERule *   pIRuleOrig = NULL;
    IOERule *   pIRule = NULL;
    HRESULT     hr = S_OK;
    
    // Get the icons
    m_himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbRules), 32, 0,
                                    RGB(255, 0, 255));
    if (NULL == m_himl)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the icons into the dialog
    hIcon = ImageList_GetIcon(m_himl, ID_JUNK_SCALE, ILD_TRANSPARENT);
    SendDlgItemMessage(m_hwndDlg, idcJunkSliderIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    hIcon = ImageList_GetIcon(m_himl, ID_JUNK_DELETE, ILD_TRANSPARENT);
    SendDlgItemMessage(m_hwndDlg, idcJunkDeleteIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    // Set the range of the slider
    SendDlgItemMessage(m_hwndDlg, idcJunkSlider, TBM_SETRANGE, (WPARAM) TRUE, (LPARAM) MAKELONG(0, 4));
    
    // Get the junk mail rule
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->GetRule(RULEID_JUNK, RULE_TYPE_MAIL, 0, &pIRuleOrig);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Save off the junk mail rule
    Assert (NULL == m_pIRuleJunk);
    hr = pIRuleOrig->Clone(&pIRule);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    m_pIRuleJunk = pIRule;
    pIRule = NULL;

    // Get the setings from the junk rule
    _FLoadJunkSettings();
    
    // Do we want to delete the junk mail
    fEnableDelete = !!DwGetOption(OPT_DELETEJUNK);
    Button_SetCheck(GetDlgItem(m_hwndDlg, idcJunkDelete), fEnableDelete ? BST_CHECKED : BST_UNCHECKED);

    // Set the range of the spinner
    SendDlgItemMessage(m_hwndDlg, idcJunkDeleteSpin, UDM_SETRANGE, (WPARAM) 0, (LPARAM) MAKELONG(999, 1));
    
    // How many days should we wait?
    SendDlgItemMessage(m_hwndDlg, idcJunkDeleteSpin, UDM_SETPOS, (WPARAM) 0,
                (LPARAM) MAKELONG(DwGetOption(OPT_DELETEJUNKDAYS), 0));
    if (FALSE == fEnableDelete)
    {
        EnableWindow(GetDlgItem(m_hwndDlg, idcJunkDeleteSpin), FALSE);
        EnableWindow(GetDlgItem(m_hwndDlg, idedtJunkDelete), FALSE);
    }
    
    m_dwState |= STATE_CTRL_INIT;
    
    // We worked
    fRet = TRUE;
    
exit:
    SafeRelease(pIRule);
    SafeRelease(pIRuleOrig);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadJunkSettings
//
//  This load the senders from the rule and inserts them into the senders list.
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::_FLoadJunkSettings()
{
    BOOL        fRet = FALSE;
    PROPVARIANT propvar = {0};
    int         iEnabled = 0;
    DWORD       dwJunkPct = 0;
    
    Assert(NULL != m_pIRuleJunk);
    
    // Get the Junk detection enabled state
    iEnabled = BST_UNCHECKED;
    if ((SUCCEEDED(m_pIRuleJunk->GetProp(RULE_PROP_DISABLED, 0, &propvar))))
    {
        Assert(VT_BOOL == propvar.vt);
        iEnabled = (FALSE == propvar.boolVal) ? BST_CHECKED : BST_UNCHECKED;
    }

    // Set the junk mail flag
    Button_SetCheck(GetDlgItem(m_hwndDlg, idcJunkMail), iEnabled);
    
    // Get the Junk percent
    dwJunkPct = 2;
    if (SUCCEEDED(m_pIRuleJunk->GetProp(RULE_PROP_JUNKPCT, 0, &propvar)))
    {
        Assert(VT_UI4 == propvar.vt);
        dwJunkPct = propvar.ulVal;
    }

    // Set the Junk percent
    SendDlgItemMessage(m_hwndDlg, idcJunkSlider, TBM_SETPOS, (WPARAM) TRUE, (LPARAM) dwJunkPct);
    
    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSaveJunkSettings
//
//  This load the senders from the rule and inserts them into the senders list.
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEJunkRulesPageUI::_FSaveJunkSettings()
{
    BOOL        fRet = FALSE;
    PROPVARIANT propvar = {0};
    BOOL        fDisabled = 0;
    DWORD       dwJunkPct = 0;
    HRESULT     hr = S_OK;

    Assert(NULL != m_pIRuleJunk);
    
    // Get the Junk detection enabled state
    fDisabled = !!(BST_UNCHECKED == Button_GetCheck(GetDlgItem(m_hwndDlg, idcJunkMail)));

    // Set the disabled state
    propvar.vt = VT_BOOL;
    propvar.boolVal = (VARIANT_BOOL) !!fDisabled;
    if (FAILED(m_pIRuleJunk->SetProp(RULE_PROP_DISABLED, 0, &propvar)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the Junk percent
    dwJunkPct = (DWORD) SendMessage(GetDlgItem(m_hwndDlg, idcJunkSlider), TBM_GETPOS, (WPARAM) 0, (LPARAM) 0);

    // Set the Junk percent
    propvar.vt = VT_UI4;
    propvar.ulVal = dwJunkPct;
    if (FAILED(m_pIRuleJunk->SetProp(RULE_PROP_JUNKPCT, 0, &propvar)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the return value
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableButtons
//
//  This enables or disables the buttons in the junk UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEJunkRulesPageUI::_EnableButtons(VOID)
{
    int         cRules = 0;
    BOOL        fEnableJunk = FALSE;
    BOOL        fEnableDelete = FALSE;
    
    // Get the enabled state of Junk
    fEnableJunk = !!(BST_CHECKED == Button_GetCheck(GetDlgItem(m_hwndDlg, idcJunkMail)));

    // Get the enabled state of Delete
    fEnableDelete = !!(BST_CHECKED == Button_GetCheck(GetDlgItem(m_hwndDlg, idcJunkDelete)));

    // Enable the senders action buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcJunkDays, fEnableJunk);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcJunkDeleteSpin, (fEnableDelete && fEnableJunk));
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idedtJunkDelete, (fEnableDelete && fEnableJunk));
        
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcJunkDelete, fEnableJunk);

    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcJunkSliderMore, fEnableJunk);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcJunkSlider, fEnableJunk);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcJunkSliderLess, fEnableJunk);
    
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbExceptions, fEnableJunk);

    return;
}

const COLUMNITEM COESendersRulesPageUI::m_rgcitem[] =
{
    {idsCaptionMail, 50},
    {idsCaptionNews, 50},
    {idsSenderDesc, 105}
};

const UINT COESendersRulesPageUI::m_crgcitem = ARRAYSIZE(COESendersRulesPageUI::m_rgcitem);

// Default destructor for the Mail Rules UI
COESendersRulesPageUI::~COESendersRulesPageUI()
{
    SafeRelease(m_pIRuleMail);
    SafeRelease(m_pIRuleNews);
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes the senders UI dialog
//
//  hwndOwner   - the handle to the owner window of this dialog
//  dwFlags     - modifiers on how this dialog should act
//
//  Returns:    S_OK, if it was successfully initialized
//
///////////////////////////////////////////////////////////////////////////////
HRESULT COESendersRulesPageUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == hwndOwner)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrCommitChanges
//
//  This commits the changes to the rules
//
//  dwFlags     - modifiers on how we should commit the changes
//  fClearDirty - should we clear the dirty state
//
//  Returns:    S_OK, if it was successfully committed
//
///////////////////////////////////////////////////////////////////////////////
HRESULT COESendersRulesPageUI::HrCommitChanges(DWORD dwFlags, BOOL fClearDirty)
{
    HRESULT     hr = S_OK;
    RULEINFO    infoRule = {0};

    Assert(NULL != m_hwndList);
    
    // Check incoming params
    if (0 != dwFlags)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Fail if we weren't initialized
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // If we aren't dirty, then there's
    // nothing to do
    if (0 == (m_dwState & STATE_DIRTY))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Save the mail senders
    if (FALSE == _FSaveSenders(RULE_TYPE_MAIL))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Initialize the rule info
    infoRule.ridRule = RULEID_SENDERS;
    infoRule.pIRule = m_pIRuleMail;
    
    // Set the rules into the rules manager
    hr = g_pRulesMan->SetRules(SETF_SENDER, RULE_TYPE_MAIL, &infoRule, 1);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Save the news senders
    if (FALSE == _FSaveSenders(RULE_TYPE_NEWS))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Initialize the rule info
    infoRule.ridRule = RULEID_SENDERS;
    infoRule.pIRule = m_pIRuleNews;
    
    // Set the rules into the rules manager
    hr = g_pRulesMan->SetRules(SETF_SENDER, RULE_TYPE_NEWS, &infoRule, 1);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Should we clear the dirty state
    if (FALSE != fClearDirty)
    {
        m_dwState &= ~STATE_DIRTY;
    }
    
    hr = S_OK;
    
exit:
    return hr;
}

INT_PTR CALLBACK COESendersRulesPageUI::FSendersRulesPageDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    COESendersRulesPageUI * pSendersUI = NULL;

    pSendersUI = (COESendersRulesPageUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pSendersUI = (COESendersRulesPageUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM) pSendersUI);

            if (FALSE == pSendersUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;

        case WM_COMMAND:
            fRet = pSendersUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;

        case WM_NOTIFY:
            fRet = pSendersUI->FOnNotify((INT) LOWORD(wParam), (NMHDR *) lParam);
            break;

        case WM_DESTROY:
            fRet = pSendersUI->FOnDestroy();
            break;
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            fRet = OnContextHelp(hwndDlg, uiMsg, wParam, lParam, g_rgCtxMapSenderRules);
            break;

        case WM_OE_FIND_DUP:
            fRet = pSendersUI->FFindItem((LPCSTR) lParam, (LONG) wParam);
            break;
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FGetRules
//
//  This brings up the edit UI for the selected rule from the mail rules list
//
//  fBegin  - is this for the LVN_BEGINLABELEDIT notification
//  pdi     - the display info for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::FGetRules(RULE_TYPE typeRule, RULENODE ** pprnode)
{
    BOOL            fRet = FALSE;
    IOERule *       pIRule = NULL;
    RULENODE *      prnodeNew = NULL;
    HRESULT         hr = S_OK;

    if (NULL == pprnode)
    {
        fRet = FALSE;
        goto exit;
    }

    // Fail if we weren't initialized
    if ((0 == (m_dwState & STATE_INITIALIZED)) || (NULL == m_hwndList))
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize the outgoing param
    *pprnode = NULL;
    
    // Make sure we don't loose any changes
    _FSaveSenders(typeRule);
    
    if (RULE_TYPE_MAIL == typeRule)
    {
        pIRule = m_pIRuleMail;
    }
    else if (RULE_TYPE_NEWS == typeRule)
    {
        pIRule = m_pIRuleNews;
    }
    else
    {
        fRet = FALSE;
        goto exit;
    }

    // Nothing to do if we don't have a rule
    if (NULL == pIRule)
    {
        fRet = TRUE;
        goto exit;
    }

    // Skip over invalid rules
    hr = pIRule->Validate(0);
    if (FAILED(hr) || (S_FALSE == hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Create a new rule node
    prnodeNew = new RULENODE;
    if (NULL == prnodeNew)
    {
        fRet = FALSE;
        goto exit;
    }

    prnodeNew->pNext = NULL;
    prnodeNew->pIRule = pIRule;
    prnodeNew->pIRule->AddRef();

    // Set the outgoing param
    *pprnode = prnodeNew;
    prnodeNew = NULL;
    
    fRet = TRUE;
    
exit:
    if (NULL != prnodeNew)
    {
        if (NULL != prnodeNew->pIRule)
        {
            prnodeNew->pIRule->Release();
        }
        delete prnodeNew; // MemFree(prnodeNew);
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the senders UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    CHAR            szRes[CCHMAX_STRINGRES];
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we haven't been initialized yet...
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndList = GetDlgItem(hwndDlg, idlvSenderList);
    if (NULL == m_hwndList)
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize the list view
    fRet = _FInitListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Load the list view
    fRet = _FLoadListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }
    
    if (FALSE != FIsIMAPOrHTTPAvailable())
    {
        AthLoadString(idsBlockSenderNoIMAP, szRes, sizeof(szRes));

        SetDlgItemText(m_hwndDlg, idcSenderTitle, szRes);
    }
    
    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the senders UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    LVITEM  lvitem;
    INT     iSelected = 0;

    // We only handle menu and accelerator commands
    if ((0 != uiNotify) && (1 != uiNotify))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch (iCtl)
    {
        case idbAddSender:
            _NewSender();
            fRet = TRUE;
            break;

        case idbModifySender:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Bring up the rule editor for that item
                _EditSender(iSelected);
                fRet = TRUE;
            }
            break;

        case idbRemoveSender:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Remove the rule from the list
                _RemoveSender(iSelected);
                fRet = TRUE;
            }
            break;            
    }
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnNotify
//
//  This handles the WM_NOTIFY message for the senders UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::FOnNotify(INT iCtl, NMHDR * pnmhdr)
{
    BOOL            fRet = FALSE;
    NMLISTVIEW *    pnmlv = NULL;
    NMLVKEYDOWN *   pnmlvkd = NULL;
    INT             iSelected = 0;
    LVHITTESTINFO   lvh;

    // We only handle notifications for the list control
    if (idlvSenderList != pnmhdr->idFrom)
    {
        fRet = FALSE;
        goto exit;
    }
    
    pnmlv = (LPNMLISTVIEW) pnmhdr;

    switch (pnmlv->hdr.code)
    {
        case NM_CLICK:
            // Did we click on an item?
            if (-1 != pnmlv->iItem)
            {
                ZeroMemory(&lvh, sizeof(lvh));
                lvh.pt = pnmlv->ptAction;
                iSelected = ListView_SubItemHitTest(m_hwndList, &lvh);
                if (-1 != iSelected)
                {
                    // Did we click on the enable field?
                    if ((0 != (lvh.flags & LVHT_ONITEMICON)) &&
                            (0 == (lvh.flags & LVHT_ONITEMLABEL)))
                    {
                        // Make sure this item is selected
                        ListView_SetItemState(m_hwndList, iSelected,
                                        LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                        
                        // Set the proper enable state
                        if (2 != lvh.iSubItem)
                        {
                            _EnableSender((0 != lvh.iSubItem) ? RULE_TYPE_NEWS : RULE_TYPE_MAIL, iSelected);
                        }
                    }
                }
            }
            else
            {
                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
          
        case NM_DBLCLK:
            // Did we click on an item?
            if (-1 != pnmlv->iItem)
            {
                ZeroMemory(&lvh, sizeof(lvh));
                lvh.pt = pnmlv->ptAction;
                iSelected = ListView_SubItemHitTest(pnmlv->hdr.hwndFrom, &lvh);
                if (-1 != iSelected)
                {
                    // Did we click on the rule name?
                    if (((0 == (lvh.flags & LVHT_ONITEMICON)) &&
                            (0 != (lvh.flags & LVHT_ONITEMLABEL))) || (2 == lvh.iSubItem))
                    {
                        // Edit the rule
                        _EditSender(iSelected);
                    }
                }
            }
            else
            {
                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
            
        case LVN_ITEMCHANGED:
            // If an item's state changed to selected..
            if ((-1 != pnmlv->iItem) &&
                        (0 != (pnmlv->uChanged & LVIF_STATE)) &&
                        (0 == (pnmlv->uOldState & LVIS_SELECTED)) &&
                        (0 != (pnmlv->uNewState & LVIS_SELECTED)))
            {
                // Enable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
        case LVN_KEYDOWN:
            pnmlvkd = (NMLVKEYDOWN *) pnmhdr;

            // The delete key removes the rule from the list view
            if (VK_DELETE == pnmlvkd->wVKey)
            {
                // Are we on a rule?
                iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (-1 != iSelected)
                {
                    // Remove the rule from the list
                    _RemoveSender(iSelected);
                }
            }
            break;
    }

    
exit:
    return fRet;
}
///////////////////////////////////////////////////////////////////////////////
//
//  FFindItem
//
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::FFindItem(LPCSTR pszFind, LONG lSkip)
{
    BOOL    fRet = FALSE;

    fRet = _FFindSender(pszFind, lSkip, NULL);

    // Tell the dialog it's aok to proceed
    SetDlgMsgResult(m_hwndDlg, WM_OE_FIND_DUP, fRet);

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInitListCtrl
//
//  This initializes the list view control in the senders dialog
//
//  Returns:    TRUE, on successful initialization
//              FALSE, otherwise.
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::_FInitListCtrl(VOID)
{
    BOOL        fRet = FALSE;
    LVCOLUMN    lvc;
    TCHAR       szRes[CCHMAX_STRINGRES];
    RECT        rc;
    UINT        ulIndex = 0;
    HIMAGELIST  himl = NULL;

    Assert(NULL != m_hwndList);
    
    // Initialize the list view structure
    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask = LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.pszText = szRes;

    // Calculate the size of the list view
    GetClientRect(m_hwndList, &rc);
    rc.right = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    // Add the columns to the list view
    for (ulIndex = 0; ulIndex < m_crgcitem; ulIndex++)
    {
        Assert(g_hLocRes);
        LoadString(g_hLocRes, m_rgcitem[ulIndex].uidsName, szRes, ARRAYSIZE(szRes));
        lvc.cchTextMax = lstrlen(szRes);

        if (ulIndex != (m_crgcitem - 1))
        {
            lvc.cx = m_rgcitem[ulIndex].uiWidth;
            rc.right -= lvc.cx;
        }
        else
        {
            lvc.cx = rc.right;
        }
        
        ListView_InsertColumn(m_hwndList, ulIndex, &lvc);
    }

    // Set the state image list
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idb16x16st), 16, 0, RGB(255, 0, 255));
    if (NULL != himl)
    {
        ListView_SetImageList(m_hwndList, himl, LVSIL_SMALL);
    }

    // Full row selection  and subitem images on listview
    ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT | LVS_EX_SUBITEMIMAGES);

    // We worked
    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadListCtrl
//
//  This loads the list view with the current senders
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::_FLoadListCtrl(VOID)
{
    BOOL            fRet = FALSE;
    HRESULT         hr =    S_OK;
    DWORD           dwListIndex = 0;
    IOERule *       pIRuleOrig = NULL;
    IOERule *       pIRule = NULL;

    Assert(NULL != m_hwndList);

    // Remove all the items from the list control
    ListView_DeleteAllItems(m_hwndList);

    // Get the mail sender rule
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->GetRule(RULEID_SENDERS, RULE_TYPE_MAIL, 0, &pIRuleOrig);
    if (SUCCEEDED(hr))
    {
        // If the block sender rule exist
        if (FALSE != _FLoadSenders(RULE_TYPE_MAIL, pIRuleOrig))
        {
            Assert (NULL == m_pIRuleMail);
            hr = pIRuleOrig->Clone(&pIRule);
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }

            m_pIRuleMail = pIRule;
            pIRule = NULL;
        }        
    }

    SafeRelease(pIRuleOrig);
    
    // Get the news sender rule
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->GetRule(RULEID_SENDERS, RULE_TYPE_NEWS, 0, &pIRuleOrig);
    if (SUCCEEDED(hr))
    {
        // If the block sender rule exist
        if (FALSE != _FLoadSenders(RULE_TYPE_NEWS, pIRuleOrig))
        {
            Assert (NULL == m_pIRuleNews);
            hr = pIRuleOrig->Clone(&pIRule);
            if (FAILED(hr))
            {
                fRet = FALSE;
                goto exit;
            }

            m_pIRuleNews = pIRule;
            pIRule = NULL;
        }        
    }

    SafeRelease(pIRuleOrig);
    
    // Select the first item in the list
    if ((NULL != m_pIRuleMail) || (NULL != m_pIRuleNews))
    {
        ListView_SetItemState(m_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
    
    // Enable the dialog buttons.
    _EnableButtons(((NULL != m_pIRuleMail) || (NULL != m_pIRuleNews)) ? 0 : -1);

    fRet = TRUE;
    
exit:
    SafeRelease(pIRule);
    SafeRelease(pIRuleOrig);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddRuleToList
//
//  This adds the filter passed in to the list view
//
//  dwIndex - the index on where to add the filter to into the list
//  pIRule  - the actual rule
//
//  Returns:    TRUE, if it was successfully added
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::_FAddSenderToList(RULE_TYPE type, LPSTR pszSender)
{
    BOOL        fRet = FALSE;
    LONG        lIndex = 0;
    LVITEM      lvitem = {0};
    ULONG       cchSender = 0;

    Assert(NULL != m_hwndList);

    // If there's nothing to do...
    if (NULL == pszSender)
    {
        fRet = FALSE;
        goto exit;
    }
    
    lvitem.mask = LVIF_IMAGE;
    
    // Insert it if we didn't find it
    if (FALSE == _FFindSender(pszSender, -1, &lIndex))
    {
        lvitem.iItem = ListView_GetItemCount(m_hwndList);
        lvitem.iImage = iiconStateUnchecked;

        lIndex = ListView_InsertItem(m_hwndList, &lvitem);
        if (-1 == lIndex)
        {
            fRet = FALSE;
            goto exit;
        }

        lvitem.iItem = lIndex;
        lvitem.iSubItem = 1;
        if (-1 == ListView_SetItem(m_hwndList, &lvitem))
        {
            fRet = FALSE;
            goto exit;
        }

        ListView_SetItemText(m_hwndList, lIndex, 2, pszSender);
        cchSender = lstrlen(pszSender) + 1;
        if (cchSender > m_cchLabelMax)
        {
            m_cchLabelMax = cchSender;
        }
    }

    // Enable the proper type
    lvitem.iItem = lIndex;
    lvitem.iImage = iiconStateChecked;
    lvitem.iSubItem = (RULE_TYPE_MAIL != type) ? 1 : 0;
    ListView_SetItem(m_hwndList, &lvitem);
    
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableButtons
//
//  This enables or disables the buttons in the senders UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COESendersRulesPageUI::_EnableButtons(INT iSelected)
{
    int         cRules = 0;
    BOOL        fSelected = FALSE;

    Assert(NULL != m_hwndList);

    fSelected = (-1 != iSelected);
    
    // Enable the senders action buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbRemoveSender, fSelected);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbModifySender, fSelected);
        
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableRule
//
//  This switches the current enabled state of the list view item
//  and updates the UI
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COESendersRulesPageUI::_EnableSender(RULE_TYPE type, int iSelected)
{
    HRESULT     hr = S_OK;
    LVITEM      lvi;
    IOERule *   pIRule = NULL;
    BOOL        fBlockNews = FALSE;
    BOOL        fBlockMail = FALSE;
    PROPVARIANT propvar;

    Assert(NULL != m_hwndList);
    
    // Are we blocking mail?
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_IMAGE;
    lvi.iItem = iSelected;
    if (FALSE == ListView_GetItem(m_hwndList, &lvi))
    {
        goto exit;
    }
    
    fBlockMail = (iiconStateUnchecked != lvi.iImage);
    
    // Are we blocking news?
    lvi.iSubItem = 1;
    if (FALSE == ListView_GetItem(m_hwndList, &lvi))
    {
        goto exit;
    }
    
    fBlockNews = (iiconStateUnchecked != lvi.iImage);
    
    // Disallow disabling both mail and news
    if (((RULE_TYPE_MAIL == type) && (FALSE != fBlockMail) && (FALSE == fBlockNews)) ||
            ((RULE_TYPE_NEWS == type) && (FALSE != fBlockNews) && (FALSE == fBlockMail)))
    {
        // Put up a message saying something is busted
        AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                        MAKEINTRESOURCEW(idsRuleSenderErrorNone), NULL,
                        MB_OK | MB_ICONERROR);
        goto exit;
    }

    // Set the UI to the opposite enabled state
    lvi.iSubItem = (RULE_TYPE_MAIL != type) ? 1 : 0;
    lvi.iImage = (RULE_TYPE_MAIL != type) ?
                    ((FALSE != fBlockNews) ? iiconStateUnchecked : iiconStateChecked) :
                        ((FALSE != fBlockMail) ? iiconStateUnchecked : iiconStateChecked);
    ListView_SetItem(m_hwndList, &lvi);
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
    
exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadSenders
//
//  This load the senders from the rule and inserts them into the senders list.
//
//  type    - the type of senders these are
//  pIRule  - the rule to get the senders from
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::_FLoadSenders(RULE_TYPE type, IOERule * pIRule)
{
    BOOL        fRet = FALSE;
    PROPVARIANT propvar;
    CRIT_ITEM * pCritItem = NULL;
    ULONG       cCritItem = 0;
    ULONG       ulIndex = 0;
    
    if (NULL == pIRule)
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the list of senders from the rule
    if (FAILED(pIRule->GetProp(RULE_PROP_CRITERIA, 0, &propvar)))
    {
        fRet = FALSE;
        goto exit;
    }

    if (0 != propvar.blob.cbSize)
    {
        Assert(VT_BLOB == propvar.vt);
        Assert(NULL != propvar.blob.pBlobData);
        cCritItem = propvar.blob.cbSize / sizeof(CRIT_ITEM);
        pCritItem = (CRIT_ITEM *) (propvar.blob.pBlobData);
        propvar.blob.pBlobData = NULL;
        propvar.blob.cbSize = 0;

        // Add each sender to the list
        for (ulIndex = 0; ulIndex < cCritItem; ulIndex++)
        {
            if ((CRIT_TYPE_SENDER == pCritItem[ulIndex].type) &&
                    (VT_LPSTR == pCritItem[ulIndex].propvar.vt) &&
                    (NULL != pCritItem[ulIndex].propvar.pszVal))
            {
                _FAddSenderToList(type, pCritItem[ulIndex].propvar.pszVal);
            }
            
        }
    }
    
    fRet = TRUE;
    
exit:
    RuleUtil_HrFreeCriteriaItem(pCritItem, cCritItem);
    SafeMemFree(pCritItem);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSaveSenders
//
//  This save the senders from the list into the rule.
//
//  type    - the type of senders to save
//
//  Returns:    TRUE, if it was successfully saved
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::_FSaveSenders(RULE_TYPE type)
{
    BOOL            fRet = FALSE;
    ULONG           cSender = 0;
    LPSTR           pszSender = NULL;
    CRIT_ITEM *     pcitemList = NULL;
    ULONG           ccitemList = 0;
    LVITEM          lvitem;
    ULONG           ulIndex = 0;
    IOERule *       pIRule = NULL;
    ACT_ITEM        aitem;
    PROPVARIANT     propvar;
    TCHAR           szRes[CCHMAX_STRINGRES];
    HRESULT         hr = S_OK;

    Assert(NULL != m_hwndList);

    ZeroMemory(&propvar, sizeof(propvar));
    
    // Figure out how many senders we have
    cSender = ListView_GetItemCount(m_hwndList);

    if (0 != cSender)
    {
        // Allocate space to hold the sender
        if (FAILED(HrAlloc((void **) &pszSender, m_cchLabelMax)))
        {
            fRet = FALSE;
            goto exit;
        }

        pszSender[0] = '\0';

        // Allocate space to hold the criteria
        if (FAILED(HrAlloc((void **) &pcitemList, cSender * sizeof(*pcitemList))))
        {
            fRet = FALSE;
            goto exit;
        }

        ZeroMemory(pcitemList, cSender * sizeof(*pcitemList));
    }
    
    ZeroMemory(&lvitem, sizeof(lvitem));
    lvitem.mask = LVIF_IMAGE;
    
    ccitemList = 0;
    for (ulIndex = 0; ulIndex < cSender; ulIndex++)
    {
        lvitem.iItem = ulIndex;
        lvitem.iSubItem = (RULE_TYPE_MAIL != type) ? 1 : 0;
        if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
        {
            continue;
        }
        
        if (FALSE != (iiconStateUnchecked != lvitem.iImage))
        {
            // Grab the sender from the list
            pszSender[0] ='\0';
            ListView_GetItemText(m_hwndList, ulIndex, 2, pszSender, m_cchLabelMax);
            if ('\0' != pszSender[0])
            {
                // Grab a copy of the sender
                pcitemList[ccitemList].propvar.pszVal = PszDupA(pszSender);
                if (NULL == pcitemList[ccitemList].propvar.pszVal)
                {
                    fRet = FALSE;
                    goto exit;
                }
                
                // Set the criteria specifics
                pcitemList[ccitemList].type = CRIT_TYPE_SENDER;
                pcitemList[ccitemList].logic = CRIT_LOGIC_OR;
                pcitemList[ccitemList].dwFlags = CRIT_FLAG_DEFAULT;
                pcitemList[ccitemList].propvar.vt = VT_LPSTR;

                ccitemList++;
            }   
        }
    }

    if (0 != ccitemList)
    {
        // Which rule are we looking at
        pIRule = (RULE_TYPE_MAIL != type) ? m_pIRuleNews : m_pIRuleMail;
    
        // Check the state
        if (NULL == pIRule)
        {
            // Create the new rule
            if (FAILED(RuleUtil_HrCreateSendersRule(0, &pIRule)))
            {
                fRet = FALSE;
                goto exit;
            }            
        }
        else
        {
            pIRule->AddRef();
        }

        // Set the new criteria in the rule
        ZeroMemory(&propvar, sizeof(propvar));
        propvar.vt = VT_BLOB;
        propvar.blob.cbSize = sizeof(CRIT_ITEM) * ccitemList;
        propvar.blob.pBlobData = (BYTE *) pcitemList;
        
        // Grab the list of criteria from the rule
        if (FAILED(pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar)))
        {
            fRet = FALSE;
            goto exit;
        }
    }

    if (RULE_TYPE_MAIL != type)
    {
        SafeRelease(m_pIRuleNews);
        m_pIRuleNews = pIRule;
    }
    else
    {
        SafeRelease(m_pIRuleMail);
        m_pIRuleMail = pIRule;
    }
    pIRule = NULL;
    
    // Set the proper return value
    fRet = TRUE;
    
exit:
    RuleUtil_HrFreeCriteriaItem(pcitemList, ccitemList);
    SafeMemFree(pcitemList);
    SafeMemFree(pszSender);
    SafeRelease(pIRule);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FFindSender
//
//  This brings up the edit UI to create a new sender for the senders list
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL COESendersRulesPageUI::_FFindSender(LPCSTR pszSender, LONG iSkip, LONG * plSender)
{
    BOOL    fRet = FALSE;
    LONG    cSenders = 0;
    LPSTR   pszLabel = NULL;
    LVITEM  lvitem = {0};
    LONG    lIndex = 0;
    
    // Check incoming params
    if (NULL == pszSender)
    {
        goto exit;
    }

    // Initialize the outgoing param
    if (NULL != plSender)
    {
        *plSender = -1;
    }
    
    // Get the number of senders
    cSenders = ListView_GetItemCount(m_hwndList);
    if (0 == cSenders)
    {
        goto exit;
    }
    
    if (FAILED(HrAlloc((void **) &pszLabel, m_cchLabelMax * sizeof(*pszLabel))))
    {
        goto exit;
    }
        
    // Set up the 
    lvitem.iSubItem = 2;
    lvitem.pszText = pszLabel;
    lvitem.cchTextMax = m_cchLabelMax;

    for (lIndex = 0; lIndex < cSenders; lIndex++)
    {
        // We need to skip over the selected item
        if (lIndex == iSkip)
        {
            continue;
        }
        
        if (0 != SendMessage(m_hwndList, LVM_GETITEMTEXT, (WPARAM) lIndex, (LPARAM) &lvitem))
        {
            if (0 == lstrcmpi(pszLabel, pszSender))
            {
                fRet = TRUE;
                break;
            }
        }
    }

    if (NULL != plSender)
    {
        if (lIndex < cSenders)
        {
            *plSender = lIndex;
        }
    }
    
exit:
    SafeMemFree(pszLabel);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _NewSender
//
//  This brings up the edit UI to create a new sender for the senders list
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COESendersRulesPageUI::_NewSender(VOID)
{
    HRESULT         hr = S_OK;
    EDIT_SENDER     editsndr = {0};
    CEditSenderUI * pEditSenderUI = NULL;
    LVITEM          lvitem = {0};
    LONG            iIndex = 0;
    ULONG           cchSender = 0;

    Assert(NULL != m_hwndList);

    editsndr.lSelected = -1;
    
    // Create the sender editor
    pEditSenderUI = new CEditSenderUI;
    if (NULL == pEditSenderUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditSenderUI->HrInit(m_hwndDlg, 0, &editsndr)))
    {
        goto exit;
    }

    // Bring up the sender editor UI
    hr = pEditSenderUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    // If the sender changed, make sure we change the label
    if (S_OK == hr)
    {
        lvitem.mask = LVIF_IMAGE;
        lvitem.iImage = (0 != (editsndr.dwFlags & SNDF_MAIL)) ?
                                    iiconStateChecked : iiconStateUnchecked;

        // Are we inserting or replacing?
        if (FALSE == _FFindSender(editsndr.pszSender, -1, &iIndex))
        {
            lvitem.iItem = ListView_GetItemCount(m_hwndList);
            iIndex = ListView_InsertItem(m_hwndList, &lvitem);
            if (-1 == iIndex)
            {
                goto exit;
            }
        }
        else
        {
            lvitem.iItem = iIndex;
            if (-1 == ListView_SetItem(m_hwndList, &lvitem))
            {
                goto exit;
            }
        }
        
        lvitem.iItem = iIndex;
        lvitem.iSubItem = 1;
        lvitem.iImage = (0 != (editsndr.dwFlags & SNDF_NEWS)) ?
                                    iiconStateChecked : iiconStateUnchecked;
        if (-1 == ListView_SetItem(m_hwndList, &lvitem))
        {
            goto exit;
        }

        ListView_SetItemText(m_hwndList, iIndex, 2, editsndr.pszSender);
        
        // Make sure the new item is selected
        ListView_SetItemState(m_hwndList, iIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        
        // Let's make sure we can see this new item
        ListView_EnsureVisible(m_hwndList, iIndex, FALSE);
        
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;
        
        cchSender = lstrlen(editsndr.pszSender) + 1;
        if (cchSender > m_cchLabelMax)
        {
            m_cchLabelMax = cchSender;
        }
    }
    
exit:
    SafeMemFree(editsndr.pszSender);
    if (NULL != pEditSenderUI)
    {
        delete pEditSenderUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EditSender
//
//  This brings up the edit UI for the selected sender from the senders list
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COESendersRulesPageUI::_EditSender(int iSelected)
{
    HRESULT         hr = S_OK;
    EDIT_SENDER     editsndr = {0};
    LVITEM          lvitem = {0};
    CEditSenderUI * pEditSenderUI = NULL;
    ULONG           cchSender = 0;
    LONG            lItemDelete = 0;

    Assert(NULL != m_hwndList);
    
    editsndr.lSelected = iSelected;
    
    // Allocate space to hold the sender
    hr = HrAlloc((void **) &(editsndr.pszSender), m_cchLabelMax);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Grab the sender from the list
    lvitem.iSubItem = 2;
    lvitem.pszText = editsndr.pszSender;
    lvitem.cchTextMax = m_cchLabelMax;

    if (0 == SendMessage(m_hwndList, LVM_GETITEMTEXT, (WPARAM) iSelected, (LPARAM) &lvitem))
    {
        goto exit;
    }   
    
    // Are we blocking mail?
    ZeroMemory(&lvitem, sizeof(lvitem));
    lvitem.mask = LVIF_IMAGE;
    lvitem.iItem = iSelected;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }
    
    if (FALSE != (iiconStateUnchecked != lvitem.iImage))
    {
        editsndr.dwFlags |= SNDF_MAIL;
    }
    
    // Are we blocking news?
    lvitem.iSubItem = 1;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }
    
    if (FALSE != (iiconStateUnchecked != lvitem.iImage))
    {
        editsndr.dwFlags |= SNDF_NEWS;
    }

    // Create the rules editor
    pEditSenderUI = new CEditSenderUI;
    if (NULL == pEditSenderUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditSenderUI->HrInit(m_hwndDlg, 0, &editsndr)))
    {
        goto exit;
    }

    // Bring up the sender editor UI
    hr = pEditSenderUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    // If the sender changed, make sure we change the label
    if (S_OK == hr)
    {
        // Do we want to remove a copy of the item
        (VOID) _FFindSender(editsndr.pszSender, iSelected, &lItemDelete);
        
        ZeroMemory(&lvitem, sizeof(lvitem));
        lvitem.iItem = iSelected;
        lvitem.mask = LVIF_IMAGE;
        lvitem.iImage = (0 != (editsndr.dwFlags & SNDF_MAIL)) ?
                                    iiconStateChecked : iiconStateUnchecked;

        if (-1 == ListView_SetItem(m_hwndList, &lvitem))
        {
            goto exit;
        }

        lvitem.iSubItem = 1;
        lvitem.iImage = (0 != (editsndr.dwFlags & SNDF_NEWS)) ?
                                    iiconStateChecked : iiconStateUnchecked;
        if (-1 == ListView_SetItem(m_hwndList, &lvitem))
        {
            goto exit;
        }

        ListView_SetItemText(m_hwndList, iSelected, 2, editsndr.pszSender);

        // Make sure we remove the dup item
        if (-1 != lItemDelete)
        {
            // Remove the item from the list
            ListView_DeleteItem(m_hwndList, lItemDelete);
        }
        
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;
        
        cchSender = lstrlen(editsndr.pszSender) + 1;
        if (cchSender > m_cchLabelMax)
        {
            m_cchLabelMax = cchSender;
        }
    }
    
exit:
    SafeMemFree(editsndr.pszSender);
    if (NULL != pEditSenderUI)
    {
        delete pEditSenderUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _RemoveSender
//
//  This removes the selected sender from the senders list
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COESendersRulesPageUI::_RemoveSender(int iSelected)
{
    TCHAR       szRes[CCHMAX_STRINGRES];
    ULONG       cchRes = 0;
    LPSTR       pszSender = NULL;
    LVITEM      lvitem;
    LPSTR       pszMessage = NULL;
    int         cSenders = 0;
    
    Assert(NULL != m_hwndList);
    
    // Get the string template to display
    cchRes = LoadString(g_hLocRes, idsRuleSenderWarnDelete, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    // Allocate space to hold the sender
    if (FAILED(HrAlloc((void **) &pszSender, m_cchLabelMax)))
    {
        goto exit;
    }
    
    // Grab the sender from the list
    ZeroMemory(&lvitem, sizeof(lvitem));
    lvitem.iSubItem = 2;
    lvitem.pszText = pszSender;
    lvitem.cchTextMax = m_cchLabelMax;

    if (0 == SendMessage(m_hwndList, LVM_GETITEMTEXT, (WPARAM) iSelected, (LPARAM) &lvitem))
    {
        goto exit;
    }   
    
    // Allocate space to hold the final display string
    if (FAILED(HrAlloc((void ** ) &pszMessage, cchRes + lstrlen(pszSender) + 1)))
    {
        goto exit;
    }

    // Build up the string and display it
    wsprintf(pszMessage, szRes, pszSender);
    if (IDNO == AthMessageBox(m_hwndDlg, MAKEINTRESOURCE(idsAthenaMail), pszMessage,
                            NULL, MB_YESNO | MB_ICONINFORMATION))
    {
        goto exit;
    }
    
    // Remove the item from the list
    ListView_DeleteItem(m_hwndList, iSelected);

    // Let's make sure we have a selection in the list
    cSenders = ListView_GetItemCount(m_hwndList);
    if (cSenders > 0)
    {
        // Did we delete the last item in the list
        if (iSelected >= cSenders)
        {
            // Move the selection to the new last item in the list
            iSelected = cSenders - 1;
        }

        // Set the new selection
        ListView_SetItemState(m_hwndList, iSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

        // Let's make sure we can see this new item
        ListView_EnsureVisible(m_hwndList, iSelected, FALSE);
    }
    else
    {
        // Make sure we clear out all of the buttons
        _EnableButtons(-1);
    }
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    SafeMemFree(pszSender);
    SafeMemFree(pszMessage);
    return;
}

// Default destructor for the Exceptions List UI
CExceptionsListUI::~CExceptionsListUI()
{
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrInit
//
//  This initializes the Exceptions List UI dialog
//
//  hwndOwner   - the handle to the owner window of this dialog
//  dwFlags     - modifiers on how this dialog should act
//
//  Returns:    S_OK, if it was successfully initialized
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CExceptionsListUI::HrInit(HWND hwndOwner, DWORD dwFlags)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == hwndOwner)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrShow
//
//  This brings up the Exceptions List UI dialog
//
//  Returns:    S_OK, if the sender was successfully entered
//              S_FALSE, if the dialog was canceled
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CExceptionsListUI::HrShow(IOERule * pIRule)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;

    // Check incoming params
    if (NULL == pIRule)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // Save off the item
    m_pIRule = pIRule;
    
    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddExceptionsList),
                                        m_hwndOwner, CExceptionsListUI::FExceptionsListDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

INT_PTR CALLBACK CExceptionsListUI::FExceptionsListDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                fRet = FALSE;
    CExceptionsListUI * pExceptionsUI = NULL;

    pExceptionsUI = (CExceptionsListUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pExceptionsUI = (CExceptionsListUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM) pExceptionsUI);

            if (FALSE == pExceptionsUI->FOnInitDialog(hwndDlg))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We didn't set the focus so return TRUE
            fRet = FALSE;
            break;

        case WM_COMMAND:
            fRet = pExceptionsUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;

        case WM_NOTIFY:
            fRet = pExceptionsUI->FOnNotify((INT) LOWORD(wParam), (NMHDR *) lParam);
            break;
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the Exceptions List UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }

    // If we haven't been initialized yet...
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndList = GetDlgItem(hwndDlg, idlvExceptions);
    if (NULL == m_hwndList)
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize the list view
    fRet = _FInitCtrls();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Load the list view
    fRet = _FLoadListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Set the focus into the list
    SetFocus(m_hwndList);
    
    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the Exceptions List UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    LVITEM  lvitem;
    INT     iSelected = 0;

    // We only handle menu and accelerator commands
    if ((0 != uiNotify) && (1 != uiNotify))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch (iCtl)
    {
        case idcAddException:
            _NewException();
            fRet = TRUE;
            break;

        case idcModifyException:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Bring up the rule editor for that item
                _EditException(iSelected);
                fRet = TRUE;
            }
            break;

        case idcRemoveException:
            // Get the selected item from the rule list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Remove the rule from the list
                _RemoveException(iSelected);
                fRet = TRUE;
            }
            break;
            
        case idcExceptionsWAB:
            // Mark the dialog as dirty
            m_dwState |= STATE_DIRTY;
            break;
            
        case IDOK:
            if (FALSE != _FOnOK())
            {
                EndDialog(m_hwndDlg, IDOK);
                fRet = TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(m_hwndDlg, IDCANCEL);
            fRet = TRUE;
            break;
    }
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnNotify
//
//  This handles the WM_NOTIFY message for the Exceptions List UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::FOnNotify(INT iCtl, NMHDR * pnmhdr)
{
    BOOL            fRet = FALSE;
    NMLISTVIEW *    pnmlv = NULL;
    NMLVKEYDOWN *   pnmlvkd = NULL;
    INT             iSelected = 0;
    LVHITTESTINFO   lvh = {0};

    // We only handle notifications for the list control
    if (idlvExceptions != pnmhdr->idFrom)
    {
        fRet = FALSE;
        goto exit;
    }
    
    pnmlv = (LPNMLISTVIEW) pnmhdr;

    switch (pnmlv->hdr.code)
    {
        case NM_CLICK:
            // Did we click on an item?
            if (-1 == pnmlv->iItem)
            {
                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
          
        case NM_DBLCLK:
            // Did we click on an item?
            if (-1 != pnmlv->iItem)
            {
                ZeroMemory(&lvh, sizeof(lvh));
                lvh.pt = pnmlv->ptAction;
                iSelected = ListView_HitTest(pnmlv->hdr.hwndFrom, &lvh);
                if (-1 != iSelected)
                {
                    // Did we click on the exception name?
                    if (0 != (lvh.flags & LVHT_ONITEMLABEL))
                    {
                        // Edit the rule
                        _EditException(iSelected);
                    }
                }
            }
            else
            {
                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
            
        case LVN_ITEMCHANGED:
            // If an item's state changed to selected..
            if ((-1 != pnmlv->iItem) &&
                        (0 != (pnmlv->uChanged & LVIF_STATE)) &&
                        (0 == (pnmlv->uOldState & LVIS_SELECTED)) &&
                        (0 != (pnmlv->uNewState & LVIS_SELECTED)))
            {
                // Enable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
        case LVN_KEYDOWN:
            pnmlvkd = (NMLVKEYDOWN *) pnmhdr;

            // The delete key removes the rule from the list view
            if (VK_DELETE == pnmlvkd->wVKey)
            {
                // Are we on a rule?
                iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (-1 != iSelected)
                {
                    // Remove the rule from the list
                    _RemoveException(iSelected);
                }
            }
            break;
    }

    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _NewException
//
//  This brings up the edit UI to create a new exception for the Exception List
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID CExceptionsListUI::_NewException(VOID)
{
    HRESULT             hr = S_OK;
    CEditExceptionUI *  pEditExcptUI = NULL;
    EDIT_EXCPT          editexcpt = {0};
    ULONG               ulIndex = 0;

    Assert(NULL != m_hwndList);
    
    // Create the sender editor
    pEditExcptUI = new CEditExceptionUI;
    if (NULL == pEditExcptUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditExcptUI->HrInit(m_hwndDlg, 0, &editexcpt)))
    {
        goto exit;
    }

    // Bring up the sender editor UI
    hr = pEditExcptUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    // If the exception changed, make sure we change the label
    if (S_OK == hr)
    {
        if (FALSE == _FAddExceptionToList(editexcpt.pszExcpt, &ulIndex))
        {
            goto exit;
        }
        
        // Make sure the new item is selected
        ListView_SetItemState(m_hwndList, ulIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        
        // Let's make sure we can see this new item
        ListView_EnsureVisible(m_hwndList, ulIndex, FALSE);
        
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;        
    }
    
exit:
    SafeMemFree(editexcpt.pszExcpt);
    if (NULL != pEditExcptUI)
    {
        delete pEditExcptUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EditException
//
//  This brings up the edit UI for the selected exception from the Execption List
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID CExceptionsListUI::_EditException(int iSelected)
{
    HRESULT             hr = S_OK;
    EDIT_EXCPT          editexcpt = {0};
    LVITEM              lvitem = {0};
    CEditExceptionUI *  pEditExcptUI = NULL;
    ULONG               cchExcpt = 0;
    LONG                lIndex = 0;
    LVFINDINFO          lvfi = {0};

    Assert(NULL != m_hwndList);
    
    // Allocate space to hold the exception
    hr = HrAlloc((void **) &(editexcpt.pszExcpt), m_cchLabelMax);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Grab the exception from the list
    lvitem.pszText = editexcpt.pszExcpt;
    lvitem.cchTextMax = m_cchLabelMax;

    if (0 == SendMessage(m_hwndList, LVM_GETITEMTEXT, (WPARAM) iSelected, (LPARAM) &lvitem))
    {
        goto exit;
    }   
    
    // Create the exception editor
    pEditExcptUI = new CEditExceptionUI;
    if (NULL == pEditExcptUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditExcptUI->HrInit(m_hwndDlg, 0, &editexcpt)))
    {
        goto exit;
    }

    // Bring up the exception editor UI
    hr = pEditExcptUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    // If the exception changed, make sure we change the label
    if (S_OK == hr)
    {
        lvfi.flags = LVFI_STRING;
        lvfi.psz = editexcpt.pszExcpt;
        
        // Check to see if the item already exists
        lIndex = ListView_FindItem(m_hwndList, -1, &lvfi);
        
        // If the item already exists 
        if ((-1 != lIndex) && (iSelected != lIndex))
        {
            // Make sure the duplicate item is selected
            ListView_SetItemState(m_hwndList, lIndex,
                    LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

            // Let's make sure we can see this new item
            ListView_EnsureVisible(m_hwndList, lIndex, FALSE);
            
            // Remove the item from the list
            ListView_DeleteItem(m_hwndList, iSelected);
        }
        else
        {
            ListView_SetItemText(m_hwndList, iSelected, 0, editexcpt.pszExcpt);
            
            cchExcpt = lstrlen(editexcpt.pszExcpt) + 1;
            if (cchExcpt > m_cchLabelMax)
            {
                m_cchLabelMax = cchExcpt;
            }
        }
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;
        
    }
    
exit:
    SafeMemFree(editexcpt.pszExcpt);
    if (NULL != pEditExcptUI)
    {
        delete pEditExcptUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _RemoveException
//
//  This removes the selected exception from the Exception List
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID CExceptionsListUI::_RemoveException(int iSelected)
{
    TCHAR       szRes[CCHMAX_STRINGRES];
    ULONG       cchRes = 0;
    LPSTR       pszExcpt = NULL;
    LVITEM      lvitem = {0};
    LPSTR       pszMessage = NULL;
    int         cExcpts = 0;
    
    Assert(NULL != m_hwndList);
    
    // Get the string template to display
    cchRes = LoadString(g_hLocRes, idsRuleExcptWarnDelete, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    // Allocate space to hold the execptions
    if (FAILED(HrAlloc((void **) &pszExcpt, m_cchLabelMax)))
    {
        goto exit;
    }
    
    // Grab the exception from the list
    lvitem.pszText = pszExcpt;
    lvitem.cchTextMax = m_cchLabelMax;

    if (0 == SendMessage(m_hwndList, LVM_GETITEMTEXT, (WPARAM) iSelected, (LPARAM) &lvitem))
    {
        goto exit;
    }   
    
    // Allocate space to hold the final display string
    if (FAILED(HrAlloc((void ** ) &pszMessage, cchRes + lstrlen(pszExcpt) + 1)))
    {
        goto exit;
    }

    // Build up the string and display it
    wsprintf(pszMessage, szRes, pszExcpt);
    if (IDNO == AthMessageBox(m_hwndDlg, MAKEINTRESOURCE(idsAthenaMail), pszMessage,
                            NULL, MB_YESNO | MB_ICONINFORMATION))
    {
        goto exit;
    }
    
    // Remove the item from the list
    ListView_DeleteItem(m_hwndList, iSelected);

    // Let's make sure we have a selection in the list
    cExcpts = ListView_GetItemCount(m_hwndList);
    if (cExcpts > 0)
    {
        // Did we delete the last item in the list
        if (iSelected >= cExcpts)
        {
            // Move the selection to the new last item in the list
            iSelected = cExcpts - 1;
        }

        // Set the new selection
        ListView_SetItemState(m_hwndList, iSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

        // Let's make sure we can see this new item
        ListView_EnsureVisible(m_hwndList, iSelected, FALSE);
    }
    else
    {
        // Make sure we clear out all of the buttons
        _EnableButtons(-1);
    }
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    SafeMemFree(pszExcpt);
    SafeMemFree(pszMessage);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnOK
//
//  This initializes the controls in the Exceptions List UI dialog
//
//  Returns:    TRUE, on successful initialization
//              FALSE, otherwise.
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::_FOnOK(VOID)
{
    BOOL        fRet = FALSE;
    BOOL        fWABEnable = FALSE;
    PROPVARIANT propvar = {0};

    // Save of the list of addresses
    if (FALSE == _FSaveListCtrl())
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Are we supposed to check the WAB?
    fWABEnable = !!(BST_CHECKED == Button_GetCheck(GetDlgItem(m_hwndDlg, idcExceptionsWAB)));

    // Save of the state of the Check WAB button
    propvar.vt = VT_BOOL;
    propvar.boolVal = (VARIANT_BOOL) !!fWABEnable;
    if (FAILED(m_pIRule->SetProp(RULE_PROP_EXCPT_WAB, 0, &propvar)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Everything's fine
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInitCtrls
//
//  This initializes the controls in the Exceptions List UI dialog
//
//  Returns:    TRUE, on successful initialization
//              FALSE, otherwise.
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::_FInitCtrls(VOID)
{
    BOOL        fRet = FALSE;
    LVCOLUMN    lvc = {0};
    RECT        rc = {0};
    PROPVARIANT propvar = {0};
    
    Assert(NULL != m_hwndList);
    
    if (FAILED(m_pIRule->GetProp(RULE_PROP_EXCPT_WAB, 0, &propvar)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the Check WAB button
    Button_SetCheck(GetDlgItem(m_hwndDlg, idcExceptionsWAB),
                (FALSE != propvar.boolVal) ? BST_CHECKED : BST_UNCHECKED);
                
    // Initialize the list view structure
    lvc.mask = LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;

    // Calculate the size of the list view
    GetClientRect(m_hwndList, &rc);
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    // Add the column to the list view
    ListView_InsertColumn(m_hwndList, 0, &lvc);

    // Full row selection  and subitem images on listview
    ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT);

    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadListCtrl
//
//  This loads the list view with the current exceptions
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::_FLoadListCtrl(VOID)
{
    BOOL                fRet = FALSE;
    ULONG               ulIndex = 0;
    IOERuleAddrList *   pIAddrList = NULL;
    RULEADDRLIST *      pralList = NULL;
    ULONG               cralList = 0;

    Assert(NULL != m_hwndList);

    // Remove all the items from the list control
    ListView_DeleteAllItems(m_hwndList);

    // Get the exceptions list from the rule
    if (FAILED(m_pIRule->QueryInterface(IID_IOERuleAddrList, (VOID **) &pIAddrList)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the list of exceptions from the address list
    if (FAILED(pIAddrList->GetList(0, &pralList, &cralList)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Add each item into the list
    for (ulIndex = 0; ulIndex < cralList; ulIndex++)
    {
        // Verify the item
        if (RALF_MAIL != pralList[ulIndex].dwFlags)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Add the item
        if (FALSE == _FAddExceptionToList(pralList[ulIndex].pszAddr, NULL))
        {
            fRet = FALSE;
            goto exit;
        }
    }
    
    // Select the first item in the list
    if (0 != cralList)
    {
        ListView_SetItemState(m_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
    
    // Enable the dialog buttons.
    _EnableButtons((0 != cralList) ? 0 : -1);

    fRet = TRUE;
    
exit:
    FreeRuleAddrList(pralList, cralList);
    SafeMemFree(pralList);
    SafeRelease(pIAddrList);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSaveListCtrl
//
//  This save the exceptions from the list view
//
//  Returns:    TRUE, if it was successfully saved
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::_FSaveListCtrl(VOID)
{
    BOOL                fRet = FALSE;
    ULONG               cExcpts = 0;
    LPSTR               pszAddr = NULL;
    RULEADDRLIST *      pralList = NULL;
    ULONG               ulIndex = 0;
    IOERuleAddrList *   pIAddrList = NULL;

    Assert(NULL != m_hwndList);

    // Figure out how many exceptions are in the list
    cExcpts = ListView_GetItemCount(m_hwndList);

    // If there are exceptions
    if (0 != cExcpts)
    {
        // Allocate space to hold the exceptions
        if (FAILED(HrAlloc((VOID **) &pszAddr, (m_cchLabelMax + 1))))
        {
            fRet = FALSE;
            goto exit;
        }

        // Initialize the exception buffer
        pszAddr[0] = '\0';
        
        // Allocate space to hold the exception list
        if (FAILED(HrAlloc((VOID **) &pralList, cExcpts * sizeof(*pralList))))
        {
            fRet = FALSE;
            goto exit;
        }

        // Initialize the list of exceptions
        ZeroMemory(pralList, cExcpts * sizeof(*pralList));
        
        // Save each exception from the list
        for (ulIndex = 0; ulIndex < cExcpts; ulIndex++)
        {
            // Get the item from the list
            pszAddr[0] = '\0';
            ListView_GetItemText(m_hwndList, ulIndex, 0, pszAddr, m_cchLabelMax + 1);
            
            // Verify it isn't empty
            if ('\0' == pszAddr[0])
            {
                fRet = FALSE;
                goto exit;
            }
            
            // Set the flags
            pralList[ulIndex].dwFlags = RALF_MAIL;

            // Save the item
            pralList[ulIndex].pszAddr = PszDupA(pszAddr);
            if (NULL == pralList[ulIndex].pszAddr)
            {
                fRet = FALSE;
                goto exit;
            }
        }
    }
    
    // Get the exceptions list from the rule
    if (FAILED(m_pIRule->QueryInterface(IID_IOERuleAddrList, (VOID **) &pIAddrList)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the list of exceptions from the address list
    if (FAILED(pIAddrList->SetList(0, pralList, cExcpts)))
    {
        fRet = FALSE;
        goto exit;
    }
        
    // Set the proper return value
    fRet = TRUE;
    
exit:
    SafeRelease(pIAddrList);
    FreeRuleAddrList(pralList, cExcpts);
    SafeMemFree(pralList);
    SafeMemFree(pszAddr);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddExceptionToList
//
//  This adds the exception passed in to the list view
//
//  pszExcpt    - the actual exception
//  pulIndex    - the index where the item was added
//
//  Returns:    TRUE, if it was successfully added
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL CExceptionsListUI::_FAddExceptionToList(LPSTR pszExcpt, ULONG * pulIndex)
{
    BOOL        fRet = FALSE;
    ULONG       cExcpts = 0;
    LPSTR       pszLabel = NULL;
    ULONG       ulIndex = 0;
    LVITEM      lvitem = {0};
    ULONG       cchExcpt = 0;

    Assert(NULL != m_hwndList);

    // If there's nothing to do...
    if (NULL == pszExcpt)
    {
        fRet = FALSE;
        goto exit;
    }

    // Initialize the outgoing param
    if (NULL != pulIndex)
    {
        *pulIndex = 0;
    }
    
    cExcpts = ListView_GetItemCount(m_hwndList);

    // Figure out the maximum size of the buffer needed get the string
    if (0 != cExcpts)
    {
        if (FAILED(HrAlloc((void **) &pszLabel, m_cchLabelMax * sizeof(*pszLabel))))
        {
            fRet = FALSE;
            goto exit;
        }
        
        // See if the exception is already in the list
        lvitem.pszText = pszLabel;
        lvitem.cchTextMax = m_cchLabelMax;

        for (ulIndex = 0; ulIndex < cExcpts; ulIndex++)
        {
            if (0 != SendMessage(m_hwndList, LVM_GETITEMTEXT, (WPARAM) ulIndex, (LPARAM) &lvitem))
            {
                if (0 == lstrcmpi(pszLabel, pszExcpt))
                {
                    break;
                }
            }
        }
    }
    
    // Insert it if we didn't find it
    if (ulIndex == cExcpts)
    {
        ZeroMemory(&lvitem, sizeof(lvitem));
        lvitem.mask = LVIF_TEXT;
        lvitem.iItem = ulIndex;
        lvitem.pszText = pszExcpt;
        
        ulIndex = ListView_InsertItem(m_hwndList, &lvitem);
        if (-1 == ulIndex)
        {
            fRet = FALSE;
            goto exit;
        }

        // Figure out the new maximum
        cchExcpt = lstrlen(pszExcpt) + 1;
        if (cchExcpt > m_cchLabelMax)
        {
            m_cchLabelMax = cchExcpt;
        }
    }

    // Set the outgoing param
    if (NULL != pulIndex)
    {
        *pulIndex = ulIndex;
    }
    
    // Set the proper return value
    fRet = TRUE;
    
exit:
    SafeMemFree(pszLabel);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableButtons
//
//  This enables or disables the buttons in the Exceptions List UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void CExceptionsListUI::_EnableButtons(INT iSelected)
{
    int         cExcpts = 0;
    BOOL        fSelected = FALSE;

    Assert(NULL != m_hwndList);

    fSelected = (-1 != iSelected);
    
    // Enable the senders action buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcRemoveException, fSelected);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idcModifyException, fSelected);
        
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\spamui.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  SpamUI.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"
#include "rulesui.h"
#include "addrrule.h"

enum SENDER_FLAGS
{
    SNDF_NONE   = 0x00000000,
    SNDF_MAIL   = 0x00000001,
    SNDF_NEWS   = 0x00000002
};

enum EXCPTLIST_FLAGS
{
    ELF_NONE    = 0x00000000,
    ELF_WAB     = 0x00000001
};

// Type definitions
typedef struct tagCOLUMNITEM
{
    UINT            uidsName;
    UINT            uiWidth;
} COLUMNITEM, * PCLOUMNITEM;

typedef struct tagEDIT_SENDER
{
    DWORD       dwFlags;
    LONG        lSelected;
    LPSTR       pszSender;
} EDIT_SENDER, * PEDIT_SENDER;

// Class definitions
class CEditSenderUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_DIRTY         = 0x00000002
        };

    private:
        HWND            m_hwndOwner;
        DWORD           m_dwFlags;
        DWORD           m_dwState;
        HWND            m_hwndDlg;
        HWND            m_hwndSender;

        EDIT_SENDER *   m_pEditSender;

    public:
        CEditSenderUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
                        m_hwndDlg(NULL), m_hwndSender(NULL), m_pEditSender(NULL) {}
        ~CEditSenderUI();

        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags, EDIT_SENDER * pEditSender);
        HRESULT HrShow(VOID);

        static INT_PTR CALLBACK FEditSendersDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
};

class CExceptionsListUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_DIRTY         = 0x00000002
        };

    private:
        HWND            m_hwndOwner;
        DWORD           m_dwFlags;
        DWORD           m_dwState;
        HWND            m_hwndDlg;
        HWND            m_hwndList;
        ULONG           m_cchLabelMax;
        IOERule *       m_pIRule;

    public:
        CExceptionsListUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
                        m_hwndList(NULL), m_hwndDlg(NULL), m_cchLabelMax(0), 
                        m_pIRule(NULL) {}
        ~CExceptionsListUI();

        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
        HRESULT HrShow(IOERule * pIRule);

        static INT_PTR CALLBACK FExceptionsListDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnNotify(INT iCtl, NMHDR * pnmhdr);

    private:
        // Functions to deal with the basic actions
        VOID _NewException(VOID);
        VOID _EditException(INT iSelected);
        VOID _RemoveException(INT iSelected);
        BOOL _FOnOK(VOID);

        // Utility functions
        BOOL _FInitCtrls(VOID);
        BOOL _FLoadListCtrl(VOID);
        BOOL _FSaveListCtrl(VOID);
        BOOL _FAddExceptionToList(LPSTR pszExcpt, ULONG * pulIndex);
        void _EnableButtons(INT iSelected);        
};

class COEJunkRulesPageUI : public COERulesPageUI
{
    private:
        enum
        {
            STATE_CTRL_INIT     = 0x00000010
        };
    
        enum {
            ID_JUNK_SCALE = 0,
            ID_JUNK_DELETE,
            ID_MAX
        };
        
    private:
        HWND                m_hwndOwner;
        HWND                m_hwndDlg;
        HIMAGELIST          m_himl;
        CExceptionsListUI * m_pExceptionsUI;
        IOERule *           m_pIRuleJunk;
        
    public:
        COEJunkRulesPageUI() : COERulesPageUI(iddRulesJunk, idsRulesJunk, 0, 0), m_hwndOwner(NULL),
                    m_hwndDlg(NULL), m_himl(NULL), m_pExceptionsUI(NULL), m_pIRuleJunk(NULL) {}
        virtual ~COEJunkRulesPageUI();

        virtual HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
        virtual HRESULT HrCommitChanges(DWORD dwFlags, BOOL fClearDirty);

        static INT_PTR CALLBACK FJunkRulesPageDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);

        DLGPROC DlgProcGetPageDlgProc(VOID) {return FJunkRulesPageDlgProc;}
        BOOL FGetRules(RULE_TYPE typeRule, RULENODE ** pprnode);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnNotify(INT iCtl, NMHDR * pnmhdr);
        BOOL FOnHScroll(INT iScrollCode, short int iPos, HWND hwndCtl);
        BOOL FOnDestroy(VOID) {return FALSE;}

    private:
        BOOL _FInitCtrls(VOID);
        BOOL _FLoadJunkSettings();
        BOOL _FSaveJunkSettings();
        VOID _EnableButtons(VOID);
};

class COESendersRulesPageUI : public COERulesPageUI
{
    private:
        enum BLOCK_TYPE
        {
            BLOCK_NONE  = 0x00000000,
            BLOCK_MAIL  = 0x00000001,
            BLOCK_NEWS  = 0x00000002
        };
        
    private:
        HWND                    m_hwndOwner;
        HWND                    m_hwndDlg;
        HWND                    m_hwndList;
        IOERule *               m_pIRuleMail;
        IOERule *               m_pIRuleNews;
        ULONG                   m_cchLabelMax;

        static const COLUMNITEM m_rgcitem[];
        static const UINT       m_crgcitem;
        
    public:
        COESendersRulesPageUI() : COERulesPageUI(iddRulesSenders, idsRulesSenders, 0, 0),
                                    m_hwndOwner(NULL), m_hwndDlg(NULL), m_hwndList(NULL),
                                    m_pIRuleMail(NULL), m_pIRuleNews(NULL), m_cchLabelMax(0) {};
        virtual ~COESendersRulesPageUI();

        virtual HRESULT HrInit(HWND hwndOwner, DWORD dwFlags);
        virtual HRESULT HrCommitChanges(DWORD dwFlags, BOOL fClearDirty);

        static INT_PTR CALLBACK FSendersRulesPageDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);

        DLGPROC DlgProcGetPageDlgProc(VOID) {return FSendersRulesPageDlgProc;}
        BOOL FGetRules(RULE_TYPE typeRule, RULENODE ** pprnode);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnNotify(INT iCtl, NMHDR * pnmhdr);
        BOOL FOnDestroy(VOID) {return FALSE;}
        BOOL FFindItem(LPCSTR pszFind, LONG lSkip);

    private:
        BOOL _FInitListCtrl(VOID);
        BOOL _FLoadListCtrl(VOID);

        BOOL _FAddSenderToList(RULE_TYPE type, LPSTR pszSender);
        void _EnableButtons(INT iSelected);
        void _EnableSender(RULE_TYPE type, INT iSelected);
        BOOL _FLoadSenders(RULE_TYPE type, IOERule * pIRule);
        BOOL _FSaveSenders(RULE_TYPE type);
        BOOL _FFindSender(LPCSTR pszSender, LONG lSkip, LONG * plSender);
        
        // Functions to deal with the basic actions
        VOID _NewSender(VOID);
        VOID _EditSender(INT iSelected);
        VOID _RemoveSender(INT iSelected);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\viewsui.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  ViewsUI.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#pragma once

#include "oerules.h"
#include "ruledesc.h"

// Views Manager UI Class
class COEViewsMgrUI
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001,
            STATE_DIRTY         = 0x00000002
        };
        
    private:
        HWND                m_hwndOwner;
        DWORD               m_dwFlags;
        DWORD               m_dwState;
        HWND                m_hwndDlg;
        HWND                m_hwndList;
        HWND                m_hwndDescript;
        CRuleDescriptUI *   m_pDescriptUI;
        RULEID *            m_pridRule;
        IOERule *           m_pIRuleDownloaded;
        BOOL                m_fApplyAll;
        
    public:
        // Constructor/destructor
        COEViewsMgrUI();
        ~COEViewsMgrUI();

        // Main UI methods
        HRESULT HrInit(HWND hwndOwner, DWORD dwFlags, RULEID * pridRule);
        HRESULT HrShow(BOOL * pfApplyAll);
        
        // Dialog methods
        static INT_PTR CALLBACK FOEViewMgrDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
        
        // Message handling methods
        BOOL FOnInitDialog(HWND hwndDlg);
        BOOL FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl);
        BOOL FOnNotify(INT iCtl, NMHDR * pnmhdr);
        BOOL FOnDestroy(VOID);
        
    private:
        BOOL _FInitListCtrl(VOID);
        BOOL _FLoadListCtrl(VOID);
        BOOL _FAddViewToList(DWORD dwIndex, RULEID ridRule, IOERule * pIRule, BOOL fSelect);
        VOID _EnableButtons(INT iSelected);
        VOID _EnableView(INT iSelected);

        // For dealing with the description field
        VOID _LoadView(INT iSelected);
        BOOL _FSaveView(INT iSelected);

        // Functions to deal with the basic actions
        VOID _NewView(VOID);
        VOID _EditView(INT iSelected);
        VOID _RemoveView(INT iSelected);
        VOID _CopyView(INT iSelected);
        VOID _DefaultView(INT iSelected);
        BOOL _FOnOK(VOID);
        BOOL _FOnCancel(VOID);
        BOOL _FGetDefaultItem(IOERule ** ppIRuleDefault, RULEID * pridDefault);
        BOOL _FOnLabelEdit(BOOL fBegin, NMLVDISPINFO * pdi);
};

BOOL FIsFilterReadOnly(RULEID ridFilter);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\rules\viewsui.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  ViewsUI.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "viewsui.h"
#include "editrule.h"
#include "ruledesc.h"
#include "ruleutil.h"
#include "rulesmgr.h"
#include "rule.h"
#include "reutil.h"
#include "shlwapip.h" 
#include <rulesdlg.h>
#include <imagelst.h>
#include <demand.h>

INT_PTR CALLBACK FSelectApplyViewDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Global data
const static HELPMAP g_rgCtxMapViewsMgr[] = {
                        {idbNewView,            idhNewView},
                        {idbModifyView,         idhModifyView},
                        {idbCopyView,           idhCopyView},
                        {idbDeleteView,         idhRemoveView},
                        {idbDefaultView,        idhApplyView},
                        {idredtViewDescription, idhViewDescription},
                        {0, 0}};
                       
COEViewsMgrUI::COEViewsMgrUI() : m_hwndOwner(NULL), m_dwFlags(0), m_dwState(STATE_UNINIT),
                                m_hwndDlg(NULL), m_hwndList(NULL), m_hwndDescript(NULL),
                                m_pDescriptUI(NULL), m_pridRule(NULL), m_pIRuleDownloaded(NULL),
                                m_fApplyAll(FALSE)
{
}

COEViewsMgrUI::~COEViewsMgrUI()
{
    if (NULL != m_pDescriptUI)
    {
        delete m_pDescriptUI;
    }
    SafeRelease(m_pIRuleDownloaded);
}

HRESULT COEViewsMgrUI::HrInit(HWND hwndOwner, DWORD dwFlags, RULEID * pridRule)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == hwndOwner)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 != (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    m_hwndOwner = hwndOwner;

    m_dwFlags = dwFlags;

    m_pridRule = pridRule;
    
    // Setup the description field
    m_pDescriptUI = new CRuleDescriptUI;
    if (NULL == m_pDescriptUI)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    m_dwState |= STATE_INITIALIZED;
    
    hr = S_OK;
    
exit:
    return hr;
}

HRESULT COEViewsMgrUI::HrShow(BOOL * pfApplyAll)
{
    HRESULT     hr = S_OK;
    int         iRet = 0;

    if (NULL == pfApplyAll)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    *pfApplyAll = FALSE;
    
    // We need to load richedit
    if (FALSE == FInitRichEdit(TRUE))
    {
        hr = E_FAIL;
        goto exit;
    }

    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddViewsManager),
                                        m_hwndOwner, COEViewsMgrUI::FOEViewMgrDlgProc,
                                        (LPARAM) this);
    if (-1 == iRet)
    {
        hr = E_FAIL;
        goto exit;
    }

    *pfApplyAll = m_fApplyAll;
    
    // Set the proper return code
    hr = (IDOK == iRet) ? S_OK : S_FALSE;
    
exit:
    return hr;
}

INT_PTR CALLBACK COEViewsMgrUI::FOEViewMgrDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    fRet = FALSE;
    COEViewsMgrUI *         pViewsUI = NULL;
    HWND                    hwndRE = 0;

    pViewsUI = (COEViewsMgrUI *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Grab the UI object pointer
            pViewsUI = (COEViewsMgrUI *) lParam;

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pViewsUI);

            hwndRE = CreateREInDialogA(hwndDlg, idredtViewDescription);

            if (!hwndRE || (FALSE == pViewsUI->FOnInitDialog(hwndDlg)))
            {
                EndDialog(hwndDlg, -1);
                fRet = TRUE;
                goto exit;
            }
            
            // We set the focus
            fRet = TRUE;
            break;

        case WM_COMMAND:
            fRet = pViewsUI->FOnCommand((UINT) HIWORD(wParam), (INT) LOWORD(wParam), (HWND) lParam);
            break;

        case WM_NOTIFY:
            fRet = pViewsUI->FOnNotify((INT) LOWORD(wParam), (NMHDR *) lParam);
            break;

        case WM_DESTROY:
            fRet = pViewsUI->FOnDestroy();
            break;   
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            fRet = OnContextHelp(hwndDlg, uiMsg, wParam, lParam, g_rgCtxMapViewsMgr);
            break;
    }
    
    exit:
        return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnInitDialog
//
//  This handles the WM_INITDIALOG message for the view manager UI dialog
//
//  hwndDlg - the handle to the dialog window
//
//  Returns:    TRUE, if it was successfully initialized
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::FOnInitDialog(HWND hwndDlg)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    
    // Check incoming params
    if (NULL == hwndDlg)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Save off the dialog window handle
    m_hwndDlg = hwndDlg;
    
    // Set the default font onto the dialog
    SetIntlFont(m_hwndDlg);

    // Save off some of the controls
    m_hwndList = GetDlgItem(hwndDlg, idlvViewsList);
    m_hwndDescript = GetDlgItem(hwndDlg, idredtViewDescription);
    if ((NULL == m_hwndList) || (NULL == m_hwndDescript))
    {
        fRet = FALSE;
        goto exit;
    }
    
    if (FAILED(m_pDescriptUI->HrInit(m_hwndDescript, 0)))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Initialize the list view
    fRet = _FInitListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }

    // Load the list view
    fRet = _FLoadListCtrl();
    if (FALSE == fRet)
    {
        goto exit;
    }
    
    // Everything's AOK
    fRet = TRUE;
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnCommand
//
//  This handles the WM_COMMAND message for the view manager UI dialog
//
//  Returns:    TRUE, if it was successfully handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::FOnCommand(UINT uiNotify, INT iCtl, HWND hwndCtl)
{
    BOOL    fRet = FALSE;
    INT     iSelected = 0;

    // We only handle menu and accelerator commands
    if ((0 != uiNotify) && (1 != uiNotify))
    {
        fRet = FALSE;
        goto exit;
    }
    
    switch (iCtl)
    {
        case IDOK:
            if (FALSE != _FOnOK())
            {
                EndDialog(m_hwndDlg, IDOK);
                fRet = TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(m_hwndDlg, IDCANCEL);
            fRet = TRUE;
            break;
            
        case idbNewView:
            _NewView();
            fRet = TRUE;
            break;

        case idbModifyView:
            // Get the selected item from the view list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Bring up the view editor for that item
                _EditView(iSelected);
                fRet = TRUE;
            }
            break;

        case idbDeleteView:
            // Get the selected item from the view list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Remove the rule from the list
                _RemoveView(iSelected);
                fRet = TRUE;
            }
            break;
            
        case idbDefaultView:
            // Get the selected item from the view list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Remove the rule from the list
                _DefaultView(iSelected);
                fRet = TRUE;
            }
            break;
            
        case idbCopyView:
            // Get the selected item from the view list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Remove the rule from the list
                _CopyView(iSelected);
                fRet = TRUE;
            }
            break;

        case idbRenameView:
            // Get the selected item from the view list
            iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if (-1 != iSelected)
            {
                // Set the focus in the list view
                SetFocus(m_hwndList);
                
                // Edit the view label in the list
                fRet = (NULL != ListView_EditLabel(m_hwndList, iSelected));
            }
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnNotify
//
//  This handles the WM_NOTIFY message for the view manager UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::FOnNotify(INT iCtl, NMHDR * pnmhdr)
{
    BOOL            fRet = FALSE;
    NMLISTVIEW *    pnmlv = NULL;
    NMLVKEYDOWN *   pnmlvkd = NULL;
    INT             iSelected = 0;
    LVHITTESTINFO   lvh = {0};

    // We only handle notifications for the list control
    // or the desscription field
    if ((idlvViewsList != pnmhdr->idFrom) && (idredtViewDescription != pnmhdr->idFrom))
    {
        fRet = FALSE;
        goto exit;
    }
    
    pnmlv = (LPNMLISTVIEW) pnmhdr;

    switch (pnmlv->hdr.code)
    {
        case NM_CLICK:
            // Did we click on an item?
            if (-1 == pnmlv->iItem)
            {
                // We clicked outside the list

                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            else
            {
                lvh.pt = pnmlv->ptAction;
                iSelected = ListView_HitTest(m_hwndList, &lvh);
                if (-1 != iSelected)
                {
                    // Did we click on the enable field?
                    if ((0 != (lvh.flags & LVHT_ONITEMSTATEICON)) &&
                            (0 == (lvh.flags & LVHT_ONITEMLABEL)))
                    
                    {
                        // Make sure this item is selected
                        ListView_SetItemState(m_hwndList, iSelected,
                                        LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                        
                        // Set the proper enable state                        
                        _EnableView(iSelected);
                    }
                }
            }
            break;
          
        case NM_DBLCLK:
            // Did we click on an item?
            if (-1 != pnmlv->iItem)
            {
                lvh.pt = pnmlv->ptAction;
                iSelected = ListView_HitTest(pnmlv->hdr.hwndFrom, &lvh);
                if (-1 != iSelected)
                {
                    // Did we click on the rule name?
                    if (0 != (lvh.flags & LVHT_ONITEMLABEL))
                    {
                        // Edit the rule
                        _EditView(iSelected);
                    }
                }
            }
            else
            {
                // We clicked outside the list
                
                // Disable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
        case LVN_ITEMCHANGED:
            // If an item's state changed to selected..
            if ((-1 != pnmlv->iItem) &&
                        (0 != (pnmlv->uChanged & LVIF_STATE)) &&
                        (0 == (pnmlv->uOldState & LVIS_SELECTED)) &&
                        (0 != (pnmlv->uNewState & LVIS_SELECTED)))
            {
                // Enable the buttons
                _EnableButtons(pnmlv->iItem);
            }
            break;
            
        case LVN_ITEMCHANGING:
            // If an item's state changed to unselected..
            if ((-1 != pnmlv->iItem) &&
                        (0 != (pnmlv->uChanged & LVIF_STATE)) &&
                        (0 != (pnmlv->uOldState & LVIS_SELECTED)) &&
                        (0 == (pnmlv->uNewState & LVIS_SELECTED)))
            {
                // Save off the rule changes
                _FSaveView(pnmlv->iItem);
            }
            break;
            
        case LVN_KEYDOWN:
            pnmlvkd = (NMLVKEYDOWN *) pnmhdr;

            // The space key changes the enable state of a rule
            if (VK_SPACE == pnmlvkd->wVKey)
            {
                // Are we on a rule?
                iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (-1 != iSelected)
                {
                    // Change the enable state of the rule
                    _EnableView(iSelected);
                }
            }
            // The delete key removes the rule from the list view
            else if (VK_DELETE == pnmlvkd->wVKey)
            {
                // Are we on a rule?
                iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (-1 != iSelected)
                {
                    // Remove the rule from the list
                    _RemoveView(iSelected);
                }
            }
            break;
            
        case LVN_BEGINLABELEDIT:
        case LVN_ENDLABELEDIT:
            fRet = _FOnLabelEdit((LVN_BEGINLABELEDIT == pnmlv->hdr.code), (NMLVDISPINFO *) pnmhdr);
            break;
    }

exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FOnDestroy
//
//  This handles the WM_DESTROY message for the view manager UI dialog
//
//  Returns:    TRUE, if it was successfully destroyed
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::FOnDestroy(VOID)
{
    BOOL        fRet = FALSE;
    UINT        cRules = 0;
    UINT        uiIndex = 0;
    LVITEM      lvitem = {0};
    RULEINFO *  pIRuleInfo = NULL;

    Assert(m_hwndList);
    
    // Get the number of views in the list view
    cRules = ListView_GetItemCount(m_hwndList);

    // Initialize to get the rule interface from the list view
    lvitem.mask = LVIF_PARAM;

    // Release each of the views from the list view
    for (uiIndex = 0; uiIndex < cRules; uiIndex++)
    {
        lvitem.iItem = uiIndex;
        
        // Get the rule interface
        if (FALSE != ListView_GetItem(m_hwndList, &lvitem))
        {
            pIRuleInfo = (RULEINFO *) (lvitem.lParam);

            if (NULL != pIRuleInfo)
            {
                // Release the view
                if (NULL != pIRuleInfo->pIRule)
                {
                    pIRuleInfo->pIRule->Release();
                }
                delete pIRuleInfo; // MemFree(pIRuleInfo);
            }
        }
    }

    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnOK
//
//  This commits the changes to the rules
//
//  dwFlags     - modifiers on how we should commit the changes
//  fClearDirty - should we clear the dirty state
//
//  Returns:    S_OK, if it was successfully committed
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::_FOnOK(VOID)
{
    BOOL        fRet = FALSE;
    HRESULT     hr = S_OK;
    LONG        cViews = 0;
    INT         iSelected = 0;
    RULEINFO *  pinfoRule = NULL;
    ULONG       cpinfoRule = 0;
    LVITEM      lvitem = {0};
    IOERule *   pIRuleDefault = NULL;
    ULONG       ulIndex = 0;
    ULONG       cViewsTotal = 0;

    Assert(NULL != m_hwndList);
    
    // Fail if we weren't initialized
    if (0 == (m_dwState & STATE_INITIALIZED))
    {
        fRet = FALSE;
        goto exit;
    }

    // If we aren't dirty, then there's
    // nothing to do
    if ((0 == (m_dwState & STATE_DIRTY)) && (S_OK != m_pDescriptUI->HrIsDirty()))
    {
        fRet = TRUE;
        goto exit;
    }

    // Let's make sure the selected rule is saved...
    iSelected = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
    if (-1 != iSelected)
    {
        _FSaveView(iSelected);
    }

    // Get the number of rules in the list view
    cViews = ListView_GetItemCount(m_hwndList);

    cViewsTotal = cViews;

    if (NULL != m_pIRuleDownloaded)
    {
        cViewsTotal++;
    }

    if (0 != cViewsTotal)
    {
        // Allocate space to hold the rules        
        hr = HrAlloc( (void **) &pinfoRule, cViewsTotal * sizeof(*pinfoRule));
        if (FAILED(hr))
        {
            fRet = FALSE;
            goto exit;
        }

        ZeroMemory(pinfoRule, cViewsTotal * sizeof(*pinfoRule));

        if (0 != cViews)
        {
            lvitem.mask = LVIF_PARAM;
            
            cpinfoRule = 0;
            for (lvitem.iItem = 0; lvitem.iItem < cViews; lvitem.iItem++)
            {
                // Grab the rule from the list view
                if (FALSE != ListView_GetItem(m_hwndList, &lvitem))
                {
                    pinfoRule[cpinfoRule] = *((RULEINFO *) (lvitem.lParam));
                    cpinfoRule++;
                }   
            }
        }

        if (NULL != m_pIRuleDownloaded)
        {
            pinfoRule[cpinfoRule].ridRule = RULEID_VIEW_DOWNLOADED;
            pinfoRule[cpinfoRule].pIRule = m_pIRuleDownloaded;
            cpinfoRule++;
        }
    }
    
    // Set the rules into the rules manager
    hr = g_pRulesMan->SetRules(SETF_CLEAR, RULE_TYPE_FILTER, pinfoRule, cpinfoRule);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the default item
    if (0 != cViews)
    {
        // Get the current default item
        if (FALSE != _FGetDefaultItem(&pIRuleDefault, NULL))
        {
            // Search for it in the list of rules
            for (ulIndex = 0; ulIndex < cpinfoRule; ulIndex++)
            {
                if (pIRuleDefault == pinfoRule[ulIndex].pIRule)
                {
                    *m_pridRule = pinfoRule[ulIndex].ridRule;
                    break;
                }
            }
        }
    }
    
    // Clear the dirty state
    m_dwState &= ~STATE_DIRTY;
    
    fRet = TRUE;
    
exit:
    delete pinfoRule; //SafeMemFree(pinfoRule);
    return fRet;
}

BOOL COEViewsMgrUI::_FOnCancel(VOID)
{
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FInitListCtrl
//
//  This initializes the list view control in the view manager UI dialog
//
//  Returns:    TRUE, on successful initialization
//              FALSE, otherwise.
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::_FInitListCtrl(VOID)
{
    BOOL        fRet = FALSE;
    LVCOLUMN    lvc = {0};
    RECT        rc = {0};
    HIMAGELIST  himl = NULL;
    TCHAR       szRes[CCHMAX_STRINGRES + 5];

    Assert(NULL != m_hwndList);
    
    // Initialize the list view structure
    lvc.mask = LVCF_WIDTH | LVCF_TEXT;

    // Calculate the size of the list view
    GetClientRect(m_hwndList, &rc);
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    // Load the string for the column
    lvc.pszText = szRes;
    lvc.cchTextMax = ARRAYSIZE(szRes);
    if (0  == LoadString(g_hLocRes, idsNameCol, szRes, ARRAYSIZE(szRes)))
    {
        szRes[0] = '\0';
    }
    
    ListView_InsertColumn(m_hwndList, 0, &lvc);
    
    // Set the state image list
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idb16x16st), 16, 0, RGB(255, 0, 255));
    if (NULL != himl)
    {
        ListView_SetImageList(m_hwndList, himl, LVSIL_STATE);
    }

    // Full row selection on listview
    ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT);

    // We worked
    fRet = TRUE;
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FLoadListCtrl
//
//  This loads the list view with the current views
//
//  Returns:    TRUE, if it was successfully loaded
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::_FLoadListCtrl(VOID)
{
    BOOL            fRet = FALSE;
    HRESULT         hr =    S_OK;
    DWORD           dwListIndex = 0;
    RULEINFO *      pinfoRules = NULL;
    ULONG           cpinfoRules = 0;
    ULONG           ulIndex = 0;
    IOERule *       pIRule = NULL;
    BOOL            fSelect = FALSE;
    BOOL            fFoundDefault = FALSE;

    Assert(NULL != m_hwndList);

    // Get the Rules enumerator
    Assert(NULL != g_pRulesMan);
    hr = g_pRulesMan->GetRules(GETF_EDIT, RULE_TYPE_FILTER, &pinfoRules, &cpinfoRules);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Remove all the items from the list control
    ListView_DeleteAllItems(m_hwndList);

    // Add each filter to the list
    dwListIndex = 0;

    for (ulIndex = 0; ulIndex < cpinfoRules; ulIndex++)
    {
        // Make a copy of the view
        hr = pinfoRules[ulIndex].pIRule->Clone(&pIRule);
        if (FAILED(hr))
        {
            continue;
        }

        // Check to see if this is a default view we aren't supposed to show
        if ((0 != (m_dwFlags & VRDF_POP3)) && (RULEID_VIEW_DOWNLOADED == pinfoRules[ulIndex].ridRule))
        {
            m_pIRuleDownloaded = pIRule;
            pIRule = NULL;
        }
        else
        {
            // Is this the default view?
            if ((NULL != m_pridRule) && (*m_pridRule == pinfoRules[ulIndex].ridRule))
            {
                fSelect = TRUE;
                fFoundDefault = TRUE;
            }
            else
            {
                fSelect = FALSE;
            }
            
            // Add view to the list
            if (FALSE != _FAddViewToList(dwListIndex, pinfoRules[ulIndex].ridRule, pIRule, fSelect))
            {
                dwListIndex++;
            }

            SafeRelease(pIRule);
        }
    }
    
    // Select the first item in the list
    if (0 != dwListIndex)
    {
        if (FALSE == fFoundDefault)
        {
            ListView_SetItemState(m_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        }
    }
    else
    {
        // Enable the dialog buttons.
        _EnableButtons(-1);
    }
    
    fRet = TRUE;
    
exit:
    SafeRelease(pIRule);
    if (NULL != pinfoRules)
    {
        for (ulIndex = 0; ulIndex < cpinfoRules; ulIndex++)
        {
            pinfoRules[ulIndex].pIRule->Release();
        }
        SafeMemFree(pinfoRules); //delete pinfoRules; 
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FAddRuleToList
//
//  This adds the view passed in to the list view
//
//  dwIndex - the index on where to add the view to into the list
//  pIRule  - the actual view
//
//  Returns:    TRUE, if it was successfully added
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::_FAddViewToList(DWORD dwIndex, RULEID ridRule, IOERule * pIRule, BOOL fSelect)
{
    BOOL        fRet = FALSE;
    HRESULT     hr = S_OK;
    PROPVARIANT propvar = {0};
    LVITEM      lvitem = {0};
    RULEINFO *  pinfoRule = NULL;
    INT         iItem = 0;

    Assert(NULL != m_hwndList);

    // If there's nothing to do...
    if (NULL == pIRule)
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Find out the name of the filter
    hr = pIRule->GetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Allocate space for the rule
    pinfoRule = new RULEINFO;
    if (NULL == pinfoRule)
    {
        fRet = FALSE;
        goto exit;
    }

    // Set up the value
    pinfoRule->ridRule = ridRule;
    pinfoRule->pIRule = pIRule;
    pinfoRule->pIRule->AddRef();
    
    // Add in the image and rule interface
    lvitem.mask = LVIF_PARAM | LVIF_STATE | LVIF_TEXT;
    lvitem.stateMask = LVIS_STATEIMAGEMASK;
    lvitem.iItem = dwIndex;
    if ((NULL != m_pridRule) && (*m_pridRule == pinfoRule->ridRule))
    {
        lvitem.state = INDEXTOSTATEIMAGEMASK(iiconStateDefault + 1);
    }
    lvitem.pszText = propvar.pszVal;
    lvitem.cchTextMax = lstrlen(propvar.pszVal) + 1;
    lvitem.lParam = (LONG_PTR) pinfoRule;

    iItem = ListView_InsertItem(m_hwndList, &lvitem);
    if (-1 == iItem)
    {
        fRet = FALSE;
        goto exit;
    }

    if (FALSE != fSelect)
    {
        // Make sure the new item is selected
        ListView_SetItemState(m_hwndList, iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

        // Make sure the new item is visible
        ListView_EnsureVisible(m_hwndList, iItem, FALSE);
    }
    
    fRet = TRUE;
    
exit:
    PropVariantClear(&propvar);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableButtons
//
//  This enables or disables the buttons in the view manager UI dialog
//  depending on what is selected.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEViewsMgrUI::_EnableButtons(INT iSelected)
{
    int         cRules = 0;
    BOOL        fSelected = FALSE;
    BOOL        fEditable = FALSE;
    LVITEM      lvi = {0};
    RULEID      ridFilter = RULEID_INVALID;

    Assert(NULL != m_hwndList);

    // Load the description field
    _LoadView(iSelected);
    
    // Grab the rule from the list view
    if (-1 != iSelected)
    {
        lvi.iItem = iSelected;
        lvi.mask = LVIF_PARAM;
        if (FALSE != ListView_GetItem(m_hwndList, &lvi))
        {
            ridFilter = ((RULEINFO *) (lvi.lParam))->ridRule;
        }        
    }

    // Check the count of items in the list view
    cRules = ListView_GetItemCount(m_hwndList);

    fSelected = (-1 != iSelected);
    fEditable = !FIsFilterReadOnly(ridFilter);
    
    // Enable the rule action buttons
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbDefaultView, fSelected);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbDeleteView, fSelected && fEditable);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbCopyView, fSelected);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbRenameView, fSelected && fEditable);
    RuleUtil_FEnDisDialogItem(m_hwndDlg, idbModifyView, fSelected && fEditable);
        
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EnableView
//
//  This switches the current default state of the list view item
//  and updates the UI
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEViewsMgrUI::_EnableView(int iSelected)
{
    HRESULT     hr = S_OK;
    LVITEM      lvitem = {0};
    int         iRet = 0;
    INT         cViews = 0;
    
    Assert(-1 != iSelected);
    
    iRet = (INT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddApplyView),
            m_hwndDlg, FSelectApplyViewDlgProc, (LPARAM) &m_fApplyAll);

    if (IDOK != iRet)
    {
        goto exit;
    }

    // Get the current count of item
    cViews = ListView_GetItemCount(m_hwndList);

    // Set up the list view item
    lvitem.mask = LVIF_PARAM | LVIF_STATE;
    lvitem.stateMask = LVIS_STATEIMAGEMASK;

    // Walk each item in the list
    for (lvitem.iItem = 0; lvitem.iItem < cViews; lvitem.iItem++)
    {
        ListView_GetItem(m_hwndList, &lvitem);
        
        // Set the selected item to the default
        if (iSelected == lvitem.iItem)
        {
            if (INDEXTOSTATEIMAGEMASK(iiconStateDefault + 1) != lvitem.state)
            {
                // Save off the default item
                if (NULL != m_pridRule)
                {
                    *m_pridRule = ((RULEINFO *) (lvitem.lParam))->ridRule;
                }

                // Set the state
                ListView_SetItemState(m_hwndList, lvitem.iItem,
                                    INDEXTOSTATEIMAGEMASK(iiconStateDefault + 1),
                                    LVIS_STATEIMAGEMASK);
            }
        }
        else
        {
            if (0 != lvitem.state)
            {
                // Clear out the state
                ListView_SetItemState(m_hwndList, lvitem.iItem, 0, LVIS_STATEIMAGEMASK);

                // Need to update the item
                ListView_Update(m_hwndList, lvitem.iItem);
            }
        }
    }
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;

exit:
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _LoadView
//
//  This loads the selected view into the description field.
//  If there isn't a selected view, then the description field is cleared.
//
//  iSelected   - the item that was selected,
//                  -1 means that nothing was selected
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEViewsMgrUI::_LoadView(INT iSelected)
{
    LVITEM      lvi = {0};
    IOERule *   pIRule = NULL;
    RULEID      ridFilter = RULEID_INVALID;

    Assert(NULL != m_hwndList);
    Assert(NULL != m_pDescriptUI);

    // Grab the rule from the list view
    if (-1 != iSelected)
    {
        lvi.iItem = iSelected;
        lvi.mask = LVIF_PARAM;
        if (FALSE != ListView_GetItem(m_hwndList, &lvi))
        {
            pIRule = ((RULEINFO *) (lvi.lParam))->pIRule;
            ridFilter = ((RULEINFO *) (lvi.lParam))->ridRule;
        }        
    }

    // Have the description field load this rule
    m_pDescriptUI->HrSetRule(RULE_TYPE_FILTER, pIRule);

    // Set the proper read only state of the description field
    m_pDescriptUI->HrSetReadOnly(FIsFilterReadOnly(ridFilter));
    
    // Display the new rule
    m_pDescriptUI->ShowDescriptionString();

    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FSaveView
//
//  This checks to see if the view has been changed in the description
//  area and if it has, then it warns the user and changes the text
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    TRUE, if the rule either didn't change or did change without problems
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::_FSaveView(int iSelected)
{
    BOOL            fRet = FALSE;
    HRESULT         hr = S_OK;
    LVITEM          lvi = {0};
    IOERule *       pIRule = NULL;
    PROPVARIANT     propvar = {0};
    CRIT_ITEM *     pCritItem = NULL;
    ULONG           cCritItem = 0;
    ACT_ITEM *      pActItem = NULL;
    ULONG           cActItem = 0;

    // If the rule didn't change, then we're done
    hr = m_pDescriptUI->HrIsDirty();
    if (S_OK != hr)
    {
        fRet = (S_FALSE == hr);
        goto exit;
    }
    
    // Grab the list view item
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iSelected;
    if (FALSE == ListView_GetItem(m_hwndList, &lvi))
    {
        fRet = FALSE;
        goto exit;
    }
    
    pIRule = ((RULEINFO *) (lvi.lParam))->pIRule;

    // Get the criteria from the rule
    hr = m_pDescriptUI->HrGetCriteria(&pCritItem, &cCritItem);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Get the actions for the rule
    hr = m_pDescriptUI->HrGetActions(&pActItem, &cActItem);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Set the criteria from the rule
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cCritItem * sizeof(CRIT_ITEM);
    propvar.blob.pBlobData = (BYTE *) pCritItem;
    hr = pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the actions for the rule
    PropVariantClear(&propvar);
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = cActItem * sizeof(ACT_ITEM);
    propvar.blob.pBlobData = (BYTE *) pActItem;
    hr = pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar);
    ZeroMemory(&propvar, sizeof(propvar));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // Make sure we clear out the fact that we saved the rule
    m_pDescriptUI->HrClearDirty();
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
    
    // Set the proper return value
    fRet = TRUE;

exit:
    RuleUtil_HrFreeCriteriaItem(pCritItem, cCritItem);
    SafeMemFree(pCritItem);
    RuleUtil_HrFreeActionsItem(pActItem, cActItem);
    SafeMemFree(pActItem);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _NewView
//
//  This brings up a fresh rules editor
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
void COEViewsMgrUI::_NewView(VOID)
{
    HRESULT         hr = S_OK;
    IOERule *       pIRule = NULL;
    TCHAR           szRes[CCHMAX_STRINGRES + 5];
    ULONG           cchRes = 0;
    ULONG           ulIndex = 0;
    TCHAR           szName[CCHMAX_STRINGRES + 5];
    LVFINDINFO      lvfinfo = {0};
    PROPVARIANT     propvar = {0};
    ACT_ITEM        aitem;
    CEditRuleUI *   pEditRuleUI = NULL;
    LONG            cRules = 0;
       
    // Create a new rule object
    if (FAILED(HrCreateRule(&pIRule)))
    {
        goto exit;
    }

    // Figure out the name of the new rule ...
    cchRes = LoadString(g_hLocRes, idsViewDefaultName, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    ulIndex = 1;
    wsprintf(szName, szRes, ulIndex);

    lvfinfo.flags = LVFI_STRING;
    lvfinfo.psz = szName;
    while (-1 != ListView_FindItem(m_hwndList, -1, &lvfinfo))
    {
        ulIndex++;
        wsprintf(szName, szRes, ulIndex);
    }

    propvar.vt = VT_LPSTR;
    propvar.pszVal = szName;

    hr = pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

#ifdef NEVER
    // Set the default action
    // Set the normal action
    ZeroMemory(&aitem, sizeof(aitem));
    aitem.type = ACT_TYPE_SHOW;
    aitem.dwFlags = ACT_FLAG_DEFAULT;
    aitem.propvar.vt = VT_UI4;
    aitem.propvar.ulVal = ACT_DATA_NULL;
    
    ZeroMemory(&propvar, sizeof(propvar));
    propvar.vt = VT_BLOB;
    propvar.blob.cbSize = sizeof(ACT_ITEM);
    propvar.blob.pBlobData = (BYTE *) &aitem;

    hr = pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
#endif  // NEVER

    // Create a rules editor object
    pEditRuleUI = new CEditRuleUI;
    if (NULL == pEditRuleUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditRuleUI->HrInit(m_hwndDlg, ERF_NEWRULE | ERF_ADDDEFAULTACTION, RULE_TYPE_FILTER, pIRule, NULL)))
    {
        goto exit;
    }

    // Bring up the rules editor UI
    hr = pEditRuleUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    if (S_OK == hr)
    {
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;
        
        // Add the rule to the manager UI
        cRules = ListView_GetItemCount(m_hwndList);
        
        _FAddViewToList(cRules, RULEID_INVALID, pIRule, TRUE);
    }
    
exit:
    SafeRelease(pIRule);
    if (NULL != pEditRuleUI)
    {
        delete pEditRuleUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _EditView
//
//  This brings up the edit UI for the selected view from the view list
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEViewsMgrUI::_EditView(int iSelected)
{
    HRESULT         hr = S_OK;
    LVITEM          lvitem = {0};
    IOERule *       pIRule = NULL;
    CEditRuleUI *   pEditRuleUI = NULL;
    PROPVARIANT     propvar = {0};

    Assert(NULL != m_hwndList);
    
    // Make sure we don't loose any changes
    _FSaveView(iSelected);

    // Grab the rule from the list view
    lvitem.iItem = iSelected;
    lvitem.mask = LVIF_PARAM;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }   

    pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
    if (NULL == pIRule)
    {
        goto exit;
    }

    // If the rule is read-only then we're done
    if (FALSE != FIsFilterReadOnly(((RULEINFO *) (lvitem.lParam))->ridRule))
    {
        goto exit;
    }
    
    // Create the rules editor
    pEditRuleUI = new CEditRuleUI;
    if (NULL == pEditRuleUI)
    {
        goto exit;
    }

    // Initialize the editor object
    if (FAILED(pEditRuleUI->HrInit(m_hwndDlg, 0, RULE_TYPE_FILTER, pIRule, NULL)))
    {
        goto exit;
    }

    // Bring up the rules editor UI
    hr = pEditRuleUI->HrShow();
    if (FAILED(hr))
    {
        goto exit;
    }

    // If the rule changed, make sure we reload the description field
    if (S_OK == hr)
    {
        // Mark the rule list as dirty
        m_dwState |= STATE_DIRTY;

        // Grab the rule name
        PropVariantClear(&propvar);
        hr = pIRule->GetProp(RULE_PROP_NAME, 0, &propvar);
        if (FAILED(hr))
        {
            goto exit;
        }

        if ((VT_LPSTR == propvar.vt) && (NULL != propvar.pszVal) && ('\0' != propvar.pszVal[0]))
        {
            ZeroMemory(&lvitem, sizeof(lvitem));
            lvitem.iItem = iSelected;
            lvitem.mask = LVIF_TEXT;
            lvitem.pszText = propvar.pszVal;
            lvitem.cchTextMax = lstrlen(propvar.pszVal) + 1;
            
            if (-1 == ListView_SetItem(m_hwndList, &lvitem))
            {
                goto exit;
            }
        }

        _EnableButtons(iSelected);
    }
    
exit:
    PropVariantClear(&propvar);
    if (NULL != pEditRuleUI)
    {
        delete pEditRuleUI;
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _RemoveView
//
//  This removes the selected rule from the mail rules list
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEViewsMgrUI::_RemoveView(int iSelected)
{
    LVITEM      lvitem = {0};
    RULEINFO *  pinfoRule = NULL;
    BOOL        fDefault = FALSE;
    PROPVARIANT propvar = {0};
    int         cViews = 0;
    TCHAR       szRes[CCHMAX_STRINGRES];
    UINT        cchRes = 0;
    LPTSTR      pszMessage = NULL;

    Assert(NULL != m_hwndList);

    // Grab the rule from the list view
    lvitem.iItem = iSelected;
    lvitem.mask = LVIF_PARAM | LVIF_STATE;
    lvitem.stateMask = LVIS_STATEIMAGEMASK;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }

    pinfoRule = (RULEINFO *) (lvitem.lParam);
    fDefault = (INDEXTOSTATEIMAGEMASK(iiconStateDefault + 1) == lvitem.state);
    if ((NULL == pinfoRule) || (NULL == pinfoRule->pIRule))
    {
        goto exit;
    }
    
    // If the rule is read-only then we're done
    if (FALSE != FIsFilterReadOnly(pinfoRule->ridRule))
    {
        goto exit;
    }
    
    // Warn the user to make sure they know we are going to remove the rule
    if (FAILED(pinfoRule->pIRule->GetProp(RULE_PROP_NAME, 0, &propvar)))
    {
        goto exit;
    }

    // Get the string template to display
    cchRes = LoadString(g_hLocRes, idsRulesWarnDelete, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    // Allocate space to hold the final display string
    if (FAILED(HrAlloc((void ** ) &pszMessage, cchRes + lstrlen(propvar.pszVal) + 1)))
    {
        goto exit;
    }

    // Build up the string and display it
    wsprintf(pszMessage, szRes, propvar.pszVal);
    if (IDNO == AthMessageBox(m_hwndDlg, MAKEINTRESOURCE(idsAthenaMail), pszMessage,
                            NULL, MB_YESNO | MB_ICONINFORMATION))
    {
        goto exit;
    }
    
    // Remove the item from the list
    ListView_DeleteItem(m_hwndList, iSelected);

    // Let's make sure we have a selection in the list
    cViews = ListView_GetItemCount(m_hwndList);
    if (cViews > 0)
    {
        // Did we delete the last item in the list
        if (iSelected >= cViews)
        {
            // Move the selection to the new last item in the list
            iSelected = cViews - 1;
        }

        // Do we need to reset the default
        if (FALSE != fDefault)
        {
            // Set the state
            ListView_SetItemState(m_hwndList, iSelected, INDEXTOSTATEIMAGEMASK(iiconStateDefault + 1),
                                LVIS_STATEIMAGEMASK);
        }
        
        // Set the new selection
        ListView_SetItemState(m_hwndList, iSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

        // Let's make sure we can see this new item
        ListView_EnsureVisible(m_hwndList, iSelected, FALSE);
    }
    else
    {
        // Make sure we clear out all of the buttons
        _EnableButtons(-1);
    }

    // Release the rule
    SafeRelease(pinfoRule->pIRule);

    // Free up the memory
    delete pinfoRule; //SafeMemFree(pinfoRule);
    
    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    PropVariantClear(&propvar);
    SafeMemFree(pszMessage);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _CopyView
//
//  This copies the selected view from the view manager UI
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEViewsMgrUI::_CopyView(INT iSelected)
{
    LVITEM          lvitem = {0};
    IOERule *       pIRule = NULL;
    HRESULT         hr = S_OK;
    IOERule *       pIRuleNew = NULL;
    PROPVARIANT     propvar = {0};
    UINT            cRules = 0;
    TCHAR           szRes[CCHMAX_STRINGRES];
    UINT            cchRes = 0;
    LPTSTR          pszName = NULL;

    Assert(NULL != m_hwndList);
    
    // Make sure we don't loose any changes
    _FSaveView(iSelected);
    
    // Grab the rule from the list view
    lvitem.iItem = iSelected;
    lvitem.mask = LVIF_PARAM;
    if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
    {
        goto exit;
    }

    pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
    if (NULL == pIRule)
    {
        goto exit;
    }

    // Create a new rule object
    hr = pIRule->Clone(&pIRuleNew);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Let's set the name

    // Get the name from the source rule
    hr = pIRule->GetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the string template to display
    cchRes = LoadString(g_hLocRes, idsRulesCopyName, szRes, ARRAYSIZE(szRes));
    if (0 == cchRes)
    {
        goto exit;
    }

    // Allocate space to hold the final display string
    if (FAILED(HrAlloc((void ** ) &pszName, cchRes + lstrlen(propvar.pszVal) + 1)))
    {
        goto exit;
    }

    // Build up the string and set it
    wsprintf(pszName, szRes, propvar.pszVal);

    PropVariantClear(&propvar);
    propvar.vt = VT_LPSTR;
    propvar.pszVal = pszName;
    pszName = NULL;
    
    // Set the name into the new rule
    Assert(VT_LPSTR == propvar.vt);
    Assert(NULL != propvar.pszVal);
    hr = pIRuleNew->SetProp(RULE_PROP_NAME, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Clear the version of the new rule
    PropVariantClear(&propvar);
    propvar.vt = VT_UI4;
    propvar.ulVal = 0;
    hr = pIRuleNew->SetProp(RULE_PROP_VERSION, 0, &propvar);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Add the rule to the rules list right below
    // the original rule
    iSelected++;
    _FAddViewToList(iSelected, RULEID_INVALID, pIRuleNew, TRUE);

    // Mark the rule list as dirty
    m_dwState |= STATE_DIRTY;
        
exit:
    SafeMemFree(pszName);
    SafeRelease(pIRuleNew);
    PropVariantClear(&propvar);
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _DefaultView
//
//  This sets the selected view as the default view
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
VOID COEViewsMgrUI::_DefaultView(int iSelected)
{
    Assert(NULL != m_hwndList);

    _EnableView(iSelected);
    
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _DefaultView
//
//  This sets the selected view as the default view
//
//  iSelected   - index of the item in the listview to work on
//
//  Returns:    NONE
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::_FGetDefaultItem(IOERule ** ppIRuleDefault, RULEID * pridDefault)
{
    BOOL        fRet = FALSE;
    LVITEM      lvitem = {0};
    INT         cViews = 0;
    
    Assert(NULL != m_hwndList);
    
    // Get the current count of item
    cViews = ListView_GetItemCount(m_hwndList);

    // Set up the list view item
    lvitem.mask = LVIF_PARAM | LVIF_STATE;
    lvitem.stateMask = LVIS_STATEIMAGEMASK;

    // Walk each item in the list
    for (lvitem.iItem = 0; lvitem.iItem < cViews; lvitem.iItem++)
    {
        ListView_GetItem(m_hwndList, &lvitem);
        
        // Set the selected item to the default
        if (INDEXTOSTATEIMAGEMASK(iiconStateDefault + 1) == lvitem.state)
        {
            // We found it
            fRet = TRUE;
            
            // Save off the default item
            if (NULL != pridDefault)
            {
                *pridDefault = ((RULEINFO *) (lvitem.lParam))->ridRule;
            }
            if (NULL != ppIRuleDefault)
            {
                *ppIRuleDefault = ((RULEINFO *) (lvitem.lParam))->pIRule;
            }
            break;
        }
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _FOnLabelEdit
//
//  This brings up the edit UI for the selected view from the view list
//
//  fBegin  - is this for the LVN_BEGINLABELEDIT notification
//  pdi     - the display info for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL COEViewsMgrUI::_FOnLabelEdit(BOOL fBegin, NMLVDISPINFO * pdi)
{
    BOOL            fRet = FALSE;
    HWND            hwndEdit = NULL;
    ULONG           cchName = 0;
    IOERule *       pIRule = NULL;
    LVITEM          lvitem = {0};
    PROPVARIANT     propvar = {0};

    Assert(NULL != m_hwndList);

    if (NULL == pdi)
    {
        fRet = FALSE;
        goto exit;
    }

    Assert(m_hwndList == pdi->hdr.hwndFrom);
    
    if (FALSE != fBegin)
    {
        // Get the rule for the item
        lvitem.iItem = pdi->item.iItem;
        lvitem.mask = LVIF_PARAM;
        if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
        {
            SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, TRUE);
            fRet = TRUE;
            goto exit;
        }

        // Should we allow the use to end the item?
        if (FALSE != FIsFilterReadOnly(((RULEINFO *) (lvitem.lParam))->ridRule))
        {
            SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, TRUE);
            fRet = TRUE;
            goto exit;
        }
            
        // Get the edit control
        hwndEdit = ListView_GetEditControl(m_hwndList);

        if (NULL == hwndEdit)
        {
            fRet = FALSE;
            goto exit;
        }
        
        // Limit the amount of text for the name
        SendMessage(hwndEdit, EM_LIMITTEXT, c_cchNameMax - 1, 0);

        // Tell the dialog it's aok to proceed
        SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
    }
    else
    {            
        // Did something change?
        if ((-1 != pdi->item.iItem) && (NULL != pdi->item.pszText))
        {
            cchName = lstrlen(pdi->item.pszText);
            
            // Check to see if the rule name is valid
            if ((0 == cchName) || (0 == UlStripWhitespace(pdi->item.pszText, TRUE, TRUE, &cchName)))
            {
                // Put up a message saying something is busted
                AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsAthenaMail),
                                MAKEINTRESOURCEW(idsRulesErrorNoName), NULL,
                                MB_OK | MB_ICONINFORMATION);
                SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
                fRet = TRUE;
                goto exit;
            }
            
            // Get the rule for the item
            lvitem.iItem = pdi->item.iItem;
            lvitem.mask = LVIF_PARAM;
            if (FALSE == ListView_GetItem(m_hwndList, &lvitem))
            {
                SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
                fRet = TRUE;
                goto exit;
            }

            pIRule = ((RULEINFO *) (lvitem.lParam))->pIRule;
            if (NULL == pIRule)
            {
                SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, FALSE);
                fRet = TRUE;
                goto exit;
            }
            
            // Set the new name into the rule
            
            propvar.vt = VT_LPSTR;
            propvar.pszVal = pdi->item.pszText;
            
            SideAssert(S_OK == pIRule->SetProp(RULE_PROP_NAME, 0, &propvar));

            // Mark the rule list as dirty
            m_dwState |= STATE_DIRTY;
        
            SetDlgMsgResult(m_hwndDlg, WM_NOTIFY, TRUE);
        }
    }

    fRet = TRUE;
    
exit:
    return fRet;
}

BOOL FIsFilterReadOnly(RULEID ridFilter)
{
    BOOL fRet = FALSE;

    // Check the incoming params
    if (RULEID_INVALID == ridFilter)
    {
        goto exit;
    }

    if ((RULEID_VIEW_ALL == ridFilter) ||
            (RULEID_VIEW_UNREAD == ridFilter) ||
            (RULEID_VIEW_DOWNLOADED == ridFilter) ||
            (RULEID_VIEW_IGNORED == ridFilter))
    {
        fRet = TRUE;
    }            
    
exit:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//  FSelectApplyViewDlgProc
//
//  This is the main dialog proc for selecting the thread state dialog
//
//  hwndDlg - handle to the filter manager dialog
//  uMsg    - the message to be acted upon
//  wParam  - the 'word' parameter for the message
//  lParam  - the 'long' parameter for the message
//
//  Returns:    TRUE, if the message was handled
//              FALSE, otherwise
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK FSelectApplyViewDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL            fRet = FALSE;
    BOOL *          pfApplyAll = NULL;
    UINT            uiId = 0;

    pfApplyAll = (BOOL *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Grab the propvariant pointer
            pfApplyAll = (BOOL *) lParam;
            if (NULL == pfApplyAll)
            {
                fRet = FALSE;
                EndDialog(hwndDlg, -1);
            }

            // Set it into the dialog so we can get it back
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pfApplyAll);

            // Set the default item
            if (FALSE != *pfApplyAll)
            {
                uiId = idcViewAll;
            }
            else
            {
                uiId = idcViewCurrent;
            }
            
            CheckDlgButton(hwndDlg, uiId, BST_CHECKED);
            
            // We didn't set the focus so return TRUE
            fRet = TRUE;
            break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    fRet = TRUE;
                    break;

                case IDOK:
                    *pfApplyAll = (BST_CHECKED == IsDlgButtonChecked(hwndDlg, idcViewAll));
                                
                    EndDialog(hwndDlg, IDOK);
                    fRet = TRUE;
                    break;
            }
            break;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\acctview.h ===
#ifndef _INC_ACCTVIEW_H
#define _INC_ACCTVIEW_H

#include "browser.h"
#include <columns.h>

class CEmptyList;
class CFolderUpdateCB;
class CGetNewGroups;

typedef struct tagFLDRNODE
{
    FOLDERID id;
    DWORD indent;
    DWORD dwDownload;
} FLDRNODE;

class CAccountView : 
        public IViewWindow,
        public IOleCommandTarget,
        public IDatabaseNotify
    {
    public:
        CAccountView();
        ~CAccountView();

        // IUnknown 
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        virtual ULONG   STDMETHODCALLTYPE AddRef(void);
        virtual ULONG   STDMETHODCALLTYPE Release(void);

        // IOleWindow
        HRESULT STDMETHODCALLTYPE GetWindow(HWND * lphwnd);                         
        HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL fEnterMode);            
                                                                             
        // IAthenaView
        HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG lpmsg);
        HRESULT STDMETHODCALLTYPE UIActivate(UINT uState);
        HRESULT STDMETHODCALLTYPE CreateViewWindow(IViewWindow *lpPrevView, IAthenaBrowser *psb, 
                                                   RECT *prcView, HWND *phWnd);
        HRESULT STDMETHODCALLTYPE DestroyViewWindow();
        HRESULT STDMETHODCALLTYPE SaveViewState();
        HRESULT STDMETHODCALLTYPE OnPopupMenu(HMENU hMenu, HMENU hMenuPopup, UINT uID);

        // IOleCommandTarget
        HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
        HRESULT STDMETHODCALLTYPE Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

        // IDatabaseNotify
        STDMETHODIMP OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pDB);

        HRESULT HrInit(FOLDERID idFolder);

        static LRESULT CALLBACK AcctViewWndProc(HWND, UINT, WPARAM, LPARAM);

    private:
        /////////////////////////////////////////////////////////////////////////
        //
        // Message Handling
        //
        LRESULT _WndProc(HWND, UINT, WPARAM, LPARAM);
        BOOL    _OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
        void    _OnSize(HWND hwnd, UINT state, int cxClient, int cyClient);
        LRESULT _OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
        void    _OnSetFocus(HWND hwnd, HWND hwndOldFocus);
        void    _PostCreate(void);
        HRESULT _InsertChildren(FOLDERID idFolder, DWORD indent, DWORD *piNode);
        HRESULT _InsertChildrenSpecial(FOLDERID idFolder, DWORD indent, DWORD *piNode);
        BOOL    _OnWinIniChange(HWND hwnd);
        void    _OnContextMenu(HWND hwnd, HWND hwndFrom, int x, int y);
        HRESULT _MarkForDownload(DWORD nCmdID);
        HRESULT _ToggleDownload(int iItem);
        HRESULT _GetDisplayInfo(LV_DISPINFO *pDispInfo, COLUMN_ID id);
        HRESULT _InsertFolder(LPFOLDERINFO pFolder);
        HRESULT _InsertFolderNews(LPFOLDERINFO pFolder);
        HRESULT _UpdateFolder(LPFOLDERINFO pFolder1, LPFOLDERINFO pFolder2);
        HRESULT _DeleteFolder(LPFOLDERINFO pFolder);
        HRESULT _Subscribe(BOOL fSubscribe);
        HRESULT _MarkAllRead(void);
        BOOL    _IsSelectedFolder(FLDRFLAGS dwFlags, BOOL fCondition, BOOL fAll, BOOL fIgnoreSpecial = FALSE);
        DWORD   _GetDownloadCmdStatus(int iSel, FLDRFLAGS dwFlags);
        LRESULT _OnPaint(HWND hwnd, HDC hdc);
        void    _HandleItemStateChange(void);
        void    _HandleSettingsButton(HWND hwnd);
        void    _OnCommand(WPARAM wParam, LPARAM lParam);
        HRESULT _HandleAccountRename(LPFOLDERINFO pFolder);
        void    _HandleDelete(BOOL fNoTrash);

        /////////////////////////////////////////////////////////////////////////
        //
        // Shell Interface Handling
        //
        BOOL    _OnActivate(UINT uActivation);
        BOOL    _OnDeactivate();

        int     _GetFolderIndex(FOLDERID id);
        int     _GetSubFolderCount(int index);

        inline FOLDERID _IdFromIndex(int index)     { IxpAssert((DWORD)index < m_cnode); return((index >= 0 && (DWORD)index < m_cnode) ? m_rgnode[index].id : FOLDERID_INVALID); }
        inline FLDRNODE *_NodeFromIndex(int index)  { IxpAssert((DWORD)index < m_cnode); return((index >= 0 && (DWORD)index < m_cnode) ? &m_rgnode[index] : NULL); }

    private:
        UINT                m_cRef;
        FOLDERID            m_idFolder;
        FOLDERTYPE          m_ftType;
        DWORD               m_dwDownloadDef;
        IAthenaBrowser     *m_pShellBrowser;
        BOOL                m_fFirstActive;
        CColumns           *m_pColumns;
        UINT                m_uActivation;
        HWND                m_hwndOwner;                  // Owner window
        HWND                m_hwnd;                       // Our window
        BOOL                m_fRegistered;

        HWND                m_hwndList;
        HWND                m_hwndHeader;
        HWND                m_rgBtns[3];
        int                 m_cBtns;
        RECT                m_rcHeader;
        RECT                m_rcMajor;
        LPSTR               m_pszMajor;
        RECT                m_rcMinor;
        LPSTR               m_pszMinor;
        RECT                m_rcButtons;

        DWORD               m_cnode;
        DWORD               m_cnodeBuf;
        FLDRNODE           *m_rgnode;

        HIMAGELIST          m_himlFolders;
        CEmptyList         *m_pEmptyList;

        CGetNewGroups      *m_pGroups;
        DWORD               m_clrWatched;
    };

#endif // _INC_ACCTVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\browser.h ===
/* *
   * Browser implementation
   * 
   * Jan 97: erican
   */

#pragma once

// for ITreeViewNotify
#include "treeview.h"

// for IConnectionNotify
#include "conman.h"
#include "tbbands.h"

// for IIdentityChangeNotify
#include "msident.h"

// for IMessageList
#include "msoeobj.h"

typedef enum tagLAYOUTPOS
{
    LAYOUT_POS_NA = -1,
    LAYOUT_POS_TOP = 0,
    LAYOUT_POS_LEFT,
    LAYOUT_POS_BOTTOM,
    LAYOUT_POS_RIGHT
} LAYOUTPOS;


typedef struct tagLAYOUT
{
    DWORD cbSize;

    // Things that can be turned on or off
    unsigned fToolbar : 1;
    unsigned fStatusBar : 1;
    unsigned fFolderBar : 1;
    unsigned fFolderList : 1;
    unsigned fTipOfTheDay : 1;
    unsigned fInfoPaneEnabled : 1;
    unsigned fInfoPane : 1;
    unsigned fOutlookBar : 1;
    unsigned fContacts : 1;
    unsigned fMailPreviewPane : 1;
    unsigned fMailPreviewPaneHeader : 1;
    unsigned fMailSplitVertically : 1;
    unsigned fNewsPreviewPane : 1;
    unsigned fNewsPreviewPaneHeader : 1;
    unsigned fNewsSplitVertically : 1;
    unsigned fFilterBar           : 1;

    // Which side is the toolbar docked to
    //COOLBAR_SIDE csToolbarSide;

    // Preview Pane settings
    BYTE bMailSplitHorzPct;         // Percent of the view that the preview pane occupies in mail / imap
    BYTE bMailSplitVertPct;
    BYTE bNewsSplitHorzPct;         // Percent of the view that the preview pane occupies in news
    BYTE bNewsSplitVertPct;
} LAYOUT, *PLAYOUT;

// forward defines
class CStatusBar;
class CBodyBar;
class CFolderBar;
class COutBar;
typedef struct tagACCTMENU *LPACCTMENU;
class CNavPane;
class CAdBar;

class IBrowserDoc
{
public:
    virtual void ResetMenus(HMENU) = 0;
    virtual void BrowserExiting(void) = 0;
};

interface IAthenaBrowser;

/////////////////////////////////////////////////////////////////////////////
//
// IViewWindow
//
// Description:  
//      IViewWindow is implemented by all views that are hosted within the 
//      Outlook Express shell.  The methods in this interface are used to manage
//      UI related things such as creation and destruction, keyboard input, and
//      menu enabling etc.
// 
interface IViewWindow : public IOleWindow
{
    STDMETHOD(TranslateAccelerator)(THIS_ LPMSG pMsg) PURE;
    STDMETHOD(UIActivate)(THIS_ UINT uState) PURE;
    STDMETHOD(CreateViewWindow)(THIS_ IViewWindow *pPrevView, IAthenaBrowser *pBrowser,
                                RECT *prcView, HWND *pHwnd) PURE;
    STDMETHOD(DestroyViewWindow)(THIS) PURE;
    STDMETHOD(SaveViewState)(THIS) PURE;
    STDMETHOD(OnPopupMenu)(THIS_ HMENU hMenu, HMENU hMenuPopup, UINT uID) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// 
// IMessageWindow
//
// IMessageWindow is an interface implemented specifically by views in 
// Outlook Express that contain the Message List object and Preview Pane   
// object.  Methods are used to control the behavior of those controls.
//
interface IMessageWindow : public IUnknown
{
    STDMETHOD(OnFrameWindowActivate)(THIS_ BOOL fActivate) PURE;
    STDMETHOD(GetCurCharSet)(THIS_ UINT *cp) PURE;
    STDMETHOD(UpdateLayout)(THIS_ BOOL fPreviewVisible, BOOL fPreviewHeader, 
                            BOOL fPreviewVert, BOOL fReload) PURE;
    STDMETHOD(GetMessageList)(THIS_ IMessageList ** ppMsgList) PURE;
};


/////////////////////////////////////////////////////////////////////////////
//
// IServerInfo
//
// IServerInfo is used so a newly created view can query the previous view
// to see if the current connection to the server can be reused for this new
// folder.
//
interface IServerInfo : public IUnknown
{
    STDMETHOD(GetFolderId)(THIS_ FOLDERID *pID) PURE;
    STDMETHOD(GetMessageFolder)(THIS_ IMessageServer **ppServer) PURE;
};



DECLARE_INTERFACE_(IAthenaBrowser, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IAthenaBrowser methods ***
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg) PURE;
    STDMETHOD(AddToolbar) (THIS_ IUnknown* punkSrc, DWORD dwIndex, BOOL fShow, BOOL fActivate) PURE;
    STDMETHOD(ShowToolbar) (THIS_ IUnknown* punkSrc, BOOL fShow) PURE;
    STDMETHOD(RemoveToolbar) (THIS_ IUnknown* punkSrc) PURE;
    STDMETHOD(HasFocus) (THIS_ UINT itb) PURE;
    STDMETHOD(OnViewWindowActive) (THIS_ struct IViewWindow *pAV) PURE;
    STDMETHOD(BrowseObject) (THIS_ FOLDERID idFolder, DWORD dwFlags) PURE;
    STDMETHOD(GetStatusBar) (THIS_ CStatusBar * * ppStatusBar) PURE;
    STDMETHOD(GetCoolbar) (THIS_ CBands * * ppCoolbar) PURE;
    STDMETHOD(GetLanguageMenu) (THIS_ HMENU *phMenu, UINT cp) PURE;
    STDMETHOD(InitPopupMenu) (THIS_ HMENU hMenu) PURE;
    STDMETHOD(UpdateToolbar) (THIS) PURE;
    STDMETHOD(GetFolderType) (THIS_ FOLDERTYPE *pftType) PURE;
    STDMETHOD(GetCurrentFolder) (THIS_ FOLDERID *pidFolder) PURE;
    STDMETHOD(GetCurrentView) (THIS_ IViewWindow **ppView) PURE;
    STDMETHOD(GetTreeView) (THIS_ CTreeView **ppTree) PURE;
    STDMETHOD(GetViewRect) (THIS_ LPRECT prc) PURE;
    STDMETHOD(GetFolderBar) (THIS_ CFolderBar **ppFolderBar) PURE;
    STDMETHOD(SetViewLayout)(THIS_ DWORD opt, LAYOUTPOS pos, BOOL fVisible, DWORD dwFlags, DWORD dwSize) PURE;
    STDMETHOD(GetViewLayout)(THIS_ DWORD opt, LAYOUTPOS *pPos, BOOL *pfVisible, DWORD *pdwFlags, DWORD *pdwSize) PURE;
    STDMETHOD(GetLayout) (THIS_ PLAYOUT playout) PURE;
    STDMETHOD(AccountsChanged) (THIS) PURE;
    STDMETHOD(CycleFocus)(THIS_ BOOL fReverse) PURE;
    STDMETHOD(ShowAdBar)(THIS_ BSTR bstr) PURE;
};


#define ITB_NONE        ((UINT)-1)
#define ITB_COOLBAR     0
#define ITB_ADBAR       1
#define ITB_BODYBAR     2
#define ITB_OUTBAR      3
#define ITB_FOLDERBAR   4
#define ITB_NAVPANE     5
#define ITB_TREE        6
#define ITB_MAX         7
//changing the name from ITB_VIEW to ITB_OEVIEW to fix the build break caused due to a redef in iedev
#define ITB_OEVIEW        (ITB_MAX + 1)

/////////////////////////////////////////////////////////////////////////////
//
// CBrowser
//

class CBrowser :
    public IAthenaBrowser,
    public IOleCommandTarget,
    public IDockingWindowSite,
    public IInputObjectSite,
    public ITreeViewNotify,
    public IConnectionNotify,
    public IIdentityChangeNotify,
    public IStoreCallback
{
public:
    /////////////////////////////////////////////////////////////////////////
    //
    // OLE Interfaces
    //
    
    // IUnknown 
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObject);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IOleWindow
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);                         
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);            
                                                                             
    // IAthenaBrowser (also IOleWindow)
    virtual STDMETHODIMP TranslateAccelerator(LPMSG lpmsg);
    virtual STDMETHODIMP AddToolbar(IUnknown* punkSrc, DWORD dwIndex, BOOL fShow, BOOL fActivate);
    virtual STDMETHODIMP ShowToolbar(IUnknown* punkSrc, BOOL fShow);
    virtual STDMETHODIMP RemoveToolbar(IUnknown* punkSrc);
    virtual STDMETHODIMP HasFocus(UINT itb);
    virtual STDMETHODIMP OnViewWindowActive(IViewWindow *pAV);
    virtual STDMETHODIMP BrowseObject(FOLDERID idFolder, DWORD dwFlags);
    virtual STDMETHODIMP GetStatusBar(CStatusBar * * ppStatusBar);
    virtual STDMETHODIMP GetCoolbar(CBands * * ppCoolbar);
    virtual STDMETHODIMP GetLanguageMenu(HMENU *phMenu, UINT cp);
    virtual STDMETHODIMP InitPopupMenu(HMENU hMenu);
    virtual STDMETHODIMP UpdateToolbar();
    virtual STDMETHODIMP GetFolderType(FOLDERTYPE *pftType);
    virtual STDMETHODIMP GetCurrentFolder(FOLDERID *pidFolder);
    virtual STDMETHODIMP GetCurrentView(IViewWindow **ppView);
    virtual STDMETHODIMP GetTreeView(CTreeView * * ppTree);
    virtual STDMETHODIMP GetViewRect(LPRECT prc);
    virtual STDMETHODIMP GetFolderBar(CFolderBar **ppFolderBar);
    virtual STDMETHODIMP SetViewLayout(DWORD opt, LAYOUTPOS pos, BOOL fVisible, DWORD dwFlags, DWORD dwSize);
    virtual STDMETHODIMP GetViewLayout(DWORD opt, LAYOUTPOS *pPos, BOOL *pfVisible, DWORD *pdwFlags, DWORD *pdwSize);
    virtual STDMETHODIMP GetLayout(PLAYOUT playout);
    virtual STDMETHODIMP AccountsChanged(void) { m_fRebuildAccountMenu = TRUE; return (S_OK); }
    virtual STDMETHODIMP CycleFocus(BOOL fReverse);
    virtual STDMETHODIMP ShowAdBar(BSTR     bstr);

    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                                     OLECMDTEXT *pCmdText); 
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                              VARIANTARG *pvaIn, VARIANTARG *pvaOut); 

    // IDockingWindowSite (also IOleWindow)
    virtual STDMETHODIMP GetBorderDW(IUnknown* punkSrc, LPRECT lprectBorder);
    virtual STDMETHODIMP RequestBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths);
    virtual STDMETHODIMP SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths);

    // IInputObjectSite
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus);

    // ITreeViewNotify
    void OnSelChange(FOLDERID idFolder);
    void OnRename(FOLDERID idFolder);
    void OnDoubleClick(FOLDERID idFolder);

    // IStoreCallback Members
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel) { return(E_NOTIMPL); }
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags) { return(E_NOTIMPL); }
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType) { return(E_NOTIMPL); }
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo) { return(E_NOTIMPL); }
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse) { return(E_NOTIMPL); }
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus) { return(E_NOTIMPL); }
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    // IConnectionNotify
    virtual STDMETHODIMP OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, CConnectionManager *pConMan);
    
    // IIdentityChangeNotify
    virtual STDMETHODIMP QuerySwitchIdentities();
    virtual STDMETHODIMP SwitchIdentities();
    virtual STDMETHODIMP IdentityInformationChanged(DWORD dwType);

    void SetDocObjPointer(IBrowserDoc* pDocObj)
    {
        m_pDocObj = pDocObj;
    }

    /////////////////////////////////////////////////////////////////////////
    //
    // Constructors, Destructors, and Initialization
    //
    CBrowser();
    virtual ~CBrowser();
    HRESULT HrInit(UINT nCmdShow, FOLDERID idFolder, HWND hWndParent = NULL);
    HRESULT IsMenuMessage(MSG *lpmsg);
    HRESULT TranslateMenuMessage(MSG *lpmsg, LRESULT *lres);
    void    WriteUnreadCount(void);

private:
    // IAthenaToolbarFrame support functions
    void    _OnFocusChange(UINT itb);
    UINT    FindTBar(IUnknown* punkSrc);
    void    ReleaseToolbarItem(int itb, BOOL fClose);
    void    ResizeNextBorder(UINT itb);
    void    GetClientArea(LPRECT prc);

    void    SetFolderType(FOLDERID idFolder);
    void    DeferedLanguageMenu();

    HRESULT LoadLayoutSettings(void);
    HRESULT SaveLayoutSettings(void);

    /////////////////////////////////////////////////////////////////////////
    //
    // Callback Functions
    //
    // Note: All callbacks must be made static members to avoid having the 
    //       implicit "this" pointer passed as the first parameter.
    //
    static LRESULT CALLBACK EXPORT_16 BrowserWndProc(HWND, UINT, WPARAM, LPARAM);
                                          
    /////////////////////////////////////////////////////////////////////////
    //
    // Message Handling
    //
    LRESULT WndProc(HWND, UINT, WPARAM, LPARAM);
    BOOL    OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void    OnSize(HWND hwnd, UINT state, int cxClient, int cyClient);
    void    OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos, BOOL fSystemMenu);
    HRESULT OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void    SpoolerDeliver(WPARAM wParam, LPARAM lParam);
    void    EnableMenuCallback(HMENU hMenu, UINT wID);
    void    FrameActivatePopups(BOOL fActive);
    void    UpdateStatusBar(void);

    HRESULT CmdSendReceieveAccount(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdDeleteAccel(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    BOOL    _InitToolbars();
    void    _ResetMenu(FOLDERTYPE ftNew, BOOL fHideHotMail);
    HRESULT _CheckAndWriteUnreadNumber(DWORD dwSrvTypes);
    DWORD   _GetNumberOfUnreadMsg(IMessageFolder *pFolder);
    inline  void    _AppendIdentityName(LPCTSTR pszIdentityName, LPSTR pszName);

private:
    /////////////////////////////////////////////////////////////////////////
    // 
    // Private Data
    //

    /////////////////////////////////////////////////////////////////////////
    // Shell Stuff
    UINT                m_cRef;
    HWND                m_hwnd;                       // Our window
    IViewWindow        *m_pView;
    IOleCommandTarget  *m_pViewCT;
    HWND                m_hwndInner;
    FOLDERTYPE          m_ftSel;
    FOLDERID            m_idSelected;
    BOOL                m_fPainted;
    HICON               m_hIconPhone,
                        m_hIconError,
                        m_hIconAthena,
                        m_hIconOffline,
                        m_hIcon,
                        m_hIconSm;
    BOOL                m_fRebuildAccountMenu,
                        m_fInitNewAcctMenu,
                        m_fInternal;
    HMENU               m_hMenu;
    HWNDLIST            m_hlDisabled;
    BOOL                m_fNoModifyAccts;

    /////////////////////////////////////////////////////////////////////////
    // Child support
    CTreeView          *m_pTreeView;
    CStatusBar         *m_pStatus;
    CBands              *m_pCoolbar;
    CBodyBar           *m_pBodyBar;
    CFolderBar         *m_pFolderBar;
    HWND                m_hwndLastFocus;
    CNavPane           *m_pNavPane;

    TCHAR               m_szName[CCHMAX_STRINGRES];

    /////////////////////////////////////////////////////////////////////////
    // Layout members
    struct SToolbarItem {
        IDockingWindow      *ptbar;
        IOleCommandTarget   *pOleCmdTarget;
        BORDERWIDTHS        rcBorderTool;
        DWORD               fShow;
    };
    SToolbarItem        m_rgTBar[ITB_MAX];

    UINT                m_itbLastFocus;   // last one called OnFocusChange (can be ITB_NONE)

    LAYOUT              m_rLayout;

    /////////////////////////////////////////////////////////////////////////
    // Mail stuff
    ULONG               m_cAcctMenu;
    LPACCTMENU          m_pAcctMenu;
    BOOL                m_fAnimate;
    UINT_PTR            m_idClearStatusTimer;

    /////////////////////////////////////////////////////////////////////////
    // View Language Menu
    HMENU               m_hMenuLanguage;
    BOOL                m_fEnvMenuInited;
    /////////////////////////////////////////////////////////////////////////

    IBrowserDoc         *m_pDocObj;
    COutBar             *m_pOutBar;

    DWORD               m_dwIdentCookie;
    BOOL                m_fSwitchIsLogout;

    CAdBar              *m_pAdBar;
};

#define DISPID_MSGVIEW_BASE                 1000

#define DISPID_MSGVIEW_TOOLBAR              (DISPID_MSGVIEW_BASE + 1)
#define DISPID_MSGVIEW_STATUSBAR            (DISPID_MSGVIEW_BASE + 2)
#define DISPID_MSGVIEW_FOLDERBAR            (DISPID_MSGVIEW_BASE + 4)
#define DISPID_MSGVIEW_FOLDERLIST           (DISPID_MSGVIEW_BASE + 5)
#define DISPID_MSGVIEW_TIPOFTHEDAY          (DISPID_MSGVIEW_BASE + 6)
#define DISPID_MSGVIEW_INFOPANE             (DISPID_MSGVIEW_BASE + 7)
#define DISPID_MSGVIEW_PREVIEWPANE_MAIL     (DISPID_MSGVIEW_BASE + 8)
#define DISPID_MSGVIEW_PREVIEWPANE_NEWS     (DISPID_MSGVIEW_BASE + 9)
#define DISPID_MSGVIEW_FOLDER               (DISPID_MSGVIEW_BASE + 10)
#define DISPID_MSGVIEW_OUTLOOK_BAR          (DISPID_MSGVIEW_BASE + 11)
#define DISPID_MSGVIEW_CONTACTS             (DISPID_MSGVIEW_BASE + 12)
#define DISPID_MSGVIEW_FILTERBAR            (DISPID_MSGVIEW_BASE + 13)

/////////////////////////////////////////////////////////////////////////////
// Drop Down treeview support
void RegisterGlobalDropDown(HWND hwndCtrl);
void UnregisterGlobalDropDown(HWND hwndCtrl);
void CancelGlobalDropDown();
HWND HwndGlobalDropDown();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\bmapi.cpp ===
#include <pch.hxx>
#include "demand.h" 
#include <bmapi.h>




#define FBadCh(c)		((c) - ' ' > 64)
#define DEC(c)			((BYTE) (((c) - ' ') & 0x3f))

/* uuencode/decode a binary string */
#define ENC(c)			((BYTE) ((c) ? ((c) & 0x3f) + ' ': '`'))

int rgLeft[3] = { 0, 2, 3 };




typedef USHORT		CCH;




STDAPI_(BOOL) FDecodeID(LPTSTR sz, LPBYTE pb, ULONG *pcb);
STDAPI_(int) CchEncodedLine(int cb);
STDAPI_(ULONG) CbOfEncoded(LPTSTR sz);
ERR ErrSzToBinaryEID( LPSTR lpstrEID, ULONG * lpcbEID, LPVOID * lppvEID );
LPSTR FAR PASCAL LpstrFromBstrA( BSTR bstrSrc, LPSTR lpstrDest );
LPSTR FAR PASCAL LpstrFromBstr( BSTR bstrSrc, LPSTR lpstrDest );
int FAR PASCAL FBMAPIFreeStruct (LPVOID lpMapiIn, ULONG uCount, USHORT usFlag);
ULONG PASCAL VB2Mapi( LPVOID lpVBIn, LPVOID lpMapiIn, ULONG uCount, USHORT usFlag );
LPMAPI_MESSAGE FAR PASCAL vbmsg2mapimsg( LPVB_MESSAGE lpVBMessage, LPSAFEARRAY lpsaVBRecips, LPSAFEARRAY lpsaVBFiles, ULONG * pulErr );
ERR FAR PASCAL ErrLpstrToBstrA( LPSTR cstr, BSTR * lpBstr );
ERR FAR PASCAL ErrLpstrToBstr( LPSTR cstr, BSTR * lpBstr );
STDAPI_(void) EncodeID(LPBYTE pb, ULONG cb, LPTSTR sz);
STDAPI_(ULONG) CchOfEncoding(ULONG cbBinary);
ERR ErrBinaryToSzEID( LPVOID lpvEID, ULONG cbEID, LPSTR * lppstrEID );
ULONG PASCAL Mapi2VB (LPVOID lpMapiIn, LPVOID lpVBIn, ULONG uCount, USHORT usFlag);















/*---------------------------------------------------------------------
 *
 *                 Copyright Microsoft Corporation, 1992
 *    _______________________________________________________________
 *
 *    PROGRAM: BMAPI.CPP
 *
 *    PURPOSE: Contains library routines VB MAPI wrappers
 *
 *    FUNCTIONS:
 *                BMAPISendMail
 *                BMAPIFindNext
 *                BMAPIReadMail
 *                BMAPIGetReadMail
 *                BMAPISaveMail
 *                BMAPIAddress
 *                BMAPIGetAddress
 *                BMAPIResolveName
 *                BMAPIDetails
 *
 *    MISCELLANEOUS:
 *
 *    -  All BMAPI procedures basically follow the same structure as
 *       follows;
 *
 *              BMAPI_ENTRY BMAPIRoutine (...)
 *              {
 *                  Allocate C Structures
 *                  Translate VB structures to C structures
 *                  Call MAPI Procedure
 *                  Translate C structures to VB Structures
 *                  DeAllocate C Structures
 *                  Return
 *              }
 *
 *
 *    REVISION HISTORY:
 *     
 *    - Last modified by v-snatar
 *
 *
 *      _____________________________________________________________
 *
 *                 Copyright Microsoft Corporation, 1992-1997
 *
 *----------------------------------------------------------------------*/

//---------------------------------------------------------------------------
// Name:		BMAPISendMail()
//
// Description:
//				32 bit support for VB MAPISendMail().
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPISendMail (LHANDLE 			hSession,
                           ULONG_PTR		ulUIParam,
                           LPVB_MESSAGE 	lpM,
                           LPSAFEARRAY * 	lppsaRecips,
                           LPSAFEARRAY * 	lppsaFiles,
                           ULONG 			flFlags,
                           ULONG 			ulReserved)
{
    ULONG                   ulRet = SUCCESS_SUCCESS;
    LPMAPI_MESSAGE          lpMail = NULL;


    //  Translate VB data into C data.

    if ((lpMail = vbmsg2mapimsg( lpM, *lppsaRecips, *lppsaFiles, &ulRet )) == NULL)
        return ulRet;
    

    // Call MAPI Procedure

    ulRet = MAPISendMail( hSession,      // session
                         ulUIParam,     // UIParam
                         lpMail,        // Mail
                         flFlags,       // Flags
                         ulReserved );  // Reserved

    // Free up data allocated by call to vbmsg2mapimsg

    FBMAPIFreeStruct(lpMail, 1, MESSAGE);
    return ulRet;
   }

//---------------------------------------------------------------------------
// Name:		BMAPIFindNext()
//
// Description:
//				Implements FindNext MAPI API.
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPIFindNext( LHANDLE 		hSession,    	// Session
                           ULONG_PTR	ulUIParam,     	// UIParam
                           BSTR *		lpbstrType,     // MessageType
                           BSTR *		lpbstrSeed,     // Seed message Id
                           ULONG 		flFlags,       	// Flags
                           ULONG 		ulReserved,    	// Reserved
                           BSTR * 		lpbstrId)       // Message Id (in/out)
{
    ULONG           ulRet;
    LPSTR           lpID = NULL;
    LPSTR           lpSeed;
    LPSTR           lpTypeArg;


    // Translate VB strings into C strings.  We'll deallocate
    // the strings before we return.

	// Always allocate the MessageID string.  This way we can redimension
	// it to fit the returned size.  We'll never use the caller's buffer.
	// It turns out the VBSetHlstr call (from ErrLpstrToHlstr) will reassign
	// the string for us.

    if (!MemAlloc((LPVOID*)&lpID, 513))
        return MAPI_E_INSUFFICIENT_MEMORY;


    lpSeed = LpstrFromBstrA( *lpbstrSeed, NULL);
    lpTypeArg = LpstrFromBstrA( *lpbstrType, NULL);

    // Call MAPI Procedure

	ulRet = MAPIFindNext( hSession,      // Session
                         ulUIParam,     // UIParam
                         lpTypeArg,     // Message Type
                         lpSeed,        // Seed Message Id
                         flFlags,       // Flags,
                         ulReserved,    // Reserved
                         lpID );        // Message ID

    // Translate Message ID into VB string

    if ( ulRet == SUCCESS_SUCCESS )
        ErrLpstrToBstrA( lpID, lpbstrId);


    // Free up C strings allocated by call to LpstrFromHlstr

    SafeMemFree( lpID );
    SafeMemFree( lpSeed );
    SafeMemFree( lpTypeArg );

    return ulRet;
}


//---------------------------------------------------------------------------
// Name:		BMAPIReadMail()
//
// Description:
//
// 				Implements MAPIReadMail VB API.  The memory allocated by
// 				MAPIReadMail is NOT deallocated (with MAPIFreeBuffer) until
//				the	caller calls BMAPIGetReadMail.  The recipient and file
//				count is returned so that the caller can Re-dimension buffers
//				before calling BMAPI GetReadMail.  A long pointer to the
//				ReadMail data is also returned since it is required in the
//				BAMPIGetReadMail call.

// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPIReadMail( PULONG_PTR	lpulMessage, 	// pointer to output data (out)
                           LPULONG 		nRecips,     	// number of recipients (out)
                           LPULONG 		nFiles,      	// number of file attachments (out)
                           LHANDLE 		hSession,    	// Session
                           ULONG_PTR	ulUIParam,     	// UIParam
                           BSTR *		lpbstrID,       // Message Id
                           ULONG 		flFlags,       	// Flags
                           ULONG 		ulReserved )    // Reserved
{
    LPSTR               lpID;
    ULONG               ulRet;
    LPMAPI_MESSAGE      lpMail = NULL;


    // Translate VB String to C String

    lpID = LpstrFromBstrA( *lpbstrID, NULL );

    // Read the message, lpMail is set by MAPI to point
    // to the memory allocated by MAPI.

    ulRet = MAPIReadMail( hSession,          	// Session
                         ulUIParam,         	// UIParam
                         lpID,              	// Message Id
                         flFlags,           	// Flags
                         ulReserved,        	// Reserved
                         &lpMail ); 	// Pointer to MAPI Data (returned)

    // Check for read error return code

    if ( ulRet != SUCCESS_SUCCESS )
    {
          // Clean up.  Set return message to zero

          *lpulMessage = 0L;
          SafeMemFree( lpID );
          return ulRet;
    }

    // Pull out the recipient and file array re-dim info

    *nFiles = lpMail->nFileCount;
    *nRecips = lpMail->nRecipCount;
    *lpulMessage = (ULONG_PTR) (LPVOID) lpMail;

    SafeMemFree( lpID );
	return ulRet;
}


//---------------------------------------------------------------------------
// Name:		BMAPIGetReadMail()
//
// Description:
//
// 				Copies data stored by MAPI ReadMail (see BMAPIReadMail)
// 				into a VB Buffer passed by the caller.  It is up to the
//				caller to make sure the buffer passed is large enough to
//				accomodate the data.
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPIGetReadMail( ULONG 		lpMessage,	 // Pointer to MAPI Mail
                              LPVB_MESSAGE	lpvbMessage, // Pointer to VB Message Buffer (out)
                              LPSAFEARRAY * lppsaRecips, // Pointer to VB Recipient Buffer (out)
                              LPSAFEARRAY * lppsaFiles,  // Pointer to VB File attachment Buffer (out)
                              LPVB_RECIPIENT lpvbOrig)   // Pointer to VB Originator Buffer (out)
{
    ULONG 			ulRet = SUCCESS_SUCCESS;
    ERR 			errVBrc;
    LPMAPI_MESSAGE 	lpMail;

    lpMail = (LPMAPI_MESSAGE)((ULONG_PTR)lpMessage);
	if ( !lpMail )
		return MAPI_E_INSUFFICIENT_MEMORY;

    // copy Attachment info to callers VB Buffer

    if (ulRet = Mapi2VB( lpMail->lpFiles, *lppsaFiles, lpMail->nFileCount, FILE ))
    {
		MAPIFreeBuffer(lpMail);
        return ulRet;
    }

    // copy Recipient info to callers VB Buffer

    if ( ulRet = Mapi2VB( lpMail->lpRecips, *lppsaRecips, lpMail->nRecipCount, RECIPIENT | USESAFEARRAY ) )
    {
		MAPIFreeBuffer( lpMail );
        return ulRet;
    }

    // Copy MAPI Message to callers VB Buffer

    errVBrc = 0;

	if ( lpMail->lpOriginator )
	{
	    lpvbOrig->ulReserved    = lpMail->lpOriginator->ulReserved;
	    lpvbOrig->ulRecipClass  = MAPI_ORIG;

	    if ( lpMail->lpOriginator->lpszName )
	        errVBrc = (ERR)(errVBrc + ErrLpstrToBstrA( lpMail->lpOriginator->lpszName, &lpvbOrig->bstrName ));

	    if ( lpMail->lpOriginator->lpszAddress )
	        errVBrc = (ERR)(errVBrc + ErrLpstrToBstrA( lpMail->lpOriginator->lpszAddress, &lpvbOrig->bstrAddress ));

	    if (lpMail->lpOriginator->ulEIDSize)
	    {
			LPSTR	lpStrEID;

			// Hexize recipient EID and convert to OLE BSTR

			if ( ErrBinaryToSzEID( lpMail->lpOriginator->lpEntryID,
					lpMail->lpOriginator->ulEIDSize,  &lpStrEID ) )
			{
				errVBrc = TRUE;
				goto exit;
			}

			// To figure out size first convert to UNICODE

			errVBrc = ErrLpstrToBstr( lpStrEID, &lpvbOrig->bstrEID );
			if ( errVBrc )
			{
				goto exit_orig;
			}

        	lpvbOrig->ulEIDSize = SysStringByteLen( lpvbOrig->bstrEID )
        			+ sizeof(OLECHAR);

			SysFreeString( lpvbOrig->bstrEID );

	        errVBrc = (ERR)(errVBrc + ErrLpstrToBstrA( lpStrEID, &lpvbOrig->bstrEID ));

exit_orig:

			SafeMemFree( lpStrEID );
	    }
	}

    lpvbMessage->flFlags    = lpMail->flFlags;
    lpvbMessage->ulReserved = lpMail->ulReserved;
    lpvbMessage->nRecipCount = lpMail->nRecipCount;
    lpvbMessage->nFileCount = lpMail->nFileCount;

    if (lpMail->lpszSubject)
        errVBrc = (ERR)(errVBrc + ErrLpstrToBstrA( lpMail->lpszSubject, &lpvbMessage->bstrSubject));

    if (lpMail->lpszNoteText)
        errVBrc = (ERR)(errVBrc + ErrLpstrToBstrA( lpMail->lpszNoteText, &lpvbMessage->bstrNoteText));

    if (lpMail->lpszMessageType)
        errVBrc = (ERR)(errVBrc + ErrLpstrToBstrA( lpMail->lpszMessageType, &lpvbMessage->bstrMessageType));

    if (lpMail->lpszDateReceived)
        errVBrc = (ERR)(errVBrc + ErrLpstrToBstrA( lpMail->lpszDateReceived, &lpvbMessage->bstrDate));

exit:

	MAPIFreeBuffer( lpMail );

	if ( errVBrc )
		ulRet = MAPI_E_FAILURE;

    return ulRet;
}


//---------------------------------------------------------------------------
// Name:		BMAPISaveMail()
//
// Description:
//				Implements MAPISaveMail API.
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPISaveMail( LHANDLE 			hSession,   	// Session
                           ULONG_PTR		ulUIParam,  	// UIParam
                           LPVB_MESSAGE 	lpM,        	// Pointer to VB Message Buffer
                           LPSAFEARRAY *	lppsaRecips,   	// Pointer to VB Recipient Buffer
                           LPSAFEARRAY *	lppsaFiles,    	// Pointer to VB File Attacment Buffer
                           ULONG 			flFlags,    	// Flags
                           ULONG 			ulReserved, 	// Reserved
                           BSTR * 			lpbstrID)   	// Message ID
{
    LPSTR 			lpID;
    ULONG 			ulRet= SUCCESS_SUCCESS;
    LPMAPI_MESSAGE 	lpMail;


    // Translate VB data to MAPI data

    lpID = LpstrFromBstrA( *lpbstrID, NULL );

	// If we allocate Message ID then we can set the flag.
	// otherwise for backward compatability assume the callers buffer size.

	if ( lpID == NULL )
	{
	    if (!MemAlloc((LPVOID*)&lpID,  513))
            return MAPI_E_INSUFFICIENT_MEMORY;
	}

    if ( (lpMail = vbmsg2mapimsg( lpM, *lppsaRecips, *lppsaFiles, &ulRet )) == NULL )
	{
        SafeMemFree( lpID );
        return ulRet;
    }

    ulRet = MAPISaveMail( hSession,
                         ulUIParam,
                         lpMail,
						 flFlags,
                         ulReserved,
                         lpID );

	if ( ulRet )
		goto exit;

    if ( ErrLpstrToBstrA( lpID, lpbstrID ) )
		ulRet = MAPI_E_INSUFFICIENT_MEMORY;

exit:
    SafeMemFree( lpID );
    FBMAPIFreeStruct( lpMail, 1, MESSAGE );


	return ulRet;
}

//---------------------------------------------------------------------------
// Name:		BMAPIAddress()
//
// Description:
//
// 				Purpose: Allows Visual Basic to call MAPIAddress.  The
//				Recipient data is stored in a global memory block.  To
//				retrieve the data the caller must call BMAPIGetAddress.
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPIAddress( PULONG_PTR		lpulRecip,       // Pointer to New Recipient Buffer (out)
                          LHANDLE 			hSession,        // Session
                          ULONG_PTR			ulUIParam,       // UIParam
                          BSTR *			lpbstrCaption,   // Caption string
                          ULONG 			ulEditFields,    // Number of Edit Controls
                          BSTR * 			lpbstrLabel,     // Label string
                          LPULONG 			lpulRecipients,  // Pointer to number of Recipients (in/out)
                          LPSAFEARRAY *		lppsaRecip, 	 // Pointer to Initial Recipients VB_RECIPIENT
                          ULONG 			ulFlags,         // Flags
                          ULONG 			ulReserved )     // Reserve
{
    LPSTR 				lpLabel = NULL;
    LPSTR 				lpCaption = NULL;
    ULONG 				ulRet;
    ULONG 				nRecipients = 0;
    LPMAPI_RECIPIENT 	lpMapi = NULL;
    LPMAPI_RECIPIENT 	lpNewRecipients	= NULL;

    // Convert VB Strings to C strings

    lpLabel   = LpstrFromBstrA( *lpbstrLabel, NULL );
    lpCaption = LpstrFromBstrA( *lpbstrCaption, NULL );

    // Allocate memory and translate VB_RECIPIENTS to MAPI_RECIPIENTS.

	if ( *lpulRecipients )
	{
	    if (!MemAlloc((LPVOID*)&lpMapi, (*lpulRecipients	* sizeof (MAPI_RECIPIENT))))
            return MAPI_E_INSUFFICIENT_MEMORY;
	}

    if ( ulRet = VB2Mapi( (LPVOID)*lppsaRecip, (LPVOID)lpMapi, *lpulRecipients, RECIPIENT | USESAFEARRAY ) )
    {
        SafeMemFree( lpLabel );
        SafeMemFree( lpCaption );
        FBMAPIFreeStruct( lpMapi, *lpulRecipients, RECIPIENT );
        return ulRet;
    }

    // Call the MAPIAddress function

    ulRet = MAPIAddress(	hSession,           	// Session
                        ulUIParam,          	// UIParam
                        lpCaption,          	// Caption
                        ulEditFields,       	// Number of edit fields
                        lpLabel,            	// Label
                        *lpulRecipients,    	// Number of Recipients
                        lpMapi,             	// Pointer to recipients
                        ulFlags,            	// Flags
                        ulReserved,         	// Reserved
                        (LPULONG) &nRecipients, // Address for new recipient count
                        (lpMapiRecipDesc far *)&lpNewRecipients);  // Address of new recipient data

    // Free up MAPI structures created in this procedure

    SafeMemFree( lpLabel );
    SafeMemFree( lpCaption );
    FBMAPIFreeStruct( lpMapi, *lpulRecipients, RECIPIENT );

    // Set the returned parameters and return

    if ( ulRet == SUCCESS_SUCCESS )
    {
        *lpulRecipients = nRecipients;
        *lpulRecip = (ULONG_PTR) (LPVOID) lpNewRecipients;
    }

	return ulRet;
}

//---------------------------------------------------------------------------
// Name:		BMAPIGetAddress()
//
// Description:
//				Converts a MapiRecipDesc array into an OLE 2.0 SAFEARRAY.
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPIGetAddress (ULONG 			ulRecipientData, // Pointer to recipient data
                             ULONG 			cRecipients,     // Number of recipients
							 LPSAFEARRAY *	lppsaRecips )	 // VB recipient array
{
    ULONG				ulRet = SUCCESS_SUCCESS;
    LPMAPI_RECIPIENT 	lpData = NULL;

    if (cRecipients == 0)
	{
		MAPIFreeBuffer( (LPVOID)((ULONG_PTR)ulRecipientData) );
        return SUCCESS_SUCCESS;
	}

    lpData = (LPMAPI_RECIPIENT)((ULONG_PTR)ulRecipientData);

    // Translate MAPI Address data to VB buffer

	ulRet = Mapi2VB( lpData, *lppsaRecips, cRecipients, RECIPIENT | USESAFEARRAY );

	// Free up MAPI recipient data since it got copied over.

	MAPIFreeBuffer( lpData );
	return ulRet;
}


//---------------------------------------------------------------------------
// Name:		BMAPIDetails()
//
// Description:
//				Allows VB to call MAPIDetails procedure.
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPIDetails (LHANDLE 			hSession,   // Session
                          ULONG_PTR			ulUIParam, 	// UIParam
                          LPVB_RECIPIENT	lpVB,  		// Pointer to VB recipient stucture
                          ULONG 			ulFlags,    // Flags
                          ULONG 			ulReserved) // Reserved

{
    ULONG            ulRet;
    LPMAPI_RECIPIENT lpMapi	= NULL;


    // Translate VB_RECIPIENTS to MAPI_RECIPIENTS.

    if (!MemAlloc((LPVOID*)&lpMapi,sizeof (MAPI_RECIPIENT)))
        return MAPI_E_INSUFFICIENT_MEMORY;

    if ( ulRet = VB2Mapi( lpVB, lpMapi, 1, RECIPIENT ) )
    {
        FBMAPIFreeStruct( lpMapi, 1, RECIPIENT );
        return ulRet;
    }

    // Call the Simple MAPI function

    ulRet = MAPIDetails( hSession,     // Session
                        ulUIParam,    // UIParam
                        lpMapi,       // Pointer to MAPI Recipient structure
                        ulFlags,      // Flags
                        ulReserved ); // Reserved

    FBMAPIFreeStruct( lpMapi, 1L, RECIPIENT );
    return ulRet;
}

//---------------------------------------------------------------------------
// Name:		BMAPIResolveName
//
// Description:
//				Implements VB MAPIResolveName
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BMAPI_ENTRY BMAPIResolveName (LHANDLE 			hSession,     // Session
                              ULONG_PTR			ulUIParam,    // UIParam
                              BSTR 				bstrMapiName, // Name to be resolved
                              ULONG 			ulFlags,      // Flags
                              ULONG 			ulReserved,   // Reserved
                              LPVB_RECIPIENT	lpVB)  		  // Pointer to VB recipient structure (out)

{
    LPMAPI_RECIPIENT	lpMapi = NULL;
    ULONG 				ulRet;
	LPSTR				lpszMapiName;


    lpszMapiName = LpstrFromBstrA( bstrMapiName, NULL );

    // Call the MAPIResolveName function

    ulRet = MAPIResolveName( hSession,   					// Session
                            ulUIParam,  					// UIParam
                            lpszMapiName, 					// Pointer to resolve name
                            ulFlags,    					// Flags
                            ulReserved, 					// Reserved
                           (LPPMAPI_RECIPIENT) &lpMapi ); 	// Pointer to Recipient (returned)

    if (ulRet != SUCCESS_SUCCESS)
        return ulRet;


	// Translate MAPI data to VB data

	ulRet = Mapi2VB( lpMapi, lpVB, 1, RECIPIENT );

	MAPIFreeBuffer( lpMapi );
	return ulRet;
}




// Helper Functions

//---------------------------------------------------------------------------
// Name:		vbmsg2mapimsg()
//
// Description:
// 				Translates VB Message structure to MAPI Message structure
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
LPMAPI_MESSAGE FAR PASCAL vbmsg2mapimsg( LPVB_MESSAGE lpVBMessage, LPSAFEARRAY lpsaVBRecips,
		LPSAFEARRAY lpsaVBFiles, ULONG * pulErr )

{
    LPMAPI_FILE lpMapiFile=NULL;
    LPMAPI_MESSAGE lpMapiMessage=NULL;
    LPMAPI_RECIPIENT lpMapiRecipient=NULL;

    if (lpVBMessage == (LPVB_MESSAGE) NULL)
    {
    	*pulErr = MAPI_E_FAILURE;
        return NULL;
    }

    // Allocate MAPI Message, Recipient and File structures
    // NOTE: Don't move the following lines of code without
    // making sure you de-allocate memory properly if the
    // calls fail.

	if (!MemAlloc((LPVOID*)&lpMapiMessage,sizeof(MapiMessage)))
	{
		*pulErr = MAPI_E_INSUFFICIENT_MEMORY;
        return NULL;
	}

    if (lpVBMessage->nFileCount > 0)
    {
        if (!MemAlloc((LPVOID*)&lpMapiFile, sizeof(MAPI_FILE)*lpVBMessage->nFileCount))
        {
            FBMAPIFreeStruct( (LPVOID*)&lpMapiMessage, 1, MESSAGE );
			*pulErr = MAPI_E_INSUFFICIENT_MEMORY;
            return NULL;
        }
    }

    if (lpVBMessage->nRecipCount > 0)
    {
        if (!MemAlloc((LPVOID*)&lpMapiRecipient, sizeof(MAPI_RECIPIENT)*lpVBMessage->nRecipCount))
        {
            FBMAPIFreeStruct( lpMapiFile, lpVBMessage->nFileCount, FILE );
            FBMAPIFreeStruct( lpMapiMessage, 1, MESSAGE );
			*pulErr = MAPI_E_INSUFFICIENT_MEMORY;
            return NULL;
        }
    }

    // Translate structures from VB to MAPI

    if ( *pulErr = VB2Mapi( lpsaVBFiles, lpMapiFile, lpVBMessage->nFileCount, FILE | USESAFEARRAY ) )
    {
        FBMAPIFreeStruct( lpMapiFile, lpVBMessage->nFileCount, FILE );
        FBMAPIFreeStruct( lpMapiRecipient, lpVBMessage->nRecipCount, RECIPIENT );
        FBMAPIFreeStruct( lpMapiMessage, 1, MESSAGE );
        return NULL;
    }

    if ( *pulErr = VB2Mapi( lpsaVBRecips, lpMapiRecipient, lpVBMessage->nRecipCount, RECIPIENT | USESAFEARRAY ) )
    {
        FBMAPIFreeStruct( lpMapiFile, lpVBMessage->nFileCount, FILE );
        FBMAPIFreeStruct( lpMapiRecipient, lpVBMessage->nRecipCount, RECIPIENT );
        FBMAPIFreeStruct( lpMapiMessage, 1, MESSAGE );
        return NULL;
    }

    if ( *pulErr = VB2Mapi( lpVBMessage, lpMapiMessage, 1, MESSAGE ) )
    {
        FBMAPIFreeStruct( lpMapiFile, lpVBMessage->nFileCount, FILE );
        FBMAPIFreeStruct( lpMapiRecipient, lpVBMessage->nRecipCount, RECIPIENT );
        FBMAPIFreeStruct( lpMapiMessage, 1, MESSAGE );
        return NULL;
    }

    // Chain File and Recipient structures to Message structure

    lpMapiMessage->lpFiles = lpMapiFile;
    lpMapiMessage->lpRecips = lpMapiRecipient;

    return lpMapiMessage;
}


//---------------------------------------------------------------------------
// Name:		VB2Mapi()
//
// Description:
//				Converts VB structures to MAPI structures.  Arrays from
//				VB 4.0 arrive as OLE SAFEARRAYs.
//
// Parameters:
// Returns:
//				Simple MAPI error code
//
// Effects:
// Notes:
//				originally FALSE for failure, TRUE for success.
// Revision:
//---------------------------------------------------------------------------
ULONG PASCAL VB2Mapi( LPVOID lpVBIn, LPVOID lpMapiIn, ULONG uCount, USHORT usFlag )
{
    ULONG 				u;
	HRESULT				hr			= 0;
	ULONG				ulErr		= SUCCESS_SUCCESS;
	ERR					Err			= FALSE;
    LPVB_RECIPIENT 		lpVBR;
    LPMAPI_RECIPIENT 	lpMapiR;
    LPVB_MESSAGE 		lpVBM;
    LPMAPI_MESSAGE 		lpMapiM;
    LPVB_FILE 			lpVBF;
    LPMAPI_FILE 		lpMapiF;
	LPSAFEARRAY			lpsa		= NULL;

    if (lpVBIn == (LPVOID)NULL)
    {
        lpMapiIn = NULL;
        return SUCCESS_SUCCESS;
    }

    if (uCount <= 0)
    {
        lpMapiIn = NULL;
        return SUCCESS_SUCCESS;
    }

    if ( lpMapiIn == (LPVOID)NULL )
        return MAPI_E_FAILURE;

    switch ( usFlag & ~(USESAFEARRAY) )
    {
        case RECIPIENT:
			if ( usFlag & USESAFEARRAY )
			{
				lpsa = (LPSAFEARRAY)lpVBIn;
				hr = SafeArrayAccessData( lpsa, (LPVOID*)&lpVBR );
				if (hr)
				{
					ulErr = MAPI_E_FAILURE;
					goto exit;
				}

				if (!lpVBR || lpsa->rgsabound[0].cElements < uCount)
				{
					(void)SafeArrayUnaccessData( lpsa );
					ulErr = MAPI_E_INVALID_RECIPS;
					goto exit;
				}
			}
			else
			{
				lpVBR = (LPVB_RECIPIENT)lpVBIn;
			}

            lpMapiR = (LPMAPI_RECIPIENT)lpMapiIn;

            for ( u = 0L; u < uCount; u++, lpMapiR++, lpVBR++ )
            {
                lpMapiR->ulReserved   = lpVBR->ulReserved;
                lpMapiR->ulRecipClass = lpVBR->ulRecipClass;

				if ( usFlag & USESAFEARRAY )
				{
	                lpMapiR->lpszName     = LpstrFromBstr( lpVBR->bstrName, NULL );
	                lpMapiR->lpszAddress  = LpstrFromBstr( lpVBR->bstrAddress, NULL );
				}
				else
				{
	                lpMapiR->lpszName     = LpstrFromBstrA( lpVBR->bstrName, NULL );
	                lpMapiR->lpszAddress  = LpstrFromBstrA( lpVBR->bstrAddress, NULL );
				}

                if (lpVBR->ulEIDSize > 0L)
                {
					LPSTR	lpStrT;

					// Convert EID string from OLE Bstr...

                    if ( usFlag & USESAFEARRAY )
                    {
						if ( IsBadReadPtr( lpVBR->bstrEID, lpVBR->ulEIDSize ) )
						{
							ulErr = MAPI_E_INVALID_RECIPS;
							goto exit;
						}

                    	lpStrT = LpstrFromBstr( lpVBR->bstrEID, NULL );
                    }
					else
					{
						// VB 4.0 took care of translating Wide Char to Multibyte.

						// ulEIDSize is still based on UNICODE byte size.  Take
						// smallest approximation.

						if ( IsBadReadPtr( lpVBR->bstrEID, lpVBR->ulEIDSize / 2 ) )
						{
							ulErr = MAPI_E_INVALID_RECIPS;
							goto exit;
						}

                    	lpStrT = LpstrFromBstrA( lpVBR->bstrEID, NULL );
					}

					// and UnHexize.

					if ( lpStrT )
					{
						Err = ErrSzToBinaryEID( lpStrT, &lpMapiR->ulEIDSize,
								&lpMapiR->lpEntryID );

						SafeMemFree(lpStrT );

						if ( Err )
						{
							ulErr = MAPI_E_INVALID_RECIPS;
							goto exit;
						}

					}
                }
                else
                    lpMapiR->lpEntryID = (LPVOID) NULL;
            }

			if ( usFlag & USESAFEARRAY )
				(void)SafeArrayUnaccessData( lpsa );

            break;

        case FILE:
			lpsa = (LPSAFEARRAY)lpVBIn;
			hr = SafeArrayAccessData( lpsa, (LPVOID*)&lpVBF );
			if ( hr )
			{
				ulErr = MAPI_E_FAILURE;
				goto exit;
			}

			if ( !lpVBF || lpsa->rgsabound[0].cElements < uCount )
			{
				(void)SafeArrayUnaccessData( lpsa );
                ulErr = MAPI_E_ATTACHMENT_NOT_FOUND;
				goto exit;
			}

            lpMapiF = (LPMAPI_FILE)lpMapiIn;

            for (u = 0L; u < uCount; u++, lpMapiF++, lpVBF++)
            {
                lpMapiF->ulReserved 	= lpVBF->ulReserved;
                lpMapiF->flFlags 		= lpVBF->flFlags;
                lpMapiF->nPosition 		= lpVBF->nPosition;
                lpMapiF->lpszPathName	= LpstrFromBstr( lpVBF->bstrPathName, NULL );
                lpMapiF->lpszFileName 	= LpstrFromBstr( lpVBF->bstrFileName, NULL );
                lpMapiF->lpFileType 	= LpstrFromBstr( lpVBF->bstrFileType, NULL);
            }

			(void)SafeArrayUnaccessData( lpsa );

            break;

        case MESSAGE:
            lpVBM = (LPVB_MESSAGE) lpVBIn;
            lpMapiM = (LPMAPI_MESSAGE) lpMapiIn;

            lpMapiM->ulReserved         = lpVBM->ulReserved;
            lpMapiM->flFlags            = lpVBM->flFlags;
            lpMapiM->nRecipCount        = lpVBM->nRecipCount;
            lpMapiM->lpOriginator       = NULL;
            lpMapiM->nFileCount         = lpVBM->nFileCount;
            lpMapiM->lpRecips           = NULL;
            lpMapiM->lpFiles            = NULL;

			// errors are ignored

            lpMapiM->lpszSubject        = LpstrFromBstrA( lpVBM->bstrSubject, NULL );
            lpMapiM->lpszNoteText       = LpstrFromBstrA( lpVBM->bstrNoteText, NULL );
            lpMapiM->lpszConversationID = LpstrFromBstrA( lpVBM->bstrConversationID, NULL );
            lpMapiM->lpszDateReceived   = LpstrFromBstrA( lpVBM->bstrDate, NULL );
            lpMapiM->lpszMessageType    = LpstrFromBstrA( lpVBM->bstrMessageType, NULL );

            break;

        default:
            ulErr = MAPI_E_FAILURE;
			goto exit;
    }

exit:

	return ulErr;
}

//---------------------------------------------------------------------------
// Name:		Mapi2VB
//
// Description:
//				Converts MAPI RECIPIENT, FILE, or MESSAGE structures to VB
//				Recipients and Files are handled as OLE SAFEARRAYs.
//
// Parameters:
// Returns:
//				Simple Mapi error code
//
// Effects:
// Notes:
//				originally FALSE for failure, TRUE for success.
// Revision:
//---------------------------------------------------------------------------
ULONG PASCAL Mapi2VB (LPVOID lpMapiIn, LPVOID lpVBIn, ULONG uCount, USHORT usFlag)
{
	HRESULT				hr = 0;
	ERR					Err	= FALSE;
	ULONG				ulErr = SUCCESS_SUCCESS;
    ULONG 				u;
    LPVB_MESSAGE 		lpVBM;
    LPMAPI_MESSAGE 		lpMapiM;
    LPVB_RECIPIENT 		lpVBR;
    LPMAPI_RECIPIENT 	lpMapiR;
    LPVB_FILE 			lpVBF;
    LPMAPI_FILE 		lpMapiF;
	LPSAFEARRAY			lpsa		= NULL;

    // If lpVBIn is NULL, this is a bad thing

    if (lpVBIn == (LPVOID) NULL)
        return MAPI_E_FAILURE;

    // if lpMapiIn is NULL then set
    // lpVBIn to NULL and return success

    if (lpMapiIn == NULL)
    {
        lpVBIn = NULL;
        return SUCCESS_SUCCESS;
    }

    switch ( usFlag & ~(USESAFEARRAY) )
    {
        case RECIPIENT:
			if ( usFlag & USESAFEARRAY )
			{
				lpsa = (LPSAFEARRAY)lpVBIn;
				hr = SafeArrayAccessData( lpsa, (LPVOID*)&lpVBR );
				if (hr)
				{
					ulErr = MAPI_E_FAILURE;
					goto exit;
				}

				if ( !lpVBR || lpsa->rgsabound[0].cElements < uCount )
				{
					(void)SafeArrayUnaccessData(lpsa);
					ulErr = MAPI_E_INVALID_RECIPS;
					goto exit;
				}

			}
			else
			{
				lpVBR = (LPVB_RECIPIENT)lpVBIn;
			}

            lpMapiR = (LPMAPI_RECIPIENT)lpMapiIn;

            for (u = 0L; u < uCount; u++, lpMapiR++, lpVBR++)
            {
                lpVBR->ulReserved    = lpMapiR->ulReserved;
                lpVBR->ulRecipClass  = lpMapiR->ulRecipClass;

				if (usFlag & USESAFEARRAY)
				{
	                if ( ErrLpstrToBstr( lpMapiR->lpszName, &lpVBR->bstrName ) )
					{
						ulErr = MAPI_E_INVALID_RECIPS;
						goto exit;
					}

	                if (Err = ErrLpstrToBstr( lpMapiR->lpszAddress, &lpVBR->bstrAddress ) )
					{
						ulErr = MAPI_E_INVALID_RECIPS;
						goto exit;
					}
				}
				else
				{
	                if ( ErrLpstrToBstrA( lpMapiR->lpszName, &lpVBR->bstrName ) )
	                {
						ulErr = MAPI_E_INVALID_RECIPS;
						goto exit;
	                }


	                if ( ErrLpstrToBstrA( lpMapiR->lpszAddress, &lpVBR->bstrAddress ) )
	                {
						ulErr = MAPI_E_INVALID_RECIPS;
						goto exit;
	                }
				}

                if ( lpMapiR->ulEIDSize > 0L)
                {
					LPSTR	lpStrEID;

					// Convert Recip EID to a hexized string

					if ( ErrBinaryToSzEID( lpMapiR->lpEntryID, lpMapiR->ulEIDSize, &lpStrEID ) )
	                {
						ulErr = MAPI_E_INVALID_RECIPS;
						goto exit;
	                }

					// Convert to a BSTR
					// and figure out the size

                    if ( usFlag & USESAFEARRAY )
                    {
                    	Err = ErrLpstrToBstr( lpStrEID, &lpVBR->bstrEID );
						SafeMemFree( lpStrEID );

						if (Err)
						{
							ulErr = MAPI_E_INVALID_RECIPS;
							goto exit;
						}


	                	lpVBR->ulEIDSize = SysStringByteLen( lpVBR->bstrEID )
	                			+ sizeof(OLECHAR);
                    }
					else
					{
						// To figure out size first convert to UNICODE

						if ( ErrLpstrToBstr( lpStrEID, &lpVBR->bstrEID ) )
						{
							SafeMemFree( lpStrEID );
							ulErr = MAPI_E_INVALID_RECIPS;
							goto exit;
						}

	                	lpVBR->ulEIDSize = SysStringByteLen( lpVBR->bstrEID )
	                			+ sizeof(OLECHAR);

						SysFreeString( lpVBR->bstrEID );

                    	Err = ErrLpstrToBstrA( lpStrEID, &lpVBR->bstrEID );
						SafeMemFree( lpStrEID );
						if ( Err )
						{
							ulErr = MAPI_E_INVALID_RECIPS;
							goto exit;
						}
					}
                }
            }

			if ( usFlag & USESAFEARRAY )
				(void)SafeArrayUnaccessData( lpsa );

            break;

        case FILE:
			lpsa = (LPSAFEARRAY)lpVBIn;
			hr = SafeArrayAccessData( lpsa, (LPVOID*)&lpVBF );
			if ( hr )
			{
				ulErr = MAPI_E_FAILURE;
				goto exit;
			}

			if ( !lpVBF || lpsa->rgsabound[0].cElements < uCount )
			{
				(void)SafeArrayUnaccessData( lpsa );
				ulErr = MAPI_E_FAILURE;
				goto exit;
			}

            lpMapiF = (LPMAPI_FILE) lpMapiIn;

            for (u = 0L; u < uCount; u++, lpMapiF++, lpVBF++)
            {
                lpVBF->ulReserved = lpMapiF->ulReserved;
				lpVBF->flFlags    = lpMapiF->flFlags;
                lpVBF->nPosition  = lpMapiF->nPosition;

                if ( ErrLpstrToBstr( lpMapiF->lpszPathName, &lpVBF->bstrPathName ) )
                {
                	ulErr = MAPI_E_ATTACHMENT_NOT_FOUND;
					goto exit;
                }

                if ( ErrLpstrToBstr( lpMapiF->lpszFileName, &lpVBF->bstrFileName ) )
                {
                	ulErr = MAPI_E_ATTACHMENT_NOT_FOUND;
					goto exit;
                }

                // this is something to keep VBAPI from faulting

                if ( ErrLpstrToBstr( (LPSTR) "", &lpVBF->bstrFileType ) )
                {
                	ulErr = MAPI_E_ATTACHMENT_NOT_FOUND;
					goto exit;
                }
            }

			(void)SafeArrayUnaccessData( lpsa );

            break;

        case MESSAGE:
            lpVBM = (LPVB_MESSAGE)lpVBIn;
            lpMapiM = (LPMAPI_MESSAGE)lpMapiIn;

            lpVBM->ulReserved   = lpMapiM->ulReserved;
            lpVBM->flFlags      = lpMapiM->flFlags;
            lpVBM->nRecipCount  = lpMapiM->nRecipCount;
            lpVBM->nFileCount   = lpMapiM->nFileCount;

            if ( ErrLpstrToBstr( lpMapiM->lpszSubject, &lpVBM->bstrSubject ) )
            {
            	ulErr = MAPI_E_INVALID_MESSAGE;
				goto exit;
            }

            if ( ErrLpstrToBstr( lpMapiM->lpszNoteText, &lpVBM->bstrNoteText ) )
            {
            	ulErr = MAPI_E_INVALID_MESSAGE;
				goto exit;
            }

            if ( ErrLpstrToBstr( lpMapiM->lpszConversationID, &lpVBM->bstrConversationID ) )
            {
            	ulErr = MAPI_E_INVALID_MESSAGE;
				goto exit;
            }

            if ( ErrLpstrToBstr( lpMapiM->lpszDateReceived, &lpVBM->bstrDate ) )
            {
            	ulErr = MAPI_E_INVALID_MESSAGE;
				goto exit;
            }

            if ( ErrLpstrToBstr( lpMapiM->lpszMessageType, &lpVBM->bstrMessageType ) )
            {
            	ulErr = MAPI_E_INVALID_MESSAGE;
				goto exit;
            }

            break;

        default:
            ulErr = MAPI_E_FAILURE;
			goto exit;
    }

exit:
	return ulErr;
}

//---------------------------------------------------------------------------
// Name:			FBMAPIFreeStruct()
//
// Description:
// 					DeAllocates MAPI structure created in VB2MAPI
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
int FAR PASCAL FBMAPIFreeStruct (LPVOID lpMapiIn, ULONG uCount, USHORT usFlag)
{
    ULONG u;
    LPMAPI_RECIPIENT	lpMapiR;
    LPMAPI_FILE 		lpMapiF;
    LPMAPI_MESSAGE 		lpMapiM;

    if (lpMapiIn == (LPVOID) NULL)
        return TRUE;

    switch ( usFlag )
    {
        case RECIPIENT:
            lpMapiR = (LPMAPI_RECIPIENT)lpMapiIn;

            for ( u = 0L; u < uCount; u++, lpMapiR++ )
            {
                SafeMemFree(lpMapiR->lpszName);
                SafeMemFree(lpMapiR->lpszAddress);
                SafeMemFree(lpMapiR->lpEntryID);
            }

            SafeMemFree(lpMapiIn);
            break;

        case FILE:
            lpMapiF = (LPMAPI_FILE) lpMapiIn;

            for ( u = 0L; u < uCount; u++, lpMapiF++ )
            {
                SafeMemFree(lpMapiF->lpszPathName);
                SafeMemFree(lpMapiF->lpszFileName);
                SafeMemFree(lpMapiF->lpFileType);
            }

            SafeMemFree(lpMapiIn);
            break;

        case MESSAGE:
            lpMapiM = ( LPMAPI_MESSAGE ) lpMapiIn;

            if (lpMapiM->lpRecips)
                FBMAPIFreeStruct((LPVOID)lpMapiM->lpRecips, lpMapiM->nRecipCount, RECIPIENT);

            if (lpMapiM->lpFiles)
                FBMAPIFreeStruct((LPVOID) lpMapiM->lpFiles, lpMapiM->nFileCount, FILE);

            SafeMemFree( lpMapiM->lpszSubject );
            SafeMemFree( lpMapiM->lpszNoteText );
            SafeMemFree( lpMapiM->lpszMessageType );
            SafeMemFree( lpMapiM->lpszDateReceived );
            SafeMemFree( lpMapiM->lpszConversationID );
            SafeMemFree( lpMapiM );
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
// Name:		LpstrFromBstr()
//
// Description:
//				Copies and converts OLE Bstr from UNICODE to an ANSI
//				C string.
//
// Parameters:
// Returns:
//				String if successful
//				NULL if failure
// Effects:
// Notes:
//				Note that this function returns NULL for failure as well as
//				a NULL bstr.  This was how the original VB 3.0 implementation
//				worked.
//
// Revision:
//---------------------------------------------------------------------------
LPSTR FAR PASCAL LpstrFromBstr( BSTR bstrSrc, LPSTR lpstrDest )
{
    USHORT cbSrc;

	if ( !bstrSrc )
		return NULL;

    // Copy over the bstr string to a 'C' string

    cbSrc = (USHORT)SysStringLen((OLECHAR *)bstrSrc);

    if (cbSrc == 0)
        return NULL;

	// make sure we handle truly multi byte character sets when
	// we convert from UNICODE to MultiByte.

	cbSrc = (USHORT)((cbSrc + 1) * sizeof(OLECHAR));

    // If Destination is NULL then we'll allocate
    // memory to hold the string.  The caller must
    // deallocate this at some time.

    if ( lpstrDest == NULL )
    {
        if(!MemAlloc((LPVOID*)&lpstrDest, cbSrc))
            return NULL;
    }

	if (!WideCharToMultiByte(CP_ACP, 0, bstrSrc, -1, lpstrDest, cbSrc, NULL, NULL))
	{
		SafeMemFree(lpstrDest);
		lpstrDest = NULL;
	}

    return lpstrDest;
}

//---------------------------------------------------------------------------
// Name:		LpstrFromBstrA
//
// Description:
// 				Copies OLE Bstre ANSI string to C string. Allocates string space
//          	from the global heap and returns a long
//          	pointer to memory. The memory must be freed by the caller
//          	with a call to BMAPIFree.
//
// Parameters:
// Returns:
//				String if successful
//				NULL if failure
//
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------

LPSTR FAR PASCAL LpstrFromBstrA( BSTR bstrSrc, LPSTR lpstrDest )
{
    USHORT cbSrc;

    // If Destination is NULL then we'll allocate memory to hold the
    // string.  The caller must deallocate this at some time.

    cbSrc = (USHORT)SysStringByteLen((OLECHAR *)bstrSrc);

    // Copy over the hlstr string to a 'C' string

    if ( cbSrc == 0 )
        return NULL;

    if ( lpstrDest == NULL )
    {
        if (!MemAlloc((LPVOID*)&lpstrDest, cbSrc + 1))
            return NULL;
    }

    memcpy( lpstrDest, bstrSrc, cbSrc );
    lpstrDest[cbSrc] = '\0';

    return lpstrDest;
}


//---------------------------------------------------------------------------
// Name:		ErrSzToBinaryEID()
//
// Description:
//				Converts a hexized binary string to binary returning
//				the binary data and the size of the data.
//
// Parameters:
// Returns:
//				FALSE	if success.
//				TRUE	if failure.
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
ERR ErrSzToBinaryEID( LPSTR lpstrEID, ULONG * lpcbEID, LPVOID * lppvEID )
{
	ERR		Err		= FALSE;
	ULONG 	cbEID;

	cbEID = CbOfEncoded( lpstrEID );
	if (!MemAlloc(lppvEID, cbEID))
    {
        Err = TRUE;
		goto exit;
	}

	if (!FDecodeID( lpstrEID, (LPBYTE)*lppvEID, lpcbEID ) )
	{
		Err = TRUE;
		SafeMemFree( *lppvEID );
		*lppvEID = NULL;
		goto exit;
	}

exit:

	return Err;
}

/*
 *	Given an string that encodes some binary data, returns the
 *	maximal size of the binary data.
 */
STDAPI_(ULONG) CbOfEncoded(LPTSTR sz)
{
	return (lstrlen(sz) / 4 + 1) * 3;	//	slightly fat
}


/*
 *	Given a byte count, returns the number of characters necessary
 *	to encode that many bytes.
 */
STDAPI_(int) CchEncodedLine(int cb)
{
	Assert(cb <= 45);
	return (cb / 3) * 4 + rgLeft[cb % 3];
}

/*
 -	FDecodeID
 -
 *	Purpose:
 *		Turns a character string produced by EncodeID back to a
 *		byte string. Some validation of the input string is done.
 *
 *	Arguments:
 *		sz				in		The input character string.
 *		pb				out		The decoded byte string. The output
 *								string is not length-checked.
 *		pcb				out		The size of the byte string
 *
 *	Returns:
 *		FALSE => the encoded string was garbled in some way
 *		TRUE  => all OK
 */
STDAPI_(BOOL) FDecodeID(LPTSTR sz, LPBYTE pb, ULONG *pcb)
{
	int		cchLine;
	int		ich;
	CCH		cch = (CCH)lstrlen(sz);
	LPTSTR	szT = sz;

	AssertSz(!IsBadStringPtr(sz, INFINITE), "FDecodeID: sz fails address check");
	AssertSz(!IsBadWritePtr(pb, 1), "FDecodeID: pb fails address check");
	AssertSz(!IsBadWritePtr(pcb, sizeof(ULONG)), "FDecodeID: pcb fails address check");

	*pcb = 0;

	while (*szT)
	{
		//	Process line header
		if (FBadCh(*szT))
			return FALSE;
		ich = DEC(*szT);				//	Byte count for "line"
		*pcb += ich;					//	running total of decoded info
		cchLine = CchEncodedLine(ich);	//	Length-check this "line"
		if (szT + cchLine + 1 > sz + cch)
			return FALSE;
		++szT;

		//	Process line contents
		for (ich = 0; ich < cchLine; ++ich)
		{
			if (FBadCh(*szT))
				return FALSE;
			switch (ich % 4)
			{
			case 0:
				*pb = (BYTE) (DEC(*szT) << 2);
				break;
			case 1:
				*pb |= (DEC(*szT) >> 4) & 0x03;
				++pb;
				*pb = (BYTE) (DEC(*szT) << 4);
				break;
			case 2:
				*pb |= (DEC(*szT) >> 2) & 0x0f;
				++pb;
				*pb = (BYTE) (DEC(*szT) << 6);
				break;
			case 3:
				*pb |= DEC(*szT);
				++pb;
				break;
			}
			++szT;
		}
	}

	return TRUE;
}

//---------------------------------------------------------------------------
// Name:		ErrLpstrToBstrA()
//
// Description:
//				Copies C string to OLE BSTR.  Note that the bstr
//				contains an ANSI string.  VB 4.0 will automatically
//				convert this ANSI string to unicode when the string if
//				this string is a member of a UDT and declared as a UDT.
//				Arrays of UDTs are handled as SAFEARRAYS.
//
//
// Parameters:
// Returns:
//				FALSE if successful
//				TRUE if failure
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
ERR FAR PASCAL ErrLpstrToBstrA( LPSTR cstr, BSTR * lpBstr )
{
	UINT	uiLen;

	if ( *lpBstr )
		SysFreeString( *lpBstr );

	uiLen = lstrlen( cstr );

	*lpBstr = SysAllocStringByteLen( cstr, (uiLen) ? uiLen : 0 );

	return (ERR)((*lpBstr) ? FALSE : TRUE);
}


//---------------------------------------------------------------------------
// Name:		ErrBinaryToSzEID()
//
// Description:
//				Converts binary data to a hexized string.
//
// Parameters:
// Returns:
//				FALSE	if success.
//				TRUE	if failure.
//
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
ERR ErrBinaryToSzEID( LPVOID lpvEID, ULONG cbEID, LPSTR * lppstrEID )
{
	ERR		Err	= FALSE;
	ULONG	cbStr;

	cbStr = CchOfEncoding( cbEID );

    if (!MemAlloc((LPVOID*)lppstrEID, cbStr))
    {
        Err = TRUE;
		goto exit;
	}

	EncodeID( (LPBYTE)lpvEID, cbEID, *lppstrEID );

exit:

	return Err;
}

/*
 *	Given the size of a binary string, returns the size of its
 *	ASCII encoding.
 */
STDAPI_(ULONG) CchOfEncoding(ULONG cbBinary)
{
	return
		(cbBinary / 3) * 4				//	3 bytes -> 4 characters
	+	rgLeft[cbBinary % 3]			//	Leftover bytes -> N characters
	+	((cbBinary / 45) + 1)			//	overhead: 1 byte per line
	+	1;								//	null
}

/*
 -	EncodeID
 -
 *	Purpose:
 *		Turns a byte string into a character string, using the
 *		uuencode algorithm.
 *
 *		Three bytes are mapped into 6 bits each of 4 characters, in
 *		the range 0x21 - 0x60. The encoding is broken up into lines
 *		of 60 characters or less. Each line begins with a count
 *		byte (which specifies the number of bytes encoded, not
 *		characters) and ends with a CRLF pair.
 *
 *		Note that this encoding is sub-optimal for UNICODE: the
 *		characters used still fall into the 7-bit ASCII range.
 *
 *	Arguments:
 *		pb				in		the byte string to encode
 *		cb				in		length of the input string
 *		sz				out		the encoded character string. No
 *								length checking is performed on the
 *								output.
 *
 */
STDAPI_(void) EncodeID(LPBYTE pb, ULONG cb, LPTSTR sz)
{
	int		cbLine;
	int		ib;
	BYTE	b;
#ifdef	DEBUG
	LPTSTR	szBase = sz;
	ULONG	cchTot = CchOfEncoding(cb);
#endif

	AssertSz(!IsBadReadPtr(pb, (UINT) cb), "EncodeID: pb fails address check");
	AssertSz(!IsBadWritePtr(sz, (UINT) cchTot), "EncodeID: sz fails address check");

	while (cb)
	{
		cbLine = min(45, (int)cb);

		Assert(sz < szBase + cchTot);
		*sz++ = ENC(cbLine);

		for (ib = 0; ib < cbLine; ++ib)
		{
			Assert(sz < szBase + cchTot);
			b = 0;
			switch (ib % 3)
			{
			case 0:
				*sz++ = ENC(*pb >> 2);
				if (ib+1 < cbLine)
					b = (BYTE) ((pb[1] >> 4) & 0x0f);
				*sz++ = ENC((*pb << 4) & 0x30 | b);
				break;
			case 1:
				if (ib+1 < cbLine)
					b = (BYTE) ((pb[1] >> 6) & 0x03);
				*sz++ = ENC((*pb << 2) & 0x3c | b);
				break;
			case 2:
				*sz++ = ENC(*pb & 0x3f);
				break;
			}
			pb++;
		}

		cb -= cbLine;
		Assert(cb == 0 || sz + 1 < szBase + cchTot);
	}

	Assert(sz + 1 == szBase + cchTot);
	*sz = 0;
}

//---------------------------------------------------------------------------
// Name:		ErrLpstrToBstr()
//
// Description:
//				Copies and converts a C string to an OLE BSTR.  This
//				routine will convert MultiByte to WideChar.
// Parameters:
// Returns:
//				FALSE if successful
//				TRUE if failure
//
// Effects:
// Notes:
//				SysReallocString returns FALSE if memory failure.
// Revision:
//---------------------------------------------------------------------------
ERR FAR PASCAL ErrLpstrToBstr( LPSTR cstr, BSTR * lpBstr )
{
	OLECHAR *	lpszWC 	= NULL;
	INT			cch		= 0;
	ERR			Err		= FALSE;

	if ( !cstr )
	{
		*lpBstr = NULL;
		return FALSE;
	}

	cch = lstrlen( cstr );
    if (!MemAlloc((LPVOID*)&lpszWC, (cch + 1) * sizeof(OLECHAR)))
        return TRUE ;


	// convert ANSI to WideChar

	if ( !MultiByteToWideChar( GetACP(), 0, cstr, -1, lpszWC, cch + 1 ) )
	{
		Err = TRUE;
		goto exit;

	}

	if ( *lpBstr )
	{
		Err = (ERR)!SysReAllocString( lpBstr, lpszWC );
		if ( Err )
			goto exit;
	}
	else
	{
		*lpBstr = SysAllocString( lpszWC );
		if ( !*lpBstr )
		{
			Err = TRUE;
			goto exit;
		}
	}

exit:

	SafeMemFree(lpszWC);

return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\acctview.cpp ===
#include "pch.hxx"
#include <iert.h>
#include <store.h>
#include <storecb.h>
#include "resource.h"
#include "ourguid.h"
#include "thormsgs.h"
#include "goptions.h"
#include "strconst.h"
#include <inetcfg.h>
#include <fonts.h>
#include <columns.h>
#include <imagelst.h>
#include <instance.h>
#include <spoolui.h>
#include <options.h>
#include <acctutil.h>
#include "shlwapip.h"
#include <menuutil.h>
#include "storutil.h"
#include <outbar.h>
#include <subscr.h>
#include "newsutil.h"
#include "acctview.h"
#include <newfldr.h>
#include <mailutil.h>
#include "menures.h"
#include "demand.h"

ASSERTDATA

#define SUBSCRIBE_BORDER    7
#define CALLOCIDBUF         256
#define IDC_SUBSCRIBE_LIST  (ID_FIRST - 4)
#define FOLDER_SYNCMASK     (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL)

static const char c_szAcctViewWndClass[] = "Outlook Express AcctView";

int __cdecl GroupCompare(const void *lParam1, const void *lParam2) ;
void DrawSettingsButton(HWND hwnd, LPDRAWITEMSTRUCT pdi);
#define C_RGBCOLORS 16
extern const DWORD rgrgbColors16[C_RGBCOLORS];

typedef struct tagACCTVIEWBTN
{
    int idsText;
    int cmd;
} ACCTVIEWBTN;

static const ACCTVIEWBTN c_rgMailBtns[] =
{
    { idsDeliverMailTT, ID_SEND_RECEIVE }
};

static const ACCTVIEWBTN c_rgImapBtns[] =
{
    { idsSynchronizeNowBtn, ID_SYNC_THIS_NOW },
    { idsIMAPFoldersBtn, ID_IMAP_FOLDERS },
    { idsSettingsBtn, ID_POPUP_SYNCHRONIZE }
};

static const ACCTVIEWBTN c_rgNewsBtns[] =
{
    { idsSynchronizeNowBtn, ID_SYNC_THIS_NOW },
    { idsNewsgroupsBtn, ID_NEWSGROUPS },
    { idsSettingsBtn, ID_POPUP_SYNCHRONIZE }
};

static const ACCTVIEWBTN c_rgHttpBtns[] =
{
    { idsSynchronizeNowBtn, ID_SYNC_THIS_NOW },
    { idsSettingsBtn, ID_POPUP_SYNCHRONIZE }
};

CAccountView::CAccountView()
{
    m_cRef = 1;
    // m_ftType
    m_pShellBrowser = NULL;
    m_fFirstActive = FALSE;
    m_pColumns = NULL;
    m_uActivation = SVUIA_DEACTIVATE;
    m_hwndOwner = NULL;
    m_hwnd = NULL;
    m_idFolder = FOLDERID_INVALID;
    m_fRegistered = FALSE;

    m_hwndList = NULL;
    m_pszMajor = NULL;
    m_pszMinor = NULL;
    m_cBtns = 0;

    m_cnode = 0;
    m_cnodeBuf = 0;
    m_rgnode = NULL;

    m_himlFolders = NULL;
    m_pEmptyList = NULL;

    m_pGroups = NULL;
    m_clrWatched = 0;
}

CAccountView::~CAccountView()
{
    if (m_pGroups != NULL)
    {
        m_pGroups->Close();
        m_pGroups->Release();
    }

    if (m_rgnode != NULL)
        MemFree(m_rgnode);

    SafeRelease(m_pShellBrowser);
    SafeRelease(m_pColumns);

    if (m_pEmptyList != NULL)
        delete m_pEmptyList;

    if (m_himlFolders != NULL)
        ImageList_Destroy(m_himlFolders);

    if (m_pszMajor != NULL)
        MemFree(m_pszMajor);
    if (m_pszMinor != NULL)
        MemFree(m_pszMinor);
}

HRESULT CAccountView::HrInit(FOLDERID idFolder)
{
    WNDCLASS wc;

    if (!GetClassInfo(g_hInst, c_szAcctViewWndClass, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = CAccountView::AcctViewWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hIcon            = NULL;
        wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szAcctViewWndClass;
        if (RegisterClass(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
            return E_FAIL;
    }

    m_idFolder = idFolder;
    m_ftType = GetFolderType(idFolder);

    m_dwDownloadDef = (m_ftType == FOLDER_NEWS) ? FOLDER_DOWNLOADNEW : FOLDER_DOWNLOADALL;

    // Set the image lists for the listview
    Assert(m_himlFolders == NULL);
    m_himlFolders = InitImageList(16, 16, MAKEINTRESOURCE(idbFolders), cFolderIcon, RGB(255, 0, 255));
    Assert(m_himlFolders);

    m_pEmptyList = new CEmptyList;
    if (m_pEmptyList == NULL)
        return(E_OUTOFMEMORY);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////
//
// OLE Interfaces
//

////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CAccountView::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IViewWindow *)this;
    else if (IsEqualIID(riid, IID_IViewWindow))
        *ppvObj = (void*) (IViewWindow *) this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (void*) (IOleCommandTarget *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CAccountView::AddRef()
{
    DOUT(TEXT("CAccountView::AddRef() - m_cRef = %d"), m_cRef + 1);
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CAccountView::Release()
{
    DOUT(TEXT("CAccountView::Release() - m_cRef = %d"), m_cRef - 1);
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

////////////////////////////////////////////////////////////////////////
//
//  IOleWindow
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CAccountView::GetWindow(HWND * lphwnd)
{
    *lphwnd = m_hwnd;
    return (m_hwnd ? S_OK : E_FAIL);
}

HRESULT STDMETHODCALLTYPE CAccountView::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////
//
//  IAthenaView
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CAccountView::TranslateAccelerator(LPMSG lpmsg)
{
    return(S_FALSE);
}

HRESULT STDMETHODCALLTYPE CAccountView::UIActivate(UINT uActivation)
{
    if (uActivation != SVUIA_DEACTIVATE)
        _OnActivate(uActivation);
    else
        _OnDeactivate();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CAccountView::CreateViewWindow(IViewWindow *lpPrevView, IAthenaBrowser *psb,
                                                           RECT *prcView, HWND *phWnd)
{
    FOLDERINFO info;

    m_pShellBrowser = psb;
    Assert(m_pShellBrowser);
    m_pShellBrowser->AddRef();

    m_pShellBrowser->GetWindow(&m_hwndOwner);
    Assert(IsWindow(m_hwndOwner));

    m_pColumns = new CColumns;
    if (m_pColumns == NULL)
        return(E_OUTOFMEMORY);

    m_hwnd = CreateWindowEx(WS_EX_CONTROLPARENT|WS_EX_CLIENTEDGE,
        c_szAcctViewWndClass,
        NULL,
        WS_VISIBLE|WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS,
        prcView->left,
        prcView->top,
        prcView->right - prcView->left,
        prcView->bottom - prcView->top,
        m_hwndOwner,
        NULL,
        g_hInst,
        (LPVOID)this);

    if (!m_hwnd)
        return E_FAIL;

    *phWnd = m_hwnd;

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CAccountView::DestroyViewWindow()
{
    HRESULT hr;
    HWND hwndDest;

    if (m_fRegistered)
        g_pStore->UnregisterNotify((IDatabaseNotify *)this);

    if (m_hwnd)
    {
        hwndDest = m_hwnd;
        m_hwnd = NULL;

        DestroyWindow(hwndDest);
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CAccountView::SaveViewState()
{
    Assert(m_pColumns != NULL);
    m_pColumns->Save(NULL, NULL);

    OptionUnadvise(m_hwnd);
    return S_OK;
}

//
//  FUNCTION:   CAccountView::OnInitMenuPopup
//
//  PURPOSE:    Called when the user is about to display a menu.  We use this
//              to update the enabled or disabled status of many of the
//              commands on each menu.
//
//  PARAMETERS:
//      hmenu       - Handle of the main menu.
//      hmenuPopup  - Handle of the popup menu being displayed.
//      uID         - Specifies the id of the menu item that
//                    invoked the popup.
//
//  RETURN VALUE:
//      Returns S_OK if we process the message.
//
//
HRESULT CAccountView::OnPopupMenu(HMENU hmenu, HMENU hmenuPopup, UINT uID)
{
    return(S_OK);
}

DWORD CAccountView::_GetDownloadCmdStatus(int iSel, FLDRFLAGS dwFlags)
{
    DWORD cmdf;

    cmdf = OLECMDF_SUPPORTED;
    if (m_ftType != FOLDER_LOCAL)
    {
        if (iSel != -1)
        {
            if (_IsSelectedFolder(FOLDER_SUBSCRIBED, TRUE, FALSE))
            {
                cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;

                if (_IsSelectedFolder(dwFlags, TRUE, TRUE))
                    cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
            }
        }
    }

    return(cmdf);
}

HRESULT CAccountView::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG i;
    BOOL fTree, fSpecial;
    FOLDERID idFolder;
    FOLDERINFO info;
    HRESULT hr;
    int iSel, cSel, cItems, iSelT;
    OLECMD *pcmd;

    Assert(prgCmds != NULL);

    cSel = ListView_GetSelectedCount(m_hwndList);
    cItems = ListView_GetItemCount(m_hwndList);
    iSel = ListView_GetNextItem(m_hwndList, -1, LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED);
    if (iSel != -1 && (DWORD)iSel >= m_cnode)
        iSel = -1;
    fTree = !(S_OK == m_pShellBrowser->HasFocus(ITB_OEVIEW));

    for (i = 0, pcmd = prgCmds; i < cCmds; i++, pcmd++)
    {
        if (pcmd->cmdf == 0)
        {
            switch (pcmd->cmdID)
            {
                case ID_POPUP_SYNCHRONIZE:
                    pcmd->cmdf = OLECMDF_SUPPORTED;
                    if (m_ftType != FOLDER_LOCAL && iSel != -1)
                    {
                        if (_IsSelectedFolder(FOLDER_SUBSCRIBED, TRUE, FALSE))
                            pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    }
                    break;

                case ID_MARK_RETRIEVE_FLD_NEW_HDRS:
                    pcmd->cmdf = _GetDownloadCmdStatus(iSel, FOLDER_DOWNLOADHEADERS);
                    break;

                case ID_MARK_RETRIEVE_FLD_NEW_MSGS:
                    pcmd->cmdf = _GetDownloadCmdStatus(iSel, FOLDER_DOWNLOADNEW);
                    break;

                case ID_MARK_RETRIEVE_FLD_ALL_MSGS:
                    pcmd->cmdf = _GetDownloadCmdStatus(iSel, FOLDER_DOWNLOADALL);
                    break;

                case ID_UNMARK_RETRIEVE_FLD:
                    pcmd->cmdf = OLECMDF_SUPPORTED;
                    if (iSel != -1)
                    {
                        if (_IsSelectedFolder(FOLDER_SUBSCRIBED, TRUE, FALSE))
                        {
                            pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;

                            if (_IsSelectedFolder(FOLDER_SYNCMASK, FALSE, TRUE))
                                pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
                        }
                    }
                    break;

                case ID_SUBSCRIBE:
                case ID_UNSUBSCRIBE:
                    pcmd->cmdf = OLECMDF_SUPPORTED;
                    if ((m_ftType == FOLDER_IMAP || m_ftType == FOLDER_NEWS) && iSel != -1)
                    {
                        if (_IsSelectedFolder(FOLDER_SUBSCRIBED, pcmd->cmdID == ID_UNSUBSCRIBE, FALSE, TRUE))
                            pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    }
                    break;

                case ID_SELECT_ALL:
                case ID_COLUMNS:
                    pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_CATCH_UP:
                    if (m_ftType == FOLDER_NEWS && iSel != -1)
                        pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        pcmd->cmdf = OLECMDF_SUPPORTED;
                    break;

                case ID_OPEN_FOLDER:
                case ID_OPEN:
                case ID_GO_SELECTED:
                case ID_COMPACT:
                case ID_MARK_ALL_READ:
                    if (iSel == -1)
                        pcmd->cmdf = OLECMDF_SUPPORTED;
                    else
                        pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                // TODO: support ID_PURGE_DELETED???

                // commands below are handled by the treeview if it has the focus
                // otherwise we'll handle them based on what is selected in us

                case ID_PROPERTIES:
                case ID_ADD_SHORTCUT:
                    if (!fTree)
                    {
                        if (iSel != -1)
                            pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        else
                            pcmd->cmdf = OLECMDF_SUPPORTED;
                    }
                    break;

                case ID_NEW_FOLDER:
                case ID_NEW_FOLDER2:
                    if (!fTree)
                    {
                        pcmd->cmdf = OLECMDF_SUPPORTED;
                        if (m_ftType != FOLDER_NEWS && iSel != -1)
                        {
                            hr = g_pStore->GetFolderInfo(_IdFromIndex(iSel), &info);
                            if (SUCCEEDED(hr))
                            {
                                if (info.tySpecial != FOLDER_DELETED)
                                    pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                                g_pStore->FreeRecord(&info);
                            }
                        }
                    }
                    break;

                case ID_DELETE:
                case ID_DELETE_FOLDER:
                    if (!fTree)
                    {
                        pcmd->cmdf = OLECMDF_SUPPORTED;
                        if (iSel != -1 && m_ftType != FOLDER_NEWS)
                        {
                            iSelT = iSel;
                            while (iSelT != -1)
                            {
                                hr = g_pStore->GetFolderInfo(_IdFromIndex(iSelT), &info);
                                if (SUCCEEDED(hr))
                                {
                                    fSpecial = (info.tySpecial != FOLDER_NOTSPECIAL);

                                    g_pStore->FreeRecord(&info);

                                    if (!fSpecial)
                                    {
                                        pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                                        break;
                                    }
                                }

                                iSelT = ListView_GetNextItem(m_hwndList, iSelT, LVNI_SELECTED);
                            }
                        }
                    }
                    break;

                case ID_MOVE:
                case ID_RENAME:
                    if (!fTree)
                    {
                        pcmd->cmdf = OLECMDF_SUPPORTED;
                        if (m_ftType != FOLDER_NEWS && iSel != -1)
                        {
                            hr = g_pStore->GetFolderInfo(_IdFromIndex(iSel), &info);
                            if (SUCCEEDED(hr))
                            {
                                if (info.tySpecial == FOLDER_NOTSPECIAL)
                                    pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                                g_pStore->FreeRecord(&info);
                            }
                        }
                    }
                    break;
            }
        }
    }

    return(S_OK);
}

HRESULT CAccountView::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    int iSel;
    BOOL fTree;
    HRESULT hr;
    FOLDERID id;

    iSel = ListView_GetNextItem(m_hwndList, -1, LVNI_ALL | LVNI_FOCUSED);
    if (iSel != -1)
    {
        if (MenuUtil_HandleNewMessageIDs(nCmdID, m_hwndOwner, _IdFromIndex((DWORD)iSel), m_ftType != FOLDER_NEWS, FALSE, NULL))
            return(S_OK);
    }

    fTree = !(S_OK == m_pShellBrowser->HasFocus(ITB_OEVIEW));

    hr = OLECMDERR_E_NOTSUPPORTED;

    switch (nCmdID)
    {
        case ID_MARK_RETRIEVE_FLD_NEW_HDRS:
        case ID_MARK_RETRIEVE_FLD_NEW_MSGS:
        case ID_MARK_RETRIEVE_FLD_ALL_MSGS:
        case ID_UNMARK_RETRIEVE_FLD:
            _MarkForDownload(nCmdID);
            hr = S_OK;
            break;

        case ID_COLUMNS:
            m_pColumns->ColumnsDialog(m_hwndOwner);
            hr = S_OK;
            break;

        case ID_SUBSCRIBE:
        case ID_UNSUBSCRIBE:
            _Subscribe(nCmdID == ID_SUBSCRIBE);
            hr = S_OK;
            break;

        case ID_COMPACT:
            if (iSel != -1)
                CompactFolders(m_hwndOwner, RECURSE_INCLUDECURRENT, _IdFromIndex((DWORD)iSel));
            hr = S_OK;
            break;

        case ID_CATCH_UP:
            iSel = -1;
            while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
                MenuUtil_OnCatchUp(_IdFromIndex((DWORD)iSel));
            hr = S_OK;
            break;

        case ID_GO_SELECTED:
        case ID_OPEN:
        case ID_OPEN_FOLDER:
            if (iSel != -1)
                g_pInstance->BrowseToObject(SW_SHOWNORMAL, _IdFromIndex((DWORD)iSel));
            hr = S_OK;
            break;

        case ID_SELECT_ALL:
            ListView_SelectAll(m_hwndList);
            if (m_hwndList != GetFocus())
                SetFocus(m_hwndList);
            hr = S_OK;
            break;

        case ID_MARK_ALL_READ:
            _MarkAllRead();
            hr = S_OK;
            break;

        // commands below are handled by the treeview if it has the focus
        // otherwise we'll handle them based on what is selected in us

        case ID_ADD_SHORTCUT:
            if (!fTree)
            {
                if (iSel != -1)
                    OutlookBar_AddShortcut(_IdFromIndex((DWORD)iSel));
                hr = S_OK;
            }
            break;

        case ID_PROPERTIES:
            if (!fTree)
            {
                if (iSel != -1)
                    MenuUtil_OnProperties(m_hwndOwner, _IdFromIndex(iSel));
                hr = S_OK;
            }
            break;

        case ID_NEW_FOLDER:
        case ID_NEW_FOLDER2:
            if (!fTree)
            {
                if (iSel != -1)
                    SelectFolderDialog(m_hwndOwner, SFD_NEWFOLDER, _IdFromIndex((DWORD)iSel), TREEVIEW_NONEWS | TREEVIEW_DIALOG | FD_DISABLEROOT | FD_FORCEINITSELFOLDER,
                        NULL, NULL, NULL);
                hr = S_OK;
            }
            break;

        case ID_MOVE:
            if (!fTree)
            {
                if (iSel != -1)
                {
                    // TODO: move all selected folders, not just the one with focus
                    SelectFolderDialog(m_hwndOwner, SFD_MOVEFOLDER, _IdFromIndex((DWORD)iSel), TREEVIEW_NONEWS | TREEVIEW_DIALOG | FD_DISABLEROOT,
                        MAKEINTRESOURCE(idsMove), MAKEINTRESOURCE(idsMoveCaption), NULL);
                }
                hr = S_OK;
            }
            break;

        case ID_RENAME:
            if (!fTree)
            {
                if (iSel != -1)
                    RenameFolderDlg(m_hwndOwner, _IdFromIndex((DWORD)iSel));
                hr = S_OK;
            }
            break;

        case ID_DELETE:
        case ID_DELETE_NO_TRASH:
        case ID_DELETE_FOLDER:
            if (!fTree)
            {
                if (iSel != -1)
                    _HandleDelete(nCmdID == ID_DELETE_NO_TRASH);

                hr = S_OK;
            }
            break;
    }

    return(hr);
}

void CAccountView::_HandleSettingsButton(HWND hwndBtn)
{
    HRESULT hr;
    HMENU hMenu;
    HWND hwndBrowser;
    RECT rc;
    DWORD state;

    hMenu = LoadPopupMenu(IDR_SYNCHRONIZE_POPUP);
    if (hMenu != NULL)
    {
        // Enable / disable
        MenuUtil_EnablePopupMenu(hMenu, (IOleCommandTarget *)this);

        GetWindowRect(hwndBtn, &rc);
        m_pShellBrowser->GetWindow(&hwndBrowser);

        TrackPopupMenu(hMenu, TPM_NONOTIFY | TPM_LEFTALIGN | TPM_TOPALIGN,
            rc.left, rc.bottom, 0, hwndBrowser, NULL);

        DestroyMenu(hMenu);
    }
}

void CAccountView::_HandleDelete(BOOL fNoTrash)
{
    FOLDERID *pid;
    int iSel, cSel, cid;

    cSel = ListView_GetSelectedCount(m_hwndList);
    if (cSel > 0)
    {
        if (MemAlloc((void **)&pid, cSel * sizeof(FOLDERID)))
        {
            cid = cSel;
            iSel = -1;
            while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
            {
                cid--;
                Assert(cid >= 0);
                pid[cid] = _IdFromIndex(iSel);
            }

            Assert(cid == 0);

            if (m_ftType == FOLDER_NEWS)
            {
                MenuUtil_OnSubscribeGroups(m_hwndOwner, pid, cSel, FALSE);
            }
            else
            {
                MenuUtil_DeleteFolders(m_hwndOwner, pid, cSel, fNoTrash);
            }

            MemFree(pid);
        }
    }
}

BOOL CAccountView::_IsSelectedFolder(FLDRFLAGS dwFlags, BOOL fCondition, BOOL fAll, BOOL fIgnoreSpecial)
{
    BOOL fSpecial;
    HRESULT hr;
    FLDRFLAGS dw;
    FOLDERINFO info;
    DWORD iItem = -1;
	BOOL fHTTPFolder = FALSE;

    while (-1 != (iItem = ListView_GetNextItem(m_hwndList, iItem, LVNI_SELECTED)))
    {
        hr = g_pStore->GetFolderInfo(_IdFromIndex(iItem), &info);
        if (SUCCEEDED(hr))
        {
            dw = info.dwFlags;
			fHTTPFolder = (BOOL) (info.tyFolder & FOLDER_HTTPMAIL);

            fSpecial = fIgnoreSpecial && (info.tySpecial != FOLDER_NOTSPECIAL);

            g_pStore->FreeRecord(&info);

            if (fSpecial)
                continue;

            if (fAll)
            {
                // If all must match and this one doesn't, then we can quit now.
                if (!(fCondition == !!(dw & dwFlags)))
                    return (FALSE);
            }
            else
            {
                // If only one needs to match and this one does, then we can
                // quit now.
                if (fCondition == !!(dw & dwFlags))
				{
					if(fHTTPFolder)
					{
						FOLDERINFO		SvrFolderInfo = {0};
						IImnAccount 	*pAccount = NULL;
						CHAR			szAccountId[CCHMAX_ACCOUNT_NAME];
						HRESULT 		hr = S_OK;
						DWORD			dwShow = 0;
						
						// Get the server for this folder
						IF_FAILEXIT(hr = GetFolderServer(_IdFromIndex(iItem), &SvrFolderInfo));
						
						// Get the account ID for the server
						*szAccountId = 0;
						IF_FAILEXIT(hr = GetFolderAccountId(&SvrFolderInfo, szAccountId));
						
						// Get the account interface
						IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAccountId, &pAccount));
						
						IF_FAILEXIT(hr = pAccount->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dwShow));
						if(dwShow)
						{
							if(HideHotmail())
								return (FALSE);
						}
					}
exit:					
                    return (TRUE);
				}
            }
        }
    }

    // If the user wanted all to match, and we get here all did match.  If the
    // user wanted only one to match and we get here, then none matched and we
    // fail.
    return (fAll);
}

LRESULT CALLBACK CAccountView::AcctViewWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT         lRet;
    CAccountView     *pThis;

    if (msg == WM_NCCREATE)
    {
        pThis = (CAccountView *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);
    }
    else
        pThis = (CAccountView *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    Assert(pThis);

    return pThis->_WndProc(hwnd, msg, wParam, lParam);
}

LRESULT CAccountView::_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndFocus, hwndBrowser;
    BOOL fTip;
    RECT rc;

    switch (msg)
    {
        HANDLE_MSG(hwnd, WM_CREATE,         _OnCreate);
        HANDLE_MSG(hwnd, WM_SIZE,           _OnSize);
        HANDLE_MSG(hwnd, WM_NOTIFY,         _OnNotify);
        HANDLE_MSG(hwnd, WM_SETFOCUS,       _OnSetFocus);

        case WM_MENUSELECT:
            CStatusBar *pStatusBar;
            m_pShellBrowser->GetStatusBar(&pStatusBar);
            HandleMenuSelect(pStatusBar, wParam, lParam);
            pStatusBar->Release();
            return 0;

        case WM_COMMAND:
            _OnCommand(wParam, lParam);
            break;

        case WM_PAINT:
            return(_OnPaint(hwnd, (HDC)wParam));

        case WM_DRAWITEM:
            if (wParam == ID_POPUP_SYNCHRONIZE)
            {
                DrawSettingsButton(hwnd, (LPDRAWITEMSTRUCT)lParam);
                return(TRUE);
            }
            break;

        case WM_CONTEXTMENU:
            _OnContextMenu(hwnd, (HWND)wParam, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam));
            return(0);

        case NVM_INITHEADERS:
            _PostCreate();
            return 0;

        case WM_ACTIVATE:
            _HandleItemStateChange();

            if (LOWORD(wParam) != WA_INACTIVE)
            {
                // DefWindowProc will set the focus to our view window, which
                // is not what we want.  Instead, we will let the explorer set
                // the focus to our view window if we should get it, at which
                // point we will set it to the proper control.
                return 0;
            }
            break;

        case WM_SYSCOLORCHANGE:
            SendMessage(m_hwndList, msg, wParam, lParam);
            break;

        case WM_WININICHANGE:
            SendMessage(m_hwndList, msg, wParam, lParam);

            // reposition and resize things with the new font
            _OnWinIniChange(hwnd);
            break;

        case NVM_GETNEWGROUPS:
            if (m_pGroups != NULL)
            {
                m_pGroups->HandleGetNewGroups();
                m_pGroups->Release();
                m_pGroups = NULL;
            }
            return(0);

        case CM_OPTIONADVISE:
            m_clrWatched = DwGetOption(OPT_WATCHED_COLOR);
            return (0);

        default:
            if (g_msgMSWheel && (msg == g_msgMSWheel))
            {
                hwndFocus = GetFocus();
                if (IsChild(hwnd, hwndFocus))
                    return SendMessage(hwndFocus, msg, wParam, lParam);
            }
            break;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

void CAccountView::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    HWND hwndBrowser;
    HRESULT hr;

    if (HIWORD(wParam) == BN_CLICKED)
    {
        switch (LOWORD(wParam))
        {
            case ID_SEND_RECEIVE:
            case ID_SYNC_THIS_NOW:
            case ID_IMAP_FOLDERS:
            case ID_NEWSGROUPS:
                m_pShellBrowser->GetWindow(&hwndBrowser);
                SendMessage(hwndBrowser, WM_COMMAND, wParam, lParam);
                break;

            case ID_POPUP_SYNCHRONIZE:
                _HandleSettingsButton((HWND)lParam);
                break;

            default:
                Assert(FALSE);
                break;
        }
    }
}

//
//  FUNCTION:   CAccountView::OnCreate
//
//  PURPOSE:    Creates the child windows necessary for the view and
//              initializes the data in those child windows.
//
//  PARAMETERS:
//      hwnd           - Handle of the view being created.
//      lpCreateStruct - Pointer to the creation params passed to
//                       CreateWindow().
//
//  RETURN VALUE:
//      Returns TRUE if the initialization is successful.
//
BOOL CAccountView::_OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    HRESULT hr;
    DWORD style;
    FOLDERINFO info;
    COLUMN_SET_TYPE set;
    const ACCTVIEWBTN *pBtn;
    int i, cBtn, idsMajor, idsMinor;
    char sz[CCHMAX_STRINGRES];

    switch (m_ftType)
    {
        case FOLDER_LOCAL:
            set = COLUMN_SET_LOCAL_STORE;
            pBtn = c_rgMailBtns;
            cBtn = ARRAYSIZE(c_rgMailBtns);
            idsMajor = 0;
            idsMinor = idsLocalFoldersMinor;
            break;
        case FOLDER_IMAP:
            set = COLUMN_SET_IMAP_ACCOUNT;
            pBtn = c_rgImapBtns;
            cBtn = ARRAYSIZE(c_rgImapBtns);
            idsMajor = idsSyncManager;
            idsMinor = idsSetSyncSettings;
            break;
        case FOLDER_HTTPMAIL:
            set = COLUMN_SET_HTTPMAIL_ACCOUNT;
            pBtn = c_rgHttpBtns;
            cBtn = ARRAYSIZE(c_rgHttpBtns);
            idsMajor = idsSyncManager;
            idsMinor = idsSetSyncSettings;
            break;
        case FOLDER_NEWS:
            set = COLUMN_SET_NEWS_ACCOUNT;
            pBtn = c_rgNewsBtns;
            cBtn = ARRAYSIZE(c_rgNewsBtns);
            idsMajor = idsSyncManagerNews;
            idsMinor = idsSetNewsSyncSettings;
            break;
        default:
            Assert(FALSE);
            break;
    }

    for (i = 0; i < cBtn; i++, pBtn++)
    {
        if (pBtn->cmd == ID_POPUP_SYNCHRONIZE)
            style = WS_VISIBLE | WS_TABSTOP | WS_CHILD | BS_NOTIFY | BS_OWNERDRAW | WS_DISABLED;
        else
            style = WS_VISIBLE | WS_TABSTOP | WS_CHILD | BS_NOTIFY;
        AthLoadString(pBtn->idsText, sz, ARRAYSIZE(sz));
        m_rgBtns[m_cBtns] = CreateWindow("button", sz, style,
                                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                hwnd, (HMENU)LongToHandle(pBtn->cmd), g_hInst, 0);
        if (m_rgBtns[m_cBtns] != NULL)
            m_cBtns++;
    }

    m_hwndList = CreateWindowEx(0, WC_LISTVIEW, c_szEmpty,
        WS_VISIBLE | WS_TABSTOP | WS_CHILD | LVS_REPORT | LVS_NOSORTHEADER |
        LVS_OWNERDATA | LVS_SHOWSELALWAYS | LVS_SHAREIMAGELISTS,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        hwnd, (HMENU)IDC_SUBSCRIBE_LIST, g_hInst, 0);
    Assert(m_hwndList != NULL);

    hr = m_pColumns->Initialize(m_hwndList, set);
    Assert(SUCCEEDED(hr));

    hr = m_pColumns->ApplyColumns(COLUMN_LOAD_REGISTRY, 0, 0);
    Assert(SUCCEEDED(hr));

    m_hwndHeader = ListView_GetHeader(m_hwndList);
    Assert(m_hwndHeader != NULL);

    // Initialize the extended styles so we get full row select.  Just because
    // it looks better.
    ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT | LVS_EX_SUBITEMIMAGES);

    Assert(m_himlFolders != NULL);
    ListView_SetImageList(m_hwndList, m_himlFolders, LVSIL_SMALL);

    SetIntlFont(m_hwndList);

    hr = g_pStore->GetFolderInfo(m_idFolder, &info);
    if (SUCCEEDED(hr))
    {
        if (MemAlloc((void **)&m_pszMajor, CCHMAX_STRINGRES))
        {
            if (idsMajor != 0)
            {
                AthLoadString(idsMajor, sz, ARRAYSIZE(sz));
                wsprintf(m_pszMajor, sz, info.pszName);
            }
            else
            {
                lstrcpy(m_pszMajor, info.pszName);
            }
        }

        if (idsMinor != 0)
            m_pszMinor = AthLoadString(idsMinor, NULL, 0);

        g_pStore->FreeRecord(&info);
    }

    m_clrWatched = DwGetOption(OPT_WATCHED_COLOR);
    OptionAdvise(hwnd);
    _OnWinIniChange(hwnd);

    return TRUE;
}

BOOL CAccountView::_OnWinIniChange(HWND hwnd)
    {
    char sz[CCHMAX_STRINGRES];
    TEXTMETRIC tm;
    HDC hdc;
    int i, cch, cxMax;
    SIZE size;
    HFONT hfont, hfontBold, hfontOld;
    RECT rc, rcBtn;

    GetClientRect(hwnd, &rc);

    hfont = HGetCharSetFont(FNT_SYS_ICON, NULL);
    hfontBold = HGetCharSetFont(FNT_SYS_ICON_BOLD, NULL);

    hdc = GetDC(hwnd);

    hfontOld = (HFONT)SelectObject(hdc, (HGDIOBJ)hfontBold);

    Assert(m_pszMajor != NULL);
    GetTextExtentPoint32(hdc, m_pszMajor, lstrlen(m_pszMajor), &size);
    m_rcMajor.left = SUBSCRIBE_BORDER;
    m_rcMajor.top = SUBSCRIBE_BORDER;
    m_rcMajor.right = m_rcMajor.left + size.cx;
    m_rcMajor.bottom = m_rcMajor.top + size.cy;

    m_rcMinor.left = m_rcMajor.left;
    m_rcMinor.top = m_rcMajor.bottom + 1;
    if (m_pszMinor != NULL)
    {
        SelectObject(hdc, (HGDIOBJ)hfont);
        GetTextExtentPoint32(hdc, m_pszMinor, lstrlen(m_pszMinor), &size);
    }
    m_rcMinor.right = m_rcMinor.left + size.cx;
    m_rcMinor.bottom = m_rcMinor.top + size.cy;

    m_rcHeader.left = 0;
    m_rcHeader.top = 0;
    m_rcHeader.right = rc.right;
    m_rcHeader.bottom = m_rcMinor.bottom + SUBSCRIBE_BORDER;

    m_rcButtons.left = m_rcHeader.left;
    m_rcButtons.top = m_rcHeader.bottom + 1;
    m_rcButtons.right = m_rcHeader.right;
    m_rcButtons.bottom = m_rcButtons.top + m_rcHeader.bottom;

    SelectObject(hdc, hfont);

    cxMax = 0;
    for (i = 0; i < m_cBtns; i++)
    {
        cch = GetWindowText(m_rgBtns[i], sz, ARRAYSIZE(sz));
        GetTextExtentPoint32(hdc, sz, cch, &size);
        if (size.cx > cxMax)
            cxMax = size.cx;
    }

    SelectObject(hdc, hfontOld);
    ReleaseDC(hwnd, hdc);

    rcBtn.top = m_rcButtons.top + SUBSCRIBE_BORDER;
    rcBtn.bottom = rcBtn.top + (m_rcMinor.bottom - m_rcMajor.top);
    rcBtn.left = m_rcMajor.left;
    rcBtn.right = cxMax + 2 * GetSystemMetrics(SM_CXEDGE) + 6 + (rcBtn.bottom - rcBtn.top);

    cxMax = SUBSCRIBE_BORDER + (rcBtn.right - rcBtn.left);

    for (i = 0; i < m_cBtns; i++)
    {
        SendMessage(m_rgBtns[i], WM_SETFONT, (WPARAM)hfont, 0);

        SetWindowPos(m_rgBtns[i], NULL, rcBtn.left, rcBtn.top,
            rcBtn.right - rcBtn.left, rcBtn.bottom - rcBtn.top,
            SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);

        rcBtn.left += cxMax;
        rcBtn.right += cxMax;
    }

    rc.top = m_rcButtons.bottom + 1;
    SendMessage(m_hwndList, WM_SETFONT, (WPARAM)hfont, 0);
    SetWindowPos(m_hwndList, NULL, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
        SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);

    return(TRUE);
}

//
//  FUNCTION:   CAccountView::OnSize
//
//  PURPOSE:    Notification that the view window has been resized.  In
//              response we update the positions of our child windows and
//              controls.
//
//  PARAMETERS:
//      hwnd   - Handle of the view window being resized.
//      state  - Type of resizing requested.
//      cxClient - New width of the client area.
//      cyClient - New height of the client area.
//
void CAccountView::_OnSize(HWND hwnd, UINT state, int cxClient, int cyClient)
{
    int cy;
    BOOL fUpdate;

    fUpdate = (cxClient > m_rcHeader.right);

    m_rcHeader.right = cxClient;
    m_rcMajor.right = m_rcHeader.right - SUBSCRIBE_BORDER;
    m_rcMinor.right = m_rcMajor.right;
    m_rcButtons.right = m_rcHeader.right;

    if ((m_rcButtons.bottom + 1) < cyClient)
        cy = cyClient - (m_rcButtons.bottom + 1);
    else
        cy = 1;

    SetWindowPos(m_hwndList, NULL, 0, 0, cxClient, cy,
        SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER | SWP_NOMOVE);

    if (fUpdate)
    {
        InvalidateRect(hwnd, NULL, FALSE);
        UpdateWindow(hwnd);
    }
}

LRESULT CAccountView::_OnPaint(HWND hwnd, HDC hdc)
{
    HFONT hfont, hfontBold, hfontOld;
    RECT rc, rcT;
    PAINTSTRUCT ps;
    COLORREF crText, crBackground;
    HBRUSH hBrush, hBrushOld;

    if (0 != GetUpdateRect(hwnd, &rc, FALSE))
    {
        hdc = BeginPaint(hwnd, &ps);

        if (IntersectRect(&rcT, &rc, &m_rcHeader))
        {
            crText = GetSysColor(COLOR_WINDOW);
            crBackground = GetSysColor(COLOR_3DSHADOW);

            hBrush = CreateSolidBrush(crBackground);
            hBrushOld = SelectBrush(hdc, hBrush);
            PatBlt(hdc, rcT.left, rcT.top, rcT.right - rcT.left, rcT.bottom - rcT.top, PATCOPY);
            SelectBrush(hdc, hBrushOld);
            DeleteBrush(hBrush);

            SetBkColor(hdc, crBackground);
            SetTextColor(hdc, crText);

            if (m_pszMajor != NULL &&
                IntersectRect(&rcT, &rc, &m_rcMajor))
            {
                hfontBold = HGetCharSetFont(FNT_SYS_ICON_BOLD, NULL);
                hfontOld = (HFONT)SelectObject(hdc, (HGDIOBJ)hfontBold);

                DrawText(hdc, m_pszMajor, lstrlen(m_pszMajor), &m_rcMajor, DT_LEFT | DT_TOP | DT_SINGLELINE | DT_NOPREFIX);

                SelectObject(hdc, (HGDIOBJ)hfontOld);
            }

            if (m_pszMinor != NULL &&
                IntersectRect(&rcT, &rc, &m_rcMinor))
            {
                hfontBold = HGetCharSetFont(FNT_SYS_ICON, NULL);
                hfontOld = (HFONT)SelectObject(hdc, (HGDIOBJ)hfontBold);

                DrawText(hdc, m_pszMinor, lstrlen(m_pszMinor), &m_rcMinor, DT_LEFT | DT_TOP | DT_SINGLELINE | DT_NOPREFIX);

                SelectObject(hdc, (HGDIOBJ)hfontOld);
            }
        }

        rc.bottom = m_rcButtons.bottom;
        DrawEdge(hdc, &rc, EDGE_ETCHED, BF_BOTTOM);

        EndPaint(hwnd, &ps);
    }

    return(0);
}

BOOL DrawArrow(HDC hdc, LPARAM x, WPARAM y, int dx, int dy)
{
    int i, iCount;

    iCount = (dx + 1) / 2;

    // draw arrow head
    for (i = 0; i < iCount; i++, dx -= 2, x += 1)
        PatBlt(hdc, (int) x, (int) y++, dx, 1, PATCOPY);

    return(TRUE);
}

#define CXARROW     9
#define CYARROW     5

void DrawSettingsButton(HWND hwnd, LPDRAWITEMSTRUCT pdi)
{
    BOOL fPushed, fDisabled;
    TCHAR sz[CCHMAX_STRINGRES];
    RECT rcFocus;
    int d, cch, x, y, xArrow, yArrow;
    SIZE size;
    UINT dsFlags;
    HGDIOBJ hbrOld;

    Assert(pdi->CtlType == ODT_BUTTON);
    Assert(pdi->CtlID == ID_POPUP_SYNCHRONIZE);

    if (!!(pdi->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)))
    {
        fPushed = !!(pdi->itemState & ODS_SELECTED);
        fDisabled = !!(pdi->itemState & ODS_DISABLED);

        if (fPushed)
            dsFlags = DFCS_BUTTONPUSH | DFCS_PUSHED;
        else
            dsFlags = DFCS_BUTTONPUSH;

        DrawFrameControl(pdi->hDC, &pdi->rcItem, DFC_BUTTON, dsFlags);

        cch = GetWindowText(pdi->hwndItem, sz, ARRAYSIZE(sz));
        GetTextExtentPoint32(pdi->hDC, sz, cch, &size);

        size.cy++;
        x = (pdi->rcItem.left + pdi->rcItem.right - size.cx) / 2;
        y = (pdi->rcItem.top + pdi->rcItem.bottom - size.cy) / 2;
        if (fPushed)
        {
            x++;
            y++;
        }

        xArrow = x + size.cx + 7;
        yArrow = (pdi->rcItem.top + pdi->rcItem.bottom - CYARROW) / 2;
        yArrow++;
        if (fPushed)
            yArrow++;

        if (fDisabled)
        {
            DrawState(pdi->hDC, NULL, DrawArrow, 0, 0,
                xArrow, yArrow, CXARROW, CYARROW, DST_COMPLEX | DSS_DISABLED);
        }
        else
        {
            hbrOld = SelectObject(pdi->hDC, GetSysColorBrush(COLOR_BTNTEXT));
            DrawArrow(pdi->hDC, xArrow, yArrow, CXARROW, CYARROW);
            SelectObject(pdi->hDC, hbrOld);
        }


        if (fDisabled)
            dsFlags = DST_TEXT | DSS_DISABLED;
        else
            dsFlags = DST_TEXT | DSS_NORMAL;

        DrawState(pdi->hDC, NULL, NULL, (LPARAM)sz, (WPARAM)cch,
            x, y, size.cx, size.cy, dsFlags);
    }

    if (!!(pdi->itemAction & ODA_FOCUS) || !!(pdi->itemState & ODS_FOCUS))
    {
        rcFocus = pdi->rcItem;

        d = GetSystemMetrics(SM_CXEDGE) + 1;
        rcFocus.left += d;
        rcFocus.right -= d;

        d = GetSystemMetrics(SM_CYEDGE) + 1;
        rcFocus.top += d;
        rcFocus.bottom -= d;

        DrawFocusRect(pdi->hDC, &rcFocus);
    }
}

//
//  FUNCTION:   CAccountView::OnSetFocus
//
//  PURPOSE:    If the focus ever is set to the view window, we want to
//              make sure it goes to one of our child windows.  Preferably
//              the focus will go to the last child to have the focus.
//
//  PARAMETERS:
//      hwnd         - Handle of the view window.
//      hwndOldFocus - Handle of the window losing focus.
//
void CAccountView::_OnSetFocus(HWND hwnd, HWND hwndOldFocus)
{
    SetFocus(m_hwndList);
}

//
//  FUNCTION:   CAccountView::OnNotify
//
//  PURPOSE:    Processes the various notifications we receive from our child
//              controls.
//
//  PARAMETERS:
//      hwnd    - Handle of the view window.
//      idCtl   - identifies the control sending the notification
//      pnmh    - points to a NMHDR struct with more information regarding the
//                notification
//
//  RETURN VALUE:
//      Dependant on the specific notification.
//
LRESULT CAccountView::_OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    LRESULT lRes=0;
    HD_NOTIFY *phdn;
    int iSel;
    DWORD dwPos;
    UINT uChanged;
    FOLDERINFO info;
    LV_HITTESTINFO lvhti;
    NM_LISTVIEW *pnmlv;
    LV_DISPINFO *pDispInfo;
    DWORD cColumns;
    NMCUSTOMDRAW *pnmcd;
    COLUMN_ID id;
    FOLDERID idFolder;
    COLUMN_SET *rgColumns;
    HRESULT hr;
    FNTSYSTYPE fntType;

    if (pnmhdr->hwndFrom != m_hwndList &&
        pnmhdr->hwndFrom != m_hwndHeader)
        return(0);

    switch (pnmhdr->code)
    {
        case NM_SETFOCUS:
            m_pShellBrowser->OnViewWindowActive(this);
            _HandleItemStateChange();
            break;

        case LVN_ITEMACTIVATE:
            // Tell our host to open the selected items
            iSel = ListView_GetNextItem(m_hwndList, -1, LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED);
            if (iSel >= 0)
                g_pInstance->BrowseToObject(SW_SHOWNORMAL, _IdFromIndex(iSel));
            break;

        case LVN_GETDISPINFO:
            pDispInfo = (LV_DISPINFO *)pnmhdr;
            id = m_pColumns->GetId(pDispInfo->item.iSubItem);

            if ((DWORD)pDispInfo->item.iItem < m_cnode)
                _GetDisplayInfo(pDispInfo, id);
            break;

        case NM_CLICK:
            dwPos = GetMessagePos();
            lvhti.pt.x = (int)(short)LOWORD(dwPos);
            lvhti.pt.y = (int)(short)HIWORD(dwPos);
            ScreenToClient(m_hwndList, &(lvhti.pt));

            // Ask the ListView where this is
            if (-1 == ListView_SubItemHitTest(m_hwndList, &lvhti))
                break;

            id = m_pColumns->GetId(lvhti.iSubItem);
            if (lvhti.flags == LVHT_ONITEMICON)
            {
                if (id == COLUMN_DOWNLOAD)
                {
                    _ToggleDownload(lvhti.iItem);
                }
            }
            break;

        case NM_CUSTOMDRAW:
            pnmcd = (NMCUSTOMDRAW *)pnmhdr;

            // If this is a prepaint notification, we tell the control we're interested
            // in further notfications.
            if (pnmcd->dwDrawStage == CDDS_PREPAINT)
            {
                lRes = CDRF_NOTIFYITEMDRAW;
                break;
            }

            // Do some extra work here to not show the selection on the priority or
            // attachment sub columns.
            // $REVIEW - Why?
            if ((pnmcd->dwDrawStage == CDDS_ITEMPREPAINT) || (pnmcd->dwDrawStage == (CDDS_ITEMPREPAINT | CDDS_SUBITEM)))
            {
                fntType = FNT_SYS_ICON;

                if (pnmcd->dwItemSpec >= m_cnode)
                {
                    lRes = CDRF_DODEFAULT;
                    break;
                }

                if (SUCCEEDED(g_pStore->GetFolderInfo(_IdFromIndex((DWORD)(pnmcd->dwItemSpec)), &info)))
                {
                    if (pnmcd->dwDrawStage == (CDDS_ITEMPREPAINT | CDDS_SUBITEM))
                    {
                        if ((info.cWatchedUnread) && (m_clrWatched > 0 && m_clrWatched < 16))
                        {
                            LPNMLVCUSTOMDRAW(pnmcd)->clrText = rgrgbColors16[m_clrWatched - 1];
                        }
                        else
                        {
                            id = m_pColumns->GetId(LPNMLVCUSTOMDRAW(pnmcd)->iSubItem);
                            if (id == COLUMN_DOWNLOAD && 0 == (info.dwFlags & FOLDER_SYNCMASK))
                            {
                                LPNMLVCUSTOMDRAW(pnmcd)->clrText = GetSysColor(COLOR_GRAYTEXT);
                            }
                        }
                    }

                    if (info.cUnread > 0 ||
                        (info.tyFolder == FOLDER_NEWS && info.dwNotDownloaded > 0))
                        fntType = FNT_SYS_ICON_BOLD;

                    g_pStore->FreeRecord(&info);
                }

                SelectObject(pnmcd->hdc, HGetCharSetFont(fntType, GetListViewCharset()));
                lRes = CDRF_NEWFONT | CDRF_NOTIFYSUBITEMDRAW;
                break;
            }

            lRes = CDRF_DODEFAULT;
            break;

        case LVN_ITEMCHANGED:
            pnmlv = (NM_LISTVIEW *)pnmhdr;
            if (!!(pnmlv->uChanged & LVIF_STATE) &&
                !!((LVIS_SELECTED | LVIS_FOCUSED) & (pnmlv->uOldState ^ pnmlv->uNewState)))
            {
                _HandleItemStateChange();
            }
            break;

        case HDN_ENDTRACK:
            phdn = (HD_NOTIFY *)pnmhdr;
            m_pColumns->SetColumnWidth(phdn->iItem, phdn->pitem->cxy);
            break;

        case HDN_DIVIDERDBLCLICK:
            phdn = (HD_NOTIFY *)pnmhdr;
            // When the user double clicks on a header divider, we're supposed to
            // autosize that column.
            m_pColumns->SetColumnWidth(phdn->iItem, ListView_GetColumnWidth(m_hwndList, phdn->iItem));
            break;

        default:
            lRes = 0;
            break;
    }

    return(lRes);
}

void CAccountView::_HandleItemStateChange()
{
    OLECMD rgCmds[3];
    HRESULT hr;
    IOleCommandTarget *pTarget;
    int i;

    hr = m_pShellBrowser->QueryInterface(IID_IOleCommandTarget, (void **)&pTarget);
    if (SUCCEEDED(hr))
    {
        for (i = 0; i < m_cBtns; i++)
        {
            rgCmds[i].cmdID = GetWindowLong(m_rgBtns[i], GWL_ID);
            rgCmds[i].cmdf = 0;
        }

        hr = pTarget->QueryStatus(NULL, m_cBtns, rgCmds, NULL);
        if (SUCCEEDED(hr))
        {
            for (i = 0; i < m_cBtns; i++)
            {
                EnableWindow(m_rgBtns[i], !!(rgCmds[i].cmdf & OLECMDF_ENABLED));

                Assert(0 == (rgCmds[i].cmdf & OLECMDF_LATCHED));
                Assert(0 == (rgCmds[i].cmdf & OLECMDF_NINCHED));
            }
        }

        pTarget->Release();
    }

    m_pShellBrowser->UpdateToolbar();
}

HRESULT CAccountView::_GetDisplayInfo(LV_DISPINFO *pDispInfo, COLUMN_ID id)
{
    DWORD dwFlags;
    int count;
    FOLDERINFO info;
    HRESULT hr;
    FLDRNODE *pNode;

    pNode = _NodeFromIndex((DWORD)pDispInfo->item.iItem);
    if (pNode == NULL)
        return(S_OK);

    hr = g_pStore->GetFolderInfo(pNode->id, &info);
    if (FAILED(hr))
        return(hr);

    if (!!(pDispInfo->item.mask & LVIF_TEXT))
    {
        if (id == COLUMN_NEWSGROUP || id == COLUMN_FOLDER)
        {
            lstrcpyn(pDispInfo->item.pszText, info.pszName, pDispInfo->item.cchTextMax);
        }
        else if (id == COLUMN_DOWNLOAD)
        {
            if (!!(info.dwFlags & FOLDER_SUBSCRIBED))
            {
                if (0 == (info.dwFlags & FOLDER_SYNCMASK))
                    dwFlags = pNode->dwDownload;
                else
                    dwFlags = info.dwFlags;

                Assert(!!(dwFlags & FOLDER_SYNCMASK));

                if (!!(dwFlags & FOLDER_DOWNLOADALL))
                    AthLoadString(idsAllMessages, pDispInfo->item.pszText, pDispInfo->item.cchTextMax);
                else if (!!(dwFlags & FOLDER_DOWNLOADNEW))
                    AthLoadString(idsNewMessages, pDispInfo->item.pszText, pDispInfo->item.cchTextMax);
                else if (!!(dwFlags & FOLDER_DOWNLOADHEADERS))
                    AthLoadString(idsNewHeaders, pDispInfo->item.pszText, pDispInfo->item.cchTextMax);
            }
        }
        else if (id == COLUMN_TOTAL || id == COLUMN_UNREAD)
        {
            if (id == COLUMN_UNREAD)
                count = info.cUnread;
            else
                count = info.cMessages;

            if (FOLDER_NEWS == info.tyFolder)
                count += info.dwNotDownloaded;

            if (count < 0)
                count = 0;
            wsprintf(pDispInfo->item.pszText, "%d", count);
        }
    }

    if (!!(pDispInfo->item.mask & LVIF_IMAGE))
    {
        if (id == COLUMN_NEWSGROUP)
        {
            pDispInfo->item.iImage = iNullBitmap;
            if (!!(info.dwFlags & FOLDER_SUBSCRIBED))
            {
                pDispInfo->item.iImage = iNewsGroup;
                if (!!(info.dwFlags & FOLDER_SYNCMASK))
                    pDispInfo->item.iImage = iNewsGroupSync;
            }
        }
        else if (COLUMN_FOLDER == id)
        {
            pDispInfo->item.iImage = iNullBitmap;
            if (!!(info.dwFlags & FOLDER_SUBSCRIBED))
            {
                if (info.tySpecial == FOLDER_NOTSPECIAL)
                    pDispInfo->item.iImage = iFolderClosed;
                else
                    pDispInfo->item.iImage = (iInbox + (((info.tySpecial == FOLDER_BULKMAIL) ? FOLDER_JUNK : info.tySpecial) - 1));
            }
        }
        else if (COLUMN_DOWNLOAD == id)
        {
            pDispInfo->item.iImage = iNullBitmap;
            if (!!(info.dwFlags & FOLDER_SUBSCRIBED))
                {
                if (!!(info.dwFlags & FOLDER_SYNCMASK))
                    pDispInfo->item.iImage = iChecked;
                else
                    pDispInfo->item.iImage = iUnchecked;
            }
        }
    }

    if (!!(pDispInfo->item.mask & LVIF_INDENT))
    {
        if (COLUMN_FOLDER == id)
            pDispInfo->item.iIndent = pNode->indent;
    }

    g_pStore->FreeRecord(&info);
    return(S_OK);
}

BOOL CAccountView::_OnActivate(UINT uActivation)
{
    // if focus stays within the frame, but goes outside our view.
    // ie.. TreeView gets focus then we get an activate nofocus. Be sure
    // to UIDeactivate the docobj in this case
    if (uActivation == SVUIA_ACTIVATE_NOFOCUS)
    {

    }

    if (m_uActivation != uActivation)
    {
        _OnDeactivate();
        m_uActivation = uActivation;

        if (!m_fFirstActive)
        {
            PostMessage(m_hwnd, NVM_INITHEADERS, 0, 0L);
            m_fFirstActive = TRUE;
        }
    }
    return TRUE;
}

BOOL CAccountView::_OnDeactivate()
{
    return TRUE;
}

HRESULT CAccountView::_InsertChildren(FOLDERID idFolder, DWORD indent, DWORD *piNode)
{
    DWORD cnode;
    ULONG cFolders;
    IEnumerateFolders *pEnum;
    FOLDERINFO info;
    HRESULT hr;

    Assert(piNode != NULL);
    Assert(*piNode <= m_cnode);

    hr = g_pStore->EnumChildren(idFolder, TRUE, &pEnum);
    if (SUCCEEDED(hr))
    {
        hr = pEnum->Count(&cFolders);
        if (SUCCEEDED(hr) && cFolders > 0)
        {
            while (S_OK == pEnum->Next(1, &info, NULL))
            {
                Assert(m_cnode <= m_cnodeBuf);

                // Skip folders which are hidden
                if (ISFLAGSET(info.dwFlags, FOLDER_HIDDEN))
                    continue;

                if (m_cnode == m_cnodeBuf)
                {
                    cnode = m_cnode + cFolders + CALLOCIDBUF;
                    if (!MemRealloc((void **)&m_rgnode, cnode * sizeof(FLDRNODE)))
                    {
                        pEnum->Release();
                        return(E_OUTOFMEMORY);
                    }

                    m_cnodeBuf = cnode;
                }

                if (*piNode < m_cnode)
                    MoveMemory(&m_rgnode[*piNode + 1], &m_rgnode[*piNode], (m_cnode - *piNode) * sizeof(FLDRNODE));

                m_rgnode[*piNode].id = info.idFolder;
                m_rgnode[*piNode].indent = indent;
                m_rgnode[*piNode].dwDownload = m_dwDownloadDef;
                (*piNode)++;
                m_cnode++;

                if (!!(info.dwFlags & FOLDER_HASCHILDREN))
                    hr = _InsertChildren(info.idFolder, indent + 1, piNode);

                g_pStore->FreeRecord(&info);

                if (FAILED(hr))
                    break;
            }
        }

        pEnum->Release();
    }

    return(hr);
}

HRESULT CAccountView::_InsertChildrenSpecial(FOLDERID idFolder, DWORD indent, DWORD *piNode)
{
    DWORD cnode;
    ULONG iFolder, cFolders;
    IEnumerateFolders *pEnum;
    FOLDERINFO info;
    HRESULT hr;
    FLDRNODE *rgNode, *pNode;

    Assert(piNode != NULL);
    Assert(*piNode <= m_cnode);
    Assert(indent == 0);

    rgNode = NULL;

    hr = g_pStore->EnumChildren(idFolder, TRUE, &pEnum);
    if (SUCCEEDED(hr))
    {
        hr = pEnum->Count(&cFolders);
        if (SUCCEEDED(hr) && cFolders > 0)
        {
            if (!MemAlloc((void **)&rgNode, cFolders * sizeof(FLDRNODE)))
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                pNode = rgNode;
                cFolders = 0;
                while (S_OK == pEnum->Next(1, &info, NULL))
                {
                    if ((!(g_dwAthenaMode & MODE_NEWSONLY) || (info.tySpecial != FOLDER_INBOX)) &&
                        ISFLAGCLEAR(info.dwFlags, FOLDER_HIDDEN))
                    {
                        pNode->id = info.idFolder;
                        pNode->indent = !!(info.dwFlags & FOLDER_HASCHILDREN) ? 1 : 0;
                        pNode->dwDownload = m_dwDownloadDef;

                        pNode++;
                        cFolders++;
                    }
                    g_pStore->FreeRecord(&info);
                }

                qsort(rgNode, cFolders, sizeof(FLDRNODE), GroupCompare);
            }
        }

        pEnum->Release();
    }

    if (rgNode != NULL)
    {
        Assert(SUCCEEDED(hr));
        Assert(cFolders > 0);
        Assert(m_cnode == 0);
        Assert(m_cnodeBuf == 0);

        for (iFolder = 0, pNode = rgNode; iFolder < cFolders; iFolder++, pNode++)
        {
            if (m_cnode == m_cnodeBuf)
            {
                cnode = m_cnode + cFolders + CALLOCIDBUF;
                if (!MemRealloc((void **)&m_rgnode, cnode * sizeof(FLDRNODE)))
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                m_cnodeBuf = cnode;
            }

            m_rgnode[*piNode].id = pNode->id;
            m_rgnode[*piNode].indent = indent;
            m_rgnode[*piNode].dwDownload = m_dwDownloadDef;
            (*piNode)++;
            m_cnode++;

            if (pNode->indent == 1)
            {
                hr = _InsertChildren(pNode->id, indent + 1, piNode);

                if (FAILED(hr))
                    break;
            }
        }

        MemFree(rgNode);
    }

    return(hr);
}

void CAccountView::_PostCreate()
{
    HRESULT hr;
    DWORD iNode;
    BOOL fNews, fSub;

    Assert(m_cnode == 0);

    ProcessICW(m_hwndOwner, m_ftType);

    fNews = m_ftType == FOLDER_NEWS;

    iNode = 0;
    if (fNews)
        hr = _InsertChildren(m_idFolder, 0, &iNode);
    else
        hr = _InsertChildrenSpecial(m_idFolder, 0, &iNode);
    if (FAILED(hr))
    {
        if (m_rgnode != NULL)
        {
            MemFree(m_rgnode);
            m_rgnode = NULL;
        }
        m_cnode = 0;
        m_cnodeBuf = 0;
    }
    else
    {
        Assert(iNode == m_cnode);
    }

    ListView_SetItemCount(m_hwndList, m_cnode);
    if (m_cnode > 0)
    {
        ListView_SetItemState(m_hwndList, -1, 0, LVIS_SELECTED | LVIS_FOCUSED);
        ListView_SetItemState(m_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }

    if (m_cnode == 0)
        m_pEmptyList->Show(m_hwndList, m_ftType == FOLDER_NEWS ? (LPSTR)idsEmptyNewsAcct : (LPSTR)idsEmptyMailAcct);

    UpdateWindow(m_hwndList);

    g_pStore->RegisterNotify(IINDEX_SUBSCRIBED, REGISTER_NOTIFY_NOADDREF, 0, (IDatabaseNotify *)this);
    m_fRegistered = TRUE;

    fSub = FALSE;

    if (m_cnode == 0 && (fNews || m_ftType == FOLDER_IMAP || m_ftType == FOLDER_HTTPMAIL))
    {
        if (IDYES == AthMessageBoxW(m_hwndOwner, MAKEINTRESOURCEW(idsAthena),
                        fNews ? MAKEINTRESOURCEW(idsErrNoSubscribedGroups) : MAKEINTRESOURCEW(idsErrNoSubscribedFolders),
                        0, MB_YESNO))
        {
            if (m_ftType == FOLDER_HTTPMAIL)
                DownloadNewsgroupList(m_hwndOwner, m_idFolder);
            else
                DoSubscriptionDialog(m_hwndOwner, fNews, m_idFolder);
            fSub = TRUE;
        }
    }
    else if (m_ftType == FOLDER_IMAP && NULL != g_pStore)
    {
        FOLDERINFO  fiServer;

        if (SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &fiServer)))
        {
            CheckIMAPDirty(fiServer.pszAccountId, m_hwnd, fiServer.idFolder, NOFLAGS);
            g_pStore->FreeRecord(&fiServer);
        }
    }

    if (!fSub && fNews)
        hr = NewsUtil_CheckForNewGroups(m_hwnd, m_idFolder, &m_pGroups);
}

void CAccountView::_OnContextMenu(HWND hwnd, HWND hwndFrom, int x, int y)
{
    HRESULT hr;
    int iSel, i, id;
    HMENU hmenu;
    FOLDERID idFolder;
    LV_HITTESTINFO lvhti;
    POINT pt = {x, y};

    // We only have context menus for the ListView
    if (hwndFrom != m_hwndList)
        return;

    if (MAKELPARAM(x, y) == -1) // invoked from keyboard: figure out pos.
    {
        Assert(hwndFrom == m_hwndList);
        i = ListView_GetFirstSel(m_hwndList);
        if (i == -1)
            return;

        ListView_GetItemPosition(m_hwndList, i, &pt);
        ClientToScreen(m_hwndList, &pt);
        x = pt.x;
        y = pt.y;
    }

    id = 0;

    if (WindowFromPoint(pt) == m_hwndHeader)
    {
        // Pop up the context menu.
        hmenu = LoadPopupMenu(IDR_COLUMNS_POPUP);
        if (hmenu != NULL)
        {
            // Disable sort options because we don't support sorting
            EnableMenuItem(hmenu, ID_SORT_ASCENDING, MF_GRAYED|MF_DISABLED);
            EnableMenuItem(hmenu, ID_SORT_ASCENDING, MF_GRAYED|MF_DISABLED);

            id = TrackPopupMenuEx(hmenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                             x, y, m_hwnd, NULL);

            DestroyMenu(hmenu);
        }
    }
    else
    {
        // Find out where the click happened
        lvhti.pt.x = x;
        lvhti.pt.y = y;
        ScreenToClient(m_hwndList, &lvhti.pt);

        // Have the ListView tell us what element this was on
        iSel = ListView_HitTest(m_hwndList, &lvhti);
        if (iSel >= 0)
        {
            idFolder = _IdFromIndex((DWORD)iSel);

            hr = MenuUtil_GetContextMenu(idFolder, (IOleCommandTarget *)this, &hmenu);
            if (SUCCEEDED(hr))
            {
                id = TrackPopupMenuEx(hmenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                                 x, y, m_hwnd, NULL);
                DestroyMenu(hmenu);
            }
        }
    }

    if (id != 0)
        Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
}

int __cdecl GroupCompare(const void *lParam1, const void *lParam2)
    {
    int cmp;
    HRESULT hr;
    FOLDERINFO info1, info2;

    IxpAssert(lParam1 != NULL);
    IxpAssert(lParam2 != NULL);

    if (FAILED(g_pStore->GetFolderInfo(((FLDRNODE *)lParam1)->id, &info1)))
        return -1;
    if (FAILED(g_pStore->GetFolderInfo(((FLDRNODE *)lParam2)->id, &info2)))
    {
        g_pStore->FreeRecord(&info1);
        return 1;
    }

    IxpAssert(0 == (info1.dwFlags & FOLDER_SERVER));
    IxpAssert(0 == (info2.dwFlags & FOLDER_SERVER));
    IxpAssert(info1.idParent == info2.idParent);

    if (info1.tySpecial != FOLDER_NOTSPECIAL)
    {
        if (info2.tySpecial != FOLDER_NOTSPECIAL)
            cmp = info1.tySpecial - info2.tySpecial;
        else
            cmp = -1;
    }
    else
    {
        if (info2.tySpecial != FOLDER_NOTSPECIAL)
            cmp = 1;
        else
            cmp = lstrcmpi(info1.pszName, info2.pszName);
    }

    g_pStore->FreeRecord(&info1);
    g_pStore->FreeRecord(&info2);

    return(cmp);
    }

HRESULT CAccountView::_InsertFolder(LPFOLDERINFO pFolder)
{
    BOOL fHide;
    DWORD cnode, cSibs, indent, index, iFirstSib, iSib, iEnd;
    HRESULT hr;
    LV_ITEM lvi;
    FLDRNODE *rgNodeSib, *pNode;

    Assert(!!(pFolder->dwFlags & FOLDER_SUBSCRIBED));

    // Check if folder is hidden
    if (pFolder->dwFlags & FOLDER_HIDDEN)
        return S_OK; // Do not display to user

    if (pFolder->tyFolder == FOLDER_NEWS)
        return(_InsertFolderNews(pFolder));

    fHide = (m_cnode == 0);

    index = _GetFolderIndex(pFolder->idFolder);
    if (index != -1)
    {
        // TODO: are we safe to assume that this one doesn't have subscribed
        // children that we aren't aware of????
        return(S_OK);
    }

    // figure out which folder the new folder is being inserted under
    if (pFolder->idParent == m_idFolder)
    {
        iFirstSib = 0;
        indent = 0;
    }
    else
    {
        index = _GetFolderIndex(pFolder->idParent);
        if (index == -1)
            return(S_OK);
        indent = m_rgnode[index].indent + 1;
        iFirstSib = index + 1;
    }

    // get all of the siblings of the new folder
    if (!MemAlloc((void **)&rgNodeSib, (m_cnode - iFirstSib + 1) * sizeof(FLDRNODE)))
        return(E_OUTOFMEMORY);

    cSibs = 0;
    for (iSib = iFirstSib, pNode = &m_rgnode[iSib]; iSib < m_cnode; iSib++, pNode++)
    {
        if (pNode->indent < indent)
        {
            break;
        }
        else if (pNode->indent == indent)
        {
            rgNodeSib[cSibs].id = pNode->id;
            cSibs++;
        }
    }
    iEnd = iSib;

    // sort the new folder and its siblings, so we know where the new one needs
    // to be inserted
    rgNodeSib[cSibs].id = pFolder->idFolder;
    cSibs++;
    qsort(rgNodeSib, cSibs, sizeof(FLDRNODE), GroupCompare);

    // find out where we're sticking the new folder
    for (iSib = 0, pNode = rgNodeSib; iSib < cSibs; iSib++, pNode++)
    {
        if (pNode->id == pFolder->idFolder)
            break;
    }
    Assert(iSib < cSibs);

    if (iSib + 1 < cSibs)
        index = _GetFolderIndex(rgNodeSib[iSib + 1].id);
    else
        index = iEnd;

    MemFree(rgNodeSib);

    if (m_cnode == m_cnodeBuf)
    {
        cnode = m_cnodeBuf + CALLOCIDBUF;
        if (!MemRealloc((void **)&m_rgnode, cnode * sizeof(FLDRNODE)))
            return(E_OUTOFMEMORY);

        m_cnodeBuf = cnode;
    }

    SetWindowRedraw(m_hwndList, FALSE);

    if (index < m_cnode)
        MoveMemory(&m_rgnode[index + 1], &m_rgnode[index], (m_cnode - index) * sizeof(FLDRNODE));

    m_rgnode[index].id = pFolder->idFolder;
    m_rgnode[index].indent = indent;
    m_rgnode[index].dwDownload = m_dwDownloadDef;
    m_cnode++;

    iEnd = index + 1;
    if (!!(pFolder->dwFlags & FOLDER_HASCHILDREN))
    {
        hr = _InsertChildren(pFolder->idFolder, indent + 1, &iEnd);
        // TODO: error handling
        Assert(SUCCEEDED(hr));
    }

    ZeroMemory(&lvi, sizeof(LV_ITEM));
    while (index < iEnd)
    {
        lvi.iItem = index++;
        ListView_InsertItem(m_hwndList, &lvi);
    }

    if (fHide)
        m_pEmptyList->Hide();

    SetWindowRedraw(m_hwndList, TRUE);
    UpdateWindow(m_hwndList);

    return(S_OK);
}

HRESULT CAccountView::_InsertFolderNews(LPFOLDERINFO pFolder)
{
    DWORD cnode;
    HRESULT hr;
    LV_ITEM lvi;

    if (m_cnode == m_cnodeBuf)
    {
        cnode = m_cnodeBuf + CALLOCIDBUF;
        if (!MemRealloc((void **)&m_rgnode, cnode * sizeof(FLDRNODE)))
            return(E_OUTOFMEMORY);

        m_cnodeBuf = cnode;
    }

    m_rgnode[m_cnode].id = pFolder->idFolder;
    m_rgnode[m_cnode].indent = 0;
    m_rgnode[m_cnode].dwDownload = m_dwDownloadDef;
    m_cnode++;

    qsort(m_rgnode, m_cnode, sizeof(FLDRNODE), GroupCompare);

    ZeroMemory(&lvi, sizeof(LV_ITEM));
    lvi.iItem = _GetFolderIndex(pFolder->idFolder);
    Assert(lvi.iItem != -1);
    ListView_InsertItem(m_hwndList, &lvi);

    if (m_cnode == 1)
        m_pEmptyList->Hide();

    return(S_OK);
}

int CAccountView::_GetFolderIndex(FOLDERID id)
{
    int i;
    FLDRNODE *pnode;

    for (i = 0, pnode = m_rgnode; (DWORD)i < m_cnode; i++, pnode++)
    {
        if (id == pnode->id)
            break;
    }

    if ((DWORD)i == m_cnode)
        i = -1;

    return(i);
}

HRESULT CAccountView::_UpdateFolder(LPFOLDERINFO pFolder1, LPFOLDERINFO pFolder2)
{
    HRESULT hr;
    int iItem;

    // Visibility change (FOLDER_SUBSCRIBED or FOLDER_HIDDEN)
    if (ISFLAGSET(pFolder1->dwFlags, FOLDER_SUBSCRIBED) != ISFLAGSET(pFolder2->dwFlags, FOLDER_SUBSCRIBED) ||
        ISFLAGSET(pFolder1->dwFlags, FOLDER_HIDDEN) != ISFLAGSET(pFolder2->dwFlags, FOLDER_HIDDEN))
    {
        if (ISFLAGSET(pFolder2->dwFlags, FOLDER_SUBSCRIBED) && ISFLAGCLEAR(pFolder2->dwFlags, FOLDER_HIDDEN))
        {
            hr = _InsertFolder(pFolder2);
        }
        else
        {
            hr = _DeleteFolder(pFolder2);
        }

        return(hr);
    }

    // Moved or renamed
    if (pFolder1->idParent != pFolder2->idParent ||
        0 != lstrcmpi(pFolder1->pszName, pFolder2->pszName))
    {
        Assert(m_ftType != FOLDER_NEWS);

        hr = _DeleteFolder(pFolder1);

        hr = _InsertFolder(pFolder2);

        return(hr);
    }

    // State change
    if (pFolder1->cUnread != pFolder2->cUnread ||
        pFolder1->cMessages != pFolder2->cMessages ||
        (pFolder1->dwFlags & FOLDER_SYNCMASK) != (pFolder2->dwFlags & FOLDER_SYNCMASK) ||
        0 != lstrcmp(pFolder1->pszName, pFolder2->pszName) ||

        // news only
        (pFolder1->tyFolder == FOLDER_NEWS &&
        (pFolder1->dwServerCount != pFolder2->dwServerCount ||
        pFolder1->dwServerHigh != pFolder2->dwServerHigh ||
        pFolder1->dwServerLow != pFolder2->dwServerLow)))
    {
        iItem = _GetFolderIndex(pFolder1->idFolder);
        if (iItem != -1)
            ListView_RedrawItems(m_hwndList, iItem, iItem);
    }

    return(S_OK);
}

int CAccountView::_GetSubFolderCount(int index)
{
    DWORD indent;
    int indexT;

    Assert((DWORD)index < m_cnode);

    indent = m_rgnode[index].indent;

    index++;
    indexT = index;
    while ((DWORD)index < m_cnode)
    {
        if (m_rgnode[index].indent <= indent)
            break;
        index++;
    }

    return(index - indexT);
}

HRESULT CAccountView::_DeleteFolder(LPFOLDERINFO pFolder)
{
    HRESULT hr;
    int iItem, cSub;

    iItem = _GetFolderIndex(pFolder->idFolder);
    if (iItem == -1)
        return(S_OK);

    SetWindowRedraw(m_hwndList, FALSE);

    cSub = _GetSubFolderCount(iItem);

    if ((DWORD)(iItem + cSub) < (m_cnode - 1))
        MoveMemory(&m_rgnode[iItem], &m_rgnode[iItem + cSub + 1], (m_cnode - (iItem + cSub + 1)) * sizeof(FLDRNODE));
    m_cnode -= cSub + 1;

    while (cSub >= 0)
    {
        ListView_DeleteItem(m_hwndList, iItem + cSub);
        cSub--;
    }

    if (m_cnode == 0)
        m_pEmptyList->Show(m_hwndList, m_ftType == FOLDER_NEWS ? (LPSTR)idsEmptyNewsAcct : (LPSTR)idsEmptyMailAcct);

    SetWindowRedraw(m_hwndList, TRUE);
    UpdateWindow(m_hwndList);

    return(S_OK);
}

HRESULT CAccountView::_HandleAccountRename(LPFOLDERINFO pFolder)
{
    char sz[CCHMAX_STRINGRES];
    HDC hdc;
    SIZE size;
    HFONT hfontBold, hfontOld;

    Assert(m_pszMajor != NULL);
    Assert(pFolder != NULL);

    AthLoadString(idsSyncManager, sz, ARRAYSIZE(sz));
    wsprintf(m_pszMajor, sz, pFolder->pszName);

    hfontBold = HGetCharSetFont(FNT_SYS_ICON_BOLD, NULL);

    hdc = GetDC(m_hwnd);

    hfontOld = (HFONT)SelectObject(hdc, (HGDIOBJ)hfontBold);

    GetTextExtentPoint32(hdc, m_pszMajor, lstrlen(m_pszMajor), &size);
    m_rcMajor.left = SUBSCRIBE_BORDER;
    m_rcMajor.top = SUBSCRIBE_BORDER;
    m_rcMajor.right = m_rcMajor.left + size.cx;
    m_rcMajor.bottom = m_rcMajor.top + size.cy;

    SelectObject(hdc, hfontOld);
    ReleaseDC(m_hwnd, hdc);

    InvalidateRect(m_hwnd, NULL, FALSE);
    UpdateWindow(m_hwnd);

    return(S_OK);
}

STDMETHODIMP CAccountView::OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pDB)
{
    BOOL                fMatch;
    DWORD               i;
    FOLDERINFO          Folder1={0};
    FOLDERINFO          Folder2={0};
    FOLDERINFO          Server;
    ORDINALLIST         Ordinals;
    TRANSACTIONTYPE     tyTransaction;
    INDEXORDINAL        iIndex;
    HRESULT             hr;

    while (hTransaction)
    {
        hr = pDB->GetTransaction(&hTransaction, &tyTransaction, &Folder1, &Folder2, &iIndex, &Ordinals);
        if (FAILED(hr))
            break;

        if (Folder1.idFolder == m_idFolder)
        {
            if (TRANSACTION_UPDATE == tyTransaction &&
                0 != lstrcmp(Folder1.pszName, Folder2.pszName))
            {
                hr = _HandleAccountRename(&Folder2);
            }
        }
        else if (Folder1.tyFolder == m_ftType && 0 == (Folder1.dwFlags & FOLDER_SERVER))
        {
            fMatch = FALSE;

            if (m_ftType == FOLDER_LOCAL)
            {
                if (Folder1.tyFolder == FOLDER_LOCAL)
                    fMatch = TRUE;
            }
            else
            {
                hr = GetFolderServer(Folder1.idParent, &Server);
                if (SUCCEEDED(hr))
                {
                    fMatch = (Server.idFolder == m_idFolder);
                    g_pStore->FreeRecord(&Server);
                }
            }

            if (fMatch)
            {
                // Insert (new Folder notification)
                if (TRANSACTION_INSERT == tyTransaction)
                {
                    hr = _InsertFolder(&Folder1);
                }
                // Update
                else if (TRANSACTION_UPDATE == tyTransaction)
                {
                    hr = _UpdateFolder(&Folder1, &Folder2);
                }

                // Delete
                else if (TRANSACTION_DELETE == tyTransaction)
                {
                    hr = _DeleteFolder(&Folder1);
                }
            }
        }
    }

    g_pStore->FreeRecord(&Folder1);
    g_pStore->FreeRecord(&Folder2);

    return(S_OK);
}

HRESULT CAccountView::_ToggleDownload(int iItem)
{
    FLDRNODE *pnode;
    FOLDERINFO info;
    HRESULT hr;

    pnode = _NodeFromIndex(iItem);
    Assert(pnode != NULL);

    hr = g_pStore->GetFolderInfo(pnode->id, &info);
    if (SUCCEEDED(hr))
    {
        if (!!(info.dwFlags & FOLDER_SUBSCRIBED))
        {
            if (!!(info.dwFlags & FOLDER_SYNCMASK))
            {
                pnode->dwDownload = (info.dwFlags & FOLDER_SYNCMASK);
                info.dwFlags &= ~FOLDER_SYNCMASK;
            }
            else
            {
                Assert(0 == (pnode->dwDownload & ~FOLDER_SYNCMASK));
                info.dwFlags |= pnode->dwDownload;
            }

            hr = g_pStore->UpdateRecord(&info);
        }

        g_pStore->FreeRecord(&info);
    }

    return(S_OK);
}

HRESULT CAccountView::_MarkForDownload(DWORD nCmdID)
{
    int iSel;
    FLDRFLAGS flag;
    FOLDERINFO info;
    HRESULT hr;
    FLDRNODE *pnode;

    switch (nCmdID)
    {
        case ID_MARK_RETRIEVE_FLD_NEW_HDRS:
            flag = FOLDER_DOWNLOADHEADERS;
            break;

        case ID_MARK_RETRIEVE_FLD_NEW_MSGS:
            flag = FOLDER_DOWNLOADNEW;
            break;

        case ID_MARK_RETRIEVE_FLD_ALL_MSGS:
            flag = FOLDER_DOWNLOADALL;
            break;

        case ID_UNMARK_RETRIEVE_FLD:
            flag = 0;
            break;

        default:
            Assert(FALSE);
            break;
    }

    iSel = -1;
    while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
    {
        pnode = _NodeFromIndex(iSel);

        hr = g_pStore->GetFolderInfo(pnode->id, &info);
        if (SUCCEEDED(hr))
        {
            if (!!(info.dwFlags & FOLDER_SUBSCRIBED) &&
                (info.dwFlags & FOLDER_SYNCMASK) != flag)
            {
                if (flag == 0)
                    pnode->dwDownload = (info.dwFlags & FOLDER_SYNCMASK);
                info.dwFlags &= ~FOLDER_SYNCMASK;
                if (flag != 0)
                    info.dwFlags |= flag;

                hr = g_pStore->UpdateRecord(&info);
            }

            g_pStore->FreeRecord(&info);
        }
    }

    return(S_OK);
}

HRESULT CAccountView::_Subscribe(BOOL fSubscribe)
{
    FOLDERID *pid;
    int iSel, cSel, cid;

    cSel = ListView_GetSelectedCount(m_hwndList);
    if (cSel > 0)
    {
        if (!MemAlloc((void **)&pid, cSel * sizeof(FOLDERID)))
            return(E_OUTOFMEMORY);

        cid = 0;
        iSel = -1;
        while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
        {
            Assert(cid < cSel);
            pid[cid] = _IdFromIndex(iSel);
            cid++;
        }

        MenuUtil_OnSubscribeGroups(m_hwndOwner, pid, cid, fSubscribe);

        MemFree(pid);
    }

    return(S_OK);
}

HRESULT CAccountView::_MarkAllRead()
{
    int iSel;
    IMessageFolder *pFolder;
    ADJUSTFLAGS flags;
    FOLDERID idFolder;
    CStoreCB *pCB;
    HRESULT hr;

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(m_hwndOwner, MAKEINTRESOURCE(idsSettingMessageFlags), FALSE);
    if (SUCCEEDED(hr))
    {
        flags.dwAdd = ARF_READ;
        flags.dwRemove = 0;

        iSel = -1;
        while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
        {
            idFolder = _IdFromIndex(iSel);

            if (SUCCEEDED(g_pStore->OpenFolder(idFolder, NULL, NOFLAGS, &pFolder)))
            {
                hr = pFolder->SetMessageFlags(NULL, &flags, NULL, (IStoreCallback *)pCB);
                if (hr == E_PENDING)
                {
                    hr = pCB->Block();

                    pCB->Reset();
                }

                pFolder->Release();
            }

            if (FAILED(hr))
                break;
        }

        pCB->Close();
    }

    pCB->Release();

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\cdrptrgt.h ===
////////////////////////////////////////////////////////////////////////
//
//  CDropTarget
//
//  IDropTarget implementation
//
////////////////////////////////////////////////////////////////////////

#ifndef _INC_CDRPTRGT_H
#define _INC_CDRPTRGT_H


class CDropTarget : public IDropTarget
{
public:
    // *** IUnknown methods ***
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // *** IDropTarget methods ***
    HRESULT STDMETHODCALLTYPE DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    HRESULT STDMETHODCALLTYPE DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    HRESULT STDMETHODCALLTYPE DragLeave(void);
    HRESULT STDMETHODCALLTYPE Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    CDropTarget(HWND hwndOwner, int iFolderType, LPCITEMIDLIST pidl);
    ~CDropTarget();

private:
    UINT            m_cRef;
    HWND            m_hwndOwner;
    int             m_iFolderType;
    LPFOLDERIDLIST  m_pidl;
    DWORD           m_dwEffect;
};

#endif // _INC_CDRPTRGT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\browser.cpp ===
/*
 *    browser.cpp                                                  
 *    
 *    Purpose:                     
 *        Implements a browser object
 *    
 *    Owner:
 *        EricAn
 *    
 *    Copyright (C) Microsoft Corp. 1996
 */
#include "pch.hxx"
#include "bodybar.h"
#include "browser.h"
#include <shellapi.h>
#include "resource.h"
#include "options.h"
#include "ipab.h"
#include "inetcfg.h"
#include "acctutil.h"
#include "mailutil.h"
#include "impapi.h"
#include "menuutil.h"
#include "ourguid.h"
#include "thormsgs.h"
#include "error.h"
#include "fonts.h"
#include "treeview.h"
#include "goptions.h"
#include "strconst.h"
#include "note.h"
#include "tbbands.h"
#include "statbar.h"
#include "newfldr.h"
#include "conman.h"
#include "acctutil.h"
#include "spoolapi.h"
#include "statnery.h"
#include "inpobj.h"
#include "fldbar.h"
#include "layout.h"
#include "htmlhelp.h"
#include "shared.h"
#include "mailutil.h"
#include <shlwapi.h>
#include "shlwapip.h" 
#include "instance.h"
#include "ruleutil.h"
#include "envfact.h"
#include "storutil.h"
#include "finder.h"
#include "demand.h"
#include "multiusr.h"
#include "menures.h"
#include "store.h"
#include "subscr.h"
#include "outbar.h"
#include "navpane.h"
#include "msostd.h"
#include "inetreg.h"
#include "mapiutil.h"
#include "adbar.h"
#include <mirror.h>

#define MAX_SIZE_EXT_STR    128

ASSERTDATA

/////////////////////////////////////////////////////////////////////////////
// 
// Defines
//

#define CBM_POSTCREATE  (WM_USER + 4000)
#define TIME_TO_CLEAR_NEWMSGSTATUS      (20*1000)    // 20 seconds
#define TIMER_CLEAR_STATUS              1003

/////////////////////////////////////////////////////////////////////////////
// 
// Macros
//

#define CBDOUT(x) DOUTL(DOUT_LEVEL4, x)

/////////////////////////////////////////////////////////////////////////////
//
// Global Data
//

static const TCHAR s_szCallClient[] = TEXT("Internet Call");
static const TCHAR s_szMailClient[] = TEXT("Mail");
static const TCHAR s_szNewsClient[] = TEXT("News");

static HACCEL s_hAccelBrowser = NULL;
static s_fQuickShutdown = FALSE;

enum {
    IMAGE_STATBAR_BLANK,
    IMAGE_STATBAR_WARNING,
    IMAGE_STATBAR_SPOOLER
};

/////////////////////////////////////////////////////////////////////////////
// 
// Prototypes
//

//
//  FUNCTION:   ShellUtil_IsRegisteredClient()
//
//  PURPOSE:    Returns whether the specified client type is handled.
//
BOOL ShellUtil_IsRegisteredClient(LPCTSTR pszClient)
{
    LONG cbSize = 0;
    TCHAR szKey[MAX_PATH];
    
    wsprintf(szKey, c_szPathFileFmt, c_szRegPathClients, pszClient);
    return (RegQueryValue(HKEY_LOCAL_MACHINE, szKey, NULL, &cbSize) == ERROR_SUCCESS) && 
           (cbSize > 1);
}

//
//  FUNCTION:   ShellUtil_RunIndirectRegCommand()
//
//  PURPOSE:    find the default value under HKLM\Software\Clients\pszClient
//              tack on shell\open\command
//              then runreg that
//
void ShellUtil_RunClientRegCommand(HWND hwnd, LPCTSTR pszClient)
{
    TCHAR szDefApp[MAX_PATH], szExpanded[MAX_PATH];
    TCHAR szKey[MAX_PATH];
    DWORD cbSize = sizeof(szDefApp);
    DWORD dwType;
    
    wsprintf(szKey, c_szPathFileFmt, c_szRegPathClients, pszClient);
    if (RegQueryValueEx(HKEY_LOCAL_MACHINE, szKey, 0, NULL, (LPBYTE)szDefApp, &cbSize) == ERROR_SUCCESS) 
    {        
        TCHAR szFullKey[MAX_PATH];
        
        // tack on shell\open\command
        wsprintf(szFullKey, TEXT("%s\\%s\\shell\\open\\command"), szKey, szDefApp);
        cbSize = sizeof(szDefApp);
        if (RegQueryValueEx(HKEY_LOCAL_MACHINE, szFullKey, 0, &dwType, (LPBYTE)szDefApp, &cbSize) == ERROR_SUCCESS)
        {
            LPSTR pszArgs;
            SHELLEXECUTEINFO ExecInfo;
            
            pszArgs = PathGetArgs(szDefApp);
            PathRemoveArgs(szDefApp);
            PathUnquoteSpaces(szDefApp);
            
            if (REG_EXPAND_SZ == dwType)
            {
                ExpandEnvironmentStrings(szDefApp, szExpanded, ARRAYSIZE(szExpanded));
                ExecInfo.lpFile = szExpanded;
            }
            else
                ExecInfo.lpFile = szDefApp;
            
            ExecInfo.hwnd = hwnd;
            ExecInfo.lpVerb = NULL;
            ExecInfo.lpParameters = pszArgs;
            ExecInfo.lpDirectory = NULL;
            ExecInfo.nShow = SW_SHOWNORMAL;
            ExecInfo.fMask = 0;
            ExecInfo.cbSize = sizeof(SHELLEXECUTEINFO);
            
            ShellExecuteEx(&ExecInfo);
        }
    }
}

/////////////////////////////////////////////////////////////////////////
//
// Constructors, Destructors, and Initialization
//

CBrowser::CBrowser()
{
    m_cRef = 1;
    m_hwnd = NULL;
    m_pView = NULL;
    m_pViewCT = NULL;
    m_hwndInner = NULL;
    m_ftSel = FOLDER_TYPESMAX;
    m_idSelected = FOLDERID_INVALID;
    m_fPainted = FALSE;
    m_hIconPhone = 0;
    m_hIconError = 0;
    m_hIconAthena = 0;
    m_hIconOffline = 0;
    m_hIcon = 0;
    m_hIconSm = 0;
    m_pTreeView = NULL;
    m_pStatus = NULL;
    m_pCoolbar = NULL;
    m_pBodyBar = NULL;
    m_pFolderBar = NULL;
    m_hwndLastFocus = NULL;
    m_fInternal = 0;
    *m_szName = 0;
    ZeroMemory(m_rgTBar, sizeof(m_rgTBar));
    m_itbLastFocus = ITB_NONE;
    m_cAcctMenu = 0;
    m_pAcctMenu = NULL;
    m_fAnimate = FALSE;
    m_hMenuLanguage = NULL;
    m_pDocObj = NULL;
    CoIncrementInit("CBrowser::CBrowser", MSOEAPI_START_SHOWERRORS, NULL, NULL);
    m_fEnvMenuInited = FALSE;
    m_fRebuildAccountMenu = TRUE;
    m_fInitNewAcctMenu = FALSE;
    m_hMenu = NULL;
    ZeroMemory(&m_hlDisabled, sizeof(HWNDLIST));
    m_dwIdentCookie = 0;
    m_fSwitchIsLogout = FALSE;
    m_fNoModifyAccts = FALSE;
    m_pAdBar    = NULL;
}

CBrowser::~CBrowser()
{
    Assert(NULL == m_pView);
    Assert(NULL == m_pViewCT);
    SafeRelease(m_pTreeView);
    SafeRelease(m_pCoolbar);
    SafeRelease(m_pBodyBar);
    SafeRelease(m_pFolderBar);
    SafeRelease(m_pStatus);
    SafeRelease(m_pOutBar);
    SafeRelease(m_pNavPane);
    SafeRelease(m_pAdBar);

    SafeMemFree(m_pAcctMenu);
    g_pBrowser = NULL;
           
    if (m_hIconPhone)
        SideAssert(DestroyIcon(m_hIconPhone));

    if (m_hIconError)
        SideAssert(DestroyIcon(m_hIconError));

    if (m_hIconAthena)
        SideAssert(DestroyIcon(m_hIconAthena));

    if (m_hIconOffline)
        SideAssert(DestroyIcon(m_hIconOffline));
    
    if (m_hIcon)
        SideAssert(DestroyIcon(m_hIcon));

    if (m_hIconSm)
        SideAssert(DestroyIcon(m_hIconSm));

    if (m_hMenuLanguage)
    {
        DeinitMultiLanguage();
        if(IsMenu(m_hMenuLanguage))
            DestroyMenu(m_hMenuLanguage);
    }

    DOUT("CBrowser calling CoDecrementInit()");
    CoDecrementInit("CBrowser::CBrowser", NULL);

    if (m_hMenu && IsMenu(m_hMenu))
        DestroyMenu(m_hMenu);
}

HRESULT CBrowser::HrInit(UINT nCmdShow, FOLDERID idFolder, HWND hWndParent)
{
    DWORD cb, type, dw;
    WNDCLASSEX      wc;
    WINDOWPLACEMENT wp;
    DWORD dwExStyle = 0;
    // Only load the layout from the registry only if we're standalone
    LoadLayoutSettings();

    m_idSelected = idFolder;

    if (!s_hAccelBrowser)
        s_hAccelBrowser = LoadAccelerators(g_hLocRes, MAKEINTRESOURCE(IDA_BROWSER_ACCEL));

    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, c_szBrowserWndClass, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = CBrowser::BrowserWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hIcon            = NULL;         // Handled in WM_CREATE
        wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground    = NULL;
        wc.lpszMenuName     = NULL;         // Handled in WM_CREATE
        wc.lpszClassName    = c_szBrowserWndClass;
        wc.hIconSm          = NULL;         // Handled in WM_CREATE
        if (RegisterClassEx(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
            return E_FAIL;
    }
    if(IS_BIDI_LOCALIZED_SYSTEM())
    {
        dwExStyle |= RTL_MIRRORED_WINDOW;
    }
    m_hwnd = CreateWindowEx(dwExStyle, c_szBrowserWndClass, NULL, WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                            hWndParent, NULL, g_hInst, (LPVOID) this);

    if (GetOption(OPT_BROWSERPOS, (LPVOID)&wp, sizeof(wp)))
    {
        // If the user has SHOWNORMAL as the default setting in the shortcut, then
        // we'll respect the setting that we saved earlier.  Otherwise, we have to
        // go with what's in the shortcut.
        if (nCmdShow != SW_SHOWNORMAL)
            wp.showCmd = nCmdShow;

        // Also, don't allow the user to come up minimized.  That's kinda wierd.
        else if (wp.showCmd == SW_SHOWMINIMIZED)
            wp.showCmd = SW_SHOWNORMAL;

        SetWindowPlacement(m_hwnd, &wp);
    }
    else
    {
        CenterDialog(m_hwnd);
        ShowWindow(m_hwnd, nCmdShow);
    }

    // Register with identity manager
    SideAssert(SUCCEEDED(MU_RegisterIdentityNotifier((IUnknown *)(IAthenaBrowser *)this, &m_dwIdentCookie)));

    SetForegroundWindow(m_hwnd);

    if (!m_hwnd)
        return E_FAIL;    
    
    cb = sizeof(DWORD);
    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegFlat, c_szRegValNoModifyAccts, &type, &dw, &cb) &&
        dw != 0)
        m_fNoModifyAccts = TRUE;

    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////
//
// OLE Interfaces
//
    
////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CBrowser::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IAthenaBrowser *) this;
    else if (IsEqualIID(riid, IID_IAthenaBrowser))
        *ppvObj = (void*) (IAthenaBrowser *) this;
    else if (IsEqualIID(riid, IID_IDockingWindowSite))
        *ppvObj = (void*) (IDockingWindowSite *) this;
    else if (IsEqualIID(riid, IID_IInputObjectSite))
        *ppvObj = (void*) (IInputObjectSite *) this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (void*) (IOleCommandTarget *) this;
    else if (IsEqualIID(riid, IID_IIdentityChangeNotify))
        *ppvObj = (void*) (IIdentityChangeNotify *) this;
    else        
        {
        *ppvObj = NULL;
        return E_NOINTERFACE;
        }

    AddRef();
    return NOERROR;
}

ULONG STDMETHODCALLTYPE CBrowser::AddRef()
{
    DOUT(TEXT("CBrowser::AddRef() - m_cRef = %d"), m_cRef + 1);
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CBrowser::Release()
{
    DOUT(TEXT("CBrowser::Release() - m_cRef = %d"), m_cRef - 1);
    if (--m_cRef == 0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

////////////////////////////////////////////////////////////////////////
//
//  IStoreCallback
//
////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBrowser::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    *phwndParent = GetLastActivePopup(m_hwnd);
    return(S_OK);
}

////////////////////////////////////////////////////////////////////////
//
//  IOleWindow
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CBrowser::GetWindow(HWND * lphwnd)                         
{
    *lphwnd = m_hwnd;
    return (m_hwnd ? S_OK : E_FAIL);
}

HRESULT STDMETHODCALLTYPE CBrowser::ContextSensitiveHelp(BOOL fEnterMode)            
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////
//
//  IAthenaBrowser
//
////////////////////////////////////////////////////////////////////////

BOOL IsOwner(HWND hwndOwner, HWND hwnd)
{
    // Loop through until we find the topmost window
    HWND hwndTemp = hwnd;
    if (GetParent(hwndTemp))
    {
        while (GetParent(hwndTemp))
            hwndTemp = GetParent(hwndTemp);

        if (hwndOwner == hwndTemp)
            return (TRUE);
    }

    return (FALSE);
}

HRESULT CBrowser::TranslateAccelerator(LPMSG lpmsg)
{
    HWND hwndFocus;
    BOOL fInnerValid, fViewFocus;
    int  i;

    if (!(m_hwnd && IsWindow(m_hwnd)))
        return S_FALSE;

    if (FWABTranslateAccelerator(lpmsg))
        return S_TRUE;

    hwndFocus = GetFocus();

    //check if it is a menu message
    if (!GetTlsGlobalActiveNote())
    {
        if (m_pCoolbar->IsMenuMessage(lpmsg) == S_OK)
            return S_OK;
    }

    // handle the mousewheel messages for this thread
    if ((g_msgMSWheel && (lpmsg->message == g_msgMSWheel)) || (lpmsg->message == WM_MOUSEWHEEL))
        {
        POINT pt;
        HWND  hwndT;

        pt.x = GET_X_LPARAM(lpmsg->lParam);
        pt.y = GET_Y_LPARAM(lpmsg->lParam);

        hwndT = WindowFromPoint(pt);
        if (hwndT != m_hwnd && IsChild(m_hwnd, hwndT))
            SendMessage(hwndT, lpmsg->message, lpmsg->wParam, lpmsg->lParam);
        else if (hwndFocus != m_hwnd && IsChild(m_hwnd, hwndFocus))
            SendMessage(hwndFocus, lpmsg->message, lpmsg->wParam, lpmsg->wParam);
        else
            return S_FALSE;
        return S_OK;
        }

    HWND hwndDropDown = HwndGlobalDropDown();
    BOOL fRetCode;

    if (hwndDropDown)
        {
        if (lpmsg->message == WM_LBUTTONDOWN ||
            lpmsg->message == WM_NCLBUTTONDOWN ||
            lpmsg->message == WM_RBUTTONDOWN ||
            lpmsg->message == WM_NCRBUTTONDOWN)
            {
            fRetCode = (BOOL)::SendMessage(hwndDropDown, WMR_CLICKOUTSIDE,
                                           CLK_OUT_MOUSE, (LPARAM)lpmsg->hwnd);
            if (fRetCode)
                return (S_OK);
            }

        if (lpmsg->message == WM_KEYDOWN &&
            // One of the possible hot keys
            (lpmsg->wParam==VK_ESCAPE || lpmsg->wParam==VK_TAB))
            {
            fRetCode = (BOOL)::SendMessage(hwndDropDown, WMR_CLICKOUTSIDE,
                                           CLK_OUT_KEYBD, (LPARAM)lpmsg->wParam);
            if (fRetCode)
                return S_OK;
            }
        }

    if (!(hwndFocus && (IsChild(m_hwnd, hwndFocus) || m_hwnd == hwndFocus || IsOwner(m_hwnd, hwndFocus))))
        return S_FALSE;

    fInnerValid = m_pView && m_hwndInner && IsWindow(m_hwndInner);
    fViewFocus = fInnerValid && hwndFocus && (IsChild(m_hwndInner, hwndFocus) || m_hwndInner == hwndFocus);

    if (fViewFocus)
    {
        if (m_pView->TranslateAccelerator(lpmsg) == S_OK)
            return S_OK;
    }

    for (i=0; i<ITB_MAX; i++)
        {
        if (m_rgTBar[i].ptbar && UnkHasFocusIO(m_rgTBar[i].ptbar) == S_OK)
            {
            if (UnkTranslateAcceleratorIO(m_rgTBar[i].ptbar, lpmsg) == S_OK)
                return S_OK;
            break;
            }
        }

    // Handle tabbing between windows
    if (lpmsg->hwnd &&
        IsChild(m_hwnd, lpmsg->hwnd))
    {
        if (lpmsg->message == WM_KEYDOWN)
        {
            if (lpmsg->wParam == VK_TAB && (FALSE == !!(0x8000 & GetKeyState(VK_CONTROL))))
            {
                SHORT state = GetKeyState(VK_SHIFT);
                HWND hwndNext = GetNextDlgTabItem(m_hwnd, GetFocus(), !!(state & 0x8000));
                SetFocus(hwndNext);
                return (S_OK);
            }
        }
    }

    if (lpmsg->hwnd &&
        IsChild(m_hwnd, lpmsg->hwnd) && s_hAccelBrowser && ::TranslateAccelerator(m_hwnd, s_hAccelBrowser, lpmsg))
        return S_OK;

    // if the view doesn't have focus, it still gets a chance at the accelerator, after the browser
    if (fInnerValid && !fViewFocus)
        if (m_pView->TranslateAccelerator(lpmsg) == S_OK)
            return S_OK;

    return S_FALSE;
}

//
//  Add the specified toolbar (as punkSrc) to this toolbar site
//
// Returns: S_OK, if successfully done.
//          E_FAIL, if failed (exceeded maximum).
//          E_NOINTERFACE, the toolbar does not support an approriate interface.
//
HRESULT CBrowser::AddToolbar(IUnknown* punk, DWORD dwIndex, BOOL fShow, BOOL fActivate)
{
    HRESULT hres = E_FAIL;

    Assert(ITB_NONE == FindTBar(punk));
    Assert(dwIndex < ITB_MAX);
    Assert(m_rgTBar[dwIndex].ptbar == NULL);

    if (punk->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&m_rgTBar[dwIndex].pOleCmdTarget) != S_OK)
    {
        m_rgTBar[dwIndex].pOleCmdTarget = NULL;
    }

    hres = punk->QueryInterface(IID_IDockingWindow, (LPVOID*)&m_rgTBar[dwIndex].ptbar);
    if (SUCCEEDED(hres)) 
    {
        m_rgTBar[dwIndex].fShow = fShow;
        UnkSetSite(m_rgTBar[dwIndex].ptbar, (IAthenaBrowser *)this);

        if (fActivate)
            m_rgTBar[dwIndex].ptbar->ShowDW(fShow);
    }

    return hres;
}

HRESULT CBrowser::ShowToolbar(IUnknown* punkSrc, BOOL fShow)
{
    UINT itb = FindTBar(punkSrc);
    if (itb == ITB_NONE)
        {
        Assert(0);
        return E_INVALIDARG;
        }

    if (m_rgTBar[itb].ptbar)
        {
        m_rgTBar[itb].fShow = fShow;
        m_rgTBar[itb].ptbar->ShowDW(fShow);
        }

    return S_OK;
}

HRESULT CBrowser::RemoveToolbar(IUnknown* punkSrc)
{
    UINT itb = FindTBar(punkSrc);
    if (itb == ITB_NONE)
    {
        Assert(0);
        return E_INVALIDARG;
    }
    
    ReleaseToolbarItem(itb, TRUE);
    
    // Clear the rect and resize the inner ones (including the view).
    SetRect(&m_rgTBar[itb].rcBorderTool, 0, 0, 0, 0);
    ResizeNextBorder(itb+1);
    
    return S_OK;
}

HRESULT CBrowser::HasFocus(UINT itb)
{
    HRESULT     hres = S_FALSE;
    
    if (ITB_OEVIEW == itb)
        hres = (ITB_OEVIEW == m_itbLastFocus) ? S_OK : S_FALSE;
    else if (m_rgTBar[itb].fShow && m_rgTBar[itb].ptbar)
        hres =  UnkHasFocusIO(m_rgTBar[itb].ptbar);
    
    return hres;
}

HRESULT CBrowser::OnViewWindowActive(IViewWindow *pAV)
{
    _OnFocusChange(ITB_OEVIEW);
    return NOERROR;
}

HRESULT CBrowser::BrowseObject(FOLDERID idFolder, DWORD dwFlags)
{
    if (!m_pTreeView)
        return E_FAIL;
    return m_pTreeView->SetSelection(idFolder, TVSS_INSERTIFNOTFOUND);
}

HRESULT CBrowser::GetStatusBar(CStatusBar * * ppStatusBar)
{
    if (m_pStatus)
    {
        *ppStatusBar = m_pStatus;
        m_pStatus->AddRef();
        return S_OK;
    }
    *ppStatusBar = NULL;
    return E_FAIL;
}

HRESULT CBrowser::GetCoolbar(CBands * * ppCoolbar)
{
    if (m_pCoolbar)
    {
        *ppCoolbar = m_pCoolbar;
        m_pCoolbar->AddRef();
        return S_OK;
    }
    *ppCoolbar = NULL;
    return E_FAIL;
}

HRESULT CBrowser::GetTreeView(CTreeView * * ppTreeView)
{
    if (m_pTreeView)
    {
        *ppTreeView = m_pTreeView;
        m_pTreeView->AddRef();
        return S_OK;
    }
    *ppTreeView = NULL;
    return E_FAIL;
}

HRESULT CBrowser::GetFolderBar(CFolderBar * * ppFolderBar)
{
    if (m_pFolderBar)
    {
        *ppFolderBar = m_pFolderBar;
        m_pFolderBar->AddRef();
        return S_OK;
    }
    *ppFolderBar = NULL;
    return E_FAIL;
}

HRESULT CBrowser::GetLanguageMenu(HMENU *phMenu, UINT uiCodepage)
{
    if(!m_hMenuLanguage)
        InitMultiLanguage();
    else if (IsMenu(m_hMenuLanguage))
        DestroyMenu(m_hMenuLanguage);
    
    UINT cp;

    if(uiCodepage)
        cp = uiCodepage;
    else if(m_pView)
    {
        IMessageWindow *pWindow;

        if (SUCCEEDED(m_pView->QueryInterface(IID_IMessageWindow, (LPVOID *) &pWindow)))
        {
            pWindow->GetCurCharSet(&cp);
            pWindow->Release();
        }
        else
            cp = GetACP();
    }
    else
        cp = GetACP();

    m_hMenuLanguage = CreateMimeLanguageMenu(TRUE,TRUE, cp);
    
    if (!m_hMenuLanguage)
        return E_FAIL;
    
    *phMenu = m_hMenuLanguage;
    return S_OK;
}

HRESULT CBrowser::InitPopupMenu(HMENU hMenu)
{
    if (!hMenu)
        return E_INVALIDARG;
    MenuUtil_EnablePopupMenu(hMenu, this);
    
    return S_OK;
}

HRESULT CBrowser::UpdateToolbar()
{
    if (m_pCoolbar)
        return (m_pCoolbar->Update());
    
    return (E_FAIL);
}


HRESULT CBrowser::GetFolderType(FOLDERTYPE *pftType)
{
    if (pftType)
    {
        *pftType = m_ftSel;
        return (S_OK);
    }
    
    return (E_INVALIDARG);
}

HRESULT CBrowser::GetCurrentFolder(FOLDERID *pidFolder)
{
    if (pidFolder)
    {
        *pidFolder = m_idSelected;
        return (S_OK);
    }
    
    return (E_INVALIDARG);
}

HRESULT CBrowser::GetCurrentView(IViewWindow **ppView)
{
    if (ppView)
    {
        *ppView = m_pView;
        (*ppView)->AddRef();
        return (S_OK);
    }
    
    return (E_INVALIDARG);
}
    
////////////////////////////////////////////////////////////////////////
//
//  IDockingWindowSite
//
////////////////////////////////////////////////////////////////////////

//
// This is an implementation of IDockingWindowSite::GetBorderDW.
//
//  This function returns a bounding rectangle for the specified toolbar
//  (by punkSrc). It gets the effective client area, then subtract border
//  area taken by "outer" toolbars. 
// 
HRESULT CBrowser::GetBorderDW(IUnknown* punkSrc, LPRECT lprectBorder)
{
    UINT itb = FindTBar(punkSrc);
    if (itb == ITB_NONE)
    {
        Assert(0);
        return E_INVALIDARG;
    }
    
    GetClientArea(lprectBorder);
    
    //
    // Subtract border area taken by "outer toolbars"
    //
    for (UINT i=0; i<itb; i++) 
    {
        lprectBorder->left += m_rgTBar[i].rcBorderTool.left;
        lprectBorder->top += m_rgTBar[i].rcBorderTool.top;
        lprectBorder->right -= m_rgTBar[i].rcBorderTool.right;
        lprectBorder->bottom -= m_rgTBar[i].rcBorderTool.bottom;
    }
    
    DOUTL(4, "CBrowser::GetBorderDW called returning=%x,%x,%x,%x",
        lprectBorder->left, lprectBorder->top, lprectBorder->right, lprectBorder->bottom);
    return S_OK;
}

HRESULT CBrowser::RequestBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths)
{
    UINT itb = FindTBar(punkSrc);
    if (itb == ITB_NONE)
    {
        Assert(0);
        return E_INVALIDARG;
    }
    
    DOUTL(4, "CBrowser::ReqestBorderSpaceST pborderwidths=%x,%x,%x,%x",
          pborderwidths->left, pborderwidths->top, pborderwidths->right, pborderwidths->bottom);
    return S_OK;
}

HRESULT CBrowser::SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths)
{
    UINT itb = FindTBar(punkSrc);
    if (itb == ITB_NONE)
    {
        Assert(0);
        return E_INVALIDARG;
    }
    
    DOUTL(4, "CBrowser::SetBorderSpaceDW pborderwidths=%x,%x,%x,%x",
          pborderwidths->left, pborderwidths->top, pborderwidths->right, pborderwidths->bottom);
    
    m_rgTBar[itb].rcBorderTool = *pborderwidths;
    ResizeNextBorder(itb+1);
    return S_OK;
}

////////////////////////////////////////////////////////////////////////
//
//  IInputObjectSite
//
////////////////////////////////////////////////////////////////////////

HRESULT CBrowser::OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus)
{
    UINT itb = FindTBar(punkSrc);
    if (itb == ITB_NONE)
    {
        //Assert(0);
        return E_INVALIDARG;
    }
    
    //
    //  Note that we keep track of which toolbar got the focus last.
    // We can't reliably monitor the kill focus event because OLE's
    // window procedure hook (for merged menu dispatching code) changes
    // focus around. 
    //
    if (fSetFocus) 
    {
        _OnFocusChange(itb);
    }
    
    UpdateToolbar();

    return S_OK;
}

////////////////////////////////////////////////////////////////////////
//
//  Support functions for IAthenaBrowser and IDockingWindowSite
//
////////////////////////////////////////////////////////////////////////

//
//  This function is called, when either tree control or the drives
// get the focus.
//
void CBrowser::_OnFocusChange(UINT itb)
{
    //
    //  If the view is loosing the focus (within the explorer),
    // we should let it know. We should update _itbLastFocus before
    // calling UIActivate, because it will call our InsertMenu back.
    //
    if (m_itbLastFocus == itb)
        return;

    UINT itbPrevFocus = m_itbLastFocus;
    m_itbLastFocus = itb;

    if (itbPrevFocus == ITB_OEVIEW)
    {
        if (m_pView)
            m_pView->UIActivate(SVUIA_ACTIVATE_NOFOCUS);
    }
    else if (itbPrevFocus != ITB_NONE)
    {
        UnkUIActivateIO(m_rgTBar[itbPrevFocus].ptbar, FALSE, NULL);
    }

    UpdateToolbar();
}


UINT CBrowser::FindTBar(IUnknown* punkSrc)
{
    int i;    
    
    Assert(punkSrc);

    // Quick check without QI
    for (i=0; i<ITB_MAX ;i++ ) 
        {
        if (punkSrc == m_rgTBar[i].ptbar)
            return i;
        }

    // If failed, do the real COM object identity check. 
    for (i=0; i<ITB_MAX ;i++ ) 
        {
        if (m_rgTBar[i].ptbar) 
            {
            if (_IsSameObject(m_rgTBar[i].ptbar, punkSrc)==S_OK) 
                {
                return i;
                }
            }
        }

    return ITB_NONE;
}

void CBrowser::ReleaseToolbarItem(int itb, BOOL fClose)
{
    IDockingWindow *ptbTmp;

    // grab it and NULL it out to eliminate race condition.
    // (actually, there's still a v. small window btwn the 2 statements).
    //
    // e.g. if you close a WebBar and then quickly shutdown windows,
    // the close destroys the window etc. but then the shutdown code
    // does _SaveToolbars which tries to do ->Save on that destroyed guy.
    ptbTmp = m_rgTBar[itb].ptbar;
    m_rgTBar[itb].ptbar = NULL;

    if (fClose)
        ptbTmp->CloseDW(0);
    UnkSetSite(ptbTmp, NULL);
    ptbTmp->Release();

    SafeRelease(m_rgTBar[itb].pOleCmdTarget);
    m_rgTBar[itb].pOleCmdTarget = NULL;
}

void CBrowser::ResizeNextBorder(UINT itb)
{
    // Find the next toolbar (even non-visible one)
    RECT rc;
    IDockingWindow* ptbarNext = NULL;

    for (int i=itb; i<ITB_MAX; i++) 
        {
        if (m_rgTBar[i].ptbar) 
            {
            ptbarNext = m_rgTBar[i].ptbar;
            break;
            }
        }

    if (ptbarNext) 
        {
        GetBorderDW(ptbarNext, &rc);
        ptbarNext->ResizeBorderDW(&rc, (IUnknown*)(IAthenaBrowser*)this, TRUE);
        } 
    else 
        {
        // resize the inner shell view
        GetViewRect(&rc);
        if (m_hwndInner)
            {
            SetWindowPos(m_hwndInner, 
                         NULL,
                         rc.left, 
                         rc.top, 
                         rc.right - rc.left, 
                         rc.bottom - rc.top,
                         SWP_NOZORDER | SWP_NOACTIVATE);            
            }
        else
            {
            InvalidateRect(m_hwnd, &rc, FALSE);
            }
        }
}

void CBrowser::GetClientArea(LPRECT prc)
{
    static const int s_rgCtlIds[] = { 1, 0, 1, IDC_STATUS_BAR, 0, 0};
    Assert(m_hwnd);
    GetEffectiveClientRect(m_hwnd, prc, (LPINT)s_rgCtlIds);
}

HRESULT CBrowser::GetViewRect(LPRECT prc)
{
    Assert(m_hwnd);
    GetClientArea(prc);

    //
    // Extract the border taken by all "frame" toolbars
    //
    for (int i=0; i<ITB_MAX; i++) 
        {
        prc->left += m_rgTBar[i].rcBorderTool.left;
        prc->top += m_rgTBar[i].rcBorderTool.top;
        prc->right -= m_rgTBar[i].rcBorderTool.right;
        prc->bottom -= m_rgTBar[i].rcBorderTool.bottom;
        }

    return (S_OK);
}

HRESULT CBrowser::GetLayout(PLAYOUT playout)
{
    Assert(playout);
    if (playout->cbSize != sizeof(LAYOUT))
        return(E_FAIL);

    Assert(m_rLayout.cbSize == sizeof(LAYOUT));
    CopyMemory(playout, &m_rLayout, sizeof(LAYOUT));

    return (S_OK);
}

HRESULT CBrowser::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                              OLECMDTEXT *pCmdText)
{
    ULONG               cServer;
    HRESULT             hr = S_OK;

    // ATTENZIONE!
    // the view gets it first because it might want to handle a command that the treeview normally
    // handles. this is really only necessary for acct views where folders are displayed in the right
    // pane, and folder-related commands should work on the selected folder and not the current 
    // treeview selection

    // View always get's it
    if (m_pViewCT)
    {
        m_pViewCT->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
    }

    // TreeView always get's it
    if (m_pTreeView)
    {
        m_pTreeView->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
    }

    // Contact's get's it
    if (m_pNavPane)
    {
        m_pNavPane->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
    }

    MenuUtil_NewMessageIDsQueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText, (m_ftSel != FOLDER_NEWS));

    // Loop through the list looking for commands the view didn't handle
    for (ULONG i = 0; i < cCmds; i++)
    {
        if (prgCmds[i].cmdf == 0)
        {
            // Handle the Send and Receive popup menu
            if (prgCmds[i].cmdID >= ID_ACCOUNT_FIRST && prgCmds[i].cmdID<= ID_ACCOUNT_LAST)
            {
                prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                continue;
            }

            // Envelope stuff
            if (prgCmds[i].cmdID >= ID_ENVELOPE_HOST_FIRST && prgCmds[i].cmdID <= ID_ENVELOPE_HOST_LAST)
            {
                prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                continue;
            }

            if (prgCmds[i].cmdID >= ID_NEW_ACCT_FIRST && prgCmds[i].cmdID <= ID_NEW_ACCT_LAST)
            {
                prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                continue;
            }

            // Regular commands
            switch (prgCmds[i].cmdID)
            {
                case ID_WORK_OFFLINE:
                {
                    // Always enabled and supported
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    if (g_pConMan->IsGlobalOffline())
                        prgCmds[i].cmdf |= OLECMDF_LATCHED;
                    break;
                }
                        
                case ID_SEND_RECEIVE:
                    if (g_dwAthenaMode & MODE_NEWSONLY)
                    {
                        //We want to leave it enabled;
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        break;
                    }
                    //Fall through. In News Only mode we want to do Send All even for Send & Receive All
                case ID_POPUP_ENVELOPE_HOST:
                case ID_RECEIVE_ALL:
                {
                    // At least one SMTP server is configured
                    if (SUCCEEDED(g_pAcctMan->GetAccountCount(ACCT_MAIL, &cServer)))
                    {
                        if (cServer)
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        else
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }

                case ID_SEND_ALL:                
                {
                    DWORD cMail = 0, cNews = 0;

                    // At least one SMTP server is configured
                    if (SUCCEEDED(g_pAcctMan->GetAccountCount(ACCT_MAIL, &cMail)) && 
                        SUCCEEDED(g_pAcctMan->GetAccountCount(ACCT_NEWS, &cNews)))
                    {
                        if (cMail || cNews)
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        else
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }

                case ID_IMAP_FOLDERS:
                {
                    // At least one news server is configured
                    if (SUCCEEDED(g_pAcctMan->GetAccountCount(ACCT_MAIL, &cServer)))
                    {
                        if (cServer)
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        else
                            prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }

                case ID_FOLDER_LIST:
                {
                    // Always enabled
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;

                    // Is it checked?
                    if (m_rLayout.fFolderList)
                        prgCmds[i].cmdf |= OLECMDF_LATCHED;

                    break;
                }

                case ID_CONTACTS_LIST:
                {
                    // enabled only when not in outnews mode
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    
                    if ((g_dwAthenaMode & MODE_OUTLOOKNEWS) != MODE_OUTLOOKNEWS)
                    {
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                    }

                    // Is it checked?
                    if (m_rLayout.fContacts)
                        prgCmds[i].cmdf |= OLECMDF_LATCHED;

                    break;
                }

                case ID_EXIT_LOGOFF:
                case ID_LOGOFF_IDENTITY:
                {
                    if (MU_CountUsers() > 1)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_DELETE_ACCEL:
                case ID_DELETE_NO_TRASH_ACCEL:
                {
                    IOleCommandTarget *pTarget = NULL;    
                    OLECMD cmd = { 0 };

                    // Check to see if it's the treeview
                    if (S_OK == m_pTreeView->HasFocusIO())
                    {
                        pTarget = m_pTreeView;
                    }

                    // Check to see if it's anything else on the Info Column
                    else if (m_pNavPane->IsContactsFocus())
                    {
                        pTarget = m_pNavPane;
                        cmd.cmdID = ID_DELETE_CONTACT;
                    }

                    // Otherwise, it must be the view
                    else
                    {
                        pTarget = m_pViewCT;
                        if (prgCmds[i].cmdID == ID_DELETE_NO_TRASH_ACCEL)
                            cmd.cmdID = ID_DELETE_NO_TRASH;
                        else
                            cmd.cmdID = ID_DELETE;
                    }

                    // Hit the target with the right command
                    if (pTarget)
                    {
                        pTarget->QueryStatus(NULL, 1, &cmd, NULL);
                        prgCmds[i].cmdf = cmd.cmdf;
                    }
                    else
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    break;
                }

                case ID_UP_ONE_LEVEL:
                    if (m_idSelected != FOLDERID_ROOT)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_SHOW_TOOLBAR:
                case ID_SHOW_FILTERBAR:
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;
            
                case ID_SWITCH_IDENTITY:
                case ID_IDENTITIES:
                case ID_MANAGE_IDENTITIES:
                case ID_NEW_IDENTITY:
                    if (((g_dwAthenaMode & MODE_OUTLOOKNEWS) == MODE_OUTLOOKNEWS) && (MU_CountUsers() <= 1))
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    else
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    }
                    break;

                case ID_MESSAGE_RULES_MAIL:
                case ID_POPUP_NEW_ACCT:
                    if (g_dwAthenaMode & MODE_OUTLOOKNEWS)
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    else
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    }
                    break;

                case ID_MESSAGE_RULES_JUNK:
                    if (g_dwAthenaMode & MODE_OUTLOOKNEWS)
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    }
                    else if (g_dwAthenaMode & MODE_JUNKMAIL)
                    {
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    }
                    break;

                // always enabled

                // File Menu
                case ID_POPUP_NEW:
                case ID_POPUP_FOLDER:
                case ID_POPUP_IMPORT:
                case ID_POPUP_EXPORT:
                case ID_POPUP_USERS:
                case ID_IMPORT_ADDRESS_BOOK:
                case ID_IMPORT_WAB:
                case ID_IMPORT_MESSAGES:
                case ID_IMPORT_MAIL_ACCOUNTS:
                case ID_IMPORT_NEWS_ACCOUNTS:
                case ID_IMPORT_RULES:
                case ID_EXPORT_ADDRESS_BOOK:
                case ID_EXPORT_MESSAGES:
                case ID_EXPORT_RULES:
                case ID_EXIT:

                // Edit Menu
                case ID_POPUP_FIND:
                case ID_FIND_MESSAGE:
                case ID_FIND_PEOPLE:

                // View Menu
                case ID_POPUP_TOOLBAR:
                case ID_POPUP_NEXT:
                case ID_LAYOUT:
                case ID_CUSTOMIZE:

                // Go Menu
                case ID_GO_INBOX:
                case ID_GO_NEWS:
                case ID_GO_FOLDER:
                case ID_GO_NETMEETING:
                case ID_GO_OUTBOX:
                case ID_GO_SENT_ITEMS:
                case ID_GO_DRAFTS:

                // Message Menu

                // Tools
                case ID_POPUP_SEND_AND_RECEIVE:
                case ID_SYNCHRONIZE:
                case ID_ADDRESS_BOOK:
                case ID_POPUP_RULES:
                //case ID_MESSAGE_RULES_MAIL:
                case ID_MESSAGE_RULES_NEWS:
                //case ID_MESSAGE_RULES_JUNK:
                case ID_MESSAGE_RULES_SENDERS:
                case ID_OPTIONS:
                case ID_ACCOUNTS:

                // Help
                case ID_HELP_CONTENTS:
                case ID_README:
                case ID_POPUP_MSWEB:
                case ID_MSWEB_FREE_STUFF:
                case ID_MSWEB_PRODUCT_NEWS:
                case ID_MSWEB_FAQ:
                case ID_MSWEB_SUPPORT:
                case ID_MSWEB_FEEDBACK:
                case ID_MSWEB_BEST:
                case ID_MSWEB_SEARCH:
                case ID_MSWEB_HOME:
                case ID_MSWEB_HOTMAIL:
                case ID_ABOUT:
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;
            }
        }
    }

    return S_OK;
}


HRESULT CBrowser::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                       VARIANTARG *pvaIn, VARIANTARG *pvaOut) 
{
    AssertSz(FALSE, "NYI");
    return (E_NOTIMPL);
}

////////////////////////////////////////////////////////////////////////
//
//  ITreeViewNotify
//
////////////////////////////////////////////////////////////////////////

void CBrowser::OnSelChange(FOLDERID idFolder)
{
    HRESULT        hr = S_OK;
    IViewWindow   *pNewView = NULL;
    BOOL           fViewFocus = FALSE;

    // don't refresh if the pidls match
    if (m_pView)
        {
        if (idFolder == m_idSelected)
            return;
        }

    // Get Focus
    HWND hwndFocus = GetFocus();
    fViewFocus = (IsWindow(m_hwndInner) && IsChild(m_hwndInner, hwndFocus));

    // hold on to the current pidl
    m_idSelected = idFolder;

    SetFolderType(idFolder);

    hr = CreateFolderViewObject(m_idSelected, m_hwnd, IID_IViewWindow, (LPVOID *)&pNewView);
    if (SUCCEEDED(hr))
    {
        IViewWindow *pOldView;

        if (m_pView)
            hr = m_pView->SaveViewState();

        if (SUCCEEDED(hr))
        {
            RECT rc;
            HWND hwnd;

            // Release the old command target
            if (m_pViewCT)
            {
                m_pViewCT->Release();
                m_pViewCT = NULL;
            }

            pOldView = m_pView;
            m_pView = pNewView;

            GetViewRect(&rc);
            hr = pNewView->CreateViewWindow(pOldView, (IAthenaBrowser*)this, &rc, &hwnd);
            if (SUCCEEDED(hr))
            {
                if (pOldView)
                    {
                    pOldView->UIActivate(SVUIA_DEACTIVATE);
                    pOldView->DestroyViewWindow();
                    pOldView->Release();                        
                    }

                m_pView->AddRef();

                // Get the command target interface for the new view.  If it fails, 
                // we can proceed, we just can't send commands.
                if (FAILED(m_pView->QueryInterface(IID_IOleCommandTarget, (LPVOID *) &m_pViewCT)))
                {
                    // Make sure that m_pViewCT is NULL
                    m_pViewCT = NULL;
                }

                m_hwndInner = hwnd;
                m_pView->UIActivate(SVUIA_ACTIVATE_FOCUS);
                if (m_itbLastFocus == ITB_NONE || m_itbLastFocus == ITB_OEVIEW || fViewFocus)
                    {
                    SetFocus(m_hwndInner);
                    m_itbLastFocus = ITB_OEVIEW;
                    }
                UpdateToolbar();
                
                if (m_pCoolbar)
                    m_pCoolbar->UpdateViewState();
            }
            else
            {
                // Bug #20855 - If we failed to browse, try to navigate to the root
                //              instead.  If we failed to browse to the root, then 
                //              we should just leave the view empty.
                m_pView = pOldView;
                AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrFailedNavigate),
                              0, MB_OK | MB_ICONSTOP);
                BrowseObject(FOLDERID_ROOT, NULL);
            }

/*
            if (m_ftSel != FOLDER_HTTPMAIL)
            {
                if (m_pAdBar)
                    ShowToolbar((IDockingWindow*)m_pAdBar, FALSE);

                if (m_pBodyBar)
                    ShowToolbar((IUnknown *) (IDockingWindow *) m_pBodyBar, m_rLayout.fInfoPane);
            }
            else
            {
                if (m_pBodyBar && m_rLayout.fInfoPane)
                    ShowToolbar((IUnknown *) (IDockingWindow *)m_pBodyBar, FALSE);

                if (m_pAdBar && m_pAdBar->fValidUrl())
                {
                    ShowToolbar((IDockingWindow*)m_pAdBar, TRUE);
                }
            }
*/
        }
        SafeRelease(pNewView);
    }

}

void CBrowser::OnRename(FOLDERID idFolder)
    {
    m_idSelected = idFolder;
    SetFolderType(idFolder);
    }

void CBrowser::OnDoubleClick(FOLDERID idFolder)
    {
    return;
    }

HRESULT CBrowser::OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, 
                                     CConnectionManager *pConMan)
{
    PostMessage(m_hwnd, CM_UPDATETOOLBAR, 0, 0L);
    
    if (CONNNOTIFY_WORKOFFLINE == nCode)
    {
        if (NULL != pvData)
        {
            if (m_pStatus)
                m_pStatus->SetConnectedStatus(CONN_STATUS_WORKOFFLINE);
        }
        else 
        {
            if (m_pStatus)
                m_pStatus->SetConnectedStatus(CONN_STATUS_CONNECTED);
        }
    }
    else 
    if ((CONNNOTIFY_USER_CANCELLED == nCode) || (CONNNOTIFY_CONNECTED == nCode))
    {
        PostMessage(m_hwnd, WM_COMMAND, MAKEWPARAM(ID_RESYNCHRONIZE, 0), 0);
    }
    
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////
//
//  Message Handling
//
////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK CBrowser::BrowserWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT      lRet;
    CBrowser    *pThis;
    LRESULT     lres;
    MSG         Menumsg;

    if (msg == WM_NCCREATE)
        {
        pThis = (CBrowser*)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);            
        }
    else
        {
        pThis = (CBrowser*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
        if (msg == WM_NCDESTROY)
            {
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)0);
            pThis->Release();
            
            // If this shutdown is due to an identity switch...
            if (s_fQuickShutdown)
            {
                if (NULL != g_pInstance)
                {
                    // ... break out of the message loop in COutlookExpress::Start
                    g_pInstance->SetSwitchingUsers(TRUE);
                }
                
                s_fQuickShutdown = FALSE;
            }

            return 0;
            }
        }

    Menumsg.hwnd    = hwnd;
    Menumsg.message = msg;
    Menumsg.wParam  = wParam;
    Menumsg.lParam  = lParam;

    if (pThis && (pThis->TranslateMenuMessage(&Menumsg, &lres) == S_OK))
        return lres;
    
    wParam = Menumsg.wParam;
    lParam = Menumsg.lParam;

    if (pThis)
        return pThis->WndProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProc(hwnd, msg, wParam, lParam);
}

LRESULT CBrowser::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int         i;
    HWND        hwndActive;

    switch (msg)
        {
        HANDLE_MSG(hwnd, WM_CREATE,         OnCreate);
        HANDLE_MSG(hwnd, WM_SIZE,           OnSize);
        HANDLE_MSG(hwnd, WM_INITMENUPOPUP,  OnInitMenuPopup);
        HANDLE_MSG(hwnd, WM_COMMAND,        OnCommand);

        
        case WM_ENABLE:
            if (!m_fInternal)
            {
                Assert (wParam || (m_hlDisabled.cHwnd == NULL && m_hlDisabled.rgHwnd == NULL));
                EnableThreadWindows(&m_hlDisabled, (NULL != wParam), ETW_OE_WINDOWS_ONLY, hwnd);
                g_hwndActiveModal = wParam ? NULL : hwnd;
            }
            break;

        case WM_OE_ENABLETHREADWINDOW:
            m_fInternal = 1;
            EnableWindow(hwnd, (BOOL)wParam);
            m_fInternal = 0;
            break;

        case WM_OE_ACTIVATETHREADWINDOW:
            hwndActive = GetLastActivePopup(hwnd);
            if (hwndActive && IsWindowEnabled(hwndActive) && IsWindowVisible(hwndActive))
                ActivatePopupWindow(hwndActive);
            break;

        case WM_OESETFOCUS:
            if (IsWindow((HWND) wParam) && IsWindowVisible((HWND) wParam))
                SetFocus((HWND) wParam);
            break;

        case CBM_POSTCREATE:
            DOUTL(2, "CBM_POSTCREATE: GetTickCount() = %ld", GetTickCount());

            UpdateWindow(m_hwnd);
            UpdateStatusBar();
            m_fPainted = TRUE;

            if (m_pTreeView)
            {
                m_pTreeView->Refresh();

                if (!g_pConMan->IsGlobalOffline())
                    g_pConMan->DoOfflineTransactions();

                // Set the focus to the view
                m_itbLastFocus = ITB_OEVIEW;

                m_pTreeView->SetSelection(m_idSelected, TVSS_INSERTIFNOTFOUND);
            }

            if (g_pConMan)
                g_pConMan->OnActivate(TRUE);

            ProcessIncompleteAccts(m_hwnd);

            Assert(g_pSpooler);

            if (g_pSpooler)
                g_pSpooler->Advise(m_hwnd, TRUE);


            // Tell the spooler we're done init'ing
            if (g_pSpooler)
            {
                //safe fix for Bug#8149
                g_pSpooler->OnStartupFinished();
            }

            if (g_pSpooler)
            {
                if (!!DwGetOption(OPT_POLLFORMSGS_ATSTARTUP))
                {
                    DWORD   dwFlags;

                    dwFlags = (!(g_dwAthenaMode & MODE_NEWSONLY)) ? DELIVER_NO_NEWSPOLL : 0;

                    g_pSpooler->StartDelivery(m_hwnd, NULL, FOLDERID_INVALID,
                        
                        dwFlags | DELIVER_SEND | DELIVER_MAIL_RECV | DELIVER_POLL | 
                        DELIVER_DIAL_ALWAYS | DELIVER_BACKGROUND | 
                        DELIVER_OFFLINE_FLAGS | DELIVER_SERVER_TYPE_ALL);
                }
            }

            return 0;

        case CM_UPDATETOOLBAR:
            UpdateToolbar();
            return 0;

        case WM_UPDATELAYOUT:
            {
            if (m_itbLastFocus == ITB_TREE)
                CycleFocus(FALSE);

            // Update our view to reflect these new options
            if (m_pFolderBar)
                m_pFolderBar->Update(FALSE, TRUE);

            if (m_rgTBar[ITB_FOLDERBAR].fShow != m_rLayout.fFolderBar)
                {
                m_rgTBar[ITB_FOLDERBAR].fShow = !m_rgTBar[ITB_FOLDERBAR].fShow;
                m_rgTBar[ITB_FOLDERBAR].ptbar->ShowDW(m_rgTBar[ITB_FOLDERBAR].fShow);
                }

            }
            return 0;

        case WM_PAINT:
            DOUTL(2, "WM_PAINT: GetTickCount() = %ld", GetTickCount());
            // if we don't have a shell view, paint a "clientedge window" instead
            if (!m_pView)
                {
                HDC         hdc;
                PAINTSTRUCT ps;
                RECT        rc;
                HBRUSH      hBrush;

                GetViewRect(&rc);
                hdc = BeginPaint(hwnd, &ps);
                DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT|BF_ADJUST);
                hBrush = SelectBrush(hdc, GetSysColorBrush(COLOR_WINDOW));
                PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATCOPY);
                SelectBrush(hdc, hBrush);
                EndPaint(hwnd, &ps);
                return 0;
                }
            break;

        case WM_DISPLAYCHANGE:
            {
            WINDOWPLACEMENT wp;
            wp.length = sizeof(wp);
            GetWindowPlacement(hwnd, &wp);
            SetWindowPlacement(hwnd, &wp);
            }
            if (m_hwndInner)
                return SendMessage(m_hwndInner, msg, wParam, lParam);
            return 0;

        case WM_FONTCHANGE:
            DeinitMultiLanguage();
        // fail thru
        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            // tell the toolbars Minus one coz we inform the InfoColumn seperately
            for (i=0; i<ITB_MAX - 1; i++) 
                {
                HWND hwndToolbar;
                if (m_rgTBar[i].ptbar && SUCCEEDED(m_rgTBar[i].ptbar->GetWindow(&hwndToolbar)))
                    SendMessage(hwndToolbar, msg, wParam, lParam);
                }            

            // Someone changed the default mail client.
#if 0
            // The mapistub gets quite upset if you unload it while it has an active mapi
            // call running
            if (g_hlibMAPI && lParam && !lstrcmpi((LPSTR) lParam, "Software\\Clients\\Mail"))
            {
                FreeLibrary(g_hlibMAPI);
                g_hlibMAPI = 0;
            }
#endif

            if (m_hwndInner)
                return SendMessage(m_hwndInner, msg, wParam, lParam);
            return 0;

        case WM_MENUSELECT:
            if (LOWORD(wParam) >= ID_STATIONERY_RECENT_0 && LOWORD(wParam) <= ID_STATIONERY_RECENT_9)
                {
                m_pStatus->ShowSimpleText(MAKEINTRESOURCE(idsRSListGeneralHelp));
                return 0;
                }

            if (m_hwndInner)
                return SendMessage(m_hwndInner, msg, wParam, lParam);
            return 0;

        case WM_NOTIFY:
            if (IDC_STATUS_BAR == wParam && lParam)
                {
                m_pStatus->OnNotify((NMHDR *) lParam);
                }

            if (m_hwndInner)
                return SendMessage(m_hwndInner, msg, wParam, lParam);
            return 0;

        case WM_DRAWITEM:
        case WM_MEASUREITEM:
        case WM_EXITMENULOOP:
        case WM_ENTERMENULOOP:
        case WM_ENTERSIZEMOVE:
        case WM_EXITSIZEMOVE:
        case WM_TIMECHANGE:
            if (m_hwndInner)
                return SendMessage(m_hwndInner, msg, wParam, lParam);
            return 0;

        case WM_SETFOCUS:
            break;

        case WM_INITMENU:
            CancelGlobalDropDown();
            break;

        case WM_ACTIVATEAPP:
            if (wParam && g_hwndActiveModal && g_hwndActiveModal != hwnd && 
                !IsWindowEnabled(hwnd))
            {
                // $MODAL
                // if we are getting activated, and are disabled then
                // bring our 'active' window to the top
                Assert (IsWindow(g_hwndActiveModal));
                PostMessage(g_hwndActiveModal, WM_OE_ACTIVATETHREADWINDOW, 0, 0);
            }

            FrameActivatePopups(NULL != wParam);
            break;

        case WM_SYSCOMMAND:
            // if we're minimizing, get the control with focus, as when we get the 
            // next WM_ACTIVATE we will already be minimized
            if (wParam == SC_MINIMIZE)
                m_hwndLastFocus = GetFocus();
            break;

        case WM_ACTIVATE:
            if (LOWORD(wParam) == WA_INACTIVE)
            {
                if (!HIWORD(wParam))
                {
                    // save the control with the focus don't do this is we're
                    // minimized, otherwise GetFocus()==m_hwnd
                    m_hwndLastFocus = GetFocus();
                }
                if (g_pConMan)
                    g_pConMan->OnActivate(FALSE);
                FrameActivatePopups(FALSE);
            }
            else
            {
                HWND hwndFocus;
                if (m_hwndLastFocus && IsWindow(m_hwndLastFocus) && IsChild(hwnd, m_hwndLastFocus))
                    SetFocus(m_hwndLastFocus);
                else if (m_rgTBar[ITB_TREE].fShow && SUCCEEDED(m_rgTBar[ITB_TREE].ptbar->GetWindow(&hwndFocus)))
                    SetFocus(hwndFocus);
                else if (m_hwndInner)
                    SetFocus(m_hwndInner);
                
                if (g_pConMan && m_fPainted)
                    g_pConMan->OnActivate(TRUE);
                
                FrameActivatePopups(FALSE);
            }
            
            if (m_pView)
            {
                // If the inner window is a message view, we need to hit it with
                // a OnFrameWindowAcivate() so the preview pane get's updated 
                // correctly.
                IMessageWindow *pWindow;

                if (SUCCEEDED(m_pView->QueryInterface(IID_IMessageWindow, (LPVOID *) &pWindow)))
                {
                    pWindow->OnFrameWindowActivate(LOWORD(wParam) != WA_INACTIVE);
                    pWindow->Release();
                }
            }

            return 0;
        
        case WM_ENDSESSION:
            if (wParam)
                {
                DOUTL(2, "CBrowser::WM_ENDSESSION");
                // g_fCheckOutboxOnShutdown = FALSE;
                SendMessage(hwnd, WM_CLOSE, 0, 0L);
                }
            return 0;

        case PUI_OFFICE_COMMAND:
            if(wParam == PLUGUI_CMD_QUERY)
            {
                PLUGUI_QUERY pq;

                pq.uQueryVal = 0; // initialize
                pq.PlugUIInfo.uMajorVersion = OFFICE_VERSION_9; // Value filled in by Apps
                pq.PlugUIInfo.uOleServer = FALSE;              // Value filled in by Apps

                return (pq.uQueryVal); // The state of the App
            }
            if(wParam != PLUGUI_CMD_SHUTDOWN)
                return(0);

            // for PLUGUI_CMD_SHUTDOWN fall to close application
            CloseFinderTreads();
            CloseThreadWindows(hwnd, GetCurrentThreadId());

        case WM_CLOSE:
            {
            WINDOWPLACEMENT wp;

            // WriteUnreadCount();
            AcctUtil_FreeSendReceieveMenu(m_hMenu, m_cAcctMenu);
            FreeNewAcctMenu(m_hMenu);

            // Close any active RAS connections we brought up
            if (g_pConMan)
                {
                // Release our notification for connection changes
                g_pConMan->Unadvise(this);
                }

            if (g_pSpooler)
                g_pSpooler->Advise(m_hwnd, FALSE);

            if (m_pView)
                {
                FOLDERSETTINGS fs;
                if (m_pViewCT)
                {
                    m_pViewCT->Release();
                    m_pViewCT = NULL;
                }
                m_pView->SaveViewState();
                m_pView->UIActivate(SVUIA_DEACTIVATE);
                m_hwndInner = NULL;
                m_pView->DestroyViewWindow();
                m_pView->Release();
                m_pView = NULL;
                }

           if (DwGetOption(OPT_PURGEWASTE))
               EmptySpecialFolder(hwnd, FOLDER_DELETED);

            // clean up the toolbars
            for (i=0; i<ITB_MAX; i++) 
                {
                if (m_rgTBar[i].ptbar)
                    ReleaseToolbarItem(i, TRUE);
                }

            // save browser settings
            wp.length = sizeof(wp);
            GetWindowPlacement(hwnd, &wp);
            SetOption(OPT_BROWSERPOS, (LPVOID)&wp, sizeof(wp), NULL, 0);

            if (m_idClearStatusTimer)
                KillTimer(m_hwnd, m_idClearStatusTimer);
            
            SaveLayoutSettings();

            //Let the DocObj know that the browser is dying
            if (m_pDocObj)
            {
                m_pDocObj->BrowserExiting();
            }

            // Unregister with Identity manager
            if (m_dwIdentCookie != 0)
            {
                MU_UnregisterIdentityNotifier(m_dwIdentCookie);
                m_dwIdentCookie = 0;
            }

            DestroyWindow(hwnd);
            }
            return 0;

        case WM_NEW_MAIL:
            Assert(0 == wParam);
            Assert(0 == lParam);

            // Add the tray icon
            if (g_pInstance)
                g_pInstance->UpdateTrayIcon(TRAYICONACTION_ADD);

            // Play a sound
            if (DwGetOption(OPT_NEWMAILSOUND) != 0)
            {
                if (!sndPlaySound((LPTSTR) s_szMailSndKey, SND_ASYNC | SND_NODEFAULT))
                    MessageBeep(MB_OK);
            }
            return 0;

        case MVM_NOTIFYICONEVENT:
            if (lParam == WM_LBUTTONDBLCLK)
                {
                if (IsIconic(m_hwnd))
                    ShowWindow(m_hwnd, SW_RESTORE);
                SetForegroundWindow(m_hwnd);
                }
            return 0;

        case MVM_SPOOLERDELIVERY:
            SpoolerDeliver(wParam, lParam);
            return 0;

        case WM_TIMER:
            if (wParam == TIMER_CLEAR_STATUS)
            {
                KillTimer(m_hwnd, m_idClearStatusTimer);
                m_idClearStatusTimer = 0;
                if (m_pStatus)
                    m_pStatus->SetSpoolerStatus(DELIVERY_NOTIFY_COMPLETE, 0);                    
            }
            return 0;

        case WM_DESTROY:
            {
#if 0
            // We need to free our menu resource
            HMENU hMenu = GetMenu(m_hwnd);
            //SetMenu(m_hwnd, NULL);
            DestroyMenu(hMenu);
#endif
            RemoveProp(hwnd, c_szOETopLevel);
            break;
            }

        }
    
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//
//  FUNCTION:   CBrowser::OnCreate
//
//  PURPOSE:    Creates the child windows necessary for the view and
//              initializes the data in those child windows.
//
//  PARAMETERS:
//      hwnd           - Handle of the view being created.
//      lpCreateStruct - Pointer to the creation params passed to 
//                       CreateWindow().
//
//  RETURN VALUE:
//      Returns TRUE if the initialization is successful.
//
BOOL CBrowser::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    // Spooler comes first
    g_fCheckOutboxOnShutdown = TRUE;

    m_hwnd = hwnd;

    // Set the title bar icon to the mailnews icon
    UINT idRes = (g_dwAthenaMode & MODE_NEWSONLY) ? idiNewsGroup : idiMailNews;

    m_hIcon = (HICON) LoadImage(g_hLocRes, MAKEINTRESOURCE(idRes), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), 0);
    SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
    m_hIconSm = (HICON) LoadImage(g_hLocRes, MAKEINTRESOURCE(idRes), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
    SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

    SetProp(hwnd, c_szOETopLevel, (HANDLE)TRUE);

    m_pStatus = new CStatusBar();
    if (!m_pStatus)
        goto error;

    m_pStatus->Initialize(m_hwnd, 0);
    m_pStatus->ShowStatus(m_rLayout.fStatusBar);

    // Init the menu bar
    m_hMenu = LoadMenu(g_hLocRes, MAKEINTRESOURCE(IDR_BROWSER_MENU));

    MenuUtil_ReplaceHelpMenu(m_hMenu);
    MenuUtil_ReplaceNewMsgMenus(m_hMenu);
    MenuUtil_ReplaceMessengerMenus(m_hMenu);

    // Register for connection changes
    if (g_pConMan)
        g_pConMan->Advise((IConnectionNotify *) this);

    // Create all our toolbar windows
    if (!_InitToolbars())
        goto error;
    
    // Initialize the folder bar
    SetFolderType(NULL);
    m_pFolderBar->Update(FALSE, TRUE);

    // Post this so we can do post creation init
    PostMessage(m_hwnd, CBM_POSTCREATE, 0, 0L);
    return TRUE;

error:
    return FALSE;
}


//
//  FUNCTION:   CBrowser::OnSize
//
//  PURPOSE:    Notification that the view window has been resized.  In
//              response we update the positions of our child windows and
//              controls.
//
//  PARAMETERS:
//      hwnd   - Handle of the view window being resized.
//      state  - Type of resizing requested.
//      cxClient - New width of the client area. 
//      cyClient - New height of the client area.
//
void CBrowser::OnSize(HWND hwnd, UINT state, int cxClient, int cyClient)
{
    if (state != SIZE_MINIMIZED)
        {
        if (m_pStatus)
            m_pStatus->OnSize(cxClient, cyClient);    
        ResizeNextBorder(0);
        }
}

HRESULT CBrowser::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    ACCTTYPE    type;
    RULEID      ridTag;

    Assert(m_pTreeView != NULL);
    if (S_OK == m_pTreeView->ForceSelectionChange())
    {
        PostMessage(hwnd, WM_COMMAND, MAKEWPARAM(id, codeNotify), (LPARAM)hwndCtl);
        return(S_OK);
    }

    // Check to see if the command is even enabled
    OLECMD cmd;
    cmd.cmdID = id;
    cmd.cmdf = 0;

    HRESULT hr = QueryStatus(&CMDSETID_OutlookExpress, 1, &cmd, NULL);
    if (FAILED(hr) || (0 == (cmd.cmdf & OLECMDF_ENABLED)))
        return (OLECMDERR_E_DISABLED);

    // Give the view first chance at any command so that it can override 
    // browser behavior.
    VARIANTARG va;

    va.vt = VT_I8;
    va.ullVal = (ULONGLONG)hwndCtl;

    // ATTENZIONE!
    // the view gets it first because it might want to handle a command that the treeview normally
    // handles. this is really only necessary for acct views where folders are displayed in the right
    // pane, and folder-related commands should work on the selected folder and not the current 
    // treeview selection

    // We should always allow the views to see the command list.
    if (m_pViewCT && SUCCEEDED(hr = m_pViewCT->Exec(&CMDSETID_OutlookExpress, id, OLECMDEXECOPT_DODEFAULT, &va, NULL)))
        return (S_OK);

    // Infocolumn always get's a chance
    if (m_pTreeView && SUCCEEDED(hr = m_pTreeView->Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL)))
        return (S_OK);

    // Infocolumn always get's a chance
    if (m_pNavPane && SUCCEEDED(hr = m_pNavPane->Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL)))
        return (S_OK);

    // $REVIEW - Why should we route commands to a toolbar?
    if (m_pCoolbar && (m_pCoolbar->OnCommand(hwnd, id, hwndCtl, codeNotify) == S_OK))
        return S_OK;    

    if (Envelope_WMCommand(hwnd, id, (WORD) codeNotify)== S_OK)
        return S_OK;

    // Handle the extra help menu commands
    if (id > ID_MSWEB_BASE && id < ID_MSWEB_LAST)
    {
        OnHelpGoto(m_hwnd, id);
        return S_OK;
    }

    // Handle the Receive From... popup menu
    if (id >= ID_ACCOUNT_FIRST && id <= ID_ACCOUNT_LAST)
    {
        Assert(g_pSpooler);
        CmdSendReceieveAccount(id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        return (S_OK);
    }

    if (id >= ID_NEW_ACCT_FIRST && id <= ID_NEW_ACCT_LAST)
    {
        HandleNewAcctMenu(m_hwnd, m_hMenu, id);
        return(S_OK);
    }

    // Handle all "create new note" IDs
    if (MenuUtil_HandleNewMessageIDs(id, m_hwnd, m_idSelected, m_ftSel != FOLDER_NEWS, FALSE, NULL))
        return S_OK;

    switch (id)
    {
        // File Menu
        case ID_EXPORT_ADDRESS_BOOK:
        case ID_IMPORT_ADDRESS_BOOK:
            MailUtil_OnImportExportAddressBook(m_hwnd, id == ID_IMPORT_ADDRESS_BOOK);
            break;

        case ID_IMPORT_WAB:
            ImportWAB(m_hwnd);
            break;

        case ID_IMPORT_MESSAGES:
            DoImport(m_hwnd);
            break;

        case ID_IMPORT_MAIL_ACCOUNTS:
        case ID_IMPORT_NEWS_ACCOUNTS:
            DoAcctImport(m_hwnd, id == ID_IMPORT_MAIL_ACCOUNTS);
            break;

        case ID_EXPORT_MESSAGES:
            DoExport(m_hwnd);
            break;

        case ID_IMPORT_RULES:
            RuleUtil_HrImportRules(m_hwnd);
            break;

        case ID_EXPORT_RULES:
            RuleUtil_HrExportRules(m_hwnd);
            break;

        case ID_NEW_IDENTITY:
            MU_NewIdentity(m_hwnd);
            break;

        case ID_SWITCH_IDENTITY:
            MU_Login(m_hwnd, TRUE, NULL);
            break;
        
        case ID_EXIT_LOGOFF:
        case ID_LOGOFF_IDENTITY:
            MU_Logoff(m_hwnd);
            break;

        case ID_MANAGE_IDENTITIES:
            MU_ManageIdentities(m_hwnd);
            break;

        case ID_EXIT:
            PostMessage(m_hwnd, WM_CLOSE, 0, 0L);
            break;

        case ID_WORK_OFFLINE:
            if (g_pConMan)
            {
                g_pConMan->SetGlobalOffline(!g_pConMan->IsGlobalOffline(), hwnd);
                UpdateToolbar();
            }
            break;


        // Edit Menu
        case ID_FIND_MESSAGE:
            DoFindMsg(m_idSelected, FOLDER_LOCAL);
            break;

        case ID_FIND_PEOPLE:
        {
            TCHAR szWABExePath[MAX_PATH];
            if(S_OK == HrLoadPathWABEXE(szWABExePath, sizeof(szWABExePath)))
                ShellExecute(NULL, "open", szWABExePath, "/find", "", SW_SHOWNORMAL);
            break;
        }

        // View Menu
        case ID_LAYOUT:
        {
            LayoutProp_Create(m_hwnd, this, &m_rLayout);
            break;
        }

        case ID_SHOW_TOOLBAR:
        {
            SetViewLayout(DISPID_MSGVIEW_TOOLBAR, LAYOUT_POS_NA, !m_rLayout.fToolbar, 0, 0);
            break;
        }

        case ID_SHOW_FILTERBAR:
        {
            SetViewLayout(DISPID_MSGVIEW_FILTERBAR, LAYOUT_POS_NA, !m_rLayout.fFilterBar, 0, 0);
            break;
        }

        // Go Menu
        case ID_UP_ONE_LEVEL:
            Assert(m_ftSel != FOLDER_ROOTNODE);
            m_pTreeView->SelectParent();
            break;

        case ID_GO_FOLDER:
        {
            FOLDERID idFolder;
            if (SUCCEEDED(SelectFolderDialog(m_hwnd, SFD_SELECTFOLDER, FOLDERID_ROOT, NOFLAGS, MAKEINTRESOURCE(idsGoToFolderTitle), MAKEINTRESOURCE(idsGoToFolderText), &idFolder)))
                BrowseObject(idFolder, 0);
            break;
        }

        case ID_GO_INBOX:
            // special case this for newsonly mode
            if (g_dwAthenaMode & MODE_NEWSONLY)
            {
                ShellUtil_RunClientRegCommand(m_hwnd, s_szMailClient);
            }
            else
                // fall through

        case ID_GO_OUTBOX:
        case ID_GO_SENT_ITEMS:
        case ID_GO_DRAFTS:
        {
            FOLDERID        idStore;
            FOLDERINFO      Folder;
            SPECIALFOLDER   sf;
    
            if (id == ID_GO_OUTBOX)
                sf = FOLDER_OUTBOX;
            else if (id == ID_GO_INBOX)
                sf = FOLDER_INBOX;
            else if (id == ID_GO_SENT_ITEMS)
                sf = FOLDER_SENT;
            else
                sf = FOLDER_DRAFT;

            if (FAILED(GetDefaultServerId(ACCT_MAIL, &idStore)))
                idStore = FOLDERID_LOCAL_STORE;

            if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(idStore, sf, &Folder)))
            {
                BrowseObject(Folder.idFolder, SBSP_DEFBROWSER | SBSP_DEFMODE | SBSP_ABSOLUTE);
                g_pStore->FreeRecord(&Folder);
            } 
            else
            {
                // We might not have this special folder for this account.  Try local.
                if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, sf, &Folder)))
                {
                    BrowseObject(Folder.idFolder, SBSP_DEFBROWSER | SBSP_DEFMODE | SBSP_ABSOLUTE);
                    g_pStore->FreeRecord(&Folder);
                }
            }

            break;
        }

        case ID_GO_NEWS:
        {
            if (g_dwAthenaMode & MODE_MAILONLY)
            {
                ShellUtil_RunClientRegCommand(m_hwnd, s_szNewsClient);
            }
            else
            {
                FOLDERID idServer;

                ProcessICW(m_hwnd, FOLDER_NEWS, TRUE);

                if (SUCCEEDED(GetDefaultServerId(ACCT_NEWS, &idServer)))
                {
                    BrowseObject(idServer, 0);
                }
            }

            break;
        }

        case ID_GO_NETMEETING:
            ShellUtil_RunClientRegCommand(m_hwnd, s_szCallClient);
            break;

        // Tools Menu
        case ID_SEND_RECEIVE:
            Assert(g_pSpooler);

            if (!(g_dwAthenaMode & MODE_NEWSONLY))
            {
                if (g_pSpooler)
                {
                    DWORD   dwFlags = 0;

                    dwFlags = (!(g_dwAthenaMode & MODE_NEWSONLY)) ? DELIVER_NO_NEWSPOLL : 0;

                    g_pSpooler->StartDelivery(m_hwnd, NULL, FOLDERID_INVALID,
                        dwFlags | DELIVER_SEND | DELIVER_MAIL_RECV | 
                        DELIVER_POLL | DELIVER_OFFLINE_FLAGS | DELIVER_SERVER_TYPE_ALL);
                }
                // $REVIEW -  Can someone explain why it's here??? - steveser
                // Tell currently selected folder to refresh itself
                // if (NULL != m_pViewCT)
                //     m_pViewCT->Exec(NULL, ID_REFRESH, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
                break;
            }
            //Fall through. In News only mode we want to do Send All even for Send & Receive All
        case ID_SEND_ALL:
            Assert(g_pSpooler);
            if (g_pSpooler)
                g_pSpooler->StartDelivery(m_hwnd, NULL, FOLDERID_INVALID,
                    DELIVER_SEND | DELIVER_NOSKIP | DELIVER_NEWS_TYPE | DELIVER_SMTP_TYPE | DELIVER_HTTP_TYPE);
            break;

        case ID_RECEIVE_ALL:
            Assert(g_pSpooler);
            if (g_pSpooler)
                g_pSpooler->StartDelivery(m_hwnd, NULL, FOLDERID_INVALID,
                    DELIVER_MAIL_RECV | DELIVER_POLL | DELIVER_OFFLINE_FLAGS | DELIVER_IMAP_TYPE | 
                    DELIVER_HTTP_TYPE);
            break;

        case ID_SYNCHRONIZE:
        {
            Assert(g_pSpooler);
            if (g_pSpooler)
                g_pSpooler->StartDelivery(m_hwnd, NULL, FOLDERID_INVALID, DELIVER_OFFLINE_SYNC | DELIVER_UPDATE_ALL);
            
            /*
            Bug# 60668
            // Tell currently selected folder to refresh itself
            if (NULL != m_pViewCT)
                m_pViewCT->Exec(NULL, ID_REFRESH, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
            */
            break;
        }

        case ID_ADDRESS_BOOK:
        {
            CWab *pWab = NULL;
            if (SUCCEEDED(HrCreateWabObject(&pWab)))
            {
                pWab->HrBrowse(m_hwnd);
                pWab->Release();
            }
            else
            {
                AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsGeneralWabError), 
                              NULL, MB_OK | MB_ICONEXCLAMATION);
            }
            break;
        }

        case ID_MESSAGE_RULES_MAIL:
        case ID_MESSAGE_RULES_NEWS:
        case ID_MESSAGE_RULES_JUNK:
        case ID_MESSAGE_RULES_SENDERS:
        {
            DWORD   dwFlags = 0;
            switch (id)
            {
                case ID_MESSAGE_RULES_MAIL:
                    dwFlags = MRDF_MAIL;
                    break;

                case ID_MESSAGE_RULES_NEWS:
                    dwFlags = MRDF_NEWS;
                    break;

                case ID_MESSAGE_RULES_JUNK:
                    dwFlags = MRDF_JUNK;
                    break;

                case ID_MESSAGE_RULES_SENDERS:
                    dwFlags = MRDF_SENDERS;
                    break;

                default:
                    Assert(FALSE);
                    dwFlags = MRDF_MAIL;
                    break;
            }
            DoMessageRulesDialog(m_hwnd, dwFlags);
            break;
        }
        
        case ID_OPTIONS:
            ShowOptions(hwnd, ATHENA_OPTIONS, 0, this);
            break;

        case ID_ACCOUNTS:
        {
            if (m_ftSel == FOLDER_NEWS)
                type = ACCT_NEWS;
            else if (m_ftSel == FOLDER_IMAP || m_ftSel == FOLDER_LOCAL)
                type = ACCT_MAIL;
            else
                type = ACCT_LAST;

            DoAccountListDialog(m_hwnd, type);
            break;
        }

        // HELP MENU COMMANDS
        case ID_HELP_CONTENTS:
            OEHtmlHelp(m_hwnd, c_szMailHelpFileHTML, HH_DISPLAY_TOPIC, (DWORD_PTR) (LPCSTR) c_szCtxHelpDefault);
            break;
            
        case ID_README:
            DoReadme(m_hwnd);
            break;
        
        case ID_ABOUT:
            DoAboutAthena(m_hwnd, m_ftSel == FOLDER_NEWS ? idiNews : idiMail);
            break;

        // Toolbar Buttons & Accelerators
        case ID_FOLDER_LIST:
            if (m_itbLastFocus == ITB_NAVPANE)
                CycleFocus(FALSE);

            SetViewLayout(DISPID_MSGVIEW_FOLDERLIST, LAYOUT_POS_NA, !m_rLayout.fFolderList, 0, 0);

            if (m_pFolderBar)
                m_pFolderBar->Update(FALSE, TRUE);
            break;

        case ID_CONTACTS_LIST:
            if (m_itbLastFocus == ITB_NAVPANE)
                CycleFocus(FALSE);

            SetViewLayout(DISPID_MSGVIEW_CONTACTS, LAYOUT_POS_NA, !m_rLayout.fContacts, 0, 0);
            break;

        // $REVIEW - Do we still need this?
        /*
        case idmAccelNextCtl:
        case idmAccelPrevCtl:
            CycleFocus(id == idmAccelPrevCtl);
            break;
        */

        case ID_DELETE_ACCEL:
        case ID_DELETE_NO_TRASH_ACCEL:
            return (CmdDeleteAccel(id, OLECMDEXECOPT_DODEFAULT, NULL, NULL));

        //Msglist handles this command. But if our view is frontpage or account view, this is not handled by them.
        //So we break here so we don't show NYI.
        case ID_RESYNCHRONIZE:
          break;

        default:
#ifdef DEBUG
            if (!hwndCtl || codeNotify == BN_CLICKED)
                nyi(MAKEINTRESOURCE(idsNYIGeneral));
#endif
            return E_NOTIMPL;
        }
    return S_OK;
}


#define MF_CHECKFLAGS(b)    (MF_BYCOMMAND|(b ? MF_CHECKED : MF_UNCHECKED))

void CBrowser::OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos, BOOL fSystemMenu)
{
    char            sz[CCHMAX_STRINGRES], szT[CCHMAX_STRINGRES];
    MENUITEMINFO    mii;
    UINT            uIDPopup;
    HMENU           hMenuLang;
    FOLDERINFO      info;
    HRESULT         hr;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;

    // make sure we recognize the popup as one of ours
    if (m_hMenu == NULL || !GetMenuItemInfo(m_hMenu, uPos, TRUE, &mii) || mii.hSubMenu != hmenuPopup)
    {
        HMENU   hMenuDrop = NULL;
        int     cItems = 0;
        
        if (GetMenuItemInfo(m_hMenu, ID_POPUP_LANGUAGE_DEFERRED, FALSE, &mii) && mii.hSubMenu == hmenuPopup)
        {
            // MessageView will take care of creating language menu
            // let's just fix menu ID
            mii.fMask = MIIM_ID;
            mii.wID = ID_POPUP_LANGUAGE;
            SetMenuItemInfo(m_hMenu, ID_POPUP_LANGUAGE_DEFERRED, FALSE, &mii); 
        }

        // Get the drop down menu
        hMenuDrop = GetSubMenu(m_hMenu, uPos);
        if (NULL == hMenuDrop)
        {
            goto exit;
        }
        
        // Get the number of items in the drop down menu
        cItems = GetMenuItemCount(hMenuDrop);
        if (-1 == cItems)
        {
            goto exit;
        }

        // Initialize the menu info
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_SUBMENU;

        // Spin throught the submenus finding the correct menu id
        for (cItems--; cItems >= 0; cItems--)
        {
            if (FALSE == GetMenuItemInfo(hMenuDrop, cItems, TRUE, &mii))
            {
                continue;
            }

            if (hmenuPopup == mii.hSubMenu)
            {
                break;
            }
        }

        // Did we find anything?
        if (cItems < 0)
        {
            goto exit;
        }
    }

    uIDPopup = mii.wID;

    switch (uIDPopup)
    {
        case ID_POPUP_FILE:
            hr = g_pStore->GetFolderInfo(m_idSelected, &info);
            if (SUCCEEDED(hr))
            {
                if (info.tyFolder == FOLDER_IMAP)
                {
                    AthLoadString(idsShowFolderCmd, sz, ARRAYSIZE(sz));
                    ModifyMenu(hmenuPopup, ID_SUBSCRIBE, MF_BYCOMMAND | MF_STRING, ID_SUBSCRIBE, sz);
                    AthLoadString(idsHideFolderCmd, sz, ARRAYSIZE(sz));
                    ModifyMenu(hmenuPopup, ID_UNSUBSCRIBE, MF_BYCOMMAND | MF_STRING, ID_UNSUBSCRIBE, sz);
                }
                else
                {
                    AthLoadString(idsSubscribeFolderCmd, sz, ARRAYSIZE(sz));
                    ModifyMenu(hmenuPopup, ID_SUBSCRIBE, MF_BYCOMMAND | MF_STRING, ID_SUBSCRIBE, sz);
                    AthLoadString(idsUnsubscribeFolderCmd, sz, ARRAYSIZE(sz));
                    ModifyMenu(hmenuPopup, ID_UNSUBSCRIBE, MF_BYCOMMAND | MF_STRING, ID_UNSUBSCRIBE, sz);
                }

                g_pStore->FreeRecord(&info);
            }
            MU_UpdateIdentityMenus(hmenuPopup);

            if (m_fNoModifyAccts)
            {
                DeleteMenu(hmenuPopup, ID_IMPORT_MAIL_ACCOUNTS, MF_BYCOMMAND);
                DeleteMenu(hmenuPopup, ID_IMPORT_NEWS_ACCOUNTS, MF_BYCOMMAND);
            }
            break;

        case ID_POPUP_TOOLS:
        {
            DWORD dwHeaders;

            // See if things were changed
            if (m_fRebuildAccountMenu)
            {
                AcctUtil_FreeSendReceieveMenu(hmenuPopup, m_cAcctMenu);
            }

            // Get the submenu for Send & Receieve
            if (m_fRebuildAccountMenu && GetMenuItemInfo(m_hMenu, ID_POPUP_SEND_AND_RECEIVE, FALSE, &mii))
            {             
                AcctUtil_CreateSendReceieveMenu(mii.hSubMenu, &m_cAcctMenu);
                m_fRebuildAccountMenu = FALSE;
            }

            if (!m_fInitNewAcctMenu)
            {
                InitNewAcctMenu(hmenuPopup);
                m_fInitNewAcctMenu = TRUE;
            }

            // Figure out if the user has the "Download 300 headers" turned on
            dwHeaders = DwGetOption(OPT_DOWNLOADCHUNKS);
            if (OPTION_OFF != dwHeaders)
            {
                // Load a new menu string from the resources
                AthLoadString(idsGetHeaderFmt, sz, ARRAYSIZE(sz));

                // Format it
                wsprintf(szT, sz, dwHeaders);

                // Splat it on the menu
                ModifyMenu(hmenuPopup, ID_GET_HEADERS, MF_BYCOMMAND | MF_STRING, ID_GET_HEADERS, szT);
            }
            else
            {
                // Load a new menu string from the resources
                AthLoadString(idsGetNewHeaders, sz, ARRAYSIZE(sz));

                // Splat it on the menu
                ModifyMenu(hmenuPopup, ID_GET_HEADERS, MF_BYCOMMAND | MF_STRING, ID_GET_HEADERS, sz);
            }

            if (m_fNoModifyAccts)
            {
                DeleteMenu(hmenuPopup, ID_ACCOUNTS, MF_BYCOMMAND);
                DeleteMenu(hmenuPopup, ID_POPUP_NEW_ACCT, MF_BYCOMMAND);
            }

            //Change Sync Folder to Sync Account or Sync NewsGroup depending on the folder selected
            MENUITEMINFO    mii = {0};
            FOLDERINFO      FolderInfo = {0};
            int             id;
            TCHAR           szMenuName[CCHMAX_STRINGRES] = {0};

            if (g_pStore && SUCCEEDED(g_pStore->GetFolderInfo(m_idSelected, &FolderInfo)))
            {
                if (ISFLAGSET(FolderInfo.dwFlags, FOLDER_SERVER))
                {
                    id  = idsSynchronizeNowBtnTT;
                }
                else if(FolderInfo.tyFolder == FOLDER_NEWS)
                {
                    id = idsDownloadNewsgroupTT;
                }
                else
                    id = idsSyncFolder;

                LoadString(g_hLocRes, id, szMenuName, ARRAYSIZE(szMenuName));

                mii.cbSize      = sizeof(MENUITEMINFO);
                mii.fMask       = MIIM_TYPE;
                mii.fType       = MFT_STRING;
                mii.dwTypeData  = szMenuName;

                SetMenuItemInfo(hmenuPopup, ID_SYNC_THIS_NOW, FALSE, &mii);

                g_pStore->FreeRecord(&FolderInfo);
            }
            
            if (0 == (g_dwAthenaMode & MODE_JUNKMAIL))
                DeleteMenu(hmenuPopup, ID_MESSAGE_RULES_JUNK, MF_BYCOMMAND);
            break;
        }

        case ID_POPUP_MESSAGE:
        {
            AddStationeryMenu(hmenuPopup, ID_POPUP_NEW_MSG, ID_STATIONERY_RECENT_0, ID_STATIONERY_MORE);

            if (!m_fEnvMenuInited && DwGetOption(OPT_SHOW_ENVELOPES))
            {
                Envelope_AddHostMenu(hmenuPopup, 2);
                m_fEnvMenuInited=TRUE;
            }
            break;
        }
    }

    // let the view handle it last so that it can override any browser init if necessary
    if (m_pView)
    {
        m_pView->OnPopupMenu(m_hMenu, hmenuPopup, uIDPopup);
        if(uIDPopup == ID_POPUP_LANGUAGE)           // It was destroyed
            hmenuPopup = m_hMenuLanguage;
    }

    // now enable/disable the items
    MenuUtil_EnablePopupMenu(hmenuPopup, this);
    
exit:
    return;
}

inline void CBrowser::_AppendIdentityName(LPCTSTR pszIdentityName, LPSTR pszName)
{
    /*
    if (((g_dwAthenaMode & MODE_OUTLOOKNEWS) != MODE_OUTLOOKNEWS) && pszIdentityName && *pszIdentityName)
    {
    */
    if (pszIdentityName && *pszIdentityName)
    {
        lstrcat(pszName, c_szSpaceDashSpace);
        lstrcat(pszName, pszIdentityName);
    }
    /*
    }
    */
}

void CBrowser::SetFolderType(FOLDERID idFolder)
{
    int             iIcon;
    LPSTR           pszName=NULL;
    LPCSTR          pszIdentityName=NULL;
    HICON           hIconOld, hIcon;
    FOLDERTYPE      ftNew;
    int             cch;
    DWORD           type, cb, dwLen;
    FOLDERINFO      Folder;
    FOLDERINFO      SvrFolderInfo = {0};
    IImnAccount     *pAccount = NULL;
    DWORD           dwShow = 0;
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];
    HRESULT         hr = S_OK;
	BOOL			fHideHotMail = FALSE;

    if (*m_szName == 0)
    {
        // TODO: it seems like the window title should a global setting not per user
        cb = sizeof(m_szName);
        if (ERROR_SUCCESS != AthUserGetValue(NULL, c_szWindowTitle, &type, (LPBYTE)m_szName, &cb) ||
            FIsEmpty(m_szName))
        {
            if ((g_dwAthenaMode & MODE_OUTLOOKNEWS) == MODE_OUTLOOKNEWS)
            {
                LoadString(g_hLocRes, idsMSOutlookNewsReader, m_szName, ARRAYSIZE(m_szName));
            }
            else
            {
                LoadString(g_hLocRes, idsAthena, m_szName, ARRAYSIZE(m_szName));
            }
        }

        Assert(*m_szName != 0);
    }
    
    pszIdentityName = MU_GetCurrentIdentityName();

    if (FOLDERID_ROOT != idFolder && SUCCEEDED(g_pStore->GetFolderInfo(idFolder, &Folder)))
    {
        iIcon = GetFolderIcon(&Folder);
        ftNew = Folder.tyFolder;
    
        dwLen = lstrlen(Folder.pszName) + lstrlen(m_szName) + lstrlen(c_szSpaceDashSpace) + 1;

        if (*pszIdentityName)
            dwLen += (lstrlen(pszIdentityName) + lstrlen(c_szSpaceDashSpace));

        //Its better to allocate a few extra bytes now than having to reallocate later depending on the outnews switch.
        //This memory gets freed before exiting the function
        if (MemAlloc((LPVOID *)&pszName, dwLen))
        {
            lstrcpy(pszName, Folder.pszName);
            lstrcat(pszName, c_szSpaceDashSpace);
            lstrcat(pszName, m_szName);
            
            _AppendIdentityName(pszIdentityName, pszName);

        }
        g_pStore->FreeRecord(&Folder);
    }
    else
    {
        iIcon = iMailNews;
        ftNew = FOLDER_ROOTNODE;
        if (*pszIdentityName)
        {
            dwLen = lstrlen(m_szName) + 1;
            
            if (*pszIdentityName)
                dwLen += lstrlen(pszIdentityName) + lstrlen(c_szSpaceDashSpace);

            if (MemAlloc((LPVOID *)&pszName, dwLen))
            {
                lstrcpy(pszName, m_szName);
                
                _AppendIdentityName(pszIdentityName, pszName);
            }
        }
        else
            pszName = PszDupA(m_szName);
    }

    SetWindowText(m_hwnd, pszName?pszName:m_szName);

    // Update the folder bar
    if (m_pFolderBar)
        m_pFolderBar->SetCurrentFolder(idFolder);
    
	// Update of Adv Bar
    if (m_pAdBar)  // Say that for Hotmail we have Ad bar always 
    {
        if (FOLDER_HTTPMAIL == ftNew)
        {
            //At startup too if the cached state is to show the URL, then just show the toolbar with whatever it is loaded with
            // Get the server for this folder
            IF_FAILEXIT(hr = GetFolderServer(idFolder, &SvrFolderInfo));

            // Get the account ID for the server
            *szAccountId = 0;
            IF_FAILEXIT(hr = GetFolderAccountId(&SvrFolderInfo, szAccountId));

            // Get the account interface
            IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAccountId, &pAccount));

			IF_FAILEXIT(hr = pAccount->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dwShow));
			if(dwShow)
			{
				if(!HideHotmail())
				{
			
					IF_FAILEXIT(hr = pAccount->GetPropDw(AP_HTTPMAIL_SHOW_ADBAR, &dwShow));
					ShowToolbar((IDockingWindow*)m_pAdBar, !!dwShow);
				}
				else
					fHideHotMail = TRUE;
			}
        }
        else
            ShowToolbar((IDockingWindow*)m_pAdBar, FALSE);
    }

    // update the coolbar and menus if we're changing folder type
    if (m_ftSel != ftNew)
    {
        m_ftSel = ftNew;
        _ResetMenu(ftNew, fHideHotMail);
        m_pCoolbar->SetFolderType(ftNew);
    }

    if (m_pBodyBar)
        ShowToolbar((IDockingWindow*)m_pBodyBar, 
        m_rLayout.fInfoPaneEnabled && m_rLayout.fInfoPane && (m_ftSel != FOLDER_HTTPMAIL));

exit:
    SafeMemFree(pszName);
    g_pStore->FreeRecord(&SvrFolderInfo);
    ReleaseObj(pAccount);
    
}

void CBrowser::_ResetMenu(FOLDERTYPE ftNew, BOOL fHideHotMail)
{
    HMENU           hMenu, hMenuT;
    MENUITEMINFO    mii;
    BOOL            fNews;
    DWORD           cServers;
    IImnEnumAccounts *pEnum;
    
    if (m_hMenuLanguage)
    {
        DeinitMultiLanguage();
        if (IsMenu(m_hMenuLanguage))
            DestroyMenu(m_hMenuLanguage);
        m_hMenuLanguage = NULL;
    }
    
    // load the new menu for the view
    SideAssert(hMenu = LoadMenu(g_hLocRes, MAKEINTRESOURCE(IDR_BROWSER_MENU)));

    MenuUtil_ReplaceNewMsgMenus(hMenu);
    MenuUtil_ReplaceHelpMenu(hMenu);
    MenuUtil_ReplaceMessengerMenus(hMenu);

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_SUBMENU;

    if ((g_dwHideMessenger == BL_HIDE) || (g_dwHideMessenger == BL_DISABLE))
    {
        // get the file popup
        SideAssert(GetMenuItemInfo(hMenu, ID_POPUP_FILE, FALSE, &mii));

        DeleteMenu(mii.hSubMenu, ID_SEND_INSTANT_MESSAGE, MF_BYCOMMAND);
    }

    if ((ftNew != FOLDER_NEWS) && (ftNew != FOLDER_IMAP))
    {
        // get the edit popup
        SideAssert(GetMenuItemInfo(hMenu, ID_POPUP_EDIT, FALSE, &mii));

        if (ftNew != FOLDER_NEWS)
            DeleteMenu(mii.hSubMenu, ID_CATCH_UP, MF_BYCOMMAND);

        if (ftNew != FOLDER_IMAP)
        {
            DeleteMenu(mii.hSubMenu, ID_UNDELETE, MF_BYCOMMAND);
            DeleteMenu(mii.hSubMenu, ID_PURGE_DELETED, MF_BYCOMMAND);
        }
    }

    if (ftNew != FOLDER_NEWS)
    {
        g_pAcctMan->GetAccountCount(ACCT_NEWS, &cServers);
        fNews = (cServers > 0);

        // get the message popup
        SideAssert(GetMenuItemInfo(hMenu, ID_POPUP_MESSAGE, FALSE, &mii));

        DeleteMenu(mii.hSubMenu, ID_UNSCRAMBLE, MF_BYCOMMAND);
        DeleteMenu(mii.hSubMenu, ID_CANCEL_MESSAGE, MF_BYCOMMAND);
        if (!fNews)
            DeleteMenu(mii.hSubMenu, ID_REPLY_GROUP, MF_BYCOMMAND);
    }
    else
    {
        fNews = TRUE;
    }

    // get the tools popup
    SideAssert(GetMenuItemInfo(hMenu, ID_POPUP_TOOLS, FALSE, &mii));

    if (ftNew != FOLDER_NEWS)
    {
        DeleteMenu(mii.hSubMenu, ID_GET_HEADERS, MF_BYCOMMAND);
        if (!fNews)
            DeleteMenu(mii.hSubMenu, ID_NEWSGROUPS, MF_BYCOMMAND);
    }

    if ((ftNew == FOLDER_LOCAL) || fHideHotMail)
    {
        DeleteMenu(mii.hSubMenu, ID_POPUP_RETRIEVE, MF_BYCOMMAND);
        DeleteMenu(mii.hSubMenu, ID_SYNC_THIS_NOW, MF_BYCOMMAND);
    }

    if (ftNew != FOLDER_IMAP)
    {
        cServers = 0;
        if (S_OK == g_pAcctMan->Enumerate(SRV_IMAP, &pEnum))
        {
            pEnum->GetCount(&cServers);
            pEnum->Release();
        }

        if (cServers == 0)
        {
            DeleteMenu(mii.hSubMenu, ID_IMAP_FOLDERS, MF_BYCOMMAND);
            if (!fNews)
                DeleteMenu(mii.hSubMenu, SEP_SUBSCRIBE, MF_BYCOMMAND);
        }
    }

    if ((g_dwHideMessenger == BL_HIDE) || (g_dwHideMessenger == BL_DISABLE))
    {
        DeleteMenu(mii.hSubMenu, SEP_MESSENGER, MF_BYCOMMAND);
        DeleteMenu(mii.hSubMenu, ID_POPUP_MESSENGER, MF_BYCOMMAND);
        DeleteMenu(mii.hSubMenu, ID_POPUP_MESSENGER_STATUS, MF_BYCOMMAND);
    }

    m_pCoolbar->ResetMenu(hMenu);
    if (m_hMenu != NULL)
    {
        if (IsMenu(m_hMenu))
        {
            AcctUtil_FreeSendReceieveMenu(m_hMenu, m_cAcctMenu);
            m_cAcctMenu = 0;
            m_fRebuildAccountMenu = TRUE;

            FreeNewAcctMenu(m_hMenu);
            m_fInitNewAcctMenu = FALSE;

            DestroyMenu(m_hMenu);
        }
    }

    m_hMenu = hMenu;
}

void CBrowser::SpoolerDeliver(WPARAM wParam, LPARAM lParam)
{
    HWND    hwndCoolbar = 0;
    char    szRes[256], sz[256];
    LPSTR   pszRes = 0;
    static BOOL s_fWarnings=FALSE;
    static ULONG s_cMsgs=0;
    
    if (wParam != DELIVERY_NOTIFY_ALLDONE)
        m_pStatus->SetSpoolerStatus((DELIVERYNOTIFYTYPE) wParam, 0);
    
    switch (wParam)
    {
        case DELIVERY_NOTIFY_STARTING:
            s_cMsgs = 0;
            s_fWarnings = FALSE;
            break;
        
        case DELIVERY_NOTIFY_CONNECTING:
            if (m_pCoolbar)
                m_pCoolbar->Invoke(idDownloadBegin, 0);

            if (m_idClearStatusTimer)
            {
                KillTimer(m_hwnd, m_idClearStatusTimer);
                m_idClearStatusTimer = 0;
            }

            if (m_pCoolbar)
                m_pCoolbar->GetWindow(&hwndCoolbar);
            break;
        
        case DELIVERY_NOTIFY_RESULT:
            if (EVENT_FAILED == lParam || EVENT_WARNINGS == lParam)
                s_fWarnings = TRUE;
            break;
        
        case DELIVERY_NOTIFY_COMPLETE:
            s_cMsgs += (ULONG) lParam;
            break;
        
        case DELIVERY_NOTIFY_ALLDONE:
            // Stop coolbar animation
            if (m_pCoolbar)
                m_pCoolbar->Invoke(idDownloadEnd, 0);                        
        
            if (s_cMsgs && IsWindow(m_hwnd))
            {
                PostMessage(m_hwnd, WM_NEW_MAIL, 0, 0);
            }

            // Show the Warnings Icon
            if (s_fWarnings)
            {
                m_pStatus->SetSpoolerStatus((DELIVERYNOTIFYTYPE) wParam, -1);
            }
            else
            {
                m_pStatus->SetSpoolerStatus((DELIVERYNOTIFYTYPE) wParam, s_cMsgs);

                // Clear the Timer
                m_idClearStatusTimer = SetTimer(m_hwnd, TIMER_CLEAR_STATUS, TIME_TO_CLEAR_NEWMSGSTATUS, NULL);
            }


            break;
    }
}

HRESULT CBrowser::CycleFocus(BOOL fReverse)
{
    DWORD   dwFlags;
    BOOL    bLast;

    HWND hwndFocus = GetFocus();
    HWND hwndNext;

	if (IsWindowVisible(hwndFocus))
	{
		hwndNext = GetNextDlgTabItem(m_hwnd, hwndFocus, fReverse);
	}
	else
	{
		hwndNext = GetNextDlgTabItem(m_hwnd, NULL, fReverse);
	}

    SetFocus(hwndNext);

    if (hwndNext == m_hwndInner || IsChild(m_hwndInner, hwndNext))
        m_itbLastFocus = ITB_OEVIEW;
    else 
        m_itbLastFocus = ITB_NAVPANE;

    return (S_OK);
}


void CBrowser::FrameActivatePopups(BOOL fActivate)
{
    HWND hwndDropDown = HwndGlobalDropDown();
    
    if (!fActivate && hwndDropDown)
        SendMessage(hwndDropDown, WMR_CLICKOUTSIDE, CLK_OUT_DEACTIVATE, 0);
}


void CBrowser::UpdateStatusBar(void)
{
    if (g_pConMan && m_pStatus)
    {
        if (g_pConMan->IsGlobalOffline())
        {
            m_pStatus->SetConnectedStatus(CONN_STATUS_WORKOFFLINE);
        }
        else
        {
            m_pStatus->SetConnectedStatus(CONN_STATUS_CONNECTED);
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// Support for drop-down treeview.  Trust me, this is necessary no matter
// how gross it is.

// currently active global drop down (if any)
static HWND s_hwndDropDown = NULL;

void RegisterGlobalDropDown(HWND hwndCtrl)
{
    Assert(s_hwndDropDown == 0);
    s_hwndDropDown = hwndCtrl;
}

void UnregisterGlobalDropDown(HWND hwndCtrl)
{
    if (s_hwndDropDown == hwndCtrl)
        s_hwndDropDown = 0;
}

void CancelGlobalDropDown()
{
    if (s_hwndDropDown)
        SendMessage(s_hwndDropDown, WMR_CLICKOUTSIDE, 0, 0);
}

HWND HwndGlobalDropDown()
{
    return s_hwndDropDown;
}

BOOL ModifyLocalFolderMenu(HMENU hMenu)
    {
    MENUITEMINFO mii;
    TCHAR        szRes[CCHMAX_STRINGRES];

    if (g_dwAthenaMode & MODE_NEWSONLY)
        {
        // File menu
        DeleteMenu(hMenu, ID_IMPORT_MESSAGES,       MF_BYCOMMAND);
        DeleteMenu(hMenu, ID_IMPORT_MAIL_ACCOUNTS,  MF_BYCOMMAND);
        DeleteMenu(hMenu, ID_EXPORT_MESSAGES,       MF_BYCOMMAND);
        
        // Tools
        ZeroMemory(&mii, sizeof(MENUITEMINFO));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_SUBMENU;

        if (GetMenuItemInfo(hMenu, ID_POPUP_TOOLS, FALSE, &mii))
            {
            // Remove Send & Receive and Message Rules
            DeleteMenu(mii.hSubMenu, ID_SEND_RECEIVE, MF_BYCOMMAND);
            }
        }

    return (TRUE);
    }

BOOL ModifyRootFolderMenu(HMENU hMenu)
    {        
    if (g_dwAthenaMode & MODE_NEWSONLY)
        {
        // File menu
        DeleteMenu(hMenu, ID_IMPORT_MESSAGES, MF_BYCOMMAND);
        DeleteMenu(hMenu, ID_IMPORT_MAIL_ACCOUNTS, MF_BYCOMMAND);
        DeleteMenu(hMenu, ID_EXPORT_MESSAGES, MF_BYCOMMAND);

        // Tools
        DeleteMenu(hMenu, ID_SEND_RECEIVE, MF_BYCOMMAND);
        }

    return (TRUE);
    }

HRESULT CBrowser::GetViewLayout(DWORD opt, LAYOUTPOS *pPos, BOOL *pfVisible, DWORD *pdwFlags, DWORD *pdwSize)
{
    HRESULT hr = E_FAIL;

    switch (opt)
    {
        case DISPID_MSGVIEW_TOOLBAR:
        {
            if (pfVisible)
                *pfVisible = m_rgTBar[ITB_COOLBAR].fShow;

            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_STATUSBAR:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fStatusBar;
            if (pPos)
                *pPos = LAYOUT_POS_NA;
            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_FOLDERBAR:
        {
            if (pfVisible)
                *pfVisible = m_rgTBar[ITB_COOLBAR].fShow;
            if (pPos)
                *pPos = LAYOUT_POS_NA;
            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_FOLDERLIST:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fFolderList;
            if (pPos)
                *pPos = LAYOUT_POS_NA;
            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_TIPOFTHEDAY:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fTipOfTheDay;
            if (pPos)
                *pPos = LAYOUT_POS_NA;
            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_INFOPANE:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fInfoPane;
            if (pPos)
                *pPos = LAYOUT_POS_NA;
            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_OUTLOOK_BAR:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fOutlookBar;
            if (pPos)
                *pPos = LAYOUT_POS_NA;
            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_CONTACTS:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fContacts;
            if (pPos)
                *pPos = LAYOUT_POS_NA;
            if (pdwFlags)
                *pdwFlags = 0;

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_PREVIEWPANE_NEWS:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fNewsPreviewPane;
            if (pPos)
                *pPos = m_rLayout.fNewsSplitVertically ? LAYOUT_POS_LEFT : LAYOUT_POS_BOTTOM ;
            if (pdwFlags)
                *pdwFlags = m_rLayout.fNewsPreviewPaneHeader;
            if (pdwSize)
            {
                if (0 == m_rLayout.bNewsSplitHorzPct)
                    m_rLayout.bNewsSplitHorzPct = 50;
                if (0 == m_rLayout.bNewsSplitVertPct)
                    m_rLayout.bNewsSplitVertPct = 50;
                *pdwSize = MAKELONG((WORD) m_rLayout.bNewsSplitHorzPct, (WORD) m_rLayout.bNewsSplitVertPct);
            }

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_PREVIEWPANE_MAIL:
        {
            if (pfVisible)
                *pfVisible = m_rLayout.fMailPreviewPane;
            if (pPos)
                *pPos = m_rLayout.fMailSplitVertically ? LAYOUT_POS_LEFT : LAYOUT_POS_BOTTOM ;
            if (pdwFlags)
                *pdwFlags = m_rLayout.fMailPreviewPaneHeader;
            if (pdwSize)
            {
                if (0 == m_rLayout.bMailSplitHorzPct)
                    m_rLayout.bMailSplitHorzPct = 50;
                if (0 == m_rLayout.bMailSplitVertPct)
                    m_rLayout.bMailSplitVertPct = 50;
                *pdwSize = MAKELONG((WORD) m_rLayout.bMailSplitHorzPct, (WORD) m_rLayout.bMailSplitVertPct);
            }

            hr = S_OK;
            break;
        }

        default:
            AssertSz(0, "CBrowser::GetViewLayout() - Called with an unrecognized layout option.");
    }

    return (hr);
}


HRESULT CBrowser::SetViewLayout(DWORD opt, LAYOUTPOS pos, BOOL fVisible, DWORD dwFlags, DWORD dwSize)
{
    HRESULT hr = E_FAIL;

    switch (opt)
    {
        case DISPID_MSGVIEW_TOOLBAR:
        {
            m_rLayout.fToolbar = !!fVisible;

            // This can be called before the windows are created.  If so, we 
            // store the setting and will use it later.
            if (m_pCoolbar)
            {            
                m_pCoolbar->HideToolbar(!m_rLayout.fToolbar);
            }
            
            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_FILTERBAR:
        {
            m_rLayout.fFilterBar = !!fVisible;

            if (m_pCoolbar)
                m_pCoolbar->HideToolbar(!m_rLayout.fFilterBar, CBTYPE_RULESTOOLBAR);

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_STATUSBAR:
        {
            m_rLayout.fStatusBar = !!fVisible;

            if (m_pStatus)
            {   
                m_pStatus->ShowStatus(m_rLayout.fStatusBar);
                ResizeNextBorder(0);
            }

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_FOLDERBAR:
        {
            m_rLayout.fFolderBar = fVisible;

            if (m_pFolderBar)
                ShowToolbar((IUnknown *) (IDockingWindow *) m_pFolderBar, fVisible);

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_FOLDERLIST:
        {
            m_rLayout.fFolderList = fVisible;

            if (m_pNavPane)
            {
                m_pNavPane->ShowFolderList(fVisible);
                m_pFolderBar->Update(FALSE, TRUE);
            }
            UpdateToolbar();
            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_TIPOFTHEDAY:
        {
            m_rLayout.fTipOfTheDay = fVisible;

            if (m_hwndInner)
                SendMessage(m_hwndInner, WM_UPDATELAYOUT, 0, 0);

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_INFOPANE:
        {
            m_rLayout.fInfoPane = fVisible;

            if (m_pBodyBar)
                ShowToolbar((IUnknown *) (IDockingWindow *) m_pBodyBar, fVisible);

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_OUTLOOK_BAR:
        {
            m_rLayout.fOutlookBar = fVisible;

            if (m_pOutBar)
                ShowToolbar((IUnknown *) (IDockingWindow *) m_pOutBar, fVisible);

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_CONTACTS:
        {
            m_rLayout.fContacts = fVisible;

            if (m_pNavPane)
            {
                m_pNavPane->ShowContacts(fVisible);
            }
            UpdateToolbar();
            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_PREVIEWPANE_NEWS:
        {
            BOOL fForceUpdate = (m_rLayout.fMailPreviewPane != (unsigned) !!fVisible);

            m_rLayout.fNewsPreviewPane = !!fVisible;
            m_rLayout.fNewsPreviewPaneHeader = !!dwFlags;            
            if (pos != LAYOUT_POS_NA)
                m_rLayout.fNewsSplitVertically = (LAYOUT_POS_LEFT == pos);

            if (LOWORD(dwSize))
            {
                m_rLayout.bNewsSplitHorzPct = (BYTE) LOWORD(dwSize);
            }

            if (HIWORD(dwSize))
            {
                m_rLayout.bNewsSplitVertPct = (BYTE) HIWORD(dwSize);
            }

            if (m_pView)
            {
                IMessageWindow *pWindow;

                if (SUCCEEDED(m_pView->QueryInterface(IID_IMessageWindow, (LPVOID *) &pWindow)))
                {
                    pWindow->UpdateLayout(fVisible, (BOOL) dwFlags, m_rLayout.fNewsSplitVertically, fForceUpdate);
                    pWindow->Release();
                }
            }
    
            UpdateToolbar();

            hr = S_OK;
            break;
        }

        case DISPID_MSGVIEW_PREVIEWPANE_MAIL:
        {
            BOOL fForceUpdate = (m_rLayout.fMailPreviewPane != (unsigned) !!fVisible);

            m_rLayout.fMailPreviewPane = !!fVisible; 
            m_rLayout.fMailPreviewPaneHeader = !!dwFlags;            
            if (pos != LAYOUT_POS_NA)
                m_rLayout.fMailSplitVertically = (LAYOUT_POS_LEFT == pos);

            if (LOWORD(dwSize))
            {
                m_rLayout.bMailSplitHorzPct = (BYTE) LOWORD(dwSize);
            }

            if (HIWORD(dwSize))
            {
                m_rLayout.bMailSplitVertPct = (BYTE) HIWORD(dwSize);
            }

            if (m_pView)
            {
                IMessageWindow *pWindow;

                if (SUCCEEDED(m_pView->QueryInterface(IID_IMessageWindow, (LPVOID *) &pWindow)))
                {
                    pWindow->UpdateLayout(fVisible, (BOOL) dwFlags, m_rLayout.fMailSplitVertically, fForceUpdate);
                    pWindow->Release();
                }
            }

            UpdateToolbar();

            hr = S_OK;
            break;
        }

        default:
            AssertSz(0, "CBrowser::SetViewLayout() - Called with an unrecognized layout option.");
    }

    return (hr);
}


//
//  FUNCTION:   CBrowser::LoadLayoutSettings()
//
//  PURPOSE:    Loads all of the layout settings from the registry and 
//              caches them in the rLayout member.
//
//  RETURN VALUE:
//      Returns S_OK all the time 
//
HRESULT CBrowser::LoadLayoutSettings(void)
{
    TraceCall("CBrowser::LoadLayoutSettings");

    m_rLayout.cbSize = sizeof(LAYOUT);

    // Things that can be turned on or off
    m_rLayout.fStatusBar              = DwGetOption(OPT_SHOWSTATUSBAR); 
    m_rLayout.fFolderBar              = !DwGetOption(OPT_HIDEFOLDERBAR);
    m_rLayout.fFolderList             = DwGetOption(OPT_SHOWTREE);
    m_rLayout.fTipOfTheDay            = DwGetOption(OPT_TIPOFTHEDAY);
    m_rLayout.fInfoPaneEnabled        = FALSE;
    m_rLayout.fInfoPane               = DwGetOption(OPT_SHOWBODYBAR);
    m_rLayout.fOutlookBar             = DwGetOption(OPT_SHOWOUTLOOKBAR);
    m_rLayout.fContacts               = DwGetOption(OPT_SHOWCONTACTS);
    m_rLayout.fMailPreviewPane        = DwGetOption(OPT_MAILHYBRIDVIEW);
    m_rLayout.fMailPreviewPaneHeader  = DwGetOption(OPT_MAILSHOWHEADERINFO);
    m_rLayout.fMailSplitVertically    = DwGetOption(OPT_MAILSPLITDIR);
    m_rLayout.fNewsPreviewPane        = DwGetOption(OPT_NEWSHYBRIDVIEW);
    m_rLayout.fNewsPreviewPaneHeader  = DwGetOption(OPT_NEWSSHOWHEADERINFO);
    m_rLayout.fNewsSplitVertically    = DwGetOption(OPT_NEWSSPLITDIR);
    
    // Coolbar Side
    //m_rLayout.csToolbarSide = COOLBAR_TOP;

    // Preview Pane widths
    m_rLayout.bMailSplitHorzPct = (BYTE) DwGetOption(OPT_MAILCYSPLIT);
    m_rLayout.bMailSplitVertPct = (BYTE) DwGetOption(OPT_MAILCXSPLIT);
    m_rLayout.bNewsSplitHorzPct = (BYTE) DwGetOption(OPT_NEWSCYSPLIT);
    m_rLayout.bNewsSplitVertPct = (BYTE) DwGetOption(OPT_NEWSCXSPLIT);

    return (S_OK);
}



//
//  FUNCTION:   CBrowser::SaveLayoutSettings()
//
//  PURPOSE:    Saves all of the layout configuration back to the registry.
//
//  RETURN VALUE:
//      Returns S_OK all the time
//
HRESULT CBrowser::SaveLayoutSettings(void)
{
    TraceCall("CBrowser::SaveLayoutSettings");

    // Things that can be turned on or off
    SetDwOption(OPT_SHOWSTATUSBAR, m_rLayout.fStatusBar, 0, 0); 
    SetDwOption(OPT_HIDEFOLDERBAR, !m_rLayout.fFolderBar, 0, 0);
    SetDwOption(OPT_SHOWTREE, m_rLayout.fFolderList, 0, 0);
    SetDwOption(OPT_TIPOFTHEDAY, m_rLayout.fTipOfTheDay, 0, 0);
    SetDwOption(OPT_SHOWBODYBAR, m_rLayout.fInfoPane, 0, 0);
    SetDwOption(OPT_SHOWOUTLOOKBAR, m_rLayout.fOutlookBar, 0, 0);
    SetDwOption(OPT_SHOWCONTACTS, m_rLayout.fContacts, 0, 0);
    SetDwOption(OPT_MAILHYBRIDVIEW, m_rLayout.fMailPreviewPane, 0, 0);
    SetDwOption(OPT_MAILSHOWHEADERINFO, m_rLayout.fMailPreviewPaneHeader, 0, 0);
    SetDwOption(OPT_MAILSPLITDIR, m_rLayout.fMailSplitVertically, 0, 0);
    SetDwOption(OPT_NEWSHYBRIDVIEW, m_rLayout.fNewsPreviewPane, 0, 0);
    SetDwOption(OPT_NEWSSHOWHEADERINFO, m_rLayout.fNewsPreviewPaneHeader, 0, 0);
    SetDwOption(OPT_NEWSSPLITDIR, m_rLayout.fNewsSplitVertically, 0, 0);

    // Preview Pane widths
    SetDwOption(OPT_MAILCYSPLIT, (DWORD) m_rLayout.bMailSplitHorzPct, 0, 0);
    SetDwOption(OPT_MAILCXSPLIT, (DWORD) m_rLayout.bMailSplitVertPct, 0, 0);
    SetDwOption(OPT_NEWSCYSPLIT, (DWORD) m_rLayout.bNewsSplitHorzPct, 0, 0);
    SetDwOption(OPT_NEWSCXSPLIT, (DWORD) m_rLayout.bNewsSplitVertPct, 0, 0);

    return (S_OK);
}


HRESULT CBrowser::CmdSendReceieveAccount(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    MENUITEMINFO mii;

    mii.cbSize     = sizeof(MENUITEMINFO);
    mii.fMask      = MIIM_DATA;
    mii.dwItemData = 0;

    if (GetMenuItemInfo(m_hMenu, nCmdID, FALSE, &mii))
    {
        if (mii.dwItemData)
        {
            g_pSpooler->StartDelivery(m_hwnd, (LPTSTR) mii.dwItemData, FOLDERID_INVALID,
                DELIVER_MAIL_SEND | DELIVER_MAIL_RECV | DELIVER_NOSKIP | 
                DELIVER_POLL | DELIVER_OFFLINE_FLAGS);
        }
        else
        {
            g_pSpooler->StartDelivery(m_hwnd, NULL, FOLDERID_INVALID,
                DELIVER_MAIL_SEND | DELIVER_MAIL_RECV | DELIVER_POLL | 
                DELIVER_OFFLINE_FLAGS);
        }
    }

    return (S_OK);
}


HRESULT CBrowser::CmdDeleteAccel(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    BOOL fNoTrash;
    IOleCommandTarget *pTarget = NULL;
    

    // Figure out where the focus is
    HWND hwndFocus = GetFocus();

    Assert(nCmdID == ID_DELETE_ACCEL || nCmdID == ID_DELETE_NO_TRASH_ACCEL);

    fNoTrash = (nCmdID == ID_DELETE_NO_TRASH_ACCEL);

    // Check to see if it's the treeview
    if (S_OK == m_pTreeView->HasFocusIO())
    {
        pTarget = m_pTreeView;
        nCmdID = fNoTrash ? ID_DELETE_NO_TRASH : ID_DELETE_FOLDER;
    }

    // Check to see if it's anything else on the Info Column
    else if (m_pNavPane->IsContactsFocus())
    {
        pTarget = m_pNavPane;
        nCmdID = ID_DELETE_CONTACT;
    }

    // Otherwise, it must be the view
    else
    {
        pTarget = m_pViewCT;
        nCmdID = fNoTrash ? ID_DELETE_NO_TRASH : ID_DELETE;
    }

    // Hit the target with the right command
    if (pTarget)
        return (pTarget->Exec(NULL, nCmdID, nCmdExecOpt, pvaIn, pvaOut));
    else
        return (OLECMDERR_E_NOTSUPPORTED);
}

HRESULT CBrowser::TranslateMenuMessage(MSG *lpmsg, LRESULT *lres)
{
    if (m_pCoolbar)
        return m_pCoolbar->TranslateMenuMessage(lpmsg, lres);
    else
        return S_FALSE;
}

BOOL CBrowser::_InitToolbars(void)
{
    DWORD   dwTreeFlags = 0;

    if (!(m_pTreeView = new CTreeView(this)))
        goto error;

    if (g_dwAthenaMode & MODE_OUTLOOKNEWS)
        dwTreeFlags |= TREEVIEW_NOIMAP | TREEVIEW_NOHTTP;

    if (FAILED(m_pTreeView->HrInit(dwTreeFlags, this)))
        goto error;


    if (!(m_pCoolbar = new CBands()))
        goto error;

    if (FAILED(m_pCoolbar->HrInit(NULL, m_hMenu, PARENT_TYPE_BROWSER)))
        goto error;

    if (FAILED(AddToolbar((IDockingWindow*)m_pCoolbar, ITB_COOLBAR, TRUE, TRUE)))
        goto error;

    //m_pCoolbar->HideToolbar(!m_rLayout.fToolbar);
    m_rLayout.fToolbar      = m_pCoolbar->IsBandVisible(CBTYPE_TOOLS);
    m_rLayout.fFilterBar    = m_pCoolbar->IsBandVisible(CBTYPE_RULESTOOLBAR);

    if (FAILED(m_pCoolbar->SetFolderType(m_ftSel)))
        goto error;

    if (!(m_pOutBar = new COutBar()))
        goto error;

    if (FAILED(m_pOutBar->HrInit(NULL, this)))
        goto error;

    if (FAILED(AddToolbar((IDockingWindow *) m_pOutBar, ITB_OUTBAR, m_rLayout.fOutlookBar, TRUE)))
        goto error;

#ifdef HOTMAILADV
    if (!(m_pAdBar = new CAdBar()))
        goto error;

    if (FAILED(AddToolbar((IDockingWindow*)m_pAdBar, ITB_ADBAR, TRUE, FALSE)))
        goto error;
#endif // HOTMAILADV

    if (!(m_pBodyBar = new CBodyBar()))
        goto error;

    BOOL fBodyBarEnabled;
    if (FAILED(m_pBodyBar->HrInit(&fBodyBarEnabled)))
        goto error;
    m_rLayout.fInfoPaneEnabled = !!fBodyBarEnabled;

    if (FAILED(AddToolbar((IDockingWindow*)m_pBodyBar, ITB_BODYBAR, 
                          m_rLayout.fInfoPaneEnabled && m_rLayout.fInfoPane, FALSE)))
        goto error;

    if (!(m_pFolderBar = new CFolderBar()))
        goto error;

    if (FAILED(m_pFolderBar->HrInit(this)))
        goto error;

    if (FAILED(AddToolbar((IDockingWindow*)m_pFolderBar, ITB_FOLDERBAR, m_rLayout.fFolderBar, TRUE)))
        goto error;

    if (!(m_pNavPane = new CNavPane()))
        goto error;

    if (FAILED(m_pNavPane->Initialize(m_pTreeView)))
        goto error;

    if (FAILED(AddToolbar((IDockingWindow*) m_pNavPane, ITB_NAVPANE, m_rLayout.fFolderList || m_rLayout.fContacts, TRUE)))
        goto error;

    return (TRUE);

error:
    SafeRelease(m_pStatus);
    SafeRelease(m_pTreeView);
    SafeRelease(m_pCoolbar);
    SafeRelease(m_pFolderBar);

    return (FALSE);
}


HRESULT CBrowser::QuerySwitchIdentities()
{
    TraceCall("CBrowser::QuerySwitchIdentities");

    if (!IsWindowEnabled(m_hwnd))
    {
        Assert(IsWindowVisible(m_hwnd));
        return E_PROCESS_CANCELLED_SWITCH;
    }

    if (g_pConMan->IsConnected())
    {
        SetForegroundWindow(m_hwnd);

        if (IDNO == AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsSwitchUser),MAKEINTRESOURCEW(idsMaintainConnection),  
                              NULL, MB_ICONEXCLAMATION  | MB_YESNO | MB_DEFBUTTON1 | MB_SYSTEMMODAL))
            g_pConMan->Disconnect(m_hwnd, TRUE, FALSE, FALSE );
    }

    m_fSwitchIsLogout = MU_CheckForIdentityLogout();

    return S_OK;
}

HRESULT CBrowser::SwitchIdentities()
{
    TraceCall("CBrowser::SwitchIdentities");

    if (!m_fSwitchIsLogout)
    {
        // Let ::BrowserWndProc know that this close is due to an id switch
        s_fQuickShutdown = TRUE;
    }
    else
    {
        s_fQuickShutdown = FALSE;
        g_pInstance->SetSwitchingUsers(FALSE);
    }

    // We can't SendMessage here as we'd cause ole to throw RPC_E_CANTCALLOUT_ININPUTSYNCCALL 
    PostMessage(m_hwnd, WM_CLOSE, 0, 0);
    
    return S_OK;
}

HRESULT CBrowser::IdentityInformationChanged(DWORD dwType)
{
    TraceCall("CBrowser::IdentityInformationChanged");

    // Refresh for adds, delete, or current identity changed
    // since adding could require that the name show up,
    // deleteing could require that it go away and changed 
    // should be reflected immediately.
    if (dwType != IIC_IDENTITY_CHANGED)
    {
        MU_IdentityChanged();
        OnRename(m_idSelected);
    }
    return S_OK;
}

HRESULT CBrowser::ShowAdBar(BSTR    bstr)
{
    HRESULT     hr              = S_OK;
#ifdef HOTMAILADV
    LPSTR       pszAdInfo       = NULL;
    BOOL        fShowAdPane     = FALSE;
    LPSTR       pszActualUrl    = NULL;
    DWORD       ActualCount     = 0;
    CHAR        szAdPaneValue[MAX_PATH];
    DWORD       cchRetCount     = 0;
    CHAR        szAdOther[MAX_PATH];
    CHAR        szEncodedString[MAX_PATH];
    CHAR        szAdSvr[MAX_PATH];
    FOLDERINFO  FolderInfo = {0};
    CHAR        szAccountId[CCHMAX_ACCOUNT_NAME];
    IImnAccount *pAccount = NULL;
    CHAR        szCachedAdUrl[INTERNET_MAX_URL_LENGTH];

    IF_FAILEXIT(hr = HrBSTRToLPSZ(CP_ACP, bstr, &pszAdInfo));

    //Search for AdPane token
    IF_FAILEXIT(hr = HrProcessAdTokens(pszAdInfo, c_szAdPane, szAdPaneValue, ARRAYSIZE(szAdPaneValue), &cchRetCount));
    
    fShowAdPane = (lstrcmp(szAdPaneValue, c_szAdPaneOn) == 0);

    // Get the server for this folder
    IF_FAILEXIT(hr = GetFolderServer(m_idSelected, &FolderInfo));

    // Get the account ID for the server
    IF_FAILEXIT(hr = GetFolderAccountId(&FolderInfo, szAccountId));

    // Get the account interface
    IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAccountId, &pAccount));

    IF_FAILEXIT(hr = pAccount->SetPropDw(AP_HTTPMAIL_SHOW_ADBAR, fShowAdPane));

    if (fShowAdPane)
    {
        //Plus one for null in version string
        ActualCount += CCH_REDIRECT_ADURL + strlen(c_szUrlSubPVER) + 1; 

        //Search for AdSvr token
        IF_FAILEXIT(hr = HrProcessAdTokens(pszAdInfo, c_szAdSvr, szAdSvr, ARRAYSIZE(szAdSvr), &cchRetCount));

        ActualCount += cchRetCount;

        ActualCount += CCH_ADSVR_TOKEN_FORMAT;

        //Search for the token other
        IF_FAILEXIT(hr = HrProcessAdTokens(pszAdInfo, c_szAdOther, szAdOther, ARRAYSIZE(szAdOther), &cchRetCount));

        //Encode the other string
        IF_FAILEXIT(hr = HrEscapeOtherAdToken(szAdOther, szEncodedString, ARRAYSIZE(szEncodedString), &cchRetCount));

        ActualCount += cchRetCount;

        //one for null
        ActualCount += CCH_OTHER_FORMAT + 1;

        IF_FAILEXIT(hr = HrAlloc((LPVOID*)&pszActualUrl, ActualCount));

        *pszActualUrl = 0;

        wsprintf(pszActualUrl, c_szAdRedirectFormat, c_szRedirectAdUrl, c_szUrlSubPVER,
                               c_szAdSvrFormat, szAdSvr, c_szAdOtherFormat, szEncodedString);

        
        IF_FAILEXIT(hr = m_pAdBar->SetUrl(pszActualUrl));

        IF_FAILEXIT(hr = pAccount->SetPropSz(AP_HTTPMAIL_ADURL, pszActualUrl));
    }

    ShowToolbar((IDockingWindow*)m_pAdBar, fShowAdPane);

    //We need to do this to persist the property into registry.
    IF_FAILEXIT(hr = pAccount->WriteChanges());

exit:

    if (FAILED(hr) && fShowAdPane)
    {
        BOOL    fSucceeded = FALSE;

        //We are supposed to show adpane, but something went wrong in the info we got. 
        //We just display the cached URL.
        *szCachedAdUrl = 0;

        if (pAccount)
        {
            if (SUCCEEDED(pAccount->GetPropSz(AP_HTTPMAIL_ADURL, szCachedAdUrl, ARRAYSIZE(szCachedAdUrl))))
            {
                fSucceeded = SUCCEEDED(m_pAdBar->SetUrl(szCachedAdUrl));
            }
        }

        if (!fSucceeded)
        {
            //If we can't get the cached ad or if the cached is empty, we turn off the adpane
            ShowToolbar((IDockingWindow*)m_pAdBar, FALSE);
        }

    }

    g_pStore->FreeRecord(&FolderInfo);
    ReleaseObj(pAccount);
    MemFree(pszActualUrl);
    MemFree(pszAdInfo);
#endif // HOTMAILADV

    return hr;
}

void CBrowser::WriteUnreadCount(void)
{
    IImnEnumAccounts    *pEnum = NULL;
    IImnAccount         *pAcct = NULL;
    DWORD               cServers = 0;
    IMessageFolder      *pFolder = NULL;
    DWORD               nCount = 0 ;
    FOLDERID            idServer;
    TCHAR               szUserEmail[CCHMAX_EMAIL_ADDRESS];
    WCHAR               wsz[CCHMAX_EMAIL_ADDRESS];
    HRESULT             hr = S_OK;

    // can't proceed if there's no accnt manager
    if (g_pAcctMan == NULL)
        return;

    // 1. Enumerate POP3 accounts:
    if (S_OK == g_pAcctMan->Enumerate(SRV_POP3, &pEnum))
    {
        // Get count of servers
        pEnum->GetCount(&cServers);

        if(cServers == 1)
        {
            // a). All POP3 account in local store
            if(SUCCEEDED(pEnum->GetNext(&pAcct)) && g_pStore)
            {
                IF_FAILEXIT(hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_INBOX, &pFolder));

                nCount = _GetNumberOfUnreadMsg(pFolder);
                IF_FAILEXIT(hr = pAcct->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szUserEmail, ARRAYSIZE(szUserEmail)));
                if(MultiByteToWideChar(CP_ACP, 0, szUserEmail, -1, wsz, CCHMAX_ACCOUNT_NAME) != 0)
                    // write # unread messages to registry
                    hr = SHSetUnreadMailCountW(wsz, nCount, L"msimn");
                SafeRelease(pFolder);
            }

        }
    }

    // 1. Enumerate IMAP accounts:
    IF_FAILEXIT(hr = _CheckAndWriteUnreadNumber(SRV_IMAP));
    IF_FAILEXIT(hr = _CheckAndWriteUnreadNumber(SRV_HTTPMAIL));

exit:
    SafeRelease(pAcct);
    SafeRelease(pEnum);
    return;
}

DWORD CBrowser::_GetNumberOfUnreadMsg(IMessageFolder *pFolder)
{
    DWORD           nCount = 0;
    HROWSET         hRowset=NULL;
    MESSAGEINFO     Message={0};
    HRESULT             hr = S_OK;
    // Create Rowset
    IF_FAILEXIT(hr = pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Iterate throug the messages
    while (S_OK == pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        // Not Read
        if (FALSE == ISFLAGSET(Message.dwFlags, ARF_READ))
            nCount++;

        // Free
        pFolder->FreeRecord(&Message);
    }

exit:
    // Clenaup
    pFolder->CloseRowset(&hRowset);

    return(nCount);
}

HRESULT CBrowser::_CheckAndWriteUnreadNumber(DWORD dwSrvTypes)
{
    IImnEnumAccounts    *pEnum = NULL;
    IImnAccount         *pAcct = NULL;
    DWORD               cServers = 0;
    IMessageFolder      *pFolder = NULL;
    DWORD               nCount = 0 ;
    FOLDERID            idServer;
    TCHAR               szAccountId[CCHMAX_ACCOUNT_NAME];
    TCHAR               szUserEmail[CCHMAX_EMAIL_ADDRESS];
    WCHAR               wsz[CCHMAX_EMAIL_ADDRESS];
    HRESULT             hr = S_OK;

    if(g_pStore == NULL)
        return(hr);

    if (S_OK == g_pAcctMan->Enumerate(dwSrvTypes, &pEnum))
    {
        while(SUCCEEDED(pEnum->GetNext(&pAcct)))
        {
            // Get the Account ID for pAccount
            IF_FAILEXIT(hr = pAcct->GetPropSz(AP_ACCOUNT_ID, szAccountId, ARRAYSIZE(szAccountId)));
            
            // Find the Server Id
            IF_FAILEXIT(hr = g_pStore->FindServerId(szAccountId, &idServer));
            
            // Open Store
            IF_FAILEXIT(hr = g_pStore->OpenSpecialFolder(idServer, NULL, FOLDER_INBOX, &pFolder));
            
            nCount = _GetNumberOfUnreadMsg(pFolder);

            // write # unread messages to registry
            IF_FAILEXIT(hr = pAcct->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szUserEmail, ARRAYSIZE(szUserEmail)));
            
            if(MultiByteToWideChar(CP_ACP, 0, szUserEmail, -1, wsz, CCHMAX_ACCOUNT_NAME) != 0)
                hr = SHSetUnreadMailCountW(wsz, nCount, L"msimn");
            SafeRelease(pFolder);
            SafeRelease(pAcct);      
        }
    }
exit:
    SafeRelease(pFolder);
    SafeRelease(pAcct);
    SafeRelease(pEnum);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\dllmain.h ===
// --------------------------------------------------------------------------
// DLLMAIN.H
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------
#ifndef __DLLMAIN_H
#define __DLLMAIN_H

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class COutlookExpress;
class CNote;
class CBrowser;
class CConnectionManager;
class CSubManager;
class CFontCache;
class CStationery;
class CNote;
interface IMimeAllocator;
interface IImnAccountManager;
interface ISpoolerEngine;
interface IFontCache;
interface IOERulesManager;
typedef struct tagACTIVEFINDFOLDER *LPACTIVEFINDFOLDER;

// --------------------------------------------------------------------------------
// HINITREF - Used internally by msoe.dll
// --------------------------------------------------------------------------------
DECLARE_HANDLE(HINITREF);
typedef HINITREF *LPHINITREF;


// --------------------------------------------------------------------------------
// Enumerations
// --------------------------------------------------------------------------------
typedef enum tagROAMSTATE {
    RS_NO_ROAMING,           // OE not currently roaming any settings
    RS_SETTINGS_DOWNLOADED   // OE has successfully DL'ed settings from cfg svr
} ROAMSTATE;


// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
extern HINSTANCE                       g_hInst;
extern HINSTANCE                       g_hLocRes;
extern CRITICAL_SECTION                g_csDBListen;
extern CRITICAL_SECTION                g_csgoCommon;
extern CRITICAL_SECTION                g_csgoMail;
extern CRITICAL_SECTION                g_csgoNews;
extern CRITICAL_SECTION                g_csFolderDlg;
extern CRITICAL_SECTION                g_csFmsg;
extern CRITICAL_SECTION                s_csPasswordList;
extern CRITICAL_SECTION                g_csAccountPropCache;
extern CRITICAL_SECTION                g_csMsgrList;
extern CRITICAL_SECTION                g_csThreadList;
extern COutlookExpress                *g_pInstance;
extern HWND                            g_hwndInit,
                                       g_hwndActiveModal;
extern UINT                            g_msgMSWheel;
extern HACCEL                          g_haccelNewsView;
extern DWORD                           g_dwAthenaMode; 
extern IImnAccountManager2            *g_pAcctMan;
extern HMODULE                         g_hlibMAPI;
extern CBrowser                       *g_pBrowser;
extern DWORD                           g_dwSecurityCheckedSchemaProp;
extern CSubManager                    *g_pSubMgr;
extern IMimeAllocator                 *g_pMoleAlloc;
extern CConnectionManager             *g_pConMan;
extern ISpoolerEngine                 *g_pSpooler;
extern IFontCache                     *g_lpIFontCache;
// bobn: brianv says we have to take this out...
//extern DWORD                           g_dwBrowserFlags;
extern UINT                            CF_FILEDESCRIPTORA; 
extern UINT                            CF_FILEDESCRIPTORW; 
extern UINT                            CF_FILECONTENTS;
extern UINT                            CF_HTML;
extern UINT                            CF_INETMSG;
extern UINT                            CF_OEFOLDER;
extern UINT                            CF_SHELLURL;
extern UINT                            CF_OEMESSAGES;
extern UINT                            CF_OESHORTCUT;
extern CStationery                    *g_pStationery;
extern ROAMSTATE                       g_rsRoamState;
extern IOERulesManager                *g_pRulesMan;
extern IMessageStore                  *g_pStore;
extern DWORD                           g_dwTlsTimeout;
extern CRITICAL_SECTION                g_csFindFolder;
extern LPACTIVEFINDFOLDER              g_pHeadFindFolder;
extern SYSTEM_INFO                     g_SystemInfo;
extern OSVERSIONINFO				   g_OSInfo;

extern BOOL                            g_fPluralIDs;
extern UINT                            g_uiCodePage;
extern IDatabaseSession               *g_pDBSession;
extern BOOL                            g_bMirroredOS;

IF_DEBUG(extern DWORD                  TAG_OBJECTDB;)
IF_DEBUG(extern DWORD                  TAG_INITTRACE;)
IF_DEBUG(extern DWORD                  TAG_SERVERQ;)
IF_DEBUG(extern DWORD                  TAG_IMAPSYNC;)


// global OE type-lib. Defer-created in BaseDisp.Cpp
// freed on process detach, protected with CS
extern ITypeLib                        *g_pOETypeLib;
extern CRITICAL_SECTION                g_csOETypeLib;

inline BOOL fIsNT5()        { return((g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (g_OSInfo.dwMajorVersion >= 5)); }
inline BOOL fIsWhistler()   { return((fIsNT5() && g_OSInfo.dwMinorVersion >=1) || 
            ((g_OSInfo.dwMajorVersion > 5) &&  (g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT))); }


#endif // __DLLMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\cexticon.h ===
////////////////////////////////////////////////////////////////////////
//
//  CExtractIcon
//
//  IExtractIcon implementation
//
////////////////////////////////////////////////////////////////////////

#ifndef _INC_CEXTICON_H
#define _INC_CEXTICON_H

class CExtractIcon : public IExtractIconA, public IExtractIconW
{
public:
    // *** IUnknown methods ***
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // *** IExtractIconA methods ***
    HRESULT STDMETHODCALLTYPE GetIconLocation(UINT uFlags,LPSTR szIconFile,UINT cchMax,int FAR *piIndex,UINT FAR *pwFlags);
    HRESULT STDMETHODCALLTYPE Extract(LPCSTR pszFile,UINT nIconIndex,HICON FAR *phiconLarge,HICON FAR *phiconSmall,UINT nIcons);

#ifndef WIN16  // WIN16FF
    // *** IExtractIconW methods ***
    HRESULT STDMETHODCALLTYPE GetIconLocation(UINT uFlags,LPWSTR szIconFile,UINT cchMax,int FAR *piIndex,UINT FAR *pwFlags);
    HRESULT STDMETHODCALLTYPE Extract(LPCWSTR pszFile,UINT nIconIndex,HICON FAR *phiconLarge,HICON FAR *phiconSmall,UINT nIcons);
#endif // !WIN16

    CExtractIcon(int iIcon, int iIconOpen, UINT uFlags, LPSTR szModule);
    ~CExtractIcon();

private:
    UINT        m_cRef;
    int         m_iIcon;
    int         m_iIconOpen;
    UINT        m_uFlags;
    char        m_szModule[MAX_PATH];    
};

#endif // _INC_CEXTICON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\cexticon.cpp ===
////////////////////////////////////////////////////////////////////////
//
//  CExtractIcon
//
//  IExtractIcon implementation
//
////////////////////////////////////////////////////////////////////////

#include "pch.hxx"
#include "cexticon.h"

CExtractIcon::CExtractIcon(int iIcon, int iIconOpen, UINT uFlags, LPSTR szModule)
{
    DOUT("CExtractIcon::CExtractIcon");

    m_cRef = 1;
    m_iIcon = iIcon;
    m_iIconOpen = iIconOpen;
    m_uFlags = uFlags;
    if (szModule)
        lstrcpy(m_szModule, szModule);
    else
        GetModuleFileName(g_hInst, m_szModule, sizeof(m_szModule)/sizeof(char));
}

CExtractIcon::~CExtractIcon()
{
}

////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE CExtractIcon::QueryInterface(REFIID riid, void **ppvObject)
{
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppvObject = (void *)this;
        }
    else if (IsEqualIID(riid, IID_IExtractIconA))
        {
        *ppvObject = (IExtractIconA *)this;
        }
    else if (IsEqualIID(riid, IID_IExtractIconW))
        {
        *ppvObject = (IExtractIconW *)this;
        }
    else
        {
        *ppvObject = NULL;
        return E_NOINTERFACE;
        }

    m_cRef++;
    return NOERROR;
}

ULONG STDMETHODCALLTYPE CExtractIcon::AddRef(void)
{
    DOUT("CExtractIcon::AddRef() ==> %d", m_cRef+1);
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CExtractIcon::Release(void)
{
    DOUT("CExtractIcon::Release() ==> %d", m_cRef-1);

    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    else
        return m_cRef;
}

////////////////////////////////////////////////////////////////////////
//
//  IExtractIconA
//
////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE CExtractIcon::GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, 
                                                        int *piIndex, UINT *pwFlags)
{
    lstrcpyn(szIconFile, m_szModule, cchMax);
    *piIndex = (uFlags & GIL_OPENICON) ? m_iIconOpen : m_iIcon;
    *pwFlags = m_uFlags;
    return NOERROR;
}

HRESULT STDMETHODCALLTYPE CExtractIcon::Extract(LPCSTR pszFile, UINT nIconIndex, HICON *phiconLarge, 
                                                HICON *phiconSmall, UINT nIcons)
{
    // let the explorer extract the icon
    return S_FALSE;
}

#ifndef WIN16  // WIN16FF
////////////////////////////////////////////////////////////////////////
//
//  IExtractIconW
//
////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE CExtractIcon::GetIconLocation(UINT uFlags, LPWSTR szIconFile, UINT cchMax, 
                                                        int *piIndex, UINT *pwFlags)
{
    MultiByteToWideChar(CP_ACP, 0, m_szModule, -1, szIconFile, cchMax);
    *piIndex = (uFlags & GIL_OPENICON) ? m_iIconOpen : m_iIcon;
    *pwFlags = m_uFlags;
    return NOERROR;
}

HRESULT STDMETHODCALLTYPE CExtractIcon::Extract(LPCWSTR pszFile, UINT nIconIndex, HICON *phiconLarge, 
                                                HICON *phiconSmall, UINT nIcons)
{
    // let the explorer extract the icon
    return S_FALSE;
}
#endif // !WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\factory.cpp ===
// --------------------------------------------------------------------------------
// FACTORY.CPP
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "factory.h"
#include "instance.h"
#include "header.h"
#include "ourguid.h"
#include "msgtable.h"
#include "envguid.h"
#include "istore.h"
#include "store.h"
#include "note.h"
#include "msoeobj.h"
#include "..\imap\imapsync.h"
#include "newsstor.h"
#include "msgfldr.h"
#include "store.h"
#include "..\http\httpserv.h"
#include <storsync.h>
#include <ruleutil.h>
#ifdef OE_MOM
#include "..\om\session.h"
#include "..\om\table.h"
#endif

// --------------------------------------------------------------------------------
// Pretty
// --------------------------------------------------------------------------------
#define OBJTYPE0        0
#define OBJTYPE1        OIF_ALLOWAGGREGATION

//HRESULT CreateInstance_StoreNamespace(IUnknown *pUnkOuter, IUnknown **ppUnknown);

// --------------------------------------------------------------------------------
// Global Object Info Table
// --------------------------------------------------------------------------------
#define PFCI(_pfn) ((PFCREATEINSTANCE)_pfn)
static CClassFactory g_rgFactory[] = {
    CClassFactory(&CLSID_MessageStore,      OBJTYPE0, PFCI(CreateMessageStore)),
    CClassFactory(&CLSID_MigrateMessageStore, OBJTYPE0, PFCI(CreateMigrateMessageStore)),
    CClassFactory(&CLSID_StoreNamespace,    OBJTYPE0, PFCI(CreateInstance_StoreNamespace)),
    CClassFactory(&CLSID_OEEnvelope,        OBJTYPE0, PFCI(CreateInstance_Envelope)),
    CClassFactory(&CLSID_OENote,            OBJTYPE0, PFCI(CreateOENote)),
    CClassFactory(&CLSID_MessageDatabase,   OBJTYPE0, PFCI(CreateMsgDbExtension)),    
    CClassFactory(&CLSID_FolderDatabase,    OBJTYPE0, PFCI(CreateFolderDatabaseExt)),    
#ifdef OE_MOM
    CClassFactory(&CLSID_OESession,         OBJTYPE1, PFCI(CreateInstance_OESession)),
    CClassFactory(&CLSID_OEMsgTable,        OBJTYPE1, PFCI(CreateInstance_OEMsgTable)),
#endif
    CClassFactory(&CLSID_OERulesManager,    OBJTYPE0, PFCI(HrCreateRulesManager)),
};
                 
// --------------------------------------------------------------------------------
// DllGetClassObject
// --------------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Trace
    TraceCall("DllGetClassObject");

    // Bad param
    if (ppv == NULL)
    {
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // Find Object Class
    for (i=0; i<ARRAYSIZE(g_rgFactory); i++)
    {
        // Compare for clsids
        if (IsEqualCLSID(rclsid, *g_rgFactory[i].m_pclsid))
        {
            // Delegate to the factory
            IF_FAILEXIT(hr = g_rgFactory[i].QueryInterface(riid, ppv));

            // Done
            goto exit;
        }
    }

    // Otherwise, let the ATL creator have a shot
    if (SUCCEEDED(hr = _Module.GetClassObject(rclsid, riid, ppv)))
        goto exit;

    // Otherwise, no class
    hr = TraceResult(CLASS_E_CLASSNOTAVAILABLE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::CClassFactory
// --------------------------------------------------------------------------------
CClassFactory::CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance)
    : m_pclsid(pclsid), m_dwFlags(dwFlags), m_pfCreateInstance(pfCreateInstance)
{
}

// --------------------------------------------------------------------------------
// CClassFactory::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    // TraceCall
    TraceCall("CClassFactory::QueryInterface");

    // Invalid Arg
    if (NULL == ppvObj)
        return TraceResult(E_INVALIDARG);

    // IClassFactory or IUnknown
    if (!IsEqualIID(riid, IID_IClassFactory) && !IsEqualIID(riid, IID_IUnknown))
        return TraceResult(E_INVALIDARG);

    // Return the Class Facotry
    *ppvObj = (LPVOID)this;

    // Add Ref the dll
    g_pInstance->DllAddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CClassFactory::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
    g_pInstance->DllAddRef();
    return 2;
}

// --------------------------------------------------------------------------------
// CClassFactory::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
    g_pInstance->DllRelease();
    return 1;
}

// --------------------------------------------------------------------------------
// CClassFactory::CreateInstance
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // Locals
    HRESULT         hr=S_OK;
    IUnknown       *pObject=NULL;

    // Trace
    TraceCall("CClassFactory::CreateInstance");

    // Bad param
    if (ppvObj == NULL)
        return TraceResult(E_INVALIDARG);

    // Init
    *ppvObj = NULL;

    // Verify that a controlling unknown asks for IUnknown
    if (NULL != pUnkOuter && IID_IUnknown != riid)
        return TraceResult(CLASS_E_NOAGGREGATION);

    // Can I do aggregaton
    if (pUnkOuter !=NULL && !(m_dwFlags & OIF_ALLOWAGGREGATION))  
        return TraceResult(CLASS_E_NOAGGREGATION);

    // Create the object...
    CHECKHR(hr = (*m_pfCreateInstance)(pUnkOuter, &pObject));

    // Aggregated, then we know we're looking for an IUnknown, return pObject, otherwise, QI
    if (pUnkOuter)
    {
        // Matches Release after Exit
        pObject->AddRef();

        // Return pObject::IUnknown
        *ppvObj = (LPVOID)pObject;
    }

    // Otherwise
    else
    {
        // Get the interface requested from pObj
        IF_FAILEXIT(hr = pObject->QueryInterface(riid, ppvObj));
    }
   
exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    Assert(FAILED(hr) ? NULL == *ppvObj : TRUE);
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::LockServer
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    return g_pInstance->LockServer(fLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\dllmain.cpp ===
// --------------------------------------------------------------------------
// DLLMAIN.CPP
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------
#include "pch.hxx"
#include "htmlstr.h"
#include "instance.h"
#include "conman.h"
#include "spengine.h"
#include "msglist.h"
#include "baui.h"
#include "wabapi.h"
#include "shared.h"
#include "rulesmgr.h"
#ifndef WIN16  //RUN16_MSLU
#include <msluapi.h>
#include <msluguid.h>
#endif //!WIN16
#include "demand.h"
#include "note.h"
#include "mirror.h"
// #ifdef _ATL_STATIC_REGISTRY
// #include <statreg.h>
// #include <statreg.cpp>
// #endif
#undef SubclassWindow
#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
HINSTANCE                       g_hLocRes = NULL;
HINSTANCE                       g_hInst=NULL;
LPMALLOC                        g_pMalloc=NULL;         // From memutil.h
CRITICAL_SECTION                g_csDBListen={0};
CRITICAL_SECTION                g_csgoCommon={0};
CRITICAL_SECTION                g_csgoMail={0};
CRITICAL_SECTION                g_csgoNews={0};
CRITICAL_SECTION                g_csFolderDlg={0};
CRITICAL_SECTION                g_csFmsg={0};
CRITICAL_SECTION                s_csPasswordList={0};
CRITICAL_SECTION                g_csAccountPropCache={0};
CRITICAL_SECTION                g_csMsgrList={0};
CRITICAL_SECTION                g_csThreadList={0};
COutlookExpress                *g_pInstance=NULL;
HWND                            g_hwndInit=NULL,
                                g_hwndActiveModal=NULL;
UINT                            g_msgMSWheel=0;
HACCEL                          g_haccelNewsView=0;
DWORD                           g_dwAthenaMode=0;
IImnAccountManager2            *g_pAcctMan=NULL;
HMODULE                         g_hlibMAPI=NULL;
CBrowser                       *g_pBrowser=NULL;
IMimeAllocator                 *g_pMoleAlloc=NULL;
CConnectionManager             *g_pConMan=NULL;
DWORD                           g_dwSecurityCheckedSchemaProp=0;
IFontCache                     *g_lpIFontCache=NULL;
ISpoolerEngine                 *g_pSpooler=NULL;
// bobn: brianv says we have to take this out...
//DWORD                           g_dwBrowserFlags=0;
UINT	                        CF_FILEDESCRIPTORA=0;
UINT	                        CF_FILEDESCRIPTORW=0;
UINT                            CF_FILECONTENTS=0;
UINT                            CF_HTML=0;
UINT                            CF_INETMSG=0;
UINT                            CF_OEFOLDER=0;
UINT                            CF_SHELLURL=0;
UINT                            CF_OEMESSAGES=0;
UINT                            CF_OESHORTCUT=0;
CStationery                    *g_pStationery=NULL;
ROAMSTATE                       g_rsRoamState=RS_NO_ROAMING;
IOERulesManager                *g_pRulesMan = NULL;
IMessageStore                  *g_pStore=NULL;
CRITICAL_SECTION                g_csFindFolder={0};
LPACTIVEFINDFOLDER              g_pHeadFindFolder=NULL;
DWORD                           g_dwTlsTimeout=0xFFFFFFFF;
BOOL                            g_fPluralIDs=0;
UINT                            g_uiCodePage=0;
IDatabaseSession               *g_pDBSession=NULL;
BOOL                            g_bMirroredOS=FALSE;
SYSTEM_INFO                     g_SystemInfo={0};
OSVERSIONINFO					g_OSInfo={0};

// --------------------------------------------------------------------------------
// Debug Trace Tags
// --------------------------------------------------------------------------------
IF_DEBUG(DWORD                  TAG_OBJECTDB=0;)
IF_DEBUG(DWORD                  TAG_INITTRACE=0;)
IF_DEBUG(DWORD                  TAG_SERVERQ=0;)
IF_DEBUG(DWORD                  TAG_IMAPSYNC=0;)

// --------------------------------------------------------------------------------
// global OE type-lib. Defer-created in BaseDisp.Cpp
// freed on process detach, protected with CS
// --------------------------------------------------------------------------------
ITypeLib                        *g_pOETypeLib=NULL;
CRITICAL_SECTION                g_csOETypeLib={0};


// --------------------------------------------------------------------------------
// Debug Globals
// --------------------------------------------------------------------------------
#ifdef DEBUG
DWORD                           dwDOUTLevel=0;          // From msoert.h
DWORD                           dwDOUTLMod=0;           // From msoert.h
DWORD                           dwDOUTLModLevel=0;      // From msoert.h
DWORD                           dwATLTraceLevel=0;      // From msoert.h
#endif

// Language DLL
// __declspec( dllimport )  HINSTANCE hLangDll;

// ATL Module Define
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_MessageList, CMessageList)
    OBJECT_ENTRY(CLSID_MsgrAb, CMsgrAb)
END_OBJECT_MAP()


// --------------------------------------------------------------------------------
// Dll Entry Point
// --------------------------------------------------------------------------------
extern "C" BOOL WINAPI DllMain(HANDLE hInst, DWORD dwReason, LPVOID lpReserved)
//extern "C" BOOL WINAPI DllMain(HANDLE hDllHandle, DWORD dwReason, LPVOID lpReserved);
{
    // Process Attach
    if (DLL_PROCESS_ATTACH == dwReason)
    {
         SHFusionInitialize(NULL);
        // Save hInstance
        g_hInst = (HINSTANCE)hInst;
        g_bMirroredOS = IS_MIRRORING_ENABLED();
        // We now want thread calls.
        // We don't care about thread attachs
        // SideAssert(DisableThreadLibraryCalls((HINSTANCE)hInst));

        // Get the OLE Task Memory Allocator
        CoGetMalloc(1, &g_pMalloc);
        AssertSz(g_pMalloc, "We are in trouble now.");        

        // Initialize Demand Loader
        InitDemandLoadedLibs();

        // Get System & OS Info
        GetPCAndOSTypes(&g_SystemInfo, &g_OSInfo);

        // Get Resources from Lang DLL
        g_hLocRes = LoadLangDll(g_hInst, c_szOEResDll, fIsNT5());
        if(g_hLocRes == NULL)
        {
            Assert(FALSE);
            return FALSE;
        }

        // Initialize TLS Globals
        InitTlsActiveNote();
        g_dwTlsTimeout = TlsAlloc();
        Assert(0xFFFFFFFF != g_dwTlsTimeout);
        TlsSetValue(g_dwTlsTimeout, NULL);

        // Initialize all global critical sections
        InitializeCriticalSection(&g_csFindFolder);
        InitializeCriticalSection(&g_csDBListen);
        InitializeCriticalSection(&g_csgoCommon);
        InitializeCriticalSection(&g_csgoMail);
        InitializeCriticalSection(&g_csgoNews);
        InitializeCriticalSection(&g_csFolderDlg);
        InitializeCriticalSection(&g_csFmsg);
        InitializeCriticalSection(&g_csOETypeLib);
        InitializeCriticalSection(&s_csPasswordList);
        InitializeCriticalSection(&g_csAccountPropCache);
        InitializeCriticalSection(&g_csMsgrList);
        InitializeCriticalSection(&g_csThreadList);
        // Initialize DOUTs
#ifdef DEBUG
        dwDOUTLevel = GetPrivateProfileInt("Debug", "Level", 0, "athena.ini");
        dwDOUTLMod = GetPrivateProfileInt("Debug", "Mod", 0, "athena.ini");
        dwDOUTLModLevel = GetPrivateProfileInt("Debug", "ModLevel", 0, "athena.ini");
        dwATLTraceLevel = GetPrivateProfileInt("ATL", "TraceLevel", 0, "athena.ini");
        TAG_OBJECTDB = GetDebugTraceTagMask("Database", TAG_OBJECTDB);
        TAG_INITTRACE = GetDebugTraceTagMask("CoIncrementTracing", TAG_INITTRACE);
        TAG_SERVERQ = GetDebugTraceTagMask("ServerQ", TAG_SERVERQ);
        TAG_IMAPSYNC = GetDebugTraceTagMask("IMAPSync", TAG_IMAPSYNC);
#endif
        // Initialize ATL module
        _Module.Init(ObjectMap, g_hInst);
        _Module.m_hInstResource = g_hLocRes;

        // Create Application Object (Don't initialize yet)
        g_pInstance = new COutlookExpress;
        AssertSz(g_pInstance, "We are in trouble now.");
    }

    // Thread Attach
    else if (DLL_THREAD_ATTACH == dwReason)
    {
        SetTlsGlobalActiveNote(NULL);
        TlsSetValue(g_dwTlsTimeout, NULL);
    }

    // Thread Attach
    else if (DLL_THREAD_DETACH == dwReason)
    {
        HWND hwndTimeout = (HWND)TlsGetValue(g_dwTlsTimeout);
        if (hwndTimeout && IsWindow(hwndTimeout))
            DestroyWindow(hwndTimeout);
        TlsSetValue(g_dwTlsTimeout, NULL);
    }

    // Process Detach
    else if (DLL_PROCESS_DETACH == dwReason)
    {
        // Free Type Lib
        SafeRelease(g_pOETypeLib);

        // Release Application
        SafeRelease(g_pInstance);

        // Free the ATL module
        _Module.Term();

        // Delete all global critical sections
        DeleteCriticalSection(&g_csgoCommon);
        DeleteCriticalSection(&g_csgoMail);
        DeleteCriticalSection(&g_csgoNews);
        DeleteCriticalSection(&g_csFolderDlg);
        DeleteCriticalSection(&g_csFmsg);
        DeleteCriticalSection(&g_csOETypeLib);
        DeleteCriticalSection(&s_csPasswordList);
        DeleteCriticalSection(&g_csAccountPropCache);
        DeleteCriticalSection(&g_csDBListen);
        DeleteCriticalSection(&g_csMsgrList);
        AssertSz(NULL == g_pHeadFindFolder, "Process is terminating with active finders running.");
        DeleteCriticalSection(&g_csFindFolder);
        DeleteCriticalSection(&g_csThreadList);

        // Free demand loaded libs
        FreeDemandLoadedLibs();

        // Free Timeout
        HWND hwndTimeout = (HWND)TlsGetValue(g_dwTlsTimeout);
        if (hwndTimeout && IsWindow(hwndTimeout))
            DestroyWindow(hwndTimeout);

        // Free TLS
        DeInitTlsActiveNote();
        if (0xFFFFFFFF != g_dwTlsTimeout)
            TlsFree(g_dwTlsTimeout);

        // Release the task allocator
        SafeRelease(g_pMalloc);

        // Free Resource Lib
        if (NULL != g_hLocRes)
            FreeLibrary(g_hLocRes);

        SHFusionUninitialize();

    }

    // Done
    return TRUE;
}

// --------------------------------------------------------------------------------
// DllCanUnloadNow
// --------------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    // If no instance, we can definately unload
    if (NULL == g_pInstance)
        return S_OK;

    // Otherwise, check with the instance object
    return g_pInstance->DllCanUnloadNow();
}

// --------------------------------------------------------------------------------
// RegTypeLib
// --------------------------------------------------------------------------------
__inline HRESULT RegTypeLib(HINSTANCE hInstRes)
{
    AssertSz(hInstRes,    "[ARGS] RegTypeLib: NULL hInstRes");
    
    HRESULT     hr = E_FAIL;
    CHAR        szDll[MAX_PATH];
    WCHAR       wszDll[MAX_PATH];

    GetModuleFileName(g_hInst, szDll, ARRAYSIZE(szDll));

    // Convert the module path to Wide-String
    if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szDll, -1, wszDll, ARRAYSIZE(wszDll)))
    {
        ITypeLib   *pTypeLib;

        hr = LoadTypeLib(wszDll, &pTypeLib);
        if (SUCCEEDED(hr))
        {
            // Register the typelib
            hr = RegisterTypeLib(pTypeLib, wszDll, NULL);
            pTypeLib->Release();
        }
    }

    return hr;
}

// --------------------------------------------------------------------------------
// DllRegisterServer
// --------------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    // CallRegInstall and RegTypeLib are in staticRT/shared.cpp
    return(CallRegInstall(g_hInst, g_hInst, c_szReg, NULL));
}

// --------------------------------------------------------------------------------
// DllUnregisterServer
// --------------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    return CallRegInstall(g_hInst, g_hInst, c_szUnReg, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\fidcpriv.h ===
////////////////////////////////////////////////////////////////////////
//
//  fidcpriv.h - private to implementation of FolderID Cache
//
////////////////////////////////////////////////////////////////////////

#ifndef _INC_FIDCPRIV_H
#define _INC_FIDCPRIV_H

class CEnumFidl : public IEnumIDList
{
public:
    // *** IUnknown methods ***
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // *** IEnumIDList methods ***
    HRESULT STDMETHODCALLTYPE Next(ULONG celt,LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    HRESULT STDMETHODCALLTYPE Skip(ULONG celt);
    HRESULT STDMETHODCALLTYPE Reset();
    HRESULT STDMETHODCALLTYPE Clone(IEnumIDList **ppenum);

//
// constructor/destructor
//
    CEnumFidl();
    ~CEnumFidl();
    HRESULT HrInit(int iFolderType, LPCFOLDERIDLIST pidl);

private:
    UINT            m_cRef;
    ULONG           m_cElt;
    LPFOLDERIDLIST *m_rgpidl;
    ULONG           m_ulEnumOffset;
};

#endif //_INC_FIDCPRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\factory.h ===
// --------------------------------------------------------------------------------
// Factory.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __FACTORY_H
#define __FACTORY_H

class CClassFactory; // Forward

// --------------------------------------------------------------------------------
// Object Flags
// --------------------------------------------------------------------------------
#define OIF_ALLOWAGGREGATION  0x0001

// --------------------------------------------------------------------------------
// Object Creation Prototypes
// --------------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFCREATEINSTANCE)(IUnknown *pUnkOuter, IUnknown **ppUnknown);

// --------------------------------------------------------------------------------
// InetComm ClassFactory
// --------------------------------------------------------------------------------
class CClassFactory : public IClassFactory
{
public:
    CLSID const        *m_pclsid;
    DWORD               m_dwFlags;
    PFCREATEINSTANCE    m_pfCreateInstance;

    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance);

    // ----------------------------------------------------------------------------
    // IUnknown members
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IClassFactory members
    // ----------------------------------------------------------------------------
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
};

#endif // __FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\init.h ===
/*
 *	i n i t . h
 *	
 *	Purpose:
 *		global init code for Athena
 *	
 *	Copyright (C) Microsoft Corp. 1993, 1994.
 */

#ifndef INIT_H
#define INIT_H

BOOL FCommonViewInit();
HRESULT HrMailInit(HWND hwnd);
BOOL Initialize_RunDLL(BOOL fMail);
void Uninitialize_RunDLL();
void DllDeInit();

#endif  //INIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\frntpage.h ===
/* *
   * Front Page IAthenaView implementation
   * 
   * Apr 97: EricAn
   */

#ifndef _FRNTPAGE_H
#define _FRNTPAGE_H

// for IAthenaView
#include "browser.h"

class CFrontBody;

/////////////////////////////////////////////////////////////////////////////
//
// Types 
//

/////////////////////////////////////////////////////////////////////////////
// 
// Exported functions
//

/////////////////////////////////////////////////////////////////////////////
//
// Global Exported Data
//

/////////////////////////////////////////////////////////////////////////////
//
// CCommonView
//

class CFrontPage :
    public IViewWindow,
    public IOleCommandTarget,
    public IMessageWindow
{
public:
    /////////////////////////////////////////////////////////////////////////
    //
    // OLE Interfaces
    //
    
    // IUnknown 
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    virtual ULONG   STDMETHODCALLTYPE AddRef(void);
    virtual ULONG   STDMETHODCALLTYPE Release(void);

    // IOleWindow
    HRESULT STDMETHODCALLTYPE GetWindow(HWND * lphwnd);                         
    HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL fEnterMode);            
                                                                             
    // IViewWindow
    HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG lpmsg);
    HRESULT STDMETHODCALLTYPE UIActivate(UINT uState);
    HRESULT STDMETHODCALLTYPE CreateViewWindow(IViewWindow  *lpPrevView, IAthenaBrowser * psb, 
                                               RECT * prcView, HWND * phWnd);
    HRESULT STDMETHODCALLTYPE DestroyViewWindow();
    HRESULT STDMETHODCALLTYPE SaveViewState();
    HRESULT STDMETHODCALLTYPE OnPopupMenu(HMENU hMenu, HMENU hMenuPopup, UINT uID);
    
    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                                     OLECMDTEXT *pCmdText); 
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                              VARIANTARG *pvaIn, VARIANTARG *pvaOut); 

    /////////////////////////////////////////////////////////////////////////
    // IMessageWindow
    //

    STDMETHOD(OnFrameWindowActivate)(THIS_ BOOL fActivate);
    STDMETHOD(GetCurCharSet)(THIS_ UINT *cp);
    STDMETHOD(UpdateLayout)(THIS_ BOOL fPreviewVisible, BOOL fPreviewHeader, 
                            BOOL fPreviewVert, BOOL fReload);
    STDMETHOD(GetMessageList)(THIS_ IMessageList ** ppMsgList) {return E_NOTIMPL;}
    
    //
    // Constructors, Destructors, and Initialization
    //
    CFrontPage();
    virtual ~CFrontPage();
    HRESULT HrInit(FOLDERID idFolder);

    /////////////////////////////////////////////////////////////////////////
    //
    // virtuals
    //
    
    /////////////////////////////////////////////////////////////////////////
    //
    // accessors
    //
//    LPITEMIDLIST   PidlRoot()   { return m_pidlRoot; }
//    LPFOLDERIDLIST Fidl()       { return m_fidl; }
    HWND           HwndOwner()  { return m_hwndOwner; }
    
private:
    BOOL    LoadBaseSettings();
    BOOL    SaveBaseSettings();

    /////////////////////////////////////////////////////////////////////////
    //
    // Callback Functions
    //
    // Note: All callbacks must be made static members to avoid having the 
    //       implicit "this" pointer passed as the first parameter.
    //
    static LRESULT CALLBACK FrontPageWndProc(HWND, UINT, WPARAM, LPARAM);
                                          
    /////////////////////////////////////////////////////////////////////////
    //
    // Message Handling
    //
    LRESULT WndProc(HWND, UINT, WPARAM, LPARAM);
    BOOL    OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void    OnSize(HWND hwnd, UINT state, int cxClient, int cyClient);
    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
    void    OnSetFocus(HWND hwnd, HWND hwndOldFocus);
    void    PostCreate();

    /////////////////////////////////////////////////////////////////////////
    //
    // Shell Interface Handling
    //
    BOOL    OnActivate(UINT uActivation);
    BOOL    OnDeactivate();

private:
    /////////////////////////////////////////////////////////////////////////
    // 
    // Private Data
    //

    /////////////////////////////////////////////////////////////////////////
    // Shell Stuff
    UINT                m_cRef;
    FOLDERID            m_idFolder;
    FOLDERTYPE          m_ftType;
    IAthenaBrowser     *m_pShellBrowser;
    BOOL                m_fFirstActive;
    UINT                m_uActivation;
    HWND                m_hwndOwner;                  // Owner window
    HWND                m_hwnd;                       // Our window
    HWND                m_hwndCtlFocus;               // Child control to set focus to
#ifndef WIN16  // No RAS support in Win16
    HMENU               m_hMenuConnect;
#endif
    
    /////////////////////////////////////////////////////////////////////////
    // Child support
    CFrontBody         *m_pBodyObj;
    IOleCommandTarget  *m_pBodyObjCT;
    CStatusBar         *m_pStatusBar;

    /////////////////////////////////////////////////////////////////////////
    // Language support
        
    /////////////////////////////////////////////////////////////////////////
    // Layout members
};

#endif // _FRNTPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\frntpage.cpp ===
/*
 *    frntpage.cpp                                                  
 *    
 *    Purpose:                     
 *        Implements the Front Page IAthenaView object
 *    
 *    Owner:
 *        EricAn
 *    
 *    Copyright (C) Microsoft Corp. 1997
 */
#include "pch.hxx"
#include "frntpage.h"
#include "resource.h"
#include "ourguid.h"
#include "thormsgs.h"
#include "goptions.h"
#include "strconst.h"
#include "frntbody.h"
#include "acctutil.h"
#include "newfldr.h"
#include <wininet.h>
#include <options.h>
#include <layout.h>
#include "finder.h"
#include <inetcfg.h>
#include "instance.h"
#include "storutil.h"
#include "menuutil.h"
#include "menures.h"
#include "statbar.h"

ASSERTDATA

/////////////////////////////////////////////////////////////////////////////
// 
// Macros
//

#define FPDOUT(x) DOUTL(DOUT_LEVEL4, x)

/////////////////////////////////////////////////////////////////////////////
//
// Global Data
//

static const TCHAR s_szFrontPageWndClass[] = TEXT("ThorFrontPageWndClass");

/////////////////////////////////////////////////////////////////////////////
// 
// Prototypes
//

/////////////////////////////////////////////////////////////////////////
//
// Constructors, Destructors, and Initialization
//

CFrontPage::CFrontPage()
{
    m_cRef = 1;
    m_idFolder = FOLDERID_INVALID;
    m_pShellBrowser = NULL;
    m_fFirstActive = FALSE;
    m_uActivation = SVUIA_DEACTIVATE;
    m_hwndOwner = NULL;
    m_hwnd = NULL;
    m_hwndCtlFocus = NULL;
    m_pBodyObj = NULL;
    m_pBodyObjCT = NULL;
#ifndef WIN16  // No RAS support in Win16
    m_hMenuConnect = 0;
#endif
    m_pStatusBar = NULL;
}

CFrontPage::~CFrontPage()
{
    SafeRelease(m_pShellBrowser);
    SafeRelease(m_pBodyObj);
    SafeRelease(m_pBodyObjCT);
    SafeRelease(m_pStatusBar);
#ifndef WIN16  // No RAS support in Win16
    if (m_hMenuConnect)
        g_pConMan->FreeConnectMenu(m_hMenuConnect);
#endif
}

HRESULT CFrontPage::HrInit(FOLDERID idFolder)
{
    WNDCLASS wc;

    if (!GetClassInfo(g_hInst, s_szFrontPageWndClass, &wc))
        {
        wc.style            = 0;
        wc.lpfnWndProc      = CFrontPage::FrontPageWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hIcon            = NULL;
        wc.hCursor          = NULL;
        wc.hbrBackground    = (HBRUSH)(COLOR_WINDOW + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = s_szFrontPageWndClass;
        if (RegisterClass(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
            return E_FAIL;
        }

    // Make copies of our pidls
    m_idFolder = idFolder;
    m_ftType = GetFolderType(m_idFolder);

    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////
//
// OLE Interfaces
//
    
////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CFrontPage::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IViewWindow *) this;
    else if (IsEqualIID(riid, IID_IViewWindow))
        *ppvObj = (void*) (IViewWindow *) this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (void*) (IOleCommandTarget *) this;
    else
        {
        *ppvObj = NULL;
        return E_NOINTERFACE;
        }

    AddRef();
    return NOERROR;
}

ULONG STDMETHODCALLTYPE CFrontPage::AddRef()
{
    DOUT(TEXT("CFrontPage::AddRef() - m_cRef = %d"), m_cRef + 1);
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CFrontPage::Release()
{
    DOUT(TEXT("CFrontPage::Release() - m_cRef = %d"), m_cRef - 1);
    if (--m_cRef == 0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

////////////////////////////////////////////////////////////////////////
//
//  IOleWindow
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CFrontPage::GetWindow(HWND * lphwnd)                         
{
    *lphwnd = m_hwnd;
    return (m_hwnd ? S_OK : E_FAIL);
}

HRESULT STDMETHODCALLTYPE CFrontPage::ContextSensitiveHelp(BOOL fEnterMode)            
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////
//
//  IAthenaView
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CFrontPage::TranslateAccelerator(LPMSG lpmsg)                
{
    // see if the body obj wants to snag it.
    if (m_pBodyObj && m_pBodyObj->HrTranslateAccelerator(lpmsg) == S_OK)
        return S_OK;

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CFrontPage::UIActivate(UINT uActivation)
{
    if (uActivation != SVUIA_DEACTIVATE)
        OnActivate(uActivation);
    else
        OnDeactivate();
    return NOERROR;
}

HRESULT STDMETHODCALLTYPE CFrontPage::CreateViewWindow(IViewWindow *lpPrevView, IAthenaBrowser *psb, 
                                                       RECT *prcView, HWND *phWnd)
{
    m_pShellBrowser = psb;
    Assert(m_pShellBrowser);
    m_pShellBrowser->AddRef();

    m_pShellBrowser->GetWindow(&m_hwndOwner);
    Assert(IsWindow(m_hwndOwner));

    // Load our registry settings
    LoadBaseSettings();
    
    m_hwnd = CreateWindowEx(WS_EX_CONTROLPARENT|WS_EX_CLIENTEDGE,
                            s_szFrontPageWndClass,
                            NULL,
                            WS_VISIBLE|WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS,
                            prcView->left,
                            prcView->top,
                            prcView->right - prcView->left,
                            prcView->bottom - prcView->top,
                            m_hwndOwner,
                            NULL,
                            g_hInst,
                            (LPVOID)this);

    if (!m_hwnd)
        return E_FAIL;

    *phWnd = m_hwnd;

    return NOERROR;
}

HRESULT STDMETHODCALLTYPE CFrontPage::DestroyViewWindow()                
{
    if (m_hwnd)
        {
        HWND hwndDest = m_hwnd;
        m_hwnd = NULL;
        DestroyWindow(hwndDest);
        }
    return NOERROR;
}

HRESULT STDMETHODCALLTYPE CFrontPage::SaveViewState()               
{
    // Save our registry settings
    SaveBaseSettings();
    return NOERROR;
}

//
//  FUNCTION:   CFrontPage::OnInitMenuPopup
//
//  PURPOSE:    Called when the user is about to display a menu.  We use this
//              to update the enabled or disabled status of many of the 
//              commands on each menu.
//
//  PARAMETERS:
//      hmenu       - Handle of the main menu.
//      hmenuPopup  - Handle of the popup menu being displayed.
//      uID         - Specifies the id of the menu item that 
//                    invoked the popup.
//
//  RETURN VALUE:
//      Returns S_OK if we process the message.
//
//
#define MF_ENABLEFLAGS(b)   (MF_BYCOMMAND|(b ? MF_ENABLED : MF_GRAYED|MF_DISABLED))
#define MF_CHECKFLAGS(b)    (MF_BYCOMMAND|(b ? MF_CHECKED : MF_UNCHECKED))

HRESULT CFrontPage::OnPopupMenu(HMENU hmenu, HMENU hmenuPopup, UINT uID)
{
    MENUITEMINFO mii;

    // give the docobj a chance to update its menu
    if (m_pBodyObj)
        m_pBodyObj->HrOnInitMenuPopup(hmenuPopup, uID);

    return S_OK;
}

HRESULT CFrontPage::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                                OLECMDTEXT *pCmdText)
{
    // Let MimeEdit have a crack at them
    if (m_pBodyObjCT)
    {
        m_pBodyObjCT->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
    }

    // handled
    return S_OK;
}


HRESULT CFrontPage::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt,
                         VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    // make sure that the 'go to inbox' check is consistent with what is in the options dlg
    // but we'll still let the browser actually handle the command
/*
    if (nCmdID == ID_OPTIONS)
    {
        if (m_ftType == FOLDER_ROOTNODE)
        {
            VARIANT_BOOL b;
            if (SUCCEEDED(m_pBodyObj->GetSetCheck(FALSE, &b)))
                SetDwOption(OPT_LAUNCH_INBOX, b ? TRUE : FALSE, m_hwnd, 0);
        }
    }
*/
    // check if the body wants to handle it
    if (m_pBodyObjCT && m_pBodyObjCT->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut) == NOERROR)
        return S_OK;

    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE CFrontPage::OnFrameWindowActivate(BOOL fActivate)
{
    return m_pBodyObj ? m_pBodyObj->HrFrameActivate(fActivate) : S_OK;
}

HRESULT STDMETHODCALLTYPE CFrontPage::GetCurCharSet(UINT *cp)
{
    *cp = GetACP();
    return (E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CFrontPage::UpdateLayout(THIS_ BOOL fPreviewVisible, 
                                                   BOOL fPreviewHeader, 
                                                   BOOL fPreviewVert, BOOL fReload)
{
    return (E_NOTIMPL);
}



////////////////////////////////////////////////////////////////////////
//
//  Message Handling
//
////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK CFrontPage::FrontPageWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT         lRet;
    CFrontPage     *pThis;

    if (msg == WM_NCCREATE)
        {
        pThis = (CFrontPage*)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);            
        }
    else
        pThis = (CFrontPage*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    Assert(pThis);

    return pThis->WndProc(hwnd, msg, wParam, lParam);
}

LRESULT CFrontPage::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fTip;

    switch (msg)
        {
        HANDLE_MSG(hwnd, WM_CREATE,         OnCreate);
        HANDLE_MSG(hwnd, WM_SIZE,           OnSize);
        HANDLE_MSG(hwnd, WM_NOTIFY,         OnNotify);
        HANDLE_MSG(hwnd, WM_SETFOCUS,       OnSetFocus);


        case WM_COMMAND:
            return SendMessage(m_hwndOwner, msg, wParam, lParam);
    
        case WM_MENUSELECT:
            HandleMenuSelect(m_pStatusBar, wParam, lParam);
            return 0;

        case NVM_INITHEADERS:
            PostCreate();
            return 0;
/*
        case CM_OPTIONADVISE:
            if ((wParam == OPT_LAUNCH_INBOX || wParam == 0xffffffff) && m_ftType == FOLDER_ROOTNODE)
                {
                VARIANT_BOOL b = DwGetOption(OPT_LAUNCH_INBOX) ? VARIANT_TRUE : VARIANT_FALSE;
                m_pBodyObj->GetSetCheck(TRUE, &b);
                }

        case WM_UPDATELAYOUT:
            m_pShellBrowser->GetViewLayout(DISPID_MSGVIEW_TIPOFTHEDAY, 0, &fTip, 0, 0);
            m_pBodyObj->ShowTip(fTip);
            return 0;
*/
        case WM_ACTIVATE:
            {
            HWND hwndFocus;
            DOUT("CFrontPage - WM_ACTIVATE(%#x)", LOWORD(wParam));
            m_pShellBrowser->UpdateToolbar();
            
            if (LOWORD(wParam) != WA_INACTIVE)
                {
                // DefWindowProc will set the focus to our view window, which
                // is not what we want.  Instead, we will let the explorer set
                // the focus to our view window if we should get it, at which
                // point we will set it to the proper control.
                return 0;
                }

            hwndFocus = GetFocus();
            if (IsChild(hwnd, hwndFocus))
                m_hwndCtlFocus = hwndFocus;
            else
                m_pBodyObj->HrGetWindow(&m_hwndCtlFocus);
            }
            break;
        
        case WM_CLOSE:
            // ignore CTRL-F4's
            return 0;        

        case WM_DESTROY:
            OptionUnadvise(hwnd);
            SafeRelease(m_pStatusBar);
            if (m_pBodyObj)
                {
                m_pBodyObj->HrUnloadAll(NULL, 0);
                m_pBodyObj->HrClose();
                }
            return 0;

#ifndef WIN16
        case WM_DISPLAYCHANGE:
#endif
        case WM_WININICHANGE:
        case WM_SYSCOLORCHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            if (m_pBodyObj)
                {
                HWND hwndBody;
                m_pBodyObj->HrGetWindow(&hwndBody);
                SendMessage(hwndBody, msg, wParam, lParam);
                }
            /* * * FALL THROUGH * * */

        case FTN_PRECHANGE:
        case FTN_POSTCHANGE:
            break;    

        default:
            if (g_msgMSWheel && (msg == g_msgMSWheel))
                {
                HWND hwndFocus = GetFocus();
                if (IsChild(hwnd, hwndFocus))
                    return SendMessage(hwndFocus, msg, wParam, lParam);
                }
            break;
        }
    
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//
//  FUNCTION:   CFrontPage::OnCreate
//
//  PURPOSE:    Creates the child windows necessary for the view and
//              initializes the data in those child windows.
//
//  PARAMETERS:
//      hwnd           - Handle of the view being created.
//      lpCreateStruct - Pointer to the creation params passed to 
//                       CreateWindow().
//
//  RETURN VALUE:
//      Returns TRUE if the initialization is successful.
//
BOOL CFrontPage::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    // register for option update notification
    SideAssert(SUCCEEDED(OptionAdvise(hwnd)));

    m_pBodyObj = new CFrontBody(m_ftType, m_pShellBrowser);
    if (!m_pBodyObj)
        goto error;

    if (FAILED(m_pBodyObj->HrInit(hwnd)))
        goto error;

    if (FAILED(m_pBodyObj->HrShow(FALSE)))
        goto error;

    return TRUE;

error:
    return FALSE;
}


//
//  FUNCTION:   CFrontPage::OnSize
//
//  PURPOSE:    Notification that the view window has been resized.  In
//              response we update the positions of our child windows and
//              controls.
//
//  PARAMETERS:
//      hwnd   - Handle of the view window being resized.
//      state  - Type of resizing requested.
//      cxClient - New width of the client area. 
//      cyClient - New height of the client area.
//
void CFrontPage::OnSize(HWND hwnd, UINT state, int cxClient, int cyClient)
{
    RECT rcBody, rcFldr;

    GetClientRect(hwnd, &rcBody);
    m_pBodyObj->HrSetSize(&rcBody);
}

//
//  FUNCTION:   CFrontPage::OnSetFocus
//
//  PURPOSE:    If the focus ever is set to the view window, we want to
//              make sure it goes to one of our child windows.  Preferably
//              the focus will go to the last child to have the focus.
//
//  PARAMETERS:
//      hwnd         - Handle of the view window.
//      hwndOldFocus - Handle of the window losing focus.
//
void CFrontPage::OnSetFocus(HWND hwnd, HWND hwndOldFocus)
{
    FPDOUT("CFrontPage - WM_SETFOCUS");

    // Check to see that we have a window stored to have focus.  If not
    // default to the message list.
    if (!m_hwndCtlFocus || !IsWindow(m_hwndCtlFocus) || m_hwndCtlFocus == m_hwndOwner)
        {
        m_pBodyObj->HrGetWindow(&m_hwndCtlFocus);
        }

    if (m_hwndCtlFocus && IsWindow(m_hwndCtlFocus))
        SetFocus(m_hwndCtlFocus);
}  

//
//  FUNCTION:   CFrontPage::OnNotify
//
//  PURPOSE:    Processes the various notifications we receive from our child
//              controls.
//
//  PARAMETERS:
//      hwnd    - Handle of the view window.
//      idCtl   - identifies the control sending the notification
//      pnmh    - points to a NMHDR struct with more information regarding the
//                notification
//
//  RETURN VALUE:
//      Dependant on the specific notification.
//
LRESULT CFrontPage::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    if (pnmhdr->code == NM_SETFOCUS)
        {
        // if we get a setfocus from a kid, and it's not the
        // body, be sure to UIDeactivate the body
        HWND    hwndBody = 0;

        m_pBodyObj->HrGetWindow(&hwndBody);
        if (pnmhdr->hwndFrom != hwndBody)
            m_pBodyObj->HrUIActivate(FALSE);
        m_pShellBrowser->OnViewWindowActive(this);
        }
    return 0;
}
    
BOOL CFrontPage::OnActivate(UINT uActivation)
{
    // if focus stays within the frame, but goes outside our view.
    // ie.. TreeView gets focus then we get an activate nofocus. Be sure
    // to UIDeactivate the docobj in this case
    if (uActivation == SVUIA_ACTIVATE_NOFOCUS)
        m_pBodyObj->HrUIActivate(FALSE);

    if (m_uActivation != uActivation)
        {
        OnDeactivate();
        m_uActivation = uActivation;
        
        SafeRelease(m_pStatusBar);
        m_pShellBrowser->GetStatusBar(&m_pStatusBar);
        if (m_pBodyObj)
            m_pBodyObj->HrSetStatusBar(m_pStatusBar);
        
        if (!m_fFirstActive)
            {
            PostMessage(m_hwnd, NVM_INITHEADERS, 0, 0L);
            m_fFirstActive = TRUE;
            }
        }
    return TRUE;
}

BOOL CFrontPage::OnDeactivate()
{    
    if (m_uActivation != SVUIA_DEACTIVATE)
        {
        m_uActivation = SVUIA_DEACTIVATE;
        if (m_pBodyObj)
            m_pBodyObj->HrSetStatusBar(NULL);
        }
    return TRUE;
}

BOOL CFrontPage::LoadBaseSettings()
{
    return TRUE;
}

BOOL CFrontPage::SaveBaseSettings()
{
    return TRUE;
}

void CFrontPage::PostCreate()
{
    Assert(m_pShellBrowser);

    m_pBodyObj->HrLoadPage();

    ProcessICW(m_hwndOwner, m_ftType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\instance.cpp ===
// --------------------------------------------------------------------------------
// INSTANCE.CPP
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "instance.h"
#include "acctutil.h"
#include "inetcfg.h"
#include <storfldr.h>
#include "zmouse.h"
#include "migrate.h"
#include <notify.h>
#include "conman.h"
#include "browser.h"
#include "note.h"
#include "reutil.h"
#include "spengine.h"
#include "addrobj.h"
#include "statnery.h"
#include "thumb.h"
#include "imagelst.h"
#include "url.h"
#include "secutil.h"
#include "shlwapip.h"
#include "ruleutil.h"
#include "newfldr.h"
#include "envfact.h"
#include "storutil.h"
#include "multiusr.h"
#include "newsstor.h"
#include "storutil.h"
#include <storsync.h>
#include "cleanup.h"
#include <grplist2.h>
#include <newsutil.h>
#include <sync.h>
#include "menures.h"
#include "shared.h"
#include "acctcach.h"
#include <inetreg.h>
#include <mapiutil.h>
#include "useragnt.h"
#include "demand.h"
#include <ieguidp.h>

static DWORD g_dwAcctAdvise = 0xffffffff;
DWORD g_dwHideMessenger = BL_DEFAULT;
extern BOOL g_fMigrationDone;
extern UINT GetCurColorRes(void);

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
void SimpleMAPICleanup(void); // smapi.cpp
BOOL DemandLoadMSOEACCT(void);
BOOL DemandLoadMSOERT2(void);
BOOL DemandLoadINETCOMM(void);

// --------------------------------------------------------------------------------
// Init Common Control Flags
// --------------------------------------------------------------------------------
#define ICC_FLAGS (ICC_WIN95_CLASSES|ICC_DATE_CLASSES|ICC_PAGESCROLLER_CLASS|ICC_USEREX_CLASSES|ICC_COOL_CLASSES|ICC_NATIVEFNTCTL_CLASS)

#ifdef DEBUG
// --------------------------------------------------------------------------------
// INITSOURCEINFO
// --------------------------------------------------------------------------------
typedef struct tagINITSOURCEINFO *LPINITSOURCEINFO;
typedef struct tagINITSOURCEINFO {
    LPSTR               pszSource;
    DWORD               cRefs;
    LPINITSOURCEINFO    pNext;
} INITSOURCEINFO;

static LPINITSOURCEINFO g_InitSourceHead=NULL;

#endif // DEBUG

// --------------------------------------------------------------------------------
// MAKEERROR
// --------------------------------------------------------------------------------
#define MAKEERROR(_pInfo, _nPrefixIds, _nErrorIds, _nReasonIds, _pszExtra1) \
    { \
        (_pInfo)->nTitleIds = idsAthena; \
        (_pInfo)->nPrefixIds = _nPrefixIds; \
        (_pInfo)->nErrorIds = _nErrorIds; \
        (_pInfo)->nReasonIds = _nReasonIds; \
        (_pInfo)->nHelpIds = IDS_ERROR_START_HELP; \
        (_pInfo)->pszExtra1 = _pszExtra1; \
        (_pInfo)->ulLastError = GetLastError(); \
    }

// --------------------------------------------------------------------------------
// CoStartOutlookExpress
// --------------------------------------------------------------------------------
MSOEAPI CoStartOutlookExpress(DWORD dwFlags, LPCWSTR pwszCmdLine, INT nCmdShow)
{
    // Tracing
    TraceCall("CoStartOutlookExpress");

    // Verify that we have an outlook express object
    Assert(g_pInstance);

    // E_OUTOFMEMORY
    if (NULL == g_pInstance)
    {
        // We should show an error, but the liklyhood of this happening is almost zero
        return TraceResult(E_OUTOFMEMORY);
    }

    // Run...
    return g_pInstance->Start(dwFlags, pwszCmdLine, nCmdShow);
}

// --------------------------------------------------------------------------------
// CoCreateOutlookExpress
// --------------------------------------------------------------------------------
MSOEAPI CoCreateOutlookExpress(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("CoCreateOutlookExpress");

    // Invalid Arg
    Assert(NULL != ppUnknown && NULL == pUnkOuter);

    // No global object yet ?
    AssertSz(g_pInstance, "This gets created in dllmain.cpp DllProcessAttach.");

    // Lets not crash
    if (NULL == g_pInstance)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // AddRef that badboy
    g_pInstance->AddRef();

    // Return the Innter
    *ppUnknown = SAFECAST(g_pInstance, IOutlookExpress *);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::COutlookExpress
// --------------------------------------------------------------------------------
COutlookExpress::COutlookExpress(void)
{
    // Trace
    TraceCall("COutlookExpress::COutlookExpress");

    // Init Members
    m_cRef = 1;
    m_hInstMutex = NULL;
    m_fPumpingMsgs = FALSE;
    m_cDllRef = 0;
    m_cDllLock = 0;
    m_cDllInit = 0;
    m_dwThreadId = GetCurrentThreadId();
    m_fSwitchingUsers = FALSE;
    m_szSwitchToUsername = NULL;
    m_hwndSplash        = NULL;
    m_pSplash           = NULL;
    m_fIncremented      = FALSE;
    m_hTrayIcon = 0;

    // Init Thread Safety
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// COutlookExpress::~COutlookExpress
// --------------------------------------------------------------------------------
COutlookExpress::~COutlookExpress(void)
{
    // Trace
    TraceCall("COutlookExpress::~COutlookExpress");

    // We should have been un-inited
    Assert(0 == m_cDllInit && 0 == m_cDllRef && 0 == m_cDllLock);

    // Free the mutex
    SafeCloseHandle(m_hInstMutex);

    // Kill CritSect
    DeleteCriticalSection(&m_cs);

    if(m_hTrayIcon)
    {
        DestroyIcon(m_hTrayIcon);
    }

    // Free the switch to if necessary
    if (m_szSwitchToUsername)
        MemFree(m_szSwitchToUsername);
}

// --------------------------------------------------------------------------------
// COutlookExpress::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP COutlookExpress::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Stack
    TraceCall("COutlookExpress::QueryInterface");

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IOutlookExpress == riid)
        *ppv = (IOutlookExpress *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COutlookExpress::AddRef(void)
{
    TraceCall("COutlookExpress::AddRef");
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// COutlookExpress::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COutlookExpress::Release(void)
{
    TraceCall("COutlookExpress::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// COutlookExpress::LockServer
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::LockServer(BOOL fLock)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("COutlookExpress::LockServer");

    if (TRUE == fLock)
    {
        InterlockedIncrement(&m_cDllLock);
    }
    else
    {
        InterlockedDecrement(&m_cDllLock);
    }
    
    // Trace
    //TraceInfo(_MSG("Lock: %d, CoIncrementInit Count = %d, Reference Count = %d, Lock Count = %d", fLock, m_cDllInit, m_cDllRef, m_cDllLock));

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// COutlookExpress::DllAddRef
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::DllAddRef(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("COutlookExpress::DllAddRef");

    // Thread Safety
    if (InterlockedIncrement(&m_cDllRef) <= 0)
    {
        // refcount already below zero
        hr = S_FALSE;
    }

    // Trace
    //TraceInfo(_MSG("CoIncrementInit Count = %d, Reference Count = %d, Lock Count = %d", m_cDllInit, m_cDllRef, m_cDllLock));

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::DllRelease
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::DllRelease(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("COutlookExpress::DllRelease");

    // Thread Safety
    if (InterlockedDecrement(&m_cDllRef) < 0)
    {
        // refcount already below zero
        hr = S_FALSE;
    }

    // Trace
    //TraceInfo(_MSG("CoIncrementInit Count = %d, Reference Count = %d, Lock Count = %d", m_cDllInit, m_cDllRef, m_cDllLock));

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// _CheckForJunkMail
// --------------------------------------------------------------------------------
void _CheckForJunkMail()
{
    HKEY hkey;
    DWORD dw=0, cb;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegRoot, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(dw);
        RegQueryValueEx(hkey, c_szRegJunkMailOn, 0, NULL, (LPBYTE)&dw, &cb);

        if (dw)
            g_dwAthenaMode |= MODE_JUNKMAIL;

        RegCloseKey(hkey);
    }

}


// --------------------------------------------------------------------------------
// COutlookExpress::Start
// --------------------------------------------------------------------------------
STDMETHODIMP COutlookExpress::Start(DWORD dwFlags, LPCWSTR pwszCmdLine, INT nCmdShow)
{
    // Locals
    HRESULT     hr=S_OK;
    MSG         msg;
    HWND        hwndTimeout;
    HINITREF    hInitRef=NULL;
    BOOL        fErrorDisplayed=FALSE;
    LPWSTR      pwszFree=NULL;
    LPWSTR      pwszCmdLineDup = NULL;

    // Stack
    TraceCall("COutlookExpress::Start");

    // Make sure OLE is initialized on the thread
    OleInitialize(NULL);

    // Duplicate It
    IF_NULLEXIT(pwszCmdLineDup = PszDupW(pwszCmdLine));

    // pwszCmdLineDup will change, remember the allocated block
    pwszFree = pwszCmdLineDup;

    //We want to process the switches set the mode flags before we call CoIncrementInit
    _ProcessCommandLineFlags(&pwszCmdLineDup, dwFlags);

    // AddRef the Dll..
    hr = CoIncrementInit("COutlookExpress", dwFlags, pwszCmdLine, &hInitRef);
    if (FAILED(hr))
    {
        fErrorDisplayed = TRUE;
        TraceResult(hr);
        goto exit;
    }

    // Process the Command Line..
    IF_FAILEXIT(hr = ProcessCommandLine(nCmdShow, pwszCmdLineDup, &fErrorDisplayed));

    // No splash screen
    CloseSplashScreen();

    // Do a CoDecrementInit
    IF_FAILEXIT(hr = CoDecrementInit("COutlookExpress", &hInitRef));

    // No need for a Message Pump ?
    if (S_OK == DllCanUnloadNow() || FALSE == ISFLAGSET(dwFlags, MSOEAPI_START_MESSAGEPUMP))
        goto exit;

    // Start the message Pump
    EnterCriticalSection(&m_cs);

    // Do we already have a pump running ?
    if (TRUE == m_fPumpingMsgs)
    {
        LeaveCriticalSection(&m_cs);
        goto exit;
    }

    // We are going to pump
    m_fPumpingMsgs = TRUE;

    // Thread Safety
    LeaveCriticalSection(&m_cs);
    SetSwitchingUsers(FALSE);

    // Message Loop
    while (GetMessageWrapW(&msg, NULL, 0, 0) && ((m_cDllInit > 0) || !SwitchingUsers()))
    {
        CNote *pNote = GetTlsGlobalActiveNote();

        // Ask it to translate an accelerator
        if (g_pBrowser && g_pBrowser->TranslateAccelerator(&msg) == S_OK)
            continue;

        // Hand message off to the active note, but ignore init window msgs and ignore per-task msgs where hwnd=0
        if (msg.hwnd != g_hwndInit && IsWindow(msg.hwnd))
        {
            pNote = GetTlsGlobalActiveNote();
            // Give it to the active note if a note has focus, call it's XLateAccelerator...
            if (pNote && pNote->TranslateAccelerator(&msg) == S_OK)
                continue;
        }

        // Get Timeout Window for this thread
        hwndTimeout = (HWND)TlsGetValue(g_dwTlsTimeout);

        // Check for Is modeless timeout dialog window message
        if (hwndTimeout && TRUE == IsDialogMessageWrapW(hwndTimeout, &msg))
            continue;

        // If Still not processed
        TranslateMessage(&msg);
        DispatchMessageWrapW(&msg);
    }

    // We are no longer pumping messages
    EnterCriticalSection(&m_cs);
    m_fPumpingMsgs = FALSE;
    LeaveCriticalSection(&m_cs);

    if(SwitchingUsers())
    {
        HrCloseWabWindow();
        while (PeekMessageWrapW(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessageWrapW(&msg);
        }
        MU_ResetRegRoot();
    }
exit:

    // Free command line copy
    SafeMemFree(pwszFree);

    // Do a CoDecrementInit
    CoDecrementInit("COutlookExpress", &hInitRef);

    // No splash screen
    CloseSplashScreen();
    
    // Is there an error ?
    if (FALSE == fErrorDisplayed && FAILED(hr) && 
        hrUserCancel != hr &&
        MAPI_E_USER_CANCEL != hr)
    {
        REPORTERRORINFO rError={0};
        
        MAKEERROR(&rError, 0, IDS_ERROR_UNKNOWN, 0, NULL);
        _ReportError(g_hLocRes, hr, 0, &rError);
    }

    //Bug #101360 - (erici) OleInitialize created a window, this destroys it.
    OleUninitialize();

    // Done
    return (SwitchingUsers() ? S_RESTART_OE : hr);
}

// --------------------------------------------------------------------------------
// COutlookExpress::_ReportError
// --------------------------------------------------------------------------------
BOOL COutlookExpress::_ReportError(
    HINSTANCE           hInstance,          // Dll Instance
    HRESULT             hrResult,           // HRESULT of the error
    LONG                lResult,            // LRESULT from like a registry function
    LPREPORTERRORINFO   pInfo)              // Report Error Information
{
    // Locals
    TCHAR       szRes[255],
                szMessage[1024],
                szTitle[128];

    // INit
    *szMessage = '\0';

    // Is there a prefix
    if (pInfo->nPrefixIds)
    {
        // Load the string
        LoadString(hInstance, pInfo->nPrefixIds, szMessage, ARRAYSIZE(szMessage));
    }

    // Error ?
    if (pInfo->nErrorIds)
    {
        // Are there extras in this error string
        if (NULL != pInfo->pszExtra1)
        {
            // Locals
            TCHAR szTemp[255];

            // Load and format
            LoadString(hInstance, pInfo->nErrorIds, szTemp, ARRAYSIZE(szTemp));

            // Format the string
            wsprintf(szRes, szTemp, pInfo->pszExtra1);
        }

        // Load the string
        else
        {
            // Load the error string
            LoadString(hInstance, pInfo->nErrorIds, szRes, ARRAYSIZE(szRes));
        }

        // Add to szMessage
        lstrcat(szMessage, g_szSpace);
        lstrcat(szMessage, szRes);
    }

    // Reason ?
    if (pInfo->nReasonIds)
    {
        // Load the string
        LoadString(hInstance, pInfo->nReasonIds, szRes, ARRAYSIZE(szRes));

        // Add to szMessage
        lstrcat(szMessage, g_szSpace);
        lstrcat(szMessage, szRes);
    }

    // Load the string
    LoadString(hInstance, pInfo->nHelpIds, szRes, ARRAYSIZE(szRes));

    // Add to szMessage
    lstrcat(szMessage, g_szSpace);
    lstrcat(szMessage, szRes);

    // Append Error Results
    if (lResult != 0 && E_FAIL == hrResult && pInfo->ulLastError)
        wsprintf(szRes, "(%d, %d)", lResult, pInfo->ulLastError);
    else if (lResult != 0 && E_FAIL == hrResult && 0 == pInfo->ulLastError)
        wsprintf(szRes, "(%d)", lResult);
    else if (pInfo->ulLastError)
        wsprintf(szRes, "(0x%08X, %d)", hrResult, pInfo->ulLastError);
    else
        wsprintf(szRes, "(0x%08X)", hrResult);

    // Add to szMessage
    lstrcat(szMessage, g_szSpace);
    lstrcat(szMessage, szRes);

    // Get the title
    LoadString(hInstance, pInfo->nTitleIds, szTitle, ARRAYSIZE(szTitle));

    // Show the error message
    MessageBox(NULL, szMessage, szTitle, MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);

    // Done
    return TRUE;
}

#ifdef DEAD
// --------------------------------------------------------------------------------
// COutlookExpress::_ValidateDll
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::_ValidateDll(LPCSTR pszDll, BOOL fDemandResult, HMODULE hModule,
    HRESULT hrLoadError, HRESULT hrVersionError, LPREPORTERRORINFO pError)
{
    // Locals
    HRESULT                 hr=S_OK;
    PFNGETDLLMAJORVERSION   pfnGetVersion;

    // Tracing
    TraceCall("COutlookExpress::_ValidateDll");

    // We must load these here in order to show errors and not crash - Load MSOERT2.DLL
    if (FALSE == fDemandResult)
    {
        MAKEERROR(pError, IDS_ERROR_PREFIX1, IDS_ERROR_MISSING_DLL, IDS_ERROR_REASON2, pszDll);
        hr = TraceResult(hrLoadError);
        goto exit;
    }

    // Try to get the current verion
    else
    {
        // Get Version Proc Address
        pfnGetVersion = (PFNGETDLLMAJORVERSION)GetProcAddress(hModule, STR_GETDLLMAJORVERSION);

        // Not the Correct Version
        if (NULL == pfnGetVersion || OEDLL_VERSION_CURRENT != (*pfnGetVersion)())
        {
            MAKEERROR(pError, IDS_ERROR_PREFIX1, IDS_ERROR_BADVER_DLL, IDS_ERROR_REASON2, pszDll);
            hr = TraceResult(hrVersionError);
            goto exit;
        }
    }

exit:
    // Done
    return hr;
}
#endif // DEAD

// --------------------------------------------------------------------------------
// COutlookExpress::CoIncrementInitDebug
// --------------------------------------------------------------------------------
#ifdef DEBUG
HRESULT COutlookExpress::CoIncrementInitDebug(LPCSTR pszSource, DWORD dwFlags, 
    LPCWSTR pwszCmdLine, LPHINITREF phInitRef)
{
    // Locals
    BOOL                fFound=FALSE;
    LPINITSOURCEINFO    pCurrent;

    // Trace
    TraceCall("COutlookExpress::CoIncrementInitDebug");

    // Invalid Args
    Assert(pszSource);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find Source
    for (pCurrent = g_InitSourceHead; pCurrent != NULL; pCurrent = pCurrent->pNext)
    {
        // Is this It ?
        if (lstrcmpi(pszSource, pCurrent->pszSource) == 0)
        {
            // Increment Reference Count
            pCurrent->cRefs++;

            // Found
            fFound = TRUE;

            // Done
            break;
        }
    }

    // Not Found, lets add one
    if (FALSE == fFound)
    {
        // Set pCurrent
        pCurrent = (LPINITSOURCEINFO)ZeroAllocate(sizeof(INITSOURCEINFO));
        Assert(pCurrent);

        // Set pszSource
        pCurrent->pszSource = PszDupA(pszSource);
        Assert(pCurrent->pszSource);

        // Set cRefs
        pCurrent->cRefs = 1;

        // Set Next
        pCurrent->pNext = g_InitSourceHead;
        
        // Set Head
        g_InitSourceHead = pCurrent;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Call the Actual CoIncrementInit
    return(CoIncrementInitImpl(dwFlags, pwszCmdLine, phInitRef));
}
#endif // DEBUG

// --------------------------------------------------------------------------------
// COutlookExpress::CoIncrementInitImpl
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::CoIncrementInitImpl(DWORD dwFlags, LPCWSTR pwszCmdLine, LPHINITREF phInitRef)
{
    // Locals
    HRESULT                 hr=S_OK;
    DWORD                   dw;
    RECT                    rc={0};
    HWND                    hwndDesk;
    DWORD                   dwSize;
    INITCOMMONCONTROLSEX    icex = { sizeof(icex), ICC_FLAGS };
    CImnAdviseAccount      *pImnAdviseAccount=NULL;
    WNDCLASSW               wcW;
    WNDCLASS                wc;
    DWORD                   dwType, dwVal, cb;
    REPORTERRORINFO         rError={0};
    LONG                    lResult=0;
    LPCWSTR                 pwszInitWndClass;
	BOOL					fReleaseMutex=FALSE;
    BOOL                    fResult;
    CHAR                    szFolder[MAX_PATH];
    IF_DEBUG(DWORD          dwTickStart=GetTickCount());

    // Tracing
    TraceCall("COutlookExpress::CoIncrementInitImpl");

    // Make sure OLE is initialized on the thread
    OleInitialize(NULL);
    
    // Thread Safety
    EnterCriticalSection(&m_cs);

	if (!SwitchingUsers() && !m_fIncremented)
    {
        SetQueryNetSessionCount(SESSION_INCREMENT_NODEFAULTBROWSERCHECK);
        m_fIncremented = TRUE;
    }

    // Increment Reference Count
    m_cDllInit++;

    // Set phInitRef
    if (phInitRef)
        *phInitRef = (HINITREF)((ULONG_PTR)m_cDllInit);

    // First-Time Reference
    if (m_cDllInit > 1)
    {
        LeaveCriticalSection(&m_cs);
        return S_OK;
    }

    // Leave CS (This code always runs on the same primary thread
    LeaveCriticalSection(&m_cs);

    if (FAILED(hr = MU_Init(ISFLAGSET(dwFlags, MSOEAPI_START_DEFAULTIDENTITY))))
        goto exit;

    // Is there more than one identity?
    g_fPluralIDs = 1 < MU_CountUsers();

    if (!MU_Login(GetDesktopWindow(), FALSE, NULL))
    {
        hr = hrUserCancel;
        goto exit;
    }

    // Create the instance mutex
    if (NULL == m_hInstMutex)
    {
        m_hInstMutex = CreateMutex(NULL, FALSE, STR_MSOEAPI_INSTANCEMUTEX);
        if (NULL == m_hInstMutex)
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_CREATE_INSTMUTEX, IDS_ERROR_REASON1, NULL);
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }
    }

    // Release m_hInstMutex if it is currently owned by this thread, allow new instances to start.
    if (FALSE == ISFLAGSET(dwFlags, MSOEAPI_START_INSTANCEMUTEX))
    {
        // Lets grab the mutex ourselves
        WaitForSingleObject(m_hInstMutex, INFINITE);
    }

    // Release the mutex
    fReleaseMutex = TRUE;

    // Must init thread on primary instnance thread

    // If the thread id is zero, then we have uninitialized everything.
    // Which means we need to re-initialize everything
    if (0 == m_dwThreadId)
    {
        m_dwThreadId = GetCurrentThreadId();
    }
    
    AssertSz(m_dwThreadId == GetCurrentThreadId(), "We are not doing first CoIncrementInit on the thread in which g_pInstance was created on.");

    // Set g_dwAthenaMode
    _CheckForJunkMail();

    // Get MimeOle IMalloc Interface
    if (NULL == g_pMoleAlloc)
    {
        hr = MimeOleGetAllocator(&g_pMoleAlloc);
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_MIMEOLE_ALLOCATOR, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
            goto exit;
        }
    }

    // Set OE5 mode for INetcomm.
    MimeOleSetCompatMode(MIMEOLE_COMPAT_MLANG2);

    // Create the Database Session Object
    if (NULL == g_pDBSession)
    {
        hr = CoCreateInstance(CLSID_DatabaseSession, NULL, CLSCTX_INPROC_SERVER, IID_IDatabaseSession, (LPVOID *)&g_pDBSession); 
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_OPEN_STORE, IDS_ERROR_REASON1, NULL);
            goto exit;
        }
    }

    // all migration and upgrade happens in here now.
    hr = MigrateAndUpgrade();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Only if there is a command line...
    if (pwszCmdLine)
    {
        LPSTR pszCmdLine = NULL;
        // If this returns S_OK, we have launched the first-run ICW exe and we need to go away. 
        // this is consistent with IE and forces the user to deal with the ICW before partying with us.
        IF_NULLEXIT(pszCmdLine = PszToANSI(CP_ACP, pwszCmdLine));

        hr = NeedToRunICW(pszCmdLine);
        
        MemFree(pszCmdLine);

        if (hr == S_OK)
        {
            hr = hrUserCancel;
            goto exit;
        }

        // If that failed, time to show an error message
        else if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_FIRST_TIME_ICW, IDS_ERROR_REASON2, NULL);
            hr = TraceResult(hr);
            goto exit;
        }
    }

    // Create WNDCLASS for Primary Outlook Express hidden window
    if (ISFLAGSET(dwFlags, MSOEAPI_START_APPWINDOW))
        pwszInitWndClass = STRW_MSOEAPI_INSTANCECLASS;
    else
        pwszInitWndClass = STRW_MSOEAPI_IPSERVERCLASS;

    // Register the init window
    if (FALSE == GetClassInfoWrapW(g_hInst, pwszInitWndClass, &wcW))
    {
        ZeroMemory(&wcW, sizeof(wcW));
        wcW.lpfnWndProc = COutlookExpress::InitWndProc;
        wcW.hInstance = g_hInst;
        wcW.lpszClassName = pwszInitWndClass;
        if (FALSE == RegisterClassWrapW(&wcW))
        {
            // In this case, we are in an error condition so don't care if PszToANSI fails.
            LPSTR pszInitWndClass = PszToANSI(CP_ACP, pwszInitWndClass);
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_REG_WNDCLASS, IDS_ERROR_REASON1, pszInitWndClass);
            MemFree(pszInitWndClass);
            hr = TraceResult(E_FAIL);
            goto exit;
        }
    }

    // Create the OutlookExpressHiddenWindow
    if (NULL == g_hwndInit)
    {
        g_hwndInit = CreateWindowExWrapW(WS_EX_TOPMOST, pwszInitWndClass, pwszInitWndClass,
                                    WS_POPUP, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,
                                    NULL, NULL, g_hInst, NULL);
        if (NULL == g_hwndInit)
        {
            // In this case, we are in an error condition so don't care if PszToANSI fails.
            LPSTR pszInitWndClass = PszToANSI(CP_ACP, pwszInitWndClass);
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_REG_WNDCLASS, IDS_ERROR_REASON1, pszInitWndClass);
            MemFree(pszInitWndClass);
            hr = TraceResult(E_FAIL);
            goto exit;
        }
    }

    // CoIncrementInit Global Options Manager
    if (FALSE == InitGlobalOptions(NULL, NULL))
    {
        MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_INIT_GOPTIONS, IDS_ERROR_REASON1, NULL);
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Prompt the user for a store location, if we don't have one already
    hr = InitializeLocalStoreDirectory(NULL, FALSE);
    if (hrUserCancel == hr || FAILED(hr))
    {   
        // If not user cancel, then must be another error
        if (hrUserCancel != hr)
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_INITSTORE_DIRECTORY, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
        }

        // Done
        goto exit;
    }

    // This needs to stay in since the Intl guys want a way to work around people who aren't going to upgrade to the latest ATOK11.
    if (ISFLAGSET(dwFlags, MSOEAPI_START_SHOWSPLASH) && 0 == DwGetOption(OPT_NO_SPLASH)
        && ((g_dwAthenaMode & MODE_OUTLOOKNEWS) != MODE_OUTLOOKNEWS))
    {
        // Create me a splash screen
        hr = CoCreateInstance(CLSID_IESplashScreen, NULL, CLSCTX_INPROC_SERVER, IID_ISplashScreen, (LPVOID *)&m_pSplash);

        // If that worked, heck, lets show it
        if (SUCCEEDED(hr))
        {
            HDC hdc = GetDC(NULL);
            m_pSplash->Show(g_hLocRes, ((GetDeviceCaps(hdc, BITSPIXEL) > 8) ? idbSplashHiRes : idbSplash256), idbSplashLoRes, &m_hwndSplash);
            ReleaseDC(NULL, hdc);
        }

        // Trace
        else
            TraceResultSz(hr, "CoCreateInstance(CLSID_IESplashScreen, ...) failed, but who cares.");

        // Everything is good
        hr = S_OK;
    }

    cb = sizeof(dw);
    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, c_szRegFlat, c_szHideMessenger, &dwType, (LPBYTE)&dw, &cb))
        dw = 0xffffffff;
    cb = sizeof(dwVal);
    if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, c_szRegFlat, c_szHideMessenger, &dwType, (LPBYTE)&dwVal, &cb))
        dwVal = 0xffffffff;
    if (dw != 0xffffffff && dwVal != 0xffffffff)
        g_dwHideMessenger = max(dw, dwVal);
    else if (dw != 0xffffffff)
        g_dwHideMessenger = dw;
    else if (dwVal != 0xffffffff)
        g_dwHideMessenger = dwVal;
    else
        g_dwHideMessenger = BL_DEFAULT;

    // IntelliMouse support
    g_msgMSWheel = RegisterWindowMessage(TEXT(MSH_MOUSEWHEEL));
    AssertSz(g_msgMSWheel, "RegisterWindowMessage for the IntelliMouse failed, we can still continue.");
            
    // Create WNDCLASS for ThumbNail
    if (FALSE == GetClassInfo(g_hLocRes, WC_THUMBNAIL, &wc))
    {
        ZeroMemory(&wc, sizeof(wc));
        wc.lpfnWndProc = (WNDPROC)ThumbNailWndProc;
        wc.hInstance = g_hLocRes;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.lpszClassName = WC_THUMBNAIL;
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        if (FALSE == RegisterClass(&wc))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_REG_WNDCLASS, IDS_ERROR_REASON1, WC_THUMBNAIL);
            hr = TraceResult(E_FAIL);
            goto exit;
        }
    }

    // Get the desktop Window
    hwndDesk = GetDesktopWindow();
    AssertSz(hwndDesk, "GetDesktopWindow returned NULL. We should be ok, I hope.");
    if (hwndDesk)
    {
        // Get the size of the desktop window
        GetWindowRect(hwndDesk, &rc);

        // sungr: following is a hack to avoid the fullscreen app detection hack that user does to modify the top-most state of the tray.
        rc.left += 20;
        rc.top  += 20;
        rc.bottom -= 20;
        rc.right  -= 20;
    }

    // Test to see if we should move the store 
    cb = ARRAYSIZE(szFolder);
    if (ERROR_SUCCESS == AthUserGetValue(NULL, c_szNewStoreDir, &dwType, (LPBYTE)szFolder, &cb))
    {
        DWORD dwMoveStore = 0;
        DWORD cb = sizeof(dwMoveStore);

        AthUserGetValue(NULL, c_szMoveStore, NULL, (LPBYTE)&dwMoveStore, &cb);
        
        if (SUCCEEDED(RelocateStoreDirectory(g_hwndInit, szFolder, (dwMoveStore != 0))))
        {
            AthUserDeleteValue(NULL, c_szNewStoreDir);
            AthUserDeleteValue(NULL, c_szMoveStore);
        }
    }

    // CoIncrementInit Common Controls Library
    InitCommonControlsEx(&icex);

    // Create account manger
    if (NULL == g_pAcctMan)
    {
        hr = AcctUtil_CreateAccountManagerForIdentity(PGUIDCurrentOrDefault(), &g_pAcctMan);
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_CREATE_ACCTMAN, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
            goto exit;
        }

        pImnAdviseAccount = new CImnAdviseAccount();
        if (NULL == pImnAdviseAccount)
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_ALLOC_ACCTADVISE, IDS_ERROR_REASON1, NULL);
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }
        
        hr = pImnAdviseAccount->Initialize();
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_INIT_ACCTADVISE, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
            goto exit;
        }

        // Register Advise sink
        Assert(g_dwAcctAdvise == 0xffffffff);
        hr = g_pAcctMan->Advise(pImnAdviseAccount, &g_dwAcctAdvise);
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_ADVISE_ACCTMAN, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
            goto exit;
        }
    }

    // Create the rules manager
    if (NULL == g_pRulesMan)
    {
        hr = HrCreateRulesManager(NULL, (IUnknown **)&g_pRulesMan); 
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, idsErrorCreateRulesMan, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
            goto exit;
        }

        // CoIncrementInit the account manager
        hr = g_pRulesMan->Initialize(0);
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, idsErrorInitRulesMan, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
            goto exit;
        }
    }

    // Create the global connection manager
    if (NULL == g_pConMan)
    {
        g_pConMan = new CConnectionManager();
        if (NULL == g_pConMan)
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_ALLOC_CONMAN, IDS_ERROR_REASON1, NULL);
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        // CoIncrementInit the Connection Manager
        hr = g_pConMan->HrInit(g_pAcctMan);
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_INIT_CONMAN, IDS_ERROR_REASON1, NULL);
            TraceResult(hr);
            goto exit;
        }
    }

    // Initialize the HTTP user agent
    InitOEUserAgent(TRUE);

    // Create the Spooler Object
    if (NULL == g_pSpooler)
    {
        hr = CreateThreadedSpooler(NULL, &g_pSpooler, TRUE);
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_CREATE_SPOOLER, IDS_ERROR_REASON1, NULL);
            hr = TraceResult(hr);
            goto exit;
        }
    }

    // Create the Font Cache Object
    if (NULL == g_lpIFontCache)
    {
        hr = CoCreateInstance(CLSID_IFontCache, NULL, CLSCTX_INPROC_SERVER, IID_IFontCache, (LPVOID *)&g_lpIFontCache); 
        if (FAILED(hr))
        {
            MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_CREATE_FONTCACHE, IDS_ERROR_REASON1, NULL);
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }
        hr = g_lpIFontCache->Init(MU_GetCurrentUserHKey(), c_szRegInternational, 0);
        Assert(SUCCEEDED(hr));
    }

    // Create the Global Store Object
    hr = InitializeStore(dwFlags);
    if (FAILED(hr))
    {
        MAKEERROR(&rError, IDS_ERROR_PREFIX1, IDS_ERROR_OPEN_STORE, IDS_ERROR_REASON1, NULL);
        goto exit;
    }

    DoNewsgroupSubscribe();

    if (NULL == g_pSync)
    {
        g_pSync = new COfflineSync;
        if (NULL == g_pSync)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        hr = g_pSync->Initialize();
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

    // Start Background Compaction in XX Seconds
    if (DwGetOption(OPT_BACKGROUNDCOMPACT))
        SideAssert(SUCCEEDED(StartBackgroundStoreCleanup(30)));

    // CoIncrementInit Drag Drop Information
    if (0 == CF_FILEDESCRIPTORA)
    {
        CF_FILEDESCRIPTORA = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORA);
        CF_FILEDESCRIPTORW = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);
        CF_FILECONTENTS = RegisterClipboardFormat(CFSTR_FILECONTENTS);
        CF_HTML = RegisterClipboardFormat(CFSTR_HTML);
        CF_INETMSG = RegisterClipboardFormat(CFSTR_INETMSG);
        CF_OEFOLDER = RegisterClipboardFormat(CFSTR_OEFOLDER);
        CF_SHELLURL = RegisterClipboardFormat(CFSTR_SHELLURL);
        CF_OEMESSAGES = RegisterClipboardFormat(CFSTR_OEMESSAGES);
        CF_OESHORTCUT = RegisterClipboardFormat(CFSTR_OESHORTCUT);
    }

    // Get the current default codepage
    cb = sizeof(dwVal);
    if (ERROR_SUCCESS == SHGetValue(MU_GetCurrentUserHKey(), c_szRegInternational, REGSTR_VAL_DEFAULT_CODEPAGE, &dwType, &dwVal, &cb))
        g_uiCodePage = (UINT)dwVal;

    // CoIncrementInit the Wab on first run
    cb = sizeof(dwVal);
    if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, c_szNewWABKey, c_szFirstRunValue, &dwType, &dwVal, &cb))
        HrInitWab(TRUE);

    //This call could fail if the registry gets trashed, but do we want an error box?
    //According to takos, no...we do not.
    HGetDefaultCharset(NULL);
   
exit:
    // Is there an error ?
    if (hrUserCancel != hr && ISFLAGSET(dwFlags, MSOEAPI_START_SHOWERRORS) && (FAILED(hr) || ERROR_SUCCESS != lResult))
    {
        // If ulError is zero, lets set it to a default
        if (0 == rError.nErrorIds)
            MAKEERROR(&rError, 0, IDS_ERROR_UNKNOWN, 0, NULL);

        // Report the Error
        _ReportError(g_hLocRes, hr, lResult, &rError);
    }

    // Release the mutex and signal the caller initialization is done
    if (fReleaseMutex)
        SideAssert(FALSE != ReleaseMutex(m_hInstMutex));

    // Trace
    //TraceInfo(_MSG("CoIncrementInit Count = %d, Reference Count = %d, Lock Count = %d", m_cDllInit, m_cDllRef, m_cDllLock));

    // Cleanup
    SafeRelease(pImnAdviseAccount);

    // If we failed, decrement the reference count
    if (FAILED(hr))
    {
        CloseSplashScreen();
        CoDecrementInit("COutlookExpress", phInitRef);
    }
    else
        Assert(g_pAcctMan);

    // Time To Crank
    TraceInfo(_MSG("Startup Time: %d", GetTickCount() - dwTickStart));

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::CloseSplashScreen
// --------------------------------------------------------------------------------
void COutlookExpress::CloseSplashScreen(void)
{
    // Kill the splash screen
    if (m_pSplash)
    {
        m_pSplash->Dismiss();
        m_pSplash->Release();
        m_pSplash = NULL;

        // HACKHACKHACK
        // This is needed because the splash screen might still be around after we
        // free up OLE.
        if (FALSE != IsWindow(m_hwndSplash))
        {
            SendMessage(m_hwndSplash, WM_CLOSE, 0, 0);
        }
    }
}

// --------------------------------------------------------------------------------
// COutlookExpress::CoDecrementInitDebug
// --------------------------------------------------------------------------------
#ifdef DEBUG
HRESULT COutlookExpress::CoDecrementInitDebug(LPCSTR pszSource, LPHINITREF phInitRef)
{
    // Locals
    BOOL                fFound=FALSE;
    LPINITSOURCEINFO    pCurrent;
    LPINITSOURCEINFO    pPrevious=NULL;

    // Trace
    TraceCall("COutlookExpress::CoDecrementInitDebug");

    // Invalid Args
    Assert(pszSource);

    // Do I need to do this
    if (NULL == phInitRef || NULL != *phInitRef)
    {
        // Thread Safety
        EnterCriticalSection(&m_cs);

        // Find Source
        for (pCurrent = g_InitSourceHead; pCurrent != NULL; pCurrent = pCurrent->pNext)
        {
            // Is this It ?
            if (lstrcmpi(pszSource, pCurrent->pszSource) == 0)
            {
                // Increment Reference Count
                pCurrent->cRefs--;

                // Found
                fFound = TRUE;

                // No More Reference Counts ?
                if (0 == pCurrent->cRefs)
                {
                    // Previous ?
                    if (pPrevious)
                        pPrevious->pNext = pCurrent->pNext;
                    else
                        g_InitSourceHead = pCurrent->pNext;

                    // Free pszSource
                    g_pMalloc->Free(pCurrent->pszSource);

                    // Free pCurrent
                    g_pMalloc->Free(pCurrent);
                }

                // Done
                break;
            }

            // Set Previous
            pPrevious = pCurrent;
        }

        // Not Found, lets add one
        Assert(fFound);

        // TraceInfoTag
        TraceInfoTag(TAG_INITTRACE, "********** CoDecrementInit **********");

        // Find Source
        for (pCurrent = g_InitSourceHead; pCurrent != NULL; pCurrent = pCurrent->pNext)
        {
            // TraceInfoTag
            TraceInfoTag(TAG_INITTRACE, _MSG("Source: %s, Refs: %d", pCurrent->pszSource, pCurrent->cRefs));
        }

        // Thread Safety
        LeaveCriticalSection(&m_cs);
    }

    // Call Actual
    return(CoDecrementInitImpl(phInitRef));
}
#endif // DEBUG

// --------------------------------------------------------------------------------
// COutlookExpress::CoDecrementInitImpl
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::CoDecrementInitImpl(LPHINITREF phInitRef)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("COutlookExpress::CoDecrementInitImpl");

    // If *phInitRef = NULL, then we should no do the CoDecrementInit
    if (phInitRef && NULL == *phInitRef)
    {
        hr = S_OK;
        goto exit;
    }


    // We must de-init on the same thread that we were created on...
    if (m_dwThreadId != GetCurrentThreadId() && g_hwndInit && IsWindow(g_hwndInit))
    {
        // Thunk the shutdown to the correct thread
        hr = (HRESULT) SendMessage(g_hwndInit, ITM_SHUTDOWNTHREAD, 0, (LPARAM)phInitRef);        
    }
    else
    {
        // Forward everything off to the main function
        hr = _CoDecrementInitMain(phInitRef);        
    }

    if (!SwitchingUsers() && m_fIncremented && (m_cDllInit == 0))
    {
		SetQueryNetSessionCount(SESSION_DECREMENT);
        m_fIncremented = FALSE;
    }

    // Uninitialize Ole
    OleUninitialize();
        
exit:
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::_CoDecrementInitMain
//
// NOTE:  We assume that we already have the critical section before this call
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::_CoDecrementInitMain(LPHINITREF phInitRef)
{
    // Stack
    TraceCall("COutlookExpress::_CoDecrementInitMain");

    // If *phInitRef = NULL, then we should no do the CoDecrementInit
    if (phInitRef && NULL == *phInitRef)
        return S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // This should never happen. It could only happen if g_hwndInit was NULL.
    AssertSz(m_dwThreadId == GetCurrentThreadId(), "We are not doing the last CoDecrementInit on the thread in which g_pInstance was created on.");

    // Release
    Assert(m_cDllInit);
    m_cDllInit--;

    // Not hit zero yet ?
    if (m_cDllInit > 0)
    {
        LeaveCriticalSection(&m_cs);
        goto exit;
    }

    // Leave Critical Section
    LeaveCriticalSection(&m_cs);

    // Validate
    Assert(NULL == g_InitSourceHead);

    // Take ownership of the mutex to block people from creating new insts while shutting down
    WaitForSingleObject(m_hInstMutex, INFINITE);

    // Cleanup the Trident data for this thread

    //g_hLibMAPI
    if (g_hlibMAPI)
    {
        FreeLibrary(g_hlibMAPI);
        g_hlibMAPI = 0;
    }

    // Make sure we remove our new mail notification from the tray
    UpdateTrayIcon(TRAYICONACTION_REMOVE);

    // Close Background Compaction
    SideAssert(SUCCEEDED(CloseBackgroundStoreCleanup()));

    // Kill the Spooler
    if (g_pSpooler)
    {
        CloseThreadedSpooler(g_pSpooler);
        g_pSpooler = NULL;
    }

    // de-init the http user agent
    InitOEUserAgent(FALSE);

    // A bunch of de-init things
    FInitRichEdit(FALSE);
    Note_Init(FALSE);
    Envelope_FreeGlobals();

    // Make sure next identity can migrate
    g_fMigrationDone = FALSE;

    // De-initialize Multilanguage menu
    DeinitMultiLanguage();

    // Deinit Stationery
    if (g_pStationery)
    {
        // Save the current list
        g_pStationery->SaveStationeryList();

        // Release the object
        SideAssert(0 == g_pStationery->Release());

        // Lets not free it again
        g_pStationery = NULL;
    }

    // Release the font cache
    SafeRelease(g_lpIFontCache);

    // Simple MAPI Cleanup
#ifndef WIN16
    SimpleMAPICleanup();
#endif

    // Kill the Wab
    HrInitWab(FALSE);

/*
We shouldn't have to do this anymore. This should be handled by IE when we decrement the session count
#ifndef WIN16   // No RAS support in Win16
    if (g_pConMan && g_pConMan->IsRasLoaded() && g_pConMan->IsConnected())
        g_pConMan->Disconnect(g_hwndInit, TRUE, FALSE, TRUE);
#endif
*/

    // Image Lists
    FreeImageLists();

    // Kill the account manager
    if (g_pAcctMan)
    {
        CleanupTempNewsAccounts();

        if (g_dwAcctAdvise != 0xffffffff)
            {
            g_pAcctMan->Unadvise(g_dwAcctAdvise);
            g_dwAcctAdvise = 0xffffffff;
            }

        g_pAcctMan->Release();
        g_pAcctMan = NULL;
    }
    Assert(g_dwAcctAdvise == 0xffffffff);

    SafeRelease(g_pSync);

#ifndef WIN16   // No RAS support in Win16
    SafeRelease(g_pConMan);
#endif

    // Kill the rules manager
    SafeRelease(g_pRulesMan);

    // Take down the password cache
    DestroyPasswordList();

    // free the account data cache
    FreeAccountPropCache();

    // MIMEOLE Allocator
    SafeRelease(g_pMoleAlloc);

    // Kill g_hwndInit
    if (g_hwndInit)
    {
        SendMessage(g_hwndInit, WM_CLOSE, (WPARAM) 0, (LPARAM) 0);
        g_hwndInit = NULL;
    }

    // Kill the store
    SafeRelease(g_pStore);
    SafeRelease(g_pLocalStore);
    SafeRelease(g_pDBSession);

    // Global options
    DeInitGlobalOptions();

    // Run register window classes
    UnregisterClass(c_szFolderWndClass, g_hInst);
    UnregisterClassWrapW(STRW_MSOEAPI_INSTANCECLASS, g_hInst);
    UnregisterClassWrapW(STRW_MSOEAPI_IPSERVERCLASS, g_hInst);
    UnregisterClass(c_szFolderViewClass, g_hInst);
    UnregisterClass(c_szBlockingPaintsClass, g_hInst);
    UnregisterClass(WC_THUMBNAIL, g_hInst);

    // Break Message Loop in RunShell if we are pumping messages and not switching identities
    if (m_fPumpingMsgs && !m_fSwitchingUsers)
        PostQuitMessage(0);
    else
        PostMessage(NULL, ITM_IDENTITYMSG, 0, 0);

    MU_Shutdown();

    // Relase the startup/shutdown mutex
    ReleaseMutex(m_hInstMutex);

    // Make sure mark this initialization thread as dead
    m_dwThreadId = 0;

exit:
    // We must have decremented succesfully
    if (phInitRef)
        *phInitRef = NULL;

    // Trace
    //TraceInfo(_MSG("_CoDecrementInitMain Count = %d, Reference Count = %d, Lock Count = %d", m_cDllInit, m_cDllRef, m_cDllLock));

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// COutlookExpress::ActivateWindow
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::ActivateWindow(HWND hwnd)
{
    // If hwnd is minimized, retstore it
    if (IsIconic(hwnd))
        ShowWindow(hwnd, SW_RESTORE);

    // If the window is not enabled, set it to the foreground
    if (IsWindowEnabled(hwnd))
        SetForegroundWindow(hwnd);

    // Otherwise, I have no clue what this does
    else
    {
        SetForegroundWindow(GetLastActivePopup(hwnd));
        MessageBeep(MB_OK);
        return S_FALSE;
    }

    // Done
    return S_OK;
}


// --------------------------------------------------------------------------------
// COutlookExpress::SetSwitchingUsers
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::SetSwitchingUsers(BOOL bSwitching)
{
    // Set the mode to whatever was passed in
    m_fSwitchingUsers = bSwitching;

    // if we are switching, we need to enter the mutex so that 
    // another process won't get started
    if (bSwitching)
        WaitForSingleObject(m_hInstMutex, INFINITE);
    return S_OK;
}

// --------------------------------------------------------------------------------
// COutlookExpress::SetSwitchingUsers
// --------------------------------------------------------------------------------
void COutlookExpress::SetSwitchToUser(TCHAR *lpszUserName)
{
    if (m_szSwitchToUsername)
    {
        MemFree(m_szSwitchToUsername);
        m_szSwitchToUsername = NULL;
    }

    MemAlloc((void **)&m_szSwitchToUsername, lstrlen(lpszUserName) + 1);
    
    if (m_szSwitchToUsername)
    {
        lstrcpy(m_szSwitchToUsername ,lpszUserName);
    }
}
// --------------------------------------------------------------------------------
// COutlookExpress::BrowseToObject
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::BrowseToObject(UINT nCmdShow, FOLDERID idFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    HWND            hwnd;

    // Trace
    TraceCall("COutlookExpress::BrowseToObject");

    // Do we already have a global browser object ?
    if (g_pBrowser)
    {
        // Get its Window
        if (SUCCEEDED(g_pBrowser->GetWindow(&hwnd)))
        {
            // Activate that Window
            IF_FAILEXIT(hr = ActivateWindow(hwnd));
        }

        // Tell the browser to browse to this object
        IF_FAILEXIT(hr = g_pBrowser->BrowseObject(idFolder, 0));
    }

    // Otherwise, we need to create a new browser object
    else
    {
        // We should always be on the correct thread here
        if (m_dwThreadId == GetCurrentThreadId())
        {
            // Create a new browser object
            IF_NULLEXIT(g_pBrowser = new CBrowser);

            // CoIncrementInit It
            IF_FAILEXIT(hr = g_pBrowser->HrInit(nCmdShow, idFolder));
        }

        // Otherwise, we need to thunk across to the init thread to make this happen.
        // This can happen when the Finder.cpp does a BrowseToObject to open a messgae's container
        else
        {
            // Thunk with a message
            Assert(g_hwndInit && IsWindow(g_hwndInit));
            IF_FAILEXIT(hr = (HRESULT)SendMessage(g_hwndInit, ITM_BROWSETOOBJECT, (WPARAM)nCmdShow, (LPARAM)idFolder));
        }
    }

exit:
    // Done
    return hr;
}

 
void COutlookExpress::_ProcessCommandLineFlags(LPWSTR *ppwszCmdLine, DWORD  dwFlags)
{
    Assert(ppwszCmdLine != NULL);
    
    DWORD   Mode = 0;

    if (*ppwszCmdLine != NULL)
    {
        // '/mailonly'
        if (0 == StrCmpNIW(*ppwszCmdLine, c_wszSwitchMailOnly, lstrlenW(c_wszSwitchMailOnly)))
        {
            SetStartFolderType(FOLDER_LOCAL);

            Mode |= MODE_MAILONLY;
            *ppwszCmdLine = *ppwszCmdLine + lstrlenW(c_wszSwitchMailOnly);
        }

        // '/newsonly'
        else if (0 == StrCmpNIW(*ppwszCmdLine, c_wszSwitchNewsOnly, lstrlenW(c_wszSwitchNewsOnly)))
        {
            SetStartFolderType(FOLDER_NEWS);

            Mode |= MODE_NEWSONLY;
            *ppwszCmdLine = *ppwszCmdLine + lstrlenW(c_wszSwitchNewsOnly);
        }
        // '/outnews'
        else if (0 == StrCmpNIW(*ppwszCmdLine, c_wszSwitchOutNews, lstrlenW(c_wszSwitchOutNews)))
        {
            SetStartFolderType(FOLDER_NEWS);

            Mode |= MODE_OUTLOOKNEWS;
            *ppwszCmdLine = *ppwszCmdLine + lstrlenW(c_wszSwitchOutNews);
        }
    }

    if (!(dwFlags & MSOEAPI_START_ALREADY_RUNNING))
    {
        g_dwAthenaMode |= Mode;
    }
}

// --------------------------------------------------------------------------------
// COutlookExpress::ProcessCommandLine
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::ProcessCommandLine(INT nCmdShow, LPWSTR pwszCmdLine, BOOL *pfErrorDisplayed)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwszArgs;
    FOLDERID        idFolder=FOLDERID_ROOT;
    HWND            hwnd=NULL;
    IF_DEBUG(DWORD  dwTickStart=GetTickCount());

    // Trace
    TraceCall("COutlookExpress::ProcessCommandLine");

    // Invalid Arg
    Assert(pfErrorDisplayed);

    // Do we have a command line
    if (NULL == pwszCmdLine)
        return S_OK;

    // Goto Next Switch
    if (*pwszCmdLine == L' ')
        pwszCmdLine++;

    // '/mailurl:'
    if (0 == StrCmpNIW(pwszCmdLine, c_wszSwitchMailURL, lstrlenW(c_wszSwitchMailURL)))
    {
        SetStartFolderType(FOLDER_LOCAL);

        pwszArgs = pwszCmdLine + lstrlenW(c_wszSwitchMailURL);
        IF_FAILEXIT(hr = _HandleMailURL(pwszArgs, pfErrorDisplayed));
    }

    // '/newsurl:'
    else if (0 == StrCmpNIW(pwszCmdLine, c_wszSwitchNewsURL, lstrlenW(c_wszSwitchNewsURL)))
    {
        SetStartFolderType(FOLDER_NEWS);

        pwszArgs = pwszCmdLine + lstrlenW(c_wszSwitchNewsURL);
        IF_FAILEXIT(hr = _HandleNewsURL(nCmdShow, pwszArgs, pfErrorDisplayed));
    }

    // '/eml:'
    else if (0 == StrCmpNIW(pwszCmdLine, c_wszSwitchEml, lstrlenW(c_wszSwitchEml)))
    {
        pwszArgs = pwszCmdLine + lstrlenW(c_wszSwitchEml);
        IF_FAILEXIT(hr = _HandleFile(pwszArgs, pfErrorDisplayed, FALSE));
    }

    // '/nws:'
    else if (0 == StrCmpNIW(pwszCmdLine, c_wszSwitchNws, lstrlenW(c_wszSwitchNws)))
    {
        pwszArgs = pwszCmdLine + lstrlenW(c_wszSwitchNws);
        IF_FAILEXIT(hr = _HandleFile(pwszArgs, pfErrorDisplayed, TRUE));
    }
    
    // Otherwise, decide where to start a browser at...
    else
    {
        // Handle '/news'
        if (0 == StrCmpNIW(pwszCmdLine, c_wszSwitchNews, lstrlenW(c_wszSwitchNews)))
        {
            // This sets g_dwIcwFlags
            SetStartFolderType(FOLDER_NEWS);
            
            if (g_pBrowser)
                g_pBrowser->GetWindow(&hwnd);

            hr = ProcessICW(hwnd, FOLDER_NEWS, TRUE);
            if (hr != S_OK)
                goto exit;

            // Get Default News SErver
            GetDefaultServerId(ACCT_NEWS, &idFolder);
        }

        // Handle '/mail /defclient'
        else if (0 == StrCmpNIW(pwszCmdLine, c_wszSwitchMail, lstrlenW(c_wszSwitchMail)) ||
                 0 == StrCmpNIW(pwszCmdLine, c_wszSwitchDefClient, lstrlenW(c_wszSwitchDefClient)))
        {
            // Locals
            FOLDERINFO  Folder;
            FOLDERID    idStore;
            
            // This sets g_dwIcwFlags
            SetStartFolderType(FOLDER_LOCAL);

            if (g_pBrowser)
                g_pBrowser->GetWindow(&hwnd);

            hr = ProcessICW(hwnd, FOLDER_LOCAL, TRUE);
            if (hr != S_OK)
                goto exit;

            // Get store ID of default account
            if (FAILED(GetDefaultServerId(ACCT_MAIL, &idStore)))
                idStore = FOLDERID_LOCAL_STORE;

            // Get Inbox Id
            if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(idStore, FOLDER_INBOX, &Folder)))
            {
                idFolder = Folder.idFolder;
                g_pStore->FreeRecord(&Folder);
            }

        }

        // No switches
        else
        {
            // default launch 
            //   - if there is already a browser, just activate it
            //   - else if the option is set, select default inbox
            //   - else select the root (pidl = NULL)
            if (g_pBrowser && SUCCEEDED(g_pBrowser->GetWindow(&hwnd)))
            {
                ActivateWindow(hwnd);
                goto exit;
            }
            else if (DwGetOption(OPT_LAUNCH_INBOX) && (FALSE == ISFLAGSET(g_dwAthenaMode, MODE_NEWSONLY)))
            {
                // Locals
                FOLDERINFO  Folder;
                FOLDERID    idStore;

                // This sets g_dwIcwFlags
                SetStartFolderType(FOLDER_LOCAL);

                // Get store ID of default account
                if (FAILED(GetDefaultServerId(ACCT_MAIL, &idStore)))
                    idStore = FOLDERID_LOCAL_STORE;

                // Get Inbox Id
                if (SUCCEEDED(g_pStore->GetSpecialFolderInfo(idStore, FOLDER_INBOX, &Folder)))
                {
                    idFolder = Folder.idFolder;
                    g_pStore->FreeRecord(&Folder);
                }
            }
        }

        // Browe to this new object, I assume if pidl=null, we browse to the root
        IF_FAILEXIT(hr = BrowseToObject(nCmdShow, idFolder));
    }

exit:
    /*
    // Cleanup
    SafeMemFree(pszFree);
    */
    // Trace
    TraceInfo(_MSG("Process Command Line Time: %d milli-seconds", GetTickCount() - dwTickStart));

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::_HandleFile
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::_HandleFile(LPWSTR pwszCmd, BOOL *pfErrorDisplayed, BOOL fNews)
{
    // Locals
    HRESULT             hr=S_OK;
    INIT_MSGSITE_STRUCT initStruct;
    DWORD               dwCreateFlags = OENCF_SENDIMMEDIATE;
    
    if (fNews)
        dwCreateFlags |= OENCF_NEWSFIRST;

    // Stack
    TraceCall("COutlookExpress::_HandleFile");

    // Invalid Arg
    Assert(pfErrorDisplayed);

    // Invalid Arg
    if (NULL == pwszCmd || L'\0' == *pwszCmd)
    {
        hr = TraceResult(E_INVALIDARG);
        goto exit; 
    }

    // Does the file exist ?
    if (FALSE == PathFileExistsW(pwszCmd))
    {
        // Locals
        REPORTERRORINFO rError={0};

        // Set hr
        hr = TraceResult(MSOEAPI_E_FILE_NOT_FOUND);

        // Duplicate It
        LPSTR pszCmd = PszToANSI(CP_ACP, pwszCmd);
        if (pszCmd)
        {
            // Make the rror
            MAKEERROR(&rError, 0, IDS_ERROR_FILE_NOEXIST, 0, pszCmd);
            rError.nHelpIds = 0;

            // Show an error
            *pfErrorDisplayed = _ReportError(g_hLocRes, hr, 0, &rError);

            // Cleanup
            MemFree(pszCmd);
        }

        // Done
        goto exit;
    }

    initStruct.dwInitType = OEMSIT_FAT;
    initStruct.pwszFile = pwszCmd;

    hr = CreateAndShowNote(OENA_READ, dwCreateFlags, &initStruct);

exit:          
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::_HandleNewsArticleURL
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::_HandleNewsArticleURL(LPSTR pszServerIn, LPSTR pszArticle, UINT uPort, BOOL fSecure, BOOL *pfErrorDisplayed)
{
    HRESULT             hr=S_OK;
    CHAR                szAccountId[CCHMAX_ACCOUNT_NAME];
    LPSTR               psz = NULL, 
                        pszBuf = NULL;
    IImnAccount        *pAccount=NULL;
    INIT_MSGSITE_STRUCT initStruct;
    LPMIMEMESSAGE       pMsg = NULL;

    Assert(pszServerIn);

    // Stack
    TraceCall("COutlookExpress::_HandleNewsArticleURL");

    // Invalid Arg
    Assert(pfErrorDisplayed);

    // If a server was specified, then try to create a temp account for it
    if (FALSE == FIsEmptyA(pszServerIn) && SUCCEEDED(CreateTempNewsAccount(pszServerIn, uPort, fSecure, &pAccount)))
    {
        // Get the Account name
        IF_FAILEXIT(hr = pAccount->GetPropSz(AP_ACCOUNT_ID, szAccountId, ARRAYSIZE(szAccountId)));
    }   
    // Otherwise, use the default news server
    else
    {
        // If a server wasn't specified, then use the default account
        IF_FAILEXIT(hr = GetDefaultNewsServer(szAccountId, ARRAYSIZE(szAccountId)));
    }

    // Bug #10555 - The URL shouldn't have <> around the article ID, but some lameoids probably will do it anyway, so deal with it.
    if (FALSE == IsDBCSLeadByte(*pszArticle) && '<' != *pszArticle)
    {
        if (!MemAlloc((void **)&pszBuf, (lstrlen(pszArticle) + 4)))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        wsprintf(pszBuf, TEXT("<%s>"), pszArticle);
        psz = pszBuf;
    }
    else
    {
        psz = pszArticle;
    }

    
    hr = HrDownloadArticleDialog(szAccountId, psz, &pMsg);
    if (S_OK == (hr))
    {
        Assert(pMsg != NULL);

        initStruct.dwInitType = OEMSIT_MSG;
        initStruct.pMsg = pMsg;
        initStruct.folderID = FOLDERID_INVALID;
    
        hr = CreateAndShowNote(OENA_READ, OENCF_NEWSFIRST, &initStruct);
    }
    else
    {
        // No errors if the user cancel'ed on purpose.
        if (HR_E_USER_CANCEL_CONNECT == hr || HR_E_OFFLINE == hr)
            hr = S_OK;
        else
        {
            AthMessageBoxW(g_hwndInit, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsNewsTaskArticleError), 0, MB_OK|MB_SETFOREGROUND); 
            hr = S_OK;
        }

    }


exit:
    // Cleanup
    MemFree(pszBuf);
    ReleaseObj(pAccount);
    ReleaseObj(pMsg);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::_HandleNewsURL
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::_HandleNewsURL(INT nCmdShow, LPWSTR pwszCmd, BOOL *pfErrorDisplayed)
{
    // Locals
    HWND            hwnd;
    HRESULT         hr=S_OK;
    LPSTR           pszCmd=NULL,
                    pszServer=NULL,
                    pszGroup=NULL,
                    pszArticle=NULL;
    UINT            uPort=(UINT)-1;
    BOOL            fSecure;
    FOLDERID        idFolder;
    TCHAR           szRes[CCHMAX_STRINGRES],
                    szError[MAX_PATH + CCHMAX_STRINGRES];

    // Stack
    TraceCall("COutlookExpress::_HandleNewsURL");
    
    // Invalid Arg
    Assert(pfErrorDisplayed);
    Assert(pwszCmd != NULL);
    Assert(*pwszCmd != 0);
    
    // Since this is a URL, then don't need to worry about UNICODE
    IF_NULLEXIT(pszCmd = PszToANSI(CP_ACP, pwszCmd));
    
    // Un-escape the Url
    UrlUnescapeInPlace(pszCmd, 0);
    
    // Figure out if the URL is valid and what type of URL it is.
    hr = URL_ParseNewsUrls(pszCmd, &pszServer, &uPort, &pszGroup, &pszArticle, &fSecure);
    
    if ((hr == INET_E_UNKNOWN_PROTOCOL || hr == INET_E_INVALID_URL) &&
        LoadString(g_hLocRes, idsErrOpenUrlFmt, szRes, ARRAYSIZE(szRes)))
    {
        // if bad url format, warn user and return S_OK as we handled it
        // Outlook Express could not open the URL '%.100s' because it is not a recognized format.
        // we clip the URL to 100 chars, so it easily fits in the MAX_PATH buffer
        wsprintf(szError, szRes, pszCmd, lstrlen(pszCmd)>100?g_szEllipsis:c_szEmpty);
        AthMessageBox(g_hwndInit, MAKEINTRESOURCE(idsAthena), szError, 0, MB_OK|MB_SETFOREGROUND); 
        return S_OK;
    }
    IF_FAILEXIT(hr);

        // Compute the correct port number
    if (uPort == -1)
        uPort = fSecure ? DEF_SNEWSPORT : DEF_NNTPPORT;
    
    // If we have an article, HandleNewsArticleURL
    if (pszArticle)
    {
        // Launch a read note onto the article id
        IF_FAILEXIT(hr = _HandleNewsArticleURL(pszServer, pszArticle, uPort, fSecure, pfErrorDisplayed));
    }

    // Otheriwse, create a PIDL and browse to that pidl (its a newsgroup)
    else
    {
        // Locals
        FOLDERID idFolder;

        if (pszServer == NULL)
        {
            // If we have a browser, the its hwnd so that ICW has a parent
            if (g_pBrowser)
                g_pBrowser->GetWindow(&hwnd);
            else
                hwnd = NULL;

            // Run the ICW if necessary
            hr = ProcessICW(hwnd, FOLDER_NEWS, TRUE);
            if (hr != S_OK)
                goto exit;
        }

        // Create a PIDL for this newsgroup URL
        if (SUCCEEDED(hr = GetFolderIdFromNewsUrl(pszServer, uPort, pszGroup, fSecure, &idFolder)))
        {
            // Browse to that object
            IF_FAILEXIT(hr = BrowseToObject(nCmdShow, idFolder));
        }
    }
    
exit:      
    // Cleanup
    SafeMemFree(pszCmd);
    SafeMemFree(pszServer);
    SafeMemFree(pszGroup);
    SafeMemFree(pszArticle);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::_HandleMailURL
//
// PURPOSE:    Provides an entry point into Thor that allows us to be
//             invoked from a URL.  The pszCmdLine paramter must be a
//             valid Mail URL or nothing happens.
//
// --------------------------------------------------------------------------------
HRESULT COutlookExpress::_HandleMailURL(LPWSTR pwszCmdLine, BOOL *pfErrorDisplayed)
{
    // Locals
    HRESULT                 hr=S_OK;
    LPMIMEMESSAGE           pMsg=NULL;
    INIT_MSGSITE_STRUCT     initStruct;
    TCHAR                   szRes[CCHMAX_STRINGRES],
                            szError[MAX_PATH + CCHMAX_STRINGRES];
    LPSTR                   pszCmdLine = NULL;

    // Stack
    TraceCall("COutlookExpress::_HandleMailURL");

    // Invalid Arg
    Assert(pfErrorDisplayed);

    // No command line
    if (NULL == pwszCmdLine || L'\0' == *pwszCmdLine)
    {
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }
   
    // Since this is a URL, then don't need to worry about UNICODE
    IF_NULLEXIT(pszCmdLine = PszToANSI(CP_ACP, pwszCmdLine));

    // Create a Message Object
    IF_FAILEXIT(hr = HrCreateMessage(&pMsg));

    // NOTE: no URLUnescape in this function - it must be done in URL_ParseMailTo to handle
    // URLs of the format:
    //
    //      mailto:foo@bar.com?subject=AT%26T%3dBell&cc=me@too.com
    //
    // so that the "AT%26T" is Unescaped into "AT&T=Bell" *AFTER* the "subject=AT%26T%3dBell&" blob is parsed.
    hr = URL_ParseMailTo(pszCmdLine, pMsg);

    if ((hr == INET_E_UNKNOWN_PROTOCOL || hr == INET_E_INVALID_URL) &&
        LoadString(g_hLocRes, idsErrOpenUrlFmt, szRes, ARRAYSIZE(szRes)))
    {
        // if bad url format, warn user and return S_OK as we handled it
        // Outlook Express could not open the URL '%.100s' because it is not a recognized format.
        // we clip the URL to 100 chars, so it easily fits in the MAX_PATH buffer
        wsprintf(szError, szRes, pszCmdLine, lstrlen(pszCmdLine)>100?g_szEllipsis:c_szEmpty);
        AthMessageBox(g_hwndInit, MAKEINTRESOURCE(idsAthena), szError, 0, MB_OK|MB_SETFOREGROUND); 
        return S_OK;
    }

    IF_FAILEXIT(hr);

    initStruct.dwInitType = OEMSIT_MSG;
    initStruct.pMsg = pMsg;
    initStruct.folderID = FOLDERID_INVALID;

    hr = CreateAndShowNote(OENA_COMPOSE, OENCF_SENDIMMEDIATE, &initStruct);

exit:
    // Cleanup
    SafeRelease(pMsg);
    MemFree(pszCmdLine);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// COutlookExpress::InitWndProc
// --------------------------------------------------------------------------------
LRESULT EXPORT_16 CALLBACK COutlookExpress::InitWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    // Locals
    BOOL        fRet;
    HRESULT     hr;

    // Delegate to the Account Manager
    if (g_pAcctMan && g_pAcctMan->ProcessNotification(msg, wp, lp) == S_OK)
        return TRUE;

    // Handle the Message
    switch(msg)
    {
        case WM_ENDSESSION:
            // if we get forced down by window, we don't exit clean, so deinit global opt it not called. We obviously don't have a mailbomb so clear the regkey.
            SetDwOption(OPT_ATHENA_RUNNING, FALSE, NULL, 0);
            break;

        case WM_SETTINGCHANGE:
            Assert (g_lpIFontCache);
            if (g_lpIFontCache)
                {
                if (!wp || SPI_SETNONCLIENTMETRICS == wp || SPI_SETICONTITLELOGFONT == wp)
                    g_lpIFontCache->OnOptionChange();
                }
            break;

        case ITM_WAB_CO_DECREMENT:
            Wab_CoDecrement();
            return 0;

        case ITM_BROWSETOOBJECT:
            return (LRESULT)g_pInstance->BrowseToObject((UINT)wp, (FOLDERID)lp);

        case ITM_SHUTDOWNTHREAD:
            return (LRESULT)g_pInstance->_CoDecrementInitMain((LPHINITREF)lp);

        case ITM_POSTCOPYDATA:
            if (lp)
            {
                g_pInstance->Start(MSOEAPI_START_ALREADY_RUNNING, (LPCWSTR)lp, SW_SHOWNORMAL);
                MemFree((LPWSTR)lp);
            }
            break;

        case WM_COPYDATA:
            {
                // Locals
                COPYDATASTRUCT *pCopyData = (COPYDATASTRUCT *)lp;

                // Command-line
                if (pCopyData->dwData == MSOEAPI_ACDM_CMDLINE)
                {
                    // #25238: On Win95, OLE get's pissed if we syncronously do stuff on the 
                    // WM_COPYDATA. On the most part it works, but if we show an error and pump messages
                    // then some messages get run out of sequence and we deadlock between msimn.exe and
                    // iexplore.exe. Now we post to ourselves as we don't care about the HRESULT anyway
                    // we free the duped string on the post
                    PostMessage(hwnd, ITM_POSTCOPYDATA, 0, (LPARAM)PszDupW((LPCWSTR)pCopyData->lpData));
                    return 0;
                }

                // Notification Thunk
                else if (pCopyData->dwData == MSOEAPI_ACDM_NOTIFY)
                {
                    // Locals
                    NOTIFYDATA      rNotify;
                    LRESULT         lResult=0;

                    // Crack the notification
                    if (SUCCEEDED(CrackNotificationPackage(pCopyData, &rNotify)))
                    {
                        // Otherwise, its within this process...
                        if (ISFLAGSET(rNotify.dwFlags, SNF_SENDMSG))
                            lResult = SendMessage(rNotify.hwndNotify, rNotify.msg, rNotify.wParam, rNotify.lParam);
                        else
                            PostMessage(rNotify.hwndNotify, rNotify.msg, rNotify.wParam, rNotify.lParam);

                        // Done
                        return lResult;
                    }

                    // Problems
                    else
                        Assert(FALSE);
                }
            }
            break;

        case MVM_NOTIFYICONEVENT:
            g_pInstance->_HandleTrayIconEvent(wp, lp);
            return (0);
    }

    // Delegate to default window procedure
    return DefWindowProc(hwnd, msg, wp, lp);
}


HRESULT COutlookExpress::UpdateTrayIcon(TRAYICONACTION type)
{
    NOTIFYICONDATA nid;
    HWND           hwnd = NULL;
    ULONG          i;

    TraceCall("COutlookExpress::UpdateTrayIcon");

    EnterCriticalSection(&m_cs);

    // Make sure we have the init window around first
    if (!g_hwndInit)
        goto exit;

    // Set up the struct
    nid.cbSize = sizeof(NOTIFYICONDATA);
    nid.uID = 0;
    nid.uFlags = NIF_ICON | NIF_TIP | NIF_MESSAGE;
    nid.uCallbackMessage = MVM_NOTIFYICONEVENT;
    if(m_hTrayIcon)
    {
        //Bug #86366 - (erici) Fixes leak.  Don't create a new ICON each time COutlookExpress::UpdateTrayIcon is called.
        nid.hIcon = m_hTrayIcon;
    }
    else
    {
        nid.hIcon = (HICON) LoadImage(g_hLocRes, MAKEINTRESOURCE(idiNewMailNotify), IMAGE_ICON, 16, 16, 0);
    }
    nid.hWnd = g_hwndInit;
    LoadString(g_hLocRes, idsNewMailNotify, nid.szTip, sizeof(nid.szTip));

    if (TRAYICONACTION_REMOVE == type)
    {
        Shell_NotifyIcon(NIM_DELETE, &nid);
    }

    // Add
    if (TRAYICONACTION_ADD == type)
    {
        Shell_NotifyIcon(NIM_ADD, &nid);
    }
    g_pBrowser->WriteUnreadCount();

exit:
    LeaveCriticalSection(&m_cs);

    return (S_OK);
}


void COutlookExpress::_HandleTrayIconEvent(WPARAM wParam, LPARAM lParam)
    {
    HWND hwnd;

    if (lParam == WM_LBUTTONDBLCLK)
    {
        if (g_pBrowser)
        {
            g_pBrowser->GetWindow(&hwnd);
            if (IsIconic(hwnd))
                ShowWindow(hwnd, SW_RESTORE);
            SetForegroundWindow(hwnd);        
            
            PostMessage(hwnd, WM_COMMAND, ID_GO_INBOX, 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\migrate.h ===
// --------------------------------------------------------------------------------
// MIGRATE.H
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __MIGRATE_H
#define __MIGRATE_H

HRESULT MigrateAndUpgrade(void);
void BuildOldCacheFileName(LPCSTR lpszServer, LPCSTR lpszGroup, LPSTR lpszFile);

#endif // __MIGRATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\migrate.cpp ===
// --------------------------------------------------------------------------------
// MIGRATE.CPP
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "strconst.h"
#include "resource.h"
#include "storfldr.h"
#include <imnact.h>
#include <acctutil.h>
#include "shlwapi.h"
#include <mimeole.h>
#include "xpcomm.h"
#include "oerules.h"
#include "goptions.h"
#include "ruleutil.h"
#include "criteria.h"
#include "actions.h"
#include "rule.h"
#include "storutil.h"
#include "shared.h"
#include "multiusr.h"
#include "msident.h"
#include "imapute.h"
#include <store.h>

#include "demand.h"

static const char c_szSettingsUpgraded[] = {"Settings Upgraded"};

BOOL g_fMigrationDone = FALSE;

void MigrateSettings(HKEY hkey);
HRESULT MigrateStoreToV2(HKEY hkeyV2, LPTSTR pszSrc, DWORD cchSrc, LPTSTR pszDest, DWORD cchDest);
HRESULT MigrateAccounts(void);
HRESULT MigrateMailServers(IImnAccountManager *pAcctMan, HKEY hkeyMail, HKEY hkeyPop3, HKEY hkeySmtp);
HRESULT MigrateNewsServers(IImnAccountManager *pAcctMan, HKEY hkeyNews);
HRESULT MigrateBase64EncodedPassword(LPCSTR pszBase64, DWORD cch, DWORD dwPropId, IImnAccount *pAccount);
HRESULT MigrateServerDataFiles(LPSTR pszServer, LPCSTR pszOldDir, LPCSTR pszSubDir);
void MigrateAccessibilityKeys(void);
HRESULT MigrateToPropertyStore(void);
void MigrateMailRulesSettings(void);
void ConvertToDBX(void);
void MigrateAccConnSettings();
void ForwardMigrateConnSettings();
void MigrateBeta2Rules();
void Stage5RulesMigration(VOID);
void Stage6RulesMigration(VOID);
#define VERLEN 20

// Data structures
typedef enum
    {
    VER_NONE = 0,
    VER_1_0,
    VER_1_1,
    VER_4_0,
    VER_5_0_B1,
    VER_5_0,
    VER_MAX,
    } SETUPVER;

/*******************************************************************

    NAME:       ConvertVerToEnum

********************************************************************/
SETUPVER ConvertVerToEnum(WORD *pwVer)
    {
    SETUPVER sv;
    Assert(pwVer);

    switch (pwVer[0])
        {
        case 0:
            sv = VER_NONE;
            break;

        case 1:
            if (0 == pwVer[1])
                sv = VER_1_0;
            else
                sv = VER_1_1;
            break;

        case 4:
            sv = VER_4_0;
            break;

        case 5:
            sv = VER_5_0;
            break;

        default:
            sv = VER_MAX;
        }

    return sv;
    }


/*******************************************************************

    NAME:       ConvertStrToVer

********************************************************************/
void ConvertStrToVer(LPCSTR pszStr, WORD *pwVer)
    {
    int i;

    Assert(pszStr);
    Assert(pwVer);

    ZeroMemory(pwVer, 4 * sizeof(WORD));

    for (i=0; i<4; i++)
        {
        while (*pszStr && (*pszStr != ',') && (*pszStr != '.'))
            {
            pwVer[i] *= 10;
            pwVer[i] += *pszStr - '0';
            pszStr++;
            }
        if (*pszStr)
            pszStr++;
        }

    return;
    }


/*******************************************************************

    NAME:       GetVerInfo

********************************************************************/
void GetVerInfo(SETUPVER *psvCurr, SETUPVER *psvPrev)
    {
    HKEY hkeyT;
    DWORD cb;
    CHAR szVer[VERLEN];
    WORD wVer[4];

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegWABVerInfo, 0, KEY_QUERY_VALUE, &hkeyT))
        {
        if (psvCurr)
            {
            cb = sizeof(szVer);
            RegQueryValueExA(hkeyT, c_szRegCurrVer, NULL, NULL, (LPBYTE)szVer, &cb);
            ConvertStrToVer(szVer, wVer);
            *psvCurr = ConvertVerToEnum(wVer);
            }

        if (psvPrev)
            {
            cb = sizeof(szVer);
            RegQueryValueExA(hkeyT, c_szRegPrevVer, NULL, NULL, (LPBYTE)szVer, &cb);
            ConvertStrToVer(szVer, wVer);
            *psvPrev = ConvertVerToEnum(wVer);
            }

        RegCloseKey(hkeyT);
        }
    }

// Entry Point
HRESULT MigrateAndUpgrade()
{
    DWORD	dwMigrate, cb, type, fMigratedStore, fMigratedStoreOE5, fConvertedToDBX, dwRegVer=0, dwMasterVer=0;
    BOOL    fNewID=FALSE;
    HKEY	hkey, hkeyForceful;
    TCHAR	szSrc[MAX_PATH], szDest[MAX_PATH];

// Keep this up to date!
#define LAST_MIGVALUE 7

    if (g_fMigrationDone)
        return(S_OK);

    ForwardMigrateConnSettings();

    if (ERROR_SUCCESS == RegCreateKeyEx(MU_GetCurrentUserHKey(), c_szRegRoot, NULL, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, &cb))
    {
        // Before anything else, see if this identity has had its registry initialized
        cb = sizeof(dwRegVer);
        if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szOEVerStamp, 0, &type, (LPBYTE)&dwRegVer, &cb))
        {
            HKEY hkeyDef;

            // No Defaults at all
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegDefaultSettings, 0, KEY_READ, &hkeyDef))
            {
                CopyRegistry(hkeyDef,  hkey);
                RegCloseKey(hkeyDef);
            }

            fNewID = TRUE;
        }
        else if (type != REG_DWORD || cb != sizeof(DWORD))
        {
            dwRegVer = 0;
        }

        // Compare to forceful setting reg value to see if we need those
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegForcefulSettings, 0, KEY_READ, &hkeyForceful))
        {
            cb = sizeof(dwMasterVer);
            RegQueryValueEx(hkeyForceful, c_szOEVerStamp, 0, NULL, (LPBYTE)&dwMasterVer, &cb);

            // Do we need to copy these in?
            if (dwRegVer < dwMasterVer)
            {
                // The act of copying will set c_szOEVerStamp
                CopyRegistry(hkeyForceful, hkey);
            }

            RegCloseKey(hkeyForceful);
        }


        // Start with no paths
        szSrc[0] = szDest[0] = 0;

        // move the store from v1 location to new location.
        // this is done because v1 barfs when trying to look at v2 store.
        // when we uninstall, we try to move the store back to its v1 location
        // and we tweak the versions of the store files so v1 repairs the files
        // and can run without crashing
        // HKCU,"software/microsoft/outlook express/5.0","MSIMN"
        if (fNewID)
        {
            fMigratedStore = TRUE;
            RegSetValueEx(hkey, c_szMSIMN, NULL, REG_DWORD, (LPBYTE)&fMigratedStore, sizeof(fMigratedStore));
        }
        else
        {
            cb = sizeof(fMigratedStore);
            if (RegQueryValueEx(hkey, c_szMSIMN, NULL, NULL, (LPBYTE)&fMigratedStore, &cb) != ERROR_SUCCESS)
                fMigratedStore = FALSE;

            if (!fMigratedStore)
            {
                // See if there is a v1 store, if so, figure out source and dest
                MigrateStoreToV2(hkey, szSrc, ARRAYSIZE(szSrc), szDest, ARRAYSIZE(szDest));
                fMigratedStore = TRUE;
                RegSetValueEx(hkey, c_szMSIMN, NULL, REG_DWORD, (LPBYTE)&fMigratedStore, sizeof(fMigratedStore));
            }
        }

        // we need to do this everytime we startup.
        // thank the trident guys for this lovely perf hit.
        MigrateAccessibilityKeys();

        if (fNewID)
            dwMigrate = LAST_MIGVALUE;
        else
        {
            cb = sizeof(dwMigrate);
            if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szSettingsUpgraded, 0, &type, (LPBYTE)&dwMigrate, &cb))
                dwMigrate = 0;
        }

        // ATTENTION! PLEASES READ THE FOLLOWING BEFORE CHANGING THE UPGRADE CODE,
        // SO YOU DON'T MESS ANYTHING UP. (i don't often comment anything so this must
        // be important.)
        //
        // everything in the dwMigrate == 0 case is pre-oe5 and before we had one place to do
        // upgrade and migration of previous oe settings. some of the pre-oe5 migration code used
        // their own reg values to indicate that migration had been performed, so we'll use those
        // in this case.
        // but from now on all migration should use the same reg value (c_szSettingsUpgraded) to
        // track what needs to be upgraded/migrated. as you change something and add migration code
        // bump up the value

        if (dwMigrate == 0)
        {
            SETUPVER svPrev;

            // HKCU,"software/microsoft/outlook express/5.0","Settings Migrated"
            MigrateSettings(hkey);

            GetVerInfo(NULL, &svPrev);
            if (VER_1_0 == svPrev || VER_1_1 == svPrev)
                MigrateAccounts();

            dwMigrate = 1;
        }

        if (dwMigrate == 1)
        {
//         MigrateCharSetMapSettings(); // We don't need to migrate this settings,
                                        // but need to keep dwMigrate for Beta2. (YST)

            dwMigrate = 2;
        }

        if (dwMigrate == 2)
        {
            //Migrate account connection settings
            MigrateAccConnSettings();

            dwMigrate = 3;
        }

        // More settings migratation are done after the store migration

        // For Outlook Express V5, we migrate the OE4 version store to the ObjectDB Store.
        // For V1 Users, the code above will have just executed and now they get to migrate again.
        if (fNewID)
            fMigratedStoreOE5 = TRUE;
        else
        {
            cb = sizeof(fMigratedStoreOE5);
            if (RegQueryValueEx(hkey, c_szStoreMigratedToOE5, NULL, NULL, (LPBYTE)&fMigratedStoreOE5, &cb) != ERROR_SUCCESS)
                fMigratedStoreOE5 = FALSE;
        }

        if (!fMigratedStoreOE5)
        {
            // If we didn't just come from v1, we don't know where we are coming from or going to...
            // Default to Store Root location
            if (!szSrc[0])
            {
                Assert(!szDest[0]);

                cb = sizeof(szSrc);
                RegQueryValueEx(hkey, c_szRegStoreRootDir, 0, &type, (LPBYTE)szSrc, &cb);
                if (REG_EXPAND_SZ == type)
                {
                    ExpandEnvironmentStrings(szSrc, szDest, ARRAYSIZE(szDest));
                    lstrcpy(szSrc, szDest);
                }
                else
                    lstrcpy(szDest, szSrc);
                }
            else
                Assert(szDest[0]);

            // Do we have anything to migrate?
            if (szSrc[0] && szDest[0])
            {
                if (SUCCEEDED(MigrateLocalStore(NULL, szSrc, szDest)))
                {
                    // Since the store migration remapped the folder id
                    // we must fix up the folder id in the rules
                    ImapUtil_B2SetDirtyFlag();

                    fMigratedStoreOE5 = TRUE;
                    RegSetValueEx(hkey, c_szConvertedToDBX, NULL, REG_DWORD, (LPBYTE)&fMigratedStoreOE5, sizeof(fMigratedStoreOE5));
                }
            }
            else
                // Nothing to migrate = success!
                fMigratedStoreOE5 = TRUE;

        }

        // Save state
        RegSetValueEx(hkey, c_szStoreMigratedToOE5, NULL, REG_DWORD, (LPBYTE)&fMigratedStoreOE5, sizeof(fMigratedStoreOE5));

        if (fNewID)
        {
            fConvertedToDBX = TRUE;
            RegSetValueEx(hkey, c_szConvertedToDBX, NULL, REG_DWORD, (LPBYTE)&fConvertedToDBX, sizeof(fConvertedToDBX));
        }
        else
        {
            cb = sizeof(fConvertedToDBX);
            if (RegQueryValueEx(hkey, c_szConvertedToDBX, NULL, NULL, (LPBYTE)&fConvertedToDBX, &cb) != ERROR_SUCCESS)
                fConvertedToDBX = FALSE;
            if (!fConvertedToDBX)
            {
                fConvertedToDBX = TRUE;
                ConvertToDBX();
                RegSetValueEx(hkey, c_szConvertedToDBX, NULL, REG_DWORD, (LPBYTE)&fConvertedToDBX, sizeof(fConvertedToDBX));
            }
        }

        if (dwMigrate == 3)
        {
            //Migrate rules settings

            // This must be done after the store has been migrated
            MigrateMailRulesSettings();

            dwMigrate = 4;
        }

        if (dwMigrate == 4)
        {
            //Migrate from Beta 2 rules

            // This must be done after the store has been migrated
            MigrateBeta2Rules();

            dwMigrate = 5;
        }

        if (dwMigrate == 5)
        {
            //Migrate from Beta 2 rules

            // This must be done after the store has been migrated
            Stage5RulesMigration();

            dwMigrate = 6;
        }

        if (dwMigrate == 6)
        {
            //Migrate from Beta 2 rules

            // This must be done after the store has been migrated
            Stage6RulesMigration();

            dwMigrate = LAST_MIGVALUE;
        }

        // Write the present upgraded settings value
        RegSetValueEx(hkey, c_szSettingsUpgraded, 0, REG_DWORD, (LPBYTE)&dwMigrate, sizeof(dwMigrate));

        // Cleanup
        RegCloseKey(hkey);
    }

    g_fMigrationDone = TRUE;

    return(S_OK);
    }


//--------------------------------------------------------------------------
// MigrateAccConnSettings
//
// This migrates the connection settings for each account. This should be called
// for the following upgrade scenarios. 1)Upgrade from pre-OE5 to OE5 Beta2 or more
// 2)Upgrade from OeBeta1 to OE5 Beta2 or more
// If the Connection Setting was previously LAN, we migrate it to use InternetConnection
// (which is any connection available). If the previous setting was RAS, we leave it
// as it is.
//
//--------------------------------------------------------------------------
void MigrateAccConnSettings()
{

	IImnEnumAccounts   *pEnum = NULL;
	IImnAccount		   *pAccount = NULL;
	DWORD				dwConnection;

	Assert(g_pAcctMan == NULL);

	if (FAILED(AcctUtil_CreateAccountManagerForIdentity(PGUIDCurrentOrDefault(), &g_pAcctMan)))
	{
		return;
	}

    if (SUCCEEDED(g_pAcctMan->Enumerate(SRV_MAIL | SRV_NNTP, &pEnum)))
	{
		while(SUCCEEDED(pEnum->GetNext(&pAccount)))
		{
			// Get Email Address
			if (SUCCEEDED(pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnection)))
			{
				if (dwConnection == CONNECTION_TYPE_LAN)
				{
                    pAccount->SetPropDw(AP_RAS_CONNECTION_TYPE, CONNECTION_TYPE_INETSETTINGS);
                    pAccount->SaveChanges();
				}
			}

			SafeRelease(pAccount);
		}

		SafeRelease(pEnum);
	}

    g_pAcctMan->Release();
    g_pAcctMan = NULL;

}

void ForwardMigrateConnSettings()
{
    /*
    We shouldn't have to do all the stuff we do above in MigrateAccConnSettings.
    We just need to look at the old regsitry settings at
    \\HKCU\Software\Microsoft\Internet Account Manager\Accounts.
    Migrating from OE4 to OE5 just uses the same location if there is only one identity.
    */

    HKEY    hKeyAccounts = NULL;
    DWORD   dwAcctSubKeys = 0;
    LONG    retval;
    DWORD   index = 0;
    LPTSTR  lpszAccountName = NULL;
    HKEY    hKeyAccountName = NULL;
    DWORD   memsize = 0;
    DWORD   dwValue;
    DWORD   cbData = sizeof(DWORD);
    DWORD   cbMaxAcctSubKeyLen;
    DWORD   DataType;
    DWORD   dwConnSettingsMigrated = 1;

    //This setting is in \\HKCU\Software\Microsoft\InternetAccountManager\Accounts

    retval = RegOpenKey(HKEY_CURRENT_USER, c_szIAMAccounts, &hKeyAccounts);
    if (ERROR_SUCCESS != retval)
        goto exit;

    retval = RegQueryValueEx(hKeyAccounts, c_szConnSettingsMigrated, NULL,  &DataType,
                        (LPBYTE)&dwConnSettingsMigrated, &cbData);

    if ((retval != ERROR_FILE_NOT_FOUND) && (retval != ERROR_SUCCESS || dwConnSettingsMigrated == 1))
        goto exit;

    retval = RegQueryInfoKey(hKeyAccounts, NULL, NULL, NULL, &dwAcctSubKeys,
                         &cbMaxAcctSubKeyLen, NULL, NULL, NULL, NULL, NULL, NULL);

    if (ERROR_SUCCESS != retval)
        goto exit;

    memsize = sizeof(TCHAR) * cbMaxAcctSubKeyLen;

    if (!MemAlloc((LPVOID*)&lpszAccountName, memsize))
    {
        lpszAccountName = NULL;
        goto exit;
    }

    ZeroMemory(lpszAccountName, memsize);

    while (index < dwAcctSubKeys)
    {
        retval = RegEnumKey(hKeyAccounts, index, lpszAccountName, memsize);

        index++;

        if (retval == ERROR_SUCCESS)
        {
            retval = RegOpenKey(hKeyAccounts, lpszAccountName, &hKeyAccountName);
            if (retval == ERROR_SUCCESS)
            {
                cbData = sizeof(DWORD);
                retval = RegQueryValueEx(hKeyAccountName, c_szConnectionType, NULL, &DataType, (LPBYTE)&dwValue, &cbData);
                if (retval == ERROR_SUCCESS)
                {
                    if (dwValue == CONNECTION_TYPE_LAN)
                    {
                        dwValue = CONNECTION_TYPE_INETSETTINGS;
                        retval = RegSetValueEx(hKeyAccountName, c_szConnectionType, 0, REG_DWORD, (const BYTE *)&dwValue,
                                               sizeof(DWORD));
                    }
                }

                RegCloseKey(hKeyAccountName);
            }
        }
    }

    //Set this to one so, when we downgrade when we do backward migration based on this key value
    dwConnSettingsMigrated = 1;
    RegSetValueEx(hKeyAccounts, c_szConnSettingsMigrated, 0, REG_DWORD, (const BYTE*)&dwConnSettingsMigrated,
                  sizeof(DWORD));

exit:
    SafeMemFree(lpszAccountName);

    if (hKeyAccounts)
        RegCloseKey(hKeyAccounts);
}


//--------------------------------------------------------------------------
// ConvertToDBX
//--------------------------------------------------------------------------
void ConvertToDBX(void)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRootDir[MAX_PATH + MAX_PATH];
    CHAR            szSrcFile[MAX_PATH + MAX_PATH];
    CHAR            szDstFile[MAX_PATH + MAX_PATH];

    // Trace
    TraceCall("ConvertToDBX");

    // Get Root Directory
    IF_FAILEXIT(hr = GetStoreRootDirectory(szRootDir, ARRAYSIZE(szRootDir)));

    // Folders
    MakeFilePath(szRootDir, "folders.ods", "", szSrcFile, ARRAYSIZE(szSrcFile));
    MakeFilePath(szRootDir, "folders.dbx", "", szDstFile, ARRAYSIZE(szSrcFile));
    DeleteFile(szDstFile);
    MoveFile(szSrcFile, szDstFile);

    // Pop3uidl
    MakeFilePath(szRootDir, "pop3uidl.ods", "", szSrcFile, ARRAYSIZE(szSrcFile));
    MakeFilePath(szRootDir, "pop3uidl.dbx", "", szDstFile, ARRAYSIZE(szSrcFile));
    DeleteFile(szDstFile);
    MoveFile(szSrcFile, szDstFile);

    // Offline
    MakeFilePath(szRootDir, "Offline.ods", "", szSrcFile, ARRAYSIZE(szSrcFile));
    MakeFilePath(szRootDir, "Offline.dbx", "", szDstFile, ARRAYSIZE(szSrcFile));
    DeleteFile(szDstFile);
    MoveFile(szSrcFile, szDstFile);

exit:
    // Done
    return;
}

HRESULT MigrateStoreToV2(HKEY hkeyV2, LPTSTR pszSrc, DWORD cchSrc, LPTSTR pszDest, DWORD cchDest)
{
    HKEY    hkeyV1;
    BOOL    fMoved = FALSE;

    Assert(pszSrc);
    Assert(pszDest);
    Assert(cchSrc > 0);
    Assert(cchDest > 0);

    // Okay, this is the first time.  Let's see if a previous version exists.
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                      c_szRegRoot_V1,
                                      0,
                                      KEY_READ,
                                      &hkeyV1))
        {
        DWORD   dwType;

        // No need to worry about REG_EXPAND_SZ here as V1 didn't write it
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyV1,
                                             c_szRegStoreRootDir,
                                             NULL,
                                             &dwType,
                                             (LPBYTE)pszSrc,
                                             &cchSrc) && *pszSrc)
            {
            AssertSz(REG_EXPAND_SZ != dwType, "V1's store path is REG_EXPAND_SZ!");

            // Figure out new path
            GetDefaultStoreRoot(NULL, pszDest, cchDest);

            // Remember it
            RegSetValueEx(hkeyV2, c_szRegStoreRootDir,  NULL, REG_SZ, (LPBYTE)pszDest, (lstrlen(pszDest)+1) * sizeof(TCHAR));
            }

        RegCloseKey(hkeyV1);
        }

    return(S_OK);
}

static const LPCTSTR c_rgCommonSettings[] =
    {
    c_szRegAlwaysSuggest,
    c_szRegIgnoreNumbers,
    c_szRegIgnoreUpper,
    c_szRegIgnoreProtect,
    c_szRegCheckOnSend,
    c_szRegIgnoreDBCS,
    c_szRasConnDetails
    };

static const LPCTSTR c_rgMailSettings[] =
    {
    c_szOptNewMailSound,
    c_szPurgeWaste,
    c_szOptnSaveInSentItems,
    c_szRegIncludeMsg,
    c_szRegPollForMail,
    c_szRegSendImmediate,
    c_szRegSigType,
    c_szRegSigText,
    c_szRegSigFile,
    c_szMarkPreviewAsRead,
    c_szRegIndentChar,
    c_szLogSmtp,
    c_szLogPop3,
    c_szSmtpLogFile,
    c_szPop3LogFile
    };

static const LPCTSTR c_rgNewsSettings[] =
    {
    c_szRegDownload,
    c_szRegAutoExpand,
    c_szRegNotifyNewGroups,
    c_szRegMarkAllRead,
    c_szRegSigType,
    c_szRegSigText,
    c_szRegSigFile,
    c_szRegNewsNoteAdvRead,
    c_szRegNewsNoteAdvSend,
    c_szRegNewsFillPreview,
    c_szCacheDelMsgDays,
    c_szCacheRead,
    c_szCacheCompactPer
    };

// Copies values listed in ppszSettings from hkeyOld to hkey
void MigrateNode(HKEY hkey, HKEY hkeyOld, LPCTSTR pszSub, LPCTSTR *ppszSettings, int cSettings)
    {
    int i;
    HKEY hkeyOldT, hkeyT;
    DWORD cValues, cbMax, cb, type;
    BYTE *pb;

    Assert(hkey != NULL);
    Assert(hkeyOld != NULL);
    Assert(ppszSettings != NULL);
    Assert(cSettings > 0);

    if (pszSub != NULL)
        {
        if (ERROR_SUCCESS != RegOpenKeyEx(hkeyOld, pszSub, 0, KEY_READ, &hkeyOldT))
            return;
        hkeyOld = hkeyOldT;

        if (ERROR_SUCCESS != RegCreateKeyEx(hkey, pszSub, NULL, NULL,
                                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyT, &cb))
            {
            RegCloseKey(hkeyOldT);
            return;
            }
        hkey = hkeyT;
        }

    if (ERROR_SUCCESS == RegQueryInfoKey(hkeyOld, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                                            &cValues, &cbMax, NULL, NULL) &&
        cValues > 0 &&
        cbMax > 0 &&
        MemAlloc((void **)&pb, cbMax))
        {
        for (i = 0; i < cSettings; i++)
            {
            cb = cbMax;
            if (ERROR_SUCCESS == RegQueryValueEx(hkeyOld, *ppszSettings, NULL, &type, pb, &cb))
                RegSetValueEx(hkey, *ppszSettings, 0, type, pb, cb);

            ppszSettings++;
            }

        MemFree(pb);
        }

    if (pszSub != NULL)
        {
        RegCloseKey(hkeyT);
        RegCloseKey(hkeyOldT);
        }
    }

BOOL MigrateSignature(HKEY hkey, HKEY hkeyOld, DWORD dwSig, BOOL fMail)
    {
    BOOL fMigrate;
    DWORD dwSigType, dwSigOpt, cb, type;
    HKEY hkeySig;
    char *psz, sz[MAX_PATH];

    fMigrate = FALSE;

    dwSigType = LOWORD(dwSig);
    dwSigOpt = HIWORD(dwSig);

    if (ERROR_SUCCESS == RegQueryValueEx(hkeyOld, (dwSigType == 2) ? c_szRegSigFile : c_szRegSigText, NULL, &type, NULL, &cb) &&
        cb > 1 &&
        MemAlloc((void **)&psz, cb))
        {
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyOld, (dwSigType == 2) ? c_szRegSigFile : c_szRegSigText, NULL, &type, (LPBYTE)psz, &cb))
            {
            wsprintf(sz, c_szPathFileFmt, c_szSigs, fMail ? c_szMail : c_szNews);
            if (ERROR_SUCCESS == RegCreateKeyEx(hkey, sz, NULL, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeySig, &type))
                {
                if (type == REG_CREATED_NEW_KEY)
                    {
                    // name
                    AthLoadString(fMail ? idsMailSig : idsNewsSig, sz, ARRAYSIZE(sz));
                    RegSetValueEx(hkeySig, c_szSigName, 0, REG_SZ, (LPBYTE)sz, lstrlen(sz) + 1);

                    // text/file
                    RegSetValueEx(hkeySig, (dwSigType == 2) ? c_szSigFile : c_szSigText, 0, REG_SZ, (LPBYTE)psz, cb);

                    // type
                    RegSetValueEx(hkeySig, c_szSigType, 0, REG_DWORD, (LPBYTE)&dwSigType, sizeof(dwSigType));

                    fMigrate = TRUE;
                    }

                RegCloseKey(hkeySig);
                }
            }

        MemFree(psz);
        }

    return(fMigrate);
    }

static const TCHAR c_szSettingsMigrated[] = TEXT("Settings Migrated");

void MigrateSettings(HKEY hkey)
    {
    HKEY hkeySrc, hkeyDst, hkeyOld;
    DWORD dw, cb, type, dwMigrate, dwSig, dwFlags;
    TCHAR   szPath[MAX_PATH];

    cb = sizeof(dwMigrate);
    if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szSettingsMigrated, NULL, &type, (LPBYTE)&dwMigrate, &cb))
        dwMigrate = 0;

    // v4.0 migration
    if (dwMigrate == 0)
        {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegRoot_V1, 0, KEY_READ, &hkeyOld))
            {
            MigrateNode(hkey, hkeyOld, NULL, (LPCTSTR *)c_rgCommonSettings, ARRAYSIZE(c_rgCommonSettings));
            MigrateNode(hkey, hkeyOld, c_szMail, (LPCTSTR *)c_rgMailSettings, ARRAYSIZE(c_rgMailSettings));
            MigrateNode(hkey, hkeyOld, c_szNews, (LPCTSTR *)c_rgNewsSettings, ARRAYSIZE(c_rgNewsSettings));

            RegCloseKey(hkeyOld);
            }

        // copy the inbox rules
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szInboxRulesPath_V1, 0, KEY_READ, &hkeySrc))
            {
            lstrcpy(szPath, c_szRegRoot);
            lstrcat(szPath, c_szInboxRulesPath);

            if (ERROR_SUCCESS == RegCreateKeyEx(MU_GetCurrentUserHKey(), szPath, 0, NULL,
                                    REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkeyDst, &dw))
                {
                if (dw != REG_OPENED_EXISTING_KEY)
                    CopyRegistry(hkeySrc, hkeyDst);
                RegCloseKey(hkeyDst);
                }

            RegCloseKey(hkeySrc);
            }

        dwMigrate = 1;
        }

    // v5.0 migration
    if (dwMigrate == 1)
        {
        dwFlags = 0xffffffff;

        // mail signature
        if (ERROR_SUCCESS == RegOpenKeyEx(hkey, c_szMail, 0, KEY_READ, &hkeyOld))
            {
            cb = sizeof(dwSig);
            if (ERROR_SUCCESS == RegQueryValueEx(hkeyOld, c_szRegSigType, NULL, &type, (LPBYTE)&dwSig, &cb) &&
                LOWORD(dwSig) != 0)
                {
                if (MigrateSignature(hkey, hkeyOld, dwSig, TRUE))
                    dwFlags = HIWORD(dwSig);
                }

            RegCloseKey(hkeyOld);
            }

        // news signature
        if (ERROR_SUCCESS == RegOpenKeyEx(hkey, c_szNews, 0, KEY_READ, &hkeyOld))
            {
            cb = sizeof(dwSig);
            if (ERROR_SUCCESS == RegQueryValueEx(hkeyOld, c_szRegSigType, NULL, &type, (LPBYTE)&dwSig, &cb) &&
                LOWORD(dwSig) != 0)
                {
                if (MigrateSignature(hkey, hkeyOld, dwSig, FALSE) &&
                    dwFlags == 0xffffffff)
                    dwFlags = HIWORD(dwSig);
                }

            RegCloseKey(hkeyOld);
            }

        cb = sizeof(dw);
        if (dwFlags != 0xffffffff &&
            ERROR_SUCCESS != RegQueryValueEx(hkey, c_szSigFlags, NULL, &type, (LPBYTE)&dw, &cb))
            {
            RegSetValueEx(hkey, c_szSigFlags, 0, REG_DWORD, (LPBYTE)&dwFlags, sizeof(dwFlags));
            }
        }
    }

const static char c_szRegImnMail[] = {"Software\\Microsoft\\Internet Mail and News\\Mail"};
const static char c_szMailPOP3Path[] = {"Software\\Microsoft\\Internet Mail and News\\Mail\\POP3"};
const static char c_szMailSMTPPath[] = {"Software\\Microsoft\\Internet Mail and News\\Mail\\SMTP"};
const static char c_szRegImnNews[] = {"Software\\Microsoft\\Internet Mail and News\\News"};

const static char c_szDefaultSmtpServer[] = {"Default SMTP Server"};
const static char c_szDefaultPop3Server[] = {"Default POP3 Server"};
const static char c_szRegConnectType[] = {"Connection Type"};
const static char c_szRegRasPhonebookEntry[] = {"RAS Phonebook Entry"};
const static char c_szRegMailConnectType[] = {"Mail Connection Type"};
const static char c_szSenderOrg[] = {"Sender Organization"};
const static char c_szSenderEMail[] = {"Sender EMail"};
const static char c_szSenderReplyTo[] = {"Reply To"};
const static char c_szSendTimeout[] = {"SendTimeout"};
const static char c_szRecvTimeout[] = {"RecvTimeout"};
const static char c_szPort[] = {"Port"};
const static char c_szRegBreakMessages[] = {"Break Message Size (KB)"};
const static char c_szRegAccountName[] = {"Account Name"};
const static char c_szRegUseSicily[] = {"Use Sicily"};
const static char c_szRegSecureConnect[] = {"Secure Connection"};
const static char c_szRegServerTimeout[] = {"Timeout"};
const static char c_szRegServerPort[] = {"NNTP Port"};
const static char c_szRegUseDesc[] = {"Use Group Descriptions"};
const static char c_szRegNewsConnectFlags[] = {"Connection Flags"};
const static char c_szRegDefServer[] = {"DefaultServer"};
const static char c_szLeaveOnServer[] = {"LeaveMailOnServer"};
const static char c_szRemoveDeleted[] = {"RemoveOnClientDelete"};
const static char c_szRemoveExpired[] = {"RemoveExpire"};
const static char c_szExpireDays[] = {"ExpireDays"};
const static char c_szRegAccount[] = {"Account"};

HRESULT MigrateAccounts()
    {
    HKEY hkeyPop3, hkeySmtp, hkeyMail, hkeyNews;
    HRESULT hr = S_OK;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegImnMail, 0, KEY_ALL_ACCESS, &hkeyMail) != ERROR_SUCCESS)
        hkeyMail = NULL;
    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegImnNews, 0, KEY_ALL_ACCESS, &hkeyNews) != ERROR_SUCCESS)
        hkeyNews = NULL;

    if (hkeyMail != NULL || hkeyNews != NULL)
    {
        // Create account manger because CSubList depends on g_pAcctMan
        Assert(g_pAcctMan == NULL);
        // Only ever migrate to DEFAULT user!
        hr = AcctUtil_CreateAccountManagerForIdentity((GUID *)&UID_GIBC_DEFAULT_USER, &g_pAcctMan);
        if (SUCCEEDED(hr))
        {
            // Try to open: HKCU\Software\Microsoft\IMN\Mail\POP3
            if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szMailPOP3Path, 0, KEY_ALL_ACCESS, &hkeyPop3) == ERROR_SUCCESS)
            {
                // Try to open: HKCU\Software\Microsoft\IMN\Mail\SMTP
                if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szMailSMTPPath, 0, KEY_ALL_ACCESS, &hkeySmtp) == ERROR_SUCCESS)
                {
                    hr = MigrateMailServers(g_pAcctMan, hkeyMail, hkeyPop3, hkeySmtp);
                    Assert(SUCCEEDED(hr));

                    RegCloseKey(hkeySmtp);
                }

                RegCloseKey(hkeyPop3);
            }

            if (hkeyNews != NULL)
            {
                hr = MigrateNewsServers(g_pAcctMan, hkeyNews);
                Assert(SUCCEEDED(hr));
            }

            g_pAcctMan->Release();
            g_pAcctMan = NULL;
        }

        if (hkeyMail != NULL)
            RegCloseKey(hkeyMail);
        if (hkeyNews != NULL)
            RegCloseKey(hkeyNews);
    }

    return(hr);
}

typedef struct tagACCTMIGRATEMAP
    {
    LPCSTR szRegValue;
    DWORD dwProp;
    } ACCTMIGRATEMAP;

typedef const ACCTMIGRATEMAP *LPCMIGRATEMAP;

HRESULT MigrateAccountSettings(IImnAccount *pAccount, HKEY hkey, LPCMIGRATEMAP pMap, int cMap)
    {
    HRESULT hr;
    int i;
    LPBYTE pb;
    PROPTYPE ptype;
    DWORD dw, cb, type;
    char sz[512];

    Assert(pAccount != NULL);
    Assert(pMap != NULL);
    Assert(cMap > 0);

    for (i = 0; i < cMap; i++, pMap++)
        {
        ptype = PROPTAG_TYPE(pMap->dwProp);
        Assert(ptype == TYPE_STRING || ptype == TYPE_DWORD || ptype == TYPE_BOOL || ptype == TYPE_PASS);

        if (ptype == TYPE_STRING || ptype == TYPE_PASS)
            {
            cb = sizeof(sz);
            pb = (LPBYTE)sz;
            }
        else
            {
            cb = sizeof(dw);
            pb = (LPBYTE)&dw;
            }

        if (RegQueryValueEx(hkey, pMap->szRegValue, 0, &type, pb, &cb) == ERROR_SUCCESS)
            {
            if (ptype == TYPE_PASS)
            {
                // IMN's Password is stored as ANSI in a REG_BINARY with no NULL terminator
                // Be sure to let MigrateBase64EncodedPassword know how long the password is
                hr = MigrateBase64EncodedPassword(sz, cb, pMap->dwProp, pAccount);
            }
            else
                hr = pAccount->SetProp(pMap->dwProp, pb, cb);
            if (FAILED(hr))
                break;
            }
        }

    return(hr);
    }

static const ACCTMIGRATEMAP c_rgMailMap[] =
    {
    {c_szRegConnectType, AP_RAS_CONNECTION_TYPE},
    {c_szRegRasPhonebookEntry, AP_RAS_CONNECTOID},
    {c_szRegMailConnectType, AP_RAS_CONNECTION_FLAGS},
    {c_szSenderName, AP_SMTP_DISPLAY_NAME},
    {c_szSenderOrg, AP_SMTP_ORG_NAME},
    {c_szSenderEMail, AP_SMTP_EMAIL_ADDRESS},
    {c_szSenderReplyTo, AP_SMTP_REPLY_EMAIL_ADDRESS},
    };

static const ACCTMIGRATEMAP c_rgPop3Map[] =
    {
    {c_szSendTimeout, AP_SMTP_TIMEOUT},
    {c_szRecvTimeout, AP_POP3_TIMEOUT},
    {c_szPort, AP_POP3_PORT},
    {c_szLeaveOnServer, AP_POP3_LEAVE_ON_SERVER},
    {c_szRemoveDeleted, AP_POP3_REMOVE_DELETED},
    {c_szRemoveExpired, AP_POP3_REMOVE_EXPIRED},
    {c_szExpireDays, AP_POP3_EXPIRE_DAYS},
    {c_szRegAccount, AP_POP3_USERNAME},
    {c_szRegUseSicily, AP_POP3_USE_SICILY},
    {c_szPassword, AP_POP3_PASSWORD},
    };

static const ACCTMIGRATEMAP c_rgSmtpMap[] =
    {
    {c_szPort, AP_SMTP_PORT}
    };

HRESULT MigrateMailAccountSettings(IImnAccountManager *pAcctMan, HKEY hkeyMail, HKEY hkeyPop3Server,
                                   HKEY hkeySmtpServer, LPSTR szDefPop3Server, LPSTR szDefSmtpServer)
    {
    DWORD dw, cb;
    HRESULT hr;
    char sz[CCHMAX_ACCOUNT_NAME];
    IImnAccount *pAccount;

    Assert(pAcctMan != NULL);
    Assert(szDefPop3Server != NULL);
    Assert(szDefSmtpServer != NULL);

    hr = pAcctMan->CreateAccountObject(ACCT_MAIL, &pAccount);
    if (FAILED(hr))
        return(hr);

    CHECKHR(hr = pAccount->SetPropSz(AP_SMTP_SERVER, szDefSmtpServer));

    CHECKHR(hr = pAccount->SetPropSz(AP_POP3_SERVER, szDefPop3Server));

    // Set Friendly Name
    lstrcpy(sz, szDefPop3Server);
    CHECKHR(hr = pAcctMan->GetUniqueAccountName(sz, ARRAYSIZE(sz)));
    CHECKHR(hr = pAccount->SetPropSz(AP_ACCOUNT_NAME, sz));

    cb = sizeof(dw);
    if (RegQueryValueEx(hkeyMail, c_szRegBreakMessages, 0, NULL, (LPBYTE)&dw, &cb) == ERROR_SUCCESS &&
        dw != 0xffffffff)
        {
        // AP_SPLITMSGS
        CHECKHR(hr = pAccount->SetPropDw(AP_SMTP_SPLIT_MESSAGES, TRUE));

        // AP_SPLITSIZE
        CHECKHR(hr = pAccount->SetPropDw(AP_SMTP_SPLIT_SIZE, dw));
        }

    CHECKHR(hr = MigrateAccountSettings(pAccount, hkeyMail, c_rgMailMap, ARRAYSIZE(c_rgMailMap)));
    CHECKHR(hr = MigrateAccountSettings(pAccount, hkeyPop3Server, c_rgPop3Map, ARRAYSIZE(c_rgPop3Map)));
    CHECKHR(hr = MigrateAccountSettings(pAccount, hkeySmtpServer, c_rgSmtpMap, ARRAYSIZE(c_rgSmtpMap)));

    // Save Account Changes
    hr = pAccount->SaveChanges();

exit:
    pAccount->Release();

    return(hr);
    }

// Note: This migrates only the default server, not un-supported multi servers
HRESULT MigrateMailServers(IImnAccountManager *pAcctMan, HKEY hkeyMail, HKEY hkeyPop3, HKEY hkeySmtp)
    {
    char szDefSmtpServer[CCHMAX_SERVER_NAME],
         szDefPop3Server[CCHMAX_SERVER_NAME];
    ULONG cb;
    DWORD dw;
    HKEY hkeyPop3Server = NULL,
         hkeySmtpServer = NULL;
    BOOL fSmtpMigrated = FALSE,
         fPop3Migrated = FALSE;
    HRESULT hr = S_OK;

    Assert(pAcctMan != NULL);
    Assert(hkeyMail != NULL);
    Assert(hkeyPop3 != NULL);
    Assert(hkeySmtp != NULL);

    // Get Default SMTP Server
    cb = sizeof(szDefSmtpServer);
    if (RegQueryValueEx(hkeyMail, c_szDefaultSmtpServer, 0, NULL, (LPBYTE)szDefSmtpServer, &cb) == ERROR_SUCCESS &&
        !FIsEmpty(szDefSmtpServer))
        {
        // If we have a default smtp sever, lets open the key
        RegOpenKeyEx(hkeySmtp, szDefSmtpServer, 0, KEY_ALL_ACCESS, &hkeySmtpServer);
        }

    // Get Default POP3 Server
    cb = sizeof(szDefPop3Server);
    if (RegQueryValueEx(hkeyMail, c_szDefaultPop3Server, 0, NULL, (LPBYTE)szDefPop3Server, &cb) == ERROR_SUCCESS &&
        !FIsEmpty(szDefPop3Server))
        {
        // If we have a default pop3 sever, lets open the key
        RegOpenKeyEx(hkeyPop3, szDefPop3Server, 0, KEY_ALL_ACCESS, &hkeyPop3Server);
        }

    // If we couldn't open the pop3 server, lets look in the registry and use the first server
    if (hkeyPop3Server == NULL)
        {
        // Enumerate and open the first server in the list
        cb = sizeof(szDefPop3Server);
        if (RegEnumKeyEx(hkeyPop3, 0, szDefPop3Server, &cb, 0, NULL, NULL, NULL) == ERROR_SUCCESS)
            RegOpenKeyEx(hkeyPop3, szDefPop3Server, 0, KEY_ALL_ACCESS, &hkeyPop3Server);
        }

    // If we couldn't open the pop3 server, lets look in the registry and use the first server
    if (hkeySmtpServer == NULL)
        {
        // Enumerate and open the first server in list
        cb = sizeof(szDefSmtpServer);
        if (RegEnumKeyEx(hkeySmtp, 0, szDefSmtpServer, &cb, 0, NULL, NULL, NULL) == ERROR_SUCCESS)
            RegOpenKeyEx(hkeySmtp, szDefSmtpServer, 0, KEY_ALL_ACCESS, &hkeySmtpServer);
        }

    if (hkeySmtpServer != NULL)
        {
        cb = sizeof(fSmtpMigrated);
        RegQueryValueEx(hkeySmtpServer, c_szMigrated, 0, NULL, (LPBYTE)&fSmtpMigrated, &cb);

        if (hkeyPop3Server != NULL)
            {
            cb = sizeof(fPop3Migrated);
            RegQueryValueEx(hkeyPop3Server, c_szMigrated, 0, NULL, (LPBYTE)&fPop3Migrated, &cb);

            if (!fPop3Migrated && !fSmtpMigrated)
                {
                hr = MigrateMailAccountSettings(pAcctMan, hkeyMail, hkeyPop3Server,
                                        hkeySmtpServer, szDefPop3Server, szDefSmtpServer);
                if (SUCCEEDED(hr))
                    {
                    fSmtpMigrated = TRUE;
                    RegSetValueEx(hkeySmtpServer, c_szMigrated, 0, REG_DWORD, (LPBYTE)&fSmtpMigrated, sizeof(fSmtpMigrated));

                    fPop3Migrated = TRUE;
                    RegSetValueEx(hkeyPop3Server, c_szMigrated, 0, REG_DWORD, (LPBYTE)&fPop3Migrated, sizeof(fPop3Migrated));
                    }
                }

            RegCloseKey(hkeyPop3Server);
            }

        RegCloseKey(hkeySmtpServer);
        }

    return(S_OK);
    }

static const ACCTMIGRATEMAP c_rgNewsMap[] =
    {
    {c_szSenderName, AP_NNTP_DISPLAY_NAME},
    {c_szSenderOrg, AP_NNTP_ORG_NAME},
    {c_szSenderEMail, AP_NNTP_EMAIL_ADDRESS},
    {c_szSenderReplyTo, AP_NNTP_REPLY_EMAIL_ADDRESS},
    };

static const ACCTMIGRATEMAP c_rgNewsServerMap[] =
    {
    {c_szRegAccountName, AP_NNTP_USERNAME},
    {c_szRegUseSicily, AP_NNTP_USE_SICILY},
    {c_szRegSecureConnect, AP_NNTP_SSL},
    {c_szRegServerTimeout, AP_NNTP_TIMEOUT},
    {c_szRegServerPort, AP_NNTP_PORT},
    {c_szRegUseDesc, AP_NNTP_USE_DESCRIPTIONS},
    {c_szRegConnectType, AP_RAS_CONNECTION_TYPE},
    {c_szRegRasPhonebookEntry, AP_RAS_CONNECTOID},
    {c_szRegNewsConnectFlags, AP_RAS_CONNECTION_FLAGS},
    {c_szPassword, AP_NNTP_PASSWORD},
    };

HRESULT MigrateNewsAccountSettings(IImnAccountManager *pAcctMan, HKEY hkeyNews, HKEY hkeyServer, LPSTR szServer, BOOL fDefault)
    {
    IImnAccount *pAccount;
    char sz[CCHMAX_ACCOUNT_NAME], szNewsDir[MAX_PATH], szDataDir[MAX_PATH];
    HRESULT hr;
    DWORD cb;

    Assert(pAcctMan != NULL);
    Assert(szServer != NULL);

    hr = pAcctMan->CreateAccountObject(ACCT_NEWS, &pAccount);
    if (FAILED(hr))
        return(hr);

    // AP_NNTP_SERVER
    CHECKHR(hr = pAccount->SetPropSz(AP_NNTP_SERVER, szServer));

    // Set Friendly Name
    lstrcpy(sz, szServer);
    CHECKHR(hr = pAcctMan->GetUniqueAccountName(sz, ARRAYSIZE(sz)));
    CHECKHR(hr = pAccount->SetPropSz(AP_ACCOUNT_NAME, sz));

    CHECKHR(hr = MigrateAccountSettings(pAccount, hkeyNews, c_rgNewsMap, ARRAYSIZE(c_rgNewsMap)));
    CHECKHR(hr = MigrateAccountSettings(pAccount, hkeyServer, c_rgNewsServerMap, ARRAYSIZE(c_rgNewsServerMap)));

    CHECKHR(hr = pAccount->SaveChanges());

    if (fDefault)
        pAccount->SetAsDefault();

exit:
    pAccount->Release();

    return(hr);
    }

HRESULT MigrateNewsServers(IImnAccountManager *pAcctMan, HKEY hkeyNews)
    {
    char szDefNntpServer[CCHMAX_SERVER_NAME],
         szServer[CCHMAX_SERVER_NAME];
    HKEY hkeyAthena = NULL, hkeyServer = NULL;
    DWORD cb, dw, i;
    BOOL fMigrated, fSetDefault, fDefault;
    LONG lResult;
    HRESULT hr = S_OK;

    Assert(pAcctMan != NULL);
    Assert(hkeyNews != NULL);

    fSetDefault = FALSE;
    hr = pAcctMan->GetDefaultAccountName(ACCT_NEWS, szServer, ARRAYSIZE(szServer));
    if (FAILED(hr))
        {
        // Query for the default news account
        cb = sizeof(szDefNntpServer);
        if (RegQueryValueEx(hkeyNews, c_szRegDefServer, 0, NULL, (LPBYTE)szDefNntpServer, &cb) == ERROR_SUCCESS &&
            !FIsEmpty(szDefNntpServer))
            fSetDefault = TRUE;
        }

    // Enumerate through the keys
    for (i = 0; ; i++)
        {
        // Enumerate Friendly Names
        cb = sizeof(szServer);
        lResult = RegEnumKeyEx(hkeyNews, i, szServer, &cb, 0, NULL, NULL, NULL);

        // No more items
        if (lResult == ERROR_NO_MORE_ITEMS)
            break;

        // Error, lets move onto the next account
        if (lResult != ERROR_SUCCESS)
            continue;

        // Lets open they server key
        if (RegOpenKeyEx(hkeyNews, szServer, 0, KEY_ALL_ACCESS, &hkeyServer) != ERROR_SUCCESS)
            continue;

        // Has this server been migrated yet ?
        cb = sizeof(fMigrated);
        if (RegQueryValueEx(hkeyServer, c_szMigrated, 0, NULL, (LPBYTE)&fMigrated, &cb) != ERROR_SUCCESS)
            fMigrated = FALSE;

        // If not migrated
        if (!fMigrated)
            {
            fDefault = (fSetDefault && (0 == lstrcmpi(szServer, szDefNntpServer)));

            hr = MigrateNewsAccountSettings(pAcctMan, hkeyNews, hkeyServer, szServer, fDefault);
            if (SUCCEEDED(hr))
                {
                fMigrated = TRUE;
                RegSetValueEx(hkeyServer, c_szMigrated, 0, REG_DWORD, (LPBYTE)&fMigrated, sizeof(fMigrated));
                }

            if (fDefault)
                fSetDefault = FALSE;
            }

        RegCloseKey(hkeyServer);
        }

    return(S_OK);
    }

HRESULT MigrateBase64EncodedPassword(LPCSTR pszBase64, DWORD cch, DWORD dwPropId, IImnAccount *pAccount)
    {
    HRESULT          hr=S_OK;
    IStream         *pstmBase64=NULL;
    IStream         *pstmDecoded=NULL;
    IMimeBody       *pBody=NULL;
    LPSTR            pszPassword=NULL;

    // Invalid Arg
    Assert(pszBase64 && pAccount);

    // Create a mime body
    CHECKHR(hr = MimeOleCreateBody(&pBody));

    // InitNew
    CHECKHR(hr = pBody->InitNew());

    // Create a pstmBase64 Stream
    CHECKHR(hr = CreateStreamOnHGlobal(NULL, TRUE, &pstmBase64));

    // Write the pszBase64 into this
    CHECKHR(hr = pstmBase64->Write(pszBase64, cch * sizeof(*pszBase64), NULL));

    // Commit
    CHECKHR(hr = pstmBase64->Commit(STGC_DEFAULT));

    // Rewind it
    CHECKHR(hr = HrRewindStream(pstmBase64));

    // Set it into IMimeBody
    CHECKHR(hr = pBody->SetData(IET_BASE64, NULL, NULL, IID_IStream, (LPVOID)pstmBase64));

    // Get the decoded stream
    CHECKHR(hr = pBody->GetData(IET_DECODED, &pstmDecoded));

    // Convert to string
    CHECKALLOC(pszPassword = PszFromANSIStreamA(pstmDecoded));

    // Store the property
    CHECKHR(hr = pAccount->SetPropSz(dwPropId, pszPassword));

exit:
    // Cleanup
    SafeRelease(pstmBase64);
    SafeRelease(pstmDecoded);
    SafeRelease(pBody);
    SafeMemFree(pszPassword);

    return(hr);
    }

static const char c_szAccessColors[] = "Always Use My Colors";
static const char c_szAccessFontFace[] = "Always Use My Font Face";
static const char c_szAccessFontSize[] = "Always Use My Font Size";
static const char c_szAccessSysCaret[] = "Move System Caret";

void MigrateAccessibilityKeys()
    {
    HKEY hkeyExplorer, hkeyAthena;
    char szValue[MAX_PATH];
	DWORD cbData, dw;

    // Migrate keys from HKCU\SW\MS\InternetExplorer\Settings
	if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szIESettingsPath, 0, KEY_QUERY_VALUE, &hkeyExplorer) == ERROR_SUCCESS)
        {
        lstrcpy(szValue, c_szRegTriSettings);
        if (RegCreateKeyEx(MU_GetCurrentUserHKey(), szValue, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyAthena, &dw) == ERROR_SUCCESS)
	        {
			cbData = sizeof(DWORD);
			if (RegQueryValueEx(hkeyExplorer, c_szAccessColors, NULL, NULL, (LPBYTE)&dw, &cbData) == ERROR_SUCCESS)
				RegSetValueEx (hkeyAthena, c_szAccessColors, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));

			cbData = sizeof(DWORD);
			if (RegQueryValueEx(hkeyExplorer, c_szAccessFontFace, NULL, NULL, (LPBYTE)&dw, &cbData) == ERROR_SUCCESS)
				RegSetValueEx (hkeyAthena, c_szAccessFontFace, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));

			cbData = sizeof(DWORD);
			if (RegQueryValueEx(hkeyExplorer, c_szAccessFontSize, NULL, NULL, (LPBYTE)&dw, &cbData) == ERROR_SUCCESS)
				RegSetValueEx (hkeyAthena, c_szAccessFontSize, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));

    		RegCloseKey(hkeyAthena);
			}

		RegCloseKey(hkeyExplorer);
		}

    // Migrate keys from HKCU\SW\MS\InternetExplorer\Main
    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegKeyIEMain, 0, KEY_QUERY_VALUE, &hkeyExplorer) == ERROR_SUCCESS)
        {
        lstrcpy(szValue, c_szRegTriMain);
        if (RegCreateKeyEx(MU_GetCurrentUserHKey(), szValue, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyAthena, &dw) == ERROR_SUCCESS)
			{
			cbData = MAX_PATH;
			if (RegQueryValueEx(hkeyExplorer, c_szAccessSysCaret, NULL, NULL, (LPBYTE)&szValue, &cbData) == ERROR_SUCCESS)
				RegSetValueEx(hkeyAthena, c_szAccessSysCaret, 0, REG_SZ, (LPBYTE)szValue, cbData);

            RegCloseKey(hkeyAthena);
            }

        RegCloseKey(hkeyExplorer);
		}
    }

ULONG UlBuildCritText(HKEY hKeyRoot, LPCSTR szKeyName, CRIT_TYPE type, IOECriteria * pICrit)
{
    ULONG           ulRet = 0;
    DWORD           cbData = 0;
    LONG            lErr = ERROR_SUCCESS;
    LPSTR           pszReg = NULL;
    LPSTR           pszVal = NULL;
    LPSTR           pszTokens = NULL;
    LPSTR           pszWalk = NULL;
    LPSTR           pszString = NULL;
    CRIT_ITEM       critItem;

    // Initialize out local vars
    ZeroMemory(&critItem, sizeof(critItem));

    // Get the key string from the registry
    cbData = 0;
    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        ulRet = 0;
        goto exit;
    }

    if (0 == cbData)
    {
        ulRet = 0;
        goto exit;
    }

    if (FAILED(HrAlloc((LPVOID *) &pszReg, cbData)))
    {
        ulRet = 0;
        goto exit;
    }

    SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, (LPVOID) pszReg, &cbData);

    // If it is empty, then we're done
    if (FALSE != FIsEmptyA(pszReg))
    {
        ulRet = 0;
        goto exit;
    }

    // The strings are supposed to be in lowercase
    CharLower(pszReg);

    // Break up the strings into each search token
    pszTokens = SzGetSearchTokens(pszReg);
    if (NULL == pszTokens)
    {
        ulRet = 0;
        goto exit;
    }

    // Count the space needed for the final string
    cbData = 0;
    for (pszWalk = pszTokens; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        // Skip empty strings
        if (FALSE == FIsEmptyA(pszWalk))
        {
            cbData += lstrlen(pszWalk) + 1;
        }
    }

    // Nothing to add
    if (0 == cbData)
    {
        ulRet = 0;
        goto exit;
    }

    // Add space to hold the string terminator
    cbData += 2;

    // Allocate space to hold the final string
    if (FAILED(HrAlloc((LPVOID *) &pszVal, cbData)))
    {
        ulRet = 0;
        goto exit;
    }

    // Build up the string
    pszString = pszVal;
    for (pszWalk = pszTokens; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        // Skip empty strings
        if (FALSE == FIsEmptyA(pszWalk))
        {
            lstrcpy(pszString, pszWalk);
            pszString += lstrlen(pszString) + 1;
        }
    }

    // Terminate the string
    pszString[0] = '\0';
    pszString[1] = '\0';

    // Build up the criteria
    critItem.type = type;
    critItem.logic = CRIT_LOGIC_NULL;
    critItem.dwFlags = CRIT_FLAG_MULTIPLEAND;
    critItem.propvar.vt = VT_BLOB;
    critItem.propvar.blob.cbSize = cbData;
    critItem.propvar.blob.pBlobData = (BYTE *) pszVal;

    // Add it to the criteria object
    if (FAILED(pICrit->AppendCriteria(0, CRIT_LOGIC_AND, &critItem, 1, &ulRet)))
    {
        ulRet = 0;
        goto exit;
    }


exit:
    SafeMemFree(pszTokens);
    SafeMemFree(pszVal);
    SafeMemFree(pszReg);
    return ulRet;
}

ULONG UlBuildCritAcct(HKEY hKeyRoot, LPCSTR szKeyName, CRIT_TYPE type, IOECriteria * pICrit)
{
    ULONG           ulRet = 0;
    DWORD           cbData = 0;
    LONG            lErr = ERROR_SUCCESS;
    LPSTR           pszVal = NULL;
    CRIT_ITEM       critItem;
    IImnAccount *   pAccount = NULL;
    CHAR            szAccount[CCHMAX_ACCOUNT_NAME];

    // Initialize out local vars
    ZeroMemory(&critItem, sizeof(critItem));

    // Get the key string from the registry
    cbData = 0;
    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        ulRet = 0;
        goto exit;
    }

    if (0 == cbData)
    {
        ulRet = 0;
        goto exit;
    }

    if (FAILED(HrAlloc((LPVOID *) &pszVal, cbData)))
    {
        ulRet = 0;
        goto exit;
    }

    SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, (LPVOID) pszVal, &cbData);

    // If it is empty, then we're done
    if (FALSE != FIsEmptyA(pszVal))
    {
        ulRet = 0;
        goto exit;
    }

    if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, pszVal, &pAccount)))
    {
        if (SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_ID, szAccount, sizeof(szAccount))))
        {
            SafeMemFree(pszVal);
            pszVal = PszDupA(szAccount);
            if (NULL == pszVal)
            {
                ulRet = 0;
                goto exit;
            }
        }
    }

    // Build up the criteria
    critItem.type = type;
    critItem.logic = CRIT_LOGIC_NULL;
    critItem.dwFlags = CRIT_FLAG_DEFAULT;
    critItem.propvar.vt = VT_LPSTR;
    critItem.propvar.pszVal = pszVal;

    // Add it to the criteria object
    if (FAILED(pICrit->AppendCriteria(0, CRIT_LOGIC_AND, &critItem, 1, &ulRet)))
    {
        ulRet = 0;
        goto exit;
    }

exit:
    SafeMemFree(pszVal);
    SafeRelease(pAccount);
    return ulRet;
}
ULONG UlBuildCritAddr(HKEY hKeyRoot, LPCSTR szKeyName, CRIT_TYPE type, IOECriteria * pICrit)
{
    ULONG           ulRet = 0;
    DWORD           cbData = 0;
    LONG            lErr = ERROR_SUCCESS;
    CRIT_ITEM       critItem;
    LPSTR           pszReg = NULL;
    LPSTR           pszVal = NULL;
    LPSTR           pszTokens = NULL;
    LPSTR           pszWalk = NULL;
    LPSTR           pszString = NULL;

    // Initialize out local vars
    ZeroMemory(&critItem, sizeof(critItem));

    // Get the key string from the registry
    cbData = 0;
    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        ulRet = 0;
        goto exit;
    }

    if (0 == cbData)
    {
        ulRet = 0;
        goto exit;
    }

    if (FAILED(HrAlloc((LPVOID *) &(pszReg), cbData)))
    {
        ulRet = 0;
        goto exit;
    }

    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, (LPVOID) pszReg, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        ulRet = 0;
        goto exit;
    }

    // If it is empty, then we're done
    if (FALSE != FIsEmptyA(pszReg))
    {
        ulRet = 0;
        goto exit;
    }

    // The strings are supposed to be in lowercase
    CharLower(pszReg);

    // Break up the strings into each search token
    pszTokens = SzGetSearchTokens(pszReg);
    if (NULL == pszTokens)
    {
        ulRet = 0;
        goto exit;
    }

    // Count the space needed for the final string
    cbData = 0;
    for (pszWalk = pszTokens; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        // Skip empty addresses
        if (FALSE == FIsEmptyA(pszWalk))
        {
            cbData += lstrlen(pszWalk) + 1;
        }
    }

    // Nothing to add
    if (0 == cbData)
    {
        ulRet = 0;
        goto exit;
    }

    // Add space to hold the string terminator
    cbData += 2;

    // Allocate space to hold the final string
    if (FAILED(HrAlloc((LPVOID *) &pszVal, cbData)))
    {
        ulRet = 0;
        goto exit;
    }

    // Build up the string
    pszString = pszVal;
    for (pszWalk = pszTokens; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        // Skip empty strings
        if (FALSE == FIsEmptyA(pszWalk))
        {
            lstrcpy(pszString, pszWalk);
            pszString += lstrlen(pszString) + 1;
        }
    }

    // Terminate the string
    pszString[0] = '\0';
    pszString[1] = '\0';


    // Build up the criteria
    critItem.type = type;
    critItem.logic = CRIT_LOGIC_NULL;
    critItem.dwFlags = CRIT_FLAG_MULTIPLEAND;
    critItem.propvar.vt = VT_BLOB;
    critItem.propvar.blob.cbSize = cbData;
    critItem.propvar.blob.pBlobData = (BYTE *) pszVal;

    // Add it to the criteria object
    if (FAILED(pICrit->AppendCriteria(0, CRIT_LOGIC_AND, &critItem, 1, &ulRet)))
    {
        ulRet = 0;
        goto exit;
    }

exit:
    SafeMemFree(pszVal);
    SafeMemFree(pszTokens);
    SafeMemFree(pszReg);
    return ulRet;
}

ULONG UlBuildCritKB(HKEY hKeyRoot, LPCSTR szKeyName, CRIT_TYPE type, IOECriteria * pICrit)
{
    ULONG           ulRet = 0;
    DWORD           cbData = 0;
    LONG            lErr = ERROR_SUCCESS;
    ULONG           ulVal = NULL;
    CRIT_ITEM       critItem;

    // Initialize out local vars
    ZeroMemory(&critItem, sizeof(critItem));

    // Get the key long from the registry
    cbData = sizeof(ulVal);
    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, (LPVOID) &ulVal, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        ulRet = 0;
        goto exit;
    }

    // Build up the criteria
    critItem.type = type;
    critItem.logic = CRIT_LOGIC_NULL;
    critItem.dwFlags = CRIT_FLAG_DEFAULT;
    critItem.propvar.vt = VT_UI4;
    critItem.propvar.ulVal = ulVal;

    // Add it to the criteria object
    if (FAILED(pICrit->AppendCriteria(0, CRIT_LOGIC_AND, &critItem, 1, &ulRet)))
    {
        ulRet = 0;
        goto exit;
    }

exit:
    return ulRet;
}

ULONG UlBuildActFolder(HKEY hKeyRoot, IMessageStore * pStore, BYTE * pbFldIdMap, LPCSTR szKeyName, ACT_TYPE type, IOEActions * pIAct)
{
    ULONG               ulRet = 0;
    DWORD               cbData = 0;
    LONG                lErr = ERROR_SUCCESS;
    ULONG               ulVal = NULL;
    ACT_ITEM            actItem;
    FOLDERID            idFolder = FOLDERID_INVALID;
    STOREUSERDATA       UserData = {0};
    RULEFOLDERDATA *    prfdData = NULL;

    // Initialize out local vars
    ZeroMemory(&actItem, sizeof(actItem));

    // Get the key long from the registry
    cbData = sizeof(ulVal);
    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, (LPVOID) &ulVal, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        ulRet = 0;
        goto exit;
    }

    // Convert to V5 folder id
    if ((NULL == pbFldIdMap) || (FAILED(RuleUtil_HrMapFldId(0, pbFldIdMap, (FOLDERID)((ULONG_PTR)ulVal), &idFolder))))
    {
        idFolder = (FOLDERID)((ULONG_PTR)ulVal);
    }

    // Create space for the data structure
    if (FAILED(HrAlloc((VOID **) &prfdData, sizeof(*prfdData))))
    {
        ulRet = 0;
        goto exit;
    }

    // Initialize the data struct
    ZeroMemory(prfdData, sizeof(*prfdData));

    // Get the timestamp for the store
    if (FAILED(pStore->GetUserData(&UserData, sizeof(STOREUSERDATA))))
    {
        ulRet = 0;
        goto exit;
    }

    // Set up the rule folder data
    prfdData->ftStamp = UserData.ftCreated;
    prfdData->idFolder = idFolder;

    // Build up the actions
    actItem.type = type;
    actItem.dwFlags = ACT_FLAG_DEFAULT;
    actItem.propvar.vt = VT_BLOB;
    actItem.propvar.blob.cbSize = sizeof(*prfdData);
    actItem.propvar.blob.pBlobData = (BYTE *) prfdData;

    // Add it to the actions object
    if (FAILED(pIAct->AppendActions(0, &actItem, 1, &ulRet)))
    {
        ulRet = 0;
        goto exit;
    }

exit:
    SafeMemFree(prfdData);
    return ulRet;
}

ULONG UlBuildActFwd(HKEY hKeyRoot, LPCSTR szKeyName, ACT_TYPE type, IOEActions * pIAct)
{
    ULONG           ulRet = 0;
    DWORD           cbData = 0,
                    cchCount = 0;
    LONG            lErr = ERROR_SUCCESS;
    LPSTR           pszVal = NULL,
                    pszTokens = NULL;
    LPWSTR          pwszVal = NULL,
                    pwszTokens = NULL;
    ACT_ITEM        actItem;
    ULONG           ulIndex = 0;

    // Initialize out local vars
    ZeroMemory(&actItem, sizeof(actItem));

    // Get the key string from the registry
    cbData = 0;
    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    if (0 == cbData)
    {
        goto exit;
    }

    if (FAILED(HrAlloc((LPVOID *) &pszVal, cbData)))
    {
        goto exit;
    }

    SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, (LPVOID) pszVal, &cbData);
    Assert(*pszVal);

    // Convert the string to our format
    for (ulIndex = 0; ulIndex < cbData; ulIndex++)
    {
        if (',' == pszVal[ulIndex])
        {
            pszVal[ulIndex] = ';';
        }
    }

    pwszVal = PszToUnicode(CP_ACP, pszVal);
    if (!pwszVal)
        goto exit;

    if (FAILED(RuleUtil_HrBuildEmailString(pwszVal, 0, &pwszTokens, &cchCount)))
    {
        goto exit;
    }

    Assert(pwszTokens);
    pszTokens = PszToANSI(CP_ACP, pwszTokens);
    if (!pszTokens)
        goto exit;

    // Build up the actions
    actItem.type = type;
    actItem.dwFlags = ACT_FLAG_DEFAULT;
    actItem.propvar.vt = VT_LPSTR;
    actItem.propvar.pszVal = pszTokens;

    // Add it to the actions object
    if (FAILED(pIAct->AppendActions(0, &actItem, 1, &ulRet)))
    {
        ulRet = 0;
        goto exit;
    }


exit:
    MemFree(pszVal);
    MemFree(pwszVal);
    MemFree(pszTokens);
    MemFree(pwszTokens);
    return ulRet;
}

ULONG UlBuildActFile(HKEY hKeyRoot, LPCSTR szKeyName, ACT_TYPE type, IOEActions * pIAct)
{
    ULONG           ulRet = 0;
    DWORD           cbData = 0;
    LONG            lErr = ERROR_SUCCESS;
    LPSTR           pszVal = NULL;
    ACT_ITEM        actItem;

    // Initialize out local vars
    ZeroMemory(&actItem, sizeof(actItem));

    // Get the key string from the registry
    cbData = 0;
    lErr = SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        ulRet = 0;
        goto exit;
    }

    if (0 == cbData)
    {
        ulRet = 0;
        goto exit;
    }

    if (FAILED(HrAlloc((LPVOID *) &pszVal, cbData)))
    {
        ulRet = 0;
        goto exit;
    }

    SHQueryValueEx(hKeyRoot, szKeyName, NULL, NULL, (LPVOID) pszVal, &cbData);

    // If it is empty, then we're done
    if (FALSE != FIsEmptyA(pszVal))
    {
        ulRet = 0;
        goto exit;
    }

    // Build up the actions
    actItem.type = type;
    actItem.dwFlags = ACT_FLAG_DEFAULT;
    actItem.propvar.vt = VT_LPSTR;
    actItem.propvar.pszVal = pszVal;

    // Add it to the actions object
    if (FAILED(pIAct->AppendActions(0, &actItem, 1, &ulRet)))
    {
        ulRet = 0;
        goto exit;
    }


exit:
    SafeMemFree(pszVal);
    return ulRet;
}

// The maximum possible size of the Athena V1 actions string
const int CCH_V1_ACTION_MAX = 255;

BOOL FConvertV1ActionsToV4(HKEY hkeyRule, IMessageStore * pStore, IOEActions * pIAct)
{
    BOOL                fRet = FALSE;
    ULONG               cbData = 0;
    LONG                lErr = ERROR_SUCCESS;
    TCHAR               szAction[CCH_V1_ACTION_MAX];
    LPSTR               pszFolderName = NULL;
    FOLDERID            idFolder = FOLDERID_INVALID;
    ACT_ITEM            actItem;
    RULEFOLDERDATA      rfdData = {0};
    STOREUSERDATA       UserData = {0};

    Assert(NULL != hkeyRule);
    Assert(NULL != pStore);
    Assert(NULL != pIAct);

    // Is there anything to do?
    cbData = sizeof(szAction);
    lErr = RegQueryValueEx(hkeyRule, c_szActionV1, NULL, NULL, (BYTE *) szAction, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        fRet = FALSE;
        goto exit;
    }

    Assert(0 == lstrcmpi(szAction, (LPTSTR) c_szMoveV1));

    // Convert from old move to a V4 move

    // Get the size of the folder name
    lErr = RegQueryValueEx(hkeyRule, c_szFolderV1, NULL, NULL, NULL, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        fRet = FALSE;
        goto exit;
    }

    // Allocate space to hold the folder name
    if (FAILED(HrAlloc( (VOID **) &pszFolderName, cbData)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Get the old folder name
    lErr = RegQueryValueEx(hkeyRule, c_szFolderV1, NULL, NULL, (BYTE *) pszFolderName, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        fRet = FALSE;
        goto exit;
    }

    // Find the folder id from the folder name in the store
    if (FAILED(GetFolderIdFromName(pStore, pszFolderName, FOLDERID_LOCAL_STORE, &idFolder)))
    {
        idFolder = FOLDERID_INVALID;
    }

    // Get the timestamp for the store
    pStore->GetUserData(&UserData, sizeof(STOREUSERDATA));

    // Set the timestamp and folder id
    rfdData.ftStamp = UserData.ftCreated;
    rfdData.idFolder = idFolder;

    // Build up the actions
    ZeroMemory(&actItem, sizeof(actItem));
    actItem.type = ACT_TYPE_MOVE;
    actItem.dwFlags = ACT_FLAG_DEFAULT;
    actItem.propvar.vt = VT_BLOB;
    actItem.propvar.blob.cbSize = sizeof(rfdData);
    actItem.propvar.blob.pBlobData = (BYTE *) &rfdData;

    // Add it to the actions object
    if (FAILED(pIAct->AppendActions(0, &actItem, 1, NULL)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Set the return value
    fRet = TRUE;

exit:
    SafeMemFree(pszFolderName);
    return fRet;
}


void MigrateMailRulesSettings(void)
{
    IImnAccountManager *pAcctMan = NULL;
    HKEY            hkeyOldRoot = NULL;
    LONG            lErr = 0;
    ULONG           cSubKeys = 0;
    HKEY            hkeyNewRoot = NULL;
    DWORD           dwDisp = 0;
    DWORD           cbData = 0;
    BYTE *          pbFldIdMap = NULL;
    HRESULT         hr = S_OK;
    ULONG           ulIndex = 0;
    TCHAR           szNameOld[16];
    HKEY            hKeyOld = NULL;
    IOERule *       pIRule = NULL;
    PROPVARIANT     propvar = {0};
    BOOL            boolVal = FALSE;
    IOECriteria *   pICrit = NULL;
    CRIT_ITEM       critItem;
    ULONG           ccritItem = 0;
    CRIT_ITEM *     pCrit = NULL;
    ULONG           ccritItemAlloc = 0;
    IOEActions *    pIAct = NULL;
    DWORD           dwActs = 0;
    ACT_ITEM        actItem;
    ULONG           cactItem = 0;
    ACT_ITEM *      pAct = NULL;
    ULONG           cactItemAlloc = 0;
    ULONG           ulName = 0;
    TCHAR           szRes[CCHMAX_STRINGRES + 5];
    TCHAR           szName[CCHMAX_STRINGRES + 5];
    IOERule *       pIRuleFind = NULL;
    RULEINFO        infoRule = {0};
    CHAR            szStoreDir[MAX_PATH + MAX_PATH];
    IMessageStore * pStore = NULL;

    // Initialize the local vars
    ZeroMemory(&critItem, sizeof(critItem));
    ZeroMemory(&actItem, sizeof(actItem));

    // Get the old key
    lErr = AthUserOpenKey(c_szRegPathInboxRules, KEY_READ, &hkeyOldRoot);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Is there anything to do?
    lErr = RegQueryInfoKey(hkeyOldRoot, NULL, NULL, NULL,
                    &cSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    if ((lErr != ERROR_SUCCESS) || (0 == cSubKeys))
    {
        goto exit;
    }

    // To make sure we don't get any sample rule created
    // set up the registry to look like we've already been set-up

    // Get the new rules key
    lErr = AthUserCreateKey(c_szRulesMail, KEY_ALL_ACCESS, &hkeyNewRoot, &dwDisp);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Save out the rules version
    cbData = RULESMGR_VERSION;
    lErr = RegSetValueEx(hkeyNewRoot, c_szRulesVersion, 0, REG_DWORD, (CONST BYTE *) &cbData, sizeof(cbData));
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    // Figure out the size of the folderid map
    lErr = AthUserGetValue(NULL, c_szFolderIdChange, NULL, NULL, &cbData);
    if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
    {
        goto exit;
    }

    // If the map exists, then grab it
    if (ERROR_SUCCESS == lErr)
    {
        // Allocate the space to hold the folderid map
        if (FAILED(HrAlloc((void **) &pbFldIdMap, cbData)))
        {
            goto exit;
        }

        // Get the folderid map from the registry
        lErr = AthUserGetValue(NULL, c_szFolderIdChange, NULL, pbFldIdMap, &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            goto exit;
        }
    }

    // CoIncrementInit Global Options Manager
    if (FALSE == InitGlobalOptions(NULL, NULL))
    {
        goto exit;
    }

    // Create the Rules Manager
    Assert(NULL == g_pRulesMan);
    hr = HrCreateRulesManager(NULL, (IUnknown **)&g_pRulesMan);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the rules manager
    hr = g_pRulesMan->Initialize(0);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the Account Manager
    Assert(g_pAcctMan == NULL);
    hr = HrCreateAccountManager(&pAcctMan);
    if (FAILED(hr))
    {
        goto exit;
    }
    hr = pAcctMan->QueryInterface(IID_IImnAccountManager2, (LPVOID *)&g_pAcctMan);
    pAcctMan->Release();
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the account manager
    hr = g_pAcctMan->Init(NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the store directory
    hr = GetStoreRootDirectory(szStoreDir, ARRAYSIZE(szStoreDir));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the store object
    pStore = new CMessageStore(FALSE);
    if (NULL == pStore)
    {
        goto exit;
    }

    // Initialize the store
    hr = pStore->Initialize(szStoreDir);
    if (FAILED(hr))
    {
        goto exit;
    }

    ulIndex = 0;
    wsprintf(szNameOld, "Rule%05d", ulIndex);

    if (0 == LoadString(g_hLocRes, idsRuleDefaultName, szRes, ARRAYSIZE(szRes)))
    {
        goto exit;
    }

    // For each entry in the old rules key
    for (;RegOpenKeyEx(hkeyOldRoot, szNameOld, 0, KEY_READ, &hKeyOld) == ERROR_SUCCESS; RegCloseKey(hKeyOld))
    {
        // Create the new Rule
        SafeRelease(pIRule);
        hr = HrCreateRule(&pIRule);
        if (FAILED(hr))
        {
            continue;
        }

        // Set the name on the rule
        ulName = 1;
        wsprintf(szName, szRes, ulName);

        Assert(NULL != g_pRulesMan);
        while (S_OK == g_pRulesMan->FindRule(szName, RULE_TYPE_MAIL, &pIRuleFind))
        {
            SafeRelease(pIRuleFind);
            ulName++;
            wsprintf(szName, szRes, ulName);
        }

        ZeroMemory(&propvar, sizeof(propvar));
        propvar.vt = VT_LPSTR;
        propvar.pszVal = szName;
        pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);

        // Set the enabled state on the rule
        cbData = sizeof(boolVal);
        SHQueryValueEx(hKeyOld, c_szDisabled, NULL, NULL, (LPVOID) (&boolVal), &cbData);

        ZeroMemory(&propvar, sizeof(propvar));
        propvar.vt = VT_BOOL;
        propvar.boolVal = !!boolVal;
        pIRule->SetProp(RULE_PROP_DISABLED, 0, &propvar);

        // Copy over the criteria
        SafeRelease(pICrit);
        hr = HrCreateCriteria(&pICrit);
        if (FAILED(hr))
        {
            continue;
        }

        ccritItem = 0;

        // Check for All Messages
        cbData = sizeof(boolVal);
        SHQueryValueEx(hKeyOld, c_szFilterAllMessages, NULL, NULL, (LPVOID) (&boolVal), &cbData);
        if (FALSE != boolVal)
        {
            critItem.type = CRIT_TYPE_ALL;
            critItem.propvar.vt = VT_EMPTY;
            critItem.logic = CRIT_LOGIC_NULL;
            critItem.dwFlags = CRIT_FLAG_DEFAULT;
            if (SUCCEEDED(pICrit->AppendCriteria(0, CRIT_LOGIC_AND, &critItem, 1, NULL)))
            {
                ccritItem++;
            }
        }
        else
        {
            // Check for account
            cbData = sizeof(boolVal);
            SHQueryValueEx(hKeyOld, c_szFilterByAccount, NULL, NULL, (LPVOID) (&boolVal), &cbData);
            if (FALSE != boolVal)
            {
                ccritItem += UlBuildCritAcct(hKeyOld, c_szAccount, CRIT_TYPE_ACCOUNT, pICrit);
            }

            // Check for size
            cbData = sizeof(boolVal);
            SHQueryValueEx(hKeyOld, c_szFilterOnSize, NULL, NULL, (LPVOID) (&boolVal), &cbData);
            if (FALSE != boolVal)
            {
                ccritItem += UlBuildCritKB(hKeyOld, c_szFilterSize, CRIT_TYPE_SIZE, pICrit);
            }

            // Check for subject
            ccritItem += UlBuildCritText(hKeyOld, c_szSubject, CRIT_TYPE_SUBJECT, pICrit);

            // Check for subject
            ccritItem += UlBuildCritAddr(hKeyOld, c_szFrom, CRIT_TYPE_FROM, pICrit);

            // Check for subject
            ccritItem += UlBuildCritAddr(hKeyOld, c_szTo, CRIT_TYPE_TO, pICrit);

            // Check for subject
            ccritItem += UlBuildCritAddr(hKeyOld, c_szCC, CRIT_TYPE_CC, pICrit);
        }

        if (0 != ccritItem)
        {
            // Get the criteria from the criteria object and set it on the rule
            RuleUtil_HrFreeCriteriaItem(pCrit, ccritItemAlloc);
            SafeMemFree(pCrit);
            if (SUCCEEDED(pICrit->GetCriteria(0, &pCrit, &ccritItemAlloc)))
            {
                ZeroMemory(&propvar, sizeof(propvar));
                propvar.vt = VT_BLOB;
                propvar.blob.cbSize = ccritItem * sizeof(CRIT_ITEM);
                propvar.blob.pBlobData = (BYTE *) pCrit;
                if (FAILED(pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar)))
                {
                    continue;
                }
            }
        }

        // Copy over the actions
        SafeRelease(pIAct);
        hr = HrCreateActions(&pIAct);
        if (FAILED(hr))
        {
            continue;
        }

        cactItem = 0;

        // Convert any old V1 actions to V4
        if (FALSE != FConvertV1ActionsToV4(hKeyOld, pStore, pIAct))
        {
            cactItem = 1;
        }
        else
        {
            // Get list of actions
            cbData = sizeof(dwActs);
            SHQueryValueEx(hKeyOld, c_szActions, NULL, NULL, (LPVOID) (&dwActs), &cbData);

            // Check for don't download
            if (0 != (dwActs & ACT_DONTDOWNLOAD))
            {
                actItem.type = ACT_TYPE_DONTDOWNLOAD;
                actItem.dwFlags = ACT_FLAG_DEFAULT;
                actItem.propvar.vt = VT_EMPTY;
                if (SUCCEEDED(pIAct->AppendActions(0, &actItem, 1, NULL)))
                {
                    cactItem++;
                }
            }
            // Check for delete from server
            else if (0 != (dwActs & ACT_DELETEOFFSERVER))
            {
                actItem.type = ACT_TYPE_DELETESERVER;
                actItem.dwFlags = ACT_FLAG_DEFAULT;
                actItem.propvar.vt = VT_EMPTY;
                if (SUCCEEDED(pIAct->AppendActions(0, &actItem, 1, NULL)))
                {
                    cactItem++;
                }
            }
            else
            {
                // Check for move to
                if (0 != (dwActs & ACT_MOVETO))
                {
                    cactItem += UlBuildActFolder(hKeyOld, pStore, pbFldIdMap, c_szMoveToHfolder, ACT_TYPE_MOVE, pIAct);
                }

                // Check for copy to
                if (0 != (dwActs & ACT_COPYTO))
                {
                    cactItem += UlBuildActFolder(hKeyOld, pStore, pbFldIdMap, c_szCopyToHfolder, ACT_TYPE_COPY, pIAct);
                }

                // Check for forward to
                if (0 != (dwActs & ACT_FORWARDTO))
                {
                    cactItem += UlBuildActFwd(hKeyOld, c_szForwardTo, ACT_TYPE_FWD, pIAct);
                }

                // Check for reply with
                if (0 != (dwActs & ACT_REPLYWITH))
                {
                    cactItem += UlBuildActFile(hKeyOld, c_szReplyWithFile, ACT_TYPE_REPLY, pIAct);
                }
            }
        }

        if (0 != cactItem)
        {
            // Get the actions from the action object and set it on the rule
            RuleUtil_HrFreeActionsItem(pAct, cactItemAlloc);
            SafeMemFree(pAct);
            if (SUCCEEDED(pIAct->GetActions(0, &pAct, &cactItemAlloc)))
            {
                ZeroMemory(&propvar, sizeof(propvar));
                propvar.vt = VT_BLOB;
                propvar.blob.cbSize = cactItem * sizeof(ACT_ITEM);
                propvar.blob.pBlobData = (BYTE *) pAct;
                if (FAILED(pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar)))
                {
                    continue;
                }
            }
        }

        // Initialize the rule info
        infoRule.ridRule = RULEID_INVALID;
        infoRule.pIRule = pIRule;

        // Add it to the rules
        g_pRulesMan->SetRules(SETF_APPEND, RULE_TYPE_MAIL, &infoRule, 1);

        ulIndex++;
        wsprintf(szNameOld, "Rule%05d", ulIndex);
    }

exit:
    RuleUtil_HrFreeActionsItem(pAct, cactItemAlloc);
    SafeMemFree(pAct);
    RuleUtil_HrFreeCriteriaItem(pCrit, ccritItemAlloc);
    SafeMemFree(pCrit);
    SafeRelease(pIAct);
    SafeRelease(pICrit);
    SafeRelease(pIRule);
    if (NULL != hKeyOld)
    {
        RegCloseKey(hKeyOld);
    }
    SafeRelease(pStore);
    SafeRelease(g_pAcctMan);
    SafeRelease(g_pRulesMan);
    DeInitGlobalOptions();
    SafeMemFree(pbFldIdMap);
    if (NULL != hkeyNewRoot)
    {
        RegCloseKey(hkeyNewRoot);
    }
    if (NULL != hkeyOldRoot)
    {
        RegCloseKey(hkeyOldRoot);
    }
}

void CopyBeta2RulesToRTM(VOID)
{
    LONG    lErr = ERROR_SUCCESS;
    HKEY    hKeyMail = NULL;
    HKEY    hkeyRTM = NULL;
    DWORD   dwDisp = 0;

    // Get the Beta 2 hkey for rules
    lErr = AthUserOpenKey(c_szMail, KEY_READ, &hKeyMail);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Create the RTM hkey for rules
    lErr = AthUserCreateKey(c_szRulesMail, KEY_ALL_ACCESS, &hkeyRTM, &dwDisp);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Copy the Beta 2 rules to the new location
    SHCopyKey(hKeyMail, c_szRules, hkeyRTM, NULL);

exit:
    if (NULL != hkeyRTM)
    {
        RegCloseKey(hkeyRTM);
    }
    if (NULL != hKeyMail)
    {
        RegCloseKey(hKeyMail);
    }
    return;
}

void UpdateBeta2String(HKEY hkeyItem, LPCSTR pszSep, DWORD dwItemType)
{
    HRESULT hr = S_OK;
    LPSTR   pszData = NULL;
    ULONG   cbData = 0;
    LONG    lErr = ERROR_SUCCESS;
    DWORD   dwData = 0;

    Assert(NULL != hkeyItem);

    // Get the new data
    hr = RuleUtil_HrGetOldFormatString(hkeyItem, c_szCriteriaValue, g_szComma, &pszData, &cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Write out the new data
    lErr = RegSetValueEx(hkeyItem, c_szCriteriaValue, 0, REG_BINARY, (BYTE *) pszData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Write out the proper value type
    dwData = VT_BLOB;
    cbData = sizeof(dwData);
    lErr = RegSetValueEx(hkeyItem, c_szCriteriaValueType, 0, REG_DWORD, (BYTE *) &dwData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Write out the proper flags
    dwData = CRIT_FLAG_MULTIPLEAND;
    cbData = sizeof(dwData);
    lErr = RegSetValueEx(hkeyItem, c_szCriteriaFlags, 0, REG_DWORD, (BYTE *) &dwData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Write the new type
    cbData = sizeof(dwItemType);
    lErr = RegSetValueEx(hkeyItem, c_szCriteriaType, 0, REG_DWORD, (BYTE *) &dwItemType, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

exit:
    SafeMemFree(pszData);
    return;
}

static IMessageStore * g_pStoreRulesMig = NULL;

VOID WriteOldOrderFormat(HKEY hkeyItem, LPSTR pszOrder)
{
    ULONG   cbData = 0;
    LPSTR   pszWalk = NULL;
    ULONG   cchWalk = 0;

    // Convert the order string back to our old format
    for (pszWalk = pszOrder; '\0' != pszWalk[0]; pszWalk += cchWalk + 1)
    {
        cchWalk = lstrlen(pszWalk);
        *(pszWalk + cchWalk) = ' ';
        cbData += cchWalk + 1;
    }

    // Make sure we terminate the order string
    pszOrder[cbData - 1] = '\0';

    // Save it
    RegSetValueEx(hkeyItem, c_szRulesOrder, 0, REG_SZ, (BYTE *) pszOrder, cbData);

    return;
}

static CRIT_TYPE    g_rgtypeCritMerge[] =
{
    CRIT_TYPE_FROM,
    CRIT_TYPE_TO,
    CRIT_TYPE_CC,
    CRIT_TYPE_TOORCC
};

static const int g_ctypeCritMerge = sizeof(g_rgtypeCritMerge) / sizeof(g_rgtypeCritMerge[0]);

BOOL FMergeRuleData(HKEY hkeyItem, LPSTR pszSubKey, LPSTR * ppszData, ULONG * pcbData)
{
    BOOL    fRet = FALSE;
    LONG    lErr = ERROR_SUCCESS;
    DWORD   dwType = 0;
    ULONG   cbString = 0;
    LPSTR   pszData = NULL;
    ULONG   cbData = 0;

    // Get the size of the original string
    lErr = SHGetValue(hkeyItem, pszSubKey, c_szCriteriaValue, &dwType, NULL, &cbString);
    if (ERROR_SUCCESS != lErr)
    {
        fRet = FALSE;
        goto exit;
    }

    // Figure out the space for the final string
    cbData = *pcbData + cbString - 2;

    // Allocate space for the final data
    if (FAILED(HrAlloc((VOID **) &pszData, cbData * sizeof(*pszData))))
    {
        fRet = FALSE;
        goto exit;
    }

    // Copy over the original string
    CopyMemory(pszData, *ppszData, *pcbData);

    // Copy over the new data
    lErr = SHGetValue(hkeyItem, pszSubKey, c_szCriteriaValue, &dwType, (BYTE *) (pszData + *pcbData - 2), &cbString);
    if (ERROR_SUCCESS != lErr)
    {
        fRet = FALSE;
        goto exit;
    }

    // Free the old data
    SafeMemFree(*ppszData);

    // Set the return values
    *ppszData = pszData;
    pszData = NULL;
    *pcbData = cbData;

    fRet = TRUE;

exit:
    SafeMemFree(pszData);
    return fRet;
}

void AddStopAction(HKEY hkeyItem, LPSTR * ppszOrder, ULONG * pcchOrder)
{
    ULONG       ulIndex = 0;
    CHAR        rgchTag[CCH_INDEX_MAX];
    LPSTR       pszWalk = NULL;
    HKEY        hkeyAction = NULL;
    DWORD       dwDisp = 0;
    ULONG       cbData = 0;
    LONG        lErr = 0;
    ACT_TYPE    typeAct = ACT_TYPE_NULL;
    DWORD       dwData = 0;
    ULONG       cchOrder = 0;
    LPSTR       pszOrder = NULL;

    // Check to see if we need to add the stop processing action
    if ('\0' == (*ppszOrder + lstrlen(*ppszOrder) + 1)[0])
    {
        // Get the action type
        cbData = sizeof(typeAct);
        lErr = SHGetValue(hkeyItem, *ppszOrder, c_szActionsType, NULL, (BYTE *) &typeAct, &cbData);
        if (ERROR_SUCCESS == lErr)
        {
            if ((ACT_TYPE_DONTDOWNLOAD == typeAct) || (ACT_TYPE_DELETESERVER == typeAct))
            {
                goto exit;
            }
        }
    }

    // Spin through the order item looking for an open entry
    for (ulIndex = 0; ulIndex < DWORD_INDEX_MAX; ulIndex++)
    {
        // Create the tag
        wsprintf(rgchTag, "%03X", ulIndex);

        // Search for the tag in the list
        for (pszWalk = *ppszOrder; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
        {
            if (0 == lstrcmp(pszWalk, rgchTag))
            {
                // Found it
                break;
            }
        }

        // If we didn't find it
        if ('\0' == pszWalk[0])
        {
            // Use this one
            break;
        }
    }

    // Did we find anything?
    if (ulIndex >= DWORD_INDEX_MAX)
    {
        goto exit;
    }

    // Create the new entry
    lErr = RegCreateKeyEx(hkeyItem, rgchTag, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyAction, &dwDisp);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    // Set the action type
    cbData = sizeof(typeAct);
    typeAct = ACT_TYPE_STOP;
    lErr = RegSetValueEx(hkeyAction, c_szActionsType, 0, REG_DWORD, (BYTE *) &typeAct, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Set the action flags
    dwData = ACT_FLAG_DEFAULT;
    cbData = sizeof(dwData);
    lErr = RegSetValueEx(hkeyAction, c_szActionsFlags, 0, REG_DWORD, (BYTE *) &dwData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Allocate space to hold the new order string
    cchOrder= *pcchOrder + CCH_INDEX_MAX;
    if (FAILED(HrAlloc((VOID **) &pszOrder, cchOrder * sizeof (*pszOrder))))
    {
        goto exit;
    }

    // Copy over the old values
    CopyMemory(pszOrder, *ppszOrder, (*pcchOrder) * sizeof(*pszOrder));

    // Add it to the new order string
    lstrcpy(pszOrder + *pcchOrder - 2, rgchTag);

    // Terminate the new string
    pszOrder[cchOrder - 2] = '\0';
    pszOrder[cchOrder - 1] = '\0';

    // Release the old string
    SafeMemFree(*ppszOrder);

    // Save the new string
    *ppszOrder = pszOrder;
    pszOrder = NULL;
    *pcchOrder = cchOrder;

exit:
    SafeMemFree(pszOrder);
    if (NULL != hkeyAction)
    {
        RegCloseKey(hkeyAction);
    }
    return;
}

void MergeRTMCriteria(HKEY hkeyItem, CRIT_TYPE typeCrit, LPSTR pszOrder, ULONG cchOrder)
{
    LONG        lErr = ERROR_SUCCESS;
    LPSTR       pszWalk = NULL;
    CRIT_TYPE   typeCritNew = CRIT_TYPE_NULL;
    ULONG       cbData = 0;
    LPSTR       pszFirst = NULL;
    DWORD       dwType = 0;
    ULONG       cbString = 0;
    LPSTR       pszString = NULL;
    LPSTR       pszSrc = NULL;

    // Look through each item
    for (pszWalk = pszOrder; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        cbData = sizeof(typeCritNew);
        lErr = SHGetValue(hkeyItem, pszWalk, c_szCriteriaType, &dwType, (BYTE *) &typeCritNew, &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            continue;
        }

        if (typeCritNew == typeCrit)
        {
            break;
        }
    }

    // If we couldn't find it we're done
    if ('\0' == pszWalk[0])
    {
        goto exit;
    }

    // Get the size of the original string
    pszFirst = pszWalk;
    lErr = SHGetValue(hkeyItem, pszFirst, c_szCriteriaValue, &dwType, NULL, &cbString);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    if (FAILED(HrAlloc((VOID **) &pszString, cbString * sizeof(*pszString))))
    {
        goto exit;
    }

    // Get the original string
    lErr = SHGetValue(hkeyItem, pszFirst, c_szCriteriaValue, &dwType, (BYTE *) pszString, &cbString);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    // Search for more entries of this type
    for (pszWalk = pszFirst + lstrlen(pszFirst) + 1; '\0' != pszWalk[0]; )
    {
        cbData = sizeof(typeCritNew);
        lErr = SHGetValue(hkeyItem, pszWalk, c_szCriteriaType, &dwType, (BYTE *) &typeCritNew, &cbData);
        if (ERROR_SUCCESS != lErr)
        {
            continue;
        }

        if (typeCritNew == typeCrit)
        {
            if (FALSE == FMergeRuleData(hkeyItem, pszWalk, &pszString, &cbString))
            {
                break;
            }

            // Remove the old key
            SHDeleteKey(hkeyItem, pszWalk);

            // Remove the item from the order string
            pszSrc = pszWalk + lstrlen(pszWalk) + 1;
            MoveMemory(pszWalk, pszSrc, cchOrder - (ULONG)(pszSrc - pszOrder));
            cchOrder -= (ULONG) (pszSrc - pszWalk);
        }
        else
        {
            pszWalk += lstrlen(pszWalk) + 1;
        }
    }

    // Save out the final string
    lErr = SHSetValue(hkeyItem, pszFirst, c_szCriteriaValue, REG_BINARY, (BYTE *) pszString, cbString);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

exit:
    SafeMemFree(pszString);
    return;
}

void UpdateBeta2Folder(HKEY hkeyItem)
{
    LONG            lErr = ERROR_SUCCESS;
    DWORD           dwType = 0;
    FOLDERID        idFolder = FOLDERID_INVALID;
    ULONG           cbData = 0;
    STOREUSERDATA   UserData = {0};
    RULEFOLDERDATA  rfdData = {0};
    DWORD           dwData = 0;

    Assert(NULL != hkeyItem);

    // Get the old folder id
    cbData = sizeof(idFolder);
    lErr = RegQueryValueEx(hkeyItem, c_szCriteriaValue, 0, &dwType, (BYTE *) &idFolder, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    // Get the timestamp for the store
    Assert(NULL != g_pStoreRulesMig);
    if (FAILED(g_pStoreRulesMig->GetUserData(&UserData, sizeof(STOREUSERDATA))))
    {
        goto exit;
    }

    // Set up the new data
    rfdData.idFolder = idFolder;
    rfdData.ftStamp = UserData.ftCreated;

    // Write out the new data
    cbData = sizeof(rfdData);
    lErr = RegSetValueEx(hkeyItem, c_szCriteriaValue, 0, REG_BINARY, (BYTE *) &rfdData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Write out the proper value type
    dwData = VT_BLOB;
    cbData = sizeof(dwData);
    lErr = RegSetValueEx(hkeyItem, c_szCriteriaValueType, 0, REG_DWORD, (BYTE *) &dwData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

exit:
    return;
}

void UpdateBeta2Show(HKEY hkeyItem)
{
    LONG            lErr = ERROR_SUCCESS;
    DWORD           dwType = 0;
    DWORD           dwData = 0;
    ULONG           cbData = 0;

    Assert(NULL != hkeyItem);

    // Get the old flags
    cbData = sizeof(dwData);
    lErr = RegQueryValueEx(hkeyItem, c_szActionsFlags, 0, &dwType, (BYTE *) &dwData, &cbData);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    if (0 != (dwData & ACT_FLAG_INVERT))
    {
        dwData = ACT_DATA_HIDE;
    }
    else
    {
        dwData = ACT_DATA_SHOW;
    }

    // Write out the new data
    cbData = sizeof(dwData);
    lErr = RegSetValueEx(hkeyItem, c_szActionsValue, 0, REG_DWORD, (BYTE *) &dwData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Write out the proper value type
    dwData = VT_UI4;
    cbData = sizeof(dwData);
    lErr = RegSetValueEx(hkeyItem, c_szActionsValueType, 0, REG_DWORD, (BYTE *) &dwData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Write out the proper flags
    dwData = ACT_FLAG_DEFAULT;
    cbData = sizeof(dwData);
    lErr = RegSetValueEx(hkeyItem, c_szActionsFlags, 0, REG_DWORD, (BYTE *) &dwData, cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

exit:
    return;
}

void UpdateBeta2Criteria(HKEY hkeyItem, LPCSTR pszSubKey)
{
    LONG        lErr = ERROR_SUCCESS;
    HKEY        hkeyAtom = NULL;
    CRIT_TYPE   typeCrit = CRIT_TYPE_NULL;
    DWORD       dwType = 0;
    ULONG       cbData = 0;

    lErr = RegOpenKeyEx(hkeyItem, pszSubKey, 0, KEY_ALL_ACCESS, &hkeyAtom);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Get the type of criteria
    cbData = sizeof(typeCrit);
    lErr = RegQueryValueEx(hkeyAtom, c_szCriteriaType, NULL, &dwType, (BYTE *) &typeCrit, &cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // For each criteria type
    switch (typeCrit)
    {
        case CRIT_TYPE_FROM:
            UpdateBeta2String(hkeyAtom, g_szSpace, (DWORD) CRIT_TYPE_FROM);
            break;

        case CRIT_TYPE_FROMADDR:
            UpdateBeta2String(hkeyAtom, g_szComma, (DWORD) CRIT_TYPE_FROM);
            break;

        case CRIT_TYPE_TO:
            UpdateBeta2String(hkeyAtom, g_szSpace, (DWORD) CRIT_TYPE_TO);
            break;

        case CRIT_TYPE_TOADDR:
            UpdateBeta2String(hkeyAtom, g_szComma, (DWORD) CRIT_TYPE_TO);
            break;

        case CRIT_TYPE_CC:
            UpdateBeta2String(hkeyAtom, g_szSpace, (DWORD) CRIT_TYPE_CC);
            break;

        case CRIT_TYPE_CCADDR:
            UpdateBeta2String(hkeyAtom, g_szComma, (DWORD) CRIT_TYPE_CC);
            break;

        case CRIT_TYPE_TOORCC:
            UpdateBeta2String(hkeyAtom, g_szSpace, (DWORD) CRIT_TYPE_TOORCC);
            break;

        case CRIT_TYPE_TOORCCADDR:
            UpdateBeta2String(hkeyAtom, g_szComma, (DWORD) CRIT_TYPE_TOORCC);
            break;

        case CRIT_TYPE_SUBJECT:
            UpdateBeta2String(hkeyAtom, g_szSpace, (DWORD) CRIT_TYPE_SUBJECT);
            break;

        case CRIT_TYPE_BODY:
            UpdateBeta2String(hkeyAtom, g_szSpace, (DWORD) CRIT_TYPE_BODY);
            break;

        case CRIT_TYPE_NEWSGROUP:
            UpdateBeta2Folder(hkeyAtom);
            break;
    }

exit:
    if (NULL != hkeyAtom)
    {
        RegCloseKey(hkeyAtom);
    }
    return;
}

void UpdateBeta2Actions(HKEY hkeyItem, LPCSTR pszSubKey)
{
    LONG        lErr = ERROR_SUCCESS;
    HKEY        hkeyAtom = NULL;
    ACT_TYPE    typeAct = ACT_TYPE_NULL;
    DWORD       dwType = 0;
    ULONG       cbData = 0;

    lErr = RegOpenKeyEx(hkeyItem, pszSubKey, 0, KEY_ALL_ACCESS, &hkeyAtom);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Get the type of actions
    cbData = sizeof(typeAct);
    lErr = RegQueryValueEx(hkeyAtom, c_szActionsType, NULL, &dwType, (BYTE *) &typeAct, &cbData);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // For each actions type
    switch (typeAct)
    {
        case ACT_TYPE_MOVE:
        case ACT_TYPE_COPY:
            UpdateBeta2Folder(hkeyAtom);
            break;

        case ACT_TYPE_SHOW:
            UpdateBeta2Show(hkeyAtom);
    }

exit:
    if (NULL != hkeyAtom)
    {
        RegCloseKey(hkeyAtom);
    }
    return;
}

void MigrateBeta2RuleItems(HKEY hkeyRule, LPCSTR pszSubkey, BOOL fActions, RULE_TYPE typeRule)
{
    LONG    lErr = ERROR_SUCCESS;
    HKEY    hkeySubkey = NULL;
    HRESULT hr = S_OK;
    LPSTR   pszOrder = NULL;
    LPSTR   pszWalk = NULL;
    ULONG   ulIndex = 0;
    ULONG   cbData = 0;
    ULONG   cchWalk = 0;

    lErr = RegOpenKeyEx(hkeyRule, pszSubkey, 0, KEY_ALL_ACCESS, &hkeySubkey);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Get the order string
    hr = RuleUtil_HrGetOldFormatString(hkeySubkey, c_szRulesOrder, g_szSpace, &pszOrder, &cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // For each item in the order string
    for (pszWalk = pszOrder; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        // Update actions
        if (FALSE != fActions)
        {
            UpdateBeta2Actions(hkeySubkey, pszWalk);
        }
        else
        {
            UpdateBeta2Criteria(hkeySubkey, pszWalk);
        }
    }

    if (FALSE == fActions)
    {
        // For each item type
        for (ulIndex = 0; ulIndex < g_ctypeCritMerge; ulIndex++)
        {
            MergeRTMCriteria(hkeySubkey, g_rgtypeCritMerge[ulIndex], pszOrder, cbData);
        }
    }
    else
    {
        if (typeRule != RULE_TYPE_FILTER)
        {
            AddStopAction(hkeySubkey, &pszOrder, &cbData);
        }
    }

    // Write out the order string
    WriteOldOrderFormat(hkeySubkey, pszOrder);

exit:
    SafeMemFree(pszOrder);
    if (NULL != hkeySubkey)
    {
        RegCloseKey(hkeySubkey);
    }
    return;
}

void UpdateBeta2Rule(HKEY hkeyRoot, LPCSTR pszRule, RULE_TYPE typeRule)
{
    HKEY    hkeyRule = NULL;
    LONG    lErr = ERROR_SUCCESS;

    // Open up the rule
    lErr = RegOpenKeyEx(hkeyRoot, pszRule, 0, KEY_ALL_ACCESS, &hkeyRule);
    if (ERROR_SUCCESS != lErr)
    {
        goto exit;
    }

    // Migrate the criteria
    MigrateBeta2RuleItems(hkeyRule, c_szRuleCriteria, FALSE, typeRule);

    // Migrate the actions
    MigrateBeta2RuleItems(hkeyRule, c_szRuleActions, TRUE, typeRule);

exit:
    if (NULL != hkeyRule)
    {
        RegCloseKey(hkeyRule);
    }
    return;
}

typedef struct _RULEREGKEY
{
    LPCSTR      pszRegKey;
    RULE_TYPE   typeRule;
} RULEREGKEY, * PRULEREGKEY;

static RULEREGKEY g_rgpszRuleRegKeys[] =
{
    {c_szRulesMail,     RULE_TYPE_MAIL},
    {c_szRulesNews,     RULE_TYPE_NEWS},
    {c_szRulesFilter,   RULE_TYPE_FILTER}
};

static const int g_cpszRuleRegKeys = sizeof(g_rgpszRuleRegKeys) / sizeof(g_rgpszRuleRegKeys[0]);

void UpdateBeta2RuleFormats(VOID)
{
    ULONG           ulIndex = 0;
    LONG            lErr = ERROR_SUCCESS;
    HKEY            hkeyRoot = NULL;
    HRESULT         hr = S_OK;
    LPSTR           pszOrder = NULL;
    LPSTR           pszWalk = NULL;
    CHAR            szStoreDir[MAX_PATH + MAX_PATH];

    // Set up the global objects

    // Get the store directory
    hr = GetStoreRootDirectory(szStoreDir, ARRAYSIZE(szStoreDir));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the store object
    g_pStoreRulesMig = new CMessageStore(FALSE);
    if (NULL == g_pStoreRulesMig)
    {
        goto exit;
    }

    // Initialize the store
    hr = g_pStoreRulesMig->Initialize(szStoreDir);
    if (FAILED(hr))
    {
        goto exit;
    }


    // For each type of rule
    for (ulIndex = 0; ulIndex < g_cpszRuleRegKeys; ulIndex++)
    {
        // Open up the rule type reg key
        if (NULL != hkeyRoot)
        {
            RegCloseKey(hkeyRoot);
        }
        lErr = AthUserOpenKey(g_rgpszRuleRegKeys[ulIndex].pszRegKey, KEY_ALL_ACCESS, &hkeyRoot);
        if (lErr != ERROR_SUCCESS)
        {
            continue;
        }

        // Get the order string
        SafeMemFree(pszOrder);
        hr = RuleUtil_HrGetOldFormatString(hkeyRoot, c_szRulesOrder, g_szSpace, &pszOrder, NULL);
        if (FAILED(hr))
        {
            continue;
        }

        // For each item in the order string
        for (pszWalk = pszOrder; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
        {
            // Update rule
            UpdateBeta2Rule(hkeyRoot, pszWalk, g_rgpszRuleRegKeys[ulIndex].typeRule);
        }
    }

exit:
    SafeMemFree(pszOrder);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    SafeRelease(g_pStoreRulesMig);
    return;
}

void MigrateBeta2Rules(VOID)
{
    // Copy over all the items from the mail\rules area

    // Get the new rules key
    CopyBeta2RulesToRTM();

    // Go through each rule type updating the formats
    UpdateBeta2RuleFormats();

    // Merge the items if neccessary

    return;
}

void MigrateGroupFilterSettings(void)
{
    IImnAccountManager *pAcctMan = NULL;
    HKEY            hkeyOldRoot = NULL;
    LONG            lErr = 0;
    ULONG           cSubKeys = 0;
    HKEY            hkeyNewRoot = NULL;
    DWORD           dwDisp = 0;
    DWORD           cbData = 0;
    HRESULT         hr = S_OK;
    ULONG           ulIndex = 0;
    TCHAR           szNameOld[16];
    HKEY            hKeyOld = NULL;
    IOERule *       pIRule = NULL;
    PROPVARIANT     propvar = {0};
    BOOL            boolVal = FALSE;
    IOECriteria *   pICrit = NULL;
    CRIT_ITEM       critItem;
    ULONG           ccritItem = 0;
    CRIT_ITEM *     pCrit = NULL;
    ULONG           ccritItemAlloc = 0;
    DWORD           dwActs = 0;
    ACT_ITEM        actItem;
    ULONG           cactItemAlloc = 0;
    ULONG           ulName = 0;
    TCHAR           szRes[CCHMAX_STRINGRES + 5];
    TCHAR           szName[CCHMAX_STRINGRES + 5];
    IOERule *       pIRuleFind = NULL;
    RULEINFO        infoRule = {0};
    CHAR            szStoreDir[MAX_PATH + MAX_PATH];
    IMessageStore * pStore = NULL;

    // Initialize the local vars
    ZeroMemory(&critItem, sizeof(critItem));
    ZeroMemory(&actItem, sizeof(actItem));

    // Get the old key
    lErr = AthUserOpenKey(c_szRegPathGroupFilters, KEY_READ, &hkeyOldRoot);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Is there anything to do?
    lErr = RegQueryInfoKey(hkeyOldRoot, NULL, NULL, NULL,
                    &cSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    if ((lErr != ERROR_SUCCESS) || (0 == cSubKeys))
    {
        goto exit;
    }

    // To make sure we don't get any sample rule created
    // set up the registry to look like we've already been set-up

    // CoIncrementInit Global Options Manager
    if (FALSE == InitGlobalOptions(NULL, NULL))
    {
        goto exit;
    }

    // Create the Rules Manager
    Assert(NULL == g_pRulesMan);
    hr = HrCreateRulesManager(NULL, (IUnknown **)&g_pRulesMan);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the rules manager
    hr = g_pRulesMan->Initialize(0);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the Account Manager
    Assert(g_pAcctMan == NULL);
    hr = HrCreateAccountManager(&pAcctMan);
    if (FAILED(hr))
    {
        goto exit;
    }
    hr = pAcctMan->QueryInterface(IID_IImnAccountManager2, (LPVOID *)&g_pAcctMan);
    pAcctMan->Release();
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the account manager
    hr = g_pAcctMan->Init(NULL);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the store directory
    hr = GetStoreRootDirectory(szStoreDir, ARRAYSIZE(szStoreDir));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Create the store object
    pStore = new CMessageStore(FALSE);
    if (NULL == pStore)
    {
        goto exit;
    }

    // Initialize the store
    hr = pStore->Initialize(szStoreDir);
    if (FAILED(hr))
    {
        goto exit;
    }

    ulIndex = 0;
    wsprintf(szNameOld, "Rule%05d", ulIndex);

    // Initialize the action
    actItem.type = ACT_TYPE_SHOW;
    actItem.dwFlags = ACT_FLAG_DEFAULT;
    actItem.propvar.vt = VT_UI4;
    actItem.propvar.ulVal = ACT_DATA_HIDE;

    if (0 == LoadString(g_hLocRes, idsNewsFilterDefaultName, szRes, ARRAYSIZE(szRes)))
    {
        goto exit;
    }

    // For each entry in the old rules key
    for (;RegOpenKeyEx(hkeyOldRoot, szNameOld, 0, KEY_READ, &hKeyOld) == ERROR_SUCCESS; RegCloseKey(hKeyOld))
    {
        // Create the new Rule
        SafeRelease(pIRule);
        hr = HrCreateRule(&pIRule);
        if (FAILED(hr))
        {
            continue;
        }

        // Set the name on the rule
        ulName = 1;
        wsprintf(szName, szRes, ulName);

        Assert(NULL != g_pRulesMan);
        while (S_OK == g_pRulesMan->FindRule(szName, RULE_TYPE_FILTER, &pIRuleFind))
        {
            SafeRelease(pIRuleFind);
            ulName++;
            wsprintf(szName, szRes, ulName);
        }

        ZeroMemory(&propvar, sizeof(propvar));
        propvar.vt = VT_LPSTR;
        propvar.pszVal = szName;
        pIRule->SetProp(RULE_PROP_NAME, 0, &propvar);

        // Copy over the criteria
        SafeRelease(pICrit);
        hr = HrCreateCriteria(&pICrit);
        if (FAILED(hr))
        {
            continue;
        }

        ccritItem = 0;

        // Check for age
        cbData = sizeof(boolVal);
        SHQueryValueEx(hKeyOld, c_szFilterOnDate, NULL, NULL, (LPVOID) (&boolVal), &cbData);
        if (FALSE != boolVal)
        {
            ccritItem += UlBuildCritKB(hKeyOld, c_szFilterDays, CRIT_TYPE_AGE, pICrit);
        }

        // Check for lines
        cbData = sizeof(boolVal);
        SHQueryValueEx(hKeyOld, c_szFilterOnSize, NULL, NULL, (LPVOID) (&boolVal), &cbData);
        if (FALSE != boolVal)
        {
            ccritItem += UlBuildCritKB(hKeyOld, c_szFilterSize, CRIT_TYPE_LINES, pICrit);
        }

        // Check for subject
        ccritItem += UlBuildCritText(hKeyOld, c_szSubject, CRIT_TYPE_SUBJECT, pICrit);

        // Check for From
        ccritItem += UlBuildCritAddr(hKeyOld, c_szFrom, CRIT_TYPE_FROM, pICrit);

        if (0 != ccritItem)
        {
            // Get the criteria from the criteria object and set it on the rule
            RuleUtil_HrFreeCriteriaItem(pCrit, ccritItemAlloc);
            SafeMemFree(pCrit);
            if (SUCCEEDED(pICrit->GetCriteria(0, &pCrit, &ccritItemAlloc)))
            {
                ZeroMemory(&propvar, sizeof(propvar));
                propvar.vt = VT_BLOB;
                propvar.blob.cbSize = ccritItem * sizeof(CRIT_ITEM);
                propvar.blob.pBlobData = (BYTE *) pCrit;
                if (FAILED(pIRule->SetProp(RULE_PROP_CRITERIA, 0, &propvar)))
                {
                    continue;
                }
            }
        }

        ZeroMemory(&propvar, sizeof(propvar));
        propvar.vt = VT_BLOB;
        propvar.blob.cbSize = sizeof(actItem);
        propvar.blob.pBlobData = (BYTE *) &actItem;
        if (FAILED(pIRule->SetProp(RULE_PROP_ACTIONS, 0, &propvar)))
        {
            continue;
        }

        // Initialize the rule info
        infoRule.ridRule = RULEID_INVALID;
        infoRule.pIRule = pIRule;

        // Add it to the rules
        g_pRulesMan->SetRules(SETF_APPEND, RULE_TYPE_FILTER, &infoRule, 1);

        ulIndex++;
        wsprintf(szNameOld, "Rule%05d", ulIndex);
    }

exit:
    RuleUtil_HrFreeCriteriaItem(pCrit, ccritItemAlloc);
    SafeMemFree(pCrit);
    SafeRelease(pICrit);
    SafeRelease(pIRule);
    if (NULL != hKeyOld)
    {
        RegCloseKey(hKeyOld);
    }
    SafeRelease(pStore);
    SafeRelease(g_pAcctMan);
    SafeRelease(g_pRulesMan);
    DeInitGlobalOptions();
    if (NULL != hkeyNewRoot)
    {
        RegCloseKey(hkeyNewRoot);
    }
    if (NULL != hkeyOldRoot)
    {
        RegCloseKey(hkeyOldRoot);
    }
}

void RemoveDeletedFromFilters(VOID)
{
    CHAR        szDeleted[CCH_INDEX_MAX];
    LONG        lErr = ERROR_SUCCESS;
    HKEY        hkeyRoot = NULL;
    HRESULT     hr = S_OK;
    LPSTR       pszOrder = NULL;
    ULONG       cchOrder = 0;
    LPSTR       pszWalk = NULL;
    LPSTR       pszSrc = NULL;

    // Create the DELETED key
    wsprintf(szDeleted, "%03X", RULEID_VIEW_DELETED);

    // Open the filter key
    lErr = AthUserOpenKey(c_szRulesFilter, KEY_ALL_ACCESS, &hkeyRoot);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Get the order string
    hr = RuleUtil_HrGetOldFormatString(hkeyRoot, c_szRulesOrder, g_szSpace, &pszOrder, &cchOrder);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Search for RULEID_VIEW_DELETED
    for (pszWalk = pszOrder; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        if (0 == lstrcmpi(szDeleted, pszWalk))
        {
            break;
        }
    }

    // If we found it, then remove it
    if ('\0' != pszWalk[0])
    {
        // Delete the view
        SHDeleteKey(hkeyRoot, szDeleted);

        // Remove it from the order string
        pszSrc = pszWalk + lstrlen(pszWalk) + 1;
        MoveMemory(pszWalk, pszSrc, cchOrder - (ULONG)(pszSrc - pszOrder));

        // Save the order string
        WriteOldOrderFormat(hkeyRoot, pszOrder);
    }

exit:
    SafeMemFree(pszOrder);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return;
}

void Stage5RulesMigration(VOID)
{
    // Remove CRIT_TYPE_DELETED from views
    RemoveDeletedFromFilters();

    // Migrate the newsgroup filters
    MigrateGroupFilterSettings();

    return;
}

void RemoveRepliesFromFilters(VOID)
{
    CHAR        szDeleted[CCH_INDEX_MAX];
    LONG        lErr = ERROR_SUCCESS;
    HKEY        hkeyRoot = NULL;
    HRESULT     hr = S_OK;
    LPSTR       pszOrder = NULL;
    ULONG       cchOrder = 0;
    LPSTR       pszWalk = NULL;
    LPSTR       pszSrc = NULL;

    // Create the DELETED key
    wsprintf(szDeleted, "%03X", RULEID_VIEW_REPLIES);

    // Open the filter key
    lErr = AthUserOpenKey(c_szRulesFilter, KEY_ALL_ACCESS, &hkeyRoot);
    if (lErr != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Get the order string
    hr = RuleUtil_HrGetOldFormatString(hkeyRoot, c_szRulesOrder, g_szSpace, &pszOrder, &cchOrder);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Search for RULEID_VIEW_REPLIES
    for (pszWalk = pszOrder; '\0' != pszWalk[0]; pszWalk += lstrlen(pszWalk) + 1)
    {
        if (0 == lstrcmpi(szDeleted, pszWalk))
        {
            break;
        }
    }

    // If we found it, then remove it
    if ('\0' != pszWalk[0])
    {
        // Delete the view
        SHDeleteKey(hkeyRoot, szDeleted);

        // Remove it from the order string
        pszSrc = pszWalk + lstrlen(pszWalk) + 1;
        MoveMemory(pszWalk, pszSrc, cchOrder - (ULONG)(pszSrc - pszOrder));

        // Save the order string
        WriteOldOrderFormat(hkeyRoot, pszOrder);
    }

exit:
    SafeMemFree(pszOrder);
    if (NULL != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    return;
}

void Stage6RulesMigration(VOID)
{
    // Remove RULEID_VIEW_REPLIES from views
    RemoveRepliesFromFilters();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\instance.h ===
// --------------------------------------------------------------------------------
// INSTANCE.H
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __INSTANCE_H
#define __INSTANCE_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include <msoeapi.h>

// --------------------------------------------------------------------------------
// Macros
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define CoIncrementInit(_pszSource, _dwFlags, _pszCmdLine, _phInitRef) \
    g_pInstance->CoIncrementInitDebug(_pszSource, _dwFlags, _pszCmdLine, _phInitRef)
#define CoDecrementInit(_pszSource, _phInitRef) \
    g_pInstance->CoDecrementInitDebug(_pszSource, _phInitRef)
#else
#define CoIncrementInit(_pszSource, _dwFlags, _pszCmdLine, _phInitRef) \
    g_pInstance->CoIncrementInitImpl(_dwFlags, _pszCmdLine, _phInitRef)
#define CoDecrementInit(_pszSource, _phInitRef) \
    g_pInstance->CoDecrementInitImpl(_phInitRef)
#endif // DEBUG

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
extern DWORD g_dwHideMessenger;

#define BL_DISP         0
#define BL_CHECK        1
#define BL_HIDE         2
#define BL_NOTINST      10
#define BL_DISABLE      (BL_CHECK | BL_NOTINST)
#define BL_DEFAULT      BL_CHECK

// --------------------------------------------------------------------------------
// User Window Messages
// --------------------------------------------------------------------------------
#define ITM_SHUTDOWNTHREAD          (WM_USER)
#define ITM_CREATENOTEWINDOW        (WM_USER+1)
#define ITM_CREATEWMSUINOTE         (WM_USER+2)
#define ITM_CALLGENERICVOIDFN       (WM_USER+3)
#define ITM_CALLFINDWINDOW          (WM_USER+4)  // wparam == OFTYPE - see enumeration above.
#define ITM_CREATEREMINDWINDOW      (WM_USER+5)
#define ITM_MAPILOGON               (WM_USER+6)
#define ITM_OPENSTORE               (WM_USER+7)
#define ITM_OPENAB                  (WM_USER+8)
#define ITM_REDOCOLUMNS             (WM_USER+9)
#define ITM_OPENNEWSSTORE           (WM_USER+10)
#define ITM_CLOSENOTES              (WM_USER+11) // this note is passed when we need to close a note.
#define ITM_CHECKCONFIG             (WM_USER+12)
#define ITM_CREATENEWSNOTEWINDOW    (WM_USER+13)
#define ITM_OPTIONADVISE            (WM_USER+14) // wparam = PFNOPTNOTIFY, lparam = LPARAM
#define ITM_OPTIONUNADVISE          (WM_USER+15) // wparam = PFNOPTNOTIFY
#define ITM_GOPTIONSCHANGED         (WM_USER+16)
#define ITM_BROWSETOOBJECT          (WM_USER+17)
#define ITM_IDENTITYMSG             (WM_USER+18)
#define ITM_POSTCOPYDATA            (WM_USER+19)
#define ITM_WAB_CO_DECREMENT        (WM_USER+20)

// --------------------------------------------------------------------------------
// Startup Modes
// --------------------------------------------------------------------------------
#define MODE_NEWSONLY       0x00000001
#define MODE_OUTLOOKNEWS   (0x00000002 | MODE_NEWSONLY | MODE_NOIDENTITIES)
#define MODE_MAILONLY       0x00000004
#define MODE_NOIDENTITIES   0x00000008
#define MODE_EXAM           0x00000010
#define MODE_PLE            0x00000020
#define MODE_JUNKMAIL       0x00000040

// --------------------------------------------------------------------------------
// TRAYICONACTION
// --------------------------------------------------------------------------------
typedef enum tagTRAYICONACTION {
    TRAYICONACTION_ADD,
    TRAYICONACTION_REMOVE
} TRAYICONACTION;

// --------------------------------------------------------------------------------
// REPORTERRORINFO
// --------------------------------------------------------------------------------
typedef struct tagREPORTERRORINFO {
    UINT                nTitleIds;          // Title of the messagebox
    UINT                nPrefixIds;         // Prefix string resource id
    UINT                nErrorIds;          // Error string resource id
    UINT                nReasonIds;         // Reason string resource id
    BOOL                nHelpIds;           // Help String Resource Id
    LPCSTR              pszExtra1;          // Extra parameter 1
    ULONG               ulLastError;        // GetLastError() Value
} REPORTERRORINFO, *LPREPORTERRORINFO;

// --------------------------------------------------------------------------------
// COutlookExpress
// --------------------------------------------------------------------------------
class COutlookExpress : public IOutlookExpress
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    COutlookExpress(void);
    ~COutlookExpress(void);

    // ----------------------------------------------------------------------------
    // IUnknown Methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IOutlookExpress Methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP Start(DWORD dwFlags, LPCWSTR pwszCmdLine, INT nCmdShow);

    // ----------------------------------------------------------------------------
    // Initialize / Uninitialize
    // ----------------------------------------------------------------------------
#ifdef DEBUG
    HRESULT CoIncrementInitDebug(LPCSTR pwszSource, DWORD dwFlags, LPCWSTR pszCmdLine, LPHINITREF phInitRef);
    HRESULT CoDecrementInitDebug(LPCSTR pwszSource, LPHINITREF phInitRef);
#endif // DEBUG

    HRESULT CoIncrementInitImpl(DWORD dwFlags, LPCWSTR pwszCmdLine, LPHINITREF phInitRef);
    HRESULT CoDecrementInitImpl(LPHINITREF phInitRef);

    // ----------------------------------------------------------------------------
    // DllAddRef / DllRelease
    // ----------------------------------------------------------------------------
    HRESULT DllAddRef(void);
    HRESULT DllRelease(void);

    // ----------------------------------------------------------------------------
    // LockServer - Called from CClassFactory Implementation
    // ----------------------------------------------------------------------------
    HRESULT LockServer(BOOL fLock);

    // ----------------------------------------------------------------------------
    // DllCanUnloadNow
    // ----------------------------------------------------------------------------
    HRESULT DllCanUnloadNow(void) {
        HRESULT hr;

        if ((m_cDllInit <= 0) && 
            (m_cDllRef  <= 0) && 
            (m_cDllLock <= 0))
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
        return hr;
    }

    // ----------------------------------------------------------------------------
    // Defered Init/Deinit Methods
    // ----------------------------------------------------------------------------
    HRESULT ProcessCommandLine(INT nCmdShow, LPWSTR pwszCmdLineIn, BOOL *pfErrorDisplayed);
    HRESULT BrowseToObject(UINT nCmdShow, FOLDERID idFolder);
    HRESULT ActivateWindow(HWND hwnd);

    // ----------------------------------------------------------------------------
    // Multi-user startup/shutdown
    // ----------------------------------------------------------------------------
    HRESULT SetSwitchingUsers(BOOL bSwitching);
    BOOL    SwitchingUsers(void)                    {return m_fSwitchingUsers;}
    void    SetSwitchToUser(TCHAR *lpszUserName);
    // ----------------------------------------------------------------------------
    // InitWndProc
    // ----------------------------------------------------------------------------
    static LRESULT EXPORT_16 CALLBACK InitWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

    // ----------------------------------------------------------------------------
    // Tray Notification Icon Stuff
    // ----------------------------------------------------------------------------
    HRESULT UpdateTrayIcon(TRAYICONACTION type);
    void CloseSplashScreen(void);

private:
    // ----------------------------------------------------------------------------
    // Private Members
    // ----------------------------------------------------------------------------
    HRESULT _HandleMailURL(LPWSTR pwszCmdLine, BOOL *pfErrorDisplayed);
    HRESULT _HandleNewsURL(INT nCmdShow, LPWSTR pwszCmd, BOOL *pfErrorDisplayed);
    HRESULT _HandleFile(LPWSTR pwszCmd, BOOL *pfErrorDisplayed, BOOL fNews);
    HRESULT _HandleNewsArticleURL(LPSTR pszServerIn, LPSTR pszArticle, UINT uPort, BOOL fSecure, BOOL *pfErrorDisplayed);
    void    _HandleTrayIconEvent(WPARAM wParam, LPARAM lParam);
    HRESULT _ValidateDll(LPCSTR pszDll, BOOL fDemandResult, HMODULE hModule, HRESULT hrLoadError, HRESULT hrVersionError, LPREPORTERRORINFO pError);
    BOOL    _ReportError(HINSTANCE hInstance, HRESULT hrResult, LONG lResult, LPREPORTERRORINFO pInfo);
    HRESULT _CoDecrementInitMain(LPHINITREF phInitRef=NULL);
    void    _ProcessCommandLineFlags(LPWSTR *ppwszCmdLine, DWORD dwFlags);

private:
    // ----------------------------------------------------------------------------
    // PrivateData
    // ----------------------------------------------------------------------------
    LONG                m_cRef;                 // Reference Count
    HANDLE              m_hInstMutex;           // Startup/Shutdown mutex
    BOOL                m_fPumpingMsgs;         // Do we have a message pump running ?
    LONG                m_cDllRef;              // Dll Reference Count
    LONG                m_cDllLock;             // Dll Reference Count
    LONG                m_cDllInit;             // Number of inits
    DWORD               m_dwThreadId;           // Thread that I was created on
    CRITICAL_SECTION    m_cs;                   // Thread Safety
    BOOL                m_fSwitchingUsers;      // Multiple user switch is happening
    TCHAR *             m_szSwitchToUsername;   // Switching to a specific user
    HWND                m_hwndSplash;
    ISplashScreen      *m_pSplash;
    BOOL                m_fIncremented;
    HICON               m_hTrayIcon;
};

#endif // __INSTANCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\multiusr.cpp ===
/*******************************************************
    MultiUsr.cpp

    Code for handling multiple user functionality in
    Outlook Express.

    Initially by Christopher Evans (cevans) 4/28/98
********************************************************/
#include "pch.hxx"
#include "multiusr.h"
#include "demand.h"
#include "instance.h"
#include "acctutil.h"
#include "options.h"
#include "conman.h"
#include <..\help\mailnews.h>
#include "msident.h"
#include "menures.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#ifndef THOR_SETUP
#include <shlwapi.h>
#define strstr                  StrStr
#define RegDeleteKeyRecursive   SHDeleteKey
#endif // THOR_SETUP

TCHAR g_szRegRoot[MAX_PATH] = "";
static TCHAR g_szCharsetRegRoot[MAX_PATH] = "";
static TCHAR g_szIdentityName[CCH_USERNAME_MAX_LENGTH+1];
static BOOL g_fUsingDefaultId = FALSE;
static IUserIdentityManager *g_pIdMan = NULL;
static HKEY g_hkeyIdentity = HKEY_CURRENT_USER;
static BOOL g_fIdentitiesDisabled = FALSE;

extern DWORD g_dwIcwFlags;

GUID *PGUIDCurrentOrDefault(void) {
    return (g_fUsingDefaultId ? (GUID *)&UID_GIBC_DEFAULT_USER : (GUID *)&UID_GIBC_CURRENT_USER);
}

static void SafeIdentityRelease()
{
    if (g_pIdMan && 0 == (g_pIdMan)->Release()) 
    {
        g_pIdMan = NULL; 
        RegCloseKey(g_hkeyIdentity); 
        g_hkeyIdentity = HKEY_CURRENT_USER;
    }
}

/*
    MU_RegisterIdentityNotifier

    Handles the dirty work of registering an identity notifier.
    Caller needs to hold on to dwCookie and use it to unadvise.
*/
HRESULT MU_RegisterIdentityNotifier(IUnknown *punk, DWORD *pdwCookie)
{
    IConnectionPoint *pConnectPt = NULL;
    HRESULT hr = S_OK;
    
    Assert(pdwCookie);
    Assert(punk);
    Assert(g_pIdMan);

    if (SUCCEEDED(hr = g_pIdMan->QueryInterface(IID_IConnectionPoint, (void **)&pConnectPt)))
    {
        Assert(pConnectPt);

        SideAssert(SUCCEEDED(hr = pConnectPt->Advise(punk, pdwCookie)));
        
        SafeRelease(pConnectPt);
        g_pIdMan->AddRef();
    }

    return hr;
}


/*
    MU_RegisterIdentityNotifier

    Handles the dirty work of unregistering an identity notifier.
    dwCookie is the cookie returned from MU_RegisterIdentityNotifier.
*/
HRESULT MU_UnregisterIdentityNotifier(DWORD dwCookie)
{
    IConnectionPoint *pConnectPt = NULL;
    HRESULT hr = S_OK;

    Assert(g_pIdMan);

    if (SUCCEEDED(hr = g_pIdMan->QueryInterface(IID_IConnectionPoint, (void **)&pConnectPt)))
    {
        Assert(pConnectPt);

        SideAssert(SUCCEEDED(hr = pConnectPt->Unadvise(dwCookie)));
        
        SafeRelease(pConnectPt);
        SafeIdentityRelease();
    }
    return hr;
}

/*
    MU_CheckForIdentitySwitch

    Check to see if the switch is actually a logout, or just a switch.
    Then tell the COutlookExpress object so that it can restart if
    necessary
*/
BOOL MU_CheckForIdentityLogout()
{
    HRESULT hr;
    IUserIdentity   *pIdentity = NULL;
    BOOL    fIsLogout = TRUE;
    GUID    uidCookie;

    Assert(g_pIdMan);
    
    if (SUCCEEDED(hr = g_pIdMan->GetIdentityByCookie((GUID *)&UID_GIBC_INCOMING_USER, &pIdentity)))
    {
        if (pIdentity)
        {
            pIdentity->GetCookie(&uidCookie);

            fIsLogout = (uidCookie == GUID_NULL);
            pIdentity->Release();
        }
    }

    return fIsLogout;
}


/*
    MU_ShowErrorMessage

    Simple wrapper around resource string table based call to MessageBox
*/
void MU_ShowErrorMessage(HINSTANCE     hInst, 
                        HWND        hwnd, 
                        UINT        iMsgID, 
                        UINT        iTitleID)
{
    char    szMsg[255], szTitle[63];

    LoadString(g_hLocRes, iMsgID, szMsg, sizeof(szMsg));
    LoadString(g_hLocRes, iTitleID, szTitle, sizeof(szTitle));
    MessageBox(hwnd, szMsg, szTitle, MB_OK);
}

// --------------------------------------------------------------------------------
//  Functions to convert GUIDs to ascii strings
// --------------------------------------------------------------------------------

static int AStringFromGUID(GUID *puid,  TCHAR *lpsz, int cch)
{
    WCHAR   wsz[255];
    int     i;

    i = StringFromGUID2(*puid, wsz, 255);

    if (WideCharToMultiByte(CP_ACP, 0, wsz, -1, lpsz, cch, NULL, NULL) == 0)
        return 0;
    
    return (lstrlen(lpsz) + 1);
}


static HRESULT GUIDFromAString(TCHAR *lpsz, GUID *puid)
{
    WCHAR   wsz[255];
    HRESULT hr;

    if (MultiByteToWideChar(CP_ACP, 0, lpsz, -1, wsz, 255) == 0)
        return GetLastError();

    hr = CLSIDFromString(wsz, puid);
    
    return hr;
}

/*
    MU_GetCurrentUserInfo

    return the current user's id (guid) and username as strings
*/
HRESULT MU_GetCurrentUserInfo(LPSTR pszId, UINT cchId, LPSTR pszName, UINT cchName)
{
    HRESULT     hr = E_UNEXPECTED;
    IUserIdentity   *pIdentity = NULL;
    GUID        uidUserId;
    WCHAR       szwName[CCH_USERNAME_MAX_LENGTH+1];

    Assert(g_pIdMan);

    // we have to have the IUserIdentityManager
    if (!g_pIdMan)
        goto exit;
    
    // Get the current user
    if (FAILED(hr = g_pIdMan->GetIdentityByCookie(PGUIDCurrentOrDefault(), &pIdentity)))
        goto exit;
    
    // if the caller wants the id
    if (pszId)
    {
        // get the cookie (id) as a guid
        if (FAILED(hr = pIdentity->GetCookie(&uidUserId)))
            goto exit;

        // turn it into a string
        if (0 == AStringFromGUID(&uidUserId,  pszId, cchId))
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }

    // if the caller wants the user's name
    if (pszName)
    {
        // get the name as a wide string
        if (FAILED(hr = pIdentity->GetName(szwName, cchName)))
            goto exit;

        // convert it to an ascii string
        if (WideCharToMultiByte(CP_ACP, 0, szwName, -1, pszName, cchName, NULL, NULL) == 0)
            hr = GetLastError();
    }

exit:
    // clean up
    SafeRelease(pIdentity);

    return hr;
}

/*
    MU_GetCurrentUserHKey

    Return the current user's HKEY.

    If no one has logged on yet (this happens when coming in from SMAPI)
    then do the login first.  If the user cancels the login, just return
    the hkey for the default user.

    Caller should not close this key.  It is a common key.  If it is going 
    to be passed out to another library or something, caller should call 
    MU_OpenCurrentUserHkey.
*/
HKEY    MU_GetCurrentUserHKey()
{
    IUserIdentity *pIdentity = NULL;
    HRESULT hr;
    HKEY    hkey;

    // g_hkeyIdentity is initialized to HKEY_CURRENT_USER
    if (g_hkeyIdentity == HKEY_CURRENT_USER)
    {
        // we haven't logged in yet.  Lets try now
        if (!MU_Login(GetDesktopWindow(), FALSE, ""))
        {
            Assert(g_pIdMan);

            if (NULL == g_pIdMan)
                goto exit;

            // if they cancelled or whatever, try to get the
            // default user
            if (FAILED(hr = g_pIdMan->GetIdentityByCookie((GUID *)&UID_GIBC_DEFAULT_USER, &pIdentity)))
                goto exit;
        }
        else
        {
            // login succeeded, get the current identity
            Assert(g_pIdMan);

            if (NULL == g_pIdMan)
                goto exit;

            if (FAILED(hr = g_pIdMan->GetIdentityByCookie(PGUIDCurrentOrDefault(), &pIdentity)))
                goto exit;
        }
        
        if (g_hkeyIdentity != HKEY_CURRENT_USER)
            RegCloseKey(g_hkeyIdentity);

        // open a new all access reg key.  Caller must close it
        if (pIdentity && SUCCEEDED(hr = pIdentity->OpenIdentityRegKey(KEY_ALL_ACCESS, &hkey)))
            g_hkeyIdentity = hkey;
        else
            g_hkeyIdentity = HKEY_CURRENT_USER;
    }
exit:
    // Clean up
    SafeRelease(pIdentity);
    return g_hkeyIdentity;
}


/*
    MU_OpenCurrentUserHkey

    Open a new reg key for the current user.  
*/
HRESULT MU_OpenCurrentUserHkey(HKEY *pHkey)
{
    HRESULT     hr = E_UNEXPECTED;
    IUserIdentity   *pIdentity = NULL;
    GUID        uidUserId;

    Assert(g_pIdMan);
    
    // we have to have the IUserIdentityManager
    if (!g_pIdMan)
        goto exit;
    
    // Get the current identity.  If we can't get it, bail.
    if (FAILED(hr = g_pIdMan->GetIdentityByCookie(PGUIDCurrentOrDefault(), &pIdentity)))
        goto exit;
    
    // If passed in an hkey pointer, open a new all access key
    if (pHkey)
        hr = pIdentity->OpenIdentityRegKey(KEY_ALL_ACCESS, pHkey);

exit:
    // Clean up
    SafeRelease(pIdentity);
    return hr;

}


/*
    MU_GetCurrentUserDirectoryRoot

    Return the path to the top of the current user's root directory.
    This is the directory where the mail store should be located.
    It is in a subfolder the App Data folder.

    lpszUserRoot is a pointer to a character buffer that is cch chars
    in size.
*/
HRESULT MU_GetCurrentUserDirectoryRoot(TCHAR   *lpszUserRoot, int cch)
{
    HRESULT hr = E_FAIL;
    IUserIdentity *pIdentity = NULL;

    Assert(g_pIdMan);
    Assert(lpszUserRoot != NULL);
    Assert(cch >= MAX_PATH);

    if (g_pIdMan == NULL)
        goto exit;
    if (FAILED(hr = g_pIdMan->GetIdentityByCookie(PGUIDCurrentOrDefault(), &pIdentity)))
        goto exit;
    hr = MU_GetIdentityDirectoryRoot(pIdentity, lpszUserRoot, cch);

exit:
    SafeRelease(pIdentity);

    return hr;
}

HRESULT MU_GetIdentityDirectoryRoot(IUserIdentity *pIdentity, LPSTR lpszUserRoot, int cch)
{
    HRESULT hr;
    TCHAR szSubDir[MAX_PATH], *psz;
    WCHAR szwUserRoot[MAX_PATH];
    int cb;

    Assert(pIdentity);
    Assert(lpszUserRoot != NULL);
    Assert(cch >= MAX_PATH);

    hr = pIdentity->GetIdentityFolder(GIF_NON_ROAMING_FOLDER, szwUserRoot, MAX_PATH);
    if (FAILED(hr))
        return(hr);
    
    if (WideCharToMultiByte(CP_ACP, 0, szwUserRoot, -1, lpszUserRoot, cch, NULL, NULL) == 0)
        return(E_FAIL);

    AthLoadString(idsMicrosoft, szSubDir, ARRAYSIZE(szSubDir));
    psz = PathAddBackslash(szSubDir);
    AthLoadString(idsAthena, psz, ARRAYSIZE(szSubDir));

    cb = lstrlen(lpszUserRoot) + lstrlen(szSubDir) + 1;
    if (cb < cch)
    {
        psz = PathAddBackslash(lpszUserRoot);
        if (psz)
        {
            lstrcpy(psz, szSubDir);
            psz = PathAddBackslash(lpszUserRoot);
        }
        
        hr = S_OK;
    }

    return(hr);
}

DWORD  MU_CountUsers()
{
    IEnumUserIdentity  *pEnum = NULL;
    HRESULT             hr;
    ULONG               cUsers = 0;

    Assert(g_pIdMan);
    
    if (SUCCEEDED(hr = g_pIdMan->EnumIdentities(&pEnum)) && pEnum)
    {
        pEnum->GetCount(&cUsers);
    
        SafeRelease(pEnum);
    }
    return cUsers;

}

/*
    MU_Login

    Wrapper routine for logging in to OE.  Asks the user to choose a username
    and, if necessary, enter the password for that user.  The user can also
    create an account at this point.  

    lpszUsername should contain the name of the person who should be the default
    selection in the list.  If the name is empty ("") then it will look up the
    default from the registry.

    Returns the username that was selected in lpszUsername.  Returns true
    if that username is valid.
*/
BOOL        MU_Login(HWND hwnd, BOOL fForceUI, char *lpszUsername) 
{
    HRESULT hr = S_OK;
    IUserIdentity   *pIdentity = NULL;

    if (g_fUsingDefaultId)
        goto exit;

    if (NULL == g_pIdMan)
    {
        hr = MU_Init(FALSE);
        if (FAILED(hr))
            goto exit;
    }

#pragma prefast(suppress:11, "noise")
    g_pIdMan->AddRef();

#pragma prefast(suppress:11, "noise")
    hr = g_pIdMan->Logon(hwnd, (fForceUI ? UIL_FORCE_UI : 0), &pIdentity);

    if (SUCCEEDED(hr))
    {
        g_fIdentitiesDisabled = (hr == S_IDENTITIES_DISABLED);

        if (!fForceUI)
        {
            if (g_hkeyIdentity != HKEY_CURRENT_USER)
                RegCloseKey(g_hkeyIdentity);

            hr = pIdentity->OpenIdentityRegKey(KEY_ALL_ACCESS,&g_hkeyIdentity);
        }

        SafeRelease(pIdentity);
    }
    SafeIdentityRelease();
exit:
    return SUCCEEDED(hr);
}

BOOL        MU_Logoff(HWND hwnd)
{
    HRESULT hr=E_FAIL;

    Assert(g_pIdMan);

    if (g_pIdMan)
        hr = g_pIdMan->Logoff(hwnd);
    return SUCCEEDED(hr);
}

/*
    MU_MigrateFirstUserSettings

    This should only be called once, when there are no users configured yet.
*/
#define MAXDATA_LENGTH      16L*1024L

void        MU_MigrateFirstUserSettings(void)
{
/*    OEUSERINFO  vCurrentUser;
    TCHAR   szLM[255];
    HKEY    hDestinationKey = NULL;
    HKEY    hSourceKey = NULL;
    FILETIME    ftCU = {0,1}, ftLM = {0,0};     //default CU to just later than LM
    DWORD   dwType, dwSize, dwStatus;

    if (MU_GetCurrentUserInfo(&vCurrentUser))
    {
        TCHAR   szRegPath[MAX_PATH], szAcctPath[MAX_PATH];

        Assert(vCurrentUser.idUserID != -1);
        
        MU_GetRegRootForUserID(vCurrentUser.idUserID, szRegPath);
        Assert(*szRegPath);

        MU_GetAccountRegRootForUserID(vCurrentUser.idUserID, szAcctPath);
        Assert(*szAcctPath);

        hDestinationKey = NULL;
            
        if (RegCreateKey(HKEY_CURRENT_USER, szAcctPath, &hDestinationKey) == ERROR_SUCCESS)
        {
          if (RegOpenKey(HKEY_CURRENT_USER, c_szInetAcctMgrRegKey, &hSourceKey) == ERROR_SUCCESS)
          {
              CopyRegistry(hSourceKey, hDestinationKey);
              RegCloseKey(hSourceKey);
          }
          RegCloseKey(hDestinationKey);
        }
            
        if (RegCreateKey(HKEY_CURRENT_USER, szRegPath, &hDestinationKey) == ERROR_SUCCESS)
        {
            if (RegOpenKey(HKEY_CURRENT_USER, c_szRegRoot, &hSourceKey) == ERROR_SUCCESS)
            {
                DWORD EnumIndex;
                DWORD cbValueName;
                DWORD cbValueData;
                DWORD Type;
                CHAR ValueNameBuffer[MAXKEYNAME];
                BYTE ValueDataBuffer[MAXDATA_LENGTH];
                
                //
                //  Copy all of the value names and their data.
                //

                EnumIndex = 0;

                while (TRUE) {

                    cbValueName = sizeof(ValueNameBuffer);
                    cbValueData = MAXDATA_LENGTH;

                    if (RegEnumValue(hSourceKey, EnumIndex++, ValueNameBuffer,
                        &cbValueName, NULL, &Type, ValueDataBuffer, &cbValueData) !=
                        ERROR_SUCCESS)
                        break;

                    RegSetValueEx(hDestinationKey, ValueNameBuffer, 0, Type,
                        ValueDataBuffer, cbValueData);

                }


                RegSetValueEx(hDestinationKey, c_szUserID, 0, REG_DWORD, (BYTE *)&vCurrentUser.idUserID, sizeof(DWORD));

                //
                //  Copy all of the subkeys and recurse into them.
                //

                EnumIndex = 0;

                while (TRUE) 
                {
                    HKEY    hSourceSubKey, hDestinationSubKey;

                    if (RegEnumKey(hSourceKey, EnumIndex++, ValueNameBuffer, MAXKEYNAME) !=
                        ERROR_SUCCESS)
                        break;
                    
                    // don't recursively copy the Profiles key into the profiles key.
                    if (lstrcmpi(ValueNameBuffer, "Profiles") != 0)
                    {
                        if (RegOpenKey(hSourceKey, ValueNameBuffer, &hSourceSubKey) ==
                            ERROR_SUCCESS) 
                        {

                            if (RegCreateKey(hDestinationKey, ValueNameBuffer,
                                &hDestinationSubKey) == ERROR_SUCCESS) 
                            {

                                CopyRegistry(hSourceSubKey, hDestinationSubKey);

                                RegCloseKey(hDestinationSubKey);

                            }

                            RegCloseKey(hSourceSubKey);

                        }
                    }
                }

                RegCloseKey(hSourceKey);
            }
            RegCloseKey(hDestinationKey);
        }
    }
    */
}


/*
    MU_ShutdownCurrentUser

    Do everything necessary to get the app to the point where 
    calling CoDecrementInit will tear everything else down.
*/
BOOL    MU_ShutdownCurrentUser(void)
{
    HWND    hWnd, hNextWnd = NULL;
    BOOL    bResult = true;
    LRESULT lResult;
    DWORD   dwProcessId, dwWndProcessId;
    HINITREF hInitRef;
/*
    g_pInstance->SetSwitchingUsers(true);

    dwProcessId = GetCurrentProcessId();
    
    g_pInstance->CoIncrementInit(0, "", &hInitRef);

    hWnd = GetTopWindow(NULL);

    if (g_pConMan->IsConnected())
    {
         if (IDNO == AthMessageBoxW(hWnd, MAKEINTRESOURCEW(idsSwitchUser),MAKEINTRESOURCEW(idsMaintainConnection),  
                              NULL, MB_ICONEXCLAMATION  | MB_YESNO | MB_DEFBUTTON1 | MB_APPLMODAL))
            g_pConMan->Disconnect(hWnd, TRUE, FALSE, FALSE );
    }

    while (hWnd)
    {
        hNextWnd = GetNextWindow(hWnd, GW_HWNDNEXT);
        
        GetWindowThreadProcessId(hWnd,&dwWndProcessId); 
        
        if (dwProcessId == dwWndProcessId && IsWindowVisible(hWnd))
        {
            TCHAR   szWndClassName[255];

            GetClassName( hWnd,  szWndClassName, sizeof(szWndClassName));
            
            if (lstrcmp(szWndClassName, g_szDBNotifyWndProc) != 0 &&
                lstrcmp(szWndClassName, g_szDBListenWndProc) != 0)
            {

                lResult = SendMessage(hWnd, WM_CLOSE, 0, 0);

                // if the window is still there, something is wrong
                if(lResult != ERROR_SUCCESS || GetTopWindow(NULL) == hWnd)
                {
                    Assert(GetTopWindow(NULL) != hWnd); 
                    return false;
                }
            }
        }

        hWnd = hNextWnd;
    }

    g_pInstance->CoDecrementInit(&hInitRef);
*/
    return bResult;
}



/*
    _GetRegRootForUserID

    HACK ALERT

    The proper way to store registry things with identities is to use the
    HKEY that is returned from IUserIdentity::OpenIdentityRegKey.  This is 
    here only because some old interfaces assume HKEY_CURRENT_USER.   Those
    that do, need to be fixed.  In the meantime, we have this
*/
HRESULT     _GetRegRootForUserID(GUID *puidUserId, LPSTR pszPath, DWORD cch)
{
    HRESULT         hr = S_OK;
    IUserIdentity  *pIdentity = NULL;
    TCHAR           szPath[MAX_PATH];
    HKEY            hkey;
    TCHAR           szUid[255];
    GUID            uidIdentityId;

    Assert(pszPath);
    Assert(g_pIdMan);
    Assert(puidUserId);
    if (g_pIdMan == NULL)
    {
        hr = E_FAIL;
        goto exit;
    }

    if (FAILED(hr = g_pIdMan->GetIdentityByCookie(puidUserId, &pIdentity)))
        goto exit;

    if (FAILED(hr = pIdentity->GetCookie(&uidIdentityId)))
        goto exit;

    AStringFromGUID(&uidIdentityId,  szUid, 255);
    wsprintf(pszPath, "%s\\%s\\%s", "Identities", szUid, c_szRegRoot);

exit:
    SafeRelease(pIdentity);
    return hr;
}



LPCTSTR     MU_GetRegRoot()
{
    if (*g_szRegRoot)
        return g_szRegRoot;

    if (FAILED(_GetRegRootForUserID(PGUIDCurrentOrDefault(), g_szRegRoot, ARRAYSIZE(g_szRegRoot))))
        _GetRegRootForUserID((GUID *)&UID_GIBC_DEFAULT_USER, g_szRegRoot, ARRAYSIZE(g_szRegRoot));

    return g_szRegRoot;
}

LPCSTR MU_GetCurrentIdentityName()
{
    HRESULT hr;
    IUserIdentity *pIdentity = NULL;
    WCHAR   szwName[CCH_USERNAME_MAX_LENGTH+1];

    Assert(g_pIdMan);
    if (g_pIdMan == NULL)
        return NULL;
    
    if (*g_szIdentityName)
        return g_szIdentityName;
    
    if (MU_CountUsers() == 1)
        g_szIdentityName[0] = 0;
    else
    {
        if (FAILED(hr = g_pIdMan->GetIdentityByCookie(PGUIDCurrentOrDefault(), &pIdentity)))
            goto exit;

        if (!pIdentity)
            goto exit;

        if (FAILED(hr = pIdentity->GetName(szwName, CCH_USERNAME_MAX_LENGTH)))
            goto exit;

        if (WideCharToMultiByte(CP_ACP, 0, szwName, -1, g_szIdentityName, CCH_USERNAME_MAX_LENGTH, NULL, NULL) == 0)
        {
            g_szIdentityName[0] = 0;
            goto exit;
        }
    }
exit:
    SafeRelease(pIdentity);
    return g_szIdentityName;
}

void  MU_ResetRegRoot()
{
    RegCloseKey(g_hkeyIdentity);
    g_hkeyIdentity = HKEY_CURRENT_USER;
    g_szRegRoot[0] = 0;
    g_szIdentityName[0] = 0;
    g_dwIcwFlags = 0;
}

void MigrateOEMultiUserToIdentities(void)
{
    TCHAR   szProfilesPath[] = "Software\\Microsoft\\Outlook Express\\5.0\\Profiles";
    TCHAR   szCheckKeyPath[] = "Software\\Microsoft\\Outlook Express\\5.0\\Shared Settings\\Setup";
    TCHAR   szPath[MAX_PATH], szProfilePath[MAX_PATH];
    HKEY    hOldKey, hOldSubkey, hNewTopKey, hNewOEKey, hNewIAMKey, hCheckKey = NULL;
    DWORD   EnumIndex;
    DWORD   cbKeyName, cUsers;
    DWORD   dwType, dwValue, dwStatus, dwSize;
    CHAR    KeyNameBuffer[1024];
    IPrivateIdentityManager *pPrivIdMgr;
    HRESULT hr;

    if (NULL == g_pIdMan)
    {
        hr = CoCreateInstance(CLSID_UserIdentityManager, NULL, CLSCTX_INPROC_SERVER, IID_IUserIdentityManager, (LPVOID *)&g_pIdMan);
        
        if (FAILED(hr))
            return;
    }

    Assert(g_pIdMan);

    if (FAILED(g_pIdMan->QueryInterface(IID_IPrivateIdentityManager, (void **)&pPrivIdMgr)))
        return;

    if (RegOpenKey(HKEY_CURRENT_USER, szProfilesPath, &hOldKey) == ERROR_SUCCESS)
    {
        dwStatus = RegCreateKey(HKEY_CURRENT_USER, szCheckKeyPath, &hCheckKey);

        dwSize = sizeof(dwValue);
        if (dwStatus != ERROR_SUCCESS ||
            (dwStatus = RegQueryValueEx(hCheckKey, "MigToLWP", NULL, &dwType, (LPBYTE)&dwValue, &dwSize)) != ERROR_SUCCESS ||
                        (1 != dwValue))
        {
            //
            //  Copy all of the value names and their data.
            //

            dwStatus = RegQueryInfoKey(hOldKey, NULL, NULL, 0, &cUsers, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

            EnumIndex = 0;

            while (TRUE && cUsers > 0) 
            {

                cbKeyName = sizeof(KeyNameBuffer);

                if (RegEnumKey(hOldKey, EnumIndex++, KeyNameBuffer, cbKeyName) !=
                    ERROR_SUCCESS)
                    break;
            
                wsprintf(szProfilePath, "%s\\Application Data", KeyNameBuffer);

                if (ERROR_SUCCESS == RegOpenKey(hOldKey, szProfilePath, &hOldSubkey))
                {
                    TCHAR   szUserName[CCH_USERNAME_MAX_LENGTH+1];
                    WCHAR   szwUserName[CCH_USERNAME_MAX_LENGTH+1];
                    IUserIdentity *pIdentity = NULL;

                    dwSize = sizeof(szUserName);
                    if ((dwStatus = RegQueryValueEx(hOldSubkey, "Current Username", NULL, &dwType, (LPBYTE)szUserName, &dwSize)) == ERROR_SUCCESS &&
                            (0 != *szUserName))
                    {
                        if (MultiByteToWideChar(CP_ACP, 0, szUserName, -1, szwUserName, CCH_USERNAME_MAX_LENGTH) == 0)
                            goto UserFailed;
                        
                        if (cUsers == 1)
                        {
                            if (FAILED(g_pIdMan->GetIdentityByCookie((GUID *)&UID_GIBC_DEFAULT_USER, &pIdentity)) || !pIdentity)
                                goto UserFailed;
                        }
                        else
                        {
                            if (FAILED(pPrivIdMgr->CreateIdentity(szwUserName, &pIdentity)) || !pIdentity)
                                goto UserFailed;
                        }
                        if (FAILED(pIdentity->OpenIdentityRegKey(KEY_ALL_ACCESS, &hNewTopKey)))
                            goto UserFailed;

                        if (ERROR_SUCCESS == RegCreateKey(hNewTopKey, c_szRegRoot, &hNewOEKey))
                        {
                            CopyRegistry(hOldSubkey, hNewOEKey);
                            RegCloseKey(hNewOEKey);
                        }

                        // now copy the IAM settings
                        wsprintf(szProfilePath, "%s\\Internet Accounts", KeyNameBuffer);
                    
                        RegCloseKey(hOldSubkey);
                        hOldSubkey = NULL;

                        if (ERROR_SUCCESS == RegOpenKey(hOldKey, szProfilePath, &hOldSubkey))
                        {
                            if (ERROR_SUCCESS == RegCreateKey(hNewTopKey, c_szInetAcctMgrRegKey, &hNewIAMKey))
                            {
                                CopyRegistry(hOldSubkey, hNewIAMKey);
                                RegCloseKey(hNewIAMKey);
                            }
                        }
                    

UserFailed:
                        RegCloseKey(hNewTopKey);
                        SafeRelease(pIdentity);
                        if (hOldSubkey)
                        {
                            RegCloseKey(hOldSubkey);
                            hOldSubkey = NULL;
                        }
                    }
                }

            }

            dwValue = 1;
            RegSetValueEx(hCheckKey, "MigToLWP", 0, REG_DWORD, (BYTE *)&dwValue, sizeof(DWORD));
        }
        if (hCheckKey != NULL)
            RegCloseKey(hCheckKey);
        RegCloseKey(hOldKey);

    }
    pPrivIdMgr->Release();
}

BOOL    MU_IdentitiesDisabled()
{
    return g_fIdentitiesDisabled || (g_dwAthenaMode & MODE_NOIDENTITIES && !g_fPluralIDs);
}

void MU_UpdateIdentityMenus(HMENU hMenu)
{
    DWORD   cItems, dwIndex;
    MENUITEMINFO    mii;
    TCHAR   szLogoffString[255];
    TCHAR   szRes[255];

    if (MU_IdentitiesDisabled())
    {
        // Delete the switch identity menu
        DeleteMenu(hMenu, ID_SWITCH_IDENTITY, MF_BYCOMMAND);
        DeleteMenu(hMenu, ID_EXIT_LOGOFF, MF_BYCOMMAND);

        // loop through the other menu items looking for logoff
        cItems = GetMenuItemCount(hMenu);
    
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID;

        for (dwIndex = cItems; dwIndex > 0; --dwIndex)
        {
            GetMenuItemInfo(hMenu, dwIndex, TRUE, &mii);

            // if this is the logoff item, delete it and the separator 
            // line that follows
            if (mii.wID == ID_IDENTITIES)
            {
                DeleteMenu(hMenu, ID_IDENTITIES, MF_BYCOMMAND);
                DeleteMenu(hMenu, dwIndex, MF_BYPOSITION);
                break;
            }
        }
    }
    else
    {
        // Load a new menu string from the resources
        AthLoadString(idsLogoffFormat, szRes, ARRAYSIZE(szRes));

        // Format it
        wsprintf(szLogoffString, szRes, MU_GetCurrentIdentityName());

        // Splat it on the menu
        ModifyMenu(hMenu, ID_LOGOFF_IDENTITY, MF_BYCOMMAND | MF_STRING, ID_LOGOFF_IDENTITY, szLogoffString);
    }
}

void MU_NewIdentity(HWND hwnd)
{
    if (g_pIdMan)
    {
        g_pIdMan->ManageIdentities(hwnd, UIMI_CREATE_NEW_IDENTITY);
    }
}

void MU_ManageIdentities(HWND hwnd)
{
    if (g_pIdMan)
    {
        g_pIdMan->ManageIdentities(hwnd, 0);
    }
}

void MU_IdentityChanged()
{
    // flush the cached name so we reload it
    *g_szIdentityName = 0;
}

HRESULT MU_Init(BOOL fDefaultId)
{
    HRESULT hr = S_OK;

    g_fUsingDefaultId = fDefaultId;

    if (NULL == g_pIdMan)
    {
        hr = CoCreateInstance(CLSID_UserIdentityManager, NULL, CLSCTX_INPROC_SERVER, IID_IUserIdentityManager, (LPVOID *)&g_pIdMan);

        if (FAILED(hr))
            MU_ShowErrorMessage(g_hLocRes, GetDesktopWindow(), idsCantLoadMsident,idsAthenaTitle);
    }
    else
        g_pIdMan->AddRef();
    return hr;
}

void MU_Shutdown()
{
    Assert(g_pIdMan);
    if (g_pIdMan == NULL)
        return;

    SafeIdentityRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\navpane.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     navpane.h
//
//  PURPOSE:    Defines CNavPane class
//

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Forward Dec's
//
class CTreeView;
interface IMsgrAb;
interface IAthenaBrowser;
class CPaneFrame;


class CNavPane : public IDockingWindow,
                 public IObjectWithSite,
                 public IOleCommandTarget,
                 public IInputObjectSite,
                 public IInputObject
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
    CNavPane();
    ~CNavPane();

    HRESULT Initialize(CTreeView *pTreeView);

    BOOL IsTreeVisible() { return m_fTreeVisible; }
    BOOL ShowFolderList(BOOL fShow);
    BOOL ShowContacts(BOOL fShow);
    BOOL IsContactsFocus();

    /////////////////////////////////////////////////////////////////////////
    // IUnknown 
    //
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /////////////////////////////////////////////////////////////////////////
    // IOleWindow
    //
    STDMETHODIMP GetWindow(HWND* lphwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    /////////////////////////////////////////////////////////////////////////
    // IDockingWindow 
    //
    STDMETHODIMP ShowDW(BOOL fShow);
    STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder, IUnknown*  punkToolbarSite,
                                BOOL fReserved);
    STDMETHODIMP CloseDW(DWORD dwReserved);

    /////////////////////////////////////////////////////////////////////////
    // IObjectWithSite
    //
    STDMETHODIMP GetSite(REFIID riid, LPVOID *ppvSite);
    STDMETHODIMP SetSite(IUnknown   *pUnkSite);

    /////////////////////////////////////////////////////////////////////////
    // IOleCommandTarget
    //
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                             OLECMDTEXT *pCmdText);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                      VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    /////////////////////////////////////////////////////////////////////////
    // IInputObjectSite
    //
    STDMETHODIMP OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus);

    /////////////////////////////////////////////////////////////////////////
    // IInputObject
    //
    STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    STDMETHODIMP HasFocusIO(void);
    STDMETHODIMP TranslateAcceleratorIO(LPMSG pMsg);

private:
    /////////////////////////////////////////////////////////////////////////
    // Window Proc Goo
    //
    static LRESULT CALLBACK _WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT CALLBACK _NavWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    void _OnSize(HWND hwnd, UINT state, int cx, int cy);
    void _OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
    void _OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
    void _OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags);
    BOOL _OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg);
    UINT _OnNCHitTest(HWND hwnd, int x, int y);

    /////////////////////////////////////////////////////////////////////////
    // Utility stuff
    //
    HRESULT _CreateChildWindows(void);
    void _UpdateVisibleState(void);

private:
    /////////////////////////////////////////////////////////////////////////
    // Member Data
    //

    // All kinds of state
    ULONG               m_cRef;             // Ref count
    BOOL                m_fShow;            // TRUE if we're visible
    BOOL                m_fTreeVisible;     // TRUE if the treeview is visible
    BOOL                m_fContactsVisible; // TRUE if contacts are visible

    // Groovy window handles
    HWND                m_hwnd;             // Our window handle
    HWND                m_hwndParent;       // Our parent's window handle
    HWND                m_hwndTree;         // The folder list window handle
    HWND                m_hwndContacts;     // The contacts control window

    // Interfaces you only wish you could have
    IDockingWindowSite *m_pSite;            // Our site 
    CTreeView          *m_pTreeView;        // Folder list pointer
    IMsgrAb            *m_pContacts;        // Contacts control
    IOleCommandTarget  *m_pContactsTarget;  // Command target for contacts
    CPaneFrame         *m_pContactsFrame;   // Contacts control frame

    // Sizing information
    int                 m_cxWidth;          // How wide our outer window is
    BOOL                m_fResizing;        // TRUE if we're in the process of resizing
    BOOL                m_fSplitting;       // TRUE if we're splitting
    int                 m_cySplitPct;       // Split percentage between the two panes
    RECT                m_rcSplit;          // Rectangle of the split bar in screen coordinates
    RECT                m_rcSizeBorder;     // Rectangle of the right hand sizing bar
    int                 m_cyTitleBar;       // Height of the pane's title bar
};


class CPaneFrame : IInputObjectSite
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
    CPaneFrame();
    ~CPaneFrame();

    HWND Initialize(HWND hwndParent, IInputObjectSite *pSite, int idsTitle, int idMenu = 0);
    BOOL SetChild(HWND hwndChild, DWORD dwDispId, IAthenaBrowser *pBrowser, IObjectWithSite *pObject,
                  IOleCommandTarget *pTarget = 0);
    void ShowMenu(void);

    /////////////////////////////////////////////////////////////////////////
    // IUnknown 
    //
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /////////////////////////////////////////////////////////////////////////
    // IInputObjectSite
    //
    STDMETHODIMP OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus);

private:
    /////////////////////////////////////////////////////////////////////////
    // Window Proc Goo
    //
    static LRESULT CALLBACK _WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT CALLBACK _FrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL _OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void _OnSize(HWND hwnd, UINT state, int cx, int cy);
    void _OnPaint(HWND hwnd);
    void _OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void _OnToggleClosePin(HWND hwnd, BOOL fPin);
    void _OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
    void _OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
    void _OnTimer(HWND hwnd, UINT id);

    void _UpdateDrawingInfo(void);

    void _CreateCloseToolbar();
    void _SizeCloseToolbar();
    void _PositionToolbar(LPPOINT pt);

private:
    /////////////////////////////////////////////////////////////////////////
    // Member Data
    //

    ULONG               m_cRef;

    // Groovy Window Handles
    HWND                m_hwnd;
    HWND                m_hwndChild;
    HWND                m_hwndParent;

    // Child info
    IAthenaBrowser     *m_pBrowser;
    DWORD               m_dwDispId;
    IOleCommandTarget  *m_pTarget;
    int                 m_idMenu;
    IInputObjectSite   *m_pSite;

    // Drawing Info
    TCHAR               m_szTitle[CCHMAX_STRINGRES];
    HFONT               m_hFont;
    HBRUSH              m_hbr3DFace;
    UINT                m_cyTitleBar;
    RECT                m_rcChild;
    RECT                m_rcTitleButton;
    BOOL                m_fHighlightIndicator;
    BOOL                m_fHighlightPressed;

    // Toolbar Info
    HWND                m_hwndClose;
    DWORD               m_cButtons;
    BOOL                m_fPin;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\multiusr.h ===
/************************************************
    MultiUsr.h

    Header for multiple user functionality
    in Outlook Express.

    Initially by Christopher Evans (cevans) 4/28/98
*************************************************/
#ifndef _MULTIUSR_H
#define _MULTIUSR_H

interface IUserIdentity;

#define USERPASSWORD_MAX_LENGTH         16
#define CCH_USERNAME_MAX_LENGTH         63

HRESULT     MU_RegisterIdentityNotifier(IUnknown *punk, DWORD *pdwCookie);
HRESULT     MU_UnregisterIdentityNotifier(DWORD dwCookie);
BOOL        MU_CheckForIdentityLogout();

HRESULT     MU_GetCurrentUserInfo(LPSTR pszId, UINT cchId, LPSTR pszName, UINT cchName);
HRESULT     MU_GetCurrentUserDirectoryRoot(TCHAR   *lpszUserRoot, int cch);
HRESULT     MU_GetIdentityDirectoryRoot(IUserIdentity *pIdentity, LPSTR lpszUserRoot, int cch);
HKEY        MU_GetCurrentUserHKey();
HRESULT     MU_OpenCurrentUserHkey(HKEY *pHkey);
BOOL        MU_Login(HWND hwnd, BOOL fForceUI, char *lpszUsername);
BOOL        MU_Logoff(HWND hwnd);
DWORD       MU_CountUsers();
LPCTSTR     MU_GetRegRoot();
void        MU_ResetRegRoot();
LPCSTR      MU_GetCurrentIdentityName();
void        MigrateOEMultiUserToIdentities(void);
BOOL        MU_IdentitiesDisabled();
void        MU_UpdateIdentityMenus(HMENU hMenu);
void        MU_IdentityChanged();
HRESULT     MU_Init(BOOL fDefaultId);
void        MU_Shutdown();
void        MU_NewIdentity(HWND hwnd);
void        MU_ManageIdentities(HWND hwnd);
GUID       *PGUIDCurrentOrDefault(void);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\rundll.cpp ===
//
//  DLL.CPP - Dll initialization routines
//

#include "pch.hxx"
#include "strconst.h"
#include <shlguid.h>
#include "ourguid.h"
#include "globals.h"
#include "folder.h"
#include "newsview.h"
#include "mimeole.h"
#include "mimeutil.h"
#include "mailnote.h"
#include "newsnote.h"
#include "resource.h"
#include "init.h"
#include <store.h>
#include "url.h" 
#include "shelutil.h"
#include <goptions.h>
#include "nnserver.h"
#include "storfldr.h"   // IsThisNashville
#include "strconst.h"
#include "grplist.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include <secutil.h>
#include <error.h>
#ifndef WIN16  //RUN16_MSLU
#include <msluapi.h>
#include <msluguid.h>
#endif //!WIN16

extern HRESULT BrowseToObject(LPCITEMIDLIST pidl);
HRESULT HrOpenMessage(HFOLDER hfldr, MSGID msgid, LPMIMEMESSAGE *ppMsg);
BOOL ParseFolderMsgId(LPSTR pszCmdLine, HFOLDER *phfldr, MSGID *pmsgid);
HRESULT HrDownloadArticleDialog(CNNTPServer *pNNTPServer, LPTSTR pszArticle, LPMIMEMESSAGE *ppMsg);


///////////////////////////////////////////////////////////////////////
//
//  FUNCTION:   HandleNWSFile
//
//  PURPOSE:    Provides an entry point into Thor that allows us to be
//              invoked from a URL.  The pszCmdLine paramter must be a
//              valid News URL or nothing happens.
//
///////////////////////////////////////////////////////////////////////
HRESULT HandleNWSFile(LPTSTR pszCmd)
{
#ifndef WIN16  //RUN16_NEWS
    LPMIMEMESSAGE   pMsg;
    int             idsErr = idsNewsRundllFailed;
    NCINFO          nci = { 0 };

    if (!pszCmd|| !*pszCmd)
        goto exit; 
    
    DOUTL(1, TEXT("HandleNWSFile - pszCmd = %s"), pszCmd);

    if ((UINT)GetFileAttributes (pszCmd) == (UINT)-1)    
        {
        idsErr = idsErrNewsCantOpen;
        goto exit;
        }

    // Do the basic DLL initialization first.
    if (!Initialize_RunDLL(FALSE))
        goto exit;
        
    // Create new message
    if (SUCCEEDED(HrCreateMessage(&pMsg)))
        {
        if (SUCCEEDED(HrLoadMsgFromFile(pMsg, pszCmd)))
            {
            LPSTR lpszUnsent;

            nci.ntNote = ntReadNote;
            nci.dwFlags = NCF_NEWS;
            nci.pMsg = pMsg;

            if (MimeOleGetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_XUNSENT), NOFLAGS, &lpszUnsent) == S_OK)
                {
                if (*lpszUnsent)
                    nci.ntNote = ntSendNote;
                SafeMimeOleFree(lpszUnsent);
                }

            if (SUCCEEDED(HrCreateNote(&nci)))
                idsErr = 0;
            }
        else
            idsErr = idsErrNewsCantOpen;
        pMsg->Release();
        }

    Uninitialize_RunDLL();

exit:          
    if (idsErr)
        AthMessageBoxW(GetDesktopWindow(), 
                      MAKEINTRESOURCEW(idsAthenaNews), 
                      MAKEINTRESOURCEW(idsErr), 
                      0,
                      MB_ICONEXCLAMATION | MB_OK);
    return (idsErr) ? E_FAIL : S_OK;
#else
    return( E_NOTIMPL );
#endif //!WIN16
}

///////////////////////////////////////////////////////////////////////
//
//  FUNCTION:   HandleNewsArticleURL
//
//  PURPOSE:    Provides an entry point into Thor that allows us to be
//              invoked from a URL.  The pszCmdLine paramter must be a
//              valid News URL or nothing happens.
//
///////////////////////////////////////////////////////////////////////
HRESULT HandleNewsArticleURL(LPTSTR pszServerIn, LPTSTR pszArticle, UINT uPort, BOOL fSecure)
{
#ifndef WIN16  //RUN16_NEWS
    NCINFO          nci;
    CNNTPServer    *pNNTPServer = NULL;
    HRESULT         hr = E_FAIL;
    TCHAR           szAccount[CCHMAX_ACCOUNT_NAME];
    TCHAR           szArticleId[1024];
    IImnAccount    *pAcct = NULL;
    LPMIMEMESSAGE   pMsg = NULL;

    // The URL specified an article id.  In this case we ONLY want to 
    // display a ReadNote window.  This requires a bit of work.

    // Do the basic DLL initialization first.
    if (!Initialize_RunDLL(FALSE))
        {
        AthMessageBoxW(GetDesktopWindow(), 
                      MAKEINTRESOURCEW(idsAthenaNews), 
                      MAKEINTRESOURCEW(idsNewsRundllFailed), 
                      0,
                      MB_ICONEXCLAMATION | MB_OK);
        return E_FAIL;
        }
        
    // If a server was specified, then try to create a temp account for it
    if (pszServerIn && 
        *pszServerIn && 
        SUCCEEDED(NewsUtil_CreateTempAccount(pszServerIn, uPort, fSecure, &pAcct)))
        {
        pAcct->GetPropSz(AP_ACCOUNT_NAME, szAccount, ARRAYSIZE(szAccount));
        pAcct->Release();
        }        
    else
        {
        // If a server wasn't specified, then use the default account
        if (NewsUtil_GetDefaultServer(szAccount, ARRAYSIZE(szAccount)) != S_OK)
            goto exit;
        }

    // Need to invoke read note.  First create and initialize an server.
    pNNTPServer = new CNNTPServer();
    if (!pNNTPServer)
        goto exit;
    
    if (FAILED(pNNTPServer->HrInit(szAccount)))
        goto exit;

    if (FAILED(pNNTPServer->Connect()))
        goto exit;

    // Bug #10555 - The URL shouldn't have <> around the article ID, but some 
    //              lameoids probably will do it anyway, so deal with it.
    lstrcpy(szArticleId, pszArticle);
    if (!IsDBCSLeadByte(*pszArticle))
        {
        if (*pszArticle != '<')
            wsprintf(szArticleId, TEXT("<%s>"), pszArticle);
        }            

    if (SUCCEEDED(hr = HrDownloadArticleDialog(pNNTPServer, szArticleId, &pMsg)))
        {
        // Initialize the NNCI struct so we can invoke a note window.    
        ZeroMemory(&nci, sizeof(NCINFO));
        nci.ntNote = ntReadNote;
        nci.dwFlags = NCF_NEWS;
        nci.pMsg = pMsg;
        HrSetAccount(pMsg, szAccount);

        // Create the note.
        hr = HrCreateNote(&nci); 
        }

exit:
    SafeRelease(pNNTPServer);
    Uninitialize_RunDLL();

    if (FAILED(hr))
        AthMessageBoxW(GetDesktopWindow(), 
                      MAKEINTRESOURCEW(idsAthenaNews), 
                      MAKEINTRESOURCEW(idsErrNewsCantOpen), 
                      0,
                      MB_ICONEXCLAMATION | MB_OK);
    return hr;
#else
    return( E_NOTIMPL );
#endif //!WIN16
}

///////////////////////////////////////////////////////////////////////
//
//  FUNCTION:   HandleNewsURL
//
//  PURPOSE:    Provides an entry point into Thor that allows us to be
//              invoked from a URL.  The pszCmdLine paramter must be a
//              valid News URL or nothing happens.
//
///////////////////////////////////////////////////////////////////////
HRESULT HandleNewsURL(LPTSTR pszCmd)
{
#ifndef WIN16  //RUN16_NEWS
    LPTSTR       pszCmdLine = NULL;
    HRESULT      hr = E_FAIL;
    LPTSTR       pszServer = 0, pszGroup = 0, pszArticle = 0;
    UINT         uPort = (UINT) -1;
    BOOL         fSecure;

    if (!MemAlloc((LPVOID*) &pszCmdLine, (2 + lstrlen(pszCmd)) * sizeof(TCHAR)))
        goto exit;
    
    lstrcpy(pszCmdLine, pszCmd);
    UrlUnescapeInPlace(pszCmdLine, 0);

    DOUTL(1, TEXT("HandleNewsURL - pszCmdLine = %s"), pszCmdLine);

    if (!pszCmdLine || !*pszCmdLine)
        goto exit;
    
    // Figure out if the URL is valid and what type of URL it is.
    if (FAILED (URL_ParseNewsUrls(pszCmdLine, &pszServer, &uPort, &pszGroup, &pszArticle, &fSecure)))
        goto exit;

    if (uPort == -1)
        uPort = fSecure ? DEF_SNEWSPORT : DEF_NNTPPORT;

    if (pszArticle)
        {
        HandleNewsArticleURL(pszServer, pszArticle, uPort, fSecure);
        hr = S_OK;
        }
    else
        {
        LPITEMIDLIST pidl = NULL;
        ShellUtil_PidlFromNewsURL(pszServer, uPort, pszGroup, fSecure, &pidl);
        hr = BrowseToObject(pidl);
        if (pidl)
            PidlFree(pidl);
        }
    
exit:          
    if (pszCmdLine)
        MemFree(pszCmdLine);
    if (pszServer)    
        MemFree(pszServer);
    if (pszGroup)
        MemFree(pszGroup);
    if (pszArticle)
        MemFree(pszArticle);

    if (FAILED(hr))
        AthMessageBoxW(GetDesktopWindow(), MAKEINTRESOURCEW(idsAthenaNews), MAKEINTRESOURCEW(idsNewsRundllFailed), 0,
                      MB_ICONEXCLAMATION | MB_OK);
    return hr;
#else
    return( E_NOTIMPL );
#endif //!WIN16
}

///////////////////////////////////////////////////////////////////////
//
//  FUNCTION:   HandleEMLFile
//
//  PURPOSE:    Used to open EML files. 
// 
///////////////////////////////////////////////////////////////////////
HRESULT HandleEMLFile(LPTSTR pszCmd)
{
    LPMIMEMESSAGE   pMsg=0;
    NCINFO          nci;
    HRESULT         hr = E_FAIL;
    int             idsErr = idsMailRundllFailed;

    if (!pszCmd || !*pszCmd)
        goto exit;
    
    DOUTL(1, TEXT("HandleEMLFile - pszCmd = %s"), pszCmd);

    // Check to see the file is valid
    if ((UINT)GetFileAttributes (pszCmd) == (UINT)-1)
        {
        idsErr = idsErrNewsCantOpen;
        goto exit;
        }

    if (!Initialize_RunDLL(TRUE))
        goto exit;

    // Create new mail message
    if (SUCCEEDED(hr = HrCreateMessage(&pMsg)))
        {
        // OPIE: correct way load EML file thro' IPF???
        // Ensure that the string is ANSI.    
        if (SUCCEEDED(hr = HrLoadMsgFromFile(pMsg, pszCmd)))
            {
            if (SUCCEEDED(hr = HandleSecurity(GetDesktopWindow(), pMsg)))
                {
                LPSTR lpszUnsent;

                // Show the note
                ZeroMemory(&nci, sizeof(NCINFO));    
                nci.ntNote = ntReadNote;    
                nci.pMsg = pMsg;
                if (MimeOleGetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_XUNSENT), NOFLAGS, &lpszUnsent) == S_OK)
                    {
                    if (*lpszUnsent)
                        {
                        nci.ntNote = ntSendNote;
                        nci.dwFlags = NCF_SENDIMMEDIATE;   //always on dllentry points...
                        }
                    SafeMimeOleFree(lpszUnsent);
                    }            

                if (SUCCEEDED(hr = HrCreateNote(&nci)))
                    idsErr = 0;
                }
            }
        else
            idsErr = idsErrNewsCantOpen;
        pMsg->Release();
        }

    // Once the user quits or sends the note, we can quit.
    Uninitialize_RunDLL();

exit:
    if (idsErr && hr != HR_E_ATHSEC_FAILED)
        AthMessageBoxW(GetDesktopWindow(), 
                      MAKEINTRESOURCEW(idsAthenaMail), 
                      MAKEINTRESOURCEW(idsErr),
                      0, MB_ICONEXCLAMATION | MB_OK);
    return (idsErr) ? E_FAIL : S_OK;
}

///////////////////////////////////////////////////////////////////////
//
//  FUNCTION:   HandleMailURL
//
//  PURPOSE:    Provides an entry point into Thor that allows us to be
//              invoked from a URL.  The pszCmdLine paramter must be a
//              valid Mail URL or nothing happens.
//
///////////////////////////////////////////////////////////////////////
HRESULT HandleMailURL(LPTSTR pszCmd)
{
    LPMIMEMESSAGE   pMsg = NULL;
    HRESULT         hr = E_FAIL;

    if (!pszCmd || !*pszCmd)
        goto exit;

    // NOTE: no URLUnescape in this function - it must be done in URL_ParseMailTo to handle
    // URLs of the format:
    //
    //      mailto:foo@bar.com?subject=AT%26T%3dBell&cc=me@too.com
    //
    // so that the "AT%26T" is Unescaped into "AT&T=Bell" *AFTER* the "subject=AT%26T%3dBell&" blob is parsed.
    
    DOUTL(1, TEXT("HandleMailURL - pszCmd = %s"), pszCmd);

    if (SUCCEEDED(HrCreateMessage(&pMsg)))
        {
        if (SUCCEEDED(URL_ParseMailTo(pszCmd, pMsg)))
            {
            if (Initialize_RunDLL(TRUE))
                {
                NCINFO nci = {0};

                nci.ntNote = ntSendNote;
                nci.dwFlags = NCF_SENDIMMEDIATE;   //always on dllentry points...
                nci.pMsg = pMsg;

                hr = HrCreateNote(&nci);

                Uninitialize_RunDLL();
                }
            }
        pMsg->Release();
        }

exit:
    if (FAILED(hr))
        AthMessageBoxW(GetDesktopWindow(), 
                      MAKEINTRESOURCEW(idsAthenaMail), 
                      MAKEINTRESOURCEW(idsMailRundllFailed),
                      0, 
                      MB_ICONEXCLAMATION | MB_OK);
    return hr;
}

#ifndef WIN16  //RUN16_NEWS

typedef struct tagARTDOWNDLG {
    CNNTPServer  *pNNTPServer;
    LPTSTR       pszArticle;
    LPMIMEMESSAGE pMsg;
    LPSTREAM      pStream;
    DWORD         dwID;
    BOOL          fOK;
} ARTDOWNDLG, * PARTDOWNDLG;

#define DAD_SERVERCB    (WM_USER + 100)

BOOL CALLBACK DownloadArticleDlg(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PARTDOWNDLG pad = (PARTDOWNDLG)GetWindowLong(hwnd, DWL_USER);
    TCHAR szBuffer[CCHMAX_STRINGRES];
    TCHAR szRes[CCHMAX_STRINGRES];

    switch (msg)
        {
        case WM_INITDIALOG:
            {
            NNTPNOTIFY not = { NULL, hwnd, DAD_SERVERCB, 0 };
            HRESULT    hr;

            // replace some strings in the group download dialog
            AthLoadString(idsDownloadArtTitle, szRes, sizeof(szRes));
            SetWindowText(hwnd, szRes);
            AthLoadString(idsDownloadArtMsg, szRes, sizeof(szRes));
            SetDlgItemText(hwnd, idcStatic1, szRes);
    
            CenterDialog(hwnd);
            Assert(lParam);
            pad = (PARTDOWNDLG)lParam;
            SetWindowLong(hwnd, DWL_USER, lParam);

            Animate_Open(GetDlgItem(hwnd, idcAnimation), idanCopyMsgs);
            Animate_Play(GetDlgItem(hwnd, idcAnimation), 0, -1, -1);
            AthLoadString(idsProgReceivedLines, szRes, sizeof(szRes));
            wsprintf(szBuffer, szRes, 0);
            SetDlgItemText(hwnd, idcProgText, szBuffer);
            // start the group download
            if (SUCCEEDED(hr = pad->pNNTPServer->Article(&not, NULL, pad->pszArticle, pad->pStream)))
                {
                pad->dwID = not.dwID;
                SetForegroundWindow(hwnd);
                }
            else
                EndDialog(hwnd, 0);
            }
            return (TRUE);
            
        case WM_COMMAND:
            Assert(pad);
            if (GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL)
                {                
                Animate_Stop(GetDlgItem(hwnd, idcAnimation));
                EndDialog(hwnd, 0);
                return TRUE;
                }
            break;
            
        case WM_DESTROY:
            Assert(pad);
            if (pad->dwID)
                pad->pNNTPServer->CancelRequest(pad->dwID);
            break;

        case DAD_SERVERCB:
            {
            LPNNTPRESPONSE pResp;
            CNNTPResponse *pNNTPResp;

            if (SUCCEEDED(pad->pNNTPServer->GetAsyncResult(lParam, &pNNTPResp)))
                {
                pNNTPResp->Get(&pResp);

                Assert(pResp->state == NS_ARTICLE);
                if (pResp->fDone)
                    {
                    if (SUCCEEDED(pResp->rIxpResult.hrResult))
                        {
                        pad->fOK = TRUE;
                        }
                    else
                        {
                        int ids;
                        if (IXP_NNTP_NO_SUCH_ARTICLE_NUM == pResp->rIxpResult.uiServerError ||
                            IXP_NNTP_NO_SUCH_ARTICLE_FOUND == pResp->rIxpResult.uiServerError)
                            ids = idsErrNewsExpired;
                        else
                            ids = idsErrNewsCantOpen;

                        AthMessageBoxW(hwnd, 
                                      MAKEINTRESOURCEW(idsAthenaNews), 
                                      MAKEINTRESOURCEW(ids),
                                      0,
                                      MB_OK | MB_ICONEXCLAMATION);

                        }
                    pad->dwID = 0;
                    EndDialog(hwnd, 0);
                    }
                else
                    {
                    AthLoadString(idsProgReceivedLines, szRes, sizeof(szRes));
                    wsprintf(szBuffer, szRes, pResp->rArticle.cLines);
                    SetDlgItemText(hwnd, idcProgText, szBuffer);
                    }

                pNNTPResp->Release();
                }
            }
            return (TRUE);        
        }
    return FALSE;        
}

HRESULT HrDownloadArticleDialog(CNNTPServer *pNNTPServer, LPTSTR pszArticle, LPMIMEMESSAGE *ppMsg)
{
    HRESULT     hr;
    ARTDOWNDLG  add = { 0 };

    if (SUCCEEDED(hr = HrCreateMessage(&add.pMsg)))
        {
        if (SUCCEEDED(hr = MimeOleCreateVirtualStream(&add.pStream)))
            {
            add.pNNTPServer = pNNTPServer;
            add.pszArticle = pszArticle;
            DialogBoxParam(g_hLocRes, 
                           MAKEINTRESOURCE(iddDownloadGroups), 
                           NULL, 
                           (DLGPROC)DownloadArticleDlg, 
                           (LPARAM)&add);
            if (add.fOK)
                {
                add.pMsg->Load(add.pStream);
                *ppMsg = add.pMsg;
                (*ppMsg)->AddRef();
                hr = S_OK;
                }
            else
                hr = E_FAIL;
            add.pStream->Release();
            }
        else
            {
            AthMessageBoxW(NULL, MAKEINTRESOURCEW(idsAthenaNews), MAKEINTRESOURCEW(idsMemory), 0, MB_OK | MB_ICONSTOP);
            }
        add.pMsg->Release();
        }
    else
        {
        AthMessageBoxW(NULL, MAKEINTRESOURCEW(idsAthenaNews), MAKEINTRESOURCEW(idsMemory), 0, MB_OK | MB_ICONSTOP);
        }

    return hr;
}

///////////////////////////////////////////////////////////////////////
//
//  FUNCTION:   LogOffRunDLL
//
//  PURPOSE:    Provides an entry point into Thor that allows us to
//              perform an ExitWindows in the context of another
//              process.  This works around all kinds of nasty shutdown
//              behavior and differences between NT and Win95.
//
///////////////////////////////////////////////////////////////////////
void WINAPI FAR LogOffRunDLL(HWND hwndStub, HINSTANCE hInstance, LPTSTR pszCmd, int nCmdShow)
{    
    HRESULT         hr = S_OK;
    IUserDatabase  *pUserDB;

    // this is required because ShowWindow ignore the params on
    // on the first call per process - this causes our notes to
    // use the nCmdShow from WinExec.  By calling here, we make
    // sure that ShowWindow respects our later calls.  (EricAn)
    ShowWindow(hwndStub, SW_HIDE);

    OleInitialize(0);

    if (SUCCEEDED(CoCreateInstance(CLSID_LocalUsers, NULL, CLSCTX_INPROC_SERVER, IID_IUserDatabase, (LPVOID*)&pUserDB)))
        {
        hr = pUserDB->Authenticate(GetDesktopWindow(), LUA_DIALOG|LUA_FORNEXTLOGON, NULL, NULL, NULL);
        pUserDB->Release();
        }
    if (SUCCEEDED(hr))
        ExitWindowsEx(EWX_LOGOFF, 0);

    OleUninitialize();
}

#endif //!WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\navpane.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     navpane.cpp
//
//  PURPOSE:    
//

#include "pch.hxx"
#include "navpane.h"
#include "treeview.h"
#include "baui.h"
#include "browser.h"
#include "menuutil.h"
#include "inpobj.h"

/////////////////////////////////////////////////////////////////////////////
// Local Stuff
//
const TCHAR c_szNavPaneClass[] = _T("Outlook Express Navigation Pane");
const TCHAR c_szPaneFrameClass[] = _T("Outlook Express Pane Frame");

// Sizing consts
const int c_cxBorder     = 1;
const int c_cyBorder     = 1;
const int c_cxTextBorder = 4;
const int c_cyTextBorder = 2;
const int c_cyClose      = 3;
const int c_cySplit      = 4;
const int c_cxSplit      = 3;

#define ID_PANE_CLOSE   2000
#define ID_PANE_PIN     2001
#define ID_PANE_TITLE   2002

#define IDT_PANETIMER   100
#define	ELAPSE_MOUSEOVERCHECK	250

/////////////////////////////////////////////////////////////////////////////
// CNavPane Implementation
//

CNavPane::CNavPane()
{
    m_cRef = 1;
    m_fShow = FALSE;
    m_fTreeVisible = FALSE;
    m_fContactsVisible = FALSE;

    m_hwnd = 0;
    m_hwndParent = 0;
    m_hwndTree = 0;
    m_hwndContacts = 0;

    m_pSite = NULL;
    m_pTreeView = NULL;
    m_pContacts = NULL;
    m_pContactsFrame = NULL;
    m_pContactsTarget = NULL;

    m_cxWidth = 200;
    m_fResizing = FALSE;
    m_fSplitting = FALSE;
    m_cySplitPct = 50;
    ZeroMemory(&m_rcSplit, sizeof(RECT));
    ZeroMemory(&m_rcSizeBorder, sizeof(RECT));

    m_cyTitleBar = 32;
}

CNavPane::~CNavPane()
{
    SafeRelease(m_pContactsFrame);
}


HRESULT CNavPane::Initialize(CTreeView *pTreeView)
{
    // We've got to have this
    if (!pTreeView)
        return (E_INVALIDARG);

    // Keep it
    m_pTreeView = pTreeView;
    m_pTreeView->AddRef();

    // Load some settings
    m_cxWidth = DwGetOption(OPT_NAVPANEWIDTH);
    if (m_cxWidth < 0)
        m_cxWidth = 200;

    m_cySplitPct = DwGetOption(OPT_NAVPANESPLIT);

    // Do some parameter checking
    if (m_cySplitPct > 100 || m_cySplitPct < 2)
        m_cySplitPct = 66;

    return (S_OK);
}


//
//  FUNCTION:   CNavPane::QueryInterface()
//
//  PURPOSE:    Allows caller to retrieve the various interfaces supported by 
//              this class.
//
HRESULT CNavPane::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    TraceCall("CNavPane::QueryInterface");

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IDockingWindow *) this;
    else if (IsEqualIID(riid, IID_IDockingWindow))
        *ppvObj = (LPVOID) (IDockingWindow *) this;
    else if (IsEqualIID(riid, IID_IObjectWithSite))
        *ppvObj = (LPVOID) (IObjectWithSite *) this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (LPVOID) (IOleCommandTarget *) this;
    else if (IsEqualIID(riid, IID_IInputObjectSite))
        *ppvObj = (LPVOID) (IInputObjectSite *) this;
    else if (IsEqualIID(riid, IID_IInputObject))
        *ppvObj = (LPVOID) (IInputObject *) this;

    if (*ppvObj)
    {
        AddRef();
        return (S_OK);
    }

    return (E_NOINTERFACE);
}


//
//  FUNCTION:   CNavPane::AddRef()
//
//  PURPOSE:    Adds a reference count to this object.
//
ULONG CNavPane::AddRef(void)
{
    TraceCall("CNavPane::AddRef");
    return ((ULONG) InterlockedIncrement((LONG *) &m_cRef));
}


//
//  FUNCTION:   CNavPane::Release()
//
//  PURPOSE:    Releases a reference on this object.
//
ULONG CNavPane::Release(void)
{
    TraceCall("CNavPane::Release");

    if (0 == InterlockedDecrement((LONG *) &m_cRef))
    {
        delete this;
        return 0;
    }

    return (m_cRef);
}


//
//  FUNCTION:   CNavPane::GetWindow()
//
//  PURPOSE:    Returns the handle of our outer window
//
//  PARAMETERS: 
//      [out] pHwnd - return value
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CNavPane::GetWindow(HWND *pHwnd)
{
    TraceCall("CNavPane::GetWindow");

    if (!pHwnd)
        return (E_INVALIDARG);

    if (IsWindow(m_hwnd))
    {
        *pHwnd = m_hwnd;
        return (S_OK);
    }

    return (E_FAIL);
}


//
//  FUNCTION:   CNavPane::ContextSensitiveHelp()
//
//  PURPOSE:    Does anyone _ever_ implement this?
//
HRESULT CNavPane::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceCall("CNavPane::ContextSensitiveHelp");
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CNavPane::ShowDW()
//
//  PURPOSE:    Show's or hides the Nav pane.  If the pane has not yet been
//              created it does that too.
//
//  PARAMETERS: 
//      [in] fShow - TRUE to show, FALSE to hide
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CNavPane::ShowDW(BOOL fShow)
{
    HRESULT     hr;
    WNDCLASSEX  wc;

    TraceCall("CNavPane::ShowDW");

    // Nothing works without a site pointer
    if (!m_pSite)
        return (E_UNEXPECTED);

    // Check to see if we've been created yet
    if (!m_hwnd)
    {
        // Register the window class if necessary
        wc.cbSize = sizeof(WNDCLASSEX);
        if (!GetClassInfoEx(g_hInst, c_szNavPaneClass, &wc))
        {
            wc.style            = 0;
            wc.lpfnWndProc      = _WndProc;
            wc.cbClsExtra       = 0;
            wc.cbWndExtra       = 0;
            wc.hInstance        = g_hInst;
            wc.hCursor          = LoadCursor(0, IDC_SIZEWE);
            wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
            wc.lpszMenuName     = NULL;
            wc.lpszClassName    = c_szNavPaneClass;
            wc.hIcon            = NULL;
            wc.hIconSm          = NULL;

            RegisterClassEx(&wc);
        }

        // Get the parent window before we create ours
        if (FAILED(m_pSite->GetWindow(&m_hwndParent)))
        {
            AssertSz(FALSE, "CNavPane::ShowDW() - Failed to get a parent window handle.");
        }

        // Create the window
        m_hwnd = CreateWindowEx(WS_EX_CONTROLPARENT, c_szNavPaneClass, NULL, 
                                WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                                0, 0, 10, 10, m_hwndParent, (HMENU) 0, g_hInst, this);
        if (!m_hwnd)
        {
            AssertSz(FALSE, "CNavPane::ShowDW() - Failed to create main window.");
            return (E_OUTOFMEMORY);
        }

        // Create any children
        if (FAILED(hr = _CreateChildWindows()))
        {
            AssertSz(FALSE, "CNavPane::ShowDW() - Failed to create child windows.");
            DestroyWindow(m_hwnd);
            return (hr);
        }
    }

    // Show or hide the window appropriately
    m_fShow = (fShow && (m_fTreeVisible || m_fContactsVisible));
    ResizeBorderDW(0, 0, FALSE);
    ShowWindow(m_hwnd, fShow ? SW_SHOW : SW_HIDE);

    return (S_OK);
}


//
//  FUNCTION:   CNavPane::ResizeBorderDW()
//
//  PURPOSE:    Called when it's time for us to re-request space from our 
//              parent.
//
//  PARAMETERS: 
//      [in] prcBorder - a RECT containing the outer rectangle the object can request space in
//      [in] punkSite  - pointer to the site that changed
//      [in] fReserved - unused.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CNavPane::ResizeBorderDW(LPCRECT prcBorder, IUnknown *punkSite, BOOL fReserved)
{
    const DWORD c_cxResizeBorder = 3;
    HRESULT     hr = S_OK;
    RECT        rcRequest = { 0 };
    RECT        rcBorder;

    TraceCall("CNavPane::ResizeBorderDW");

    // If we don't have a site pointer, this ain't gonna work
    if (!m_pSite)
        return (E_UNEXPECTED);

    // If we visible, then calculate our border requirements.  If we're not 
    // visible, the our requirements are zero and we can use the default
    // values in rcRequest.
    Assert(IsWindow(m_hwnd));

    // If the caller didn't provide us with a rect, get one ourselves
    if (!prcBorder)
    {
        m_pSite->GetBorderDW((IDockingWindow *) this, &rcBorder);
        prcBorder = &rcBorder;
    }

    // The space we need is the min of either what we want to be or the
    // width of the parent minus some
    if (m_fShow)
    {
        rcRequest.left = min(prcBorder->right - prcBorder->left - 32, m_cxWidth);
    }

    // Ask for the space we need
    if (SUCCEEDED(m_pSite->RequestBorderSpaceDW((IDockingWindow *) this, &rcRequest)))
    {
        // Tell the site how be we're going to be
        if (SUCCEEDED(m_pSite->SetBorderSpaceDW((IDockingWindow *) this, &rcRequest)))
        {
            // Now once that's all done, resize ourselves if we're visible
            if (m_fShow)
            {
                SetWindowPos(m_hwnd, 0, prcBorder->left, prcBorder->top, rcRequest.left,
                             prcBorder->bottom - prcBorder->top, SWP_NOZORDER | SWP_NOACTIVATE);
            }
        }
    }

    return (S_OK);
}


//
//  FUNCTION:   CNavPane::CloseDW()
//
//  PURPOSE:    Called when the parent want's to destroy this window
//
//  PARAMETERS: 
//      [in] dwReserved - unused
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CNavPane::CloseDW(DWORD dwReserved)
{
    TraceCall("CNavPane::CloseDW");

    // Save our settings
    SetDwOption(OPT_NAVPANEWIDTH, m_cxWidth, NULL, 0);
    SetDwOption(OPT_NAVPANESPLIT, m_cySplitPct, NULL, 0);

    if (m_pTreeView)
        m_pTreeView->DeInit();

    if (m_hwnd)
    {
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }

    // Destroy our children here
    SafeRelease(m_pTreeView);
    SafeRelease(m_pContactsTarget);
    SafeRelease(m_pContacts);

    return (S_OK);
}


//
//  FUNCTION:   CNavPane::GetSite()
//
//  PURPOSE:    Called to request an interface to our site
//
//  PARAMETERS: 
//      [in]  riid - Requested interface
//      [out] ppvSite - Returned interface if available
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CNavPane::GetSite(REFIID riid, LPVOID *ppvSite)
{
    HRESULT hr;

    TraceCall("CNavPane::GetSite");

    if (m_pSite)
    {
        // Ask our site for the requested interface
        hr = m_pSite->QueryInterface(riid, ppvSite);
        return (hr);
    }

    return (E_FAIL);
}


//
//  FUNCTION:   CNavPane::SetSite()
//
//  PURPOSE:    Called to tell us who our site will be.
//
//  PARAMETERS: 
//      [in] pUnkSite - Pointer to the new site
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CNavPane::SetSite(IUnknown *pUnkSite)
{
    HRESULT hr = S_OK;

    TraceCall("CNavPane::SetSite");

    // If we already have a site, release it
    if (m_pSite)
    {
        m_pSite->Release();
        m_pSite = 0;
    }

    // If we were given a new site, keep it
    if (pUnkSite)
    {
        hr = pUnkSite->QueryInterface(IID_IDockingWindowSite, (LPVOID *) &m_pSite);
        return (hr);
    }

    return (hr);
}


//
//  FUNCTION:   CNavPane::_WndProc()
//
//  PURPOSE:    External callback.
//
LRESULT CALLBACK CNavPane::_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CNavPane *pThis;

    if (uMsg == WM_NCCREATE)
    {
        pThis = (CNavPane *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM) pThis);
    }
    else
        pThis = (CNavPane *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (pThis)
        return (pThis->_NavWndProc(hwnd, uMsg, wParam, lParam));

    return (FALSE);
}


//
//  FUNCTION:   CNavPane::_NavWndProc()
//
//  PURPOSE:    Left as an exercise for the reader
//
LRESULT CALLBACK CNavPane::_NavWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_SETCURSOR,   _OnSetCursor);
        HANDLE_MSG(hwnd, WM_SIZE,        _OnSize);
        HANDLE_MSG(hwnd, WM_MOUSEMOVE,   _OnMouseMove);
        HANDLE_MSG(hwnd, WM_LBUTTONDOWN, _OnLButtonDown);
        HANDLE_MSG(hwnd, WM_LBUTTONUP,   _OnLButtonUp);
        
        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
        {
            // Forward these to all our children
            if (IsWindow(m_hwndTree))
                SendMessage(m_hwndTree, uMsg, wParam, lParam);
            if (IsWindow(m_hwndContacts))
                SendMessage(m_hwndContacts, uMsg, wParam, lParam);

            // Update any of our own sizes
            m_cyTitleBar =(UINT) SendMessage(m_hwndTree, WM_GET_TITLE_BAR_HEIGHT, 0, 0);
            return (0);
        }

    }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
}


//
//  FUNCTION:   CNavPane::_OnSize()
//
//  PURPOSE:    When our window get's resized, we need to resize our child 
//              windows too.
//
void CNavPane::_OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    RECT rc;
    DWORD cyTree;
    DWORD cySplit = c_cySplit;
    
    TraceCall("CNavPane::_OnSize");

    // If only the tree is visible
    if (m_fTreeVisible && !m_fContactsVisible)
        cyTree = cy;
    else if (m_fTreeVisible && m_fContactsVisible)
        cyTree = (cy * m_cySplitPct) / 100;
    else if (!m_fTreeVisible && m_fContactsVisible)
    {
        cyTree = 0;
        cySplit = 0;
    }

    // Resize the TreeView to fit inside our window
    if (m_hwndTree)
        SetWindowPos(m_hwndTree, 0, 0, 0, cx - c_cxSplit, cyTree, SWP_NOZORDER | SWP_NOACTIVATE);
    if (m_hwndContacts)
    SetWindowPos(m_hwndContacts, 0, 0, cyTree + cySplit, cx - 3, cy - cyTree - cySplit, SWP_NOZORDER | SWP_NOACTIVATE);

    // Figure out where a few things are, starting with the split bar
    SetRect(&rc, c_cxBorder, cyTree, cx - c_cxSplit - c_cxBorder, cyTree + cySplit);
    m_rcSplit = rc;

    // Figure out where the right side is
    SetRect(&rc, cx - c_cxSplit, 0, cx, cy);
    m_rcSizeBorder = rc;
}


//
//  FUNCTION:   CNavPane::_OnLButtonDown()
//
//  PURPOSE:    When the user clicks down and we get this notification, it 
//              must be because they want to resize.
//
void CNavPane::_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    TraceCall("CNavPane::_OnLButtonDown");

    if (!m_fResizing)
    {
        SetCapture(hwnd);
        m_fResizing = TRUE;

        POINT pt = {x, y};
        if (PtInRect(&m_rcSplit, pt))
        {
            m_fSplitting = TRUE;
        }
    }
}


//
//  FUNCTION:   CNavPane::_OnMouseMove()
//
//  PURPOSE:    If we're resizing, update our position etc.
//
void CNavPane::_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
{
    POINT pt = {x, y};
    RECT  rcClient;

    TraceCall("CNavPane::_OnMouseMove");

    if (m_fResizing)
    {
        if (m_fSplitting)
        {
            GetClientRect(m_hwnd, &rcClient);
            m_cySplitPct = (int)(((float) pt.y / (float) rcClient.bottom) * 100);

            // Make sure we have the min's and max's right
            int cy = (rcClient.bottom * m_cySplitPct) / 100;
            if (cy < m_cyTitleBar)
            {
                m_cySplitPct = (int)(((float) m_cyTitleBar / (float) rcClient.bottom) * 100);
            }
            else if (rcClient.bottom - cy < m_cyTitleBar)
            {
                m_cySplitPct = (int)(((float) (rcClient.bottom - m_cyTitleBar) / (float) rcClient.bottom) * 100);
            }

            _OnSize(hwnd, 0, rcClient.right, rcClient.bottom);          
        }
        else
        {
            if (pt.x > 32)
            {
                GetClientRect(m_hwndParent, &rcClient);
                m_cxWidth = max(0, min(pt.x, rcClient.right - 32));
                ResizeBorderDW(0, 0, FALSE);
            }
        }
    }
}


//
//  FUNCTION:   CNavPane::_OnLButtonUp()
//
//  PURPOSE:    If the user was resizing, then they're done now and we can
//              clean up.
//
void CNavPane::_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
{
    TraceCall("CNavPane::_OnLButtonUp");

    if (m_fResizing)
    {
        ReleaseCapture();
        m_fResizing = FALSE;
        m_fSplitting = FALSE;
    }
}


//
//  FUNCTION:   CNavPane::_OnSetCursor()
//
//  PURPOSE:    Do some jimmying with the cursor
//
BOOL CNavPane::_OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg)
{
    POINT pt;

    TraceCall("_OnSetCursor");

    // Get the cursor position
    GetCursorPos(&pt);
    ScreenToClient(m_hwnd, &pt);
    
    // If the cursor is within the split bar, update the cursor
    if (PtInRect(&m_rcSplit, pt))
    {
        SetCursor(LoadCursor(NULL, IDC_SIZENS));
        return (TRUE);
    }

    if (PtInRect(&m_rcSizeBorder, pt))
    {
        SetCursor(LoadCursor(NULL, IDC_SIZEWE));
        return (TRUE);
    }

    return (FALSE);
}


//
//  FUNCTION:   CNavPane::_OnNCHitTest()
//
//  PURPOSE:    We monkey around with the non client area to get the correct 
//              cursors
//
//  PARAMETERS: 
//      [in] hwnd - Window handle the mouse is in
//      [in] x, y - Position of the mouse in screen coordinates
//
//  RETURN VALUE:
//      Our personal opinion of where the mouse is.
//
UINT CNavPane::_OnNCHitTest(HWND hwnd, int x, int y)
{
    POINT pt = {x, y};

    // If the cursor is in the split bar
    if (PtInRect(&m_rcSplit, pt))
        return (HTTOP);

    if (PtInRect(&m_rcSizeBorder, pt))
        return (HTRIGHT);

    return (HTCLIENT);
}


//
//  FUNCTION:   CNavPane::_CreateChildWindows()
//
//  PURPOSE:    Creates the child windows that will be displayed.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CNavPane::_CreateChildWindows(void)
{
    IOleWindow   *pWindow = NULL;
    IInputObject *pInputObj = NULL;
    HRESULT       hr;

    TraceCall("CNavPane::_CreateChildWindows");

    // The treeview is always created by the browser.  All we have to do
    // is tell it to create it's UI.
    m_hwndTree = m_pTreeView->Create(m_hwnd, (IInputObjectSite *) this, TRUE);
    Assert(m_hwndTree);

    // If the tree is supposed to be visible, show it
    if (DwGetOption(OPT_SHOWTREE))
    {
        ShowWindow(m_hwndTree, SW_SHOW);
        m_fTreeVisible = TRUE;
        m_cyTitleBar = (UINT) SendMessage(m_hwndTree, WM_GET_TITLE_BAR_HEIGHT, 0, 0);
    }

    // If we're showing contacts, create it
    if (DwGetOption(OPT_SHOWCONTACTS) && (!(g_dwAthenaMode & MODE_OUTLOOKNEWS)))
    {
        ShowContacts(TRUE);
    }

    return (S_OK);
}


//
//  FUNCTION:   CNavPane::ShowFolderList()
//
//  PURPOSE:    Shows and hides the folder list doodad
//
//  PARAMETERS: 
//      BOOL fShow
//
BOOL CNavPane::ShowFolderList(BOOL fShow)
{
    TraceCall("CNavPane::ShowFolderList");

    // The folder list _always_ exists.  We just toggle the state
    ShowWindow(m_hwndTree, fShow ? SW_SHOW : SW_HIDE);
    m_fTreeVisible = fShow;
    _UpdateVisibleState();

    RECT rc;
    GetClientRect(m_hwnd, &rc);
    _OnSize(m_hwnd, 0, rc.right, rc.bottom);

    return (TRUE);
}


//
//  FUNCTION:   CNavPane::ShowContacts()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      BOOL fShow
//
//  RETURN VALUE:
//      BOOL 
//
BOOL CNavPane::ShowContacts(BOOL fShow)
{
    CMsgrAb        *pMsgrAb;
    HWND            hwnd;
    IAthenaBrowser *pBrowser;
    HRESULT         hr;
    RECT            rc = {0};

    if (!m_pContacts)
    {
        hr = CreateMsgrAbCtrl(&m_pContacts);
        if (SUCCEEDED(hr))
        {
            // Initialize the control
            m_pContactsFrame = new CPaneFrame();
            if (!m_pContactsFrame)
                return (0);
            m_hwndContacts = m_pContactsFrame->Initialize(m_hwnd, this, idsABBandTitle, IDR_BA_TITLE_POPUP);

            pMsgrAb = (CMsgrAb *) m_pContacts;
            hwnd = pMsgrAb->CreateControlWindow(m_hwndContacts, rc);
            if (hwnd)
            {
                if (SUCCEEDED(m_pSite->QueryInterface(IID_IAthenaBrowser, (LPVOID *) &pBrowser)))
                {
                    m_pContactsFrame->SetChild(hwnd, DISPID_MSGVIEW_CONTACTS, pBrowser, pMsgrAb, pMsgrAb);
                    pBrowser->Release();
                }
            }

            // Get the command target
            m_pContacts->QueryInterface(IID_IOleCommandTarget, (LPVOID *) &m_pContactsTarget);
        }
    }

    SetWindowPos(m_hwndContacts, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    ShowWindow(m_hwndContacts, fShow ? SW_SHOW : SW_HIDE);
    m_fContactsVisible = fShow;
    _UpdateVisibleState();

    GetClientRect(m_hwnd, &rc);
    _OnSize(m_hwnd, 0, rc.right, rc.bottom);

    return (TRUE);
}


//
//  FUNCTION:   CNavPane::_UpdateVisibleState()
//
//  PURPOSE:    Checks to see if we need to show our hide ourselves
//
void CNavPane::_UpdateVisibleState(void)
{
    // If this leaves us with nothing visible, then we hide ourselves
    if (!m_fTreeVisible && !m_fContactsVisible)
    {
        ShowWindow(m_hwnd, SW_HIDE);
        m_fShow = FALSE;
        ResizeBorderDW(0, 0, 0);
    }
    else if (m_fShow == FALSE && (m_fTreeVisible || m_fContactsVisible))
    {
        // Show ourselves
        m_fShow = TRUE;
        ShowWindow(m_hwnd, SW_SHOW);
        ResizeBorderDW(0, 0, 0);
    }
}


HRESULT CNavPane::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                              OLECMDTEXT *pCmdText) 
{

    if (m_pContactsTarget)
    {
        for (UINT i = 0; i < cCmds; i++)
        {
            if (prgCmds[i].cmdf == 0 && prgCmds[i].cmdID == ID_CONTACTS_MNEMONIC)
            {
                prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
            }
        }
    }

    if (m_pContactsTarget)
        return (m_pContactsTarget->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText));

    return (S_OK);
}


HRESULT CNavPane::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                       VARIANTARG *pvaIn, VARIANTARG *pvaOut) 
{
    if (m_pContactsTarget && nCmdID == ID_CONTACTS_MNEMONIC)
    {
        m_pContactsFrame->ShowMenu();
        return (S_OK);
    }

    if (m_pContactsTarget)
        return (m_pContactsTarget->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut));

    return (OLECMDERR_E_NOTSUPPORTED);
}

BOOL CNavPane::IsContactsFocus(void)
{
    IInputObject *pInputObject = 0;
    HRESULT       hr = S_FALSE;

    if (m_pContacts)
    {
        if (SUCCEEDED(m_pContacts->QueryInterface(IID_IInputObject, (LPVOID *) &pInputObject)))
        {
            hr = pInputObject->HasFocusIO();
            pInputObject->Release();
            return (S_OK == hr);
        }
    }

    return (S_OK == hr);
}

HRESULT CNavPane::OnFocusChangeIS(IUnknown *punkSrc, BOOL fSetFocus)
{
    // Simply call through to our host
    UnkOnFocusChangeIS(m_pSite, (IInputObject*) this, fSetFocus);
    return (S_OK);
}

HRESULT CNavPane::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    if (fActivate)
    {
        UnkOnFocusChangeIS(m_pSite, (IInputObject *) this, TRUE);
        SetFocus(m_hwnd);
    }

    return (S_OK);
}

HRESULT CNavPane::HasFocusIO(void)
{
    if (m_hwnd == 0)
       return (S_FALSE);

    HWND hwndFocus = GetFocus();
    return (hwndFocus == m_hwnd || IsChild(m_hwnd, hwndFocus)) ? S_OK : S_FALSE;
}    
    
HRESULT CNavPane::TranslateAcceleratorIO(LPMSG pMsg)
{
    if (m_pTreeView && (m_pTreeView->HasFocusIO() == S_OK))
        return m_pTreeView->TranslateAcceleratorIO(pMsg);

    if (m_pContacts && (UnkHasFocusIO(m_pContacts) == S_OK))
        return UnkTranslateAcceleratorIO(m_pContacts, pMsg);

    return (S_FALSE);
}    

/////////////////////////////////////////////////////////////////////////////
// CPaneFrame
//

CPaneFrame::CPaneFrame()
{
    m_cRef = 1;

    m_hwnd = 0;
    m_hwndChild = 0;
    m_hwndParent = 0;

    m_szTitle[0] = 0;
    m_hFont = 0;
    m_hbr3DFace = 0;
    m_cyTitleBar = 0;
    m_fHighlightIndicator = FALSE;
    m_fHighlightPressed = FALSE;
    ZeroMemory(&m_rcTitleButton, sizeof(RECT));

    m_hwndClose = 0;
    m_cButtons = 1;

    m_pBrowser = NULL;
    m_dwDispId = 0;
    m_pTarget = 0;
    m_idMenu = 0;

    m_fPin = FALSE;
}

CPaneFrame::~CPaneFrame()
{
    if (m_hFont != 0)
        DeleteObject(m_hFont);
    if (m_hbr3DFace != 0)
        DeleteObject(m_hbr3DFace);
}


//
//  FUNCTION:   CPaneFrame::Initialize()
//
//  PURPOSE:    Initializes the frame by telling the pane what it's title 
//              should be.
//
//  PARAMETERS: 
//      [in] hwndParent
//      [in] idsTitle
//
//  RETURN VALUE:
//      HWND 
//
HWND CPaneFrame::Initialize(HWND hwndParent, IInputObjectSite *pSite, int idsTitle, int idMenu)
{
    WNDCLASSEX wc;

    TraceCall("CPaneFrame::Initialize");

    // This should be NULL
    Assert(NULL == m_hwnd);
    
    // Save this for later
    m_hwndParent = hwndParent;
    m_idMenu = idMenu;
    m_pSite = pSite;

    // Load the title
    AthLoadString(idsTitle, m_szTitle, ARRAYSIZE(m_szTitle));

    // Register the window class if necessary
    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, c_szPaneFrameClass, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = _WndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hCursor          = LoadCursor(0, IDC_ARROW);
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szPaneFrameClass;
        wc.hIcon            = NULL;
        wc.hIconSm          = NULL;

        RegisterClassEx(&wc);
    }

    // Create the window
    m_hwnd = CreateWindowEx(WS_EX_CONTROLPARENT, c_szPaneFrameClass, m_szTitle, 
                            WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                            0, 0, 0, 0, hwndParent, 0, g_hInst, this);
    if (!m_hwnd)
    {
        AssertSz(m_hwnd, "CPaneFrame::Initialize() - Failed to create a frame");
        return (0);
    }

    return (m_hwnd);
}


//
//  FUNCTION:   CPaneFrame::SetChild()
//
//  PURPOSE:    Allows the owner to tell us what the child window handle is.
//
BOOL CPaneFrame::SetChild(HWND hwndChild, DWORD dwDispId, IAthenaBrowser *pBrowser, 
                          IObjectWithSite *pObject, IOleCommandTarget *pTarget)
{
    TraceCall("CPaneFrame::SetChild");

    if (IsWindow(hwndChild))
    {
        m_hwndChild = hwndChild;

        if (pBrowser)
        {
            m_pBrowser = pBrowser;
            m_dwDispId = dwDispId;
        }

        if (pObject)
        {
            pObject->SetSite((IInputObjectSite *) this);
        }

        if (pTarget)
        {
            m_pTarget = pTarget;
        }

        return (TRUE);
    }

    return (FALSE);
}


void CPaneFrame::ShowMenu(void)
{
    if (m_idMenu)
    {
        _OnLButtonDown(m_hwnd, 0, m_rcTitleButton.left, m_rcTitleButton.top, 0);
    }
}

//
//  FUNCTION:   CPaneFrame::QueryInterface()
//
//  PURPOSE:    Allows caller to retrieve the various interfaces supported by 
//              this class.
//
HRESULT CPaneFrame::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    TraceCall("CPaneFrame::QueryInterface");

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IInputObjectSite *) this;
    else if (IsEqualIID(riid, IID_IInputObjectSite))
        *ppvObj = (LPVOID) (IInputObjectSite *) this;

    if (*ppvObj)
    {
        AddRef();
        return (S_OK);
    }

    return (E_NOINTERFACE);
}


//
//  FUNCTION:   CPaneFrame::AddRef()
//
//  PURPOSE:    Adds a reference count to this object.
//
ULONG CPaneFrame::AddRef(void)
{
    TraceCall("CPaneFrame::AddRef");
    return ((ULONG) InterlockedIncrement((LONG *) &m_cRef));
}


//
//  FUNCTION:   CPaneFrame::Release()
//
//  PURPOSE:    Releases a reference on this object.
//
ULONG CPaneFrame::Release(void)
{
    TraceCall("CPaneFrame::Release");

    if (0 == InterlockedDecrement((LONG *) &m_cRef))
    {
        delete this;
        return 0;
    }

    return (m_cRef);
}


HRESULT CPaneFrame::OnFocusChangeIS(IUnknown *punkSrc, BOOL fSetFocus)
{
    // Simply call through to our host
    UnkOnFocusChangeIS(m_pSite, (IInputObject*) this, fSetFocus);
    return (S_OK);
}


//
//  FUNCTION:   CPaneFrame::_WndProc()
//
//  PURPOSE:    External callback.
//
LRESULT CALLBACK CPaneFrame::_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CPaneFrame *pThis;

    if (uMsg == WM_NCCREATE)
    {
        pThis = (CPaneFrame *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM) pThis);
    }
    else
        pThis = (CPaneFrame *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (pThis)
        return (pThis->_FrameWndProc(hwnd, uMsg, wParam, lParam));

    return (FALSE);
}


//
//  FUNCTION:   CPaneFrame::_FrameWndProc()
//
//  PURPOSE:    Left as an exercise for the reader
//
LRESULT CALLBACK CPaneFrame::_FrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_CREATE,      _OnCreate);
        HANDLE_MSG(hwnd, WM_SIZE,        _OnSize);
        HANDLE_MSG(hwnd, WM_PAINT,       _OnPaint);
        HANDLE_MSG(hwnd, WM_COMMAND,     _OnCommand);
        HANDLE_MSG(hwnd, WM_MOUSEMOVE,   _OnMouseMove);
        HANDLE_MSG(hwnd, WM_LBUTTONDOWN, _OnLButtonDown);
        HANDLE_MSG(hwnd, WM_TIMER,       _OnTimer);

        case WM_TOGGLE_CLOSE_PIN:
            _OnToggleClosePin(hwnd, (BOOL) lParam);
            return (0);

        case WM_GET_TITLE_BAR_HEIGHT:
            return (m_cyTitleBar + (c_cyBorder * 2) + 1);

        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
        {
            // Forward these to all our children
            if (IsWindow(m_hwndChild))
                SendMessage(m_hwndChild, uMsg, wParam, lParam);
            _UpdateDrawingInfo();
            break;
        }

        case WM_SETFOCUS:
        {
            if (m_hwndChild && ((HWND)wParam) != m_hwndChild)
                SetFocus(m_hwndChild);
            break;
        }            
    }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
}


//
//  FUNCTION:   CPaneFrame::_OnCreate()
//
//  PURPOSE:    Loads some info that will be handy later
//
BOOL CPaneFrame::_OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    TraceCall("CPaneFrame::_OnCreate");

    m_hwnd = hwnd;

    _UpdateDrawingInfo();
    _CreateCloseToolbar();

    return (TRUE);
}


//
//  FUNCTION:   CPaneFrame::_OnSize()
//
//  PURPOSE:    Resizes our child to fit in the right place
//
void CPaneFrame::_OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    TraceCall("CPaneFrame::_OnSize");

    m_rcChild.left = c_cyBorder;
    m_rcChild.top = m_cyTitleBar;
    m_rcChild.right = cx - (2 * c_cyBorder);
    m_rcChild.bottom = cy - m_cyTitleBar - c_cyBorder;

    if (m_hwndChild)
        SetWindowPos(m_hwndChild, 0, m_rcChild.left, m_rcChild.top, m_rcChild.right, 
                     m_rcChild.bottom, SWP_NOZORDER | SWP_NOACTIVATE);

    POINT pt = {cx, cy};
    _PositionToolbar(&pt);

    // Invalidate the title area
    RECT rc = m_rcChild;
    rc.top = 0;
    rc.bottom = m_rcChild.top;
    InvalidateRect(m_hwnd, &rc, FALSE);

    rc.left = 0;
    rc.right = c_cyBorder;
    rc.bottom = cy;
    InvalidateRect(m_hwnd, &rc, FALSE);

    rc.left = cx - c_cyBorder;
    rc.right = cx;
    InvalidateRect(m_hwnd, &rc, FALSE);
}


//
//  FUNCTION:   CPaneFrame::_OnPaint()
//
//  PURPOSE:    Called when it's time to paint our borders and title area.
//
void CPaneFrame::_OnPaint(HWND hwnd)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    RECT        rc;
    RECT        rcClient;
    POINT       pt[3];
    HBRUSH      hBrush,
                hBrushOld;
    HPEN        hPen,
                hPenOld;

    // Get our window size
    GetClientRect(m_hwnd, &rcClient);
    rc = rcClient;

    // Start painting
    hdc = BeginPaint(hwnd, &ps);

    // Draw a simple edge around or window
    DrawEdge(hdc, &rc, BDR_SUNKENOUTER, BF_TOPRIGHT | BF_BOTTOMLEFT);

    // Now draw a raised edge around our title bar area
    InflateRect(&rc, -1, -1);
    rc.bottom = m_cyTitleBar;
    DrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_TOPRIGHT | BF_BOTTOMLEFT);

    // Paint the background
    InflateRect(&rc, -c_cxBorder, -c_cyBorder);
    FillRect(hdc, &rc, m_hbr3DFace);

    // Now draw some groovy text
    SelectFont(hdc, m_hFont);
    SetBkColor(hdc, GetSysColor(COLOR_3DFACE));
    SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));

    // Draw the text
    InflateRect(&rc, -c_cxTextBorder, -c_cyTextBorder);

    if (!m_fPin)
    {
        DrawText(hdc, m_szTitle, -1, &rc, DT_CALCRECT | DT_VCENTER | DT_LEFT);
        DrawText(hdc, m_szTitle, -1, &rc, DT_VCENTER | DT_LEFT);
    }
    else
    {
        TCHAR sz[CCHMAX_STRINGRES];
        AthLoadString(idsPushPinInfo, sz, ARRAYSIZE(sz));
        IDrawText(hdc, sz, &rc, DT_VCENTER | DT_END_ELLIPSIS | DT_LEFT, 
                  rc.bottom - rc.top);
        DrawText(hdc, sz, -1, &rc, DT_CALCRECT | DT_VCENTER | DT_END_ELLIPSIS | DT_LEFT);
    }

    // Drop-down indicator
    if (m_idMenu)
    {
        COLORREF    crFG = GetSysColor(COLOR_WINDOWTEXT);

        pt[0].x = rc.right + 6;
        pt[0].y = (m_cyTitleBar - 6) / 2 + 2;
        pt[1].x = pt[0].x + 6;
        pt[1].y = pt[0].y;
        pt[2].x = pt[0].x + 3;
        pt[2].y = pt[0].y + 3;

        hPen = CreatePen(PS_SOLID, 1, crFG);
        hBrush = CreateSolidBrush(crFG);
        hPenOld = SelectPen(hdc, hPen);
        hBrushOld = SelectBrush(hdc, hBrush);
        Polygon(hdc, pt, 3);
        SelectPen(hdc, hPenOld);
        SelectBrush(hdc, hBrushOld);
        DeleteObject(hPen);
        DeleteObject(hBrush);

        if (m_fHighlightIndicator)
        {
            rc = m_rcTitleButton;
            DrawEdge(hdc, &rc, m_fHighlightPressed ? BDR_SUNKENOUTER : BDR_RAISEDINNER, 
                     BF_TOPRIGHT | BF_BOTTOMLEFT);
        }
    }

    EndPaint(hwnd, &ps);    
}


//
//  FUNCTION:   _OnCommand()
//
//  PURPOSE:    We get the occasional command now and again
//
void CPaneFrame::_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case ID_PANE_CLOSE:
        {
            if (m_pBrowser)
                m_pBrowser->SetViewLayout(m_dwDispId, LAYOUT_POS_NA, FALSE, 0, 0);
            return;
        }

        case ID_PANE_PIN:
        {
            SendMessage(m_hwndChild, WMR_CLICKOUTSIDE, CLK_OUT_DEACTIVATE, 0);
            if (m_pBrowser)
                m_pBrowser->SetViewLayout(m_dwDispId, LAYOUT_POS_NA, TRUE, 0, 0);
            return;
        }
    }

    return;
}

//
//  FUNCTION:   CPaneFrame::_OnToggleClosePin()
//
//  PURPOSE:    Sent to the frame when we should change the close button
//              to a pin button.
//
//  PARAMETERS: 
//      [in] fPin - TRUE to turn the Pin on, FALSE to turn it off.
//
void CPaneFrame::_OnToggleClosePin(HWND hwnd, BOOL fPin)
{
    TraceCall("CPaneFrame::_OnToggleClosePin");

    if (fPin)
    {
        static const TBBUTTON tb[] = 
        {
            { 2, ID_PANE_PIN, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0, 0}, 0, 0}
        };

        SendMessage(m_hwndClose, TB_DELETEBUTTON, 0, 0);
        SendMessage(m_hwndClose, TB_ADDBUTTONS, ARRAYSIZE(tb), (LPARAM) tb);
        SendMessage(m_hwndClose, TB_SETHOTITEM, (WPARAM) -1, 0);

        m_fPin = TRUE;
    }
    else
    {
        static const TBBUTTON tb[] = 
        {
            { 1, ID_PANE_CLOSE, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0, 0}, 0, 0}
        };

        SendMessage(m_hwndClose, TB_DELETEBUTTON, 0, 0);
        SendMessage(m_hwndClose, TB_ADDBUTTONS, ARRAYSIZE(tb), (LPARAM) tb);
        SendMessage(m_hwndClose, TB_SETHOTITEM, (WPARAM) -1, 0);

        m_fPin = FALSE;
    }
}


//
//  FUNCTION:   CPaneFrame::_UpdateDrawingInfo()
//
//  PURPOSE:    When we get created or when the user changes their settings, 
//              we need to reload our fonts, colors, and sizes.
//
void CPaneFrame::_UpdateDrawingInfo(void)
{
    LOGFONT     lf;
    TEXTMETRIC  tm;
    HDC         hdc;

    TraceCall("CPaneFrame::_UpdateDrawingInfo");

    if (m_hFont)
        DeleteObject(m_hFont);

    // Figure out which font to use
    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, FALSE);

    // Create the font
    m_hFont = CreateFontIndirect(&lf);

    // Get the metrics of this font
    hdc = GetDC(m_hwnd);
    SelectFont(hdc, m_hFont);
    GetTextMetrics(hdc, &tm);

    // Calculate the height
    m_cyTitleBar = tm.tmHeight + (2 * c_cyBorder) + (2 * c_cyTextBorder);

    RECT rc = {2 * c_cxBorder, 2 * c_cyBorder, 0, m_cyTitleBar - c_cyBorder};
    SIZE s;
    GetTextExtentPoint32(hdc, m_szTitle, lstrlen(m_szTitle), &s);
    m_rcTitleButton = rc;
    m_rcTitleButton.right = 14 + (2 * c_cxTextBorder) + s.cx + (2 * c_cxBorder);

    ReleaseDC(m_hwnd, hdc);

    // Get the brush we need
    if (m_hbr3DFace)
        DeleteObject(m_hbr3DFace);
    m_hbr3DFace = CreateSolidBrush(GetSysColor(COLOR_3DFACE));
}


//
//  FUNCTION:   CPaneFrame::_CreateCloseToolbar()
//
//  PURPOSE:    Creates the toolbar that has our close button
//
void CPaneFrame::_CreateCloseToolbar()
{
    CHAR szTitle[255];

    TraceCall("CPaneFrame::_CreateCloseToolbar");

    AthLoadString(idsHideFolders, szTitle, ARRAYSIZE(szTitle));

    m_hwndClose = CreateWindowEx(0, TOOLBARCLASSNAME, szTitle, 
                                 WS_VISIBLE | WS_CHILD | TBSTYLE_FLAT | TBSTYLE_CUSTOMERASE |
                                 WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOMOVEY |
                                 CCS_NOPARENTALIGN | CCS_NORESIZE,
                                 0, c_cyClose, 30, 15, m_hwnd, 0, g_hInst, NULL);
    if (m_hwndClose)
    {
        static const TBBUTTON tb[] = 
        {
            { 1, ID_PANE_CLOSE, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0, 0}, 0, 0}
        };

        SendMessage(m_hwndClose, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
        SendMessage(m_hwndClose, TB_SETBITMAPSIZE, 0, (LPARAM) MAKELONG(11, 9));
        
        TBADDBITMAP tbab = { g_hLocRes, idbClosePin };
        SendMessage(m_hwndClose, TB_ADDBITMAP, 4, (LPARAM) &tbab);
        SendMessage(m_hwndClose, TB_ADDBUTTONS, ARRAYSIZE(tb), (LPARAM) tb);
        SendMessage(m_hwndClose, TB_SETINDENT, 0, 0);

        _SizeCloseToolbar();
    }
}


//
//  FUNCTION:   CPaneFrame::_SizeCloseToolbar()
//
//  PURPOSE:    Set's the size of the toolbar appropriately.
//
void CPaneFrame::_SizeCloseToolbar(void)
{
    TraceCall("CPaneFrame::_SizeCloseToolbar");

    RECT rc;
    LONG lButtonSize;

    GetWindowRect(m_hwndClose, &rc);
    lButtonSize = (LONG) SendMessage(m_hwndClose, TB_GETBUTTONSIZE, 0, 0L);
    SetWindowPos(m_hwndClose, NULL, 0, 0, LOWORD(lButtonSize) * m_cButtons,
                 rc.bottom - rc.top, SWP_NOMOVE | SWP_NOACTIVATE);

    _PositionToolbar(NULL);
}



//
//  FUNCTION:   CPaneFrame::_PositionToolbar()
//
//  PURPOSE:    Does the work of correctly positioning the close button
//              toolbar.
//
//  PARAMETERS: 
//      LPPOINT ppt
//
void CPaneFrame::_PositionToolbar(LPPOINT ppt)
{
    TraceCall("CPaneFrame::_PositionToolbar");

    if (m_hwndClose)
    {
        RECT rc;
        GetClientRect(m_hwnd, &rc);

        if (ppt)
        {
            rc.left = 0;
            rc.right = ppt->x;
        }

        RECT rcTB;
        GetWindowRect(m_hwndClose, &rcTB);
        rc.left = rc.right - (rcTB.right - rcTB.left) - 3;

        DWORD top = max((int) ((m_cyTitleBar - (rcTB.bottom - rcTB.top)) / 2) + 1, 0);

        SetWindowPos(m_hwndClose, HWND_TOP, rc.left, top, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
    }
}

void CPaneFrame::_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    POINT pt = {x, y};
    UINT  id;

    if (m_idMenu && PtInRect(&m_rcTitleButton, pt))
    {
        m_fHighlightPressed = TRUE;
        InvalidateRect(m_hwnd, &m_rcTitleButton, TRUE);
        UpdateWindow(m_hwnd);

        HMENU hMenu = LoadPopupMenu(m_idMenu);
        MenuUtil_EnablePopupMenu(hMenu, m_pTarget);

        if (m_idMenu == IDR_BA_TITLE_POPUP && ((g_dwHideMessenger == BL_HIDE) || (g_dwHideMessenger == BL_DISABLE)))
        {
            DeleteMenu(hMenu, ID_NEW_ONLINE_CONTACT, MF_BYCOMMAND);
            DeleteMenu(hMenu, ID_SET_ONLINE_CONTACT, MF_BYCOMMAND);
            DeleteMenu(hMenu, SEP_MESSENGER, MF_BYCOMMAND);
            DeleteMenu(hMenu, ID_SORT_BY_NAME, MF_BYCOMMAND);
            DeleteMenu(hMenu, ID_SORT_BY_STATUS, MF_BYCOMMAND);
        }

        pt.x = m_rcTitleButton.left;
        pt.y = m_rcTitleButton.bottom;

        ClientToScreen(m_hwnd, &pt);
        id = TrackPopupMenuEx(hMenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                              pt.x, pt.y, m_hwnd, NULL);
        if (id)
        {
            m_pTarget->Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        }

        m_fHighlightPressed = m_fHighlightIndicator = FALSE;
        KillTimer(m_hwnd, IDT_PANETIMER);
        InvalidateRect(m_hwnd, &m_rcTitleButton, TRUE);
        UpdateWindow(m_hwnd);

        if(hMenu)
        {
            //Bug #101329 - (erici) Destroy leaked MENU.
            BOOL bMenuDestroyed = DestroyMenu(hMenu);
            Assert(bMenuDestroyed);
        }
    }
}


void CPaneFrame::_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
{
    POINT pt = {x, y};

    if (m_idMenu && (m_fHighlightIndicator != PtInRect(&m_rcTitleButton, pt)))
    {
        m_fHighlightIndicator = !m_fHighlightIndicator;
        InvalidateRect(m_hwnd, &m_rcTitleButton, TRUE);

        if (m_fHighlightIndicator)
            SetTimer(m_hwnd, IDT_PANETIMER, ELAPSE_MOUSEOVERCHECK, NULL);
        else
            KillTimer(m_hwnd, IDT_PANETIMER);
    }       
}

void CPaneFrame::_OnTimer(HWND hwnd, UINT id)
{
    RECT rcClient;
    POINT pt;
    DWORD dw;

    dw = GetMessagePos();
    pt.x = LOWORD(dw);
    pt.y = HIWORD(dw);
    ScreenToClient(m_hwnd, &pt);

    if (id == IDT_PANETIMER)
    {
        GetClientRect(m_hwnd, &rcClient);

        // No need to handle mouse in client area, OnMouseMove will catch this. We
		// only need to catch the mouse moving out of the client area.
		if (!PtInRect(&rcClient, pt) && !m_fHighlightPressed)
		{
			KillTimer(m_hwnd, IDT_PANETIMER);
			m_fHighlightIndicator = FALSE;
            InvalidateRect(m_hwnd, &m_rcTitleButton, TRUE);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\smapi.cpp ===
//
//  SMAPI.CPP - Simple MAPI implementation
//

#include "pch.hxx"
#include "note.h"
#include <mapi.h>
#include <mapicode.h>
#include <mimeutil.h>
#include <resource.h>
#include <ipab.h>
#include <error.h>
#include <strconst.h>
#include "smapimem.h"
#include <bodyutil.h>
#include <goptions.h>
#include <spoolapi.h>
#include "instance.h"
#include "msgfldr.h"
#include <mailutil.h>
#include <storecb.h>
#include "multiusr.h"
#include <..\help\mailnews.h>
#include <inetcfg.h>
#include "mapidlg.h"

#include "demand.h"

ASSERTDATA

static LPWAB            s_lpWab;
static LPWABOBJECT      s_lpWabObject;
static IAddrBook*       s_lpAddrBook;

extern  HANDLE  hSmapiEvent;
HINITREF    hInitRef=NULL;

HRESULT HrAdrlistFromRgrecip(ULONG nRecips, lpMapiRecipDesc lpRecips, LPADRLIST *ppadrlist);
HRESULT HrRgrecipFromAdrlist(LPADRLIST lpAdrList, lpMapiRecipDesc * lppRecips);
void ParseEmailAddress(LPSTR pszEmail, LPSTR *ppszAddrType, LPSTR *ppszAddress);
void FreePadrlist(LPADRLIST padrlist);
ULONG HrFillMessage(LPMIMEMESSAGE *pmsg, lpMapiMessage lpMessage, BOOL *pfWebPage, BOOL bValidateRecips, BOOL fOriginator);
BOOL HrReadMail (IMessageFolder *pFolder, LPSTR lpszMessageID, lpMapiMessage FAR *lppMessage, FLAGS flFlags);
ULONG HrValidateMessage(lpMapiMessage lpMessage);
BOOL HrSMAPISend(HWND hWnd, IMimeMessage *pMsg);
HRESULT HrFromIDToNameAndAddress(LPTSTR *pszLocalName, LPTSTR *pszLocalAddress, ULONG cbEID, LPENTRYID lpEID);
INT_PTR CALLBACK WarnSendMailDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

//  Fix for Bug #62129 (v-snatar)
HRESULT HrSendAndRecv();

typedef enum tagINTERACTIVESTATE
{
    IS_UNINIT,
    IS_INTERACTIVE,
    IS_NOTINTERACTIVE,
} INTERACTIVESTATE;

// Determine if the current process is a service or not
BOOL IsProcessInteractive(void);

///////////////////////////////////////////////////////////////////////
//
// UlSimpleMAPIInit
//
///////////////////////////////////////////////////////////////////////
ULONG UlSimpleMAPIInit(BOOL fInit, HWND hwnd, BOOL fLogonUI)
{
    ULONG   ulRet = SUCCESS_SUCCESS;
    BOOL    bCoIncrementFailure = FALSE;
    
    if (fInit)
    {
        // [PaulHi] 5/17/99  @todo @bug
        // The "SimpleMAPIInit" name is used in debug only builds to track users of
        // OE.  However, if this function (CoIncrementInit) fails (if user doesn't
        // provide identity) then a memory leak will occur because CoDecrementInit()
        // is called with "COutlookExpress" and so the "SimpleMAPIInit" node isn't
        // free'd.  Again, this is for debug binaries only.

        /*
            Yet more cludgyness:

            If SMAPI is not allowed to show logon UI, we ask OE to use the default
            identity.  However, the default identity could have a password on it.
            In this case, SMAPI would like to fail the logon.  Unfortunately, the 
            identity manager does not make it easy to discover if an identity has a
            a password (we would need to grok the registry).  This limitation is 
            currently moot as OE will logon to the default identity without requiring
            the user to supply the required password.  If this is fixed, we will have
            to change this code.
        */
        if (FAILED(CoIncrementInit("SimpleMAPIInit", MSOEAPI_START_SHOWERRORS | 
            ((fLogonUI) ? 0 : MSOEAPI_START_DEFAULTIDENTITY ), NULL, &hInitRef)))
        {
            ulRet = MAPI_E_FAILURE;
            bCoIncrementFailure = TRUE;
            goto exit;
        }

        if (S_OK != ProcessICW(hwnd, FOLDER_LOCAL, TRUE, fLogonUI))
        {
            ulRet = MAPI_E_LOGON_FAILURE;
            goto exit;
        }
        
        if (NULL == s_lpWab)
        {
            if (FAILED(HrCreateWabObject(&s_lpWab)))
            {
                ulRet = MAPI_E_FAILURE;
                goto exit;
            }
            Assert(s_lpWab);
            
            if (FAILED(s_lpWab->HrGetAdrBook(&s_lpAddrBook)))
            {
                ulRet = MAPI_E_FAILURE;
                goto exit;
            }
            Assert(s_lpAddrBook);
            
            if (FAILED(s_lpWab->HrGetWabObject(&s_lpWabObject)))
            {
                ulRet = MAPI_E_FAILURE;
                goto exit;
            }
            Assert(s_lpWabObject);
        }
        else
        {
            if (FAILED(s_lpWab->HrGetWabObject(&s_lpWabObject)))
            {
                ulRet = MAPI_E_FAILURE;
                goto exit;
            }
            Assert(s_lpWabObject);
        }
    }

exit:
    if (FALSE == fInit || (fInit && SUCCESS_SUCCESS != ulRet && !bCoIncrementFailure))
    {
        CoDecrementInit("SimpleMAPIInit", NULL);
    }
    
    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// SimpleMAPICleanup
//
///////////////////////////////////////////////////////////////////////
void SimpleMAPICleanup(void)
{
    SafeRelease(s_lpWab);
    s_lpWabObject = NULL;
    s_lpAddrBook = NULL;
}

///////////////////////////////////////////////////////////////////////
//
// Simple MAPI Session Implementation
//
///////////////////////////////////////////////////////////////////////

#define SESSION_MAGIC   0xEA030571

class CSession
{
public:
    CSession();
    ~CSession();
    ULONG UlInit(HWND hwnd, BOOL fLogonUI);

    ULONG                m_cRef;
    DWORD                m_dwSessionMagic;
    IMessageFolder       *m_pfldrInbox;
    BOOL                 m_fDllInited;
};

typedef CSession * PSESS;

CSession::CSession()
{
    m_cRef = 0;
    m_dwSessionMagic = SESSION_MAGIC;
    m_pfldrInbox = NULL;
    m_fDllInited = FALSE;
}

CSession::~CSession()
{
    if (m_pfldrInbox)
        m_pfldrInbox->Release();
    if (m_fDllInited)
        {
        UlSimpleMAPIInit(FALSE, NULL, FALSE);
        }
}

ULONG CSession::UlInit(HWND hwnd, BOOL fLogonUI)
{
    ULONG   ulRet = SUCCESS_SUCCESS;

    ulRet = UlSimpleMAPIInit(TRUE, hwnd, fLogonUI);
    if (SUCCESS_SUCCESS == ulRet)
    {
        m_fDllInited = TRUE;
    }
    
    return ulRet;
}

ULONG UlGetSession(LHANDLE lhSession, PSESS *ppSession, ULONG_PTR ulUIParam, BOOL fLogonUI, BOOL fNeedInbox)
{
    ULONG   ulRet = SUCCESS_SUCCESS;
    PSESS   pSession = NULL;

    if (lhSession && IsBadWritePtr((LPVOID)lhSession, sizeof(CSession)))
    {
        ulRet = MAPI_E_INVALID_SESSION;
        goto exit;
    }
    
    if (lhSession)
    {
        pSession = (PSESS)lhSession;
        if (pSession->m_dwSessionMagic != SESSION_MAGIC)
        {
            ulRet = MAPI_E_INVALID_SESSION;
            goto exit;
        }
    }
    else
    {
        pSession = new CSession();
        if (NULL == pSession)
        {
            ulRet = MAPI_E_INSUFFICIENT_MEMORY;
            goto exit;
        }

        ulRet = pSession->UlInit((HWND) ulUIParam, fLogonUI);
        if (SUCCESS_SUCCESS != ulRet)
        {
            delete pSession;
            goto exit;
        }
    }

    if (fNeedInbox && !pSession->m_pfldrInbox)
    {
        if (FAILED(g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_INBOX, &pSession->m_pfldrInbox)))
        {
            ulRet = MAPI_E_FAILURE;
            goto exit;
        }
    }

    pSession->m_cRef++;
    *ppSession = pSession;

    // Set the return value
    ulRet = SUCCESS_SUCCESS;
    
exit:
    return ulRet;    
}

ULONG ReleaseSession(PSESS pSession)
{
    HRESULT hr =S_OK;
    if (NULL == pSession)
        return MAPI_E_INVALID_SESSION;
    if (IsBadWritePtr(pSession, sizeof(CSession)))
        return MAPI_E_INVALID_SESSION;
    if (pSession->m_dwSessionMagic != SESSION_MAGIC)
        return MAPI_E_INVALID_SESSION;
    
    if (--pSession->m_cRef == 0)
    {
        delete pSession;

/*        if(hInitRef)
            IF_FAILEXIT(hr = CoDecrementInit("SimpleMAPIInit", &hInitRef));

        hInitRef = NULL;
*/
    }

    return SUCCESS_SUCCESS;
// exit:
    return(hr);
}

///////////////////////////////////////////////////////////////////////
//
// MAPILogon
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPILogon(ULONG_PTR ulUIParam,
                           LPSTR lpszProfileName,
                           LPSTR lpszPassword,
                           FLAGS flFlags,
                           ULONG ulReserved,
                           LPLHANDLE lplhSession)
{
    ULONG ulRet = SUCCESS_SUCCESS;
    PSESS pSession = NULL;
    BOOL  fLogonUI;

    fLogonUI = (0 != (flFlags & MAPI_LOGON_UI));

    // If the process is not interactive, they should not have 
    // allowed any UI
    if (!IsProcessInteractive() && fLogonUI)
    {
        ulRet = MAPI_E_FAILURE;
        goto exit;
    }     

    ulRet = UlGetSession(NULL, &pSession, ulUIParam, fLogonUI, FALSE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;
        
    *lplhSession = (LHANDLE)pSession;    
    
    //  Fix for Bug #62129 (v-snatar)
    if (flFlags & MAPI_FORCE_DOWNLOAD)
        HrSendAndRecv();
    
exit:
    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// MAPILogoff
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPILogoff(LHANDLE lhSession,
                            ULONG_PTR ulUIParam,
                            FLAGS flFlags,
                            ULONG ulReserved)
{
    return ReleaseSession((PSESS)lhSession);
}

///////////////////////////////////////////////////////////////////////
//
// MAPIFreeBuffer
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIFreeBuffer(LPVOID lpv)
{
    LPBufInternal   lpBufInt;
    LPBufInternal   lpT;

    if (!lpv)
        return(0L); //  for callers who don't check for NULL themselves.

    lpBufInt = LPBufIntFromLPBufExt(lpv);

    if (IsBadWritePtr(lpBufInt, sizeof(BufInternal)))
        {
        TellBadBlock(lpv, "fails address check");
        return MAPI_E_FAILURE;
        }
    if (GetFlags(lpBufInt->ulAllocFlags) != ALLOC_WITH_ALLOC)
        {
        TellBadBlock(lpv, "has invalid allocation flags");
        return MAPI_E_FAILURE;
        }

#ifdef DEBUG
    if (!FValidAllocChain(lpBufInt))
        goto ret;
#endif

    // Free the first block
    lpT = lpBufInt->pLink;
    g_pMalloc->Free(lpBufInt);
    lpBufInt = lpT;

    while (lpBufInt)
        {
        if (IsBadWritePtr(lpBufInt, sizeof(BufInternal)) || GetFlags(lpBufInt->ulAllocFlags) != ALLOC_WITH_ALLOC_MORE)
            goto ret;

        lpT = lpBufInt->pLink;
        g_pMalloc->Free(lpBufInt);
        lpBufInt = lpT;
        }

ret:
    return SUCCESS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
//
// MAPISendMail
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPISendMail(LHANDLE lhSession,          // ignored
                              ULONG_PTR ulUIParam,
                              lpMapiMessage lpMessage,
                              FLAGS flFlags,
                              ULONG ulReserved)
{
    ULONG               ulRet = SUCCESS_SUCCESS;
    LPMIMEMESSAGE       pMsg = NULL;
    HRESULT             hr; 
    BOOL                fWebPage;
    PSESS               pSession = NULL;
    BOOL                fLogonUI;
    BOOL                fOleInit = FALSE;

    // validate parameters
    if (NULL == lpMessage || IsBadReadPtr(lpMessage, sizeof(MapiMessage)))
        return MAPI_E_INVALID_MESSAGE;

    fLogonUI = (0 != (flFlags & MAPI_LOGON_UI));
    
    // If the process is not interactive, they should not allow any UI
    if (!IsProcessInteractive() && fLogonUI)
    {
        return MAPI_E_FAILURE;
    } 

    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    if (!(flFlags & MAPI_DIALOG))
        {
        ulRet = HrValidateMessage(lpMessage);
        if (ulRet)
            return ulRet;
        }    

    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, fLogonUI, FALSE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;

    // display warning dialog if app is sending mail without ui and the users
    // wish to be alerted
    if (!(flFlags & MAPI_DIALOG) && !!DwGetOption(OPT_SECURITY_MAPI_SEND))
    {
        if (IDCANCEL == DialogBoxParam(g_hLocRes,MAKEINTRESOURCE(iddMapiSend),
                        NULL, (DLGPROC)WarnSendMailDlgProc, (LPARAM)lpMessage))
            goto error;
    }

    // Make sure OLE is initialized
    OleInitialize(NULL);
    fOleInit = TRUE;

    // Fill IMimeMessage with the lpMessage structure members
    ulRet = HrFillMessage(&pMsg, lpMessage, &fWebPage, !(flFlags & MAPI_DIALOG), !(flFlags & MAPI_DIALOG));
    if (ulRet)
        goto error;

    if (flFlags & MAPI_DIALOG)
        {
        INIT_MSGSITE_STRUCT rInitSite;
        DWORD               dwAction,
                            dwCreateFlags = OENCF_SENDIMMEDIATE | OENCF_MODAL; // always on dllentry points...

        if (fWebPage)
            dwAction = OENA_WEBPAGE;
        else
            dwAction = OENA_COMPOSE;

        rInitSite.dwInitType = OEMSIT_MSG;
        rInitSite.pMsg = pMsg;
        rInitSite.folderID = FOLDERID_INVALID;
        hr = CreateAndShowNote(dwAction, dwCreateFlags, &rInitSite, (HWND)ulUIParam);
        hInitRef = NULL;
        }
    else
        hr = HrSMAPISend((HWND)ulUIParam, pMsg); // Send the Message without displaying it

    if (SUCCEEDED(hr))
        ulRet = SUCCESS_SUCCESS;
    else
        ulRet = MAPI_E_FAILURE;

error:
    if (pMsg)
        pMsg->Release();

    ReleaseSession(pSession);

    // Make sure we clean up OLE afterwords
    if (fOleInit)
        OleUninitialize();
    
    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// MAPISendDocuments
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPISendDocuments(ULONG_PTR ulUIParam,
                                   LPSTR lpszDelimChar,
                                   LPSTR lpszFullPaths,
                                   LPSTR lpszFileNames,
                                   ULONG ulReserved)
{
    ULONG               ulRet = MAPI_E_FAILURE;
    int                 cch;
    LPMIMEMESSAGE       pMsg = NULL;
    HRESULT             hr;
    CStringParser       spPath;
    int                 nCount=0; // Used to find the number of files to be attached
    PSESS               pSession = NULL;
    INIT_MSGSITE_STRUCT rInitSite;
    DWORD               dwAction,
                        dwCreateFlags = OENCF_SENDIMMEDIATE | OENCF_MODAL; //always on dllentry points...
    // check for the Delimiter
    Assert(lpszDelimChar);
    if (lpszDelimChar == NULL)
        return MAPI_E_FAILURE;

    // check for the Paths
    Assert (lpszFullPaths);
    if (lpszFullPaths == NULL)
        return MAPI_E_FAILURE;

    // MAPISendDocuments is documented as always bringing up UI
    // A service should not call this function
    if (!IsProcessInteractive())
        return MAPI_E_LOGIN_FAILURE;
    
    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    ulRet = UlGetSession(NULL, &pSession, ulUIParam, TRUE, FALSE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;
        
    // create an empty message
    hr = HrCreateMessage(&pMsg);
    if (FAILED(hr))
        goto error;

    dwAction = OENA_COMPOSE;

    // ~~~ Do I need to do something with OEMSIT_VIRGIN?
    rInitSite.dwInitType = OEMSIT_MSG;
    rInitSite.pMsg = pMsg;
    rInitSite.folderID = FOLDERID_INVALID;

    // Determine the number of attachments (nCount), indiviual file names and pathnames

    // call pMsg->AttachFile with appropriate parameters nCount times

    // To parse the lpszFullPaths and lpszFileNames use CStringParser class

    spPath.Init(lpszFullPaths, lstrlen(lpszFullPaths), 0);

    //Parse the path for the delimiter

    spPath.ChParse(lpszDelimChar);

    while (spPath.CchValue())
    {
        // Add the attachment

        hr = pMsg->AttachFile(spPath.PszValue(), NULL, NULL);
        if (FAILED(hr))
            goto error;
        nCount++;

        //Parse the path for the delimiter

        spPath.ChParse(lpszDelimChar);
    }

    // set the subject on the message

    if (nCount == 1)
    {
        if (lpszFileNames)
            hr = MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, lpszFileNames);
    }
    else
    {
        TCHAR szBuf[CCHMAX_STRINGRES];
        AthLoadString(idsAttachedFiles, szBuf, ARRAYSIZE(szBuf));
        hr = MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, szBuf);
    }

    if (FAILED(hr))
        goto error;

    hr = CreateAndShowNote(dwAction, dwCreateFlags, &rInitSite, (HWND)ulUIParam);
    if (SUCCEEDED(hr))
        ulRet = SUCCESS_SUCCESS;

error:
    if (pMsg)
        pMsg->Release();

    ReleaseSession(pSession);

    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// MAPIAddress
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIAddress(LHANDLE lhSession,
                             ULONG_PTR ulUIParam,
                             LPTSTR lpszCaption,
                             ULONG nEditFields,
                             LPTSTR lpszLabels,
                             ULONG nRecips,
                             lpMapiRecipDesc lpRecips,
                             FLAGS flFlags,
                             ULONG ulReserved,
                             LPULONG lpnNewRecips,
                             lpMapiRecipDesc FAR * lppNewRecips)
{
    ULONG               ul, ulRet = MAPI_E_FAILURE;
    HRESULT             hr;
    LPADRLIST           lpAdrList = 0;
    ADRPARM             AdrParms = {0};
    static ULONG        rgulTypes[3] = {MAPI_TO, MAPI_CC, MAPI_BCC};
    PSESS               pSession = NULL;
    BOOL                fLogonUI;

    // Validate Parameters - Begin

    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    if (lpszCaption && IsBadStringPtr(lpszCaption, (UINT)0xFFFF))
        return MAPI_E_FAILURE;

    if (nEditFields > 4)
        return MAPI_E_INVALID_EDITFIELDS;

    if (nEditFields == 1 && lpszLabels && IsBadStringPtr(lpszLabels, (UINT)0xFFFF))
        return MAPI_E_INVALID_EDITFIELDS;

    if (nEditFields && IsBadWritePtr(lpnNewRecips, (UINT)sizeof(ULONG)))
        return MAPI_E_INVALID_EDITFIELDS;

    if (nEditFields && IsBadWritePtr(lppNewRecips, (UINT)sizeof(lpMapiRecipDesc)))
        return MAPI_E_INVALID_EDITFIELDS;

    if (nRecips && IsBadReadPtr(lpRecips, (UINT)nRecips * sizeof(MapiRecipDesc)))
        return MAPI_E_INVALID_RECIPS;

    fLogonUI = (0 != (flFlags & MAPI_LOGON_UI));

    // Services shouldn't ask for UI
    if (!IsProcessInteractive() && fLogonUI)
        return MAPI_E_LOGIN_FAILURE;

    // Validate parameters - End

    // init output parameters
    if (nEditFields)
        {
        *lppNewRecips = NULL;
        *lpnNewRecips = 0;
        }

    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, fLogonUI, FALSE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;
        
    // build an adrlist from the lpRecips
    if (nRecips)
        {
        ULONG ulMax = MAPI_TO;

        hr = HrAdrlistFromRgrecip(nRecips, lpRecips, &lpAdrList);
        if (hr)
            goto exit;
        Assert(nRecips == lpAdrList->cEntries);

        // we need to grow nEditFields if it isn't big enough
        for (ul = 0; ul < nRecips; ul++)
            {
            if (ulMax < lpRecips[ul].ulRecipClass && lpRecips[ul].ulRecipClass <= MAPI_BCC)
                ulMax = lpRecips[ul].ulRecipClass;
            }
        Assert(ulMax >= MAPI_TO && ulMax <= MAPI_BCC);
        if (ulMax > nEditFields)
            {
            DOUT("MAPIAddress: growing nEditFields from %ld to %ld\r\n", nEditFields, ulMax);
            nEditFields = ulMax;
            }
        }

    // Fill the AdrParm structure

    AdrParms.ulFlags = DIALOG_MODAL;
    AdrParms.lpszCaption = lpszCaption;
    AdrParms.cDestFields = nEditFields == 4 ? 3 : nEditFields;
    if (nEditFields == 1 && lpszLabels && *lpszLabels)
        AdrParms.lppszDestTitles = &lpszLabels;
    AdrParms.lpulDestComps = rgulTypes;

    if (NULL == s_lpAddrBook)
        {
        ulRet = MAPI_E_FAILURE;
        goto exit;
        }
    
    hr = s_lpAddrBook->Address(&ulUIParam, &AdrParms, &lpAdrList);
    if (hr)
        {
        if (MAPI_E_USER_CANCEL == hr)
            ulRet = MAPI_E_USER_ABORT;
        else if (MAPI_E_NO_RECIPIENTS == hr || MAPI_E_AMBIGUOUS_RECIP == hr)
            ulRet = MAPI_E_INVALID_RECIPS;
        goto exit;
        }

    if (nEditFields && lpAdrList && lpAdrList->cEntries)
    {    
        hr = HrRgrecipFromAdrlist(lpAdrList, lppNewRecips);
        if (hr)
            goto exit;

        *lpnNewRecips = lpAdrList->cEntries;
    }

    ulRet = SUCCESS_SUCCESS;

exit:

    FreePadrlist(lpAdrList);

    ReleaseSession(pSession);

    return ulRet;
}



///////////////////////////////////////////////////////////////////////
//
// MAPIDetails
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIDetails(LHANDLE lhSession,
                             ULONG_PTR ulUIParam,
                             lpMapiRecipDesc lpRecip,
                             FLAGS flFlags,
                             ULONG ulReserved)
{
    ULONG                   ulRet = MAPI_E_FAILURE;
    HRESULT                 hr;
    LPSTR                   pszAddrType = 0;
    LPSTR                   pszAddress = 0;
    ULONG                   cbEntryID;
    LPENTRYID               lpEntryID = 0;
    PSESS                   pSession = NULL;
    BOOL                    fLogonUI;

    // Validate  parameters - Begin

    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    if (IsBadReadPtr(lpRecip, (UINT)sizeof(MapiRecipDesc)))
        return MAPI_E_INVALID_RECIPS;

    if (lpRecip->ulEIDSize == 0 && !lpRecip->lpszAddress)
        return MAPI_E_INVALID_RECIPS;

    fLogonUI = (0 != (flFlags & MAPI_LOGON_UI));

    // Services shouldn't ask for UI
    if (!IsProcessInteractive() && fLogonUI)
        return MAPI_E_LOGIN_FAILURE;

    // Validate parameters - End

    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, fLogonUI, FALSE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;
        
    if (NULL == s_lpAddrBook)
        {
        ulRet = MAPI_E_FAILURE;
        goto exit;
        }
    
    if (lpRecip->ulEIDSize)
        {
        cbEntryID = lpRecip->ulEIDSize;
        lpEntryID = (LPENTRYID)lpRecip->lpEntryID;
        }
    else
        {
        ParseEmailAddress(lpRecip->lpszAddress, &pszAddrType, &pszAddress);

        CHECKHR(hr = s_lpAddrBook->CreateOneOff(lpRecip->lpszName, pszAddrType, pszAddress, 0, &cbEntryID, &lpEntryID));
        }

    CHECKHR(hr = s_lpAddrBook->Details(&ulUIParam, NULL, NULL, cbEntryID, lpEntryID, NULL, NULL, NULL, DIALOG_MODAL));
    ulRet = SUCCESS_SUCCESS;

exit:
    if (pszAddrType)
        MemFree(pszAddrType);
    if (pszAddress)
        MemFree(pszAddress);

    if (lpEntryID && lpEntryID != lpRecip->lpEntryID && NULL != s_lpWabObject)
        s_lpWabObject->FreeBuffer(lpEntryID);

    ReleaseSession(pSession);

    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// MAPIResolveName
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIResolveName(LHANDLE lhSession,
                                 ULONG_PTR ulUIParam,
                                 LPSTR lpszName,
                                 FLAGS flFlags,
                                 ULONG ulReserved,
                                 lpMapiRecipDesc FAR *lppRecip)
{
    ULONG                ulRet = SUCCESS_SUCCESS, ulNew;
    LPADRLIST            lpAdrList = 0;
    HRESULT              hr;
    LPADRENTRY           lpAdrEntry;
    PSESS                pSession = NULL;
    BOOL                 fLogonUI;

    // Validate  parameters - Begin    
    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    /*
      HACK:  #68119 Excel doesn't pass in a parent.
      This isn't the best thing to do, but this handle shouldn't be 0.
      The only thing to watch out for is fast actions while this processing
      is happening could make this dialog modal to the wrong window, but
      that us much more unlikely than the bug this fixes.
    */
    if(!ulUIParam)
        ulUIParam = (ULONG_PTR)GetForegroundWindow();

    if (!lpszName || IsBadStringPtr(lpszName, (UINT)0xFFFF) || !*lpszName)
        return MAPI_E_FAILURE;

    if (IsBadWritePtr(lppRecip, (UINT)sizeof(lpMapiRecipDesc)))
        return MAPI_E_FAILURE;

    fLogonUI = (0 != (flFlags & MAPI_LOGON_UI));

    // Services shouldn't ask for UI
    if (!IsProcessInteractive() && fLogonUI)
        return MAPI_E_LOGIN_FAILURE;

    // Validate  parameters - End

    *lppRecip = NULL;

    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, fLogonUI, FALSE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;
        
    // Allocate memory for lpAdrList

    // Determine number of bytes needed
    ulNew = sizeof(ADRLIST) + sizeof(ADRENTRY);

    // Allocate new buffer
    if (NULL == s_lpWabObject)
        {
        ulRet = MAPI_E_FAILURE;
        goto exit;
        }
        
    hr = s_lpWabObject->AllocateBuffer(ulNew, (LPVOID *)&lpAdrList);
    if (hr)
        goto exit;

    lpAdrList->cEntries = 1;
    lpAdrEntry = lpAdrList->aEntries;

    // Allocate memory for SPropValue
    hr = s_lpWabObject->AllocateBuffer(sizeof(SPropValue), (LPVOID *)&lpAdrEntry->rgPropVals);
    if (hr)
        goto exit;

    lpAdrEntry->cValues = 1;
    lpAdrEntry->rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;

    hr = s_lpWabObject->AllocateMore(lstrlen(lpszName) + 1, lpAdrEntry->rgPropVals, (LPVOID*)(&(lpAdrEntry->rgPropVals[0].Value.lpszA)));
    if (FAILED (hr))
        goto exit;

    // Fill in the name
    lstrcpy(lpAdrEntry->rgPropVals[0].Value.lpszA, lpszName);

     // Call ResolveName of IAddrBook
    if (NULL == s_lpAddrBook)
        {
        ulRet = MAPI_E_FAILURE;
        goto exit;
        }
    
    hr = s_lpAddrBook->ResolveName(ulUIParam, flFlags & MAPI_DIALOG, NULL, lpAdrList);

    if (hr)
        {
        if ((hr == MAPI_E_NOT_FOUND) || (hr == MAPI_E_USER_CANCEL))
            ulRet = MAPI_E_UNKNOWN_RECIPIENT;
        else if (hr == MAPI_E_AMBIGUOUS_RECIP)
            ulRet = MAPI_E_AMBIGUOUS_RECIPIENT;
        else
            ulRet = MAPI_E_FAILURE;
        goto exit;
        }
    else if ((lpAdrList->cEntries != 1) || !lpAdrList->aEntries->cValues)
        {
        ulRet = MAPI_E_AMBIGUOUS_RECIPIENT;
        goto exit;
        }

    ulRet = HrRgrecipFromAdrlist(lpAdrList, lppRecip);

exit:

    FreePadrlist(lpAdrList);

    ReleaseSession(pSession);

    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// MAPIFindNext
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIFindNext(LHANDLE lhSession,
                              ULONG_PTR ulUIParam,
                              LPSTR lpszMessageType,
                              LPSTR lpszSeedMessageID,
                              FLAGS flFlags,
                              ULONG ulReserved,
                              LPSTR lpszMessageID)
{
    MESSAGEINFO             MsgInfo={0};
    ULONG                   ulRet = MAPI_E_FAILURE;
    HRESULT                 hr;
    MESSAGEID               idMessage;
    MESSAGEID               dwMsgIdPrev;
    PSESS                   pSession = NULL;
    HROWSET                 hRowset=NULL;

    // Validate parameters - begin

    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    if (lpszSeedMessageID && IsBadStringPtr(lpszSeedMessageID, (UINT)0xFFFF))
        return MAPI_E_INVALID_MESSAGE;

    if (lpszSeedMessageID && (!*lpszSeedMessageID || !IsDigit(lpszSeedMessageID)))
        lpszSeedMessageID = NULL;

    if (IsBadWritePtr(lpszMessageID, 64))
        return MAPI_E_INSUFFICIENT_MEMORY;
    
    // Validate parameters - end

    // We shouldn't need to show login UI, because the session must be valid
    // and a valid session would require a login
    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, FALSE, TRUE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;

    hr = pSession->m_pfldrInbox->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset);
    if (FAILED(hr))
    {
        ulRet = MAPI_E_NO_MESSAGES;
        goto exit;
    }

    hr = pSession->m_pfldrInbox->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL);
    if (FAILED(hr) || S_FALSE == hr)
    {
        ulRet = MAPI_E_NO_MESSAGES;
        goto exit;
    }

    if (lpszSeedMessageID)               // If the seed is NULL
    {
        idMessage = (MESSAGEID)((UINT_PTR)StrToUint(lpszSeedMessageID));

        while (1)
        {
            dwMsgIdPrev = MsgInfo.idMessage;

            pSession->m_pfldrInbox->FreeRecord(&MsgInfo);

            hr = pSession->m_pfldrInbox->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL);

            if (FAILED(hr) || S_FALSE == hr)
            {
                ulRet = MAPI_E_NO_MESSAGES;
                goto exit;
            }

            if (dwMsgIdPrev == idMessage)
                break;
        }
    }

    // Check for Read unread messages only flag
    if (flFlags & MAPI_UNREAD_ONLY)
    {
        while (ISFLAGSET(MsgInfo.dwFlags, ARF_READ))
        {
            // Free MsgInfo
            pSession->m_pfldrInbox->FreeRecord(&MsgInfo);

            // Get the next message
            hr = pSession->m_pfldrInbox->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL);

            // Not Found
            if (FAILED(hr) || S_FALSE == hr)
            {
                ulRet = MAPI_E_NO_MESSAGES;
                goto exit;
            }
        }
    }            
    
    wsprintf(lpszMessageID, "%lu", MsgInfo.idMessage);
    ulRet = SUCCESS_SUCCESS;

exit:
    if (pSession && pSession->m_pfldrInbox)
    {
        pSession->m_pfldrInbox->CloseRowset(&hRowset);
        pSession->m_pfldrInbox->FreeRecord(&MsgInfo);
    }

    ReleaseSession(pSession);

    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// MAPIReadMail
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIReadMail(LHANDLE lhSession,
                              ULONG_PTR ulUIParam,
                              LPSTR lpszMessageID,
                              FLAGS flFlags,
                              ULONG ulReserved,
                              lpMapiMessage FAR *lppMessage)
{
    ULONG                   ulRet = MAPI_E_FAILURE;
    HRESULT                 hr;
    lpMapiMessage           rgMessage = NULL;
    PSESS                   pSession = NULL;

    // Validate parameters - Begin

    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    if (!lpszMessageID)
        return MAPI_E_INVALID_MESSAGE;

    if (lpszMessageID && (!*lpszMessageID || !IsDigit(lpszMessageID)))
        return MAPI_E_INVALID_MESSAGE;

    if (IsBadWritePtr(lppMessage,(UINT)sizeof(lpMapiMessage)))
        return MAPI_E_FAILURE;

    // Validate parameters - End

    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, FALSE, TRUE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;

    if (!HrReadMail(pSession->m_pfldrInbox, lpszMessageID, &rgMessage, flFlags))
        goto exit;

    ulRet = SUCCESS_SUCCESS;

    *lppMessage = rgMessage;

exit:
    if (ulRet != SUCCESS_SUCCESS)
        if (rgMessage)
            MAPIFreeBuffer(rgMessage);

    ReleaseSession(pSession);

    return ulRet;
}


///////////////////////////////////////////////////////////////////////
//
// MAPISaveMail
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPISaveMail(LHANDLE lhSession,
                              ULONG_PTR ulUIParam,
                              lpMapiMessage lpMessage,
                              FLAGS flFlags,
                              ULONG ulReserved,
                              LPSTR lpszMessageID)
{
    ULONG           ulRet = MAPI_E_FAILURE;
    HRESULT         hr;
    IMimeMessage   *pMsg = NULL;
    MESSAGEID       msgid;
    PSESS           pSession = NULL;
    HWND            hwnd = (HWND)ulUIParam;
    BOOL            fLogonUI;

    // Validate parameters - Begin

    if (ulUIParam && !IsWindow(hwnd))
        hwnd = 0;

    if (!lpszMessageID)
        return MAPI_E_INVALID_MESSAGE;

    if (lpszMessageID && *lpszMessageID && !IsDigit(lpszMessageID))
        return MAPI_E_INVALID_MESSAGE;

    if (IsBadReadPtr(lpMessage, (UINT)sizeof(lpMapiMessage)))
        return MAPI_E_FAILURE;

    fLogonUI = (0 != (flFlags & MAPI_LOGON_UI));

    // Services shouldn't ask for UI
    if (!IsProcessInteractive() && fLogonUI)
        return MAPI_E_LOGIN_FAILURE;

    // Validate parameters - End

    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, fLogonUI, TRUE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;

#pragma prefast(suppress:11, "noise")
    if (*lpszMessageID)
        {
        MESSAGEIDLIST List;
        msgid = (MESSAGEID)((UINT_PTR)StrToUint(lpszMessageID));
        List.cMsgs = 1;
        List.prgidMsg = &msgid;
        if (FAILED(hr = pSession->m_pfldrInbox->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &List, NULL, NOSTORECALLBACK)))
            {
            ulRet = MAPI_E_INVALID_MESSAGE;
            goto exit;
            }
        }

    // Fill IMimeMessage with the lpMessage structure members
    ulRet = HrFillMessage(&pMsg, lpMessage, NULL, FALSE, TRUE);
    if (ulRet)
        goto exit;

    if (FAILED(hr = HrSaveMessageInFolder(hwnd, pSession->m_pfldrInbox, pMsg, 0, &msgid, TRUE)))
        {
        ulRet = MAPI_E_FAILURE;
        goto exit;
        }

    ulRet = SUCCESS_SUCCESS;
    wsprintf(lpszMessageID, "%lu", msgid);

exit:
    if (pMsg)
        pMsg->Release();

    ReleaseSession(pSession);

    return ulRet;
}


///////////////////////////////////////////////////////////////////////
//
// MAPIDeleteMail
//
///////////////////////////////////////////////////////////////////////

ULONG FAR PASCAL MAPIDeleteMail(LHANDLE lhSession,
                                ULONG_PTR ulUIParam,
                                LPSTR lpszMessageID,
                                FLAGS flFlags,
                                ULONG ulReserved)
{
    ULONG                   ulRet = MAPI_E_FAILURE;
    MESSAGEID                   dwMsgID;
    HRESULT                 hr;
    PSESS                   pSession = NULL;
    MESSAGEIDLIST           List;

    // Validate parameters - Begin

    if (ulUIParam && !IsWindow((HWND)ulUIParam))
        ulUIParam = 0;

    if (!lpszMessageID)
        return MAPI_E_INVALID_MESSAGE;

    if (!*lpszMessageID || !IsDigit(lpszMessageID))
        return MAPI_E_INVALID_MESSAGE;

    // Validate parameters - End

    // This function requires a valid session that must have been
    // logged in at some point so login UI is not allowed
    ulRet = UlGetSession(lhSession, &pSession, ulUIParam, FALSE, TRUE);
    if (SUCCESS_SUCCESS != ulRet)
        return ulRet;

    dwMsgID = (MESSAGEID)((UINT_PTR)StrToUint(lpszMessageID));

    List.cMsgs = 1;
    List.prgidMsg = &dwMsgID;

    hr = DeleteMessagesProgress((HWND)ulUIParam, pSession->m_pfldrInbox, DELETE_MESSAGE_NOPROMPT, &List);

    if (FAILED(hr))
        goto exit;

    ulRet = SUCCESS_SUCCESS;

exit:

    ReleaseSession(pSession);

    return ulRet;
}

///////////////////////////////////////////////////////////////////////
//
// INTERNAL FUNCTIONS
//
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//
//  SMAPIAllocateBuffer
//
//  Purpose:
//      Allocates a memory buffer that must be freed with MAPIFreeBuffer().
//
//  Arguments:
//      ulSize  in      Size, in bytes, of the buffer to be allocated.
//      lppv    out     Pointer to variable where the address of the
//                      allocated memory will be returned.
//
//  Returns:
//      sc              Indicating error if any (see below)
//
//  Errors:
//      MAPI_E_INSUFFICIENT_MEMORY  Allocation failed.
//
///////////////////////////////////////////////////////////////////////

SCODE SMAPIAllocateBuffer(ULONG ulSize, LPVOID * lppv)
{
    SCODE           sc = S_OK;
    LPBufInternal   lpBufInt;

    //  Don't allow allocation to wrap across 32 bits, or to exceed 64K
    //  under win16.

    if (ulSize > INT_SIZE(ulSize))
        {
        DOUT("SMAPIAllocateBuffer: ulSize %ld is way too big\n", ulSize);
        sc = MAPI_E_INSUFFICIENT_MEMORY;
        goto ret;
        }

    lpBufInt = (LPBufInternal)g_pMalloc->Alloc((UINT)INT_SIZE(ulSize));

    if (lpBufInt)
        {
        lpBufInt->pLink = NULL;
        lpBufInt->ulAllocFlags = ALLOC_WITH_ALLOC;
        *lppv = (LPVOID)LPBufExtFromLPBufInt(lpBufInt);
        }
    else
        {
        DOUT("SMAPIAllocateBuffer: not enough memory for %ld\n", ulSize);
        sc = MAPI_E_INSUFFICIENT_MEMORY;
        }

ret:
    return sc;
}

///////////////////////////////////////////////////////////////////////
//
//  SMAPIAllocateMore
//
//  Purpose:
//      Allocates a linked memory buffer in such a way that it can be freed
//      with one call to MAPIFreeBuffer (passing the buffer the client
//      originally allocated with SMAPIAllocateBuffer).
//
//  Arguments:
//      ulSize  in      Size, in bytes, of the buffer to be allocated.
//      lpv     in      Pointer to a buffer allocated with SMAPIAllocateBuffer.
//      lppv    out     Pointer to variable where the address of the
//                      allocated memory will be returned.
//
//  Assumes:
//      Validates that lpBufOrig and lppv point to writable memory,
//      and that lpBufOrig was allocated with SMAPIAllocateBuffer.
//
//  Returns:
//      sc              Indicating error if any (see below)
//
//  Side effects:
//      None
//
//  Errors:
//      MAPI_E_INSUFFICIENT_MEMORY  Allocation failed.
//
///////////////////////////////////////////////////////////////////////

SCODE SMAPIAllocateMore(ULONG ulSize, LPVOID lpv, LPVOID * lppv)
{
    SCODE           sc = S_OK;
    LPBufInternal   lpBufInt;
    LPBufInternal   lpBufOrig;

    lpBufOrig = LPBufIntFromLPBufExt(lpv);

#ifdef DEBUG
    if (!FValidAllocChain(lpBufOrig))
        {
        sc = MAPI_E_FAILURE;
        goto ret;
        }
#endif

    //  Don't allow allocation to wrap across 32 bits, or to be
    //  greater than 64K under win16.

    if (ulSize > INT_SIZE(ulSize))
        {
        DOUT("SMAPIAllocateMore: ulSize %ld is way too big\n", ulSize);
        sc = MAPI_E_INSUFFICIENT_MEMORY;
        goto ret;
        }

    //  Allocate the chained block and hook it to the head of the chain.

    lpBufInt = (LPBufInternal)g_pMalloc->Alloc((UINT)INT_SIZE(ulSize));

    if (lpBufInt)
        {
        lpBufInt->ulAllocFlags = ALLOC_WITH_ALLOC_MORE;

        // EnterCriticalSection(&csHeap);

        lpBufInt->pLink = lpBufOrig->pLink;
        lpBufOrig->pLink = lpBufInt;

        // LeaveCriticalSection(&csHeap);

        *lppv = (LPVOID)LPBufExtFromLPBufInt(lpBufInt);
        }
    else
        {
        DOUT("SMAPIAllocateMore: not enough memory for %ld\n", ulSize);
        sc = MAPI_E_INSUFFICIENT_MEMORY;
        }

ret:
    return sc;
}

#ifdef DEBUG

BOOL FValidAllocChain(LPBufInternal lpBuf)
{
    LPBufInternal   lpBufTemp;

    if (IsBadWritePtr(lpBuf, sizeof(BufInternal)))
        {
        TellBadBlockInt(lpBuf, "fails address check");
        return FALSE;
        }
    if (GetFlags(lpBuf->ulAllocFlags) != ALLOC_WITH_ALLOC)
        {
        TellBadBlockInt(lpBuf, "has invalid flags");
        return FALSE;
        }

    for (lpBufTemp = lpBuf->pLink; lpBufTemp; lpBufTemp = lpBufTemp->pLink)
        {
        if (IsBadWritePtr(lpBufTemp, sizeof(BufInternal)))
            {
            TellBadBlockInt(lpBufTemp, "(linked block) fails address check");
            return FALSE;
            }
        if (GetFlags(lpBufTemp->ulAllocFlags) != ALLOC_WITH_ALLOC_MORE)
            {
            TellBadBlockInt(lpBufTemp, "(linked block) has invalid flags");
            return FALSE;
            }
        }

    return TRUE;
}

#endif  // DEBUG

/*
 -  HrAdrentryFromPrecip
 -
 *  Purpose:
 *      Copies data from a MapiRecipDesc structure to the property
 *      value array on an ADRENTRY structure.
 *
 *  Arguments:
 *      precip          in      the input structure
 *      padrentry       out     the output structure
 *
 *  Returns:
 *      HRESULT
 *
 *  Errors:
 *      MAPI_E_INVALID_RECIPS
 *      MAPI_E_BAD_RECIPTYPE
 *      others passed through
 */
HRESULT HrAdrentryFromPrecip(lpMapiRecipDesc precip, ADRENTRY *padrentry)
{
    HRESULT         hr;
    LPSPropValue    pprop;
    LPSTR           pszAddress = NULL;

    // Validate lpMapiRecipDesc, ie, ensure that if there isn't an EntryID or
    // an Address there had better be a Display Name, otherwise we fail
    // like MAPI 0 with MAPI_E_FAILURE.

    if ((!precip->lpszAddress || !precip->lpszAddress[0]) &&
        (!precip->ulEIDSize || !precip->lpEntryID) &&
        (!precip->lpszName || !precip->lpszName[0]))
        {
        hr = MAPI_E_INVALID_RECIPS;
        goto ret;
        }

    if (NULL == s_lpWabObject)
        {
        hr = MAPI_E_FAILURE;
        goto ret;
        }
        
    hr = s_lpWabObject->AllocateBuffer(4 * sizeof(SPropValue), (LPVOID*)&padrentry->rgPropVals);
    if (hr)
        goto ret;

    pprop = padrentry->rgPropVals;

    //  Recipient type
    switch ((short)precip->ulRecipClass)
        {
        case MAPI_TO:
        case MAPI_CC:
        case MAPI_BCC:
            pprop->ulPropTag = PR_RECIPIENT_TYPE;
            pprop->Value.ul = precip->ulRecipClass;
            pprop++;
            break;
        default:
            hr = MAPI_E_BAD_RECIPTYPE;
            goto ret;
        }

    // Display Name
    if (precip->lpszName && *precip->lpszName)
        {
        hr = s_lpWabObject->AllocateMore(lstrlen(precip->lpszName)+1, padrentry->rgPropVals, (LPVOID*)&pprop->Value.lpszA);
        if (hr)
            goto ret;
        pprop->ulPropTag = PR_DISPLAY_NAME;
        lstrcpy(pprop->Value.lpszA, precip->lpszName);
        pprop++;
        }

    // Email Address
    if (precip->lpszAddress && *precip->lpszAddress)
        {
        ParseEmailAddress(precip->lpszAddress, NULL, &pszAddress);
        hr = s_lpWabObject->AllocateMore(lstrlen(pszAddress)+1, padrentry->rgPropVals, (LPVOID*)&pprop->Value.lpszA);
        if (hr)
            goto ret;
        pprop->ulPropTag = PR_EMAIL_ADDRESS;
        lstrcpy(pprop->Value.lpszA, pszAddress);
        pprop++;
        }

    // EntryID
    if (precip->ulEIDSize && precip->lpEntryID)
        {
        hr = s_lpWabObject->AllocateMore(precip->ulEIDSize, padrentry->rgPropVals, (LPVOID*)&pprop->Value.bin.lpb);
        if (hr)
            goto ret;
        pprop->ulPropTag = PR_ENTRYID;
        pprop->Value.bin.cb = precip->ulEIDSize;
        CopyMemory(pprop->Value.bin.lpb, precip->lpEntryID, precip->ulEIDSize);
        pprop++;
        }

    padrentry->cValues = (ULONG) (pprop - padrentry->rgPropVals);

    Assert(padrentry->cValues <= 4);

ret:
    if (pszAddress)
        MemFree(pszAddress);
    if ((hr) && (NULL != s_lpWabObject))
        {
        s_lpWabObject->FreeBuffer(padrentry->rgPropVals);
        padrentry->rgPropVals = NULL;
        }

    return hr;
}


/*
 -  HrAdrlistFromRgrecip
 -
 *  Purpose:
 *      Copies a list of simple MAPI recipients to a list of
 *      extended MAPI recipients.
 *
 *  Arguments:
 *      nRecips         in      count of recipient in input list
 *      lpRecips        in      list of recipients to be converted
 *      ppadrlist       out     output list
 *
 *  Returns:
 *      HRESULT
 *
 */
HRESULT HrAdrlistFromRgrecip(ULONG nRecips, lpMapiRecipDesc lpRecips, LPADRLIST *ppadrlist)
{
    HRESULT         hr;
    LPADRLIST       padrlist = NULL;
    lpMapiRecipDesc precip;
    ULONG           i;
    LPADRENTRY      padrentry = NULL;
    ULONG           cbAdrList = sizeof(ADRLIST) + nRecips * sizeof(ADRENTRY);

    *ppadrlist = NULL;
    if (NULL == s_lpWabObject)
        {
        hr = E_FAIL;
        goto exit;
        }
        
    hr = s_lpWabObject->AllocateBuffer(cbAdrList, (LPVOID*)&padrlist);
    if (hr)
        goto exit;
    ZeroMemory(padrlist, cbAdrList);

    //  Copy each entry.
    //  Note that the memory for each recipient's properties must
    //  be linked so that Address() can free it using MAPIFreeBuffer.
    for (i = 0, padrentry = padrlist->aEntries, precip = lpRecips; i < nRecips; i++, precip++, padrentry++)
        {
        //  Copy the entry. Unresolved names will not be resolved.
        hr = HrAdrentryFromPrecip(precip, padrentry);
        if (hr)
            goto exit;

        // increment count so we can effectively blow away the list if a failure
        // occurs.

        padrlist->cEntries++;
        }

    *ppadrlist = padrlist;

exit:
    Assert( !hr || (ULONG)hr > 26 );

    if (hr)
        FreePadrlist(padrlist);

    return hr;
}

HRESULT HrRgrecipFromAdrlist(LPADRLIST lpAdrList, lpMapiRecipDesc * lppRecips)
{
    HRESULT         hr = S_OK;
    lpMapiRecipDesc rgRecips = NULL;
    lpMapiRecipDesc pRecip;
    LPADRENTRY      pAdrEntry;
    LPSPropValue    pProp;
    ULONG           ul, ulProp;

    if (lpAdrList && lpAdrList->cEntries)
        {
        DWORD dwSize = sizeof(MapiRecipDesc) * lpAdrList->cEntries;

        hr = SMAPIAllocateBuffer(dwSize, (LPVOID*)&rgRecips);
        if (FAILED (hr))
            goto exit;
        ZeroMemory(rgRecips, dwSize);

        // Initialize the Padding

        for (ul = 0, pAdrEntry = lpAdrList->aEntries, pRecip = rgRecips; ul<lpAdrList->cEntries; ul++, pAdrEntry++, pRecip++)
            {
            for (ulProp = 0, pProp = pAdrEntry->rgPropVals; ulProp < pAdrEntry->cValues; ulProp++, pProp++)
                {
                switch (PROP_ID(pProp->ulPropTag))
                    {
                    case PROP_ID(PR_ENTRYID):
                        hr = SMAPIAllocateMore(pProp->Value.bin.cb, rgRecips, (LPVOID*)(&(pRecip->lpEntryID)));
                        if (FAILED (hr))
                            goto exit;
                        pRecip->ulEIDSize = pProp->Value.bin.cb;
                        CopyMemory(pRecip->lpEntryID, pProp->Value.bin.lpb, pProp->Value.bin.cb);
                        break;

                    case PROP_ID(PR_EMAIL_ADDRESS):
                        hr = SMAPIAllocateMore(lstrlen(pProp->Value.lpszA)+1, rgRecips, (LPVOID*)(&(pRecip->lpszAddress)));
                        if (FAILED (hr))
                            goto exit;
                        lstrcpy(pRecip->lpszAddress, pProp->Value.lpszA);
                        break;

                    case PROP_ID(PR_DISPLAY_NAME):
                        hr = SMAPIAllocateMore(lstrlen(pProp->Value.lpszA)+1, rgRecips,(LPVOID*)(&(pRecip->lpszName)));
                        if (FAILED (hr))
                            goto exit;
                        lstrcpy(pRecip->lpszName, pProp->Value.lpszA);
                        break;

                    case PROP_ID(PR_RECIPIENT_TYPE):
                        pRecip->ulRecipClass = pProp->Value.l;
                        break;

                    default:
                        break;
                    }
                }
            }
        }
exit:
    if (hr)
        {
        MAPIFreeBuffer(rgRecips);
        rgRecips = NULL;
        }
    *lppRecips = rgRecips;
    return hr;
}

void ParseEmailAddress(LPSTR pszEmail, LPSTR *ppszAddrType, LPSTR *ppszAddress)
{
    CStringParser spAddress;
    char          chToken;

    Assert(ppszAddress);

    spAddress.Init(pszEmail, lstrlen(pszEmail), 0);

    // Parse the address for the delimiter

    chToken = spAddress.ChParse(":");

    if (chToken == ':')
        {
        if (ppszAddrType)
            *ppszAddrType = PszDup(spAddress.PszValue());
        spAddress.ChParse(c_szEmpty);
        *ppszAddress = PszDup(spAddress.PszValue());
        }
    else
        {
        if (ppszAddrType)
            *ppszAddrType = PszDup(c_szSMTP);
        *ppszAddress = PszDup(pszEmail);
        }
}


void FreePadrlist(LPADRLIST lpAdrList)
{
    if ((lpAdrList) && (NULL != s_lpWabObject))
        {
        for (ULONG ul = 0; ul < lpAdrList->cEntries; ul++)
            s_lpWabObject->FreeBuffer(lpAdrList->aEntries[ul].rgPropVals);
        s_lpWabObject->FreeBuffer(lpAdrList);
        }
}

ULONG AddMapiRecip(LPMIMEADDRESSTABLE pAddrTable, lpMapiRecipDesc lpRecip, BOOL bValidateRecips)
{
    LPSTR       pszName = NULL, pszAddress = NULL;
    LPSTR       pszNameFree = NULL, pszAddrFree = NULL;
    LPADRLIST   pAdrList = NULL;
    ULONG       ulPropCount;
    ULONG       ulRet = MAPI_E_FAILURE;
    HRESULT     hr;

    if (lpRecip->ulRecipClass > 3 || lpRecip->ulRecipClass < 1)
        return MAPI_E_BAD_RECIPTYPE;

    if (lpRecip->ulEIDSize && lpRecip->lpEntryID && SUCCEEDED(HrFromIDToNameAndAddress(&pszName, &pszAddress, lpRecip->ulEIDSize, (ENTRYID*)lpRecip->lpEntryID)))
        {
        pszNameFree = pszName;
        pszAddrFree = pszAddress;
        }
    else if (lpRecip->lpszAddress && *lpRecip->lpszAddress)
        {
        // we have an email address
        ParseEmailAddress(lpRecip->lpszAddress, NULL, &pszAddress);
        pszAddrFree = pszAddress;

        if (lpRecip->lpszName && *lpRecip->lpszName)
            pszName = lpRecip->lpszName;
        else
            // no name, so make it the same as the address
            pszName = pszAddress;
        }
    else if (lpRecip->lpszName && *lpRecip->lpszName)
        {
        if (bValidateRecips)
            {
            // we have a name, but no address, so resolve it
            hr = HrAdrlistFromRgrecip(1, lpRecip, &pAdrList);
            if (FAILED(hr))
                goto exit;

             // Call ResolveName of IAddrBook
            if (NULL == s_lpAddrBook)
                {
                ulRet = MAPI_E_FAILURE;
                goto exit;
                }
    
            hr = s_lpAddrBook->ResolveName(NULL, NULL, NULL, pAdrList);
            if (hr)
                {
                if (hr == MAPI_E_NOT_FOUND)
                    ulRet = MAPI_E_UNKNOWN_RECIPIENT;
                else if (hr == MAPI_E_AMBIGUOUS_RECIP)
                    ulRet = MAPI_E_AMBIGUOUS_RECIPIENT;
                else
                    ulRet = MAPI_E_FAILURE;
                goto exit;
                }
            else if ((pAdrList->cEntries != 1) || !pAdrList->aEntries->cValues)
                {
                ulRet = MAPI_E_AMBIGUOUS_RECIPIENT;
                goto exit;
                }
        
            for (ulPropCount = 0; ulPropCount < pAdrList->aEntries->cValues; ulPropCount++)
                {
                switch (pAdrList->aEntries->rgPropVals[ulPropCount].ulPropTag)
                    {
                    case PR_EMAIL_ADDRESS:
                        pszAddress = pAdrList->aEntries->rgPropVals[ulPropCount].Value.lpszA;
                        break;

                    case PR_DISPLAY_NAME:
                        pszName = pAdrList->aEntries->rgPropVals[ulPropCount].Value.lpszA;
                        break;

                    default:
                        break;
                    }
                }
            }
        else
            pszName = lpRecip->lpszName;
        }
    else
        {
        return MAPI_E_INVALID_RECIPS;
        }

    hr = pAddrTable->Append(MapiRecipToMimeOle(lpRecip->ulRecipClass), 
                            IET_DECODED, 
                            pszName, 
                            pszAddress,    
                            NULL);
    if (SUCCEEDED(hr))
        ulRet = SUCCESS_SUCCESS;

exit:
    if (pszNameFree)
        MemFree(pszNameFree);
    if (pszAddrFree)
        MemFree(pszAddrFree);
    if (pAdrList)
        FreePadrlist(pAdrList);
    return ulRet;
}

///////////////////////////////////////////////////////////////////////////////////
//  Given a MapiMessage structure, this function creates a IMimeMessage object and
//  fills it with the appropriate structure members
//
//  Arguments:
//      pMsg            out      IMimeMessage pointer
//      ppStream        out      Stream pointer
//      lpMessage       in       Message structure
//      nc              in/out   NCINFO structure
//
//  Result
//      BOOL - TRUE if successful FALSE if failed
////////////////////////////////////////////////////////////////////////////////////

ULONG HrFillMessage(LPMIMEMESSAGE *pMsg, lpMapiMessage lpMessage, BOOL *pfWebPage, BOOL bValidateRecips, BOOL fOriginator)
{
    BOOL                    bRet = FALSE;

    LPSTREAM                pStream = NULL;
    LPMIMEADDRESSTABLE      pAddrTable = NULL;
    IImnAccount            *pAccount = NULL;
    HRESULT                 hr;
    LPSTR                   pszAddress;
    ULONG                   ulRet = MAPI_E_FAILURE;

    if (pfWebPage)
        *pfWebPage = FALSE;

     // create an empty message
    hr = HrCreateMessage(pMsg);
    if (FAILED(hr))
        goto error;

     // set the subject on the message
    if (lpMessage->lpszSubject)
        {
        hr = MimeOleSetBodyPropA(*pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, lpMessage->lpszSubject);
        if (FAILED(hr))
            goto error;
        }

    // set the body on the message
    if (lpMessage->lpszNoteText && *(lpMessage->lpszNoteText))
        {
        hr = MimeOleCreateVirtualStream(&pStream);
        if (FAILED(hr))
            goto error;

        hr = pStream->Write(lpMessage->lpszNoteText, lstrlen(lpMessage->lpszNoteText), NULL);
        if (FAILED(hr))
            goto error;

        hr = (*pMsg)->SetTextBody(TXT_PLAIN, IET_DECODED, NULL, pStream, NULL);
        if (FAILED(hr))
            goto error;
        }

    // ignore lpMessage->lpszMessageType

    // ignore lpMessage->lpszDateReceived

    // ignore lpMessage->lpszConversationID

    // ignore lpMessage->flFlags

    // ignore lpMessage->lpOriginator

    // set the recipients on the message
    if (lpMessage->nRecipCount || fOriginator)
        {
        ULONG ulRecipRet;

        hr = (*pMsg)->GetAddressTable(&pAddrTable);
        if (FAILED(hr))
            goto error;

        for (ULONG i = 0; i < lpMessage->nRecipCount; i++)
            {
            ulRecipRet = AddMapiRecip(pAddrTable, &lpMessage->lpRecips[i], bValidateRecips);
            if (ulRecipRet != SUCCESS_SUCCESS)
                {
                ulRet = ulRecipRet;
                goto error;
                }
            }
        }

    // set the attachments on the message
    if (lpMessage->nFileCount)
        {
        // special case: no body & one .HTM file - inline the HTML
        if ((!lpMessage->lpszNoteText || !*(lpMessage->lpszNoteText)) &&
            lpMessage->nFileCount == 1 &&
            !(lpMessage->lpFiles->flFlags & MAPI_OLE) &&
            !(lpMessage->lpFiles->flFlags & MAPI_OLE_STATIC) &&
            FIsHTMLFile(lpMessage->lpFiles->lpszPathName))
            {
#if 0
            DWORD dwByteOrder;
            DWORD cbRead;
#endif

            Assert(NULL == pStream);
            hr = CreateStreamOnHFile(lpMessage->lpFiles->lpszPathName,
                                     GENERIC_READ,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL,
                                     &pStream);
            if (FAILED(hr))
                goto error;

#if 0
            // SBAILEY: Raid-75400 - Try to detect the byte order mark in the html....
            if (SUCCEEDED(pStream->Read(&dwByteOrder, sizeof(DWORD), &cbRead)) && cbRead == sizeof(DWORD))
            {
                // Byte Order
                if (dwByteOrder == 0xfffe)
                {
                    // Create a new stream
                    IStream *pStmTemp=NULL;

                    // Create it
                    if (SUCCEEDED(MimeOleCreateVirtualStream(&pStmTemp)))
                    {
                        // Copy pStream into pStmTemp
                        if (SUCCEEDED(HrCopyStream(pStream, pStmTemp, NULL)))
                        {
                            // Release pStream
                            pStream->Release();

                            // Assume pStmTemp
                            pStream = pStmTemp;

                            // Don't Release pStmTemp
                            pStmTemp = NULL;

                            // Should already be unicode
                            Assert(1200 == lpMessage->lpFiles->ulReserved);

                            // Make sure ulReserved is set to 1200
                            lpMessage->lpFiles->ulReserved = 1200;
                        }
                    }

                    // Cleanup
                    SafeRelease(pStmTemp);
                }
            }

            // Rewind
            HrRewindStream(pStream);
#endif

            // intl hack. If the shell is calling us, then lpFiles->ulReserved contains the codepage of
            // the webpage they're attaching. All other mapi clients should call us with 0 as this param.
            // if ulReserved is a valid CP, we'll convert to a HCHARSET and use that for the message.

            if (lpMessage->lpFiles->ulReserved)
                HrSetMsgCodePage((*pMsg), lpMessage->lpFiles->ulReserved);

            hr = (*pMsg)->SetTextBody(TXT_HTML, (1200 == lpMessage->lpFiles->ulReserved ? IET_UNICODE : IET_INETCSET), NULL, pStream, NULL);
            if (FAILED(hr))
                goto error;

            // we're sending this as a web page
            if (pfWebPage)
                *pfWebPage = TRUE;
            }
        else
            {
            lpMapiFileDesc pFile;
            LPSTREAM       pStreamFile;
            LPTSTR         pszFileName;

            for (ULONG i = 0; i < lpMessage->nFileCount; i++)
                {
                pFile = &lpMessage->lpFiles[i];

                if (pFile->lpszPathName && *(pFile->lpszPathName))
                    {
                    hr = CreateStreamOnHFile(pFile->lpszPathName,
                                             GENERIC_READ,
                                             FILE_SHARE_READ,
                                             NULL,
                                             OPEN_EXISTING,
                                             FILE_ATTRIBUTE_NORMAL,
                                             NULL,
                                             &pStreamFile);
                    if (FAILED(hr))
                        goto error;

                    if (pFile->lpszFileName && *pFile->lpszFileName)
                        pszFileName = pFile->lpszFileName;
                    else
                        pszFileName = pFile->lpszPathName;

                    hr = (*pMsg)->AttachFile(pszFileName, pStreamFile, NULL);

                    pStreamFile->Release();

                    if (FAILED(hr))
                        goto error;
                    }
                }
            }
        }

    if (fOriginator)
        {
        TCHAR szDisplayName[CCHMAX_DISPLAY_NAME];
        TCHAR szEmailAddress[CCHMAX_EMAIL_ADDRESS];
        TCHAR szAccountName[CCHMAX_DISPLAY_NAME];

        // Get the default account
        if (FAILED(hr = g_pAcctMan->GetDefaultAccount(ACCT_MAIL, &pAccount)))
            goto error;

        // Get Originator Display Name
        if (FAILED(hr = pAccount->GetPropSz(AP_SMTP_DISPLAY_NAME, szDisplayName, ARRAYSIZE(szDisplayName))))
            goto error;

        // Get Originator Email Name
        if (FAILED(hr = pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmailAddress, ARRAYSIZE(szEmailAddress))))
            goto error;

        // Get the account Name
        if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccountName, ARRAYSIZE(szAccountName))))
            goto error;   
            
        // Append Sender
        if (FAILED(hr = pAddrTable->Append(IAT_FROM, IET_DECODED, szDisplayName, szEmailAddress, NULL)))
            goto error;
 
        if (FAILED(hr = HrSetAccount(*pMsg, szAccountName)))
            goto error;
        }

    ulRet = SUCCESS_SUCCESS;

    // If you're not a web page (whose charset can be sniffed), set the default charset...
    if((NULL == pfWebPage) || (!(*pfWebPage)))
    {
        if (g_hDefaultCharsetForMail==NULL) 
            ReadSendMailDefaultCharset();

        (*pMsg)->SetCharset(g_hDefaultCharsetForMail, CSET_APPLY_ALL);
    }

error:
    SafeRelease(pStream);
    SafeRelease(pAddrTable);
    SafeRelease(pAccount);

    return ulRet;
}

HRESULT AddRecipient(lpMapiMessage pMessage, lpMapiRecipDesc pRecip, ADDRESSPROPS *pAddress, ULONG ulRecipType)
{
    HRESULT     hr;
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID = NULL;
    LPSTR       pszAddrType = NULL;
    LPSTR       pszAddress = NULL;

    if (FAILED(hr = SMAPIAllocateMore(lstrlen(pAddress->pszFriendly) + 1, pMessage, (LPVOID*)&(pRecip->lpszName))))
        goto exit;

    lstrcpy(pRecip->lpszName, pAddress->pszFriendly);

    if (FAILED(hr = SMAPIAllocateMore(lstrlen(pAddress->pszEmail) + 1, pMessage, (LPVOID*)&(pRecip->lpszAddress))))
        goto exit;

    lstrcpy(pRecip->lpszAddress, pAddress->pszEmail);

    pRecip->ulReserved = 0;
    pRecip->ulRecipClass = ulRecipType;

    ParseEmailAddress(pRecip->lpszAddress, &pszAddrType, &pszAddress);

    if (NULL == s_lpAddrBook)
        {
        hr = E_FAIL;
        goto exit;
        }
    
    if (FAILED(hr = s_lpAddrBook->CreateOneOff(pRecip->lpszName, pszAddrType, pszAddress, 0, &cbEntryID, &lpEntryID)))
        goto exit;

    if (FAILED(hr = SMAPIAllocateMore(cbEntryID, pMessage, (LPVOID*)&(pRecip->lpEntryID))))
        goto exit;

    pRecip->ulEIDSize = cbEntryID;
    CopyMemory(pRecip->lpEntryID, lpEntryID, cbEntryID);

exit:
    if ((lpEntryID) && (NULL != s_lpWabObject))
        s_lpWabObject->FreeBuffer(lpEntryID);
    if (pszAddrType)
        MemFree(pszAddrType);
    if (pszAddress)
        MemFree(pszAddress);
    return hr;
}

HRESULT AddRecipientType(lpMapiMessage pMessage, LPMIMEADDRESSTABLE pAddrTable, DWORD dwAdrType, ULONG ulRecipType)
{
    IMimeEnumAddressTypes  *pEnum;
    ADDRESSPROPS            rAddress;
    HRESULT                 hr = S_OK;

    if (FAILED(hr = pAddrTable->EnumTypes(dwAdrType, IAP_FRIENDLY|IAP_EMAIL, &pEnum)))
        return MAPI_E_FAILURE;

    while (S_OK == pEnum->Next(1, &rAddress, NULL))
        {
        if (SUCCEEDED(hr = AddRecipient(pMessage, &pMessage->lpRecips[pMessage->nRecipCount], &rAddress, ulRecipType)))
            pMessage->nRecipCount++;
        g_pMoleAlloc->FreeAddressProps(&rAddress);
        }

    pEnum->Release();
    return hr;
}


HRESULT AddOriginator(lpMapiMessage pMessage, LPMIMEADDRESSTABLE pAddrTable)
{
    IMimeEnumAddressTypes  *pEnum;
    ADDRESSPROPS            rAddress;
    HRESULT                 hr = S_OK;

    if (FAILED(hr = pAddrTable->EnumTypes(IAT_FROM, IAP_FRIENDLY|IAP_EMAIL, &pEnum)))
        return MAPI_E_FAILURE;

    if (S_OK == pEnum->Next(1, &rAddress, NULL))
        {
        hr = AddRecipient(pMessage, pMessage->lpOriginator, &rAddress, MAPI_ORIG);
        g_pMoleAlloc->FreeAddressProps(&rAddress);
        }
    else
        {
        if (SUCCEEDED(hr = SMAPIAllocateMore(1, pMessage, (LPVOID*)&(pMessage->lpOriginator->lpszName))))
            {
            pMessage->lpOriginator->lpszAddress = pMessage->lpOriginator->lpszName;
            *pMessage->lpOriginator->lpszName = 0;
            }
        }

    pEnum->Release();
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////
// Called by MAPIReadMail to Read an existing message in the store
// and copy in a MapiMessage structure  
// 
//  Arguments:
//      pFolder          in      pointer to IMessageFolder          
//      lpszMessageID    in      Message ID   
//      lppMessage       out     pointer to lpMapiMessage structure/      
//
//  Result
//      BOOL - TRUE if successful FALSE if failed
////////////////////////////////////////////////////////////////////////////////////

BOOL HrReadMail(IMessageFolder *pFolder, LPSTR lpszMessageID, lpMapiMessage FAR *lppMessage, FLAGS flFlags)
{
    ULONG                   nRecipCount=0, ulCount=0, nBody=0;
    HRESULT                 hr;
    MESSAGEID               dwMsgID;
    MESSAGEINFO             MsgInfo={0};
    IStream                 *pStream = NULL;
    IStream                 *pStreamHTML = NULL;
    IMimeMessage            *pMsg = NULL;
    LPMIMEADDRESSTABLE      pAddrTable = NULL;
    LPSTR                   pszTemp = 0;
    lpMapiMessage           rgMessage;
    ULONG                   ulSize,ulRead;
    PROPVARIANT             rVariant;
    FILETIME                localfiletime;
    SYSTEMTIME              systemtime;
    ULONG                   cAttach=0;
    LPHBODY                 rghAttach = 0;
    lpMapiFileDesc          rgFiles = NULL;
    BOOL                    bRet=FALSE;

    dwMsgID = (MESSAGEID)((UINT_PTR)StrToUint(lpszMessageID));

    MsgInfo.idMessage = dwMsgID;

    if (FAILED(pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &MsgInfo, NULL)))
        goto exit;

    if (FAILED(hr = pFolder->OpenMessage(dwMsgID, OPEN_MESSAGE_SECURE, &pMsg, NOSTORECALLBACK)))
        goto exit;

    // Allocate memory for rgMessage
    if (FAILED(hr = SMAPIAllocateBuffer(sizeof(MapiMessage), (LPVOID*)&rgMessage)))
        goto exit;
    ZeroMemory(rgMessage, sizeof(MapiMessage));

    // Get the subject
    if (SUCCEEDED(hr = MimeOleGetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &pszTemp)))
        {
        if (FAILED(hr = SMAPIAllocateMore(lstrlen(pszTemp) + 1, rgMessage, (LPVOID*)&(rgMessage->lpszSubject))))
            goto exit;
        lstrcpy(rgMessage->lpszSubject, pszTemp);
        SafeMimeOleFree(pszTemp);
        }

    // Get the body text
    if (!(flFlags & MAPI_ENVELOPE_ONLY))
        {
        if (FAILED(hr = pMsg->GetTextBody(TXT_PLAIN, IET_DECODED, &pStream, NULL)))
            {
            if (SUCCEEDED(hr = pMsg->GetTextBody(TXT_HTML, IET_INETCSET, &pStreamHTML, NULL)))
                {
                if (FAILED(hr = HrConvertHTMLToPlainText(pStreamHTML, &pStream, CF_TEXT)))
                    goto exit;
                }
            }
        if (pStream)
            {
            if (FAILED(hr = HrGetStreamSize(pStream, &ulSize)))
                goto exit;
            if (FAILED(hr = HrRewindStream(pStream)))
                goto exit;

            if (ulSize>0)
                {
                if (FAILED(hr = SMAPIAllocateMore(ulSize + 1, rgMessage, (LPVOID*)&(rgMessage->lpszNoteText))))
                    goto exit;

                if (FAILED(hr = pStream->Read((LPVOID)rgMessage->lpszNoteText, ulSize, &ulRead)))
                    goto exit;

                rgMessage->lpszNoteText[ulRead] = 0;
                }
            }
        }
    else
        {
        // if we don't call GetTextBody, then the GetAttachments call will consider the bodies as attachments
        if (FAILED(pMsg->GetTextBody(TXT_PLAIN, IET_DECODED, NULL, NULL)))
            pMsg->GetTextBody(TXT_HTML, IET_INETCSET, NULL, NULL);
        }

    // Set the message date / Received Time...
    rVariant.vt = VT_FILETIME;
    if (SUCCEEDED(hr = pMsg->GetProp(PIDTOSTR(PID_ATT_RECVTIME),0,&rVariant)))
        {
        if (!FileTimeToLocalFileTime(&rVariant.filetime, &localfiletime))
            goto exit;

        if (!FileTimeToSystemTime(&localfiletime, &systemtime))
            goto exit;

        if (FAILED(hr = SMAPIAllocateMore(20, rgMessage, (LPVOID*)&(rgMessage->lpszDateReceived))))
            goto exit;

        wsprintf(rgMessage->lpszDateReceived,"%04.4d/%02.2d/%02.2d %02.2d:%02.2d", systemtime.wYear, systemtime.wMonth, systemtime.wDay, systemtime.wHour, systemtime.wMinute);
        }

    // Set the flags
    if (ISFLAGSET(MsgInfo.dwFlags, ARF_READ))
        rgMessage->flFlags = 0;
    else
        rgMessage->flFlags = MAPI_UNREAD;

    // Get Address Table

    CHECKHR(hr = pMsg->GetAddressTable(&pAddrTable));

    if (FAILED(hr = SMAPIAllocateMore(sizeof(MapiRecipDesc), rgMessage, (LPVOID*)&(rgMessage->lpOriginator))))
        goto exit;
    ZeroMemory(rgMessage->lpOriginator, sizeof(MapiRecipDesc));

    if (FAILED(AddOriginator(rgMessage, pAddrTable)))
        goto exit;

    // Allocate space for the recipients    

    if (FAILED(pAddrTable->CountTypes(IAT_RECIPS, &nRecipCount)))
        goto exit;

    if (nRecipCount)
        {
        if (FAILED(hr = SMAPIAllocateMore(nRecipCount * sizeof(MapiRecipDesc), rgMessage, (LPVOID*)&(rgMessage->lpRecips))))
            goto exit;
        ZeroMemory(rgMessage->lpRecips, nRecipCount * sizeof(MapiRecipDesc));

        // Add the To
        if (FAILED(AddRecipientType(rgMessage, pAddrTable, IAT_TO, MAPI_TO)))
            goto exit;

        // Add the Cc
        if (FAILED(AddRecipientType(rgMessage, pAddrTable, IAT_CC, MAPI_CC)))
            goto exit;

        // Add the Bcc
        if (FAILED(AddRecipientType(rgMessage, pAddrTable, IAT_BCC, MAPI_BCC)))
            goto exit;
        }

    // Fill the lpFiles structure
    if (FAILED(hr = pMsg->GetAttachments(&cAttach, &rghAttach)))
        goto exit;

    if (!(flFlags & (MAPI_SUPPRESS_ATTACH|MAPI_ENVELOPE_ONLY)))
    {
        if (flFlags & MAPI_BODY_AS_FILE)
            nBody = 1;

        if (cAttach + nBody)
        {
            if (FAILED(hr = SMAPIAllocateMore((cAttach + nBody) * sizeof(MapiFileDesc), rgMessage, (LPVOID*)&rgFiles)))
                goto exit;
        }

        // Check if MAPI_BODY_AS_FILE is set in flFlags
        if (flFlags & MAPI_BODY_AS_FILE)
        {
            TCHAR lpszPath[MAX_PATH];
        
            // Create a temporary file
            if (!FBuildTempPath ("msoenote.txt", lpszPath, MAX_PATH, FALSE))
                goto exit;
    
            if FAILED(hr = WriteStreamToFile(pStream, lpszPath, CREATE_ALWAYS, GENERIC_WRITE))
                goto exit;   

            // Reset the body back to NULL

            if (rgMessage->lpszNoteText)
                rgMessage->lpszNoteText[0] = '\0';
                
            // Make this file as the first attachment

            if (FAILED(hr = SMAPIAllocateMore(lstrlen(lpszPath) + 1, rgMessage, (LPVOID*)&(rgFiles[0].lpszFileName))))
                goto exit;
            if (FAILED(hr = SMAPIAllocateMore(lstrlen(lpszPath) + 1, rgMessage, (LPVOID*)&(rgFiles[0].lpszPathName))))
                goto exit;

            lstrcpy(rgFiles[0].lpszPathName, lpszPath);
            lstrcpy(rgFiles[0].lpszFileName, lpszPath);
            rgFiles[0].ulReserved = 0;
            rgFiles[0].flFlags = 0;
            rgFiles[0].nPosition = 0;
            rgFiles[0].lpFileType = NULL;    
        }

        for (ulCount = 0; ulCount < cAttach; ulCount++)
        {
            LPMIMEBODY     pBody=0;
            TCHAR          lpszPath[MAX_PATH];
            LPTSTR         lpszFileName;
                        
            // The file doesn't contain anything. Fill the file
            // from the stream

            if (FAILED(hr = MimeOleGetBodyPropA(pMsg, rghAttach[ulCount], PIDTOSTR(PID_ATT_GENFNAME), NOFLAGS, &lpszFileName)))
                goto exit;

            if (!FBuildTempPath (lpszFileName, lpszPath, MAX_PATH, FALSE))
                goto exit;

            SafeMimeOleFree(lpszFileName);

            hr=pMsg->BindToObject(rghAttach[ulCount], IID_IMimeBody, (LPVOID *)&pBody);
            if (FAILED(hr))
                goto exit;

            hr=pBody->SaveToFile(IET_INETCSET, lpszPath);
            if (FAILED(hr))
                goto exit;

            if (FAILED(hr = SMAPIAllocateMore(lstrlen(lpszPath) + 1, rgMessage, (LPVOID*)&rgFiles[ulCount+nBody].lpszPathName)))
                goto exit;
            if (FAILED(hr = SMAPIAllocateMore(lstrlen(lpszPath) + 1, rgMessage, (LPVOID*)&rgFiles[ulCount+nBody].lpszFileName)))
                goto exit;

            lstrcpy(rgFiles[ulCount+nBody].lpszPathName, lpszPath);
            lstrcpy(rgFiles[ulCount+nBody].lpszFileName, lpszPath);
            rgFiles[ulCount+nBody].ulReserved = 0;
            rgFiles[ulCount+nBody].flFlags = 0;
            rgFiles[ulCount+nBody].nPosition = 0;
            rgFiles[ulCount+nBody].lpFileType = NULL;

            ReleaseObj(pBody);           
        }
    }
    else
    {   // else condition added in response to bug# 2716 (v-snatar)
        if ((flFlags & MAPI_SUPPRESS_ATTACH) && !(flFlags & MAPI_ENVELOPE_ONLY))
        {
            if (cAttach)
            {
                // Allocate memory for rgFiles
                if (FAILED(hr = SMAPIAllocateMore(cAttach * sizeof(MapiFileDesc), rgMessage, (LPVOID*)&rgFiles)))
                    goto exit;

                // This is important as we don't fill any other structure
                // member apart from lpszFileName

                ZeroMemory((LPVOID)rgFiles,cAttach * sizeof(MapiFileDesc));

                for (ulCount = 0; ulCount < cAttach; ulCount++)
                {
                    LPTSTR lpszFileName;

                    if (FAILED(hr = MimeOleGetBodyPropA(pMsg, rghAttach[ulCount], PIDTOSTR(PID_ATT_GENFNAME), NOFLAGS, &lpszFileName)))
                        goto exit;

                    // Allocate memory for the filename
                    if (FAILED(hr = SMAPIAllocateMore(lstrlen(lpszFileName)+1, rgMessage, (LPVOID*)&rgFiles[ulCount].lpszFileName)))
                        goto exit;

                    lstrcpy(rgFiles[ulCount].lpszFileName, lpszFileName);

                    SafeMimeOleFree(lpszFileName);
                }        
            }
        }
    }

    // Set other parameters of MapiMessage
    rgMessage->ulReserved = 0;
    rgMessage->lpszMessageType = NULL;
    rgMessage->lpszConversationID = NULL;

    rgMessage->lpFiles = rgFiles;
    rgMessage->nFileCount = rgFiles ? cAttach + nBody : 0;

    bRet = TRUE;

    *lppMessage = rgMessage;

    // Mark the message as Read
    
    if (!(flFlags & MAPI_PEEK))
    {
        MESSAGEIDLIST List;
        ADJUSTFLAGS Flags;

        List.cMsgs = 1;
        List.prgidMsg = &MsgInfo.idMessage;

        Flags.dwAdd = ARF_READ;
        Flags.dwRemove = 0;

        pFolder->SetMessageFlags(&List, &Flags, NULL, NOSTORECALLBACK);
    }
          
exit:
    SafeRelease(pStreamHTML);
    if (pFolder)
        pFolder->FreeRecord(&MsgInfo);
    SafeMimeOleFree(rghAttach);

    if (FAILED(hr))
        SafeRelease((pMsg));

    if (pMsg)
        pMsg->Release();

    if (pAddrTable)
        pAddrTable->Release();

    return bRet;
}


///////////////////////////////////////////////////////////////////////////////////
// This function is used to check if the parameters in the MapiMessage structure
// are sufficient to Send a mail using the structure details.
//
//  Parameters:
//      lpMessage       in     pointer to MapiMessage structure/      
//
//  Result
//      BOOL - 0 if successful or appropriate error message
///////////////////////////////////////////////////////////////////////////////////

ULONG HrValidateMessage(lpMapiMessage lpMessage)
{
    ULONG           ulCount=0;

    if (lpMessage->lpszSubject && IsBadStringPtr(lpMessage->lpszSubject, (UINT)0xFFFF))
        return MAPI_E_FAILURE;

    if (lpMessage->lpszNoteText && IsBadStringPtr(lpMessage->lpszNoteText, (UINT)0xFFFF))
        return MAPI_E_FAILURE;
  
    if (lpMessage->nFileCount > 0)
    {
        for (ulCount=0; ulCount<lpMessage->nFileCount; ulCount++)
        {
            if (!lpMessage->lpFiles[ulCount].lpszPathName)
                return MAPI_E_FAILURE;
        }
    }

    return SUCCESS_SUCCESS;
}



BOOL HrSMAPISend(HWND hWnd, IMimeMessage *pMsg)
{
    BOOL                    bRet = FALSE;
    HRESULT                 hr;
    ISpoolerEngine          *pSpooler = NULL;
    BOOL                    fSendImmediate = FALSE;

    if (!g_pSpooler)
        {
        if (FAILED(hr = CreateThreadedSpooler(NULL, &pSpooler, TRUE)))
            goto error;
        g_pSpooler = pSpooler;
        }

    fSendImmediate = DwGetOption(OPT_SENDIMMEDIATE);
    
    if (FAILED(hr = HrSendMailToOutBox(hWnd, pMsg, fSendImmediate, TRUE)))
        goto error;

    if (pSpooler)
        {
        CloseThreadedSpooler(pSpooler);
        pSpooler = NULL;
        g_pSpooler = NULL;
        }
       
    bRet = TRUE;

error:
    
    if (pSpooler)
        pSpooler->Release();

    return bRet;
}


HRESULT HrFromIDToNameAndAddress(LPTSTR *ppszLocalName, LPTSTR *ppszLocalAddress, ULONG cbEID, LPENTRYID lpEID)
{
    ULONG           ulObjType = 0, ulcValues;
    IMailUser       *lpMailUser = NULL;
    HRESULT         hr = NOERROR;
    SizedSPropTagArray(2, ptaEid) = { 2, {PR_DISPLAY_NAME, PR_EMAIL_ADDRESS} };
    SPropValue      *spValue = NULL;

    // Validate the parameters - Begin

    if (0 == cbEID || NULL == lpEID || ppszLocalName == NULL || ppszLocalAddress == NULL)
        return E_INVALIDARG;
    
    *ppszLocalName = NULL;
    *ppszLocalAddress = NULL;

    // Validate the parameters - End
   
    if (NULL == s_lpAddrBook)
        {
        hr = MAPI_E_FAILURE;
        goto error;
        }
    
    if FAILED(hr = s_lpAddrBook->OpenEntry(cbEID, (LPENTRYID)lpEID, NULL, 0, &ulObjType, (LPUNKNOWN *)&lpMailUser))
        goto error;

    if FAILED(hr = lpMailUser->GetProps((LPSPropTagArray)&ptaEid, NULL, &ulcValues, &spValue))
        goto error;

    if (ulcValues != 2)
        {
        hr = MAPI_E_FAILURE;
        goto error;
        }

    if (spValue[0].ulPropTag == PR_DISPLAY_NAME)
        {
        if (!MemAlloc((LPVOID*)ppszLocalName, lstrlen(spValue[0].Value.lpszA) + 1))
            goto error;
        lstrcpy(*ppszLocalName, spValue[0].Value.lpszA);
        }

    if (spValue[1].ulPropTag == PR_EMAIL_ADDRESS)
        {
        if (!MemAlloc((LPVOID*)ppszLocalAddress, lstrlen(spValue[1].Value.lpszA) + 1))
            goto error;
        lstrcpy(*ppszLocalAddress, spValue[1].Value.lpszA);
        }

    hr = NOERROR;
 
error:
    ReleaseObj(lpMailUser);
    
    if ((spValue) && (NULL != s_lpWabObject))
        s_lpWabObject->FreeBuffer(spValue);
        
    return hr;
}
  
  

//  Fix for Bug #62129 (v-snatar)
HRESULT HrSendAndRecv()
{
    HRESULT             hr=E_FAIL;
    ISpoolerEngine      *pSpooler = NULL;

    if (!g_pSpooler)
    {
        if (FAILED(hr = CreateThreadedSpooler(NULL, &pSpooler, TRUE)))
            goto error;
        g_pSpooler = pSpooler;
    }
    
   
    g_pSpooler->StartDelivery(NULL, NULL, FOLDERID_INVALID, DELIVER_MAIL_RECV | DELIVER_NOUI );

    WaitForSingleObject(hSmapiEvent, INFINITE);    

    if (pSpooler)
    {
        CloseThreadedSpooler(pSpooler);
        pSpooler = NULL;
        g_pSpooler = NULL;
    }     
    
error:    
    if (pSpooler)
        pSpooler->Release();        

    return hr;
}

/*
    This code was taken from OLK2000's RTM source code

    Debug code was removed, the allocator was switched over to g_pMalloc,
    the name was changed from IsServiceAnExe, and the static s_isState was
    added.
*/
BOOL WINAPI IsProcessInteractive( VOID )
{
    static INTERACTIVESTATE s_isState = IS_UNINIT;
    
    HANDLE hProcessToken = NULL;
    HANDLE hThreadToken = NULL;
    DWORD groupLength = 50;
    DWORD dw;

    PTOKEN_GROUPS groupInfo = NULL;

    SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;
    PSID InteractiveSid = NULL;
    PSID ServiceSid = NULL;
    DWORD i;
    BOOL fServiceSID = FALSE;
    BOOL fInteractiveSID = FALSE;

    // Start with assumption that process is a Service, not an EXE.
    // This is the conservative assumption. If there's an error, we
    // have to return an answer based on incomplete information. The
    // consequences are less grave if we assume we're in a service:
    // an interactive app might fail instead of putting up UI, but if
    // a service mistakenly tries to put up UI it will hang.
    BOOL fExe = FALSE;

    // Bail out early if we have already been here
    if (s_isState != IS_UNINIT)
    {
        return (IS_INTERACTIVE == s_isState);
    }

    //  If we're not running on NT, the high bit of the version is set.
    //  In this case, it's always an EXE.
    DWORD dwVersion = GetVersion();
    if (dwVersion >= 0x80000000)
    {
        fExe = TRUE;
        goto ret;
    }

    // The information we need is on the process token.
    // If we're impersonating, we probably won't be able to open the process token.
    // Revert now; we'll re-impersonate when we're done.
    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hThreadToken))
    {
        RevertToSelf();
    }
    else
    {
        dw = GetLastError();
        if (dw != ERROR_NO_TOKEN)
        {
            goto ret;
        }
    }

    // Now open the process token.
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
    {
        goto ret;
    }

    groupInfo = (PTOKEN_GROUPS)g_pMalloc->Alloc(groupLength);
    if (groupInfo == NULL)
        goto ret;

    if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
        groupLength, &groupLength))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            goto ret;
        }

        g_pMalloc->Free(groupInfo);
        groupInfo = NULL;
    
        groupInfo = (PTOKEN_GROUPS)g_pMalloc->Alloc(groupLength);
    
        if (groupInfo == NULL)
            goto ret;
    
        if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
            groupLength, &groupLength))
        {
            goto ret;
        }
    }

    //
    //  We now know the groups associated with this token.  We want to look to see if
    //  the interactive group is active in the token, and if so, we know that
    //  this is an interactive process.
    //
    //  We also look for the "service" SID, and if it's present, we know we're a service.
    //
    //  The service SID will be present iff the service is running in a
    //  user account (and was invoked by the service controller).
    //


    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_INTERACTIVE_RID, 0, 0,
        0, 0, 0, 0, 0, &InteractiveSid))
    {
        goto ret;
    }

    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID, 0, 0, 0,
        0, 0, 0, 0, &ServiceSid))
    {
        goto ret;
    }

    for (i = 0; i < groupInfo->GroupCount ; i += 1)
    {
        SID_AND_ATTRIBUTES sanda = groupInfo->Groups[i];
        PSID Sid = sanda.Sid;
    
        //
        //  Check to see if the group we're looking at is one of
        //  the 2 groups we're interested in.
        //  We should never see both groups.
        //
    
        if (EqualSid(Sid, InteractiveSid))
        {
            //
            //  This process has the Interactive SID in its
            //  token.  This means that the process is running as
            //  an EXE.
            //
            fInteractiveSID = TRUE;
            break;
        }
        else if (EqualSid(Sid, ServiceSid))
        {
            //
            //  This process has the Service SID in its
            //  token.  This means that the process is running as
            //  a service running in a user account.
            //
            fServiceSID = TRUE;
            break;
        }
    }

    /////// Truth table /////// 
    //
    //  1. fServiceSID && !fInteractiveSID
    //  This process has the Service SID in its token.
    //  This means that the process is running as a service running in
    //  a user account.
    //
    //  2. !fServiceSID && fInteractiveSID
    //  This process has the Interactive SID in its token.
    //  This means that the process is running as an EXE.
    //
    //  3. !fServiceSID && !fInteractiveSID
    //  Neither Interactive or Service was present in the current users token,
    //  This implies that the process is running as a service, most likely
    //  running as LocalSystem.
    //
    //  4. fServiceSID && fInteractiveSID
    //  This shouldn't happen.
    //
    if (fServiceSID)
    {
        if (fInteractiveSID)
        {
            AssertSz(FALSE, "IsServiceAnExe: fServiceSID && fInteractiveSID - wha?");
        }
        fExe = FALSE;
    }
    else if (fInteractiveSID)
    {
        fExe = TRUE;
    }
    else // !fServiceSID && !fInteractiveSID
    {
        fExe = FALSE;
    }

ret:

    if (InteractiveSid)
        FreeSid(InteractiveSid);

    if (ServiceSid)
        FreeSid(ServiceSid);

    if (groupInfo)
        g_pMalloc->Free(groupInfo);

    if (hThreadToken)
    {
        if (!ImpersonateLoggedOnUser(hThreadToken))
        {
            AssertSz(FALSE, "ImpersonateLoggedOnUser failed!");
        }
        CloseHandle(hThreadToken);
    }

    if (hProcessToken)
        CloseHandle(hProcessToken);

    // Avoid the overhead for future calls
    s_isState = (fExe) ? IS_INTERACTIVE : IS_NOTINTERACTIVE;
    
    return(fExe);
}

const static HELPMAP g_rgCtxVirus[] = 
{
    {IDC_TO_TEXT,               IDH_MAIL_VIRUS_TO},
    {IDC_SUBJECT_TEXT,          IDH_MAIL_VIRUS_SUBJECT},
    {IDOK,                      IDH_MAIL_VIRUS_SEND},
    {IDCANCEL,                  IDH_MAIL_VIRUS_DONT_SEND},
    {idcStatic1,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};

INT_PTR CALLBACK WarnSendMailDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_INITDIALOG:
        {
            lpMapiMessage lpMessage = (lpMapiMessage)lParam;

            if (lpMessage)
            {
                if (lpMessage->lpszSubject)
                    SetDlgItemText(hwnd, IDC_SUBJECT_TEXT, lpMessage->lpszSubject);

                if (lpMessage->nRecipCount)
                {
                    TCHAR *szTo = NULL;
                    int cTo = MAX_PATH;
                    int cch = 0;

                    if (MemAlloc((void**)&szTo, cTo*sizeof(TCHAR)))
                    {
                        szTo[0] = (TCHAR)0;
                        for (ULONG i = 0; i < lpMessage->nRecipCount; i++)
                        {
                            int cLen = lstrlen(lpMessage->lpRecips[i].lpszAddress); 
                            if ((cch + cLen + 1) > cTo)
                            {
                                cTo += cLen + MAX_PATH;
                                if (!MemRealloc((void **)&szTo, cTo*sizeof(TCHAR)))
                                    break;
                            }
                            if (i > 0)
                            {
                                lstrcat(szTo, ";");
                                cch++;
                            }
                            lstrcat(szTo, lpMessage->lpRecips[i].lpszAddress);
                            cch += cLen;
                        }
                        SetDlgItemText(hwnd, IDC_TO_TEXT, szTo);
                        MemFree(szTo);
                    }
                }
            }

            SetFocus(GetDlgItem(hwnd, IDOK));
            CenterDialog(hwnd);
            return(FALSE);
        }
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, msg, wParam, lParam, g_rgCtxVirus);

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    // fall through...
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return(TRUE);
            }
            break; // wm_command

    } // message switch
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\smapimem.h ===
#ifndef _SMAPIMEM_H_
#define _SMAPIMEM_H_

//  Buffer link overhead.
//  Blocks of memory obtained with MAPIAllocateMore are linked to a
//  block obtained with MAPIAllocateBuffer, so that the whole chain
//  may be freed with one call to MAPIFreeBuffer.

typedef struct _BufInternal * LPBufInternal;
typedef struct _BufInternal
{
    ULONG           ulAllocFlags;
    LPBufInternal   pLink;
} BufInternal;


//  Values for ulAllocFlags. This dword contains two kinds of
//  information:
//  =   In the high-order word, flags telling whether or not
//      the block is the head of an allocation chain, and whether
//      the block contains additional debugging information.
//  =   In the low-order word, an enum telling which heap
//      it was allocated from.

#define ALLOC_WITH_ALLOC        ((ULONG) 0x10000000)
#define ALLOC_WITH_ALLOC_MORE   ((ULONG) 0x20000000)
#define FLAGSMASK               ((ULONG) 0xFFFF0000)
#define GetFlags(_fl)           ((ULONG) (_fl) & FLAGSMASK)

//  Conversion macros

#define INT_SIZE(a) ((a) + sizeof(BufInternal))

#define LPBufExtFromLPBufInt(PBUFINT) \
    ((LPVOID)(((LPBYTE)PBUFINT) + sizeof(BufInternal)))

#define LPBufIntFromLPBufExt(PBUFEXT) \
    ((LPBufInternal)(((LPBYTE)PBUFEXT) - sizeof(BufInternal)))


#ifdef DEBUG

#define TellBadBlock(_p, _s)  \
    { DOUT("MAPIAlloc: memory block [%#08lx] %s", _p, _s); \
      AssertSz(0, "Bad memory block"); }

#define TellBadBlockInt(_p, _s)  \
    { DOUT("MAPIAlloc: memory block [%#08lx] %s", LPBufExtFromLPBufInt(_p), _s); \
      AssertSz(0, "Bad memory block"); }

BOOL FValidAllocChain(LPBufInternal lpBuf);

#else

#define TellBadBlock(_p, _s)
#define TellBadBlockInt(_p, _s)

#endif // DEBUG

SCODE SMAPIAllocateBuffer(ULONG ulSize, LPVOID * lppv);
SCODE SMAPIAllocateMore(ULONG ulSize, LPVOID lpv, LPVOID * lppv);

#endif // _SMAPIMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\tipday.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     tipday.h
//
//  PURPOSE:    Defines the CTipOfTheDay control.
//


typedef struct {
    LPTSTR pszLinkText;
    LPTSTR pszLinkAddr;
    HWND   hwndCtl;
} LINKINFO, *PLINKINFO;


#define LINKINFO_PROP   _T("Link Info")         // PLINKINFO pointer
#define WNDPROC_PROP    _T("Wndproc")
#define TIPINFO_PROP    _T("CTipOfTheDay")      // 'this' pointer
#define BUTTON_CLASS    _T("Athena Button")

class CTipOfTheDay
    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructors, Destructors, and Initialization
    CTipOfTheDay();
    ~CTipOfTheDay();
    HRESULT HrCreate(HWND hwndParent, FOLDER_TYPE ftType);
    
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    static LRESULT CALLBACK TipWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                       LPARAM lParam);

    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void OnSize(HWND hwnd, UINT state, int cx, int cy);
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem);
    void OnDestroy(HWND hwnd);
    void OnSysColorChange(HWND hwnd);
    void OnPaint(HWND hwnd);
    HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type);
    
    DWORD GetRequiredWidth(void);
    DWORD GetRequiredHeight(void);
    void FreeLinkInfo(void);
    HRESULT HrLoadTipInfo(void);
    HRESULT HrLoadLinkInfo(void);
    HRESULT HrCreateChildWindows(HWND hwnd);
    
    HWND GetHwnd(void) { return m_hwnd; }    
    
private:
    /////////////////////////////////////////////////////////////////////////
    // Private Data    
    ULONG           m_cRef;
    HWND            m_hwnd;
    HWND            m_hwndParent;
    HWND            m_hwndNext;
    FOLDER_TYPE     m_ftType;
    TCHAR           m_szTitle[CCHMAX_STRINGRES];
    TCHAR           m_szNextTip[64];
    
    // Tip string information
    LPTSTR          m_pszTip;
    DWORD           m_dwCurrentTip;

    // Link information
//    DWORD           m_cLinks;
//    PLINKINFO       m_rgLinkInfo;
    
    // Drawing info -- these get reset every WM_SYSCOLORCHANGE
    COLORREF        m_clrBack;
    COLORREF        m_clrText;
    COLORREF        m_clrLink;    
    HFONT           m_hfLink;
    TEXTMETRIC      m_tmLink;
    HFONT           m_hfTitle;
    TEXTMETRIC      m_tmTitle;
    HFONT           m_hfTip;
    HICON           m_hiTip;
    DWORD           m_cyTitleHeight;
    DWORD           m_cxTitleWidth;
    HBRUSH          m_hbrBack;
    DWORD           m_dwBorder;
    DWORD           m_cxNextWidth;
    DWORD           m_cyNextHeight;
    RECT            m_rcTip;
    };



#define IDC_TIPCONTROL                  1001
#define IDC_TIP_STATIC                  1002
#define IDC_NEXTTIP_BUTTON              1003
#define IDC_LINKBASE_BUTTON             1500



#define LINK_BUTTON_BORDER              3       // pixels
#define TIP_ICON_HEIGHT                 32
#define TIP_ICON_WIDTH                  32


/////////////////////////////////////////////////////////////////////////////
// 
// CLinkButton
//
// Creates an owner-drawn button that looks a lot like a web link.
//
class CLinkButton
    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructors, Destructors, and Initialization
    CLinkButton();
    ~CLinkButton();
    HRESULT HrCreate(HWND hwndParent, LPTSTR pszCaption, LPTSTR pszLink, 
                     UINT uID);
    HRESULT HrCreate(HWND hwndParent, LPTSTR pszCaption, UINT uID, UINT index,
                     HBITMAP hbmButton, HBITMAP hbmMask, HPALETTE hpal);

    /////////////////////////////////////////////////////////////////////////
    // Ref Counting
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    /////////////////////////////////////////////////////////////////////////
    // Moving, Sizing
    DWORD GetHeight(void)               { return m_cyHeight; }
    DWORD GetWidth(void)                { return m_cxWidth; }
    HWND  GetWindow(void)               { return m_hwnd; }

    void Move(DWORD x, DWORD y);
    void Move(POINT pt)                 { Move(pt.x, pt.y); }

    void Show(BOOL fShow);  

    /////////////////////////////////////////////////////////////////////////
    // Painting
    void OnDraw(HWND hwnd, const DRAWITEMSTRUCT *lpDrawItem);
    HBRUSH OnCtlColorBtn(HWND hwnd)     { return (m_hbrBack); }

    /////////////////////////////////////////////////////////////////////////
    // System changes
    void OnSysColorChange(void);
    void OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange);

    /////////////////////////////////////////////////////////////////////////
    // Execute
    void OnCommand(void);

private:
    /////////////////////////////////////////////////////////////////////////
    // Private Data
    ULONG           m_cRef;             // Ref Count
    HWND            m_hwnd;             // Handle of our button window
    HWND            m_hwndParent;       // Handle of our parent

    // Caption and Link strings and Command ID
    LPTSTR          m_pszCaption;
    LPTSTR          m_pszLink;
    UINT            m_uID;

    // Drawing info -- these get reset every WM_SYSCOLORCHANGE
    COLORREF        m_clrLink;    
    COLORREF        m_clrBack;
    HFONT           m_hfLink;
    TEXTMETRIC      m_tmLink;
    HBRUSH          m_hbrBack;

    DWORD           m_dwBorder;
    DWORD           m_cxWidth;
    DWORD           m_cyHeight;

    UINT            m_index;
    DWORD           m_cxImage;
    DWORD           m_cyImage;

    // GDI Resources passed to us when we are created
    HBITMAP         m_hbmButtons;
    HBITMAP         m_hbmMask;
    HPALETTE        m_hpalButtons;
    };

// #define CX_BUTTON_IMAGE   96
// #define CY_BUTTON_IMAGE   84

#define CX_BUTTON_IMAGE   110 // 104
#define CY_BUTTON_IMAGE   110 // 68


LRESULT CALLBACK ButtonSubClass(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

HRESULT HrLoadButtonBitmap(HWND hwnd, int idBmp, int idMask, HBITMAP* phBtns, 
                           HBITMAP *phMask, HPALETTE *phPalette);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\smapi16.cpp ===
//
//  SMAPI16.CPP - Simple MAPI implementation, 16bit Version
//

#include "pch.hxx"
#include <mapi.h>
#include <note.h>
#include <mimeutil.h>
#include <resource.h>
#include <ipab.h>
#include <error.h>

ASSERTDATA


#define WriteVar2File( hf, v )    _lwrite( (hf), &(v), sizeof(v) );
#define ReadVarFromFile( hf, v )  _lread( (hf), &(v), sizeof(v) );


static const char  s_cszMailMsgCmd[] = "msimn.exe /mailmsg:%s";

inline void  WriteStr2File( HFILE hFile, LPCSTR cszText )
{
   UINT  uText = ( cszText == NULL ) ? 0 : lstrlen( cszText ) + 1;
   _lwrite( hFile, &uText, sizeof( uText ) );
   if ( uText > 0 )
      _lwrite( hFile, cszText, uText );
}

inline void  WriteMRD2File( HFILE hFile, lpMapiRecipDesc lpMRD )
{
   WriteVar2File( hFile, lpMRD->ulReserved );
   WriteVar2File( hFile, lpMRD->ulRecipClass );
   WriteStr2File( hFile, lpMRD->lpszName );
   WriteStr2File( hFile, lpMRD->lpszAddress );
   WriteVar2File( hFile, lpMRD->ulEIDSize );
   _lwrite( hFile, lpMRD->lpEntryID, lpMRD->ulEIDSize );
}

inline LPSTR  ReadStrFromFile( HFILE hFile )
{
   UINT  uText;
   LPSTR  szText;

   ReadVarFromFile( hFile, uText );
   if ( uText > 0 )
   {
      szText = (LPSTR)malloc( uText );
      _lread( hFile, szText, uText );
   }
   else
      szText = NULL;

   return( szText );
}

inline lpMapiRecipDesc  ReadMRDFromFile( HFILE hFile )
{
   lpMapiRecipDesc  lpMRD = new MapiRecipDesc;

   ReadVarFromFile( hFile, lpMRD->ulReserved );
   ReadVarFromFile( hFile, lpMRD->ulRecipClass );
   lpMRD->lpszName = ReadStrFromFile( hFile );
   lpMRD->lpszAddress = ReadStrFromFile( hFile );
   ReadVarFromFile( hFile, lpMRD->ulEIDSize );
   if ( lpMRD->ulEIDSize > 0 )
   {
      lpMRD->lpEntryID = malloc( lpMRD->ulEIDSize );
      _lread( hFile, lpMRD->lpEntryID, lpMRD->ulEIDSize );
   }
   else
      lpMRD->lpEntryID = NULL;

   return( lpMRD );
}

inline lpMapiFileDesc  ReadMFDFromFile( HFILE hFile )
{
   lpMapiFileDesc  lpMFD = new MapiFileDesc;

   ReadVarFromFile( hFile, lpMFD->ulReserved );
   ReadVarFromFile( hFile, lpMFD->flFlags );
   ReadVarFromFile( hFile, lpMFD->nPosition );
   lpMFD->lpszPathName = ReadStrFromFile( hFile );
   lpMFD->lpszFileName = ReadStrFromFile( hFile );
   lpMFD->lpFileType = NULL;

   return( lpMFD );
}

#define FreeMemSafe( lp ) \
           if ( (lp) != NULL ) \
           {                   \
              free( lp );      \
              lp = NULL;       \
           }

inline void  FreeMRDSafe( lpMapiRecipDesc &lpMRD )
{
   if ( lpMRD != NULL )
   {
      FreeMemSafe( lpMRD->lpszName );
      FreeMemSafe( lpMRD->lpszAddress );
      FreeMemSafe( lpMRD->lpEntryID );
      free( lpMRD );
      lpMRD = NULL;
   }
}

inline void  FreeMFDSafe( lpMapiFileDesc &lpMFD )
{
   if ( lpMFD != NULL )
   {
      FreeMemSafe( lpMFD->lpszPathName );
      FreeMemSafe( lpMFD->lpszFileName );
      free( lpMFD );
      lpMFD = NULL;
   }
}


///////////////////////////////////////////////////////////////////////
// 
// MAPISendMail
// 
///////////////////////////////////////////////////////////////////////

EXTERN_C ULONG STDAPICALLTYPE
MAPISENDMAIL(
   LHANDLE lhSession,   // ignored
   ULONG ulUIParam,
   lpMapiMessage lpMessage,
   FLAGS flFlags,
   ULONG ulReserved
   )
{
   // validate parameters
   if ( NULL == lpMessage || IsBadReadPtr( lpMessage, sizeof( MapiMessage ) ) )
      return MAPI_E_INVALID_MESSAGE;

   // $BUGBUG - We do not support sendmail without UI yet.  This is a big
   //           hole that we need to fix.
   if (!(flFlags & MAPI_DIALOG))
      return MAPI_E_NOT_SUPPORTED;

   // Create Temporary File Storage
   //
   char  szTmpDir[_MAX_PATH], szTmpFile[_MAX_PATH];
   OFSTRUCT  of;
   HFILE  hTmp;

   if ( GetTempPath( _MAX_PATH, szTmpDir ) == 0 )
      return( MAPI_E_FAILURE );
   if ( GetTempFileName( szTmpDir, "msm", 0, szTmpFile ) == 0 )
      return( MAPI_E_FAILURE );
   hTmp = OpenFile( szTmpFile, &of, OF_CREATE | OF_WRITE );
   if ( hTmp == HFILE_ERROR )
      return( MAPI_E_FAILURE );

   // lhSession is intentionally ignored because it is impossible to support it
   WriteVar2File( hTmp, lhSession );
   WriteVar2File( hTmp, ulUIParam );
   WriteVar2File( hTmp, flFlags );
   WriteVar2File( hTmp, ulReserved );

   // Write lpMapiMessage into Temporary File
   //
   int  i;

   WriteVar2File( hTmp, lpMessage->ulReserved );
   WriteStr2File( hTmp, lpMessage->lpszSubject );
   WriteStr2File( hTmp, lpMessage->lpszNoteText );
   WriteStr2File( hTmp, lpMessage->lpszMessageType );
   WriteStr2File( hTmp, lpMessage->lpszDateReceived );
   WriteStr2File( hTmp, lpMessage->lpszConversationID );
   WriteVar2File( hTmp, lpMessage->flFlags );
   WriteVar2File( hTmp, lpMessage->lpOriginator );
   if ( lpMessage->lpOriginator != NULL )
      WriteMRD2File( hTmp, lpMessage->lpOriginator );
   WriteVar2File( hTmp, lpMessage->nRecipCount );
   for ( i = 0;  i < lpMessage->nRecipCount;  i++ )
      WriteMRD2File( hTmp, lpMessage->lpRecips+i );
   WriteVar2File( hTmp, lpMessage->nFileCount );
   for ( i = 0;  i < lpMessage->nFileCount;  i++ )
   {
      lpMapiFileDesc  lpMFD = lpMessage->lpFiles+i;
      WriteVar2File( hTmp, lpMFD->ulReserved );
      WriteVar2File( hTmp, lpMFD->flFlags );
      WriteVar2File( hTmp, lpMFD->nPosition );
      WriteStr2File( hTmp, lpMFD->lpszPathName );
      WriteStr2File( hTmp, lpMFD->lpszFileName );

      Assert( lpMFD->lpFileType == NULL );
   }
#ifdef DEBUG
   WriteStr2File( hTmp, szTmpFile );
#endif

   if ( hTmp != NULL && hTmp != HFILE_ERROR )
      _lclose( hTmp );

   // Execute MSIMN.EXE
   //
   char  szFmt[256], szCmd[256];
   LPSTR  szLastDirSep = NULL;

   if ( GetModuleFileName( g_hInst, szFmt, sizeof( szFmt ) ) == 0 )
      return( MAPI_E_FAILURE );
   for ( LPSTR szPtr = szFmt;  *szPtr != '\0';  szPtr = AnsiNext( szPtr ) )
      if ( *szPtr == '\\' )
         szLastDirSep = szPtr;
   if ( szLastDirSep == NULL )
      return( MAPI_E_FAILURE );
   lstrcpy( szLastDirSep+1, s_cszMailMsgCmd );
   wsprintf( szCmd, szFmt, szTmpFile );

   return( ( WinExec( szCmd, SW_SHOW ) < 32 ) ? MAPI_E_FAILURE : SUCCESS_SUCCESS );
}


HRESULT  HandleMailMsg( LPSTR szCmd )
{
   OFSTRUCT            of;
   HFILE               hTmp;
   ULONG               ulRet = MAPI_E_FAILURE;
   NCINFO              nci = { 0 };
   LPMIMEMESSAGE       pMsg = NULL;
   LPSTREAM            pStream = NULL;
   LPMIMEADDRESSTABLE  pAddrTable = NULL;
   HRESULT             hr;
   LPSTR               szText = NULL;
   lpMapiRecipDesc     lpMRD = NULL;
   lpMapiFileDesc      lpMFD = NULL;
   ULONG               ulTmp;
   BOOL                fBody = FALSE;

   // Open Tmp File
   //
   LPSTR  szSpace = strchr( szCmd, ' ' );
   if ( szSpace != NULL )
      *szSpace = '\0';
   hTmp = OpenFile( szCmd, &of, OF_READ );
   if ( hTmp == HFILE_ERROR )
      goto error;

   LHANDLE  lhSession;
   ULONG  ulUIParam;
   FLAGS  flFlags;
   ULONG  ulReserved;

   ReadVarFromFile( hTmp, lhSession );
   ReadVarFromFile( hTmp, ulUIParam );
   ReadVarFromFile( hTmp, flFlags );
   ReadVarFromFile( hTmp, ulReserved );

   hr = HrCreateMessage( &pMsg );
   if ( FAILED( hr ) )
      goto error;

   nci.ntNote = ntSendNote;
   nci.dwFlags = NCF_SENDIMMEDIATE | NCF_MODAL;
   nci.pMsg = pMsg;
   nci.hwndOwner = (HWND)ulUIParam;

   ReadVarFromFile( hTmp, ulTmp );

   // set the subject on the message
   szText = ReadStrFromFile( hTmp );
   if ( szText != NULL )
   {
      hr = MimeOleSetBodyPropA( pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT),
                                NOFLAGS, szText );
      if ( FAILED( hr ) )
         goto error;
      FreeMemSafe( szText );
   }

   // set the body on the message
   szText = ReadStrFromFile( hTmp );
   if ( szText != NULL )
   {
      if ( szText[0] != '\0' )
      {
         fBody = TRUE;
         hr = MimeOleCreateVirtualStream( &pStream );
         if ( FAILED( hr ) )
            goto error;
         hr = pStream->Write( szText, lstrlen( szText ), NULL );
         if ( FAILED( hr ) )
            goto error;
         hr = pMsg->SetTextBody( TXT_PLAIN, IET_DECODED, NULL, pStream, NULL );
         if ( FAILED( hr ) )
            goto error;
      }
      FreeMemSafe( szText );
   }

   // ignore lpMessage->lpszMessageType
   szText = ReadStrFromFile( hTmp );
   FreeMemSafe( szText );
   // ignore lpMessage->lpszDateReceived
   szText = ReadStrFromFile( hTmp );
   FreeMemSafe( szText );
   // ignore lpMessage->lpszConversationID
   szText = ReadStrFromFile( hTmp );
   FreeMemSafe( szText );
   // ignore lpMessage->flFlags
   ReadVarFromFile( hTmp, ulTmp );
   // ignore lpMessage->lpOriginator
   lpMRD = ReadMRDFromFile( hTmp );
   FreeMRDSafe( lpMRD );

   // set the recipients on the message
   ReadVarFromFile( hTmp, ulTmp );
   if ( ulTmp > 0 )
   {
      hr = pMsg->GetAddressTable( &pAddrTable );
      if ( FAILED( hr ) )
         goto error;
      for ( ULONG i = 0;  i < ulTmp;  i++ )
      {
         lpMRD = ReadMRDFromFile( hTmp );
         hr = pAddrTable->Append( MapiRecipToMimeOle( lpMRD->ulRecipClass ),
                                  IET_DECODED,
                                  lpMRD->lpszName, lpMRD->lpszAddress, NULL );
         if ( FAILED( hr ) )
            goto error;
         FreeMRDSafe( lpMRD );
      }
   }

   // set the attachments on the message
   ReadVarFromFile( hTmp, ulTmp );
   if ( ulTmp > 0 )
   {
      lpMFD = ReadMFDFromFile( hTmp );
      // special case: no body & one .HTM file - inline the HTML
      if ( fBody && ulTmp == 1 &&
           ( ( lpMFD->flFlags & ( MAPI_OLE | MAPI_OLE_STATIC ) ) == 0 ) &&
           FIsHTMLFile( lpMFD->lpszPathName ) )
      {
         Assert( pStream == NULL );
         hr = CreateStreamOnHFile( lpMFD->lpszPathName,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL,
                                   &pStream );
         if ( FAILED( hr ) )
            goto error;
         hr = pMsg->SetTextBody( TXT_HTML, IET_DECODED, NULL, pStream, NULL );
         if ( FAILED( hr ) )
            goto error;
         nci.ntNote = ntWebPage;
      }
      else
      {
         for ( ULONG i = 0;  i < ulTmp;  i++ )
         {
            if ( i > 0 )
            {
               FreeMFDSafe( lpMFD );
               lpMFD = ReadMFDFromFile( hTmp );
            }

            // $BUGBUG - should we error this out, or send anyway?
            if ( lpMFD->flFlags & MAPI_OLE )
               continue;
            if ( lpMFD->lpszPathName != NULL && lpMFD->lpszPathName[0] != '\0' )
            {
               hr = pMsg->AttachFile( lpMFD->lpszPathName, NULL, NULL );
               if ( FAILED( hr ) )
                  goto error;
            }
         }
         FreeMFDSafe( lpMFD );
      }
   }
#ifdef DEBUG
   {
   LPSTR  szTmpFile = ReadStrFromFile( hTmp );
   free( szTmpFile );
   }
#endif

   // this is redundant, but need to close file before opening Note window
   if ( hTmp != NULL && hTmp != HFILE_ERROR )
   {
      _lclose( hTmp );
      hTmp = NULL;
   }

   if ( Initialize_RunDLL( TRUE ) )
   {
      hr = HrCreateNote( &nci );
      if ( SUCCEEDED( hr ) )
         ulRet = SUCCESS_SUCCESS;
      Uninitialize_RunDLL();
   }

error:
   if ( hTmp != NULL && hTmp != HFILE_ERROR )
      _lclose( hTmp );
   OpenFile( szCmd, &of, OF_DELETE );

   FreeMemSafe( szText );
   FreeMRDSafe( lpMRD );
   FreeMFDSafe( lpMFD );
   if ( pMsg )
      pMsg->Release();
   if ( pAddrTable )
      pAddrTable->Release();
   if ( pStream )
      pStream->Release();

   if ( FAILED( ulRet ) )
      AthMessageBoxW( GetDesktopWindow(),
                     MAKEINTRESOURCEW( idsAthenaMail ),
                     MAKEINTRESOURCEW( idsMailRundllFailed ),
                     0,
                     MB_ICONEXCLAMATION | MB_OK );
   return( ulRet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\shell\tipday.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     TipDay.cpp
//
//  PURPOSE:    Implements the CTipOfTheDay object
//

#include "pch.hxx"
#include "strconst.h"
#include "resource.h"
#include "fldrview.h"
#include "tipday.h"
#include "hotlinks.h"


#ifdef WIN16
// At this moment, these definitions are restricted to this file only
#define GetProp     GetProp32
#define SetProp     SetProp32
#define RemoveProp  RemoveProp32

#define BS_NOTIFY   0L
#endif


CTipOfTheDay::CTipOfTheDay()
    {
    m_cRef = 1;
    m_hwnd = 0;
    m_hwndParent = 0;
    m_hwndNext = 0;
    
    m_ftType = FOLDER_TYPESMAX;
    m_szTitle[0] = 0;
    m_szNextTip[0] = 0;
    
    m_pszTip = NULL;
    m_dwCurrentTip = 0;
    
    m_clrBack = 0;
    m_clrText = RGB(255, 255, 255);
    m_clrLink = RGB(255, 255, 255);
    m_hfLink = 0;
    m_hfTitle = 0;
    m_hfTip = 0;
    m_cyTitleHeight = TIP_ICON_HEIGHT;
    m_cxTitleWidth = 0;
    m_hbrBack = 0;
    }


CTipOfTheDay::~CTipOfTheDay()
    {
    if (IsWindow(m_hwnd))
        {
        AssertSz(!IsWindow(m_hwnd), _T("CTipOfTheDay::~CTipOfTheDay() - The ")
                 _T("tip window should have already been destroyed."));
        DestroyWindow(m_hwnd); 
        }
    
    SafeMemFree(m_pszTip);
    FreeLinkInfo();
    
    if (m_hfLink)
        DeleteFont(m_hfLink);
    if (m_hfTitle)
        DeleteFont(m_hfTitle);
    if (m_hfTip)
        DeleteFont(m_hfTip);
    if (m_hbrBack)
        DeleteBrush(m_hbrBack);
    
    UnregisterClass(c_szTipOfTheDayClass, g_hLocRes /* g_hInst*/);
    UnregisterClass(BUTTON_CLASS, g_hLocRes /* g_hInst*/);
    }


ULONG CTipOfTheDay::AddRef(void)
    {
    return (++m_cRef);
    }

ULONG CTipOfTheDay::Release(void)
    {
    ULONG cRef = m_cRef--;
    
    if (m_cRef == 0)
        delete this;
    
    return (cRef);    
    }    

//
//  FUNCTION:   CTipOfTheDay::HrCreate()
//
//  PURPOSE:    Creates the TipOfTheDay control.
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the window that will be the parent of
//                        the control.
//      <in> ftType     - Type of folder this is for.
//
//  RETURN VALUE:
//      E_UNEXPECTED  - Failed to register a required window class
//      E_OUTOFMEMORY - Could not create the window
//      S_OK          - Everything succeeded.
//
HRESULT CTipOfTheDay::HrCreate(HWND hwndParent, FOLDER_TYPE ftType)
    {
#ifndef WIN16
    WNDCLASSEX wc;
#else
    WNDCLASS wc;
#endif
    
    m_hwndParent = hwndParent;
    m_ftType = ftType;
    
    // Check to see if we need to register the window class for this control
#ifndef WIN16
    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hLocRes /* g_hInst*/, c_szTipOfTheDayClass, &wc))
#else
    if ( !GetClassInfo( g_hLocRes /* g_hInst*/, c_szTipOfTheDayClass, &wc ) )
#endif
        {
        wc.style            = 0;
        wc.lpfnWndProc      = TipWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hLocRes /* g_hInst*/;
        wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground    = NULL; // CreateSolidBrush(GetSysColor(COLOR_INFOBK));
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szTipOfTheDayClass;
        wc.hIcon            = NULL;
#ifndef WIN16
        wc.hIconSm          = NULL;
        
        if (0 == RegisterClassEx(&wc))
#else
        if ( 0 == RegisterClass( &wc ) )
#endif
            {
            AssertSz(FALSE, _T("CTipOfTheDay::HrCreate() - RegiserClassEx() failed."));
            return (E_UNEXPECTED);
            }
        }
    
    // We also want to superclass the buttons so we change change the cursor
    // to the Hand people are used to from their web browser
#ifndef WIN16
    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hLocRes /* g_hInst*/, BUTTON_CLASS, &wc))    
        {
        if (GetClassInfoEx(g_hLocRes /* g_hInst*/, _T("Button"), &wc))
#else
    if ( !GetClassInfo( g_hLocRes /* g_hInst*/, BUTTON_CLASS, &wc ) )
        {
        if ( GetClassInfo( NULL, "Button", &wc ) )
#endif
            {
            wc.hCursor = LoadCursor(g_hLocRes, MAKEINTRESOURCE(idcurHand));
            wc.lpszClassName = BUTTON_CLASS;

#ifndef WIN16
            if (0 == RegisterClassEx(&wc))
#else
            wc.hInstance = g_hLocRes /* g_hInst*/;
            if ( 0 == RegisterClass( &wc ) )
#endif
                {
                AssertSz(FALSE, _T("CTipOfTheDay::HrCreate() - RegisterClassEx() failed."));
                return (E_UNEXPECTED);
                }
            }
        }
    
    // Create the tip control window
    m_hwnd = CreateWindowEx(WS_EX_CONTROLPARENT, c_szTipOfTheDayClass, 
                            _T("Tip of the Day"), WS_CHILD | WS_VISIBLE | WS_TABSTOP | WS_CLIPSIBLINGS, 
                            0, 0, 100, 100, hwndParent, (HMENU) IDC_TIPCONTROL, 
                            g_hLocRes, this);
    if (!m_hwnd)
        {
        GetLastError();
        AssertSz(m_hwnd, _T("CTipOfTheDay::HrCreate() - Failed to create window."));
        return (E_OUTOFMEMORY);
        }

    return (S_OK);    
    }


LRESULT CALLBACK EXPORT_16 CTipOfTheDay::TipWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                          LPARAM lParam)
    {
    CTipOfTheDay *pThis = (CTipOfTheDay *) GetProp(hwnd, TIPINFO_PROP);
    
    switch (uMsg)
        {
        case WM_NCCREATE:
            // Get the this pointer that was passed in
            pThis = (CTipOfTheDay *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
            Assert(pThis);
            
            // Stuff the this pointer for the object into a property
            SetProp(hwnd, TIPINFO_PROP, pThis);
            pThis->AddRef();                            // Released in WM_DESTROY
            return (TRUE);
            
        HANDLE_MSG(hwnd, WM_CREATE,         pThis->OnCreate);
        HANDLE_MSG(hwnd, WM_SIZE,           pThis->OnSize);
        HANDLE_MSG(hwnd, WM_COMMAND,        pThis->OnCommand);
        HANDLE_MSG(hwnd, WM_DRAWITEM,       pThis->OnDrawItem);
        HANDLE_MSG(hwnd, WM_DESTROY,        pThis->OnDestroy);
        HANDLE_MSG(hwnd, WM_SYSCOLORCHANGE, pThis->OnSysColorChange);        
        HANDLE_MSG(hwnd, WM_PAINT,          pThis->OnPaint);        

        case WM_SETTINGCHANGE:
            pThis->OnSysColorChange(hwnd);
            break;
            
        case WM_SETFOCUS:
            if (pThis && IsWindow(pThis->m_hwndNext))
                SetFocus(pThis->m_hwndNext);
            return (0);
            
        HANDLE_MSG(hwnd, WM_CTLCOLORSTATIC, pThis->OnCtlColor);
        }
    
    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
    }


//
//  FUNCTION:   CTipOfTheDay::OnCreate()
//
//  PURPOSE:    Does all of the initialization of the control, including loading
//              the tip string, creating child windows, etc.
//
//  PARAMETERS:
//      <in> hwnd           - Handle of the tip window
//      <in> lpCreateStruct - Information from the CreateWindow() call
//
//  RETURN VALUE:
//      TRUE  - Allows the window to be created
//      FALSE - Prevents the window from being created.
//
BOOL CTipOfTheDay::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
    {
    HRESULT hr;
    
    // First load the tip
    if (FAILED(HrLoadTipInfo()))
        return (FALSE);
    
    // Create the child windows
    if (FAILED(HrCreateChildWindows(hwnd)))
        return (FALSE);
    
    // Load the string we should be using for the title - ie "Tip of the Day"
    AthLoadString(idsTipOfTheDay, m_szTitle, ARRAYSIZE(m_szTitle));    
    m_hiTip = LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiTipIcon));
    AthLoadString(idsNextTip, m_szNextTip, ARRAYSIZE(m_szNextTip));
    
    // Build our GDI objects/info
    OnSysColorChange(hwnd);
    
    return (TRUE);
    }


//
//  FUNCTION:   CTipOfTheDay::HrLoadTipInfo()
//
//  PURPOSE:    Loads the appropriate tip string into m_pszTip.
//
//  RETURN VALUE:
//      E_UNEXPECTED - For some reason we couldn't find the string in the registry.
//      E_OUTOFMEMORY - Not enough memory to allocate a buffer to store the string.
//      S_OK - The string was loaded.
//
HRESULT CTipOfTheDay::HrLoadTipInfo(void)
    {
    HKEY    hKeyUser = 0, hKey;
    LPCTSTR pszKey, pszKeyUser;
    TCHAR   szValue[16];
    DWORD   cValues;
    DWORD   cValueLen;
    HRESULT hr = S_OK;
    DWORD   dwType;
    DWORD   cbData;
    
    // Preset some default values first
    m_dwCurrentTip = 0;
    SafeMemFree(m_pszTip);
    
    // First load which tip the user should see next
    if (FOLDER_NEWS == m_ftType)
        pszKeyUser = c_szRegNews;
    else
        pszKeyUser = c_szMailPath;   
    
    // Now load the tip string
    if (FOLDER_NEWS == m_ftType)
        pszKey = c_szRegTipStringsNews;
    else
        pszKey = c_szRegTipStringsMail;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKey, 0, KEY_READ, &hKey))
        {
        if (ERROR_SUCCESS != RegQueryInfoKey(hKey, NULL, 0, 0, NULL, NULL, NULL, 
                                             &cValues, NULL, &cValueLen, NULL, NULL))
            {
            AssertSz(FALSE, _T("CTipOfTheDay::LoadTipInfo() - Failed call to RegQueryInfoKey()."));
            hr = E_UNEXPECTED;
            goto exit;
            }
        
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, pszKeyUser, 0, 
                                          KEY_READ | KEY_WRITE, &hKeyUser))
            {
            cbData = sizeof(DWORD);
            RegQueryValueEx(hKeyUser, c_szRegCurrentTip, 0, &dwType, (LPBYTE) &m_dwCurrentTip, 
                            &cbData);

            m_dwCurrentTip++;
            if (m_dwCurrentTip > cValues)
                m_dwCurrentTip = 1;
            
            RegSetValueEx(hKeyUser, c_szRegCurrentTip, 0, REG_DWORD, (const LPBYTE)  
                          &m_dwCurrentTip, sizeof(DWORD));
            RegCloseKey(hKeyUser);        
            }
        else
            m_dwCurrentTip++;    
            
        // Allocate the buffer for the string
        if (!MemAlloc((LPVOID*) &m_pszTip, sizeof(TCHAR) * (cValueLen + 1)))
            {
            AssertSz(FALSE, _T("CTipOfTheDay::LoadTipInfo() - MemAlloc() failed."));
            hr = E_OUTOFMEMORY;
            goto exit;
            }
            
        // Now load the actual tip string    
        wsprintf(szValue, _T("%d"), m_dwCurrentTip);        
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, szValue, 0, &dwType, 
                                             (LPBYTE) m_pszTip, &cValueLen))
            {
            AssertSz(FALSE, _T("CTipOfTheDay::LoadTipInfo() - Failed to load tip string."));
            hr = E_UNEXPECTED;
            goto exit;
            }
        
        RegCloseKey(hKey);    
        }
    
    return (hr);       
    
exit:
    SafeMemFree(m_pszTip);
    RegCloseKey(hKey);
    
    return (hr);
    }


//
//  FUNCTION:   CTipOfTheDay::HrLoadLinkInfo()
//
//  PURPOSE:    Loads the links that we will display at the bottom of our page
//              into the m_rgLinkInfo array.
//
//  RETURN VALUE:
//      E_UNEXPECTED - For some reason we failed to find the link information
//                     in the registry.
//      E_OUTOFMEMORY - Not enough memory to allocate m_rgLinkInfo.
//      S_OK - m_rgLinkInfo and m_cLinks are set correctly.
//
HRESULT CTipOfTheDay::HrLoadLinkInfo(void)
    {
#if 0
    HKEY    hKey;
    LPCTSTR pszKey;
    DWORD   cValues;
    DWORD   cValueLen;
    DWORD   iLink;
    DWORD   iLinkIndex;
    HRESULT hr = S_OK;
    DWORD   dwType;
    DWORD   cbData;
    TCHAR   szValue[64];
    
    // Open the appropriate key for the tip links
    if (FOLDER_NEWS == m_ftType)
        pszKey = c_szRegTipLinksNews;
    else
        pszKey = c_szRegTipLinksMail;   
    
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKey, 0, KEY_READ, &hKey))
        return (E_UNEXPECTED);
    
    // Get the number of values in this key
    if (ERROR_SUCCESS != RegQueryInfoKey(hKey, NULL, 0, 0, NULL, NULL, NULL, 
                                         &cValues, NULL, &cValueLen, NULL, NULL))
        {
        AssertSz(FALSE, _T("CTipOfTheDay::HrLoadLinkInfo() - Failed call to RegQueryInfoKey()."));
        hr = E_UNEXPECTED;
        goto exit;
        }
    
    // There should always be an even number of values in this key since each
    // link should have a link text and link addr value.
    m_cLinks = (cValues / 2) + (cValues % 2);
    Assert(0 == (cValues % 2));
    
    // Allocate the m_rgLinkInfo array.  If the below assert fails, we are 
    // leaking the m_rgLinkInfo array.
    AssertSz(NULL == m_rgLinkInfo, _T("CTipOfTheDay::HrLoadLinkInfo() - We should only call this once."));
    
    if (!MemAlloc((LPVOID *) &m_rgLinkInfo, sizeof(LINKINFO) * m_cLinks))
        {
        AssertSz(FALSE, _T("CTipOfTheDay::HrLoadLinkInfo() - Failed to allocate memory."));
        hr = E_OUTOFMEMORY;
        goto exit;
        }
    ZeroMemory(m_rgLinkInfo, sizeof(LINKINFO) * m_cLinks);    
    
    // Loop through the items and load each string
    iLink = 0;
    for (iLinkIndex = 1; iLinkIndex <= m_cLinks; iLinkIndex++)
        {
        // Allocate the link text array
        if (!MemAlloc((LPVOID*) &(m_rgLinkInfo[iLink].pszLinkText), cValueLen))
            {
            AssertSz(FALSE, _T("CTipOfTheDay::HrLoadLinkInfo() - Failed to allocate memory."));
            hr = E_OUTOFMEMORY;
            goto exit;
            }
            
        // Allocate the link address array
        if (!MemAlloc((LPVOID*) &(m_rgLinkInfo[iLink].pszLinkAddr), cValueLen))
            {
            AssertSz(FALSE, _T("CTipOfTheDay::HrLoadLinkInfo() - Failed to allocate memory."));
            hr = E_OUTOFMEMORY;
            goto exit;
            }
        
        // Load the link text
        wsprintf(szValue, c_szRegLinkText, iLinkIndex);
        cbData = cValueLen;
        m_rgLinkInfo[iLink].pszLinkText[0] = 0;
        RegQueryValueEx(hKey, szValue, 0, &dwType, (LPBYTE) m_rgLinkInfo[iLink].pszLinkText, &cbData);
        Assert(0 != lstrlen(m_rgLinkInfo[iLink].pszLinkText));

        // Load the link addr
        wsprintf(szValue, c_szRegLinkAddr, iLinkIndex);
        cbData = cValueLen;
        m_rgLinkInfo[iLink].pszLinkAddr[0] = 0;
        RegQueryValueEx(hKey, szValue, 0, &dwType, (LPBYTE) m_rgLinkInfo[iLink].pszLinkAddr, &cbData);
        Assert(0 != lstrlen(m_rgLinkInfo[iLink].pszLinkAddr));
        
        // Make sure we have values.  If not, we dump this data and go on.
        if (0 == lstrlen(m_rgLinkInfo[iLink].pszLinkAddr) || 
            0 == lstrlen(m_rgLinkInfo[iLink].pszLinkText))
            {
            SafeMemFree(m_rgLinkInfo[iLink].pszLinkText);
            SafeMemFree(m_rgLinkInfo[iLink].pszLinkAddr);            
            }
        else        
            iLink++;    
        }
    
    // Store the number of links we actually loaded.
    m_cLinks = iLink;    
    RegCloseKey(hKey);
    return (hr);
    
exit:    
    // Free the linkinfo array
    FreeLinkInfo();
    
    // Close the registry
    RegCloseKey(hKey);
    return (hr);

#endif
    return (E_NOTIMPL);
    }


//
//  FUNCTION:   CTipOfTheDay::FreeLinkInfo()
//
//  PURPOSE:    Frees the m_rgLinkInfo array.
//
void CTipOfTheDay::FreeLinkInfo(void)
    {
#if 0
    if (m_rgLinkInfo && m_cLinks)
        {
        for (DWORD i = 0; i < m_cLinks; i++)
            {
            SafeMemFree(m_rgLinkInfo[i].pszLinkText);
            SafeMemFree(m_rgLinkInfo[i].pszLinkAddr);            
            }
        
        SafeMemFree(m_rgLinkInfo);
        m_cLinks = 0;
        }
#endif
    }


//
//  FUNCTION:   CTipOfTheDay::HrCreateChildWindows()
//
//  PURPOSE:    Creates the child windows needed for the tip and the link 
//              buttons.
//
//  RETURN VALUE:
//      E_OUTOFMEMORY - Could not create the tip window
//      S_OK - Everything was created OK
//
HRESULT CTipOfTheDay::HrCreateChildWindows(HWND hwnd)
    {
    // Create the "Next Tip" button
    m_hwndNext = CreateWindowEx(WS_EX_TRANSPARENT, BUTTON_CLASS, m_szNextTip,
                                WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | BS_PUSHBUTTON | BS_NOTIFY | BS_OWNERDRAW | WS_TABSTOP | WS_VISIBLE, 
                                0, 0, 10, 10, hwnd, 
                                (HMENU) IDC_NEXTTIP_BUTTON, g_hLocRes, 0);

    return (S_OK);    
    }


//
//  FUNCTION:   CTipOfTheDay::OnDestroy()
//
//  PURPOSE:    This is sent as the tip control is being destroyed.  In
//              response, we remove the properties we set on any of our
//              windows, including the link buttons.
//
//  PARAMETERS:
//      <in> hwnd - Handle of the tip control.
//
void CTipOfTheDay::OnDestroy(HWND hwnd)
    {
#if 0
    // Loop through the tip windows removing their properties
    for (DWORD i = 0; i < m_cLinks; i++)
        {
        Assert(IsWindow(m_rgLinkInfo[i].hwndCtl));
        RemoveProp(m_rgLinkInfo[i].hwndCtl, LINKINFO_PROP);
        }
#endif
    
    // Now remove and Release() our 'this' pointer.  These were AddRef()'d
    // in WM_NCCREATE.
    Assert(IsWindow(m_hwnd));
    RemoveProp(m_hwnd, TIPINFO_PROP);
    Release();
    }


//
//  FUNCTION:   CTipOfTheDay::OnDrawItem()
//
//  PURPOSE:    Draws the link buttons
//
//  PARAMETERS:
//      <in> hwnd       - Handle of the tip control window
//      <in> lpDrawItem - Pointer to a DRAWITEMSTRUCT with the info needed to 
//                        draw the button.
//
void CTipOfTheDay::OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT* lpDrawItem)
    {
    HDC      hdc = lpDrawItem->hDC;
    COLORREF clrText;
    UINT     uAlign;
    HFONT    hf;
    RECT     rcBtn;
    int      yText;
    LPTSTR   pszText;
    
    Assert(lpDrawItem->CtlType == ODT_BUTTON);
    Assert(lpDrawItem->CtlID >= IDC_LINKBASE_BUTTON || 
           lpDrawItem->CtlID == IDC_NEXTTIP_BUTTON);
    
    // Get the LINKINFO struct from the button prop
    if (lpDrawItem->CtlID == IDC_NEXTTIP_BUTTON)
        pszText = m_szNextTip;
    else
        {
        PLINKINFO pLinkInfo = (PLINKINFO) GetProp(lpDrawItem->hwndItem, LINKINFO_PROP);
        Assert(pLinkInfo);
        Assert(pLinkInfo->hwndCtl == lpDrawItem->hwndItem);
        
        pszText = pLinkInfo->pszLinkText;        
        }
    
    // Set up the DC
    SetBkMode(hdc, TRANSPARENT);
    clrText = SetTextColor(hdc, m_clrLink);
    hf = SelectFont(hdc, m_hfLink);
    
    // Draw the text
    FillRect(hdc, &lpDrawItem->rcItem, m_hbrBack);
    rcBtn = lpDrawItem->rcItem;
    DrawText(hdc, pszText, lstrlen(pszText), &rcBtn, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        
    // Check to see if we should have a focus rect
    if (lpDrawItem->itemState & ODS_FOCUS)
        {
        InflateRect(&rcBtn, -1, -1);
        DrawFocusRect(hdc, &rcBtn);
        }
    
    // Restore the DC
    SetTextColor(hdc, clrText);
    SelectFont(hdc, hf);
    }


//
//  FUNCTION:   CTipOfTheDay::OnSysColorChange()
//
//  PURPOSE:    Reloads our colors and fonts to match the system settings.
//
void CTipOfTheDay::OnSysColorChange(HWND hwnd)
    {
    NONCLIENTMETRICS ncm;
    HDC hdc;
    HFONT hf;
    SIZE size;

#ifndef WIN16
    // Get the colors that we need
#if 1
    m_clrBack = GetSysColor(COLOR_INFOBK);
    m_clrText = GetSysColor(COLOR_INFOTEXT);
#else
    m_clrBack = GetSysColor(COLOR_BTNFACE);    
    m_clrText = GetSysColor(COLOR_BTNTEXT);
#endif
#else //!WIN16
    m_clrBack = GetSysColor(COLOR_BTNFACE);    
    m_clrText = GetSysColor(COLOR_BTNTEXT);
#endif //!WIN16

    // Get the border size
    m_dwBorder = GetSystemMetrics(SM_CXBORDER) * 8;

    if (!LookupLinkColors(&m_clrLink, NULL))
        m_clrLink = m_clrText;
    
    // Get a new background brush
    if (m_hbrBack)
        {
        DeleteBrush(m_hbrBack);
        m_hbrBack = 0;
        }
    m_hbrBack = CreateSolidBrush(m_clrBack);
    
    // Get the fonts
    ZeroMemory(&ncm, sizeof(NONCLIENTMETRICS));
    ncm.cbSize = sizeof(NONCLIENTMETRICS);

#ifndef WIN16
    if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE))
#else
    {
        HFONT  hfSys;
        hfSys = (HFONT)GetStockObject( ANSI_VAR_FONT );
        GetObject( hfSys, sizeof( LOGFONT ), &ncm.lfMessageFont );
    }
#endif
        {
        m_hfTip = CreateFontIndirect(&ncm.lfMessageFont);
        
        ncm.lfMessageFont.lfUnderline = TRUE;
        m_hfLink = CreateFontIndirect(&ncm.lfMessageFont);

        // Adjust the font for the title text
        ncm.lfMessageFont.lfHeight = -16;
        ncm.lfMessageFont.lfWeight = FW_BOLD;
        ncm.lfMessageFont.lfUnderline = FALSE;
        m_hfTitle = CreateFontIndirect(&ncm.lfMessageFont);
        
        // Get the text metrics as well
        hdc = GetDC(m_hwnd);
        
        hf = SelectFont(hdc, m_hfLink);
        GetTextMetrics(hdc, &m_tmLink);        
        SelectFont(hdc, m_hfTitle);
        GetTextMetrics(hdc, &m_tmTitle);
        
        // Calculate how big the title area is
        GetTextExtentPoint32(hdc, m_szTitle, lstrlen(m_szTitle), &size);
        m_cxTitleWidth = TIP_ICON_WIDTH + (1 * m_dwBorder);
        m_cyTitleHeight = max(TIP_ICON_HEIGHT, m_tmTitle.tmHeight * 2) + (2 * m_dwBorder);

        SelectFont(hdc, hf);
        ReleaseDC(m_hwnd, hdc);
        }
    
    InvalidateRect(hwnd, NULL, TRUE);    
    }


//
//  FUNCTION:   CTipOfTheDay::OnCommand()
//
//  PURPOSE:    Used to handle commands from our controls.  More specificly,
//              we launch URL's when the user clicks a button link.
//
void CTipOfTheDay::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
    SHELLEXECUTEINFO rShellExec;
    PLINKINFO pLinkInfo;
    RECT rcClient;
    
    switch (codeNotify)
        {
        // The user clicked on one of our links.  We need to launch the URL.
        case BN_CLICKED:
            if (IDC_NEXTTIP_BUTTON == id)
                {
                if (SUCCEEDED(HrLoadTipInfo()))
                    {
                    InvalidateRect(hwnd, NULL, TRUE);
                    }
                }
            else
                {
                // First get the PLINKINFO for the button
                if (NULL == (pLinkInfo = (PLINKINFO) GetProp(hwndCtl, LINKINFO_PROP)))
                    return;
                    
                ZeroMemory (&rShellExec, sizeof (rShellExec));
                rShellExec.cbSize = sizeof (rShellExec);
                rShellExec.fMask  = SEE_MASK_NOCLOSEPROCESS;
                rShellExec.hwnd   = GetParent(m_hwnd);
                rShellExec.nShow  = SW_SHOWNORMAL;
                rShellExec.lpFile = pLinkInfo->pszLinkAddr;
                rShellExec.lpVerb = NULL; // i.e. "Open"
                ShellExecuteEx (&rShellExec);              
                }
                
            return;
        }
    
    return;    
    }


//
//  FUNCTION:   CTipOfTheDay::OnSize()
//
//  PURPOSE:    Handles moving and sizing our child windows when the control
//              size is changed.
//
//  PARAMETERS:
//      <in> hwnd   - Handle of the control window.
//      <in> state  - Type of sizing that occured.
//      <in> cx, cy - New width and height of the client area.
//
void CTipOfTheDay::OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
    HFONT hf;
    SIZE  size;
    HDC   hdc;
    DWORD i;
    RECT  rc;
    BOOL  fShow = FALSE;
    
    m_cyNextHeight = m_tmLink.tmHeight + (2 * LINK_BUTTON_BORDER);

    hdc = GetDC(m_hwnd);
    hf = SelectFont(hdc, m_hfLink);

    // Position the "Next Tip" button in the bottom right corner
    if (GetTextExtentPoint32(hdc, m_szNextTip, lstrlen(m_szNextTip), &size))
        m_cxNextWidth = size.cx + (2 * LINK_BUTTON_BORDER);
    else
        m_cxNextWidth = 0;
            
    // If the "Next Tip" button would overlap the title, then hide it
    fShow = ((int)(cx - m_dwBorder - m_cxNextWidth) > (int) m_cxTitleWidth);
    ShowWindow(m_hwndNext, fShow ? SW_SHOW : SW_HIDE);

    SetWindowPos(m_hwndNext, 0, cx - m_dwBorder - m_cxNextWidth, 
                 cy - m_dwBorder - m_cyNextHeight,                 
                 m_cxNextWidth, m_cyNextHeight, SWP_NOACTIVATE | SWP_NOZORDER);
                 
    SelectFont(hdc, hf);
    ReleaseDC(m_hwnd, hdc);    

    // Calculate the new rectangle for the tip text
    m_rcTip.left   = m_cxTitleWidth + m_dwBorder;
    m_rcTip.top    = m_dwBorder;
    m_rcTip.right  = cx - (2 * m_dwBorder) - m_cxNextWidth; 
    m_rcTip.bottom = cy - m_dwBorder;

    SetRect(&rc, m_cxTitleWidth + m_dwBorder, 0, cx, cy);
    InvalidateRect(hwnd, &rc, TRUE);
    }


//
//  FUNCTION:   CTipOfTheDay::GetRequiredWidth()
//
//  PURPOSE:    Returns the minimum width the control requires to display 
//              itself correctly.
//
//  RETURN VALUE:
//      Returns the minimum width required for the control in pixels.
//
DWORD CTipOfTheDay::GetRequiredWidth(void)
    {
    // No longer used
    return (0);
    }


//
//  FUNCTION:   CTipOfTheDay::GetRequiredWidth()
//
//  PURPOSE:    Returns the minimum width the control requires to display 
//              itself correctly.
//
//  RETURN VALUE:
//      Returns the minimum width required for the control in pixels.
//
DWORD CTipOfTheDay::GetRequiredHeight(void)
    {
    return (m_cyTitleHeight);
    }


void CTipOfTheDay::OnPaint(HWND hwnd)
    {
    PAINTSTRUCT ps;
    HDC         hdc;
    HFONT       hf;
    COLORREF    clrBack;
    COLORREF    clrText;
    UINT        uAlign;
    RECT        rc;
    RECT        rcClient;
    
    GetClientRect(m_hwnd, &rcClient);
    hdc = BeginPaint(hwnd, &ps);
    
    // See if we need to erase the background
    if (ps.fErase)
        {
        FillRect(hdc, &ps.rcPaint, m_hbrBack);
        }
    
    // Set up the DC
    clrBack = SetBkColor(hdc, m_clrBack);
    clrText = SetTextColor(hdc, m_clrText);
    SetBkMode(hdc, TRANSPARENT);
    uAlign = SetTextAlign(hdc, TA_TOP);
    hf = SelectFont(hdc, m_hfTitle);
    
    // Draw the tip icon
    DrawIcon(hdc, m_dwBorder, max(((m_cyTitleHeight - 32) / 2), 0), m_hiTip);
    
    // A little line to make it look nice
    MoveToEx(hdc, m_cxTitleWidth, m_dwBorder, NULL);
    LineTo(hdc, m_cxTitleWidth, m_cyTitleHeight - m_dwBorder);
    
    // Figure out how big the "Tip of the Day" rect is going to be
    rc.left = TIP_ICON_WIDTH + m_dwBorder;
    rc.top = m_dwBorder;
    rc.right = m_cxTitleWidth - m_dwBorder;
    rc.bottom = m_cyTitleHeight;
    
    // "Tip of the Day" title
//    DrawText(hdc, m_szTitle, lstrlen(m_szTitle), &rc, DT_CENTER | DT_NOPREFIX | DT_NOCLIP | DT_WORDBREAK);

    // Draw the tip text
    SelectFont(hdc, m_hfTip);
    rc = m_rcTip;
    rc.right = rcClient.right;
    FillRect(hdc, &rc, m_hbrBack);
    DrawText(hdc, m_pszTip, lstrlen(m_pszTip), &m_rcTip, DT_CENTER | DT_NOPREFIX | DT_WORDBREAK);
    
    // Restore the DC
    SetBkColor(hdc, clrBack);
    SetTextColor(hdc, clrText);
    SetTextAlign(hdc, uAlign);
    SelectFont(hdc, hf);

    EndPaint(hwnd, &ps);
    }


HBRUSH CTipOfTheDay::OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
    {
    Assert(type == CTLCOLOR_STATIC);
    
    SetBkColor(hdc, m_clrBack);
    SetTextColor(hdc, m_clrText);
    SetBkMode(hdc, TRANSPARENT);
    return (m_hbrBack);
    }


//////////////////////////////////////////////////////////////////////////////

CLinkButton::CLinkButton()
    {
    m_cRef = 1;
    m_hwnd = 0;
    m_hwndParent = 0;

    m_pszCaption = NULL;
    m_pszLink = NULL;

    m_clrLink = RGB(0, 0, 0);
    m_clrBack = RGB(255, 255, 255);
    m_hfLink = NULL;
    ZeroMemory(&m_tmLink, sizeof(TEXTMETRIC));
    m_hbrBack = NULL;

    m_dwBorder = 0;
    m_cxWidth = 0;
    m_cyHeight = 0;

    m_cxImage = 0;
    m_cyImage = 0;

#ifdef WIN16
    m_hbmButtons = NULL;
#endif
    }

CLinkButton::~CLinkButton()
    {
    if (m_hfLink)
        DeleteFont(m_hfLink);
    if (m_hbrBack)
        DeleteBrush(m_hbrBack);
#if IMAGELIST
    if (m_himl)
        ImageList_Destroy(m_himl);
#endif

    SafeMemFree(m_pszCaption);
    SafeMemFree(m_pszLink);
    }

ULONG CLinkButton::AddRef(void)
    {
    return (++m_cRef);
    }

ULONG CLinkButton::Release(void)
    {
    ULONG cRef = m_cRef--;
    
    if (m_cRef == 0)
        delete this;
    
    return (cRef);    
    }    

//
//  FUNCTION:   CLinkButton::HrCreate()
//
//  PURPOSE:    Creates the owner drawn button and initializes the class 
//              members with the correct caption and link information.
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the button's parent window
//      <in> pszCaption - Text to display on the button
//      <in> pszLink    - URL to execute when the user clicks on the button
//      <in> uID        - Command ID for the button
//
//  RETURNS:
//      Returns S_OK if everything succeeds.
//
HRESULT CLinkButton::HrCreate(HWND hwndParent, LPTSTR pszCaption, LPTSTR pszLink,
                              UINT uID)
    {
    Assert(IsWindow(hwndParent));
    Assert(pszCaption);
    Assert(pszLink);

    // Copy down the provided information
    m_hwndParent = hwndParent;
    m_pszCaption = PszDup(pszCaption);
    m_pszLink = PszDup(pszLink);
    m_uID = uID;

    // Create the button window
    m_hwnd = CreateWindowEx(0, BUTTON_CLASS, m_pszCaption,
                            WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE 
                            | BS_PUSHBUTTON | BS_NOTIFY | BS_OWNERDRAW | WS_TABSTOP, 
                            0, 0, 10, 10, hwndParent, (HMENU) uID, g_hLocRes, 0);

    if (!m_hwnd)
        return (E_OUTOFMEMORY);

    // Set our this pointer as a property of the button so we can retrieve
    // it later
    SetProp(m_hwnd, LINKINFO_PROP, this);

    // Subclass the button so we can clean ourselves up correctly when it 
    // gets destroyed
    WNDPROC pfn = (WNDPROC) SetWindowLong(m_hwnd, GWL_WNDPROC, 
                                          (LONG) ButtonSubClass);
    SetProp(m_hwnd, WNDPROC_PROP, pfn);

    OnSysColorChange();
    
    return (S_OK);
    }


//
//  FUNCTION:   CLinkButton::HrCreate()
//
//  PURPOSE:    Creates the owner drawn button and initializes the class 
//              members with the correct caption and link information.
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the button's parent window
//      <in> pszCaption - Text to display on the button
//      <in> uID        - Command ID for the button
//      <in> idBmp      - Id for the bitmap that contains the button image
//      <in> index      - Index of the image in idBmp for this button
//
//  RETURNS:
//      Returns S_OK if everything succeeds.
//
HRESULT CLinkButton::HrCreate(HWND hwndParent, LPTSTR pszCaption, UINT uID, 
                              UINT index, HBITMAP hbmButton, HBITMAP hbmMask, HPALETTE hpal)
    {
    Assert(IsWindow(hwndParent));
    Assert(pszCaption);
    Assert(uID);

    // Copy down the provided information
    m_hwndParent = hwndParent;
    m_pszCaption = PszDup(pszCaption);
    m_uID = uID;
    m_index = index;

    m_cxImage = CX_BUTTON_IMAGE;
    m_cyImage = CY_BUTTON_IMAGE;

    m_hbmButtons = hbmButton;
    m_hbmMask = hbmMask;
    m_hpalButtons = hpal;

    // Create the button window
    m_hwnd = CreateWindowEx(0, BUTTON_CLASS, m_pszCaption,
                            WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE 
                            | BS_PUSHBUTTON | BS_NOTIFY | BS_OWNERDRAW | WS_TABSTOP, 
                            0, 0, 10, 10, hwndParent, (HMENU) uID, g_hLocRes, 0);

    if (!m_hwnd)
        return (E_OUTOFMEMORY);

    // Set our this pointer as a property of the button so we can retrieve
    // it later
    SetProp(m_hwnd, LINKINFO_PROP, this);

    // Subclass the button so we can clean ourselves up correctly when it 
    // gets destroyed
    WNDPROC pfn = (WNDPROC) SetWindowLong(m_hwnd, GWL_WNDPROC, 
                                          (LONG) ButtonSubClass);
    SetProp(m_hwnd, WNDPROC_PROP, pfn);

    OnSysColorChange();
    
    return (S_OK);
    }

//
//  FUNCTION:   CLinkButton::OnDrawItem()
//
//  PURPOSE:    Draws the link button
//
//  PARAMETERS:
//      <in> hwnd       - Handle of the tip control window
//      <in> lpDrawItem - Pointer to a DRAWITEMSTRUCT with the info needed to 
//                        draw the button.
//
#define ROP_PatMask     0x00E20746      // D <- S==1 ? P : D
#define DESTINATION     0x00AA0029
void CLinkButton::OnDraw(HWND hwnd, const DRAWITEMSTRUCT* lpDrawItem)
    {
    HDC      hdc = lpDrawItem->hDC;
    COLORREF clrText, clrBack;
    UINT     uAlign;
    HFONT    hf;
    RECT     rcBtn;
    int      yText;
    HBRUSH   hbr;
    HPALETTE hpalOld;
    
    Assert(lpDrawItem->CtlType == ODT_BUTTON);
    Assert(lpDrawItem->CtlID == m_uID);
    
    // Set up the DC    
    clrText = SetTextColor(hdc, m_clrLink);
    clrBack = SetBkColor(hdc, m_clrBack);
    hf = SelectFont(hdc, m_hfLink);
    
    // Draw the text
    rcBtn = lpDrawItem->rcItem;
    FillRect(hdc, &rcBtn, m_hbrBack);

    // If there was an image set, then draw that first
#if IMAGELIST
    if (m_himl)
        {
        ImageList_Draw(m_himl, m_index, hdc, rcBtn.left, rcBtn.top, ILD_TRANSPARENT);
        rcBtn.top += m_cyImage;
        }
#endif

    // If we're supposed to paint button images, do so now
    if (m_hbmButtons)
        {
        HBRUSH  hbrWhite;
        HDC     hdcMem;
        HBITMAP hbmMemOld;
        HBRUSH  hbrOld;
        HDC     hdcMask;
        HBITMAP hbmMaskOld;

        Assert(m_hpalButtons);

        // Select and realize the palette
        hpalOld = SelectPalette(hdc, m_hpalButtons, TRUE);
        RealizePalette(hdc);

        hbrWhite = CreateSolidBrush(0x00FFFFFF);

#ifndef WIN16
        SetTextColor(hdc, RGB(255, 255, 255));
        SetBkColor(hdc, RGB(0, 0, 0));
#else
        SetTextColor( hdc, RGB( 0, 0, 0 ) );
        SetBkColor( hdc, RGB( 255, 255, 255 ) );
#endif
        
        // Set up a memory DC for the button bitmap
        hdcMem = CreateCompatibleDC(hdc);
        hbmMemOld = SelectBitmap(hdcMem, m_hbmButtons);
        hbrOld = SelectBrush(hdcMem, /* hbrWhite */ m_hbrBack);

#if 1
        // Set up a memory DC for the mask
        hdcMask = CreateCompatibleDC(hdc);
        hbmMaskOld = SelectBitmap(hdcMask, m_hbmMask);

        BitBlt(hdc, 0, rcBtn.top, CX_BUTTON_IMAGE, CY_BUTTON_IMAGE, hdcMem,  CX_BUTTON_IMAGE * m_index, 0, SRCINVERT);
        BitBlt(hdc, 0, rcBtn.top, CX_BUTTON_IMAGE, CY_BUTTON_IMAGE, hdcMask, CX_BUTTON_IMAGE * m_index, 0, SRCAND);
        BitBlt(hdc, 0, rcBtn.top, CX_BUTTON_IMAGE, CY_BUTTON_IMAGE, hdcMem,  CX_BUTTON_IMAGE * m_index, 0, SRCINVERT);
/*
        // Combine the mask and the button bitmaps
        BitBlt(hdcMem, 0, 0, CX_BUTTON_IMAGE * 6, CY_BUTTON_IMAGE, hdcMask, 0, 0,
               ROP_PatMask);

        // Paint the final button image on the screen
        BitBlt(hdc, 0, rcBtn.top, CX_BUTTON_IMAGE, CY_BUTTON_IMAGE, hdcMem, 
               CX_BUTTON_IMAGE * m_index, 0, SRCCOPY);
*/
        // Clean up the mask memory DC
        SelectBitmap(hdcMask, hbmMaskOld);
        DeleteDC(hdcMask);
#else
        MaskBlt(hdc, 
                0, 
                rcBtn.top, 
                CX_BUTTON_IMAGE, 
                CY_BUTTON_IMAGE,
                hdcMem,
                CX_BUTTON_IMAGE * m_index,
                0,
                m_hbmMask,
                CX_BUTTON_IMAGE * m_index,
                0,
                MAKEROP4(DESTINATION, SRCCOPY));
#endif

        // Clean up the button memory DC
        SelectBrush(hdcMem, hbrOld);
        SelectBitmap(hdcMem, hbmMemOld);
        DeleteDC(hdcMem);
        DeleteBrush(hbrWhite);

        // Reset the palette
        if (hpalOld != NULL)
            SelectPalette(hdc, hpalOld, TRUE);

        rcBtn.top += m_cyImage;
        }

    clrText = SetTextColor(hdc, m_clrLink);
    clrBack = SetBkColor(hdc, m_clrBack);
    DrawText(hdc, m_pszCaption, lstrlen(m_pszCaption), &rcBtn, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        
    // Check to see if we should have a focus rect
    if (lpDrawItem->itemState & ODS_FOCUS)
        {
        rcBtn = lpDrawItem->rcItem;
        InflateRect(&rcBtn, -1, -1);
        DrawFocusRect(hdc, &rcBtn);
        }
    
    // Restore the DC
    SetTextColor(hdc, clrText);
    SetBkColor(hdc, clrBack);
    SelectFont(hdc, hf);
    }


//
//  FUNCTION:   CLinkButton::OnSysColorChange()
//
//  PURPOSE:    Reloads our colors and fonts to match the system settings.
//
void CLinkButton::OnSysColorChange(void)
    {
    NONCLIENTMETRICS ncm;
    HDC hdc;
    HFONT hf;
    SIZE size;
    COLORREF clrText;

    // Get the colors that we need
    clrText = GetSysColor(COLOR_BTNTEXT);
    if (!LookupLinkColors(&m_clrLink, NULL))
        m_clrLink = clrText;

    m_clrBack = GetSysColor(COLOR_WINDOW);
    if (m_hbrBack)
        DeleteBrush(m_hbrBack);
    m_hbrBack = CreateSolidBrush(m_clrBack);
    
    // Get the border size
    m_dwBorder = GetSystemMetrics(SM_CXBORDER) * 8;
    
    // Get the fonts
    ZeroMemory(&ncm, sizeof(NONCLIENTMETRICS));
    ncm.cbSize = sizeof(NONCLIENTMETRICS);

#ifndef WIN16
    if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE))
#else
    {
        HFONT  hfSys;
        hfSys = (HFONT)GetStockObject( ANSI_VAR_FONT );
        GetObject( hfSys, sizeof( LOGFONT ), &ncm.lfMessageFont );
    }
#endif
        {
        ncm.lfMessageFont.lfUnderline = TRUE;
        m_hfLink = CreateFontIndirect(&ncm.lfMessageFont);

        // Get the text metrics as well
        hdc = GetDC(m_hwnd);
        
        hf = SelectFont(hdc, m_hfLink);
        GetTextMetrics(hdc, &m_tmLink);        
        
        // Calculate how big the link text area is
        GetTextExtentPoint32(hdc, m_pszCaption, lstrlen(m_pszCaption), &size);
        m_cxWidth = max((DWORD) m_cxImage, (DWORD) (size.cx + (2 * LINK_BUTTON_BORDER)));

        // If we have an image, we don't next the extra spacing
        if (m_cyImage)
            m_cyHeight = m_tmLink.tmHeight + m_cyImage + LINK_BUTTON_BORDER;
        else
            m_cyHeight = m_tmLink.tmHeight + (2 * LINK_BUTTON_BORDER);

        SelectFont(hdc, hf);
        ReleaseDC(m_hwnd, hdc);
        }
    
    InvalidateRect(m_hwnd, NULL, TRUE);    
    }

void CLinkButton::Move(DWORD x, DWORD y)
    {
    SetWindowPos(m_hwnd, 0, x, y, m_cxWidth, m_cyHeight, 
                 SWP_NOZORDER | SWP_NOACTIVATE);
    }


void CLinkButton::OnCommand(void)
    {
#ifndef WIN16
    SHELLEXECUTEINFO rShellExec;

    ZeroMemory (&rShellExec, sizeof (rShellExec));
    rShellExec.cbSize = sizeof (rShellExec);
    rShellExec.fMask  = SEE_MASK_NOCLOSEPROCESS;
    rShellExec.hwnd   = m_hwndParent;
    rShellExec.nShow  = SW_SHOWNORMAL;
    rShellExec.lpFile = m_pszLink;
    rShellExec.lpVerb = NULL; // i.e. "Open"
    ShellExecuteEx (&rShellExec);
#else
    RunBrowser( m_pszLink, FALSE );
#endif //!WIN16
    }

void CLinkButton::Show(BOOL fShow)
    {
    ShowWindow(m_hwnd, fShow ? SW_SHOW : SW_HIDE);
    }

LRESULT CALLBACK EXPORT_16 ButtonSubClass(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    // If the message is WM_DESTROY, then we need to free the CLinkButton
    // class associated with the button.
    if (uMsg == WM_DESTROY)
        {
        CLinkButton *pLink = (CLinkButton*) GetProp(hwnd, LINKINFO_PROP);
        if (pLink)
            pLink->Release();
        SetProp(hwnd, LINKINFO_PROP, 0);
        }

    // Pass the message on to the original window procedure
    WNDPROC pfn = (WNDPROC) GetProp(hwnd, WNDPROC_PROP);
    if (pfn)
        return CallWindowProc(pfn, hwnd, uMsg, wParam, lParam);
    else
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

/////////////////////////////////////////////////////////////////////////////

HRESULT HrLoadButtonBitmap(HWND hwnd, int idBmp, int idMask, HBITMAP* phBtns, 
                           HBITMAP *phMask, HPALETTE *phPalette)
    {
    HRESULT     hr = S_OK;
    HBITMAP     hbmBtn = 0;
    HBITMAP     hbmMask = 0;
    BITMAP      bm;
    HDC         hdc = 0;
    HDC         hdcBitmap = 0;
    DWORD       adw[257];
    int         i, n;
    HPALETTE    hPal = 0;

    // Load the button bitmap
    hbmBtn = (HBITMAP) LoadImage(g_hLocRes, MAKEINTRESOURCE(idBmp), IMAGE_BITMAP,
                                 0, 0, LR_CREATEDIBSECTION);
    if (!hbmBtn)
        {
        Assert(hbmBtn);
        hr = E_INVALIDARG;
        goto exit;
        }

    // Load the mask bitmap
    hbmMask = (HBITMAP) LoadImage(g_hLocRes, MAKEINTRESOURCE(idMask), IMAGE_BITMAP,
                                  0, 0, LR_CREATEDIBSECTION);
    if (!hbmMask)
        {
        Assert(hbmMask);
        hr = E_INVALIDARG;
        goto exit;
        }

#ifndef WIN16
    // Get the dimensions of the bitmaps
    GetObject((HGDIOBJ) hbmBtn, sizeof(BITMAP), &bm);

    // Set up the DC's with the bitmap
    hdc = GetDC(hwnd);
    Assert(hdc != NULL);
    hdcBitmap = CreateCompatibleDC(hdc);
    Assert(hdcBitmap != NULL);

    SelectBitmap(hdcBitmap, hbmBtn);

    // Create a palette for the bitmap
    n = GetDIBColorTable(hdcBitmap, 0, 256, (LPRGBQUAD) &adw[1]);
    for (i = 1; i <= n; i++)
        adw[i] = RGB(GetBValue(adw[i]), GetGValue(adw[i]), GetRValue(adw[i]));
    adw[0] = MAKELONG(0x300, n);
    hPal = CreatePalette((LPLOGPALETTE) &adw[0]);
    Assert(hPal);

    // Clean up
    DeleteDC(hdcBitmap);
    ReleaseDC(hwnd, hdc);
#else
    hPal = (HPALETTE)GetStockObject( DEFAULT_PALETTE );
    Assert( hPal );
#endif

    // Set up the return values
    *phBtns = hbmBtn;
    *phMask = hbmMask;
    *phPalette = hPal;

    return (S_OK);

exit:
    // Delete the button bitmap
    if (hbmBtn)
        DeleteBitmap(hbmBtn);

    // Delete the mask
    if (hbmMask)
        DeleteBitmap(hbmMask);

    return (hr);
    }


//
//  FUNCTION:   CLinkButton::OnPaletteChanged()
//
//  PURPOSE:    Sent when another window changes the palette on us.
//
//  PARAMETERS:
//      <in> hwnd - Handle of the folderview window
//      <in> hwndPaletteChange - The window that changed the palette.
//
void CLinkButton::OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange)
    {
    if (hwnd != hwndPaletteChange)
        InvalidateRect(m_hwnd, NULL, FALSE);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\enginit.cpp ===
// --------------------------------------------------------------------------------
// Enginit.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "spengine.h"
#include "ourguid.h"

HANDLE hSmapiEvent; // Added for Bug# 62129 (v-snatar)

// --------------------------------------------------------------------------------
// SAFECLOSEHANDLE
// --------------------------------------------------------------------------------
#ifndef WIN16
#define SAFECLOSEHANDLE(_handle) \
    if (NULL != _handle) { \
        CloseHandle(_handle); \
        _handle = NULL; \
    }
#else
#define SAFECLOSEHANDLE(_handle) \
    if (NULL != _handle) { \
        CloseEvent(_handle); \
        _handle = NULL; \
    }
#endif
// --------------------------------------------------------------------------------
// ENGINECREATEINFO
// --------------------------------------------------------------------------------
typedef struct tagENGINECREATEINFO {
    HEVENT              hEvent;                 // Event used to synchronize creation
    HRESULT             hrResult;               // Result from SpoolEngineThreadEntry
    PFNCREATESPOOLERUI  pfnCreateUI;            // Function to create the spooler ui object
    CSpoolerEngine     *pSpooler;               // Spooler Engine
    BOOL                fPoll;                  // Whether or not to poll
} ENGINECREATEINFO, *LPENGINECREATEINFO;

// --------------------------------------------------------------------------------
// SpoolerEngineThreadEntry
// --------------------------------------------------------------------------------
#ifndef WIN16
DWORD SpoolerEngineThreadEntry(LPDWORD pdwParam);
#else
unsigned int __stdcall LOADDS_16 SpoolerEngineThreadEntry(LPDWORD pdwParam);
#endif
HTHREAD hThread = NULL;

// --------------------------------------------------------------------------------
// CreateThreadedSpooler
// --------------------------------------------------------------------------------
HRESULT CreateThreadedSpooler(PFNCREATESPOOLERUI pfnCreateUI, ISpoolerEngine **ppSpooler,
                              BOOL fPoll)
{
    // Locals
    HRESULT             hr=S_OK;
    HTHREAD             hThread=NULL;
    DWORD               dwThreadId;
    ENGINECREATEINFO    rCreate;

    // Invalid Arg
    if (NULL == ppSpooler)
        return TrapError(E_INVALIDARG);

    // Initialize the Structure
    ZeroMemory(&rCreate, sizeof(ENGINECREATEINFO));

    rCreate.hrResult = S_OK;
    rCreate.pfnCreateUI = pfnCreateUI;
    rCreate.fPoll = fPoll;

    // Create an Event to synchonize creation
    rCreate.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == rCreate.hEvent)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Added Bug# 62129 (v-snatar)
    hSmapiEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Create the inetmail thread
    hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)SpoolerEngineThreadEntry, &rCreate, 0, &dwThreadId);
    if (NULL == hThread)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Wait for SpoolEngineThreadEntry to signal the event
    WaitForSingleObject_16(rCreate.hEvent, INFINITE);

    // Failure
    if (FAILED(rCreate.hrResult))
    {
        hr = TrapError(rCreate.hrResult);
        goto exit;
    }

    // Return the object
    Assert(rCreate.pSpooler);
    *ppSpooler = (ISpoolerEngine *)rCreate.pSpooler;
    rCreate.pSpooler->m_hThread = hThread;

exit:
    // Cleanup
    SAFECLOSEHANDLE(rCreate.hEvent);
    SafeRelease(rCreate.pSpooler);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CloseThreadedSpooler
// ------------------------------------------------------------------------------------
HRESULT CloseThreadedSpooler(ISpoolerEngine *pSpooler)
{
    // Locals
    DWORD       dwThreadId;
    HTHREAD      hThread;

    // Invalid Arg
    if (NULL == pSpooler)
        return TrapError(E_INVALIDARG);

    // Get the Thread Info
    pSpooler->GetThreadInfo(&dwThreadId, &hThread);

    // Assert
    Assert(dwThreadId && hThread);

    // Post quit message
    PostThreadMessage(dwThreadId, WM_QUIT, 0, 0);

    // Wait for event to become signaled
    WaitForSingleObject(hThread, INFINITE);

    // Close the thread handle
    CloseHandle(hThread);

    // Close the Event Created for Simple MAPI purposes
    // Bug #62129 (v-snatar)

    CloseHandle(hSmapiEvent);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// SpoolerEngineThreadEntry
// --------------------------------------------------------------------------------
#ifndef WIN16
DWORD SpoolerEngineThreadEntry(LPDWORD pdwParam) 
#else
unsigned int __stdcall LOADDS_16 SpoolerEngineThreadEntry(LPDWORD pdwParam)
#endif
{  
    // Locals
    MSG                     msg;
    HWND                    hwndUI;
    CSpoolerEngine         *pSpooler=NULL;
    ISpoolerUI             *pUI=NULL;
    LPENGINECREATEINFO      pCreate;

    // We better have a parameter
    Assert(pdwParam);

    // Cast to create info
    pCreate = (LPENGINECREATEINFO)pdwParam;

    // Initialize COM
    pCreate->hrResult = OleInitialize(NULL);
    if (FAILED(pCreate->hrResult))
    {
        TrapError(pCreate->hrResult);
        SetEvent(pCreate->hEvent);
        return 0;
    }

    // Create the Spooler UI
    if (pCreate->pfnCreateUI)
    {
        // Create the UI Object
        pCreate->hrResult = (*pCreate->pfnCreateUI)(&pUI);
        if (FAILED(pCreate->hrResult))
        {
            CoUninitialize();
            TrapError(pCreate->hrResult);
            SetEvent(pCreate->hEvent);
            return 0;
        }
    }

    // Create a Spooler Object
    pCreate->pSpooler = new CSpoolerEngine;
    if (NULL == pCreate->pSpooler)
    {
        CoUninitialize();
        pCreate->hrResult = TrapError(E_OUTOFMEMORY);
        SetEvent(pCreate->hEvent);
        return 0;
    }

    // Initialize the Spooler Engine
    pCreate->hrResult = pCreate->pSpooler->Init(pUI, pCreate->fPoll);
    if (FAILED(pCreate->hrResult))
    {
        CoUninitialize();
        TrapError(pCreate->hrResult);
        SetEvent(pCreate->hEvent);
        return 0;
    }

    // No UI Yet ?
    if (NULL == pUI)
    {
        // Get the spooler UI object
        SideAssert(SUCCEEDED(pCreate->pSpooler->BindToObject(IID_ISpoolerUI, (LPVOID *)&pUI)));
    }

    // I want to hold onto the spooler
    pSpooler = pCreate->pSpooler;
    pSpooler->AddRef();

    // Set Event
    SetEvent(pCreate->hEvent);

    // Pump Messages
    while (GetMessage(&msg, NULL, 0, 0))
    {
        // Give the message to the UI object
        if (pUI->IsDialogMessage(&msg) == S_FALSE && pSpooler->IsDialogMessage(&msg) == S_FALSE)
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // Raid 67816: OE:TW:Error message stop responding after OE is closed.
    // If a dialog was displayed when the above message loop broke out, then that dialog will
    // have automatically gone away and left the spooler UI window disabled!
    pUI->GetWindow(&hwndUI);
    EnableWindow(hwndUI, TRUE);

    // Shutdown the spooler
    pSpooler->Shutdown();

    // Release the UI Object
    pUI->Close();
    pUI->Release();

    // Release
    pSpooler->Release();

    // Deinit COM
    OleUninitialize();

    // Done
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\imaptask.h ===
//***************************************************************************
// IMAP4 Spooler Task Object Header File
// Written by Raymond Cheng, 6/27/97
//***************************************************************************

#ifndef __IMAPTASK_H
#define __IMAPTASK_H

//---------------------------------------------------------------------------
// Includes
//---------------------------------------------------------------------------
#include "spoolapi.h"
#include "imnact.h"


//---------------------------------------------------------------------------
// Forward Declarations
//---------------------------------------------------------------------------
class CIMAPFolderMgr;


//---------------------------------------------------------------------------
// CIMAPTask Class Definition
//---------------------------------------------------------------------------
class CIMAPTask : public ISpoolerTask
{
public:
    // Constructor, Destructor
    CIMAPTask(void);
    ~CIMAPTask(void);

    // IUnknown Methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    // ISpoolerTask Methods
    HRESULT STDMETHODCALLTYPE Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx);
    HRESULT STDMETHODCALLTYPE BuildEvents(ISpoolerUI *pSpoolerUI,
        IImnAccount *pAccount, LPCTSTR pszFolder);
    HRESULT STDMETHODCALLTYPE Execute(EVENTID eid, DWORD dwTwinkie);
    HRESULT STDMETHODCALLTYPE ShowProperties(HWND hwndParent, EVENTID eid, DWORD dwTwinkie);
    HRESULT STDMETHODCALLTYPE GetExtendedDetails(EVENTID eid, DWORD dwTwinkie,
        LPSTR *ppszDetails);
    HRESULT STDMETHODCALLTYPE Cancel(void);
    HRESULT STDMETHODCALLTYPE IsDialogMessage(LPMSG pMsg);
    HRESULT STDMETHODCALLTYPE OnFlagsChanged(DWORD dwFlags);

private:
    // Module variables
    long m_lRefCount;
    ISpoolerBindContext *m_pBindContext;
    ISpoolerUI *m_pSpoolerUI;
    char m_szAccountName[CCHMAX_ACCOUNT_NAME];
    LPCSTR m_pszFolder;
    CIMAPFolderMgr *m_pIMAPFolderMgr;
    HWND m_hwnd;
    EVENTID m_CurrentEID;
    BOOL m_fFailuresEncountered;
    DWORD m_dwTotalTicks;
    DWORD m_dwFlags;

    // Functions
    static LRESULT CALLBACK IMAPTaskWndProc(HWND hwnd, UINT uMsg,
        WPARAM wParam, LPARAM lParam);

}; // class CIMAPTask

#endif // __IMAPTASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\httptask.cpp ===
// --------------------------------------------------------------------------------
// h t t p t a s k . h
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Greg S. Friedman
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "httptask.h"
#include "taskutil.h"
#include "acctcach.h"
#include "xputil.h"
#include "useragnt.h"
#include "..\http\httputil.h"

// --------------------------------------------------------------------------------
// Data Types
// --------------------------------------------------------------------------------
typedef enum tagHTTPEVENTTYPE
{ 
    EVENT_HTTPSEND
} HTTPEVENTTYPE;

#define CURRENTHTTPEVENT  ((LPHTTPEVENTINFO)m_psaEvents->GetItemAt(m_iEvent))

//----------------------------------------------------------------------
// FreeNewMessageInfo
//----------------------------------------------------------------------
static void __cdecl _FreeHTTPEventInfo(LPVOID pei)
{
    Assert(NULL != pei);
    SafeMemFree(pei);
}

// --------------------------------------------------------------------------------
// CHTTPTask::CHTTPTask
// --------------------------------------------------------------------------------
CHTTPTask::CHTTPTask(void) :
    m_cRef(1),
    m_dwFlags(NOFLAGS),
    m_dwState(NOFLAGS),
    m_cbTotal(0),
    m_cbSent(0),
    m_cbStart(0),
    m_cCompleted(0),
    m_wProgress(0),
    m_pSpoolCtx(NULL),
    m_pAccount(NULL),
    m_pOutbox(NULL),
    m_pSentItems(NULL),
    m_psaEvents(NULL),
    m_iEvent(0),
    m_pszSubject(NULL),
    m_pBody(NULL),
    m_pTransport(NULL),
    m_pUI(NULL),
    m_idSendEvent(INVALID_EVENT),
    m_pszAccountId(NULL),
    m_pszSendMsgUrl(NULL)
{
    InitializeCriticalSection(&m_cs);

    ZeroMemory(&m_rServer, sizeof(INETSERVER));
}

// --------------------------------------------------------------------------------
// CHTTPTask::~CHTTPTask
// --------------------------------------------------------------------------------
CHTTPTask::~CHTTPTask(void)
{
    _Reset();
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CHTTPTask::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr = S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(ISpoolerTask *)this;
    else if (IID_ISpoolerTask == riid)
        *ppv = (ISpoolerTask *)this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHTTPTask::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CHTTPTask::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHTTPTask::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// ---------------------------------------------------------------------------
// ISpoolerTask Methods
// ---------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CHTTPTask::Init
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx)
{
    // Invalid Arg
    if (NULL == pBindCtx)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Save the Activity Flags - DELIVER_xxx
    m_dwFlags = dwFlags;

    // Hold onto the bind context
    Assert(NULL == m_pSpoolCtx);
    m_pSpoolCtx = pBindCtx;
    m_pSpoolCtx->AddRef();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPTask::BuildEvents
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::BuildEvents(ISpoolerUI *pSpoolerUI, 
                                    IImnAccount *pAccount, 
                                    FOLDERID idFolder)
{
    HRESULT         hr = S_OK;
    HROWSET	        hRowset=NULL;
    MESSAGEINFO     mi = {0};
    CHAR            szAccount[CCHMAX_ACCOUNT_NAME];
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];
    CHAR            szMessage[255];
    CHAR            szRes[255];
    FOLDERINFO      fi = {0};
    LPFOLDERINFO    pfiFree = NULL;
    LPSTR           pszUserAgent = GetOEUserAgentString();
    LPSTR           pszCachedPass = NULL;
    FOLDERID        idServer;

    // Invalid Arg
    if (NULL == pSpoolerUI || NULL == pAccount)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    m_pUI = pSpoolerUI;
    m_pUI->AddRef();

    m_pAccount = pAccount;
    m_pAccount->AddRef();

    // Get the Account Name
    CHECKHR(hr = m_pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccount, ARRAYSIZE(szAccount)));
    
    // Get the account ID
    CHECKHR(hr = m_pAccount->GetPropSz(AP_ACCOUNT_ID, szAccountId, ARRAYSIZE(szAccountId)));
    m_pszAccountId = PszDupA(szAccountId);

    // Get the outbox
    CHECKHR(hr = m_pSpoolCtx->BindToObject(IID_CLocalStoreOutbox, (LPVOID *)&m_pOutbox));

    // Get the sent items. Don't fail if it doesn't exist.
    if (DwGetOption(OPT_SAVESENTMSGS))
    {
        if (SUCCEEDED(g_pStore->FindServerId(m_pszAccountId, &idServer)))
            g_pStore->OpenSpecialFolder(idServer, NULL, FOLDER_SENT, &m_pSentItems);
    }

    // Create a Rowset
    CHECKHR(hr = m_pOutbox->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

	// Loop
	while (S_OK == m_pOutbox->QueryRowset(hRowset, 1, (LPVOID *)&mi, NULL))
	{
        CHECKHR(hr = _HrAppendOutboxMessage(szAccount, &mi));

        // Free Current
        m_pOutbox->FreeRecord(&mi);
    } 

    if (NULL == m_psaEvents || 0 == m_psaEvents->GetLength())
        goto exit;

    // create the transport object
    CHECKHR(hr = CoCreateInstance(CLSID_IHTTPMailTransport, NULL, CLSCTX_INPROC_SERVER, IID_IHTTPMailTransport, (LPVOID *)&m_pTransport));

    // Init the Transport
    CHECKHR(hr = m_pTransport->InitNew(pszUserAgent, NULL, this));

    // Fill an INETSERVER structure from the account object
    CHECKHR(hr = m_pTransport->InetServerFromAccount(m_pAccount, &m_rServer));

    // looked for a cached password and, if one exists, use it
    GetAccountPropStrA(m_pszAccountId, CAP_PASSWORD, &pszCachedPass);
    if (NULL != pszCachedPass)
        lstrcpyn(m_rServer.szPassword, pszCachedPass, sizeof(m_rServer.szPassword));

    // connect to the server. the transport won't
    // actually connect until a command is issued
    CHECKHR(hr = m_pTransport->Connect(&m_rServer, TRUE, FALSE));

    LOADSTRING(IDS_SPS_SMTPEVENT, szRes);
    wsprintf(szMessage, szRes, m_psaEvents->GetLength(), m_rServer.szAccount);

    CHECKHR(hr = m_pSpoolCtx->RegisterEvent(szMessage, (ISpoolerTask *)this, EVENT_HTTPSEND, m_pAccount, &m_idSendEvent));

    // If this account is set to always prompt for password and password isn't
    // already cached, show UI so we can prompt user for password
    if (ISFLAGSET(m_rServer.dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) && NULL == pszCachedPass)
    {
        m_pUI->ShowWindow(SW_SHOW);
    }

exit:
    // Cleanup
    SafeMemFree(pszUserAgent);
    SafeMemFree(pszCachedPass);

    if (m_pOutbox)
    {
        m_pOutbox->CloseRowset(&hRowset);
        m_pOutbox->FreeRecord(&mi);
    }

    LeaveCriticalSection(&m_cs);

    return hr;
}
    
// --------------------------------------------------------------------------------
// CHTTPTask::Execute
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::Execute(EVENTID eid, DWORD_PTR dwTwinkie)
{
    HRESULT hr = E_FAIL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    if (EVENT_HTTPSEND == dwTwinkie)
        hr = _HrExecuteSend(eid, dwTwinkie);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::CancelEvent
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPTask::Cancel
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::Cancel(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    m_dwState |= HTTPSTATE_CANCELED;

    // Simply drop the connection
    if (m_pTransport)    
        m_pTransport->DropConnection();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPTask::IsDialogMessage
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::IsDialogMessage(LPMSG pMsg)
{
    return S_FALSE;
}

// --------------------------------------------------------------------------------
// CHTTPTask::OnFlagsChanged
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnFlagsChanged(DWORD dwFlags)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPTask::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnLogonPrompt(
                                LPINETSERVER            pInetServer,
                                IInternetTransport     *pTransport)
{
    HRESULT     hr = S_OK;
    LPSTR       pszCachedPass = NULL;

    EnterCriticalSection(&m_cs);
    // pull password out of the cache
    GetAccountPropStrA(m_pszAccountId, CAP_PASSWORD, &pszCachedPass);
    if (NULL != pszCachedPass && 0 != lstrcmp(pszCachedPass, pInetServer->szPassword))
    {
        lstrcpyn(pInetServer->szPassword, pszCachedPass, sizeof(pInetServer->szPassword));
        goto exit;
    }

    if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
    {
        hr = S_FALSE;
        goto exit;
    }

    hr = TaskUtil_OnLogonPrompt(m_pAccount, m_pUI, NULL, pInetServer, AP_HTTPMAIL_USERNAME, 
                                AP_HTTPMAIL_PASSWORD, AP_HTTPMAIL_PROMPT_PASSWORD, TRUE);
    
    // cache the password
    if (S_OK == hr)
        HrCacheAccountPropStrA(m_pszAccountId, CAP_PASSWORD, pInetServer->szPassword);
    
exit:
    LeaveCriticalSection(&m_cs);
    SafeMemFree(pszCachedPass);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CHTTPTask::OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CHTTPTask::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnStatus(IXPSTATUS ixpstatus, IInternetTransport *pTransport)
{
    // Locals
    EVENTCOMPLETEDSTATUS tyEventStatus = EVENT_SUCCEEDED;

    EnterCriticalSection(&m_cs);

    // Invalid State
    Assert(m_pUI && m_pSpoolCtx);

    // Feed the the IXP status to the UI object
    m_pUI->SetSpecificProgress(MAKEINTRESOURCE(XPUtil_StatusToString(ixpstatus)));

    // Disconnected
    if (ixpstatus == IXP_DISCONNECTED)
    {
        HRESULT hrDisconnect = _OnDisconnectComplete();
        
        // TODO: update progress state and deal with errors

        // Set the animation
        m_pUI->SetAnimation(idanOutbox, FALSE);

        if (!ISFLAGSET(m_dwState, HTTPSTATE_EVENTSUCCESS) || (NULL != m_cCompleted && m_cCompleted < m_psaEvents->GetLength()))
        {
            if (ISFLAGSET(m_dwState, HTTPSTATE_CANCELED))
                tyEventStatus = EVENT_CANCELED;
            else if (ISFLAGSET(m_dwState, HTTPSTATE_EVENTSUCCESS))
                tyEventStatus = EVENT_WARNINGS;
            else
                tyEventStatus = EVENT_FAILED;
        }

        // Result
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_RESULT, tyEventStatus);

        // Result
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_COMPLETE, 0);

        // Hands Off my callback
        SideAssert(m_pTransport->HandsOffCallback() == S_OK);

        // This task is complete
        m_pSpoolCtx->EventDone(m_idSendEvent, tyEventStatus);
    }

    LeaveCriticalSection(&m_cs);

    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPTask::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CHTTPTask::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CHTTPTask::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport)

{
    return E_NOTIMPL;
}
// --------------------------------------------------------------------------------
// CHTTPTask::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// IHTTPMailCallback methods
// --------------------------------------------------------------------------------
// --------------------------------------------------------------------------------
// CHTTPTask::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::OnResponse(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT     hr = S_OK;
    HRESULT     hrCatch;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // if the send message url couldn't be retrieved, convert the error into
    // a more informative error code.
    if (SP_E_HTTP_SERVICEDOESNTWORK == pResponse->rIxpResult.hrResult)
    {
        _CatchResult(SP_E_HTTP_NOSENDMSGURL);
        goto exit;
    }
    
        // Handle the Error
    if (TASKRESULT_SUCCESS != _CatchResult(&pResponse->rIxpResult))
        goto exit;

    switch (pResponse->command)
    {
        case HTTPMAIL_GETPROP:
            if (SUCCEEDED(_HrAdoptSendMsgUrl(pResponse->rGetPropInfo.pszProp)))
            {
                pResponse->rGetPropInfo.pszProp = NULL;
                // build the message and post it
                hr = _HrPostCurrentMessage();
            }
            break;

        case HTTPMAIL_SENDMESSAGE:
            _UpdateSendMessageProgress(pResponse);
            if (pResponse->fDone)
                _CatchResult(_HrFinishCurrentEvent(S_OK, pResponse->rSendMessageInfo.pszLocation));
            break;

        default:
            Assert(FALSE);
            break;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::GetParentWindow
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPTask::GetParentWindow(HWND *phwndParent)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// Private Implementation
// --------------------------------------------------------------------------------
// --------------------------------------------------------------------------------
// CHTTPTask::_Reset
// --------------------------------------------------------------------------------
void CHTTPTask::_Reset(void)
{
    SafeRelease(m_pSpoolCtx);
    SafeRelease(m_pAccount);
    SafeRelease(m_pOutbox);
    SafeRelease(m_pSentItems);

    delete m_psaEvents;
    m_iEvent = 0;

    SafeMemFree(m_pszSubject);

    SafeRelease(m_pBody);

    SafeRelease(m_pTransport);
    SafeRelease(m_pUI);

    SafeMemFree(m_pszAccountId);
    SafeMemFree(m_pszSendMsgUrl);
}

// --------------------------------------------------------------------------------
// CHTTPTask::_CatchResult
// --------------------------------------------------------------------------------
TASKRESULTTYPE CHTTPTask::_CatchResult(HRESULT hr)
{
    // Locals
    IXPRESULT   rResult;

    // Build an IXPRESULT
    ZeroMemory(&rResult, sizeof(IXPRESULT));
    rResult.hrResult = hr;

    // Get the HTTPMail Result Type
    return _CatchResult(&rResult);
}

// --------------------------------------------------------------------------------
// CHTTPTask::_CatchResult
// --------------------------------------------------------------------------------
TASKRESULTTYPE CHTTPTask::_CatchResult(LPIXPRESULT pResult)
{
    HWND            hwndParent;
    TASKRESULTTYPE  tyTaskResult = TASKRESULT_FAILURE;

    // If Succeeded
    if (SUCCEEDED(pResult->hrResult))
        return TASKRESULT_SUCCESS;

    // Get Window
    if (NULL == m_pUI || FAILED(m_pUI->GetWindow(&hwndParent)))
        hwndParent = NULL;

    // Process generic protocol error
    tyTaskResult = TaskUtil_FBaseTransportError(IXP_HTTPMail, m_idSendEvent, pResult, &m_rServer, m_pszSubject, m_pUI,
                                                !ISFLAGSET(m_dwFlags, DELIVER_NOUI), hwndParent);

    // Have a Transport
    if (m_pTransport)
    {
        // If Task Failure, drop the connection
        if (TASKRESULT_FAILURE == tyTaskResult)
        {
            // Roast the current connection
            m_pTransport->DropConnection();
        }

        // If Event Failure...
        else if (TASKRESULT_EVENTFAILED == tyTaskResult)
        {
            // Goto Next Event
            if (FAILED(_HrFinishCurrentEvent(pResult->hrResult, NULL)))
            {
                // Roast the current connection
                m_pTransport->DropConnection();
            }
        }
    }

    return tyTaskResult;
}

// --------------------------------------------------------------------------------
// CHTTPTask::_HrAppendOutboxMessage
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrAppendOutboxMessage(LPCSTR pszAccount, LPMESSAGEINFO pmi)
{
    HRESULT         hr = S_OK;
    IImnAccount     *pAccount = NULL;
    LPHTTPEVENTINFO pEvent = NULL;

    Assert(NULL != pszAccount && NULL != pmi);

    // handle empty account id
    if (NULL == pmi->pszAcctId || FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pmi->pszAcctId, &pAccount)))
    {
        // do some special junk with default accounts
        goto exit;
    }
    else if (lstrcmpi(pmi->pszAcctName, pszAccount) != 0)
        goto exit;

    if (NULL == m_psaEvents)
        CHECKHR(hr = CSortedArray::Create(NULL, _FreeHTTPEventInfo, &m_psaEvents));

    // build the event object and append it into the event array
    if (!MemAlloc((void **)&pEvent, sizeof(HTTPEVENTINFO)))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    CHECKHR(hr = m_psaEvents->Add(pEvent));

    pEvent->idMessage = pmi->idMessage;
    pEvent->fComplete = FALSE;

    m_cbTotal += (pmi->cbMessage + 175);
    pEvent->cbSentTotal = m_cbTotal;    // running total

    pEvent = NULL;

exit:
    SafeMemFree(pEvent);
    SafeRelease(pAccount);

    return hr;
}


// --------------------------------------------------------------------------------
// CHTTPTask::_HrCreateSendProps
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrCreateSendProps(IMimeMessage *pMessage,
                                      LPSTR *ppszFrom,
                                      LPHTTPTARGETLIST *ppTargets)
{
    HRESULT                 hr = S_OK;
    IMimeAddressTable       *pAdrTable = NULL;
    IMimeEnumAddressTypes   *pAdrEnum = NULL;
    ADDRESSPROPS            rAddress;
    ULONG                   c;
    LPSTR                   pszFrom = NULL;
    LPSTR                   pszTemp = NULL;
    LPHTTPTARGETLIST        pTargets = NULL;
    DWORD                   dwTargetCapacity = 0;

    Assert(NULL != ppszFrom && NULL != ppTargets);
    if (NULL == ppszFrom || NULL == ppTargets)
        return E_INVALIDARG;

    *ppszFrom = NULL;
    *ppTargets = NULL;
    
    // allocate a targetlist
    if (!MemAlloc((void **)&pTargets, sizeof(HTTPTARGETLIST)))
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    pTargets->cTarget = 0;
    pTargets->prgTarget = NULL;

    ZeroMemory(&rAddress, sizeof(ADDRESSPROPS));

    // Get the recipients...
    CHECKHR(hr = pMessage->GetAddressTable(&pAdrTable));

    // Get Enumerator
    CHECKHR(hr = pAdrTable->EnumTypes(IAT_KNOWN, IAP_ADRTYPE | IAP_EMAIL, &pAdrEnum));

    // Walk the enumerator
    while (SUCCEEDED(pAdrEnum->Next(1, &rAddress, &c)) && c == 1)
    {
        if (NULL != rAddress.pszEmail)
        {
            // Get Type
            if (ISFLAGSET(IAT_RECIPS, rAddress.dwAdrType))
            {
                // copy the address
                pszTemp = PszDupA(rAddress.pszEmail);
                if (NULL == pszTemp)
                {
                    hr = TraceResult(E_OUTOFMEMORY);
                    goto exit;
                }

                // add it to the collection of addresses we are building
                if (pTargets->cTarget == dwTargetCapacity)
                {
                    if (!MemRealloc((void **)&pTargets->prgTarget, (dwTargetCapacity + 4) * sizeof(LPSTR)))
                    {
                        hr = TraceResult(E_OUTOFMEMORY);
                        goto exit;
                    }
                    dwTargetCapacity += 4;
                }

                pTargets->prgTarget[pTargets->cTarget++] = pszTemp;
                pszTemp = NULL;

            }
            else if (NULL == pszFrom && IAT_FROM == rAddress.dwAdrType)
            {
                pszFrom = PszDupA(rAddress.pszEmail);
                if (NULL == pszFrom)
                {
                    hr = TraceResult(E_OUTOFMEMORY);
                    goto exit;
                }
            }
        }

        // Release
        g_pMoleAlloc->FreeAddressProps(&rAddress);
    }

    // success. transfer ownership of the params to the caller
    *ppszFrom = pszFrom;
    pszFrom = NULL;
    *ppTargets = pTargets;
    pTargets = NULL;

exit:
    if (pTargets)
        Http_FreeTargetList(pTargets);
    SafeMemFree(pszTemp);
    SafeRelease(pAdrTable);
    SafeRelease(pAdrEnum);
    SafeMemFree(pszFrom);

    return hr;
}

// ------------------------------------------------------------------------------------
// CHTTPTask::_HrOpenMessage
// ------------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrOpenMessage(MESSAGEID idMessage, IMimeMessage **ppMessage)
{
    // Locals
    HRESULT         hr=S_OK;

    // Check Params
    Assert(ppMessage && m_pOutbox);

    // Init
    *ppMessage = NULL;

    // Stream in message
    CHECKHR(hr = m_pOutbox->OpenMessage(idMessage, OPEN_MESSAGE_SECURE, ppMessage, NOSTORECALLBACK));

    // remove an X-Unsent headers before sending
    (*ppMessage)->DeleteBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_XUNSENT));

exit:
    // Failure
    if (FAILED(hr))
        SafeRelease((*ppMessage));

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::_HrPostCurrentMessage
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrPostCurrentMessage(void)
{
    HRESULT             hr = S_OK;
    IMimeMessage        *pMessage = NULL;
    LPHTTPEVENTINFO     pEvent = NULL;
    CHAR                szRes[CCHMAX_RES];
    CHAR                szMsg[CCHMAX_RES + CCHMAX_ACCOUNT_NAME];
    LPSTR               pszFrom = NULL;
    LPHTTPTARGETLIST    pTargets = NULL;

    Assert(NULL != m_psaEvents);
    Assert(m_iEvent <= m_psaEvents->GetLength());

    pEvent = CURRENTHTTPEVENT;
    Assert(NULL != pEvent);

    LOADSTRING(IDS_SPS_SMTPPROGRESS, szRes);
    wsprintf(szMsg, szRes, m_iEvent + 1, m_psaEvents->GetLength());

    // Set Specific Progress
    m_pUI->SetSpecificProgress(szMsg);

    // Open Store Message
    if (FAILED(_HrOpenMessage(pEvent->idMessage, &pMessage)))
    {
        hr = TrapError(SP_E_SMTP_CANTOPENMESSAGE);
        goto exit;
    }

    CHECKHR(hr = _HrCreateSendProps(pMessage, &pszFrom, &pTargets));

    CHECKHR(hr = pMessage->GetMessageSource(&m_pBody, 0));

    hr = m_pTransport->SendMessage(m_pszSendMsgUrl, pszFrom, pTargets, DwGetOption(OPT_SAVESENTMSGS), m_pBody, 0);

exit:
    SafeRelease(pMessage);
    SafeMemFree(pszFrom);
    if (pTargets)
        Http_FreeTargetList(pTargets);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::_HrExecuteSend
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrExecuteSend(EVENTID eid, DWORD_PTR dwTwinkie)
{
    HRESULT     hr = S_OK;
    LPSTR       pszSendMsgUrl = NULL;
    CHAR        szRes[CCHMAX_RES];
    CHAR        szBuf[CCHMAX_RES + CCHMAX_SERVER_NAME];


        // Set the animation
    m_pUI->SetAnimation(idanOutbox, TRUE);

    // Setup Progress Meter
    m_pUI->SetProgressRange(100);

    // Connecting to ...
    LoadString(g_hLocRes, idsInetMailConnectingHost, szRes, ARRAYSIZE(szRes));
    wsprintf(szBuf, szRes, m_rServer.szAccount);
    m_pUI->SetGeneralProgress(szBuf);

    // Notify
    m_pSpoolCtx->Notify(DELIVERY_NOTIFY_CONNECTING, 0);

    Assert(NULL == m_pszSendMsgUrl);

    // look for the sendmsg url in the cache
    if (!GetAccountPropStrA(m_pszAccountId, CAP_HTTPMAILSENDMSG, &m_pszSendMsgUrl))
    {
        hr = m_pTransport->GetProperty(HTTPMAIL_PROP_SENDMSG, &pszSendMsgUrl);
        if (E_PENDING == hr)
        {
            hr = S_OK;
            goto exit;
        }
        CHECKHR(hr);
        CHECKHR(hr = _HrAdoptSendMsgUrl(pszSendMsgUrl));
    }

    Assert(NULL != m_pszSendMsgUrl);

    CHECKHR(hr = _HrPostCurrentMessage());

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::_HrAdoptSendMsgUrl
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrAdoptSendMsgUrl(LPSTR pszSendMsgUrl)
{
    Assert(NULL == m_pszSendMsgUrl);

    if (NULL == pszSendMsgUrl)
        return E_INVALIDARG;

    m_pszSendMsgUrl = pszSendMsgUrl ;

    // add it to the account data cache
    HrCacheAccountPropStrA(m_pszAccountId, CAP_HTTPMAILSENDMSG, m_pszSendMsgUrl);

    return S_OK;
}


// --------------------------------------------------------------------------------
// CHTTPTask::_HrFinishCurrentEvent
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrFinishCurrentEvent(HRESULT hrResult, LPSTR pszLocationUrl)
{
    // Locals
    HRESULT             hr = S_OK;
    LPHTTPEVENTINFO     pEvent;
    MESSAGEID           idMessage;

    if (FAILED(hrResult))
        goto exit;

    // save in sent items
    if (m_pSentItems && m_pBody && pszLocationUrl)
    {
        // add the message to the sent items folder
        CHECKHR(hr = Http_AddMessageToFolder(m_pSentItems, m_pszAccountId, NULL, ARF_READ, pszLocationUrl, &idMessage));
        
        // write the message body out
        CHECKHR(hr = Http_SetMessageStream(m_pSentItems, idMessage, m_pBody, NULL, TRUE));
    }

    // Get the current http event
    pEvent = CURRENTHTTPEVENT;

    pEvent->fComplete = TRUE;
    m_dwState |= HTTPSTATE_EVENTSUCCESS;

    ++m_cCompleted;

exit:
    // go to the next event
    hr = _HrStartNextEvent();

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::_HrStartNextEvent
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_HrStartNextEvent(void)
{
    // Locals
    HRESULT     hr = S_OK;

    // free the previous subject
    SafeMemFree(m_pszSubject);

    // free the previous body
    SafeRelease(m_pBody);

    // Fixup m_cbSent to be correct
    m_cbSent = (CURRENTHTTPEVENT)->cbSentTotal;
    m_cbStart = m_cbSent;

    // Are we done yet ?
    if (m_iEvent + 1 == m_psaEvents->GetLength())
    {
        // Update progress
        _DoProgress();

        // Disconnect from the server
        CHECKHR(hr = m_pTransport->Disconnect());
    }

    // otherwise, increment the event count and send the next message
    else
    {
        // Next Event
        m_iEvent++;

        // Update progress
        //_DoProgress();
        // Send Reset Command
        hr = _HrPostCurrentMessage();
        if (hr == E_PENDING)
            hr = S_OK;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::_OnDisconnectComplete
// --------------------------------------------------------------------------------
HRESULT CHTTPTask::_OnDisconnectComplete(void)
{
    // Locals
    HRESULT             hr = S_OK;
    LPDWORD             prgdwIds = NULL;
    DWORD               cIdsAlloc = 0;
    DWORD               i;
    LPHTTPEVENTINFO     pEvent;
    ADJUSTFLAGS         Flags;
    DWORD               cEvents;
    MESSAGEIDLIST       rList;

    rList.cMsgs = 0;
    rList.prgidMsg = NULL;

    // Invalid State
    Assert(m_pOutbox);
    Assert(m_psaEvents);

    cEvents = m_psaEvents->GetLength();

    // Walk through the list of events
    for (i=0; i < cEvents; i++)
    {
        // Readability
        pEvent = (LPHTTPEVENTINFO)m_psaEvents->GetItemAt(i);

        // If this event was in the outbox
        if (0 != pEvent->idMessage && pEvent->fComplete)
        {
            // Insert into my array of message ids
            if (rList.cMsgs + 1 > cIdsAlloc)
            {
                // Realloc
                CHECKHR(hr = HrRealloc((LPVOID *)&rList.prgidMsg, sizeof(DWORD) * (cIdsAlloc + 10)));

                // Increment cIdsAlloc
                cIdsAlloc += 10;
            }

            // Set Message Id
            rList.prgidMsg[rList.cMsgs++] = pEvent->idMessage;
        }
    }

    if (rList.cMsgs)
    {
        Flags.dwAdd = ARF_READ;
        Flags.dwRemove = ARF_SUBMITTED | ARF_UNSENT;

        if (m_idSendEvent != INVALID_EVENT)
        {
            // Delete the messages.
            // Messages are never copied to the local outbox for httpmail
            CHECKHR(hr = m_pOutbox->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &rList, NULL, NOSTORECALLBACK));
        }
        else
        {
            // Raid-7639: OE sends message over and over when runs out of disk space.
            m_pOutbox->SetMessageFlags(&rList, &Flags, NULL, NOSTORECALLBACK);
        }
    }

exit:
    // Cleanup
    SafeMemFree(rList.prgidMsg);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPTask::_UpdateSendMessageProgress
// --------------------------------------------------------------------------------
void CHTTPTask::_UpdateSendMessageProgress(LPHTTPMAILRESPONSE pResponse)
{
    // the transport is attempting to resend the stream..
    // reset our progress indicator
    if (pResponse->rSendMessageInfo.fResend)
    {
        m_cbSent = m_cbStart;
    }
    else
    {
        // Increment Status
        m_cbSent += pResponse->rSendMessageInfo.cbIncrement;
    }

     // Do Progress
    _DoProgress();
}

// --------------------------------------------------------------------------------
// CHTTPTask::_DoProgress
// --------------------------------------------------------------------------------
void CHTTPTask::_DoProgress(void)
{
    // Locals
    WORD            wProgress = 0;
    WORD            wDelta;

    // Invalid Arg
    Assert(m_cbTotal > 0 && m_pUI);

    if (m_cbSent > 0)
    {
        // Compute Current Progress Index
        wProgress = (WORD)((m_cbSent * 100) / m_cbTotal);

        // Compute Delta
        wDelta = wProgress - m_wProgress;

        // Progress Delta
        if (wDelta > 0)
        {
            // Incremenet Progress
            m_pUI->IncrementProgress(wDelta);

            // Increment my wProgress
            m_wProgress += wDelta;

            // Don't go over 100 percent
            Assert(m_wProgress <= 100);
        }
    }
    else if (m_wProgress != 0)
    {
        m_pUI->SetProgressPosition(0);
        m_wProgress = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\httptask.h ===
// --------------------------------------------------------------------------------
// h t t p t a s k . h
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Greg S. Friedman
// --------------------------------------------------------------------------------
#ifndef __HTTPTASK_H
#define __HTTPTASK_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "spoolapi.h"
#include "srtarray.h"
#include "taskutil.h"

// --------------------------------------------------------------------------------
// State
// --------------------------------------------------------------------------------
#define HTTPSTATE_CANCELED      FLAG01
#define HTTPSTATE_EVENTSUCCESS  FLAG02  // one or more events succeeded

// --------------------------------------------------------------------------------
// HTTPEVENTINFO
// --------------------------------------------------------------------------------
typedef struct tagHTTPEVENTINFO {
    DWORD               dwFlags;                // Flags
    MESSAGEID           idMessage;              // Store Information
    BOOL                fComplete;              // has event been completed
    DWORD               cbSentTotal;            // running total of sent bytes
} HTTPEVENTINFO, *LPHTTPEVENTINFO;

// --------------------------------------------------------------------------------
// CHTTPTask
// --------------------------------------------------------------------------------
class CHTTPTask: public ISpoolerTask, IHTTPMailCallback
{
public:
    // ----------------------------------------------------------------------------
    // CHTTPTask
    // ----------------------------------------------------------------------------
    CHTTPTask(void);
private:
    ~CHTTPTask(void);
    
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // ---------------------------------------------------------------------------
    // ISpoolerTask
    // ---------------------------------------------------------------------------
    STDMETHODIMP Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx);
    STDMETHODIMP BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder);
    STDMETHODIMP Execute(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP ShowProperties(HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie) { return TrapError(E_NOTIMPL); }
    STDMETHODIMP GetExtendedDetails(EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails) { return TrapError(E_NOTIMPL); }
    STDMETHODIMP Cancel(void);
    STDMETHODIMP IsDialogMessage(LPMSG pMsg);
    STDMETHODIMP OnFlagsChanged(DWORD dwFlags);

    // ----------------------------------------------------------------------------
    // ITransportCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnLogonPrompt(
            LPINETSERVER            pInetServer,
            IInternetTransport     *pTransport);

    STDMETHODIMP_(INT) OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport);

    // ----------------------------------------------------------------------------
    // IHTTPMailCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnResponse(LPHTTPMAILRESPONSE pResponse);

    STDMETHODIMP GetParentWindow(HWND *phwndParent);

private:
    // ---------------------------------------------------------------------------
    // Private Methods
    // ---------------------------------------------------------------------------
    void _Reset(void);

    TASKRESULTTYPE _CatchResult(HRESULT hr);
    TASKRESULTTYPE _CatchResult(LPIXPRESULT pResult);

    HRESULT _HrAppendOutboxMessage(LPCSTR pszAccount, LPMESSAGEINFO pmi);
    HRESULT _HrCreateSendProps(IMimeMessage *pMessage, LPSTR *ppszFrom, LPHTTPTARGETLIST *ppTargets);
    HRESULT _HrCreateHeaderStream(IMimeMessage *pMessage, IStream **ppStream);
    HRESULT _HrOpenMessage(MESSAGEID idMessage, IMimeMessage **ppMessage);
    HRESULT _HrPostCurrentMessage(void);
    HRESULT _HrExecuteSend(EVENTID eid, DWORD_PTR dwTwinkie);
    HRESULT _HrAdoptSendMsgUrl(LPSTR pszSendMsgUrl);
    HRESULT _HrFinishCurrentEvent(HRESULT hrResult, LPSTR pszLocationUrl);
    HRESULT _HrStartNextEvent(void);
    HRESULT _OnDisconnectComplete(void);
    void    _UpdateSendMessageProgress(LPHTTPMAILRESPONSE pResponse);
    void    _DoProgress(void);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    LONG                    m_cRef;             // Reference counting
    CRITICAL_SECTION        m_cs;               // thread safety
    DWORD                   m_dwFlags;          // flags
    DWORD                   m_dwState;          // state flags
    DWORD                   m_cbTotal;          // total bytes to send
    DWORD                   m_cbSent;           // number of bytes sent
    DWORD                   m_cbStart;          // number of bytes sent at event start
    long                    m_cCompleted;       // number of messages successfully sent
    WORD                    m_wProgress;        // Current progress index
    ISpoolerBindContext     *m_pSpoolCtx;       // spooler bind context
    IImnAccount             *m_pAccount;        // account
    IMessageFolder          *m_pOutbox;         // The outbox
    IMessageFolder          *m_pSentItems;      // Sent items folder
    CSortedArray            *m_psaEvents;       // array of queued events
    long                    m_iEvent;           // Current Event
    LPSTR                   m_pszSubject;       // subject of current message
    IStream                 *m_pBody;            // current message body
    IHTTPMailTransport      *m_pTransport;      // http data transport
    ISpoolerUI              *m_pUI;             // SpoolerUI
    EVENTID                 m_idSendEvent;      // EventId for message send
    INETSERVER              m_rServer;          // Server information
    LPSTR                   m_pszAccountId;     // Account Id
    LPSTR                   m_pszSendMsgUrl;    // Url to post outbound messages to
};

#endif // __HTTPTASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\imaptask.cpp ===
//***************************************************************************
// IMAP4 Spooler Task Object
// Written by Raymond Cheng, 6/27/97
//***************************************************************************

//---------------------------------------------------------------------------
// Includes
//---------------------------------------------------------------------------
#include "pch.hxx"
#include "resource.h"
#include "imaptask.h"
#include "imnact.h"
#include "conman.h"
#include "imapfmgr.h"
#include "thormsgs.h"
#include "imaputil.h"
#include "xpcomm.h"
#include "ourguid.h"


//---------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------


//***************************************************************************
// Function: CIMAPTask (Constructor)
//***************************************************************************
CIMAPTask::CIMAPTask(void)
{
    m_lRefCount = 1;
    m_pBindContext = NULL;
    m_pSpoolerUI = NULL;
    m_szAccountName[0] = '\0';
    m_pszFolder = NULL;
    m_pIMAPFolderMgr = NULL;
    m_hwnd = NULL;
    m_CurrentEID = 0;
    m_fFailuresEncountered = FALSE;
    m_dwTotalTicks = 0;
    m_dwFlags = 0;
} // CIMAPTask (constructor)



//***************************************************************************
// Function: ~CIMAPTask (Destructor)
//***************************************************************************
CIMAPTask::~CIMAPTask(void)
{
    if (NULL != m_pIMAPFolderMgr) {
        m_pIMAPFolderMgr->Close();
        m_pIMAPFolderMgr->Release();
    }

    if (NULL != m_pSpoolerUI)
        m_pSpoolerUI->Release();

    if (NULL != m_pBindContext)
        m_pBindContext->Release();

    if (NULL != m_hwnd)
        DestroyWindow(m_hwnd);
} // ~CIMAPTask (destructor)



//***************************************************************************
// Function: QueryInterface
//
// Purpose:
//   Read the Win32SDK OLE Programming References (Interfaces) about the
// IUnknown::QueryInterface function for details. This function returns a
// pointer to the requested interface.
//
// Arguments:
//   REFIID iid [in] - an IID identifying the interface to return.
//   void **ppvObject [out] - if successful, this function returns a pointer
//     to the requested interface in this argument.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::QueryInterface(REFIID iid, void **ppvObject)
{
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppvObject);

    // Init variables, arguments
    hrResult = E_NOINTERFACE;
    if (NULL == ppvObject)
        goto exit;

    *ppvObject = NULL;

    // Find a ptr to the interface
    if (IID_IUnknown == iid) {
        *ppvObject = (IUnknown *) this;
        ((IUnknown *) this)->AddRef();
    }

    if (IID_ISpoolerTask == iid) {
        *ppvObject = (ISpoolerTask *) this;
        ((ISpoolerTask *) this)->AddRef();
    }

    // If we returned an interface, return success
    if (NULL != *ppvObject)
        hrResult = S_OK;

exit:
    return hrResult;
} // QueryInterface



//***************************************************************************
// Function: AddRef
//
// Purpose:
//   This function should be called whenever someone makes a copy of a
// pointer to this object. It bumps the reference count so that we know
// there is one more pointer to this object, and thus we need one more
// release before we delete ourselves.
//
// Returns:
//   A ULONG representing the current reference count. Although technically
// our reference count is signed, we should never return a negative number,
// anyways.
//***************************************************************************
ULONG STDMETHODCALLTYPE CIMAPTask::AddRef(void)
{
    Assert(m_lRefCount > 0);

    m_lRefCount += 1;

    DOUT ("CIMAPTask::AddRef, returned Ref Count=%ld", m_lRefCount);
    return m_lRefCount;
} // AddRef



//***************************************************************************
// Function: Release
//
// Purpose:
//   This function should be called when a pointer to this object is to
// go out of commission. It knocks the reference count down by one, and
// automatically deletes the object if we see that nobody has a pointer
// to this object.
//
// Returns:
//   A ULONG representing the current reference count. Although technically
// our reference count is signed, we should never return a negative number,
// anyways.
//***************************************************************************
ULONG STDMETHODCALLTYPE CIMAPTask::Release(void)
{
    Assert(m_lRefCount > 0);
    
    m_lRefCount -= 1;
    DOUT("CIMAPTask::Release, returned Ref Count = %ld", m_lRefCount);

    if (0 == m_lRefCount) {
        delete this;
        return 0;
    }
    else
        return m_lRefCount;
} // Release

static const char c_szIMAPTask[] = "IMAP Task";

//***************************************************************************
// Function: Init
// Purpose: ISpoolerTask implementation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::Init(DWORD dwFlags,
                                          ISpoolerBindContext *pBindCtx)
{
    WNDCLASSEX wc;
    HRESULT hrResult;
    
    Assert(m_lRefCount > 0);
    Assert(NULL != pBindCtx);

    // Initialize variables
    hrResult = S_OK;

    // Save pBindCtx to module var
    m_pBindContext = pBindCtx;
    pBindCtx->AddRef();
    m_dwFlags = dwFlags;

    // Create a hidden window to process WM_IMAP_* messages
    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, c_szIMAPTask, &wc)) {
        wc.style            = 0;
        wc.lpfnWndProc      = IMAPTaskWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hCursor          = NULL;
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szIMAPTask;
        wc.hIcon            = NULL;
        wc.hIconSm          = NULL;

        RegisterClassEx(&wc);
    }

    m_hwnd = CreateWindow(c_szIMAPTask, NULL, WS_POPUP, 10, 10, 10, 10,
                          GetDesktopWindow(), NULL, g_hInst, this);
    if (NULL == m_hwnd) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

exit:
    return hrResult;
} // Init



//***************************************************************************
// Function: BuildEvents
// Purpose: ISpoolerTask implementation.
// Arguments:
//   LPCTSTR pszFolder [in] - currently this argument is taken to mean the
//     currently selected IMAP folder. Set this argument to NULL if no
//     IMAP folder is currently selected. This argument is used to avoid
//     polling the currently selected folder for its unread count.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::BuildEvents(ISpoolerUI *pSpoolerUI,
                                                 IImnAccount *pAccount,
                                                 LPCTSTR pszFolder)
{
    HRESULT hrResult;
    char szFmt[CCHMAX_STRINGRES], szEventDescription[CCHMAX_STRINGRES];
    EVENTID eidThrowaway;

    Assert(m_lRefCount > 0);
    Assert(NULL != pSpoolerUI);
    Assert(NULL != pAccount);

    // Copy spooler UI pointer
    m_pSpoolerUI = pSpoolerUI;
    pSpoolerUI->AddRef();

    // Find and save account name
    hrResult = pAccount->GetPropSz(AP_ACCOUNT_NAME, m_szAccountName,
        sizeof(m_szAccountName));
    if (FAILED(hrResult))
        goto exit;

    // Keep ptr to current folder name (we want to SKIP it during unread poll!)
    m_pszFolder = pszFolder;

#ifndef WIN16   // No RAS support in Win16
    // Create and initialize CIMAPFolderMgr to poll unread
    hrResult = g_pConMan->CanConnect(m_szAccountName);
    if (FAILED(hrResult))
        goto exit;
#endif
    
    m_pIMAPFolderMgr = new CIMAPFolderMgr(m_hwnd);
    if (NULL == m_pIMAPFolderMgr) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

    hrResult = m_pIMAPFolderMgr->HrInit(m_szAccountName, 'i', fCREATE_FLDR_CACHE);
    if (FAILED(hrResult))
        goto exit;

    m_pIMAPFolderMgr->SetOnlineOperation(TRUE);
    m_pIMAPFolderMgr->SetUIMode(!(m_dwFlags & DELIVER_BACKGROUND));

    // This CIMAPFolderMgr is ready. Register our one and only event
    LoadString(g_hLocRes, IDS_SPS_POP3CHECKING, szFmt, ARRAYSIZE(szFmt));
    wsprintf(szEventDescription, szFmt, m_szAccountName);
    hrResult = m_pBindContext->RegisterEvent(szEventDescription, this, NULL,
        pAccount, &eidThrowaway);

    if (SUCCEEDED(hrResult))
        TaskUtil_CheckForPasswordPrompt(pAccount, SRV_IMAP, m_pSpoolerUI);

exit:
    return hrResult;
} // BuildEvents



//***************************************************************************
// Function: Execute
// Purpose: ISpoolerTask implementation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::Execute(EVENTID eid, DWORD dwTwinkie)
{
    HRESULT hrResult;
    char szFmt[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];

    Assert(m_lRefCount > 0);
    Assert(NULL == dwTwinkie); // I'm not currently using this

    // Initialize progress indication
    m_pSpoolerUI->SetProgressRange(1);
    LoadString(g_hLocRes, IDS_SPS_POP3CHECKING, szFmt, ARRAYSIZE(szFmt));
    wsprintf(szBuf, szFmt, m_szAccountName);
    m_pSpoolerUI->SetGeneralProgress(szBuf);
    m_pSpoolerUI->SetAnimation(idanDownloadNews, TRUE);

    // Start the unread count poll
    Assert(NULL != m_pIMAPFolderMgr);
    hrResult = m_pIMAPFolderMgr->PollUnreadCounts(m_hwnd, m_pszFolder);
    if (FAILED(hrResult))
        goto exit;

    m_CurrentEID = eid;

exit:
    return hrResult;
} // Execute



//***************************************************************************
// Function: ShowProperties
// Purpose: ISpoolerTask implementation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::ShowProperties(HWND hwndParent,
                                                    EVENTID eid,
                                                    DWORD dwTwinkie)
{
    Assert(m_lRefCount > 0);
    return E_NOTIMPL;
} // ShowProperties



//***************************************************************************
// Function: GetExtendedDetails
// Purpose: ISpoolerTask implementation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::GetExtendedDetails(EVENTID eid,
                                                        DWORD dwTwinkie,
                                                        LPSTR *ppszDetails)
{
    Assert(m_lRefCount > 0);
    return E_NOTIMPL;
} // GetExtendedDetails



//***************************************************************************
// Function: Cancel
// Purpose: ISpoolerTask implementation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::Cancel(void)
{
    Assert(m_lRefCount > 0);
    return m_pIMAPFolderMgr->Disconnect();
} // Cancel



//***************************************************************************
// Function: IsDialogMessage
// Purpose: ISpoolerTask implementation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::IsDialogMessage(LPMSG pMsg)
{
    Assert(m_lRefCount > 0);
    return S_FALSE;
} // IsDialogMessage



//***************************************************************************
// Function: OnFlagsChanged
// Purpose: ISpoolerTask implementation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CIMAPTask::OnFlagsChanged(DWORD dwFlags)
{
    Assert(m_lRefCount > 0);
    m_dwFlags = dwFlags;

    if (m_pIMAPFolderMgr)
        m_pIMAPFolderMgr->SetUIMode(!(m_dwFlags & DELIVER_BACKGROUND));

    return S_OK;
} // OnFlagsChanged



//***************************************************************************
// Function: IMAPTaskWndProc
//
// Purpose:
//   This function handles WM_IMAP_* messages which result from polling for
// unread counts on the IMAP server. The various WM_IMAP_* messages are
// translated into spooler UI events to inform the user of the progress of
// the operation.
//***************************************************************************
LRESULT CALLBACK CIMAPTask::IMAPTaskWndProc(HWND hwnd, UINT uMsg,
                                            WPARAM wParam, LPARAM lParam)
{
    CIMAPTask *pThis = (CIMAPTask *) GetProp(hwnd, _T("this"));

    switch (uMsg) {
        case WM_CREATE:
            pThis = (CIMAPTask *) ((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetProp(hwnd, _T("this"), (LPVOID) pThis);
            return 0;

        case WM_IMAP_ERROR: {
            HRESULT hrResult;
            LPSTR pszErrorStr;

            pThis->m_fFailuresEncountered = TRUE;
            hrResult = ImapUtil_WMIMAPERRORToString(lParam, &pszErrorStr, NULL);
            if (FAILED(hrResult)) {
                AssertSz(FALSE, "Could not construct full error str for WM_IMAP_ERROR");
                pThis->m_pSpoolerUI->InsertError(pThis->m_CurrentEID,
                    ((INETMAILERROR *)lParam)->pszMessage);
            }
            else {
                pThis->m_pSpoolerUI->InsertError(pThis->m_CurrentEID,
                    pszErrorStr);
                MemFree(pszErrorStr);
            }
            return 0;
        } // case WM_IMAP_ERROR

        case WM_IMAP_SIMPLEERROR: {
            char sz[CCHMAX_STRINGRES];

            pThis->m_fFailuresEncountered = TRUE;
            Assert(0 == HIWORD(lParam)); // Can't handle two text strings
            LoadString(g_hLocRes, LOWORD(lParam), sz, ARRAYSIZE(sz));
            pThis->m_pSpoolerUI->InsertError(pThis->m_CurrentEID, sz);
        } // case WM_IMAP_SIMPLEERROR
            return 0;

        case WM_IMAP_POLLUNREAD_DONE: {
            HRESULT hrResult;
            EVENTCOMPLETEDSTATUS ecs;

            Assert((0 == wParam || 1 == wParam) && 0 == lParam);
            ecs = EVENT_SUCCEEDED; // Let's be optimistic
            if (pThis->m_fFailuresEncountered) {
                char sz[CCHMAX_STRINGRES], szFmt[CCHMAX_STRINGRES];

                LoadString(g_hLocRes, idsIMAPPollUnreadFailuresFmt, szFmt, ARRAYSIZE(szFmt));
                wsprintf(sz, szFmt, pThis->m_szAccountName);
                pThis->m_pSpoolerUI->InsertError(pThis->m_CurrentEID, sz);
                ecs = EVENT_WARNINGS;
            }

            if (0 == wParam)
                ecs = EVENT_FAILED;

            hrResult = pThis->m_pBindContext->EventDone(pThis->m_CurrentEID, ecs);
            Assert(SUCCEEDED(hrResult));
            return 0;
        } // case WM_IMAP_POLLUNREAD_DONE

        case WM_IMAP_POLLUNREAD_TICK:
            Assert(0 == lParam);
            if (0 == wParam)
                pThis->m_fFailuresEncountered = TRUE;
            else if (1 == wParam) {
                char sz[CCHMAX_STRINGRES], szFmt[CCHMAX_STRINGRES];

                LoadString(g_hLocRes, idsIMAPPollUnreadIMAP4Fmt, szFmt, ARRAYSIZE(szFmt));
                wsprintf(sz, szFmt, pThis->m_szAccountName);
                pThis->m_fFailuresEncountered = TRUE;
                pThis->m_pSpoolerUI->InsertError(pThis->m_CurrentEID, sz);
            }
            else {
                Assert(2 == wParam);
                if (pThis->m_dwTotalTicks > 0)
                    pThis->m_pSpoolerUI->IncrementProgress(1);
            }
            return 0;

        case WM_IMAP_POLLUNREAD_TOTAL:
            Assert(0 == lParam);
            pThis->m_dwTotalTicks = wParam;
            pThis->m_pSpoolerUI->SetProgressRange(wParam);
            return 0;
    } // switch (uMsg)

    // If we reached this point, we didn't process the msg: DefWindowProc it
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
} // IMAPTaskWndProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\ontask.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     ontask.h
//
//  PURPOSE:    Defines the Offline News task.
//

#ifndef __ONTASK_H__
#define __ONTASK_H__

#include "spoolapi.h"
#include <storutil.h>

/////////////////////////////////////////////////////////////////////////////
// Forward references
//
class CNewsStore;

/////////////////////////////////////////////////////////////////////////////
// Types of events we support
//

typedef struct tagONEVENTINFO
    {
    char  szGroup[256];
    FOLDERID idGroup;
    DWORD dwFlags;
    BOOL  fMarked;
    BOOL  fIMAP;
    } ONEVENTINFO;
    
typedef enum tagONTASKSTATE 
    {
    ONTS_IDLE = 0,          // Idle    
    ONTS_CONNECTING,        // Waiting for a connect response
    ONTS_INIT,              // Initializing
    ONTS_HEADERRESP,        // Waiting for the header download
    ONTS_ALLMSGS,           // Downloading all messages
    ONTS_NEWMSGS,           // Downloading new messages
    ONTS_MARKEDMSGS,        // Downloading marked messages    
    ONTS_END,               // Cleanup
    ONTS_MAX
    } ONTASKSTATE;

typedef enum tagARTICLESTATE
    {
    ARTICLE_GETNEXT,
    ARTICLE_ONRESP,
    ARTICLE_END,

    ARTICLE_MAX
    } ARTICLESTATE;


class COfflineTask;
typedef HRESULT (COfflineTask::*PFNONSTATEFUNC)(THIS_ void);
typedef HRESULT (COfflineTask::*PFNARTICLEFUNC)(THIS_ void);
    
/////////////////////////////////////////////////////////////////////////////
// class COfflineTask
//    
// Overview:
// This object defines and implements the ISpoolerTask interface to handle 
// offline news functions.  This is a separate object from CNewsTask to 
// provide a logical separation between what needs to be done online versus
// what is only done offline in news.
//
class COfflineTask : public ISpoolerTask, public IStoreCallback, public ITimeoutCallback
    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor, destructor, initialization
    COfflineTask();
    ~COfflineTask();    
   
    /////////////////////////////////////////////////////////////////////////
    // IUnknown Interface
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /////////////////////////////////////////////////////////////////////////
    // ISpoolerTask Interface
    STDMETHOD(Init)(THIS_ DWORD dwFlags, ISpoolerBindContext *pBindCtx);
    STDMETHOD(BuildEvents)(THIS_ ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder);
    STDMETHOD(Execute)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHOD(CancelEvent)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHOD(ShowProperties)(THIS_ HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHOD(GetExtendedDetails)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails);
    STDMETHOD(Cancel)(THIS);
    STDMETHOD(IsDialogMessage)(THIS_ LPMSG pMsg);
    STDMETHOD(OnFlagsChanged)(THIS_ DWORD dwFlags);

    /////////////////////////////////////////////////////////////////////////
    // IStoreCallback Interface
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    /////////////////////////////////////////////////////////////////////////
    // ITimeoutCallback Interface
    STDMETHODIMP  OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

private:
    /////////////////////////////////////////////////////////////////////////
    // Window callback and message handling
    static LRESULT CALLBACK TaskWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    /////////////////////////////////////////////////////////////////////////
    // These functions build the event list
    HRESULT InsertGroups(IImnAccount *pAccount, FOLDERID idFolder);
    HRESULT InsertAllGroups(FOLDERID idParent, IImnAccount *pAccount, BOOL fIMAP);

    /////////////////////////////////////////////////////////////////////////
    // State Machine Stuff
    void NextState(void);

    HRESULT Download_Init(void);
    HRESULT Download_AllMsgs(void);
    HRESULT Download_NewMsgs(void);
    HRESULT Download_MarkedMsgs(void);
    HRESULT Download_Done(void);

    HRESULT Article_Init(MESSAGEIDLIST *pList);
    HRESULT Article_GetNext(void);
    HRESULT Article_OnResp(WPARAM wParam, LPARAM lParam);
    HRESULT Article_OnError(WPARAM wParam, LPARAM lParam);
    HRESULT Article_Done(void);

    /////////////////////////////////////////////////////////////////////////
    // Utility functions

    void SetGeneralProgress(const TCHAR *pFmt, ...);
    void SetSpecificProgress(const TCHAR *pFmt, ...);
    void InsertError(const TCHAR *pFmt, ...);

private:
    /////////////////////////////////////////////////////////////////////////
    // Private member data
    ULONG                   m_cRef;

    // State
    BOOL                    m_fInited;
    DWORD                   m_dwFlags;
    ONTASKSTATE             m_state;
    ARTICLESTATE            m_as;
    EVENTID                 m_eidCur;
    ONEVENTINFO            *m_pInfo;
    char                    m_szAccount[CCHMAX_ACCOUNT_NAME];
    char                    m_szAccountId[CCHMAX_ACCOUNT_NAME];
    FOLDERID                m_idAccount;
    DWORD                   m_cEvents;
    BOOL                    m_fDownloadErrors;
    BOOL                    m_fFailed;
    DWORD                   m_fNewHeaders;
    BOOL                    m_fCancel;

    // Spooler Interfaces
    ISpoolerBindContext    *m_pBindCtx;
    ISpoolerUI             *m_pUI;

    IMessageFolder         *m_pFolder;

    // Windows
    HWND                    m_hwnd;

    // State table
    static const PFNONSTATEFUNC m_rgpfnState[ONTS_MAX];
    static const PFNARTICLEFUNC m_rgpfnArticle[ARTICLE_MAX];

    // Used during event execution
    DWORD                   m_dwLast;
    DWORD                   m_dwPrev;
    DWORD                   m_cDownloaded;
    DWORD                   m_cCur;
    DWORD_PTR               m_dwPrevHigh;
    DWORD                   m_dwNewInboxMsgs;
    LPMESSAGEIDLIST         m_pList;

    // Callback 
    HTIMEOUT                m_hTimeout;
    IOperationCancel       *m_pCancel;
    STOREOPERATIONTYPE      m_tyOperation;    
    };
     

    
#endif // __ONTASK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\newstask.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     newstask.h
//
//  PURPOSE:    Implements a task object to take care of news downloads.
//

#ifndef __NEWSTASK_H__
#define __NEWSTASK_H__

#include "spoolapi.h"
#include "newsstor.h"
#include "StorUtil.h"

/////////////////////////////////////////////////////////////////////////////
// Types of events we support

#define HUNDRED_NANOSECONDS 10000000

typedef enum tagEVENTTYPE
    { 
    EVENT_OUTBOX,
    EVENT_NEWMSGS,
    EVENT_IMAPUPLOAD
    } EVENTTYPE;

typedef struct tagEVENTINFO 
    {
    TCHAR       szGroup[256];
    EVENTTYPE   type;
    } EVENTINFO;

typedef enum tagNEWSTASKSTATE
    {
    NTS_IDLE = 0,

    NTS_CONNECTING,

    NTS_POST_INIT,          
    NTS_POST_NEXT,          // Posting states
    NTS_POST_RESP,
    NTS_POST_DISPOSE,
    NTS_POST_END,

    NTS_NEWMSG_INIT,
    NTS_NEWMSG_NEXTGROUP,   // Check for new messages
    NTS_NEWMSG_RESP,
    NTS_NEWMSG_HTTPSYNCSTORE,
    NTS_NEWMSG_HTTPRESP,
    NTS_NEWMSG_END,

    NTS_MAX
    } NEWSTASKSTATE;

typedef struct tagSPLITMSGINFO
{
    FOLDERID                idFolder;
    LPMIMEMESSAGEPARTS      pMsgParts;
    LPMIMEENUMMESSAGEPARTS  pEnumParts;
} SPLITMSGINFO;

class CNewsTask;
typedef HRESULT (CNewsTask::*PFNSTATEFUNC)(THIS_ void);

/////////////////////////////////////////////////////////////////////////////
// class CNewsTask
// 
// Overview:
// This object defines and implements the ISpoolerTask interface to handle
// uploading and downloading information from a news server.
//
class CNewsTask : public ISpoolerTask, public IStoreCallback, public ITimeoutCallback
    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor, destructor, initialization
    CNewsTask();
    ~CNewsTask();    
   
    /////////////////////////////////////////////////////////////////////////
    // IUnknown Interface
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /////////////////////////////////////////////////////////////////////////
    // ISpoolerTask Interface
    STDMETHOD(Init)(THIS_ DWORD dwFlags, ISpoolerBindContext *pBindCtx);
    STDMETHOD(BuildEvents)(THIS_ ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder);
    STDMETHOD(Execute)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHOD(CancelEvent)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHOD(ShowProperties)(THIS_ HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHOD(GetExtendedDetails)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails);
    STDMETHOD(Cancel)(THIS);
    STDMETHOD(IsDialogMessage)(THIS_ LPMSG pMsg);
    STDMETHOD(OnFlagsChanged)(THIS_ DWORD dwFlags);

    /////////////////////////////////////////////////////////////////////////
    // IStoreCallback Interface
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    /////////////////////////////////////////////////////////////////////////
    // ITimeoutCallback Interface
    STDMETHODIMP  OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

protected:
    /////////////////////////////////////////////////////////////////////////
    // Window callback and message handling
    static LRESULT CALLBACK TaskWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                        LPARAM lParam);

    /////////////////////////////////////////////////////////////////////////
    // These functions build the event list
    HRESULT InsertOutbox(LPTSTR szAccount, IImnAccount *pAccount);
    HRESULT InsertNewMsgs(LPTSTR pszAccount, IImnAccount *pAccount, BOOL fHttp);

    /////////////////////////////////////////////////////////////////////////
    // State Machine Stuff
    void NextState(void);

    /////////////////////////////////////////////////////////////////////////
    // Utility functions
    HRESULT DisposeOfPosting(MESSAGEID dwMsgID);

public:
    /////////////////////////////////////////////////////////////////////////
    // Functions that upload posts
    HRESULT Post_Init(void);
    HRESULT Post_NextPart(void);
    HRESULT Post_NextMsg(void);
    HRESULT Post_Dispose(void);
    HRESULT Post_Done(void);

    /////////////////////////////////////////////////////////////////////////
    // Functions that check for new messages
    HRESULT NewMsg_Init(void);
    HRESULT NewMsg_InitHttp(void);
    HRESULT NewMsg_NextGroup(void);
    HRESULT NewMsg_HttpSyncStore(void);
    HRESULT NewMsg_Done(void);

private:
    void FreeSplitInfo(void);

    /////////////////////////////////////////////////////////////////////////
    // Private member data
    ULONG                   m_cRef;         // Object reference count

    // State
    BOOL                    m_fInited;      // TRUE if we've been initialized
    DWORD                   m_dwFlags;      // Flags passed in from the spooler engine
    NEWSTASKSTATE           m_state;        // Current state of the task
    EVENTID                 m_eidCur;       // Currently executing event
    EVENTINFO              *m_pInfo;        // EVENTINFO for the current event
    BOOL                    m_fConnectFailed;
    TCHAR                   m_szAccount[256];
    TCHAR                   m_szAccountId[256];
    FOLDERID                m_idAccount;
    DWORD                   m_cEvents;      // Number of events left to execute
    BOOL                    m_fCancel;
    IImnAccount             *m_pAccount;

    // Spooler Interfaces
    ISpoolerBindContext    *m_pBindCtx;     // Interface to communicate with the spooler engine
    ISpoolerUI             *m_pUI;          // Interface to communicate with the UI

    // News Object Pointers
    IMessageServer         *m_pServer;      // Pointer to the transport object
    IMessageFolder         *m_pOutbox;      // Pointer to the outbox
    IMessageFolder         *m_pSent;        // Pointer to the sent items folder

    // Windows
    HWND                    m_hwnd;         // Handle that recieves transport messages

    // Posting
    int                     m_cMsgsPost;    // Number of messages to post
    int                     m_cCurPost;     // Message currently being posted
    int                     m_cFailed;      // Number of messages which failed to post
    int                     m_cCurParts;    // Number of parts the current message includes
    int                     m_cPartsCompleted;  // Number of parts whose post have completed.
    BOOL                    m_fPartFailed;  // Did one of the parts fail?
    LPMESSAGEINFO           m_rgMsgInfo;    // Array of headers for messages to post
    SPLITMSGINFO           *m_pSplitInfo;
    
    // New messages check
    int                     m_cGroups;      // Number of groups we're checking
    int                     m_cCurGroup;    // Current group we're checking
    FOLDERID               *m_rgidGroups;   // Array of group folderids we're checking
    DWORD                   m_dwNewInboxMsgs; // Number of new msgs detected in Inbox

    // Callback 
    HTIMEOUT                m_hTimeout;
    IOperationCancel       *m_pCancel;
    STOREOPERATIONTYPE      m_tyOperation;    
    };

#endif // __NEWSTASK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\pop3task.cpp ===
// --------------------------------------------------------------------------------
// Pop3task.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "pop3task.h"
#include "resource.h"
#include "xputil.h"
#include "goptions.h"
#include "strconst.h"
#include "mimeutil.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "options.h"
#include "xpcomm.h"
#include "ourguid.h"
#include "msgfldr.h"
#include "storecb.h"
#include "mailutil.h"
#include "ruleutil.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Debug Modifiers
// --------------------------------------------------------------------------------
#ifdef DEBUG
BOOL g_fUidlByTop = FALSE;
BOOL g_fFailTopCommand = FALSE;
LONG g_ulFailNumber=-1;
#endif

// --------------------------------------------------------------------------------
// ISLASTPOPID
// --------------------------------------------------------------------------------
#define ISLASTPOPID(_dwPopId) \
    (_dwPopId == m_rTable.cItems)

// --------------------------------------------------------------------------------
// ISVALIDPOPID
// --------------------------------------------------------------------------------
#define ISVALIDPOPID(_dwPopId) \
    (_dwPopId - 1 < m_rTable.cItems)

// --------------------------------------------------------------------------------
// ITEMFROMPOPID
// --------------------------------------------------------------------------------
#define ITEMFROMPOPID(_dwPopId) \
    (&m_rTable.prgItem[_dwPopId - 1])

// --------------------------------------------------------------------------------
// CPop3Task::CPop3Task
// --------------------------------------------------------------------------------
CPop3Task::CPop3Task(void)
{
    m_cRef = 1;
    m_dwFlags = 0;
    m_dwState = 0;
    m_dwExpireDays = 0;
    m_pSpoolCtx = NULL;
    m_pAccount = NULL;
    m_pTransport = NULL;
    m_pUI = NULL;
    m_pIExecRules = NULL;
    m_pIRuleSender = NULL;
    m_pIRuleJunk = NULL;
    m_pInbox = NULL;
    m_pOutbox = NULL;
    m_eidEvent = 0;
    m_pUidlCache = NULL;
    m_uidlsupport = UIDL_SUPPORT_NONE;
    m_dwProgressMax = 0;
    m_dwProgressCur = 0;
    m_wProgress = 0;
    m_eidEvent = 0;
    m_hrResult = S_OK;
    m_pStream = NULL;
    m_state = POP3STATE_NONE;
    m_hwndTimeout = NULL;
    m_pLogFile = NULL;
    m_pSmartLog = NULL;
    *m_szAccountId = '\0';
    ZeroMemory(&m_rMetrics, sizeof(POP3METRICS));
    ZeroMemory(&m_rFolder, sizeof(POP3FOLDERINFO));
    ZeroMemory(&m_rTable, sizeof(POP3ITEMTABLE));
    ZeroMemory(&m_rServer, sizeof(INETSERVER));
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CPop3Task::~CPop3Task
// --------------------------------------------------------------------------------
CPop3Task::~CPop3Task(void)
{
    // Reset the Object
    _ResetObject(TRUE);

    // Kill the critical section
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CPop3Task::_ResetObject
// --------------------------------------------------------------------------------
void CPop3Task::_ResetObject(BOOL fDeconstruct)
{
    // Release Folder Objects
    _ReleaseFolderObjects();

    // Make sure the transport is disconnect
    if (m_pTransport)
    {
        m_pTransport->Release();
        m_pTransport = NULL;
    }

    // Release the Outbox
    SafeRelease(m_pAccount);
    SafeRelease(m_pInbox);
    SafeRelease(m_pOutbox);
    SafeRelease(m_pIExecRules);
    SafeRelease(m_pIRuleSender);
    SafeRelease(m_pIRuleJunk);
    SafeRelease(m_pSpoolCtx);
    SafeRelease(m_pUI);
    SafeRelease(m_pUidlCache);
    SafeRelease(m_pStream);
    SafeRelease(m_pLogFile);

    // Kill the log file
    _FreeSmartLog();

    // Free the event table elements
    _FreeItemTableElements();

    // Deconstructing
    if (fDeconstruct)
    {
        // Free Event Table
        SafeMemFree(m_rTable.prgItem);
    }

    // Otherwise, reset some vars
    else
    {
        // Reset total byte count
        m_dwFlags = 0;
        m_dwState = 0;
        m_dwExpireDays = 0;
        m_eidEvent = 0;
        m_wProgress = 0;
        m_uidlsupport = UIDL_SUPPORT_NONE;
        m_state = POP3STATE_NONE;
        ZeroMemory(&m_rFolder, sizeof(POP3FOLDERINFO));
        ZeroMemory(&m_rMetrics, sizeof(POP3METRICS));
        ZeroMemory(&m_rServer, sizeof(INETSERVER));
    }
}

// --------------------------------------------------------------------------------
// CPop3Task::_ReleaseFolderObjects
// --------------------------------------------------------------------------------
void CPop3Task::_ReleaseFolderObjects(void)
{
    // m_rFolder should have been release
    _CloseFolder();

    // Force Inbox Rules to release folder objects
    if (m_pIExecRules)
    {
        m_pIExecRules->ReleaseObjects();
    }

    // Download only locks the inbox
    SafeRelease(m_pInbox);
}

// --------------------------------------------------------------------------------
// CPop3Task::_FreeItemTableElements
// --------------------------------------------------------------------------------
void CPop3Task::_FreeItemTableElements(void)
{
    // Loop the table of events
    for (ULONG i=0; i<m_rTable.cItems; i++)
    {
        // Free pszForwardTo
        SafeMemFree(m_rTable.prgItem[i].pszUidl);
        RuleUtil_HrFreeActionsItem(m_rTable.prgItem[i].pActList, m_rTable.prgItem[i].cActList);
        SafeMemFree(m_rTable.prgItem[i].pActList);
    }

    // No Events
    m_rTable.cItems = 0;
}

// --------------------------------------------------------------------------------
// CPop3Task::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(ISpoolerTask *)this;
    else if (IID_ISpoolerTask == riid)
        *ppv = (ISpoolerTask *)this;
    else if (IID_ITimeoutCallback == riid)
        *ppv = (ITimeoutCallback *) this;
    else if (IID_ITransportCallbackService == riid)
        *ppv = (ITransportCallbackService *) this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::CPop3Task
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPop3Task::AddRef(void)
{
    EnterCriticalSection(&m_cs);
    ULONG cRef = ++m_cRef;
    LeaveCriticalSection(&m_cs);
    return cRef;
}

// --------------------------------------------------------------------------------
// CPop3Task::CPop3Task
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPop3Task::Release(void)
{
    EnterCriticalSection(&m_cs);
    ULONG cRef = --m_cRef;
    LeaveCriticalSection(&m_cs);
    if (0 != cRef)
        return cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CPop3Task::Init
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx)
{
    // Invalid Arg
    if (NULL == pBindCtx)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Reset this object
    _ResetObject(FALSE);

    // Save the Activity Flags - DELIVER_xxx
    m_dwFlags = dwFlags;

    // Hold onto the bind context
    Assert(NULL == m_pSpoolCtx);
    m_pSpoolCtx = pBindCtx;
    m_pSpoolCtx->AddRef();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPop3Task::BuildEvents
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder)
{
    // Locals
    HRESULT       hr=S_OK;
    DWORD         dw;
    CHAR          szAccountName[CCHMAX_ACCOUNT_NAME];
    CHAR          szRes[CCHMAX_RES];
    CHAR          szMessage[CCHMAX_RES + CCHMAX_ACCOUNT_NAME];
    LPSTR         pszLogFile=NULL;
    DWORD         dwState;
    PROPVARIANT   propvar = {0};

    // Invalid Arg
    if (NULL == pSpoolerUI || NULL == pAccount)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(NULL == m_pTransport && NULL == m_pAccount && NULL == m_pInbox && 0 == m_rTable.cItems);

    // Save the UI Object
    m_pUI = pSpoolerUI;
    m_pUI->AddRef();

    // Release current Account
    m_pAccount = pAccount;
    m_pAccount->AddRef();

    // Leave mail on server
    if (SUCCEEDED(m_pAccount->GetPropDw(AP_POP3_LEAVE_ON_SERVER, &dw)) && TRUE == dw)
        FLAGSET(m_dwState, POP3STATE_LEAVEONSERVER);

    // Delete Expire
    if (SUCCEEDED(m_pAccount->GetPropDw(AP_POP3_REMOVE_EXPIRED, &dw)) && TRUE == dw)
        FLAGSET(m_dwState, POP3STATE_DELETEEXPIRED);

    // Days to Expire
    if (FAILED(m_pAccount->GetPropDw(AP_POP3_EXPIRE_DAYS, &m_dwExpireDays)))
        m_dwExpireDays = 5;

    // Delete From Server when deleted from Deleted Items Folder...
    if (SUCCEEDED(m_pAccount->GetPropDw(AP_POP3_REMOVE_DELETED, &dw)) && TRUE == dw)
        FLAGSET(m_dwState, POP3STATE_SYNCDELETED);

    // Get the inbox rules object
    Assert(g_pRulesMan);
    CHECKHR(hr = g_pRulesMan->ExecRules(EXECF_ALL, RULE_TYPE_MAIL, &m_pIExecRules));

    // Get the block sender rule
    Assert(NULL == m_pIRuleSender);
    (VOID) g_pRulesMan->GetRule(RULEID_SENDERS, RULE_TYPE_MAIL, 0, &m_pIRuleSender);

    // Only use it if it there and enabled
    if (NULL != m_pIRuleSender)
    {
        if (FAILED(m_pIRuleSender->GetProp(RULE_PROP_DISABLED, 0, &propvar)))
        {
            m_pIRuleSender->Release();
            m_pIRuleSender = NULL;
        }
        else
        {
            Assert(VT_BOOL == propvar.vt);
            if (FALSE != propvar.boolVal)
            {
                m_pIRuleSender->Release();
                m_pIRuleSender = NULL;
            }

            PropVariantClear(&propvar);
        }
    }
    
    Assert(NULL == m_pIRuleJunk);
    (VOID) g_pRulesMan->GetRule(RULEID_JUNK, RULE_TYPE_MAIL, 0, &m_pIRuleJunk);
    
    // Only use it if it enabled
    if (NULL != m_pIRuleJunk)
    {
        if (FAILED(m_pIRuleJunk->GetProp(RULE_PROP_DISABLED, 0, &propvar)))
        {
            m_pIRuleJunk->Release();
            m_pIRuleJunk = NULL;
        }
        else
        {
            Assert(VT_BOOL == propvar.vt);
            if (FALSE != propvar.boolVal)
            {
                m_pIRuleJunk->Release();
                m_pIRuleJunk = NULL;
            }

            PropVariantClear(&propvar);
        }
    }
    
    // Predownload rules
    CHECKHR(hr = m_pIExecRules->GetState(&dwState));

    // Do we have server actions to do?
    if (0 != (dwState & ACT_STATE_SERVER))
        FLAGSET(m_dwState, POP3STATE_PDR);

    // No Post Download Rules
    if ((0 == (dwState & (ACT_STATE_LOCAL|CRIT_STATE_ALL))) && 
              (NULL == m_pIRuleSender) && 
              (NULL == m_pIRuleJunk))
        FLAGSET(m_dwState, POP3STATE_NOPOSTRULES);

    // No Body Rules
    if ((ISFLAGSET(dwState, CRIT_STATE_ALL)) || (NULL != m_pIRuleJunk))
        FLAGSET(m_dwState, POP3STATE_BODYRULES);

    // Get the outbox
    CHECKHR(hr = m_pSpoolCtx->BindToObject(IID_CLocalStoreOutbox, (LPVOID *)&m_pOutbox));

    // Get a pop3 log file
    m_pSpoolCtx->BindToObject(IID_CPop3LogFile, (LPVOID *)&m_pLogFile);

    // Get Account Id
    CHECKHR(hr = m_pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccountName, ARRAYSIZE(szAccountName)));

    // Register Event - Get new messages from '%s'.
    LOADSTRING(IDS_SPS_POP3EVENT, szRes);

    // Format the String
    wsprintf(szMessage, szRes, szAccountName);

    // Register for the event...
    CHECKHR(hr = m_pSpoolCtx->RegisterEvent(szMessage, (ISpoolerTask *)this, POP3EVENT_DOWNLOADMAIL, m_pAccount, &m_eidEvent));

exit:
    // Failure
    if (FAILED(hr))
    {
        _CatchResult(hr);
        _ResetObject(FALSE);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_DoSmartLog
// --------------------------------------------------------------------------------
void CPop3Task::_DoSmartLog(IMimeMessage *pMessage)
{
    // Don't make the function call if this is null...
    Assert(m_pSmartLog && m_pSmartLog->pStmFile && m_pSmartLog->pszProperty && m_pSmartLog->pszValue && pMessage);

    // Do a query property...
    if (lstrcmpi("all", m_pSmartLog->pszProperty) == 0 || S_OK == pMessage->QueryProp(m_pSmartLog->pszProperty, m_pSmartLog->pszValue, TRUE, FALSE))
    {
        // Locals
        LPSTR       psz=NULL;
        PROPVARIANT rVariant;
        IStream     *pStream=NULL;

        // Get IAT_FROM
        if (FAILED(pMessage->GetAddressFormat(IAT_FROM, AFT_DISPLAY_BOTH, &psz)))
        {
            // Try IAT_SENDER
            pMessage->GetAddressFormat(IAT_SENDER, AFT_DISPLAY_BOTH, &psz);
        }

        // Write the Sender
        if (psz)
        {
            // Write It
            SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(psz, lstrlen(psz), NULL)));

            // Free psz
            SafeMemFree(psz);
        }

        // Otherwise, write Unknown
        else
        {
            CHAR sz[255];
            LoadString(g_hLocRes, idsUnknown, sz, ARRAYSIZE(sz));
            SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(sz, lstrlen(sz), NULL)));
        }

        // Write a tab
        SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write("\t", 1, NULL)));

        // Get IAT_CC
        if (SUCCEEDED(pMessage->GetAddressFormat(IAT_CC, AFT_DISPLAY_BOTH, &psz)))
        {
            // Write It
            SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(psz, lstrlen(psz), NULL)));

            // Free psz
            SafeMemFree(psz);
        }

        // Write a tab
        SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write("\t", 1, NULL)));

        // Lets write the X-Mailer just to be a nice guy
        rVariant.vt = VT_LPSTR;
        if (SUCCEEDED(pMessage->GetProp(PIDTOSTR(PID_HDR_XMAILER), 0, &rVariant)))
        {
            // Write It
            SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(rVariant.pszVal, lstrlen(rVariant.pszVal), NULL)));

            // Free psz
            SafeMemFree(rVariant.pszVal);
        }

        // Write a tab
        SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write("\t", 1, NULL)));

        // Lets write the X-MimeOLE just to be a nice guy
        rVariant.vt = VT_LPSTR;
        if (SUCCEEDED(pMessage->GetProp("X-MimeOLE", 0, &rVariant)))
        {
            // Write It
            SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(rVariant.pszVal, lstrlen(rVariant.pszVal), NULL)));

            // Free psz
            SafeMemFree(rVariant.pszVal);
        }

        // Write a tab
        SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write("\t", 1, NULL)));

        // Lets write the Subject just to be a nice guy
        rVariant.vt = VT_LPSTR;
        if (SUCCEEDED(pMessage->GetProp(PIDTOSTR(PID_HDR_DATE), 0, &rVariant)))
        {
            // Write It
            SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(rVariant.pszVal, lstrlen(rVariant.pszVal), NULL)));

            // Free psz
            SafeMemFree(rVariant.pszVal);
        }

        // Write a tab
        SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write("\t", 1, NULL)));

        // Lets write the Subject just to be a nice guy
        rVariant.vt = VT_LPSTR;
        if (SUCCEEDED(pMessage->GetProp(PIDTOSTR(PID_HDR_SUBJECT), 0, &rVariant)))
        {
            // Write It
            SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(rVariant.pszVal, lstrlen(rVariant.pszVal), NULL)));

            // Free psz
            SafeMemFree(rVariant.pszVal);
        }

        // Write a tab
        SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write("\t", 1, NULL)));

        // Write the first line of the message body
        if (FAILED(pMessage->GetTextBody(TXT_PLAIN, IET_DECODED, &pStream, NULL)))
        {
            // Try to get the HTML body
            if (FAILED(pMessage->GetTextBody(TXT_HTML, IET_DECODED, &pStream, NULL)))
                pStream = NULL;
        }

        // Did we find a stream
        if (pStream)
        {
            // Locals
            BYTE        rgBuffer[1048];
            ULONG       cbRead;
            ULONG       i;
            ULONG       cGood=0;

            // Read a buffer
            if (SUCCEEDED(pStream->Read(rgBuffer, sizeof(rgBuffer), &cbRead)))
            {
                // Write until we hit a \r or \n
                for (i=0; i<cbRead; i++)
                {
                    // End of line
                    if ('\r' == rgBuffer[i] || '\n' == rgBuffer[i])
                    {
                        // If we found 3 or more non-space chars, we found the first line
                        if (cGood > 3)
                            break;

                        // Otherwise, continue...
                        else
                        {
                            rgBuffer[i] = ' ';
                            cGood = 0;
                            continue;
                        }
                    }

                    // Replace Tabs with spaces so that it doesn't mess up tab delimited file
                    if ('\t' == rgBuffer[i])
                        rgBuffer[i] = ' ';

                    // If not a space
                    if (FALSE == FIsSpaceA((LPSTR)(rgBuffer + i)))
                        cGood++;
                }

                // Write the character
                m_pSmartLog->pStmFile->Write(rgBuffer, ((i > 0) ? i - 1 : i), NULL);
            }

            // Free psz
            SafeRelease(pStream);
        }

        // Write a tab
        SideAssert(SUCCEEDED(m_pSmartLog->pStmFile->Write(g_szCRLF, lstrlen(g_szCRLF), NULL)));
    }
}

// --------------------------------------------------------------------------------
// CPop3Task::_FreeSmartLog
// --------------------------------------------------------------------------------
void CPop3Task::_FreeSmartLog(void)
{
    if (m_pSmartLog)
    {
        SafeMemFree(m_pSmartLog->pszAccount);
        SafeMemFree(m_pSmartLog->pszProperty);
        SafeMemFree(m_pSmartLog->pszValue);
        SafeMemFree(m_pSmartLog->pszLogFile);
        SafeRelease(m_pSmartLog->pStmFile);
        g_pMalloc->Free(m_pSmartLog);
        m_pSmartLog = NULL;
    }
}

// --------------------------------------------------------------------------------
// CPop3Task::_ReadSmartLogEntry
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_ReadSmartLogEntry(HKEY hKey, LPCSTR pszKey, LPSTR *ppszValue)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cb;

    // Read the pszKey
    if (RegQueryValueEx(hKey, pszKey, NULL, NULL, NULL, &cb) != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Allocate
    cb++;
    CHECKALLOC(*ppszValue = PszAllocA(cb));

    // Read the pszKey
    if (RegQueryValueEx(hKey, pszKey, NULL, NULL, (LPBYTE)*ppszValue, &cb) != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto exit;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_InitializeSmartLog
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_InitializeSmartLog(void)
{
    // Locals
    HRESULT         hr=S_OK;
    HKEY            hKey=NULL;
    ULARGE_INTEGER  uliPos = {0,0};
    LARGE_INTEGER   liOrigin = {0,0};

    // Get Advanced Logging Information
    if (AthUserOpenKey(c_szRegPathSmartLog, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Allocate smart log
    CHECKALLOC(m_pSmartLog = (LPSMARTLOGINFO)g_pMalloc->Alloc(sizeof(SMARTLOGINFO)));

    // Zero Init
    ZeroMemory(m_pSmartLog, sizeof(SMARTLOGINFO));

    // Read the Account
    CHECKHR(hr = _ReadSmartLogEntry(hKey, "Account", &m_pSmartLog->pszAccount));

    // Read the Property
    CHECKHR(hr = _ReadSmartLogEntry(hKey, "Property", &m_pSmartLog->pszProperty));

    // Read the ContainsValue
    CHECKHR(hr = _ReadSmartLogEntry(hKey, "ContainsValue", &m_pSmartLog->pszValue));

    // Read the LogFile
    CHECKHR(hr = _ReadSmartLogEntry(hKey, "LogFile", &m_pSmartLog->pszLogFile));

    // Open the logfile
    CHECKHR(hr = OpenFileStream(m_pSmartLog->pszLogFile, OPEN_ALWAYS, GENERIC_WRITE | GENERIC_READ, &m_pSmartLog->pStmFile));

    // Seek to the end
    CHECKHR(hr = m_pSmartLog->pStmFile->Seek(liOrigin, STREAM_SEEK_END, &uliPos));

exit:
    // Failure
    if (FAILED(hr))
        _FreeSmartLog();

    // Cleanup
    if (hKey)
        RegCloseKey(hKey);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::Execute
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::Execute(EVENTID eid, DWORD_PTR dwTwinkie)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szRes[CCHMAX_RES];
    CHAR        szBuf[CCHMAX_RES + CCHMAX_SERVER_NAME];
    DWORD       cb;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check State
    Assert(eid == m_eidEvent && m_pAccount && m_pUI);

    // Create the Transport Object
    CHECKHR(hr = CreatePOP3Transport(&m_pTransport));

    // Init the Transport
    CHECKHR(hr = m_pTransport->InitNew(NULL, (IPOP3Callback *)this));

    // Fill an INETSERVER structure from the account object
    CHECKHR(hr = m_pTransport->InetServerFromAccount(m_pAccount, &m_rServer));

    // Get Account Id
    CHECKHR(hr = m_pAccount->GetPropSz(AP_ACCOUNT_ID, m_szAccountId, ARRAYSIZE(m_szAccountId)));

    // Always connect using the most recently supplied password from the user
    hr = GetPassword(m_rServer.dwPort, m_rServer.szServerName, m_rServer.szUserName,
        m_rServer.szPassword, sizeof(m_rServer.szPassword));

    // If this account is set to always prompt for password and password isn't
    // already cached, show UI so we can prompt user for password
    if (m_pUI && ISFLAGSET(m_rServer.dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) && FAILED(hr))
    {
        m_pUI->ShowWindow(SW_SHOW);
    }

    // Get Smart Logging INformation
    _InitializeSmartLog();

    // Set the animation
    m_pUI->SetAnimation(idanInbox, TRUE);

    // Setup Progress Meter
    m_pUI->SetProgressRange(100);

    // Connecting to ...
    LoadString(g_hLocRes, idsInetMailConnectingHost, szRes, ARRAYSIZE(szRes));
    wsprintf(szBuf, szRes, m_rServer.szAccount);
    m_pUI->SetGeneralProgress(szBuf);

    // Notify
    m_pSpoolCtx->Notify(DELIVERY_NOTIFY_CONNECTING, 0);

    // Connect
    CHECKHR(hr = m_pTransport->Connect(&m_rServer, TRUE, TRUE));

exit:
    // Failure
    if (FAILED(hr))
    {
        FLAGSET(m_dwState, POP3STATE_EXECUTEFAILED);
        _CatchResult(hr);

        // Tell the transport to release my callback: otherwise I leak
        SideAssert(m_pTransport->HandsOffCallback() == S_OK);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

STDMETHODIMP CPop3Task::CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie)
{
    return(S_OK);
}

// --------------------------------------------------------------------------------
// CPop3Task::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Is there currently a timeout dialog
    if (m_hwndTimeout)
    {
        // Set foreground
        SetForegroundWindow(m_hwndTimeout);
    }
    else
    {
        // Not suppose to be showing UI ?
        if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
        {
            hr = S_FALSE;
            goto exit;
        }

        // Do Timeout Dialog
        m_hwndTimeout = TaskUtil_HwndOnTimeout(m_rServer.szServerName, m_rServer.szAccount, "POP3", m_rServer.dwTimeout, (ITimeoutCallback *) this);

        // Couldn't create the dialog
        if (NULL == m_hwndTimeout)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Always tell the transport to keep on trucking
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnLogonPrompt(LPINETSERVER pInetServer, IInternetTransport *pTransport)
{
    // Locals
    HRESULT hr=S_FALSE;
    char szPassword[CCHMAX_PASSWORD];

    // Check if we have a cached password that's different from current password
    hr = GetPassword(pInetServer->dwPort, pInetServer->szServerName, pInetServer->szUserName,
        szPassword, sizeof(szPassword));
    if (SUCCEEDED(hr) && 0 != lstrcmp(szPassword, pInetServer->szPassword))
    {
        lstrcpyn(pInetServer->szPassword, szPassword, sizeof(pInetServer->szPassword));
        return S_OK;
    }

    hr = S_FALSE; // Re-initialize

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // NOERRORS...
    if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
        goto exit;

    // TaskUtil_OnLogonPrompt
    hr = TaskUtil_OnLogonPrompt(m_pAccount, m_pUI, NULL, pInetServer, AP_POP3_USERNAME,
                                AP_POP3_PASSWORD, AP_POP3_PROMPT_PASSWORD, TRUE);

    // Cache the password for this session
    if (S_OK == hr)
        SavePassword(pInetServer->dwPort, pInetServer->szServerName,
            pInetServer->szUserName, pInetServer->szPassword);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CPop3Task::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport)
{
    // Locals
    HWND        hwnd;
    INT         nAnswer;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid State
    Assert(m_pUI);

    // Get Window
    if (FAILED(m_pUI->GetWindow(&hwnd)))
        hwnd = NULL;

    // I assume this is a critical prompt, so I will not check for no UI mode
    nAnswer = MessageBox(hwnd, pszText, pszCaption, uType);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return nAnswer;
}

// --------------------------------------------------------------------------------
// CPop3Task::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnError(IXPSTATUS ixpstatus, LPIXPRESULT pResult, IInternetTransport *pTransport)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid State
    Assert(m_pUI);

    // Insert Error Into UI
    _CatchResult(POP3_NONE, pResult);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPop3Task::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnCommand(CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport)
{
    // Logging
    if (m_pLogFile && pszLine)
    {
        // Response
        if (CMD_RESP == cmdtype)
            m_pLogFile->WriteLog(LOGFILE_RX, pszLine);

        // Send
        else if (CMD_SEND == cmdtype)
            m_pLogFile->WriteLog(LOGFILE_TX, pszLine);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPop3Task::_CatchResult
// --------------------------------------------------------------------------------
TASKRESULTTYPE CPop3Task::_CatchResult(HRESULT hr)
{
    // Locals
    IXPRESULT   rResult;

    // Build an IXPRESULT
    ZeroMemory(&rResult, sizeof(IXPRESULT));
    rResult.hrResult = hr;

    // Get the SMTP Result Type
    return _CatchResult(POP3_NONE, &rResult);
}

// --------------------------------------------------------------------------------
// CPop3Task::_CatchResult
// --------------------------------------------------------------------------------
TASKRESULTTYPE CPop3Task::_CatchResult(POP3COMMAND command, LPIXPRESULT pResult)
{
    // Locals
    HWND            hwndParent;
    TASKRESULTTYPE  tyTaskResult=TASKRESULT_FAILURE;

    // If Succeeded
    if (SUCCEEDED(pResult->hrResult))
        return TASKRESULT_SUCCESS;

    // Get Window
    if (FAILED(m_pUI->GetWindow(&hwndParent)))
        hwndParent = NULL;

    // Process generic protocol errro
    tyTaskResult = TaskUtil_FBaseTransportError(IXP_POP3, m_eidEvent, pResult, &m_rServer, NULL, m_pUI,
                                                !ISFLAGSET(m_dwFlags, DELIVER_NOUI), hwndParent);

    // Save Result
    m_hrResult = pResult->hrResult;

    // If Task Failure, drop the connection
    if (NULL != m_pTransport)
        m_pTransport->DropConnection();

    // Return Result
    return tyTaskResult;
}

// --------------------------------------------------------------------------------
// CPop3Task::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnStatus(IXPSTATUS ixpstatus, IInternetTransport *pTransport)
{
    // Locals
    EVENTCOMPLETEDSTATUS tyEventStatus=EVENT_SUCCEEDED;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid State
    Assert(m_pUI && m_pSpoolCtx);

    // Feed the the IXP status to the UI object
    m_pUI->SetSpecificProgress(MAKEINTRESOURCE(XPUtil_StatusToString(ixpstatus)));

    // Disconnected
    if (ixpstatus == IXP_DISCONNECTED)
    {
        // Locals
        BOOL fWarning=FALSE;

        // Note that OnDisconnect was called
        FLAGSET(m_dwState, POP3STATE_ONDISCONNECT);

        // If a UIDL Sync is in progress, then return now...
        if (POP3STATE_UIDLSYNC == m_state)
            goto exit;

        // Kill the timeout dialog
        if (m_hwndTimeout)
        {
            DestroyWindow(m_hwndTimeout);
            m_hwndTimeout = NULL;
        }

        // Cache Cleanup
        _CleanupUidlCache();

        // Reset the progress
        // m_pUI->SetProgressRange(100);

        // State
        m_state = POP3STATE_NONE;

        // Set the animation
        m_pUI->SetAnimation(idanInbox, FALSE);

        // Infinite Loop
        if (m_rMetrics.cInfiniteLoopAutoGens)
        {
            // Load the Warning
            CHAR szRes[CCHMAX_RES];
            LOADSTRING(idsReplyForwardLoop, szRes);

            // Format the Error
            CHAR szMsg[CCHMAX_RES + CCHMAX_ACCOUNT_NAME + CCHMAX_SERVER_NAME + CCHMAX_RES];
            wsprintf(szMsg, szRes, m_rMetrics.cInfiniteLoopAutoGens, m_rServer.szAccount, m_rServer.szServerName);

            // Insert the warning
            m_pUI->InsertError(m_eidEvent, szMsg);

            // Warning
            fWarning = TRUE;
        }

        // Nothing to download
        if (ISFLAGSET(m_dwState, POP3STATE_CANCELPENDING))
            tyEventStatus = EVENT_CANCELED;
        else if (FAILED(m_hrResult) || (m_rMetrics.cDownloaded == 0 && m_rMetrics.cDownload > 0))
            tyEventStatus = EVENT_FAILED;
        else if (!ISFLAGSET(m_dwState, POP3STATE_LOGONSUCCESS))
            tyEventStatus = EVENT_WARNINGS;
        else if (m_rMetrics.cDownloaded && m_rMetrics.cDownload && m_rMetrics.cDownloaded < m_rMetrics.cDownload)
            tyEventStatus = EVENT_WARNINGS;
        else if (fWarning)
            tyEventStatus = EVENT_WARNINGS;

        // Result
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_RESULT, tyEventStatus);

        // Success and messages were downloaded
        if (EVENT_FAILED != tyEventStatus && m_rMetrics.cDownloaded && m_rMetrics.cPartials)
        {
            // Sitch Partials
            _HrStitchPartials();
        }

        // Notify
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_COMPLETE, m_rMetrics.cDownloaded);

        // Tell the transport to release my callback
        SideAssert(m_pTransport->HandsOffCallback() == S_OK);

        // This task is complete
        if (!ISFLAGSET(m_dwState, POP3STATE_EXECUTEFAILED))
            m_pSpoolCtx->EventDone(m_eidEvent, tyEventStatus);
    }

    // Authorizing
    else if (ixpstatus == IXP_AUTHORIZING)
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_AUTHORIZING, 0);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPop3Task::_CleanupUidlCache
// --------------------------------------------------------------------------------
void CPop3Task::_CleanupUidlCache(void)
{
    // Locals
    ULONG       i;
    UIDLRECORD  UidlInfo={0};
    LPPOP3ITEM  pItem;

    // No Cache Objects
    if (NULL == m_pUidlCache)
        return;

    // Count the number of messages we will have to get a top for
    for (i=0; i<m_rTable.cItems; i++)
    {
        // Readability
        pItem = &m_rTable.prgItem[i];

        // Delete the Cached Uidl
        if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DELETED) && ISFLAGSET(pItem->dwFlags, POP3ITEM_DELETECACHEDUIDL))
        {
            // No UIDL
            if (pItem->pszUidl)
            {
                // Set Search Info
                UidlInfo.pszUidl = pItem->pszUidl;
                UidlInfo.pszServer = m_rServer.szServerName;
                UidlInfo.pszAccountId = m_szAccountId;

                // Set Props on the cached uidl message
                m_pUidlCache->DeleteRecord(&UidlInfo);
            }
        }
    }

    // Remove all traces of if the account from the uid cache
    if (ISFLAGSET(m_dwState, POP3STATE_CLEANUPCACHE))
    {
        // Locaks
        HROWSET hRowset=NULL;

        // Create a rowset
        if (SUCCEEDED(m_pUidlCache->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset)))
        {
            // Delete Enumeration
            while (S_OK == m_pUidlCache->QueryRowset(hRowset, 1, (LPVOID *)&UidlInfo, NULL))
            {
                // Delete this puppy ?
                if (lstrcmpi(UidlInfo.pszServer, m_rServer.szServerName) == 0 && 
                    UidlInfo.pszAccountId != NULL &&
                    lstrcmpi(UidlInfo.pszAccountId, m_szAccountId) == 0)
                {
                    // Delete this record
                    m_pUidlCache->DeleteRecord(&UidlInfo);
                }

                // Free
                m_pUidlCache->FreeRecord(&UidlInfo);
            }

            // Purge everthing that matches this
            m_pUidlCache->CloseRowset(&hRowset);
        }
    }
}

// --------------------------------------------------------------------------------
// CPop3Task::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnResponse(LPPOP3RESPONSE pResponse)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Testing UIDL Command
    if (m_uidlsupport == UIDL_SUPPORT_TESTING_UIDL_COMMAND && POP3_UIDL == pResponse->command)
    {
#ifdef DEBUG
        pResponse->rIxpResult.hrResult = g_fUidlByTop ? E_FAIL : pResponse->rIxpResult.hrResult;
#endif
        // Failure ?
        if (FAILED(pResponse->rIxpResult.hrResult))
        {
            // Set Specific Progress
            //CHAR szRes[CCHMAX_RES];
            //LOADSTRING(IDS_SPS_POP3UIDL_UIDL, szRes);
            //m_pUI->SetSpecificProgress(szRes);

            // Try to top command
            _CatchResult(m_pTransport->CommandTOP(POP3CMD_GET_POPID, 1, 0));

            // Testing by top command
            m_uidlsupport = UIDL_SUPPORT_TESTING_TOP_COMMAND;
        }

        // Otherwise
        else
        {
            // State
            m_state = POP3STATE_GETTINGUIDLS;

            // Using the UIDL command
            m_uidlsupport = UIDL_SUPPORT_USE_UIDL_COMMAND;

            // Set Specific Progress
            //CHAR szRes[CCHMAX_RES];
            //LOADSTRING(IDS_SPS_POP3UIDL_UIDL, szRes);
            //m_pUI->SetSpecificProgress(szRes);

            // Issue full UIDL command
            _CatchResult(m_pTransport->CommandUIDL(POP3CMD_GET_ALL, 0));
        }

        // Done
        goto exit;
    }

    // Testing Top Command
    else if (m_uidlsupport == UIDL_SUPPORT_TESTING_TOP_COMMAND && POP3_TOP == pResponse->command)
    {
#ifdef DEBUG
        pResponse->rIxpResult.hrResult = g_fFailTopCommand ? E_FAIL : pResponse->rIxpResult.hrResult;
#endif
        // Failure ?
        if (FAILED(pResponse->rIxpResult.hrResult))
        {
            // Disable the leave on server option in the account
            m_pAccount->SetPropDw(AP_POP3_LEAVE_ON_SERVER, FALSE);

            // Save the Changed
            m_pAccount->SaveChanges();

            // Failure
            _CatchResult(SP_E_CANTLEAVEONSERVER);

            // Done
            goto exit;
        }

        // Using the UIDL command
        else
        {
            // State
            m_state = POP3STATE_GETTINGUIDLS;

            // Set this and fall through to the switch...
            m_uidlsupport = UIDL_SUPPORT_USE_TOP_COMMAND;
        }
    }

#ifdef DEBUG
    if (POP3_RETR == pResponse->command && TRUE == pResponse->fDone && (ULONG)g_ulFailNumber == pResponse->rRetrInfo.dwPopId)
        pResponse->rIxpResult.hrResult = E_FAIL;
#endif

    // If Succeeded
    if (FAILED(pResponse->rIxpResult.hrResult))
    {
        // Get Window
        HWND hwndParent;
        if (FAILED(m_pUI->GetWindow(&hwndParent)))
            hwndParent = NULL;

        // Dont drop if working on POP3_PASS or POP3_USER
        if (POP3_PASS == pResponse->command || POP3_USER == pResponse->command)
        {
            // Log an Error ? If the user's password is not empty or they have fSavePassword enabled
            TaskUtil_FBaseTransportError(IXP_POP3, m_eidEvent, &pResponse->rIxpResult, &m_rServer, NULL, m_pUI, !ISFLAGSET(m_dwFlags, DELIVER_NOUI), hwndParent);

            // Done
            goto exit;
        }

        // Command base Failure
        else if (POP3_RETR == pResponse->command)
        {
            // Message Number %d could not be retrieved."
            CHAR szRes[CCHMAX_RES];
            LoadString(g_hLocRes, IDS_SP_E_RETRFAILED, szRes, ARRAYSIZE(szRes));

            // Format the Error
            CHAR szMsg[CCHMAX_RES + CCHMAX_RES];
            wsprintf(szMsg, szRes, pResponse->rRetrInfo.dwPopId);

            // Fill the IXPRESULT
            IXPRESULT rResult;
            CopyMemory(&rResult, &pResponse->rIxpResult, sizeof(IXPRESULT));
            rResult.pszProblem = szMsg;
            rResult.hrResult = SP_E_POP3_RETR;

            // Insert the Error
            TaskUtil_FBaseTransportError(IXP_POP3, m_eidEvent, &rResult, &m_rServer, NULL, m_pUI, !ISFLAGSET(m_dwFlags, DELIVER_NOUI), hwndParent);

            // Close Current Folder
            _CloseFolder();

            // Retrieve the next message
            _CatchResult(_HrRetrieveNextMessage(pResponse->rRetrInfo.dwPopId));

            // Done
            goto exit;
        }

        // Default Error Handler
        else if (TASKRESULT_SUCCESS != _CatchResult(pResponse->command, &pResponse->rIxpResult))
            goto exit;
    }

    // Handle Command Type
    switch(pResponse->command)
    {
    case POP3_CONNECTED:
        // Notify
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_CHECKING, 0);

        // Logon Success
        FLAGSET(m_dwState, POP3STATE_LOGONSUCCESS);

        // Issue the STAT command
        _CatchResult(m_pTransport->CommandSTAT());
        break;

    case POP3_STAT:
        // Process the StatCommand
        _CatchResult(_HrOnStatResponse(pResponse));
        break;

    case POP3_LIST:
        // Process the List Command
        _CatchResult(_HrOnListResponse(pResponse));
        break;

    case POP3_UIDL:
        // Process the Uidl Command
        _CatchResult(_HrOnUidlResponse(pResponse));
        break;

    case POP3_TOP:
        // Process the Top Command
        _CatchResult(_HrOnTopResponse(pResponse));
        break;

    case POP3_RETR:
        // Process Retreive Response
        _CatchResult(_HrOnRetrResponse(pResponse));
        break;

    case POP3_DELE:
        // Process Delete Response
        _CatchResult(_HrDeleteNextMessage(pResponse->dwPopId));
        break;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrLockUidlCache
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrLockUidlCache(void)
{
    // Locals
    HRESULT hr=S_OK;

    // No Cache yet ?
    if (NULL == m_pUidlCache)
    {
        // Lets the the UID Cache
        CHECKHR(hr = m_pSpoolCtx->BindToObject(IID_CUidlCache, (LPVOID *)&m_pUidlCache));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrOnStatResponse
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrOnStatResponse(LPPOP3RESPONSE pResponse)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRes[CCHMAX_RES];
    CHAR            szSize[CCHMAX_RES];
    CHAR            szMsg[CCHMAX_RES + CCHMAX_ACCOUNT_NAME + CCHMAX_RES];
    BOOL            fFound;

    // Progress
    LOADSTRING(IDS_SPS_POP3CHECKING, szRes);
    wsprintf(szMsg, szRes, m_rServer.szAccount);
    m_pUI->SetGeneralProgress(szMsg);

    // Update Event Status
    LOADSTRING(IDS_SPS_POP3TOTAL, szRes);
    StrFormatByteSizeA(pResponse->rStatInfo.cbMessages, szSize, ARRAYSIZE(szSize));
    wsprintf(szMsg, szRes, m_rServer.szAccount, pResponse->rStatInfo.cMessages, szSize);
    m_pUI->UpdateEventState(m_eidEvent, -1, szMsg, NULL);

    // No New Messages ?
    if (0 == pResponse->rStatInfo.cMessages)
    {
        m_pTransport->Disconnect();
        goto exit;
    }

    // Save total byte count
    m_rMetrics.cbTotal = pResponse->rStatInfo.cbMessages;

    // Assume no clean cache
    FLAGCLEAR(m_dwState, POP3STATE_CLEANUPCACHE);

    // If Leave on Server, return TRUE
    if (ISFLAGSET(m_dwState, POP3STATE_LEAVEONSERVER))
    {
        // Lock the tree
        CHECKHR(hr = _HrLockUidlCache());

        // We will need to get the uidls
        FLAGSET(m_dwState, POP3STATE_GETUIDLS);
    }

    // Okay, we may still need to get the uidls if
    else
    {
        // Locals
        UIDLRECORD  UidlInfo={0};
        HROWSET     hRowset=NULL;

        // Lock the tree
        CHECKHR(hr = _HrLockUidlCache());

        // Create a Rowset
        CHECKHR(hr = m_pUidlCache->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

        // Delete Enumeration
        while (S_OK == m_pUidlCache->QueryRowset(hRowset, 1, (LPVOID *)&UidlInfo, NULL))
        {
            // Delete this puppy ?
            if (lstrcmpi(UidlInfo.pszServer, m_rServer.szServerName) == 0 &&
                UidlInfo.pszAccountId != NULL && 
                lstrcmpi(UidlInfo.pszAccountId, m_szAccountId) == 0)
            {
                // Get Uidls from the server
                FLAGSET(m_dwState, POP3STATE_GETUIDLS);

                // Cleanup the uidl cache when complete
                FLAGSET(m_dwState, POP3STATE_CLEANUPCACHE);

                // Free
                m_pUidlCache->FreeRecord(&UidlInfo);

                // Done
                break;
            }

            // Free
            m_pUidlCache->FreeRecord(&UidlInfo);
        }

        // Purge everthing that matches this
        m_pUidlCache->CloseRowset(&hRowset);
    }

    // Allocate the Item Table
    CHECKALLOC(m_rTable.prgItem = (LPPOP3ITEM)g_pMalloc->Alloc(sizeof(POP3ITEM) * pResponse->rStatInfo.cMessages));

    // Set Counts
    m_rTable.cAlloc = m_rTable.cItems = pResponse->rStatInfo.cMessages;

    // Zeroinit Array
    ZeroMemory(m_rTable.prgItem, sizeof(POP3ITEM) * pResponse->rStatInfo.cMessages);

    // Initialize Progress
    m_dwProgressMax = m_rTable.cItems;

    // If we need to get the UIDL list, lets test for it...
    if (ISFLAGSET(m_dwState, POP3STATE_GETUIDLS))
        m_dwProgressMax += (m_rTable.cItems * 4);

    // Otherwise
    else
    {
        // Release the Uidl Cache Lock
        SafeRelease(m_pUidlCache);
    }

    // Progress Current
    m_dwProgressCur = 0;

    // Predownload rules increases mprogress
    if (ISFLAGSET(m_dwState, POP3STATE_PDR))
        m_dwProgressMax += m_rTable.cItems;

    // Set Specific Progress
    LOADSTRING(IDS_SPS_POP3STAT, szRes);
    m_pUI->SetSpecificProgress(szRes);

    // Set the uidl command to see if the user supports it
    CHECKHR(hr = m_pTransport->CommandLIST(POP3CMD_GET_ALL, 0));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrOnTopResponse
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrOnTopResponse(LPPOP3RESPONSE pResponse)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               dwPopId=pResponse->rTopInfo.dwPopId;
    LPPOP3ITEM          pItem;
    IMimePropertySet   *pHeader=NULL;
    CHAR                szRes[CCHMAX_RES];
    CHAR                szMsg[CCHMAX_RES+CCHMAX_RES];

    // Validate the Item
    Assert(ISVALIDPOPID(dwPopId));

    // Get the current item
    pItem = ITEMFROMPOPID(dwPopId);

    // We should assume that were downloading this item at this point
    Assert(ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD));

    // No stream yet ?
    if (NULL == m_pStream)
    {
        // Create a Stream
        CHECKHR(hr = MimeOleCreateVirtualStream(&m_pStream));
    }

    // If this infor is valid
    if (TRUE == pResponse->fValidInfo)
    {
        // Write the data into the stream
        CHECKHR(hr = m_pStream->Write(pResponse->rTopInfo.pszLines, pResponse->rTopInfo.cbLines, NULL));
    }

    // Is the command done ?
    if (TRUE == pResponse->fDone)
    {
        // Commit the stream
        CHECKHR(hr = m_pStream->Commit(STGC_DEFAULT));

        // Getting UIDL
        if (POP3STATE_GETTINGUIDLS == m_state)
        {
            // Better not have a uidl yet
            Assert(NULL == pItem->pszUidl);

            // Increment Progress
            m_dwProgressCur+=2;

            // Set Specific Progress
            //LOADSTRING(IDS_SPS_POP3UIDL_TOP, szRes);
            //wsprintf(szMsg, szRes, dwPopId, m_rTable.cItems);
            //m_pUI->SetSpecificProgress(szMsg);

            // Get Uidl From HeaderStream
            CHECKHR(hr = _HrGetUidlFromHeaderStream(m_pStream, &pItem->pszUidl, &pHeader));
        }

        // Otherwise, just increment one
        else
            m_dwProgressCur++;

        // Show Progress
        _DoProgress();

        // If we plan on downloading this thing
        if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD) && ISFLAGSET(m_dwState, POP3STATE_PDR))
        {
            // Check Inbox Rule for this item
            _ComputeItemInboxRule(pItem, m_pStream, pHeader, NULL, TRUE);
        }

        // Release the current stream
        SafeRelease(m_pStream);

        // Totally Done ?
        if (ISLASTPOPID(dwPopId))
        {
            // Start the download process
            CHECKHR(hr = _HrStartDownloading());
        }

        // Otherwise, lets get the top of the next item
        else if (POP3STATE_GETTINGUIDLS == m_state)
        {
            // Next Top
            CHECKHR(hr = m_pTransport->CommandTOP(POP3CMD_GET_POPID, dwPopId + 1, 0));
        }

        // Otherwise, find next message marked for download to check against predownload rules
        else
        {
            // NextTopForInboxRule
            CHECKHR(hr = _HrNextTopForInboxRule(dwPopId));
        }
    }

exit:
    // Cleanup
    SafeRelease(pHeader);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrOnUidlResponse
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrOnUidlResponse(LPPOP3RESPONSE pResponse)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwPopId=pResponse->rUidlInfo.dwPopId;
    LPPOP3ITEM      pItem;
    CHAR            szRes[CCHMAX_RES];
    CHAR            szMsg[CCHMAX_RES + CCHMAX_RES];

    // Is the command done ?
    if (TRUE == pResponse->fDone)
    {
        // If there are pre-download rules that are not size only, get all the tops
        if (ISFLAGSET(m_dwState, POP3STATE_PDR))
        {
            // Clear the state
            m_state = POP3STATE_NONE;

            // NextTopForInboxRule
            CHECKHR(hr = _HrStartServerSideRules());
        }

        // Otherwise, do the list command
        else
        {
            // Start the download process
            CHECKHR(hr = _HrStartDownloading());
        }
    }

    // Otherwise
    else
    {
        // Make Sure PopId is on current iitem
        Assert(ISVALIDPOPID(dwPopId) && pResponse->rUidlInfo.pszUidl);

        // Get Current Item
        pItem = ITEMFROMPOPID(dwPopId);

        // Duplicate the Uidl
        CHECKALLOC(pItem->pszUidl = PszDupA(pResponse->rUidlInfo.pszUidl));

        // Increment Progress
        m_dwProgressCur+=1;

        // Do progress
        _DoProgress();
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrOnListResponse
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrOnListResponse(LPPOP3RESPONSE pResponse)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwPopId=pResponse->rListInfo.dwPopId;
    LPPOP3ITEM      pItem;

    // Is the command done ?
    if (TRUE == pResponse->fDone)
    {
        // If we need to get the UIDL list, lets test for it...
        if (ISFLAGSET(m_dwState, POP3STATE_GETUIDLS))
        {
            // Set the uidl command to see if the user supports it
            CHECKHR(hr = m_pTransport->CommandUIDL(POP3CMD_GET_POPID, 1));

            // Set State
            m_uidlsupport = UIDL_SUPPORT_TESTING_UIDL_COMMAND;
        }

        // Otherwise
        else
        {
            // Predownload rules increases mprogress
            if (ISFLAGSET(m_dwState, POP3STATE_PDR))
            {
                // Clear the state
                m_state = POP3STATE_NONE;

                // NextTopForInboxRule
                CHECKHR(hr = _HrStartServerSideRules());
            }

            // Otherwise, do the list command
            else
            {
                // Start the download process
                CHECKHR(hr = _HrStartDownloading());
            }
        }
    }

    // Otherwise
    else
    {
        // Make Sure PopId is on current iitem
        if(!ISVALIDPOPID(dwPopId))
            return(E_FAIL);

        // Get Current Item
        pItem = ITEMFROMPOPID(dwPopId);

        // Duplicate the Uidl
        pItem->cbSize = pResponse->rListInfo.cbSize;

        // Assume we will download it
        FLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD | POP3ITEM_DELETEOFFSERVER);

        // Increment Progress
        m_dwProgressCur++;

        // Do progress
        _DoProgress();

        // This yields so that other threads can execute
        //Sleep(0);
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrStartDownloading
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrStartDownloading(void)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    CHAR            szRes[CCHMAX_RES];
    CHAR            szSize1[CCHMAX_RES];
    CHAR            szSize2[CCHMAX_RES];
    CHAR            szMsg[CCHMAX_RES + CCHMAX_ACCOUNT_NAME + CCHMAX_RES];

    // State
    Assert(m_rMetrics.cLeftByRule == 0 && m_rMetrics.cDownload == 0 && m_rMetrics.cDelete == 0 && m_rMetrics.cbDownload == 0);

    // If we got uidls, then lets do the cache compare lookup
    if (!ISFLAGSET(m_dwState, POP3STATE_PDR) && ISFLAGSET(m_dwState, POP3STATE_GETUIDLS))
    {
        // Returns FALSE if user cancel
        CHECKHR(hr = _HrDoUidlSynchronize());
    }

    // Compute number of new messages to download
    for (i=0; i<m_rTable.cItems; i++)
    {
        // Download ?
        if (ISFLAGSET(m_rTable.prgItem[i].dwFlags, POP3ITEM_DOWNLOAD))
        {
            // Increment total number of bytes we will download
            m_rMetrics.cbDownload += m_rTable.prgItem[i].cbSize;

            // Increment count of messages we will download
            m_rMetrics.cDownload++;

            // Set running total in pop3 item
            m_rTable.prgItem[i].dwProgressCur = m_rMetrics.cbDownload;
        }

        // Count Left By Rule in case we don't download anything
        else if (ISFLAGSET(m_rTable.prgItem[i].dwFlags, POP3ITEM_LEFTBYRULE))
            m_rMetrics.cLeftByRule++;

        // Delete
        if (ISFLAGSET(m_rTable.prgItem[i].dwFlags, POP3ITEM_DELETEOFFSERVER))
        {
            // Number of messages we will delete
            m_rMetrics.cDelete++;
        }
    }

    // Update Event Status
    LOADSTRING(IDS_SPS_POP3NEW, szRes);
    StrFormatByteSizeA(m_rMetrics.cbDownload, szSize1, ARRAYSIZE(szSize1));
    StrFormatByteSizeA(m_rMetrics.cbTotal, szSize2, ARRAYSIZE(szSize2));
    wsprintf(szMsg, szRes, m_rServer.szAccount, m_rMetrics.cDownload, szSize1, m_rTable.cItems, szSize2);
    m_pUI->UpdateEventState(m_eidEvent, -1, szMsg, NULL);

    // New Messages ?
    if (m_rMetrics.cDownload > 0)
    {
        // Setup Progress
        m_rMetrics.iCurrent = 0;
        m_wProgress = 0;
        m_dwProgressCur = 0;
        m_dwProgressMax = m_rMetrics.cbDownload;
        m_pUI->SetProgressRange(100);
        m_rMetrics.cLeftByRule = 0;

        // Notify
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_RECEIVING, 0);

        // State
        m_state = POP3STATE_DOWNLOADING;

        // Open the Inbox
        Assert(NULL == m_pInbox);
        CHECKHR(hr = m_pSpoolCtx->BindToObject(IID_CLocalStoreInbox, (LPVOID *)&m_pInbox));

        // Download the Next Message
        CHECKHR(hr = _HrRetrieveNextMessage(0));
    }

    // Otherwise if cDelete
    else if (m_rMetrics.cDelete > 0)
    {
        // Delete the Next Message
        CHECKHR(hr = _HrStartDeleteCycle());
    }

    // Otherwise, disconnect
    else
    {
        // Disconnect
        CHECKHR(hr = m_pTransport->Disconnect());
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_DoProgress
// --------------------------------------------------------------------------------
void CPop3Task::_DoProgress(void)
{
    // Compute Current Progress Index
    WORD wProgress;
    if (m_dwProgressMax > 0)
        wProgress = (WORD)((m_dwProgressCur * 100) / m_dwProgressMax);
    else
        wProgress = 0;

    // Only if greater than
    if (wProgress > m_wProgress)
    {
        // Compute Delta
        WORD wDelta = wProgress - m_wProgress;

        // Progress Delta
        if (wDelta > 0)
        {
            // Incremenet Progress
            m_pUI->IncrementProgress(wDelta);

            // Increment my wProgress
            m_wProgress += wDelta;

            // Don't go above 100
            if (m_wProgress > 100)
                m_wProgress = 100;
        }
    }
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrGetUidlFromHeaderStream
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrGetUidlFromHeaderStream(IStream *pStream, LPSTR *ppszUidl, IMimePropertySet **ppHeader)
{
    // Locals
    HRESULT             hr=S_OK;
    IMimePropertySet   *pHeader=NULL;

    // Invalid Arg
    Assert(pStream && ppszUidl);

    // Init
    *ppszUidl = NULL;
    *ppHeader = NULL;

    // Rewind Header Stream
    CHECKHR(hr = HrRewindStream(pStream));

    // Load the header
    CHECKHR(hr = MimeOleCreatePropertySet(NULL, &pHeader));

    // Load the header
    CHECKHR(hr = pHeader->Load(pStream));

    // Get the message Id...
    if (FAILED(MimeOleGetPropA(pHeader, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, ppszUidl)))
    {
        // Try to use the received headers...
        MimeOleGetPropA(pHeader, PIDTOSTR(PID_HDR_RECEIVED), NOFLAGS, ppszUidl);
    }

    // Returen the Header ?
    *ppHeader = pHeader;
    pHeader = NULL;

exit:
    // Release the text stream
    SafeRelease(pHeader);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrDoUidlSynchronize
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrDoUidlSynchronize(void)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPOP3ITEM      pItem;
    ULONG           i,j;

#ifdef DEBUG
    DWORD dwTick = GetTickCount();
#endif

    // Uidl Sync
    m_state = POP3STATE_UIDLSYNC;

    // Compute number of new messages to download
    for (i=0,j=0; i<m_rTable.cItems; i++,j++)
    {
        // Readability
        pItem = &m_rTable.prgItem[i];

        // Get Uidl Falgs
        _GetItemFlagsFromUidl(pItem);

        // Progress
        m_dwProgressCur+=3;

        // Do Progress
        _DoProgress();

        // Pump Message
        if (j >= 10)
        {
            //Sleep(0);
            m_pSpoolCtx->PumpMessages();
            j = 0;
        }

        // Cancel
        if (ISFLAGSET(m_dwState, POP3STATE_CANCELPENDING))
        {
            // Change State
            m_state = POP3STATE_NONE;

            // Drop the connection
            if (m_pTransport)
                m_pTransport->DropConnection();

            // User Cancel
            hr = IXP_E_USER_CANCEL;

            // Done
            break;
        }

        // OnDisconnect has been called
        if (ISFLAGSET(m_dwState, POP3STATE_ONDISCONNECT))
        {
            // Change State
            m_state = POP3STATE_NONE;

            // Fake the call to OnStatus
            OnStatus(IXP_DISCONNECTED, NULL);

            // Done
            break;
        }
    }

    // Uidl Sync
    m_state = POP3STATE_NONE;

    // Cool tracing
#ifdef DEBUG
    DebugTrace("CPop3Task::_HrDoUidlSynchronize took %d Milli-Seconds\n", GetTickCount() - dwTick);
#endif // DEBUG

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::_GetItemFlagsFromUidl
// --------------------------------------------------------------------------------
void CPop3Task::_GetItemFlagsFromUidl(LPPOP3ITEM pItem)
{
    // Locals
    UIDLRECORD rUidlInfo={0};

    // Invalid Arg
    Assert(pItem && m_pUidlCache);

    // If we are already not going to download this item, then return
    if (!ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD))
        return;

    // If there is no UIDL, we will download it...
    if (NULL == pItem->pszUidl || '\0' == *pItem->pszUidl)
        return;

    // If not leaving on server, mark for delete
    if (ISFLAGSET(m_dwState, POP3STATE_LEAVEONSERVER))
        FLAGCLEAR(pItem->dwFlags, POP3ITEM_DELETEOFFSERVER);

    // Set Search Info
    rUidlInfo.pszUidl = pItem->pszUidl;
    rUidlInfo.pszServer = m_rServer.szServerName;
    rUidlInfo.pszAccountId = m_szAccountId;

    // This yields so that other threads can execute
    //Sleep(0);

    // Exist - if not, lets download it...
    if (DB_S_NOTFOUND == m_pUidlCache->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &rUidlInfo, NULL))
    {
        if (ISFLAGSET(m_dwState, POP3STATE_LEAVEONSERVER))
            FLAGSET(pItem->dwFlags, POP3ITEM_CACHEUIDL);
        return;
    }

    // Don't download it again
    FLAGCLEAR(pItem->dwFlags, POP3ITEM_DOWNLOAD | POP3ITEM_DELETEOFFSERVER);

    // If the message has been download, lets decide if we should delete it
    if (rUidlInfo.fDownloaded)
    {
        // Expired or deleted from client, or remove when deleted from delete items folder.
        if (!ISFLAGSET(m_dwState, POP3STATE_LEAVEONSERVER) || _FUidlExpired(&rUidlInfo) ||
            (ISFLAGSET(m_dwState, POP3STATE_SYNCDELETED) && rUidlInfo.fDeleted))
        {
            FLAGSET(pItem->dwFlags, POP3ITEM_DELETECACHEDUIDL);
            FLAGSET(pItem->dwFlags, POP3ITEM_DELETEOFFSERVER);
        }
    }

    // Free The Dude
    m_pUidlCache->FreeRecord(&rUidlInfo);
}

// ------------------------------------------------------------------------------------
// CPop3Task::_FUidlExpired
// ------------------------------------------------------------------------------------
BOOL CPop3Task::_FUidlExpired(LPUIDLRECORD pUidlInfo)
{
    // Locals
    SYSTEMTIME          st;
    FILETIME            ft;
    ULONG               ulSeconds;

    // If not expiring, return FALSE
    if (!ISFLAGSET(m_dwState, POP3STATE_DELETEEXPIRED))
        return FALSE;

    // Get Current Time
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    // Convert st to seconds since Jan 1, 1996
    ulSeconds = UlDateDiff(&pUidlInfo->ftDownload, &ft);

    // Greater than expire days
    if ((ulSeconds / SECONDS_INA_DAY) >= m_dwExpireDays)
        return TRUE;

    // Done
    return FALSE;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_ComputeItemInboxRule
// ------------------------------------------------------------------------------------
void CPop3Task::_ComputeItemInboxRule(LPPOP3ITEM pItem, LPSTREAM pStream,
                IMimePropertySet *pHeaderIn, IMimeMessage * pIMMsg, BOOL fServerRules)
{
    // Locals
    HRESULT             hr=S_OK;
    IMimePropertySet   *pHeader=NULL;
    ACT_ITEM           *pActions=NULL;
    ULONG               cActions=0;

    // We should not have checked the inbox rule for this item yet
    Assert(m_pIExecRules && pItem && (pStream || pHeaderIn || pIMMsg));
    Assert(ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD) && !ISFLAGSET(pItem->dwFlags, POP3ITEM_CHECKEDINBOXRULE));

    // We've checked this inbox rule
    FLAGSET(pItem->dwFlags, POP3ITEM_CHECKEDINBOXRULE);

    // Assume we don't find an inbox rule for this item
    FLAGCLEAR(pItem->dwFlags, POP3ITEM_HASINBOXRULE);

    // Header was passed in ?
    if (pHeaderIn)
    {
        pHeader = pHeaderIn;
        pHeader->AddRef();
    }

    // Do we already have a Mime message?
    else if (pIMMsg)
    {
        CHECKHR(hr = pIMMsg->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pHeader));
    }
    
    // Otherwise, load the stream in to a header
    else
    {
        // Rewind Header Stream
        CHECKHR(hr = HrRewindStream(pStream));

        // Load the header
        CHECKHR(hr = MimeOleCreatePropertySet(NULL, &pHeader));

        // Load the header
        CHECKHR(hr = pHeader->Load(pStream));
    }

    // Check the inbox rule

    // If we have pre-download rules,
    if ((FALSE != fServerRules) && ISFLAGSET(m_dwState, POP3STATE_PDR))
    {
        // Check to see if we have any actions
        hr = m_pIExecRules->ExecuteRules(ERF_ONLYSERVER | ERF_SKIPPARTIALS, m_szAccountId, NULL, NULL, pHeader, NULL, pItem->cbSize, &pActions, &cActions);

        // If we don't have any actions, or
        // this isn't a server side rule
        if ((S_OK != hr) ||
                    ((ACT_TYPE_DONTDOWNLOAD != pActions[0].type) && (ACT_TYPE_DELETESERVER != pActions[0].type)))
        {
            // Make sure we can check rules again
            FLAGCLEAR(pItem->dwFlags, POP3ITEM_CHECKEDINBOXRULE);
            hr = S_FALSE;
        }
        else
        {
            // _OnKnownRuleActions
            _OnKnownRuleActions(pItem, pActions, cActions, fServerRules);
        }
    }
    // If we don't have pre-download rules, then check rules normally.
    else
    {
        hr = S_FALSE;
        
        // Do block sender first
        if (m_pIRuleSender)
        {
            hr = m_pIRuleSender->Evaluate(m_szAccountId, NULL, NULL, pHeader, pIMMsg, pItem->cbSize, &pActions, &cActions);
        }

        // If we aren't blocking the sender
        if (S_OK != hr)
        {
            hr = m_pIExecRules->ExecuteRules(ERF_SKIPPARTIALS, m_szAccountId, NULL, NULL, pHeader, pIMMsg, pItem->cbSize, &pActions, &cActions);
        }
        
        // If we don't have a rule match
        if ((S_OK != hr) && (NULL != m_pIRuleJunk))
        {
            hr = m_pIRuleJunk->Evaluate(m_szAccountId, NULL, NULL, pHeader, pIMMsg, pItem->cbSize, &pActions, &cActions);
        }
        
        // Did we have some actions to perform...
        if (S_OK == hr)
        {
            // This item has an inbox rule
            FLAGSET(pItem->dwFlags, POP3ITEM_HASINBOXRULE);

            // Save off the actions list
            pItem->pActList = pActions;
            pActions = NULL;
            pItem->cActList = cActions;
        }
    }

exit:
    // Cleanup
    RuleUtil_HrFreeActionsItem(pActions, cActions);
    SafeMemFree(pActions);
    SafeRelease(pHeader);

    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_OnKnownRuleActions
// ------------------------------------------------------------------------------------
void CPop3Task::_OnKnownRuleActions(LPPOP3ITEM pItem, ACT_ITEM * pActions, ULONG cActions, BOOL fServerRules)
{
    // This item has an inbox rule
    FLAGSET(pItem->dwFlags, POP3ITEM_HASINBOXRULE);

    // If Action is to delete off sever
    if ((FALSE != fServerRules) && (1 == cActions))
    {
        if (ACT_TYPE_DELETESERVER == pActions->type)
        {
            // Don't Cache the UIDL
            FLAGCLEAR(pItem->dwFlags, POP3ITEM_DELETECACHEDUIDL | POP3ITEM_CACHEUIDL | POP3ITEM_DOWNLOAD);

            // Delete off the server
            FLAGSET(pItem->dwFlags, POP3ITEM_DELETEOFFSERVER | POP3ITEM_DELEBYRULE);
        }

        // Otherwise, don't download the message
        else if (ACT_TYPE_DONTDOWNLOAD == pActions->type)
        {
            // Download It and Don't download it and delete it
            FLAGCLEAR(pItem->dwFlags, POP3ITEM_DOWNLOAD | POP3ITEM_DELETEOFFSERVER);

            // Set the Flag
            FLAGSET(pItem->dwFlags, POP3ITEM_LEFTBYRULE);
        }
    }
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrStartServerSideRules
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrStartServerSideRules(void)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // If we got uidls, then lets do the cache compare lookup
    if (ISFLAGSET(m_dwState, POP3STATE_GETUIDLS))
    {
        // Returns FALSE if user cancel
        CHECKHR(hr = _HrDoUidlSynchronize());
    }

    // Check State
    m_rMetrics.cTopMsgs = 0;
    m_rMetrics.iCurrent = 0;

    // Count the number of messages we will have to get a top for
    for (i=0; i<m_rTable.cItems; i++)
    {
        if (ISFLAGSET(m_rTable.prgItem[i].dwFlags, POP3ITEM_DOWNLOAD))
            m_rMetrics.cTopMsgs++;
    }

    // Adjust progress
    m_dwProgressMax -= m_rTable.cItems;

    // Add m_rMetrics.cTopMsgs back onto m_dwProgressMax
    m_dwProgressMax += m_rMetrics.cTopMsgs;

    // Do the first one
    CHECKHR(hr = _HrNextTopForInboxRule(0));

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrNextTopForInboxRule
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrNextTopForInboxRule(DWORD dwPopIdCurrent)
{
    // Locals
    HRESULT             hr=S_OK;
    CHAR                szRes[CCHMAX_RES];
    CHAR                szMsg[CCHMAX_RES+CCHMAX_RES];

    // State should be none
    Assert(POP3STATE_NONE == m_state);

    // Increment iCurrent
    m_rMetrics.iCurrent++;

    // Set Specific Progress
    //LOADSTRING(IDS_SPS_PREDOWNRULES, szRes);
    //wsprintf(szMsg, szRes, m_rMetrics.iCurrent, m_rMetrics.cTopMsgs);
    //m_pUI->SetSpecificProgress(szMsg);

    // Loop until we find the next message that we are downloading
    while(1)
    {
        // Incremenet dwPopIdCurrent
        dwPopIdCurrent++;

        // Last PopId, start the download
        if (dwPopIdCurrent > m_rTable.cItems)
        {
            // Start the download process
            CHECKHR(hr = _HrStartDownloading());

            // Done
            break;
        }

        // If we are still downloading this item
        if (ISFLAGSET(m_rTable.prgItem[dwPopIdCurrent - 1].dwFlags, POP3ITEM_DOWNLOAD))
        {
            // Try to top command
            CHECKHR(hr = m_pTransport->CommandTOP(POP3CMD_GET_POPID, dwPopIdCurrent, 0));

            // Done
            break;
        }
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrRetrieveNextMessage
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrRetrieveNextMessage(DWORD dwPopIdCurrent)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRes[CCHMAX_RES];
    CHAR            szMsg[CCHMAX_RES + CCHMAX_RES];
    LPPOP3ITEM      pItem;

    // Cancel Pending...
    if (ISFLAGSET(m_dwState, POP3STATE_CANCELPENDING))
    {
        // Start the Delete Cycle
        CHECKHR(hr = _HrStartDeleteCycle());

        // Done
        goto exit;
    }

    // Adjust progress
    if (dwPopIdCurrent > 0)
    {
        // Get current item
        pItem = ITEMFROMPOPID(dwPopIdCurrent);
        Assert(ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD));

        // Adjust progress Cur
        m_dwProgressCur = pItem->dwProgressCur;

        // Do progress
        _DoProgress();
    }

    // Loop until we find the next message that we are downloading
    while(1)
    {
        // Incremenet dwPopIdCurrent
        dwPopIdCurrent++;

        // Last PopId, start the download
        if (dwPopIdCurrent > m_rTable.cItems)
        {
            // Start the download process
            CHECKHR(hr = _HrStartDeleteCycle());

            // Done
            break;
        }

        // Readability
        pItem = ITEMFROMPOPID(dwPopIdCurrent);

        // Download this message ?
        if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD))
        {
            // Increment m_rMetrics.iCurrent
            m_rMetrics.iCurrent++;

            // Status
            LOADSTRING(idsInetMailRecvStatus, szRes);
            wsprintf(szMsg, szRes, m_rMetrics.iCurrent, m_rMetrics.cDownload);
            m_pUI->SetSpecificProgress(szMsg);

            // Retrieve this item
            CHECKHR(hr = m_pTransport->CommandRETR(POP3CMD_GET_POPID, dwPopIdCurrent));

            // Done
            break;
        }

        // Count Number of items left by rule
        else if (ISFLAGSET(pItem->dwFlags, POP3ITEM_LEFTBYRULE))
            m_rMetrics.cLeftByRule++;
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrOnRetrResponse
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrOnRetrResponse(LPPOP3RESPONSE pResponse)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwPopId=pResponse->rRetrInfo.dwPopId;
    LPPOP3ITEM      pItem;

    // Get Current Item
    pItem = ITEMFROMPOPID(dwPopId);

    // Validate the item
    Assert(ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD));

    // Valid info
    if (TRUE == pResponse->fValidInfo)
    {
        // Progress...
        m_dwProgressCur += pResponse->rRetrInfo.cbLines;

        // Don't let progress grow beyond what we estimated the ceiling for this message
        if (m_dwProgressCur > pItem->dwProgressCur)
            m_dwProgressCur = pItem->dwProgressCur;

        // Show Progress
        _DoProgress();

        // Do we have a destination yet ?
        if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DESTINATIONKNOWN))
        {
            // We better have a stream
            Assert(m_rFolder.pStream && m_rFolder.pFolder);

            // Simply write the data
            CHECKHR(hr = m_rFolder.pStream->Write(pResponse->rRetrInfo.pszLines, pResponse->rRetrInfo.cbLines, NULL));
        }

        // Otherwise
        else
        {
            // If there are no inbox rules
            if (ISFLAGSET(m_dwState, POP3STATE_NOPOSTRULES))
            {
                // Use the Inbox
                CHECKHR(hr = _HrOpenFolder(m_pInbox));

                // Destination is known
                FLAGSET(pItem->dwFlags, POP3ITEM_DESTINATIONKNOWN);

                // Simply write the data
                CHECKHR(hr = m_rFolder.pStream->Write(pResponse->rRetrInfo.pszLines, pResponse->rRetrInfo.cbLines, NULL));
            }

            // else if we have only body rules...
            else if (ISFLAGSET(m_dwState, POP3STATE_BODYRULES))
            {
                // No stream yet ?
                if (NULL == m_pStream)
                {
                    // Create a Stream
                    CHECKHR(hr = MimeOleCreateVirtualStream(&m_pStream));
                }

                // Simply write the data
                CHECKHR(hr = m_pStream->Write(pResponse->rRetrInfo.pszLines, pResponse->rRetrInfo.cbLines, NULL));
            }
            
            // Otherwise...
            else
            {
                // Have I checked the inbox rule for this item yet ?
                if (!ISFLAGSET(pItem->dwFlags, POP3ITEM_CHECKEDINBOXRULE))
                {
                    // No stream yet ?
                    if (NULL == m_pStream)
                    {
                        // Create a Stream
                        CHECKHR(hr = MimeOleCreateVirtualStream(&m_pStream));
                    }

                    // Simply write the data
                    CHECKHR(hr = m_pStream->Write(pResponse->rRetrInfo.pszLines, pResponse->rRetrInfo.cbLines, NULL));

                    // If I have the header, check the inbox rule
                    if (TRUE == pResponse->rRetrInfo.fHeader)
                    {
                        // Commit the stream
                        CHECKHR(hr = m_pStream->Commit(STGC_DEFAULT));

                        // Check Inbox Rule for this item
                        _ComputeItemInboxRule(pItem, m_pStream, NULL, NULL, FALSE);
                    }
                }

                // Have I checked the inbox rule for this item yet ?
                if (ISFLAGSET(pItem->dwFlags, POP3ITEM_CHECKEDINBOXRULE))
                {
                    // Locals
                    IMessageFolder *pFolder;

                    // We must have the header
                    IxpAssert(pResponse->rRetrInfo.fHeader);

                    // Did we find an Inbox Rule
                    if (ISFLAGSET(pItem->dwFlags, POP3ITEM_HASINBOXRULE) && S_OK == _GetMoveFolder(pItem, &pFolder))
                    {
                        // Use the Inbox
                        CHECKHR(hr = _HrOpenFolder(pFolder));
                    }

                    // No Move To, just use the inbox
                    else
                    {
                        // Use the Inbox
                        CHECKHR(hr = _HrOpenFolder(m_pInbox));
                    }

                    // Destination is known
                    FLAGSET(pItem->dwFlags, POP3ITEM_DESTINATIONKNOWN);

                    // If m_pStream, then copy this to the folder
                    if (m_pStream)
                    {
                        // Rewind the stream
                        CHECKHR(hr = HrRewindStream(m_pStream));

                        // Copy this stream to the folder
                        CHECKHR(hr = HrCopyStream(m_pStream, m_rFolder.pStream, NULL));

                        // Relase m_pStream
                        SafeRelease(m_pStream);
                    }

                    // Otherwise, store the data into the folder
                    else
                    {
                        IxpAssert(FALSE);
                        // Simply write the data
                        CHECKHR(hr = m_rFolder.pStream->Write(pResponse->rRetrInfo.pszLines, pResponse->rRetrInfo.cbLines, NULL));
                    }
                }
            }
        }
    }

    // Done ?
    if (TRUE == pResponse->fDone)
    {
        // Finish this message download
        CHECKHR(hr = _HrFinishMessageDownload(dwPopId));
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrFinishMessageDownload
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrFinishMessageDownload(DWORD dwPopId)
{
    // Locals
    HRESULT         hr=S_OK;
    IMimeMessage   *pMessage=NULL;
    PROPVARIANT     rUserData;
    LPPOP3ITEM      pItem;
    SYSTEMTIME      st;
    UIDLRECORD      rUidlInfo={0};
    MESSAGEID       idMessage;
    DWORD           dwMsgFlags;
    IMessageFolder  *pFolder;
    ULONG           ulIndex = 0;
    IStream *       pIStm = NULL;
    BOOL            fDelete=FALSE;
    
    // Get Current Item
    pItem = ITEMFROMPOPID(dwPopId);

    // Create a New Mail Message
    CHECKHR(hr = HrCreateMessage(&pMessage));

    // Has Body rules
    if (ISFLAGSET(m_dwState, POP3STATE_BODYRULES))
    {
        // I should not have checked for a rule yet
        IxpAssert(!ISFLAGSET(pItem->dwFlags, POP3ITEM_CHECKEDINBOXRULE) && !ISFLAGSET(pItem->dwFlags, POP3ITEM_HASINBOXRULE));

        // Better have a current folder
        Assert(m_pStream);

        // Check Params
        CHECKHR(hr = m_pStream->Commit(STGC_DEFAULT));
        
        pIStm = m_pStream;
    }
    else
    {
        // Better have a current folder
        Assert(m_rFolder.pStream);

        // Check Params
        CHECKHR(hr = m_rFolder.pStream->Commit(STGC_DEFAULT));

        // Change the Lock Type
        CHECKHR(hr = m_rFolder.pFolder->ChangeStreamLock(m_rFolder.pStream, ACCESS_READ));
        
        pIStm = m_rFolder.pStream;
    }

    // Rewind
    CHECKHR(hr = HrRewindStream(pIStm));

    // Stream in
    CHECKHR(hr = pMessage->Load(pIStm));

    // Count Partials
    if (S_OK == pMessage->IsContentType(HBODY_ROOT, STR_CNT_MESSAGE, STR_SUB_PARTIAL))
        m_rMetrics.cPartials++;

    // Save Server
    rUserData.vt = VT_LPSTR;
    rUserData.pszVal = m_rServer.szServerName;
    pMessage->SetProp(PIDTOSTR(PID_ATT_SERVER), NOFLAGS, &rUserData);

    // Save Account Name
    rUserData.vt = VT_LPSTR;
    rUserData.pszVal = m_rServer.szAccount;
    pMessage->SetProp(STR_ATT_ACCOUNTNAME, NOFLAGS, &rUserData);

    // Save Account Name
    rUserData.vt = VT_LPSTR;
    rUserData.pszVal = m_szAccountId;
    pMessage->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &rUserData);

    // Save UIDL
    if (pItem->pszUidl)
    {
        rUserData.vt = VT_LPSTR;
        rUserData.pszVal = pItem->pszUidl;
        pMessage->SetProp(PIDTOSTR(PID_ATT_UIDL), NOFLAGS, &rUserData);
    }

    // Save User Name
    rUserData.vt = VT_LPSTR;
    rUserData.pszVal = m_rServer.szUserName;
    pMessage->SetProp(PIDTOSTR(PID_ATT_USERNAME), NOFLAGS, &rUserData);

    // Initialize dwMsgFlags
    dwMsgFlags = ARF_RECEIVED;

    // Has Body rules
    if (ISFLAGSET(m_dwState, POP3STATE_BODYRULES))
    {
        // I should not have checked for a rule yet
        IxpAssert(!ISFLAGSET(pItem->dwFlags, POP3ITEM_CHECKEDINBOXRULE) && !ISFLAGSET(pItem->dwFlags, POP3ITEM_HASINBOXRULE));

        // Compute the inbox rule
        _ComputeItemInboxRule(pItem, NULL, NULL, pMessage, FALSE);
        
        // Did we find an Inbox Rule
        if (ISFLAGCLEAR(pItem->dwFlags, POP3ITEM_HASINBOXRULE) || (S_OK != _GetMoveFolder(pItem, &pFolder)))
        {
            pFolder = m_pInbox;
        }

        // Destination is known
        FLAGSET(pItem->dwFlags, POP3ITEM_DESTINATIONKNOWN);        
    }
    else
    {
        pFolder = m_rFolder.pFolder;
    }

    // Store the message into the folder
    IF_FAILEXIT(hr = pFolder->SaveMessage(&idMessage, SAVE_MESSAGE_GENID, dwMsgFlags, pIStm, pMessage, NOSTORECALLBACK));
    
    // Success
    m_rFolder.fCommitted = TRUE;

    // This message was successfully downloaded
    FLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOADED);

    // Do PostDownloadRule
    _DoPostDownloadActions(pItem, idMessage, pFolder, pMessage, &fDelete);
    
    // Release Folder Object
    SafeRelease(m_rFolder.pStream);
    
    // Relase m_pStream
    SafeRelease(m_pStream);

    // Release the Folder
    SafeRelease(m_rFolder.pFolder);

    // Clear the folder infor Struct
    ZeroMemory(&m_rFolder, sizeof(POP3FOLDERINFO));

    // If going to delete it...
    if (fDelete)
    {
        // Mark it for deletion
        FLAGSET(pItem->dwFlags, POP3ITEM_DELETEOFFSERVER);

        // We will store its uidl, but lets delete it later
        FLAGSET(pItem->dwFlags, POP3ITEM_DELETECACHEDUIDL);
    }

    // Cached the UIDL for this message ?
    if (ISFLAGSET(pItem->dwFlags, POP3ITEM_CACHEUIDL))
    {
        // Should have a pszUidl
        Assert(pItem->pszUidl && m_pUidlCache);

        // Don't fault
        if (pItem->pszUidl)
        {
            // Set Key
            GetSystemTime(&st);
            SystemTimeToFileTime(&st, &rUidlInfo.ftDownload);
            rUidlInfo.fDownloaded = TRUE;
            rUidlInfo.fDeleted = FALSE;
            rUidlInfo.pszUidl = pItem->pszUidl;
            rUidlInfo.pszServer = m_rServer.szServerName;
            rUidlInfo.pszAccountId = m_szAccountId;

            // Set Propgs
            m_pUidlCache->InsertRecord(&rUidlInfo);
        }
    }

    // Successful download
    m_rMetrics.cDownloaded++;

    // Do smart log
    if (m_pSmartLog && (lstrcmpi(m_pSmartLog->pszAccount, m_rServer.szAccount) == 0 || lstrcmpi("All", m_pSmartLog->pszAccount) == 0))
        _DoSmartLog(pMessage);

    // Retrieve the next message
    CHECKHR(hr = _HrRetrieveNextMessage(dwPopId));

exit:
    // Cleanup
    SafeRelease(pMessage);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_DoPostDownloadActions
// ------------------------------------------------------------------------------------
void CPop3Task::_DoPostDownloadActions(LPPOP3ITEM pItem, MESSAGEID idMessage,
    IMessageFolder *pFolder, IMimeMessage *pMessage, BOOL *pfDeleteOffServer)
{
    // Locals
    HRESULT         hr;
    MESSAGEINFO     Message = {0};
    HWND            hwnd = NULL;

    // Finish Applying the inbox rules
    if (!ISFLAGSET(pItem->dwFlags, POP3ITEM_HASINBOXRULE))
    {
        goto exit;
    }

    // Get Window
    if (FAILED(m_pUI->GetWindow(&hwnd)))
        hwnd = NULL;
        
    // Set the Id
    Message.idMessage = idMessage;

    // Get the message
    hr = pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL);
    if (FAILED(hr) || DB_S_NOTFOUND == hr)
    {
        goto exit;
    }

    if (FAILED(RuleUtil_HrApplyActions(hwnd, m_pIExecRules, &Message, pFolder, pMessage, 0, pItem->pActList,
                        pItem->cActList, &(m_rMetrics.cInfiniteLoopAutoGens), pfDeleteOffServer)))
    {
        goto exit;
    }

exit:
    // Free
    if (NULL != pFolder)
    {
        pFolder->FreeRecord(&Message);
    }
    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrOpenFolder
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrOpenFolder(IMessageFolder *pFolder)
{
    // Locals
    HRESULT     hr=S_OK;

    // Current folder better be empty
    Assert(NULL == m_rFolder.pFolder && NULL == m_rFolder.pStream && 0 == m_rFolder.faStream);

    // Bad Arguments
    if (NULL == pFolder)
    {
        Assert(FALSE);
        return TrapError(E_INVALIDARG);
    }

    // Save the folder
    m_rFolder.pFolder = pFolder;

    // AddRef 
    m_rFolder.pFolder->AddRef();

    // Get a stream from the
    CHECKHR(hr = m_rFolder.pFolder->CreateStream(&m_rFolder.faStream));

    // Open the Stream
    CHECKHR(hr = m_rFolder.pFolder->OpenStream(ACCESS_WRITE, m_rFolder.faStream, &m_rFolder.pStream));

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_CloseFolder
// ------------------------------------------------------------------------------------
void CPop3Task::_CloseFolder(void)
{
    // Release the Stream
    SafeRelease(m_rFolder.pStream);

	// Release the reference to the stream. If the stream was reused,
	// it's refCount was incremented down below
    if (m_rFolder.faStream != 0)
    {
        // Must have a folder
        Assert(m_rFolder.pFolder);

        // Delete the Stream
        SideAssert(SUCCEEDED(m_rFolder.pFolder->DeleteStream(m_rFolder.faStream)));

        // Nill
        m_rFolder.faStream = 0;
    }

    // AddRef 
    SafeRelease(m_rFolder.pFolder);
}

// --------------------------------------------------------------------------------
// CPop3Task::_HrStartDeleteCycle
// --------------------------------------------------------------------------------
HRESULT CPop3Task::_HrStartDeleteCycle(void)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;
    LPPOP3ITEM  pItem;

    // Release Folder Objects
    _ReleaseFolderObjects();

    // Check State
    m_rMetrics.cDelete = 0;
    m_rMetrics.iCurrent = 0;

    // Count the number of messages we will have to get a top for
    for (i=0; i<m_rTable.cItems; i++)
    {
        // Readability
        pItem = &m_rTable.prgItem[i];

        // If it was marked for download, and we didn't download it, don't delete it
        if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOAD) && !ISFLAGSET(pItem->dwFlags, POP3ITEM_DOWNLOADED))
            FLAGCLEAR(pItem->dwFlags, POP3ITEM_DELETEOFFSERVER);

        // Is it marked for delete ?
        else if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DELETEOFFSERVER))
            m_rMetrics.cDelete++;
    }

    // Nothing to delete
    if (0 == m_rMetrics.cDelete)
    {
        // Disconnect
        m_pTransport->Disconnect();

        // Done
        goto exit;
    }

    // Setup Progress
    m_rMetrics.iCurrent = 0;
    m_wProgress = 0;
    m_dwProgressCur = 0;
    m_dwProgressMax = m_rMetrics.cDelete;
    m_pUI->SetProgressRange(100);

    // State
    m_state = POP3STATE_DELETING;

    // Do the first one
    CHECKHR(hr = _HrDeleteNextMessage(0));

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrDeleteNextMessage
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrDeleteNextMessage(DWORD dwPopIdCurrent)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRes[CCHMAX_RES];
    CHAR            szMsg[CCHMAX_RES + CCHMAX_RES];
    LPPOP3ITEM      pItem;

    // Mark as deleted
    if (dwPopIdCurrent > 0)
    {
        // Get the item
        pItem = ITEMFROMPOPID(dwPopIdCurrent);

        // Mark as deleted
        FLAGSET(pItem->dwFlags, POP3ITEM_DELETED);
    }

    // Loop until we find the next message that we are downloading
    while(1)
    {
        // Incremenet dwPopIdCurrent
        dwPopIdCurrent++;

        // Last PopId, start the download
        if (dwPopIdCurrent > m_rTable.cItems)
        {
            // Disconnect
            m_pTransport->Disconnect();

            // Done
            break;
        }

        // Readability
        pItem = ITEMFROMPOPID(dwPopIdCurrent);

        // Download this message ?
        if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DELETEOFFSERVER))
        {
            // Increment m_rMetrics.iCurrent
            m_rMetrics.iCurrent++;

            // Status
            //LOADSTRING(IDS_SPS_POP3DELE, szRes);
            //wsprintf(szMsg, szRes, m_rMetrics.iCurrent, m_rMetrics.cDelete);
            //m_pUI->SetSpecificProgress(szMsg);

            // Retrieve this item
            CHECKHR(hr = m_pTransport->CommandDELE(POP3CMD_GET_POPID, dwPopIdCurrent));

            // Count number of items deleted by rule
            if (ISFLAGSET(pItem->dwFlags, POP3ITEM_DELEBYRULE))
                m_rMetrics.cDeleByRule++;

            // Done
            break;
        }
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrBuildFolderPartialMsgs
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrBuildFolderPartialMsgs(IMessageFolder *pFolder, LPPARTIALMSG *ppPartialMsgs,
    ULONG *pcPartialMsgs, ULONG *pcTotalParts)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPARTIALMSG    pPartialMsgs=NULL;
    ULONG           cPartialMsgs=0,
                    iPartialMsg,
                    iMsgPart,
                    i,
                    cTotalParts=0;
    ULONG           cAlloc=0;
    MESSAGEINFO     MsgInfo={0};
    HROWSET         hRowset=NULL;
    BOOL            fKnownPartialId;

    // Check Params
    Assert(pFolder && ppPartialMsgs && pcPartialMsgs);

    // Init
    *ppPartialMsgs = NULL;
    *pcPartialMsgs = 0;
    *pcTotalParts = 0;

    // Create a Rowset
    CHECKHR(hr = pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

	// Loop
	while (S_OK == pFolder->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL))
	{
        // Is this a partial, i.e. does it have a partial id...
        if (!FIsEmptyA(MsgInfo.pszPartialId))
        {
            // Assume we don't know th id
            fKnownPartialId = FALSE;

            // See if I know this partial id
            for (iPartialMsg=0; iPartialMsg<cPartialMsgs; iPartialMsg++)
            {
                if (lstrcmp(MsgInfo.pszPartialId, pPartialMsgs[iPartialMsg].pszId) == 0)
                {
                    fKnownPartialId = TRUE;
                    break;
                }
            }

            // Did we know this message...
            if (fKnownPartialId == FALSE)
            {
                // Realloc my array ?
                if (cPartialMsgs + 1 >= cAlloc)
                {
                    // Realloc the array
                    if (!MemRealloc((LPVOID *)&pPartialMsgs, (cAlloc + 20) * sizeof(PARTIALMSG)))
                    {
                        hr = TrapError(hrMemory);
                        goto exit;
                    }

                    // Zero Init
                    ZeroMemory(pPartialMsgs + cAlloc, 20 * sizeof(PARTIALMSG));

                    // Realloc
                    cAlloc += 20;
                }

                // Set index into partial msgs lsit
                iPartialMsg = cPartialMsgs;

                // Set some stuff
                if (MsgInfo.pszAcctName)
                    lstrcpyn(pPartialMsgs[iPartialMsg].szAccount, MsgInfo.pszAcctName, CCHMAX_ACCOUNT_NAME);
                pPartialMsgs[iPartialMsg].pszId = PszDupA(MsgInfo.pszPartialId);
                pPartialMsgs[iPartialMsg].cTotalParts = LOWORD(MsgInfo.dwPartial);

                // Increment number of known partial messages
                cPartialMsgs++;
            }

            // Otherwise, we know the partial id already...
            else
            {
                // See if this message details the total number of parts
                if (pPartialMsgs[iPartialMsg].cTotalParts == 0)
                    pPartialMsgs[iPartialMsg].cTotalParts = LOWORD(MsgInfo.dwPartial);
            }

            // Can I add one more msgpart into this list
            if (pPartialMsgs[iPartialMsg].cMsgParts + 1 >= pPartialMsgs[iPartialMsg].cAlloc)
            {
                // Realloc the array
                if (!MemRealloc((LPVOID *)&pPartialMsgs[iPartialMsg].pMsgParts, (pPartialMsgs[iPartialMsg].cAlloc + 20) * sizeof(MSGPART)))
                {
                    hr = TrapError(hrMemory);
                    goto exit;
                }

                // Zero Init
                ZeroMemory(pPartialMsgs[iPartialMsg].pMsgParts + pPartialMsgs[iPartialMsg].cAlloc, 20 * sizeof(MSGPART));

                // Realloc
                pPartialMsgs[iPartialMsg].cAlloc += 20;
            }

            // Set Message Part
            iMsgPart = pPartialMsgs[iPartialMsg].cMsgParts;

            // Set Message Info
            pPartialMsgs[iPartialMsg].pMsgParts[iMsgPart].iPart = HIWORD(MsgInfo.dwPartial);
            pPartialMsgs[iPartialMsg].pMsgParts[iMsgPart].msgid = MsgInfo.idMessage;
            //pPartialMsgs[iPartialMsg].pMsgParts[iMsgPart].phi = phi;
            //phi = NULL;

            // Increment the number of parts in the list
            pPartialMsgs[iPartialMsg].cMsgParts++;
        }

        // Free
        pFolder->FreeRecord(&MsgInfo);
    }

    // Lets sort the list by pszId
    for (i=0; i<cPartialMsgs; i++)
    {
        if (pPartialMsgs[i].pMsgParts && pPartialMsgs[i].cMsgParts > 0)
            _QSortMsgParts(pPartialMsgs[i].pMsgParts, 0, pPartialMsgs[i].cMsgParts-1);
        cTotalParts += pPartialMsgs[i].cMsgParts;
    }

    // Success
    *pcPartialMsgs = cPartialMsgs;
    *ppPartialMsgs = pPartialMsgs;
    *pcTotalParts  = cTotalParts;

exit:
    // Cleanup
    if (pFolder)
    {
        pFolder->CloseRowset(&hRowset);
        pFolder->FreeRecord(&MsgInfo);
    }

    // If We failed, free stuff
    if (FAILED(hr))
    {
        _FreePartialMsgs(pPartialMsgs, cPartialMsgs);
        SafeMemFree(pPartialMsgs);
        *ppPartialMsgs = NULL;
        *pcPartialMsgs = 0;
        *pcTotalParts = 0;
    }

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_QSortMsgParts
// ------------------------------------------------------------------------------------
void CPop3Task::_QSortMsgParts(LPMSGPART pMsgParts, LONG left, LONG right)
{
    register    long i, j;
    WORD        k;
    MSGPART     y;

    i = left;
    j = right;
    k = pMsgParts[(left + right) / 2].iPart;

    do
    {
        while(pMsgParts[i].iPart < k && i < right)
            i++;
        while (pMsgParts[j].iPart > k && j > left)
            j--;

        if (i <= j)
        {
            CopyMemory(&y, &pMsgParts[i], sizeof(MSGPART));
            CopyMemory(&pMsgParts[i], &pMsgParts[j], sizeof(MSGPART));
            CopyMemory(&pMsgParts[j], &y, sizeof(MSGPART));
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        _QSortMsgParts(pMsgParts, left, j);
    if (i < right)
        _QSortMsgParts(pMsgParts, i, right);
}


// ------------------------------------------------------------------------------------
// CPop3Task::_FreePartialMsgs
// ------------------------------------------------------------------------------------
void CPop3Task::_FreePartialMsgs(LPPARTIALMSG pPartialMsgs, ULONG cPartialMsgs)
{
    // Locals
    ULONG       i, j;

    // Nothing to free
    if (pPartialMsgs == NULL)
        return;

    // Loop the array
    for (i=0; i<cPartialMsgs; i++)
    {
        SafeMemFree(pPartialMsgs[i].pszId);
#if 0
        for (j=0; j<pPartialMsgs[i].cMsgParts; j++)
        {
            FreeHeaderInfo(pPartialMsgs[i].pMsgParts[j].phi);
        }
#endif
        SafeMemFree(pPartialMsgs[i].pMsgParts);
    }

    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_HrStitchPartials
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_HrStitchPartials(void)
{
    // Locals
    HRESULT             hr = S_OK;
    IMessageFolder     *pInbox=NULL,
                       *pDeletedItems=NULL;
    LPPARTIALMSG        pPartialMsgs=NULL;
    ULONG               cPartialMsgs=0,
                        i,
                        j,
                        cbCacheInfo,
                        cErrors=0,
                        cTotalParts;
    IMimeMessageParts  *pParts=NULL;
    LPMSGPART           pMsgParts;
    IMimeMessage       *pMailMsg=NULL,
                       *pMailMsgSingle=NULL;
    TCHAR               szRes[255];
    PROPVARIANT         rUserData;
    ULONG               cCombined=0;
    MESSAGEIDLIST       List;
    HWND                hwnd;

    // Progress
    AthLoadString(idsStitchingMessages, szRes, ARRAYSIZE(szRes));
    m_pUI->SetSpecificProgress(szRes);
    m_pUI->SetAnimation(idanDecode, TRUE);
    m_pUI->SetProgressRange(100);

    // Get Window
    if (FAILED(m_pUI->GetWindow(&hwnd)))
        hwnd = NULL;

    // open the inbox
    CHECKHR(hr = m_pSpoolCtx->BindToObject(IID_CLocalStoreInbox, (LPVOID *)&pInbox));

    // deleted items folder
    CHECKHR(hr = m_pSpoolCtx->BindToObject(IID_CLocalStoreDeleted, (LPVOID *)&pDeletedItems));

    // Get array of message parts in this folder
    CHECKHR(hr = _HrBuildFolderPartialMsgs(pInbox, &pPartialMsgs, &cPartialMsgs, &cTotalParts));

    // If nothing, were done
    if (pPartialMsgs == NULL || cPartialMsgs == 0)
        goto exit;

    // Setup Progress
    m_rMetrics.iCurrent = 0;
    m_wProgress = 0;
    m_dwProgressCur = 0;
    m_dwProgressMax = cTotalParts;

    // Loop through partial messages list
    for (i=0; i<cPartialMsgs; i++)
    {
        // If we don't know all of the parts yet, continue
        if (pPartialMsgs[i].cTotalParts == 0)
            continue;

        // Or we don't have all of the parts yet...
        if (pPartialMsgs[i].cTotalParts != pPartialMsgs[i].cMsgParts)
            continue;

        // Lets create a mail message list
        Assert(pParts == NULL);

        // Create Parts Object
        CHECKHR(hr = MimeOleCreateMessageParts(&pParts));

        // Set pMsgParts
        pMsgParts = pPartialMsgs[i].pMsgParts;

        // Ok, lets build a message list by opening the messages up out of the store...
        for (j=0; j<pPartialMsgs[i].cMsgParts; j++)
        {
            // Progress
            if (j > 0)
            {
                m_dwProgressCur++;
                _DoProgress();
            }

            // Open this message
            if (FAILED(pInbox->OpenMessage(pMsgParts[j].msgid, NOFLAGS, &pMailMsg, NOSTORECALLBACK)))
            {
                cErrors++;
                hr = TrapError(E_FAIL);
                goto NextPartialMessage;
            }

            // Add into pmml
            pParts->AddPart(pMailMsg);

            // Release It
            SafeRelease(pMailMsg);
        }

        // Create a new message to combine everyting into
        Assert(pMailMsgSingle == NULL);

        // Create a Message
        hr = pParts->CombineParts(&pMailMsgSingle);
        if (FAILED(hr))
        {
            cErrors++;
            TrapError(hr);
            goto NextPartialMessage;
        }

        // Set Account
        HrSetAccount(pMailMsgSingle, pPartialMsgs[i].szAccount);

        // Set Combined Flag
        rUserData.vt = VT_UI4;
        rUserData.ulVal = MESSAGE_COMBINED;
        pMailMsgSingle->SetProp(PIDTOSTR(PID_ATT_COMBINED), NOFLAGS, &rUserData);

        // Save the message
        hr = pMailMsgSingle->Commit(0);
        if (FAILED(hr))
        {
            cErrors++;
            TrapError(hr);
            goto NextPartialMessage;
        }

        // Save It
        hr = pInbox->SaveMessage(NULL, SAVE_MESSAGE_GENID, ARF_RECEIVED, 0, pMailMsgSingle, NOSTORECALLBACK);
        if (FAILED(hr))
        {
            cErrors++;
            TrapError(hr);
            goto NextPartialMessage;
        }

        // Ok, now lets move those original messages to the deleted items folder...
        for (j=0; j<pPartialMsgs[i].cMsgParts; j++)
        {
            // Setup the msgidlsit
            List.cMsgs = 1;
            List.prgidMsg = &pMsgParts[j].msgid;

            // Move msgid to deleted items folder
            CopyMessagesProgress(hwnd, pInbox, pDeletedItems, COPY_MESSAGE_MOVE, &List, NULL);
        }

        // Count Combined
        cCombined++;

        // Cleanup
NextPartialMessage:
        SafeRelease(pMailMsg);
        SafeRelease(pMailMsgSingle);
        SafeRelease(pParts);
    }

    // If I combined parts, apply inbox rules to the inbox
    if (cCombined)
    {
        // Apply to the inbox
        RuleUtil_HrApplyRulesToFolder(RULE_APPLY_PARTIALS, 0, m_pIExecRules, pInbox, NULL, NULL);
    }

exit:
    // Cleanup
    m_pUI->SetSpecificProgress(c_szEmpty);
    m_pUI->SetProgressRange(100);
    SafeRelease(pInbox);
    SafeRelease(pDeletedItems);
    SafeRelease(pParts);
    SafeRelease(pMailMsg);
    SafeRelease(pMailMsgSingle);
    _FreePartialMsgs(pPartialMsgs, cPartialMsgs);
    SafeMemFree(pPartialMsgs);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPop3Task::_GetMoveFolder
// ------------------------------------------------------------------------------------
HRESULT CPop3Task::_GetMoveFolder(LPPOP3ITEM pItem, IMessageFolder ** ppFolder)
{
    HRESULT             hr = S_OK;
    IMessageFolder *    pFolder = NULL;
    ULONG               ulIndex = 0;
    FOLDERID            idFolder = FOLDERID_INVALID;
    FOLDERINFO          infoFolder = {0};
    SPECIALFOLDER       tySpecial = FOLDER_NOTSPECIAL;
    RULEFOLDERDATA *    prfdData = NULL;

    // Check incoming params
    if ((NULL == pItem) || (NULL == ppFolder))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing param
    *ppFolder = NULL;

    // Search for a Move actions
    for (ulIndex = 0; ulIndex < pItem->cActList; ulIndex++)
    {
        switch (pItem->pActList[ulIndex].type)
        {
            case ACT_TYPE_MOVE:
                Assert(VT_BLOB == pItem->pActList[ulIndex].propvar.vt);
                if ((0 != pItem->pActList[ulIndex].propvar.blob.cbSize) && (NULL != pItem->pActList[ulIndex].propvar.blob.pBlobData))
                {
                    // Make life simpler
                    prfdData = (RULEFOLDERDATA *) (pItem->pActList[ulIndex].propvar.blob.pBlobData);
                    
                    // Validate the rule folder data
                    if (S_OK == RuleUtil_HrValidateRuleFolderData(prfdData))
                    {
                        idFolder = prfdData->idFolder;
                    }
                }
                break;
                
            case ACT_TYPE_DELETE:
            case ACT_TYPE_JUNKMAIL:
                Assert(VT_EMPTY == pItem->pActList[ulIndex].propvar.vt);

                tySpecial = (ACT_TYPE_JUNKMAIL == pItem->pActList[ulIndex].type) ? FOLDER_JUNK : FOLDER_DELETED;
                
                hr = g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, tySpecial, &infoFolder);
                if (FAILED(hr))
                {
                    goto exit;;
                }

                idFolder = infoFolder.idFolder;
                break;
        }

        // Are we through?
        if (idFolder != FOLDERID_INVALID)
        {
            break;
        }
    }
    
    // Did we find anything?
    if (ulIndex >= pItem->cActList)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Get the message folder
    hr = m_pIExecRules->GetRuleFolder(idFolder, (DWORD_PTR *) (&pFolder));
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Use the new folder
    *ppFolder = pFolder;
    pFolder = NULL;

    // NULL out the actions
    pItem->pActList[ulIndex].type = ACT_TYPE_NULL;

    // Set the return value
    hr = S_OK;
    
exit:
    SafeRelease(pFolder);
    g_pStore->FreeRecord(&infoFolder);
    return hr;
}

// --------------------------------------------------------------------------------
// CPop3Task::Cancel
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::Cancel(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Canceled
    FLAGSET(m_dwState, POP3STATE_CANCELPENDING);

    // Am I in a state where I can drop the connection???
    if (POP3STATE_UIDLSYNC != m_state)
    {
        if (POP3STATE_UIDLSYNC != m_state && POP3STATE_DOWNLOADING != m_state && POP3STATE_DELETING != m_state)
        {
            // Simply drop the connection
            //If a dialer UI is not dismissed, before changing the identities or shutting down OE, 
            //the transport object would not have been created. This happens only when the dialer UI is not 
            //modal to the window. Right now IE dialer is modal and MSN dialer is not.
            //See Bug# 53679
            
            if (m_pTransport)
                m_pTransport->DropConnection();
        }

        // Otherwise, let the state handle the disconnect
        else
        {
            // Finishing last message...
            m_pUI->SetSpecificProgress(MAKEINTRESOURCE(idsSpoolerDisconnect));
        }
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPop3Task::OnTimeoutResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Should have a handle to the timeout window
    Assert(m_hwndTimeout);

    // No timeout window handle
    m_hwndTimeout = NULL;

    // Stop ?
    if (TIMEOUT_RESPONSE_STOP == eResponse)
    {
        // Canceled
        FLAGSET(m_dwState, POP3STATE_CANCELPENDING);

        // Report error and drop connection
        _CatchResult(IXP_E_TIMEOUT);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPop3Task::IsDialogMessage
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::IsDialogMessage(LPMSG pMsg)
{
    HRESULT hr=S_FALSE;
    EnterCriticalSection(&m_cs);
    if (m_hwndTimeout && IsWindow(m_hwndTimeout))
        hr = (TRUE == ::IsDialogMessage(m_hwndTimeout, pMsg)) ? S_OK : S_FALSE;
    LeaveCriticalSection(&m_cs);
    return hr;
}


// --------------------------------------------------------------------------------
// CPop3Task::OnFlagsChanged
// --------------------------------------------------------------------------------
STDMETHODIMP CPop3Task::OnFlagsChanged(DWORD dwFlags)
    {
    EnterCriticalSection(&m_cs);
    m_dwFlags = dwFlags;
    LeaveCriticalSection(&m_cs);

    return (S_OK);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\newstask.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     newstask.cpp
//
//  PURPOSE:    Implements a task object to take care of news posts.
//

#include "pch.hxx"
#include "resource.h"
#include "imagelst.h"
#include "storfldr.h"
#include "mimeutil.h"
#include "newstask.h"
#include "goptions.h"
#include "thormsgs.h"
#include "spoolui.h"
#include "xputil.h"
#include "ourguid.h"
#include "demand.h"
#include "msgfldr.h"
#include "taskutil.h"
#include <storsync.h>
#include <ntverp.h>

ASSERTDATA

const static char c_szThis[] = "this";

static const PFNSTATEFUNC g_rgpfnState[NTS_MAX] = 
    {
    NULL,                               // Idle
    NULL,                               // Connecting
    &CNewsTask::Post_Init,
    &CNewsTask::Post_NextMsg,
    NULL,                               // Post_OnResp
    &CNewsTask::Post_Dispose,
    &CNewsTask::Post_Done,
    &CNewsTask::NewMsg_Init,
    &CNewsTask::NewMsg_NextGroup,
    NULL,                               // NewMsg_OnResp
    &CNewsTask::NewMsg_HttpSyncStore,
    NULL,                               // NewMsg_OnHttpResp
    &CNewsTask::NewMsg_Done
    };

static const TCHAR c_szXNewsReader[] = "Microsoft Outlook Express " VER_PRODUCTVERSION_STRING;

//
//  FUNCTION:   CNewsTask::CNewsTask()
//
//  PURPOSE:    Initializes the member variables of the object.
//
CNewsTask::CNewsTask()
{
    m_cRef = 1;

    m_fInited = FALSE;
    m_dwFlags = 0;
    m_state = NTS_IDLE;
    m_eidCur = 0;
    m_pInfo = NULL;
    m_fConnectFailed = FALSE;
    m_szAccount[0] = 0;
    m_szAccountId[0] = 0;
    m_idAccount = FOLDERID_INVALID;
    m_pAccount  = NULL;
    m_cEvents = 0;
    m_fCancel = FALSE;

    m_pBindCtx = NULL;
    m_pUI = NULL;

    m_pServer = NULL;
    m_pOutbox = NULL;
    m_pSent = NULL;

    m_hwnd = 0;

    m_cMsgsPost = 0;
    m_cCurPost = 0;
    m_cFailed = 0;
    m_cCurParts = 0;
    m_cPartsCompleted = 0;
    m_fPartFailed = FALSE;
    m_rgMsgInfo = NULL;
    m_pSplitInfo = NULL;
    
    m_cGroups = 0;
    m_cCurGroup = -1;
    m_rgidGroups = NULL;
    m_dwNewInboxMsgs = 0;

    m_pCancel = NULL;
    m_hTimeout = NULL;
    m_tyOperation = SOT_INVALID;
}

//
//  FUNCTION:   CNewsTask::~CNewsTask()
//
//  PURPOSE:    Frees any resources allocated during the life of the class.
//
CNewsTask::~CNewsTask()    
{
    DestroyWindow(m_hwnd);

    FreeSplitInfo();

    SafeMemFree(m_pInfo);

    SafeRelease(m_pBindCtx);
    SafeRelease(m_pUI);
    SafeRelease(m_pAccount);

    if (m_pServer)
    {
        m_pServer->Close(MSGSVRF_HANDS_OFF_SERVER);
        m_pServer->Release();
    }

    Assert(NULL == m_pOutbox);
    Assert(NULL == m_pSent);

    SafeMemFree(m_rgMsgInfo);

    CallbackCloseTimeout(&m_hTimeout);
    SafeRelease(m_pCancel);
}


HRESULT CNewsTask::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (NULL == *ppvObj)
        return (E_INVALIDARG);

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID)(ISpoolerTask *) this;
    else if (IsEqualIID(riid, IID_ISpoolerTask))
        *ppvObj = (LPVOID)(ISpoolerTask *) this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (LPVOID)(IStoreCallback *) this;
    else if (IsEqualIID(riid, IID_ITimeoutCallback))
        *ppvObj = (LPVOID)(ITimeoutCallback *) this;
    
    if (NULL == *ppvObj)
        return (E_NOINTERFACE);

    AddRef();
    return (S_OK);
}


ULONG CNewsTask::AddRef(void)
{
    ULONG cRefT;

    cRefT = ++m_cRef;

    return (cRefT);
}


ULONG CNewsTask::Release(void)
{
    ULONG cRefT;

    cRefT = --m_cRef;

    if (0 == cRefT)
        delete this;

    return (cRefT);
}

static const char c_szNewsTask[] = "News Task";

//
//  FUNCTION:   CNewsTask::Init()
//
//  PURPOSE:    Called by the spooler engine to tell us what type of task to 
//              execute and to provide us with a pointer to our bind context.
//
//  PARAMETERS:
//      <in> dwFlags  - Flags to tell us what types of things to do
//      <in> pBindCtx - Pointer to the bind context interface we are to use
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_ALREADYINITIALIZED
//      S_OK
//      E_OUTOFMEMORY
//
HRESULT CNewsTask::Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx)
{
    HRESULT hr = S_OK;

    // Validate the arguments
    if (NULL == pBindCtx)
        return (E_INVALIDARG);

    // Check to see if we've been initialzed already 
    if (m_fInited)
    {
        hr = SP_E_ALREADYINITIALIZED;
        goto exit;
    }

    // Copy the flags
    m_dwFlags = dwFlags;

    // Copy the bind context pointer
    m_pBindCtx = pBindCtx;
    m_pBindCtx->AddRef();

    // Create the window
    WNDCLASSEX wc;

    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, c_szNewsTask, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = TaskWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hCursor          = NULL;
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szNewsTask;
        wc.hIcon            = NULL;
        wc.hIconSm          = NULL;

        RegisterClassEx(&wc);
    }

    m_hwnd = CreateWindow(c_szNewsTask, NULL, WS_POPUP, 10, 10, 10, 10,
                          GetDesktopWindow(), NULL, g_hInst, this);
    if (!m_hwnd)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    m_fInited = TRUE;

exit:
    return (hr);
}


//
//  FUNCTION:   CNewsTask::BuildEvents()
//
//  PURPOSE:    This method is called by the spooler engine telling us to create
//              and event list for the account specified.  
//
//  PARAMETERS:
//      <in> pAccount - Account object to build the event list for
//
//  RETURN VALUE:
//      SP_E_UNINITALIZED
//      E_INVALIDARG
//      S_OK
//
HRESULT CNewsTask::BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder)
{
    HRESULT         hr;
    BOOL            fIMAP;
    BOOL            fHttp;
    FOLDERINFO      fiFolderInfo;
    DWORD           dw                        = 0;
    ULARGE_INTEGER  uhLastFileTime64          = {0};
    ULARGE_INTEGER  uhCurFileTime64           = {0};
    ULARGE_INTEGER  uhMinPollingInterval64    = {0};
    FILETIME        CurFileTime               = {0};
    DWORD           cb                        = 0;

    Assert(pAccount != NULL);
    Assert(pSpoolerUI != NULL);
    Assert(m_fInited);

    m_pAccount = pAccount;
    m_pAccount->AddRef();

    // Get the account name from the account object
    if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, m_szAccount, ARRAYSIZE(m_szAccount))))
        return(hr);

    // Get the account name from the account object
    if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_ID, m_szAccountId, ARRAYSIZE(m_szAccountId))))
        return(hr);

    if (FAILED(hr = g_pStore->FindServerId(m_szAccountId, &m_idAccount)))
        return(hr);

    // Copy the UI object
    m_pUI = pSpoolerUI;
    m_pUI->AddRef();

    // Create the server object
    hr = g_pStore->GetFolderInfo(m_idAccount, &fiFolderInfo);
    if (FAILED(hr))
        return(hr);

    fIMAP = (fiFolderInfo.tyFolder == FOLDER_IMAP);
    fHttp = (fiFolderInfo.tyFolder == FOLDER_HTTPMAIL);

    hr = CreateMessageServerType(fiFolderInfo.tyFolder, &m_pServer);
    g_pStore->FreeRecord(&fiFolderInfo);
    
    if (FAILED(hr))
        return(hr);

    hr = m_pServer->Initialize(g_pLocalStore, m_idAccount, NULL, FOLDERID_INVALID);
    if (FAILED(hr))
        return(hr);

    if (!fIMAP & !fHttp)
    {
        // Add posts to upload
        if (DELIVER_SEND & m_dwFlags)
            InsertOutbox(m_szAccountId, pAccount);
    }

    if (fHttp)
    {
        if (!!(m_dwFlags & DELIVER_AT_INTERVALS))
        {
            //If this is background polling make sure that HTTP's maxpolling interval has elapsed before
            //polling again.

            cb = sizeof(uhMinPollingInterval64);
            IF_FAILEXIT(hr = pAccount->GetProp(AP_HTTPMAIL_MINPOLLINGINTERVAL, (LPBYTE)&uhMinPollingInterval64, &cb));

            cb = sizeof(uhLastFileTime64);
            IF_FAILEXIT(hr = pAccount->GetProp(AP_HTTPMAIL_LASTPOLLEDTIME, (LPBYTE)&uhLastFileTime64, &cb));

            GetSystemTimeAsFileTime(&CurFileTime);
            uhCurFileTime64.QuadPart = CurFileTime.dwHighDateTime;
            uhCurFileTime64.QuadPart = uhCurFileTime64.QuadPart << 32;
            uhCurFileTime64.QuadPart += CurFileTime.dwLowDateTime;

            //We do not want to do background polling if the last time we polled this http mail
            //account was less than maximum polling interval specified by the server.
            //We should only poll if the time elapsed is greater than or equal to the max polling interval
            if ((uhCurFileTime64.QuadPart - uhLastFileTime64.QuadPart) < uhMinPollingInterval64.QuadPart)
            {
                goto exit;
            }

            //Mark the last polled time.
            hr = pAccount->SetProp(AP_HTTPMAIL_LASTPOLLEDTIME, (LPBYTE)&uhCurFileTime64, sizeof(uhCurFileTime64));
        }
    }
    // Check for new msgs
    if ((DELIVER_POLL & m_dwFlags) && (fIMAP || fHttp || !(m_dwFlags & DELIVER_NO_NEWSPOLL)))
    {
        if (ISFLAGSET(m_dwFlags, DELIVER_NOSKIP) ||
            (!fIMAP && !fHttp && (FAILED(pAccount->GetPropDw(AP_NNTP_POLL, &dw)) || dw != 0)) ||
            (fIMAP  && (FAILED(pAccount->GetPropDw(AP_IMAP_POLL, &dw)) || dw != 0)) ||
            (fHttp  && (FAILED(pAccount->GetPropDw(AP_HTTPMAIL_POLL, &dw)) || dw != 0)))
        {
            InsertNewMsgs(m_szAccountId, pAccount, fHttp);
        }
    }

exit:

    return (hr);
}


//
//  FUNCTION:   CNewsTask::Execute()
//
//  PURPOSE:    This signals our task to start executing an event.
//
//  PARAMETERS:
//      <in> pSpoolerUI - Pointer of the UI object we'll display progress through
//      <in> eid        - ID of the event to execute
//      <in> dwTwinkie - Our extra information we associated with the event
//
//  RETURN VALUE:
//      SP_E_EXECUTING
//      S_OK
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//
HRESULT CNewsTask::Execute(EVENTID eid, DWORD_PTR dwTwinkie)
{
    TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    
    // Make sure we're already idle
    Assert(m_state == NTS_IDLE);
    
    // Make sure we're initialized
    Assert(m_fInited);

    // Copy the event id and event info
    m_eidCur = eid;
    m_pInfo = (EVENTINFO *) dwTwinkie;
    
    // Update the event UI to an executing state
    Assert(m_pUI);
    m_pUI->SetProgressRange(1);

    // Set up the progress
    AthLoadString(idsInetMailConnectingHost, szRes, ARRAYSIZE(szRes));
    wsprintf(szBuf, szRes, m_szAccount);
    m_pUI->SetGeneralProgress(szBuf);

    m_pUI->SetAnimation(idanDownloadNews, TRUE);

    // Depending on the type of event, set the state machine info
    switch (((EVENTINFO*) dwTwinkie)->type)
    {
        case EVENT_OUTBOX:            
            m_state = NTS_POST_INIT;
            break;

        case EVENT_NEWMSGS:
            m_state = NTS_NEWMSG_INIT;
            break;
    }

    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

    return(S_OK);
}

HRESULT CNewsTask::CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie)
{
    // Make sure we're initialized
    Assert(m_fInited);

    Assert(dwTwinkie != 0);
    MemFree((EVENTINFO *)dwTwinkie);

    return(S_OK);
}

//
//  FUNCTION:   CNewsTask::ShowProperties
//
//  PURPOSE:    <???>
//
//  PARAMETERS:
//      <???>
//
//  RETURN VALUE:
//      <???>
//
//  COMMENTS:
//      <???>
//
HRESULT CNewsTask::ShowProperties(HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CNewsTask::GetExtendedDetails
//
//  PURPOSE:    <???>
//
//  PARAMETERS:
//      <???>
//
//  RETURN VALUE:
//      <???>
//
//  COMMENTS:
//      <???>
//
HRESULT CNewsTask::GetExtendedDetails(EVENTID eid, DWORD_PTR dwTwinkie, 
                                      LPSTR *ppszDetails)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CNewsTask::Cancel
//
//  PURPOSE:    <???>
//
//  PARAMETERS:
//      <???>
//
//  RETURN VALUE:
//      <???>
//
//  COMMENTS:
//      <???>
//
HRESULT CNewsTask::Cancel(void)
{
    // this can happen if user cancels out of connect dlg
    if (m_state == NTS_IDLE)
        return(S_OK);

    // Drop the server connection
    if (m_pServer)
        m_pServer->Close(MSGSVRF_DROP_CONNECTION);

    m_fCancel = TRUE;

    if (m_pInfo->type == EVENT_OUTBOX)
        m_state = NTS_POST_END;
    else
        m_state = NTS_NEWMSG_END;
    
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

    return (S_OK);
}


//
//  FUNCTION:   CNewsTask::InsertOutbox()
//
//  PURPOSE:    Checks the outbox for news posts destine for this news account.
//
//  PARAMETERS:
//      <in> pszAcctId - ID of the account to check the outbox for.
//
//  RETURN VALUE:
//      E_UNEXECTED 
//      E_OUTOFMEMORY 
//      S_OK
//
HRESULT CNewsTask::InsertOutbox(LPTSTR pszAcctId, IImnAccount *pAccount)
{
    HRESULT            hr = S_OK;
    IMessageFolder    *pOutbox = NULL;
    MESSAGEINFO        MsgInfo={0};
    HROWSET            hRowset=NULL;

    // Get the outbox
    if (FAILED(hr = m_pBindCtx->BindToObject(IID_CLocalStoreOutbox, (LPVOID *) &pOutbox)))
        goto exit;

    // Loop through the outbox looking for posts to this server
    m_cMsgsPost = 0;

    // Create a Rowset
    if (FAILED(hr = pOutbox->CreateRowset(IINDEX_PRIMARY, 0, &hRowset)))
        goto exit;

    // Get the first message
	while (S_OK == pOutbox->QueryRowset(hRowset, 1, (void **)&MsgInfo, NULL))
    {
        // Has this message been submitted and is it a news message?
        if ((MsgInfo.dwFlags & (ARF_SUBMITTED | ARF_NEWSMSG)) == (ARF_SUBMITTED | ARF_NEWSMSG))
        {
            // Is the account the same as the account we're looking for
            if (MsgInfo.pszAcctId && 0 == lstrcmpi(MsgInfo.pszAcctId, pszAcctId))
                m_cMsgsPost++;
        }

        // Free the header info
        pOutbox->FreeRecord(&MsgInfo);
    }

    // Release Lock
    pOutbox->CloseRowset(&hRowset);

    // Good to go
    hr = S_OK;

    // If there were any messages then add the event
    if (m_cMsgsPost)
    {
        EVENTINFO *pei = NULL;
        TCHAR      szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
        EVENTID    eid;

        // Allocate a structure to set as our cookie
        if (!MemAlloc((LPVOID*) &pei, sizeof(EVENTINFO)))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        // Fill out the event info
        pei->szGroup[0] = 0;
        pei->type = EVENT_OUTBOX;

        // Create the event description
        AthLoadString(idsNewsTaskPost, szRes, ARRAYSIZE(szRes));
        wsprintf(szBuf, szRes, m_cMsgsPost, m_szAccount);

        // Insert the event into the spooler
        hr = m_pBindCtx->RegisterEvent(szBuf, this, (DWORD_PTR) pei, pAccount, &eid);
        if (FAILED(hr))
            goto exit;

        m_cEvents++;

    } // if (m_cMsgsPost)

exit:
    // Release Lock
    if (pOutbox)
        pOutbox->CloseRowset(&hRowset);
    SafeRelease(pOutbox);
    return (hr);
}


//
//  FUNCTION:   CNewsTask::TaskWndProc()
//
//  PURPOSE:    Hidden window that processes messages for this task.
//
LRESULT CALLBACK CNewsTask::TaskWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                        LPARAM lParam)
{
    CNewsTask *pThis = (CNewsTask *) GetProp(hwnd, c_szThis);

    switch (uMsg)
    {
        case WM_CREATE:
        {
            LPCREATESTRUCT pcs = (LPCREATESTRUCT) lParam;
            pThis = (CNewsTask *) pcs->lpCreateParams;
            SetProp(hwnd, c_szThis, (LPVOID) pThis);
            return (0);
        }

        case NTM_NEXTSTATE:
            if (pThis)
            {
                pThis->AddRef();
                pThis->NextState();
                pThis->Release();
            }
            return (0);

        case WM_DESTROY:
            RemoveProp(hwnd, c_szThis);
            break;
    }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
}


//
//  FUNCTION:   CNewsTask::Post_Init()
//
//  PURPOSE:    Called when we're in a NTS_POST_INIT state.  The task is 
//              initialized to execute the posting event.
//
//  RETURN VALUE:
//      E_OUTOFMEMORY
//      E_UNEXPECTED
//      S_OK
//
HRESULT CNewsTask::Post_Init(void)
{
    HRESULT     hr = S_OK;
    DWORD       dwCur = 0;
    MESSAGEINFO MsgInfo={0};
    HROWSET     hRowset=NULL;
    BOOL        fInserted = FALSE;
    TCHAR      *pszAcctName = NULL;

    // Open the outbox
    Assert(m_pBindCtx);
    if (FAILED(hr = m_pBindCtx->BindToObject(IID_CLocalStoreOutbox, (LPVOID *) &m_pOutbox)))
        goto exit;

    Assert(m_pSent == NULL);

    // If we use sent items, get that pointer too
    if (DwGetOption(OPT_SAVESENTMSGS))
    {
        if (FAILED(hr = TaskUtil_OpenSentItemsFolder(m_pAccount, &m_pSent)))
            goto exit;
        Assert(m_pSent != NULL);
    }

    // Allocate an array of header pointers for the messages we're going to post
    if (!MemAlloc((LPVOID*) &m_rgMsgInfo, m_cMsgsPost * sizeof(MESSAGEINFO)))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Zero out the array
    ZeroMemory(m_rgMsgInfo, m_cMsgsPost * sizeof(MESSAGEINFO));

    // Create Rowset
    if (FAILED(hr = m_pOutbox->CreateRowset(IINDEX_PRIMARY, 0, &hRowset)))
        goto exit;

    // While we have stuff
    while (S_OK == m_pOutbox->QueryRowset(hRowset, 1, (void **)&MsgInfo, NULL))
    {
        // Has this message been submitted and is it a news message?
        if ((MsgInfo.dwFlags & (ARF_SUBMITTED | ARF_NEWSMSG)) == (ARF_SUBMITTED | ARF_NEWSMSG))
        {
            // Is the account the same as the account we're looking for
            if (MsgInfo.pszAcctId && 0 == lstrcmpi(MsgInfo.pszAcctId, m_szAccountId))
            {
                if (NULL == pszAcctName && MsgInfo.pszAcctName)
                    pszAcctName  = PszDup(MsgInfo.pszAcctName);

                CopyMemory(&m_rgMsgInfo[dwCur++], &MsgInfo, sizeof(MESSAGEINFO));
                ZeroMemory(&MsgInfo, sizeof(MESSAGEINFO));
            }
        }

        // Free the header info
        m_pOutbox->FreeRecord(&MsgInfo);
    }

    // Release Lock
    m_pOutbox->CloseRowset(&hRowset);

    // Good to go
    hr = S_OK;

    //Assert(dwCur);

    // Update the UI to an executing state
    Assert(m_pUI);

    // Set up the progress
    TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    AthLoadString(idsProgDLPostTo, szRes, ARRAYSIZE(szRes));
    wsprintf(szBuf, szRes, (LPTSTR) pszAcctName ? pszAcctName : "");

    Assert(m_pUI);
    m_pUI->SetGeneralProgress(szBuf);
    m_pUI->SetProgressRange((WORD) m_cMsgsPost);

    m_pUI->SetAnimation(idanOutbox, TRUE);
    m_pBindCtx->Notify(DELIVERY_NOTIFY_SENDING_NEWS, 0);

    // Reset the counter to post the first message
    m_cCurPost = -1;
    m_cFailed = 0;
    m_state = NTS_POST_NEXT;

exit:
    
    SafeMemFree(pszAcctName);

    if (m_pOutbox)
        m_pOutbox->CloseRowset(&hRowset);

    // If something failed, then update the UI
    if (FAILED(hr))
    {
        m_pUI->InsertError(m_eidCur, MAKEINTRESOURCE(idshrCantOpenOutbox));
        m_cFailed = m_cMsgsPost;

        // Move to a terminating state
        m_state = NTS_POST_END;        
    }
        
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    return (hr);
}

void CNewsTask::FreeSplitInfo()
{
    if (m_pSplitInfo != NULL)
    {
        if (m_pSplitInfo->pEnumParts != NULL)
            m_pSplitInfo->pEnumParts->Release();
        if (m_pSplitInfo->pMsgParts != NULL)
            m_pSplitInfo->pMsgParts->Release();
        MemFree(m_pSplitInfo);
        m_pSplitInfo = NULL;
    }
}

HRESULT CNewsTask::Post_NextPart(void)
{
    LPMIMEMESSAGE pMsgSplit;
    HRESULT hr;
    LPSTREAM pStream;
    LPMESSAGEINFO pInfo;
    DWORD dwLines;
    char rgch[12];
    PROPVARIANT rUserData;

    Assert(m_pSplitInfo->pEnumParts != NULL);

    pInfo = &m_rgMsgInfo[m_cCurPost];

    hr = m_pSplitInfo->pEnumParts->Next(1, &pMsgSplit, NULL);
    if (hr == S_OK)
    {
        Assert(pMsgSplit);

        rUserData.vt = VT_LPSTR;
        rUserData.pszVal = (LPSTR)pInfo->pszAcctName;
        pMsgSplit->SetProp(STR_ATT_ACCOUNTNAME, 0, &rUserData);
        rUserData.pszVal = pInfo->pszAcctId;;
        pMsgSplit->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), 0, &rUserData);

        // since this is a new message it doesn't have a line
        // count yet, so we need to do it before we stick it
        // in the outbox
        HrComputeLineCount(pMsgSplit, &dwLines);
        wsprintf(rgch, "%d", dwLines);
        MimeOleSetBodyPropA(pMsgSplit, HBODY_ROOT, PIDTOSTR(PID_HDR_LINES), NOFLAGS, rgch);
		MimeOleSetBodyPropA(pMsgSplit, HBODY_ROOT, PIDTOSTR(PID_HDR_XNEWSRDR), NOFLAGS, c_szXNewsReader);
        // Final Parameter: fSaveChange = TRUE since messsage is dirty

        hr = pMsgSplit->GetMessageSource(&pStream, 0);
        if (SUCCEEDED(hr) && pStream != NULL)
        {
            hr = m_pServer->PutMessage(m_pSplitInfo->idFolder, pInfo->dwFlags, &pInfo->ftReceived, pStream, this);

            m_cCurParts++;

            pStream->Release();
        }
        
        pMsgSplit->Release();
    }

    return(hr);
}

//
//  FUNCTION:   CNewsTask::Post_NextMsg()
//
//  PURPOSE:    Posts the next message in our outbox.
//
//  RETURN VALUE:
//      <???>
//
HRESULT CNewsTask::Post_NextMsg(void)
{
    LPMESSAGEINFO   pInfo;
    FOLDERID        idFolder;
    char            szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    DWORD           dw, cbSize, cbMaxSendMsgSize;
    IImnAccount    *pAcct;
    LPMIMEMESSAGE   pMsg = 0;
    HRESULT         hr = S_OK;
    IStream        *pStream = NULL;

    if (m_pSplitInfo != NULL)
    {
        hr = Post_NextPart();
        Assert(hr != S_OK);
        if (hr == E_PENDING)
        {
            m_state = NTS_POST_RESP;
            return(S_OK);
        }
        
        FreeSplitInfo();

        if (FAILED(hr))
        {
            m_cFailed++;
            m_fPartFailed = TRUE;
        }

        Assert(m_pUI);
        m_pUI->IncrementProgress(1);
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

        return(S_OK);
    }

    m_cCurPost++;
    m_cCurParts = 0;
    m_cPartsCompleted = 0;
    m_fPartFailed = FALSE;

    // Check to see if we're already done
    if (m_cCurPost >= m_cMsgsPost)
    {
        // If so, move to a cleanup state
        m_state = NTS_POST_END;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        return(S_OK);
    }

    // Update the progress UI
    AthLoadString(idsProgDLPost, szRes, ARRAYSIZE(szRes));
    wsprintf(szBuf, szRes, m_cCurPost + 1, m_cMsgsPost);

    Assert(m_pUI);
    m_pUI->SetSpecificProgress(szBuf);

    pInfo = &m_rgMsgInfo[m_cCurPost];

    // Load the message stream from the store
    if (SUCCEEDED(hr = m_pOutbox->OpenMessage(pInfo->idMessage, OPEN_MESSAGE_SECURE, &pMsg, this)))
    {
        hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pInfo->pszAcctId, &pAcct);
        if (SUCCEEDED(hr))
        {
            hr = g_pStore->FindServerId(pInfo->pszAcctId, &idFolder);
            if (SUCCEEDED(hr))
            {
                if (SUCCEEDED(pAcct->GetPropDw(AP_NNTP_SPLIT_MESSAGES, &dw)) &&
                    dw != 0 &&
                    SUCCEEDED(pAcct->GetPropDw(AP_NNTP_SPLIT_SIZE, &dw)))
                {
                    cbMaxSendMsgSize = dw;
                }
                else
                {
                    cbMaxSendMsgSize = 0xffffffff;
                }

                SideAssert(pMsg->GetMessageSize(&cbSize, 0)==S_OK);
                if (cbSize < (cbMaxSendMsgSize * 1024))
                {
                    hr = pMsg->GetMessageSource(&pStream, 0);
                    if (SUCCEEDED(hr) && pStream != NULL)
                    {
                        hr = m_pServer->PutMessage(idFolder,
                                        pInfo->dwFlags,
                                        &pInfo->ftReceived,
                                        pStream,
                                        this);
                        m_cCurParts ++;
                        pStream->Release();
                    }
                }
                else
                {
                    Assert(m_pSplitInfo == NULL);
                    if (!MemAlloc((void **)&m_pSplitInfo, sizeof(SPLITMSGINFO)))
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        ZeroMemory(m_pSplitInfo, sizeof(SPLITMSGINFO));
                        m_pSplitInfo->idFolder = idFolder;

                        hr = pMsg->SplitMessage(cbMaxSendMsgSize * 1024, &m_pSplitInfo->pMsgParts);
                        if (hr == S_OK)
                        {
                            hr = m_pSplitInfo->pMsgParts->EnumParts(&m_pSplitInfo->pEnumParts);
                            if (hr == S_OK)
                            {
                                hr = Post_NextPart();
                            }
                        }

                        if (hr != E_PENDING)
                            FreeSplitInfo();
                    }
                }
            }

            pAcct->Release();
        }

        if (hr == E_PENDING)
        {
            m_state = NTS_POST_RESP;
            hr = S_OK;
            goto exit;
        }
    }

    // If we get here, something failed.
    m_cFailed++;
    Assert(m_pUI);
    m_pUI->IncrementProgress(1);
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

exit:
    SafeRelease(pMsg);
    return (hr);
}

HRESULT CNewsTask::Post_Dispose()
{
    HRESULT hr;

    hr = DisposeOfPosting(m_rgMsgInfo[m_cCurPost].idMessage);

    if (hr == E_PENDING)
        return(S_OK);

    // TODO: handle error

    // Update the progress bar
    Assert(m_pUI);
    m_pUI->IncrementProgress(1);

    // Move on to the next post
    m_state = NTS_POST_NEXT;
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);

    return(hr);
}

//
//  FUNCTION:   CNewsTask::Post_Done()
//
//  PURPOSE:    Allows the posting event to clean up and finalize the UI.
//
//  RETURN VALUE:
//      S_OK
//
HRESULT CNewsTask::Post_Done(void)
{
    // Free the header array
    if (m_rgMsgInfo && m_cMsgsPost)
    {
        for (LONG i=0; i<m_cMsgsPost; i++)
            m_pOutbox->FreeRecord(&m_rgMsgInfo[i]);
        MemFree(m_rgMsgInfo);
    }

    // Free the folder pointers we're hanging on to
    SafeRelease(m_pOutbox);
    SafeRelease(m_pSent);

    // Tell the spooler we're done
    Assert(m_pBindCtx);
    m_pBindCtx->Notify(DELIVERY_NOTIFY_COMPLETE, m_dwNewInboxMsgs);

    if (m_fCancel)
    {
        m_pBindCtx->EventDone(m_eidCur, EVENT_CANCELED);
        m_fCancel = FALSE;
    }
    else if (m_cFailed == m_cMsgsPost)
        m_pBindCtx->EventDone(m_eidCur, EVENT_FAILED);
    else if (m_cFailed == 0)
        m_pBindCtx->EventDone(m_eidCur, EVENT_SUCCEEDED);
    else
        m_pBindCtx->EventDone(m_eidCur, EVENT_WARNINGS);

    m_cMsgsPost = 0;
    m_cCurPost = 0;
    m_cFailed = 0;
    m_rgMsgInfo = NULL;
    SafeMemFree(m_pInfo);

    m_eidCur = 0;

    m_cEvents--;
    if (m_cEvents == 0 && m_pServer)
        m_pServer->Close(MSGSVRF_DROP_CONNECTION);

    m_state = NTS_IDLE;

    return (S_OK);
}

HRESULT CNewsTask::DisposeOfPosting(MESSAGEID dwMsgID)
{
    MESSAGEIDLIST MsgIdList;
    ADJUSTFLAGS AdjustFlags;
    HRESULT hrResult = E_FAIL;
    
    MsgIdList.cAllocated = 0;
    MsgIdList.cMsgs = 1;
    MsgIdList.prgidMsg = &dwMsgID;

    if (DwGetOption(OPT_SAVESENTMSGS))
    {
        // If we've reached this point, it's time to try local Sent Items folder
        Assert(m_pSent != NULL);

        // change msg flags first, so if copy fails, the user doesn't get
        // messed up by us posting the message every time they do a send
        AdjustFlags.dwRemove = ARF_SUBMITTED | ARF_UNSENT;
        AdjustFlags.dwAdd = ARF_READ;

        hrResult = m_pOutbox->SetMessageFlags(&MsgIdList, &AdjustFlags, NULL, NULL);
        Assert(hrResult != E_PENDING);
        if (SUCCEEDED(hrResult))
            hrResult = m_pOutbox->CopyMessages(m_pSent, COPY_MESSAGE_MOVE, &MsgIdList, NULL, NULL, this);
    }
    else
    {
        // If we've reached this point, it's time to delete the message from the Outbox
        hrResult = m_pOutbox->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &MsgIdList, NULL, this);
    }

    return hrResult;
}

//
//  FUNCTION:   CNewsTask::NextState()
//
//  PURPOSE:    Executes the function for the current state
//
void CNewsTask::NextState(void)
{
    if (NULL != g_rgpfnState[m_state])
        (this->*(g_rgpfnState[m_state]))();
}

HRESULT CNewsTask::InsertNewMsgs(LPSTR pszAccountId, IImnAccount *pAccount, BOOL fHttp)
    {
    HRESULT hr = S_OK;
    ULONG cSub = 0;
    IEnumerateFolders *pEnum = NULL;

    if (fHttp)
        m_cGroups = 1;
    else
    {
        // Load the sublist for this server
        Assert(m_idAccount != FOLDERID_INVALID);
        hr = g_pStore->EnumChildren(m_idAccount, TRUE, &pEnum);
        if (FAILED(hr))
            goto exit;

        hr = pEnum->Count(&cSub);
        if (FAILED(hr))
            goto exit;

        m_cGroups = (int)cSub;
    }

    // If there were any groups then add the event
    if (m_cGroups)
        {
        EVENTINFO *pei;
        char       szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
        EVENTID    eid;

        // Allocate a structure to set as our cookie
        if (!MemAlloc((LPVOID*) &pei, sizeof(EVENTINFO)))
            {
            hr = E_OUTOFMEMORY;
            goto exit;
            }

        // Fill out the event info
        pei->szGroup[0] = 0;
        pei->type = EVENT_NEWMSGS;

        // Create the event description
        AthLoadString(idsCheckNewMsgsServer, szRes, ARRAYSIZE(szRes));
        wsprintf(szBuf, szRes, m_szAccount);

        // Insert the event into the spooler
        hr = m_pBindCtx->RegisterEvent(szBuf, this, (DWORD_PTR) pei, pAccount, &eid); 
        m_cEvents++;
        }

exit:
    SafeRelease(pEnum);
    return (hr);
    }


HRESULT CNewsTask::NewMsg_InitHttp(void)
{
    HRESULT         hr = S_OK;

    // Set up the progress
    TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    AthLoadString(IDS_SPS_POP3CHECKING, szRes, ARRAYSIZE(szRes));
    wsprintf(szBuf, szRes, (LPTSTR) m_szAccount);
 
    Assert(m_pUI);
    m_pUI->SetGeneralProgress(szBuf);
    m_pUI->SetProgressRange(1);
    
    m_pUI->SetAnimation(idanInbox, TRUE);
    m_pBindCtx->Notify(DELIVERY_NOTIFY_CHECKING, 0);

    // set the to generate correct success/failure message
    m_cGroups = 1;

    m_state = NTS_NEWMSG_HTTPSYNCSTORE;

    return hr;
}

HRESULT CNewsTask::NewMsg_Init(void)
    {
    const       BOOL    fDONT_INCLUDE_PARENT    = FALSE;
    const       BOOL    fSUBSCRIBED_ONLY        = TRUE;
    FOLDERINFO          FolderInfo              = {0};
    HRESULT             hr                      = S_OK;
    DWORD               dwAllocated;
    DWORD               dwUsed;
    BOOL                fImap                   = FALSE;
    DWORD               dwIncludeAll            = 0;
    DWORD               dwDone                  = FALSE;

    Assert(m_idAccount != FOLDERID_INVALID);

    if (SUCCEEDED(g_pStore->GetFolderInfo(m_idAccount, &FolderInfo)))
    {
        // httpmail updates folder counts differently
        if (FOLDER_HTTPMAIL == FolderInfo.tyFolder)
        {
            g_pStore->FreeRecord(&FolderInfo);

            IF_FAILEXIT(hr = m_pAccount->GetPropDw(AP_HTTPMAIL_GOTPOLLINGINTERVAL, &dwDone));
            if (!dwDone)
            {
                //We need to get the polling interval from the server
                //This is an asynchrnous call. The value gets updated in OnComplete. 
                //Meanwhile we go ahead and poll for new messages
                hr = m_pServer->GetMinPollingInterval((IStoreCallback*)this);
            }

            hr = NewMsg_InitHttp();
            goto exit;
        }

        fImap = (FolderInfo.tyFolder == FOLDER_IMAP);
        if (fImap)
        {
            if (FAILED(hr = m_pAccount->GetPropDw(AP_IMAP_POLL_ALL_FOLDERS, &dwIncludeAll)))
            {
                dwIncludeAll = 0;
            }
        }

        g_pStore->FreeRecord(&FolderInfo);
    }

    if (fImap && (!dwIncludeAll))
    {
        dwUsed = 0;
        if (FAILED(GetInboxId(g_pStore, m_idAccount, &m_rgidGroups, &dwUsed)))
            goto exit;
    }
    else
    {
        // Get an array of all subscribed folders
        hr = FlattenHierarchy(g_pStore, m_idAccount, fDONT_INCLUDE_PARENT,
            fSUBSCRIBED_ONLY, &m_rgidGroups, &dwAllocated, &dwUsed);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

    m_cGroups = dwUsed;

    // Set up the progress
    TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    AthLoadString(IDS_SPS_POP3CHECKING, szRes, ARRAYSIZE(szRes));
    wsprintf(szBuf, szRes, (LPTSTR) m_szAccount);

    Assert(m_pUI);
    m_pUI->SetGeneralProgress(szBuf);
    m_pUI->SetProgressRange((WORD) m_cGroups);

    if (fImap)
    {
        m_pUI->SetAnimation(idanInbox, TRUE);
        m_pBindCtx->Notify(DELIVERY_NOTIFY_CHECKING, 0);
    }
    else
    {
        m_pUI->SetAnimation(idanDownloadNews, TRUE);
        m_pBindCtx->Notify(DELIVERY_NOTIFY_CHECKING_NEWS, 0);
    }

    // Reset the counters for the first group
    m_cCurGroup = -1;
    m_cFailed = 0;
    m_state = NTS_NEWMSG_NEXTGROUP;

exit:
    // If something failed, update the UI
    if (FAILED(hr))
        {
        m_pUI->InsertError(m_eidCur, MAKEINTRESOURCE(idsErrNewMsgsFailed));
        m_cFailed = m_cGroups;

        // Move to a terminating state
        m_state = NTS_NEWMSG_END;
        }

    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    return (hr);
    }

HRESULT CNewsTask::NewMsg_NextGroup(void)
    {
    HRESULT hr = E_FAIL;

    do
    {
        FOLDERINFO info;

        // Keep looping until we find a folder that's selectable and exists
        m_cCurGroup++;

        // Check to see if we're already done
        if (m_cCurGroup >= m_cGroups)
        {
            m_state = NTS_NEWMSG_END;
            hr = S_OK;
            PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
            break;
        }

        if (SUCCEEDED(hr = g_pStore->GetFolderInfo(m_rgidGroups[m_cCurGroup], &info)))
        {
            if (0 == (info.dwFlags & (FOLDER_NOSELECT | FOLDER_NONEXISTENT)))
            {
                // Update the progress UI
                TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
                AthLoadString(idsLogCheckingNewMessages, szRes, ARRAYSIZE(szRes));
                wsprintf(szBuf, szRes, info.pszName);

                g_pStore->FreeRecord(&info);

                Assert(m_pUI);
                m_pUI->SetSpecificProgress(szBuf);

                // Send the group command to the server
                if (E_PENDING == (hr = m_pServer->GetFolderCounts(m_rgidGroups[m_cCurGroup], (IStoreCallback *)this)))
                {
                    m_state = NTS_NEWMSG_RESP;
                    hr = S_OK;
                }

                break;
            }
            else
            {
                g_pStore->FreeRecord(&info);
            }
        }
    } while (1);


    if (FAILED(hr))
    {
        // If we get here, something failed
        m_cFailed++;
        Assert(m_pUI);
        m_pUI->IncrementProgress(1);
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    }

    return (hr);
    }

HRESULT CNewsTask::NewMsg_HttpSyncStore(void)
{
    HRESULT     hr = S_OK;

    // send the command to the server
    hr = m_pServer->SynchronizeStore(FOLDERID_INVALID, NOFLAGS, (IStoreCallback  *)this);
    if (E_PENDING == hr)
    {
        m_state = NTS_NEWMSG_HTTPRESP;
        hr = S_OK;
    }

    return hr;
}

HRESULT CNewsTask::NewMsg_Done(void)
    {
    HRESULT hr = S_OK;

    // Free the group array
    if (m_rgidGroups)
        {
        MemFree(m_rgidGroups);
        m_rgidGroups = NULL;
        }

    SafeMemFree(m_pInfo);

    // Tell the spooler we're done
    Assert(m_pBindCtx);
    m_pBindCtx->Notify(DELIVERY_NOTIFY_COMPLETE, m_dwNewInboxMsgs);

    if (m_fCancel)
        {
        m_pBindCtx->EventDone(m_eidCur, EVENT_CANCELED);
        m_fCancel = FALSE;
        }
    else if (m_cFailed == m_cGroups)
        m_pBindCtx->EventDone(m_eidCur, EVENT_FAILED);
    else if (m_cFailed == 0)
        m_pBindCtx->EventDone(m_eidCur, EVENT_SUCCEEDED);
    else
        m_pBindCtx->EventDone(m_eidCur, EVENT_WARNINGS);

    m_cGroups = 0;
    m_cCurGroup = 0;
    m_cFailed = 0;
    m_dwNewInboxMsgs = 0;

    m_eidCur = 0;

    m_cEvents--;
    if (m_cEvents == 0 && m_pServer)
        m_pServer->Close(MSGSVRF_DROP_CONNECTION);

    m_state = NTS_IDLE;

    return (S_OK);
    }

// --------------------------------------------------------------------------------
// CNewsTask::IsDialogMessage
// --------------------------------------------------------------------------------
STDMETHODIMP CNewsTask::IsDialogMessage(LPMSG pMsg)
{
    return S_FALSE;
}


STDMETHODIMP CNewsTask::OnFlagsChanged(DWORD dwFlags)
{
    m_dwFlags = dwFlags;

    return (S_OK);
}


STDMETHODIMP CNewsTask::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    // Hold onto this
    Assert(m_tyOperation == SOT_INVALID);

    if (pCancel)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }
    m_tyOperation = tyOperation;

    // Party On
    return(S_OK);
}

STDMETHODIMP CNewsTask::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // NOTE: that you can get more than one type of value for tyOperation.
    //       Most likely, you will get SOT_CONNECTION_STATUS and then the
    //       operation that you might expect. See HotStore.idl and look for
    //       the STOREOPERATION enumeration type for more info.

    switch (tyOperation)
    {
        case SOT_NEW_MAIL_NOTIFICATION:
            m_dwNewInboxMsgs = dwCurrent;
            break;
    }

    // Done
    return(S_OK);
}

STDMETHODIMP CNewsTask::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);

    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

STDMETHODIMP CNewsTask::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND hwnd;
    BOOL fPrompt = TRUE;

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into general CanConnect Utility
    if ((m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)) || (dwFlags & CC_FLAG_DONTPROMPT))
        fPrompt = FALSE;

    return CallbackCanConnect(pszAccountId, hwnd, fPrompt);
}

STDMETHODIMP CNewsTask::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    HWND hwnd;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)) &&
        !(ISFLAGSET(pServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) &&
        '\0' == pServer->szPassword[0]))
        return(S_FALSE);

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(hwnd, pServer, ixpServerType);
}

STDMETHODIMP CNewsTask::OnComplete(STOREOPERATIONTYPE   tyOperation, HRESULT        hrComplete, 
                                   LPSTOREOPERATIONINFO pOpInfo,     LPSTOREERROR   pErrorInfo)
{
    char            szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES * 2], szSubject[64];
    NEWSTASKSTATE   ntsNextState = NTS_MAX;
    LPSTR           pszSubject = NULL;
    LPSTR           pszOpDescription = NULL;
    BOOL            fInsertError = FALSE;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    IxpAssert(m_tyOperation != SOT_INVALID);
    if (m_tyOperation != tyOperation)
        return(S_OK);

    switch (tyOperation)
    {
        case SOT_PUT_MESSAGE:
            m_cPartsCompleted ++;

            // Figure out if we succeeded or failed
            if (FAILED(hrComplete))
            {
                if (!m_fPartFailed )
                {
                    Assert(m_pUI);

                    // Set us up to display the error
                    pszOpDescription = MAKEINTRESOURCE(idsNewsTaskPostError);
                    pszSubject = m_rgMsgInfo[m_cCurPost].pszSubject;
                    if (pszSubject == NULL || *pszSubject == 0)
                    {
                        AthLoadString(idsNoSubject, szSubject, ARRAYSIZE(szSubject));
                        pszSubject = szSubject;
                    }
                    fInsertError = TRUE;

                    m_cFailed++;
                    m_fPartFailed = TRUE;
                }
            }

            if (m_cPartsCompleted == m_cCurParts)
            {
                if (m_fPartFailed)
                {
                    // Update the progress bar
                    Assert(m_pUI);
                    m_pUI->IncrementProgress(1);

                    // Move on to the next post
                    ntsNextState = NTS_POST_NEXT;
                }
                else
                {
                    ntsNextState = NTS_POST_DISPOSE;
                }
            }

            break; // case SOT_PUT_MESSAGE


        case SOT_UPDATE_FOLDER:
            if (FAILED(hrComplete))
                {
                FOLDERINFO  fiFolderInfo;

                Assert(m_pUI);

                LoadString(g_hLocRes, idsUnreadCountPollErrorFmt, szRes, sizeof(szRes));
                if (SUCCEEDED(g_pStore->GetFolderInfo(m_rgidGroups[m_cCurGroup], &fiFolderInfo)))
                {
                    wsprintf(szBuf, szRes, fiFolderInfo.pszName);
                    g_pStore->FreeRecord(&fiFolderInfo);
                }
                else
                {
                    LoadString(g_hLocRes, idsUnknown, szSubject, sizeof(szSubject));
                    wsprintf(szBuf, szRes, szSubject);
                }
                pszOpDescription = szBuf;
                fInsertError = TRUE;

                m_cFailed++;
                }

            // Update the progress bar
            m_pUI->IncrementProgress(1);

            // Move on to the next group
            ntsNextState = NTS_NEWMSG_NEXTGROUP;

            break; // case SOT_UPDATE_FOLDER

        case SOT_SYNCING_STORE:
            if (( IXP_E_HTTP_NOT_MODIFIED != hrComplete) && (FAILED(hrComplete)))
            {  
                LoadString(g_hLocRes, idsHttpPollFailed, szBuf, sizeof(szBuf));
                pszOpDescription = szBuf;
                fInsertError = TRUE;

                m_cFailed++;
            }

            // update the progress bar
            m_pUI->IncrementProgress(1);

            // we're done
            ntsNextState = NTS_NEWMSG_END;

            break; // case SOT_SYNCING_STORE

        case SOT_COPYMOVE_MESSAGE:
            // Update the progress bar
            Assert(m_pUI);
            m_pUI->IncrementProgress(1);

            // Move on to the next post
            ntsNextState = NTS_POST_NEXT;

            if (FAILED(hrComplete))
            {
                Assert(m_pUI);

                pszOpDescription = MAKEINTRESOURCE(IDS_SP_E_CANT_MOVETO_SENTITEMS);
                fInsertError = TRUE;
            }
            break; // case SOT_COPYMOVE_MESSAGE

        case SOT_GET_HTTP_MINPOLLINGINTERVAL:
            if (SUCCEEDED(hrComplete) && pOpInfo)
            {
                ULARGE_INTEGER  uhMinPollingInterval64 = {0};
                
                //Convert it to seconds.
                uhMinPollingInterval64.QuadPart = pOpInfo->dwMinPollingInterval * 60;

                //FILETIME is intervals of 100 nano seconds. Need to convert to 100 nanoseconds
                uhMinPollingInterval64.QuadPart *= HUNDRED_NANOSECONDS;

                m_pAccount->SetProp(AP_HTTPMAIL_MINPOLLINGINTERVAL, (LPBYTE)&uhMinPollingInterval64, sizeof(uhMinPollingInterval64));

                m_pAccount->SetPropDw(AP_HTTPMAIL_GOTPOLLINGINTERVAL, TRUE);

                break;
            }

        default:
            if (IXP_E_HTTP_NOT_MODIFIED == hrComplete)
            {
                hrComplete   = S_OK;
                fInsertError = FALSE;
            }
            else
            {
                if (FAILED(hrComplete))
                {
                    Assert(m_pUI);

                    pszOpDescription = MAKEINTRESOURCE(idsGenericError);
                    fInsertError = TRUE;

                    m_cFailed++;
                }
            }
            break; // default case

    } // switch

    if (fInsertError && NULL != pErrorInfo) 
    {
        Assert(pErrorInfo->hrResult == hrComplete); // These two should not be different
        TaskUtil_InsertTransportError(ISFLAGCLEAR(m_dwFlags, DELIVER_NOUI), m_pUI, m_eidCur,
            pErrorInfo, pszOpDescription, pszSubject);
    }

    // Move on to next state
    if (IXP_E_USER_CANCEL == hrComplete)
    {
        // User cancelled logon prompt, so just abort everything
        Cancel();
    }
    else if (NTS_MAX != ntsNextState)
    {
        m_state = ntsNextState;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    }

    // Release your cancel object
    SafeRelease(m_pCancel);
    m_tyOperation = SOT_INVALID;

    // Done
    return(S_OK);
}

STDMETHODIMP CNewsTask::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    HWND hwnd;

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Raid 55082 - SPOOLER: SPA/SSL auth to NNTP does not display cert warning and fails.
#if 0
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);
#endif

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into my swanky utility
    return CallbackOnPrompt(hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}

STDMETHODIMP CNewsTask::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}

STDMETHODIMP CNewsTask::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    HRESULT hr;

    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);

    if (m_pUI)
    {
        hr = m_pUI->GetWindow(phwndParent);
    }
    else
    {
        *phwndParent = NULL;
        hr = E_FAIL;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\ontask.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     ontask.cpp
//
//  PURPOSE:    Implements the offline news task.
//

#include "pch.hxx"
#include "resource.h"
#include "ontask.h"
#include "thormsgs.h"
#include "xputil.h"
#include "mimeutil.h"
#include <stdio.h>
#include "strconst.h"
#include <newsstor.h>
#include "ourguid.h"
#include "taskutil.h"

ASSERTDATA

const static char c_szThis[] = "this";

const PFNONSTATEFUNC COfflineTask::m_rgpfnState[ONTS_MAX] = 
{
    NULL,
    NULL,
    &COfflineTask::Download_Init,
    NULL,
    &COfflineTask::Download_AllMsgs,
    &COfflineTask::Download_NewMsgs,
    &COfflineTask::Download_MarkedMsgs,
    &COfflineTask::Download_Done,
};

const PFNARTICLEFUNC COfflineTask::m_rgpfnArticle[ARTICLE_MAX] = 
{
    &COfflineTask::Article_GetNext,
    NULL,
    &COfflineTask::Article_Done
};

#define GROUP_DOWNLOAD_FLAGS(flag) (((flag) & FOLDER_DOWNLOADHEADERS) || \
				    ((flag) & FOLDER_DOWNLOADNEW) || \
				    ((flag) & FOLDER_DOWNLOADALL))

#define CMSGIDALLOC     512
//
//  FUNCTION:   COfflineTask::COfflineTask()
//
//  PURPOSE:    Initializes the member variables of the object.
//
COfflineTask::COfflineTask()
{
    m_cRef = 1;
    
    m_fInited = FALSE;
    m_dwFlags = 0;
    m_state = ONTS_IDLE;
    m_eidCur = 0;
    m_pInfo = NULL;
    m_szAccount[0] = 0;
    m_cEvents = 0;
    m_fDownloadErrors = FALSE;
    m_fFailed = FALSE;
    m_fNewHeaders = FALSE;
    m_fCancel = FALSE;
    
    m_pBindCtx = NULL;
    m_pUI = NULL;
    
    m_pFolder = NULL;
    
    m_hwnd = 0;
    
    m_dwLast = 0;
    m_dwPrev = 0;
    m_cDownloaded = 0;
    m_dwPrevHigh = 0;
    m_dwNewInboxMsgs = 0;
    m_pList = NULL;

    m_pCancel = NULL;
    m_hTimeout = NULL;
    m_tyOperation = SOT_INVALID;
}

//
//  FUNCTION:   COfflineTask::~COfflineTask()
//
//  PURPOSE:    Frees any resources allocated during the life of the class.
//
COfflineTask::~COfflineTask()    
{
    DestroyWindow(m_hwnd);
    
    SafeMemFree(m_pInfo);
    SafeMemFree(m_pList);

    SafeRelease(m_pBindCtx);
    SafeRelease(m_pUI);
    
    CallbackCloseTimeout(&m_hTimeout);
    SafeRelease(m_pCancel);

    if (m_pFolder)
    {
	    m_pFolder->Close();
	    SideAssert(0 == m_pFolder->Release());
    }
}


HRESULT COfflineTask::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (NULL == *ppvObj)
	    return (E_INVALIDARG);
    
    *ppvObj = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
	    *ppvObj = (LPVOID)(ISpoolerTask *) this;
    else if (IsEqualIID(riid, IID_ISpoolerTask))
	    *ppvObj = (LPVOID)(ISpoolerTask *) this;
    
    if (NULL == *ppvObj)
	    return (E_NOINTERFACE);
    
    AddRef();
    return (S_OK);
}


ULONG COfflineTask::AddRef(void)
{
    ULONG cRefT;
    
    cRefT = ++m_cRef;
    
    return (cRefT);
}


ULONG COfflineTask::Release(void)
{
    ULONG cRefT;
    
    cRefT = --m_cRef;
    
    if (0 == cRefT)
        delete this;
    
    return (cRefT);
}

static const char c_szOfflineTask[] = "Offline Task";

//
//  FUNCTION:   COfflineTask::Init()
//
//  PURPOSE:    Called by the spooler engine to tell us what type of task to 
//              execute and to provide us with a pointer to our bind context.
//
//  PARAMETERS:
//      <in> dwFlags  - Flags to tell us what types of things to do
//      <in> pBindCtx - Pointer to the bind context interface we are to use
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_ALREADYINITIALIZED
//      S_OK
//      E_OUTOFMEMORY
//
HRESULT COfflineTask::Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx)
{
    // Validate the arguments
    Assert(pBindCtx != NULL);
    
    // Check to see if we've been initialzed already 
    Assert(!m_fInited);
    
    // Copy the flags
    m_dwFlags = dwFlags;
    
    // Copy the bind context pointer
    m_pBindCtx = pBindCtx;
    m_pBindCtx->AddRef();
    
    // Create the window
    WNDCLASSEX wc;
    
    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, c_szOfflineTask, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = TaskWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hCursor          = NULL;
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szOfflineTask;
        wc.hIcon            = NULL;
        wc.hIconSm          = NULL;
        
        RegisterClassEx(&wc);
    }
    
    m_hwnd = CreateWindow(c_szOfflineTask, NULL, WS_POPUP, 10, 10, 10, 10,
        GetDesktopWindow(), NULL, g_hInst, this);
    if (!m_hwnd)
        return(E_OUTOFMEMORY);
    
    m_fInited = TRUE;
    
    return(S_OK);
}


//
//  FUNCTION:   COfflineTask::BuildEvents()
//
//  PURPOSE:    This method is called by the spooler engine telling us to create
//              and event list for the account specified.  
//
//  PARAMETERS:
//      <in> pAccount - Account object to build the event list for
//
//  RETURN VALUE:
//      SP_E_UNINITALIZED
//      E_INVALIDARG
//      S_OK
//
HRESULT COfflineTask::BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder)
{
    HRESULT hr;
    
    // Validate the arguments
    Assert(pAccount != NULL);
    Assert(pSpoolerUI != NULL);
    
    // Check to see if we've been initalized
    Assert(m_fInited);
    
    // Get the account name from the account object
    if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, m_szAccount, ARRAYSIZE(m_szAccount))))
        return(hr);
    
    // Get the account name from the account object
    if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_ID, m_szAccountId, ARRAYSIZE(m_szAccountId))))
        return(hr);
    
    if (FAILED(hr = g_pStore->FindServerId(m_szAccountId, &m_idAccount)))
        return(hr);
    
    // Copy the UI object
    m_pUI = pSpoolerUI;
    m_pUI->AddRef();
    
    hr = InsertGroups(pAccount, idFolder);
    
    return(hr);
}


//
//  FUNCTION:   COfflineTask::InsertGroups()
//
//  PURPOSE:    Scans the specified account for groups that have an update 
//              property or marked messages.
//
//  PARAMETERS:
//      <in> szAccount - Name of the account to check
//      <in> pAccount  - Pointer to the IImnAccount object for szAccount
//
//  RETURN VALUE:
//      S_OK
//      E_OUTOFMEMORY
//
HRESULT COfflineTask::InsertGroups(IImnAccount *pAccount, FOLDERID idFolder)
{
    FOLDERINFO  info = { 0 };
    HRESULT     hr = S_OK;
    DWORD       dwFlags = 0;
    DWORD       ids;
    TCHAR       szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    EVENTID     eid;
    ONEVENTINFO *pei = NULL;
    BOOL        fIMAP = FALSE;
    DWORD       dwServerFlags;
    
    
    // Figure out if this is NNTP or IMAP
    if (SUCCEEDED(pAccount->GetServerTypes(&dwServerFlags)) && (dwServerFlags & (SRV_IMAP | SRV_HTTPMAIL)))
        fIMAP = TRUE;
    
    if (FOLDERID_INVALID != idFolder)
    {
        // Fill Folder
        hr = g_pStore->GetFolderInfo(idFolder, &info);
        if (FAILED(hr))
            return hr;
        
        // Figure out what we're downloading
        ids = 0;
        if (m_dwFlags & DELIVER_OFFLINE_HEADERS)
        {
            dwFlags = FOLDER_DOWNLOADHEADERS;
            if (m_dwFlags & DELIVER_OFFLINE_MARKED)
                ids = idsDLHeadersAndMarked;
            else
                ids = idsDLHeaders;
        }
        else if (m_dwFlags & DELIVER_OFFLINE_NEW)
        {
            dwFlags = FOLDER_DOWNLOADNEW;
            if (m_dwFlags & DELIVER_OFFLINE_MARKED)
                ids = idsDLNewMsgsAndMarked;
            else
                ids = idsDLNewMsgs;
        }
        else if (m_dwFlags & DELIVER_OFFLINE_ALL)
        {
            dwFlags = FOLDER_DOWNLOADALL;
            ids = idsDLAllMsgs;
        }
        else if (m_dwFlags & DELIVER_OFFLINE_MARKED)
        {
            ids = idsDLMarkedMsgs;
        }
        
        // Create the event description
        Assert(ids);                
        AthLoadString(ids, szRes, ARRAYSIZE(szRes));
        wsprintf(szBuf, szRes, info.pszName);
        
        // Allocate a structure to save as our twinkie
        if (!MemAlloc((LPVOID *) &pei, sizeof(ONEVENTINFO)))
        {
            g_pStore->FreeRecord(&info);
            return(E_OUTOFMEMORY);
        }
        lstrcpy(pei->szGroup, info.pszName);
        pei->idGroup = info.idFolder;
        pei->dwFlags = dwFlags;
        pei->fMarked = m_dwFlags & DELIVER_OFFLINE_MARKED;
        pei->fIMAP = fIMAP;
        
        // Insert the event into the spooler
        hr = m_pBindCtx->RegisterEvent(szBuf, this, (DWORD_PTR) pei, pAccount, &eid);
        if (SUCCEEDED(hr))
            m_cEvents++;
        
        g_pStore->FreeRecord(&info);
    }
    else
    {
        //Either Sync All or Send & Receive
        
        Assert(m_idAccount != FOLDERID_INVALID);
        
        BOOL        fInclude = FALSE;
        
        if (!(m_dwFlags & DELIVER_OFFLINE_SYNC) && !(m_dwFlags & DELIVER_NOSKIP))
        {
            DWORD   dw;
            if (dwServerFlags & SRV_IMAP)
            {
                if (SUCCEEDED(pAccount->GetPropDw(AP_IMAP_POLL, &dw)) && dw)
                {
                    fInclude = TRUE;
                }   
            }
            else
            {
                if (dwServerFlags & SRV_HTTPMAIL)
                {
                    if (SUCCEEDED(pAccount->GetPropDw(AP_HTTPMAIL_POLL, &dw)) && dw)
                    {
                        fInclude = TRUE;
                    }
                }
            }
        }
        else
            fInclude = TRUE;
        
        if (fInclude)
            hr = InsertAllGroups(m_idAccount, pAccount, fIMAP);
    }
    
    return (hr);
}


HRESULT COfflineTask::InsertAllGroups(FOLDERID idParent, IImnAccount *pAccount, BOOL fIMAP)
{
    FOLDERINFO  info = { 0 };
    IEnumerateFolders *pEnum = NULL;
    HRESULT     hr = S_OK;
    DWORD       dwFlags = 0;
    BOOL        fMarked;
    DWORD       ids;
    TCHAR       szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    EVENTID     eid;
    ONEVENTINFO *pei = NULL;
    BOOL        fSubscribedOnly = TRUE;
    
    if (fIMAP)
        fSubscribedOnly = FALSE;
    
    Assert(idParent != FOLDERID_INVALID);
    hr = g_pStore->EnumChildren(idParent, fSubscribedOnly, &pEnum);
    if (FAILED(hr))
        return(hr);
    
    // Walk the list of groups and add them to the queue as necessary
    while (S_OK == pEnum->Next(1, &info, NULL))
    {
        // If the download flags are set for this group, insert it
        dwFlags = info.dwFlags;
        
        HasMarkedMsgs(info.idFolder, &fMarked);
        
        if (GROUP_DOWNLOAD_FLAGS(dwFlags) || fMarked)
        {
            // Figure out what we're downloading
            ids = 0;
            if (dwFlags & FOLDER_DOWNLOADHEADERS)
            {
                if (fMarked)
                    ids = idsDLHeadersAndMarked;
                else
                    ids = idsDLHeaders;
            }
            else if (dwFlags & FOLDER_DOWNLOADNEW)
            {
                if (fMarked)
                    ids = idsDLNewMsgsAndMarked;
                else
                    ids = idsDLNewMsgs;
            }
            else if (dwFlags & FOLDER_DOWNLOADALL)
            {
                ids = idsDLAllMsgs;
            }
            else if (fMarked)
            {
                ids = idsDLMarkedMsgs;
            }
            
            // Create the event description
            Assert(ids);                
            AthLoadString(ids, szRes, ARRAYSIZE(szRes));
            wsprintf(szBuf, szRes, info.pszName);
            
            // Allocate a structure to save as our twinkie
            if (!MemAlloc((LPVOID *) &pei, sizeof(ONEVENTINFO)))
            {
                g_pStore->FreeRecord(&info);
                
                hr = E_OUTOFMEMORY;
                break;
            }
            lstrcpy(pei->szGroup, info.pszName);
            pei->idGroup = info.idFolder;
            pei->dwFlags = dwFlags;
            pei->fMarked = fMarked;
            pei->fIMAP = fIMAP;
            
            // Insert the event into the spooler
            hr = m_pBindCtx->RegisterEvent(szBuf, this, (DWORD_PTR) pei, pAccount, &eid);
            if (FAILED(hr))
            {
                g_pStore->FreeRecord(&info);
                break;
            }
            
            m_cEvents++;
        }
        
        // Recurse on any children
        if (info.dwFlags & FOLDER_HASCHILDREN)
        {
            hr = InsertAllGroups(info.idFolder, pAccount, fIMAP);
            if (FAILED(hr))
                break;
        }
        
        g_pStore->FreeRecord(&info);
    }
    
    pEnum->Release();
    return hr;
}
    
    
//
//  FUNCTION:   COfflineTask::Execute()
//
//  PURPOSE:    This signals our task to start executing an event.
//
//  PARAMETERS:
//      <in> pSpoolerUI - Pointer of the UI object we'll display progress through
//      <in> eid        - ID of the event to execute
//      <in> dwTwinkie  - Our extra information we associated with the event
//
//  RETURN VALUE:
//      SP_E_EXECUTING
//      S_OK
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//
HRESULT COfflineTask::Execute(EVENTID eid, DWORD_PTR dwTwinkie)
{
    // Make sure we're already idle
    Assert(m_state == ONTS_IDLE)
        
        // Make sure we're initialized
        Assert(m_fInited);
    Assert(m_pInfo == NULL);
    
    // Copy the event id and event info
    m_eidCur = eid;
    m_pInfo = (ONEVENTINFO *) dwTwinkie;
    
    // Forget UI stuff if we're just going to cancel everything
    if (FALSE == m_fCancel)
    {
        // Update the event UI to an executing state
        Assert(m_pUI);
        m_pUI->UpdateEventState(m_eidCur, -1, NULL, MAKEINTRESOURCE(idsStateExecuting));
        m_pUI->SetProgressRange(1);
        
        // Set up the progress
        SetGeneralProgress((LPSTR)idsInetMailConnectingHost, m_szAccount);
        if (m_pInfo->fIMAP)
            m_pUI->SetAnimation(idanInbox, TRUE);
        else
            m_pUI->SetAnimation(idanDownloadNews, TRUE);
    }
    
    m_state = ONTS_INIT;
    
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    
    return(S_OK);
}

HRESULT COfflineTask::CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie)
{
    // Make sure we're initialized
    Assert(m_fInited);
    
    Assert(dwTwinkie != 0);
    MemFree((ONEVENTINFO *)dwTwinkie);
    
    return(S_OK);
}

//
//  FUNCTION:   <???>
//
//  PURPOSE:    <???>
//
//  PARAMETERS:
//      <???>
//
//  RETURN VALUE:
//      <???>
//
//  COMMENTS:
//      <???>
//
HRESULT COfflineTask::ShowProperties(HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   <???>
//
//  PURPOSE:    <???>
//
//  PARAMETERS:
//      <???>
//
//  RETURN VALUE:
//      <???>
//
//  COMMENTS:
//      <???>
//
HRESULT COfflineTask::GetExtendedDetails(EVENTID eid, DWORD_PTR dwTwinkie, 
    LPSTR *ppszDetails)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   <???>
//
//  PURPOSE:    <???>
//
//  PARAMETERS:
//      <???>
//
//  RETURN VALUE:
//      <???>
//
//  COMMENTS:
//      <???>
//
HRESULT COfflineTask::Cancel(void)
{
    Assert(m_state != ONTS_IDLE);
    
    m_fCancel = TRUE;
    
    m_state = ONTS_END;
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    
    return (S_OK);
}


//
//  FUNCTION:   COfflineTask::TaskWndProc()
//
//  PURPOSE:    Hidden window that processes messages for this task.
//
LRESULT CALLBACK COfflineTask::TaskWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    COfflineTask *pThis = (COfflineTask *) GetProp(hwnd, c_szThis);
    
    switch (uMsg)
    {
        case WM_CREATE:
        {
            LPCREATESTRUCT pcs = (LPCREATESTRUCT) lParam;
            pThis = (COfflineTask *) pcs->lpCreateParams;
            SetProp(hwnd, c_szThis, (LPVOID) pThis);
            return (0);
        }
        
        case NTM_NEXTSTATE:
            if (pThis)
            {
                pThis->AddRef();
                pThis->NextState();
                pThis->Release();
            }
            return (0);
        
        case NTM_NEXTARTICLESTATE:
            if (pThis)
            {
                pThis->AddRef();
                if (m_rgpfnArticle[pThis->m_as])
                    (pThis->*(m_rgpfnArticle[pThis->m_as]))();
                pThis->Release();
            }
            return (0);
        
        case WM_DESTROY:
            RemoveProp(hwnd, c_szThis);
            break;
    }
    
    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
}


//
//  FUNCTION:   COfflineTask::NextState()
//
//  PURPOSE:    Executes the function for the current state
//
void COfflineTask::NextState(void)
{
    if (m_fCancel)
        m_state = ONTS_END;
    
    if (NULL != m_rgpfnState[m_state])
        (this->*(m_rgpfnState[m_state]))();
}

//
//  FUNCTION:   COfflineTask::Download_Init()
//
//  PURPOSE:    Does the initialization needed to download headers and messages
//              for a particular newsgroup.
//
HRESULT COfflineTask::Download_Init(void)
{
    HRESULT hr;
    SYNCFOLDERFLAGS flags = SYNC_FOLDER_DEFAULT;
    FOLDERINFO info;
    
    Assert(m_pFolder == NULL);
    Assert(0 == flags); // If this isn't 0, please verify correctness
    
    hr = g_pStore->OpenFolder(m_pInfo->idGroup, NULL, NOFLAGS, &m_pFolder);
    if (FAILED(hr))
    {
        goto Failure;
    }
    
    Assert(m_pFolder != NULL);
    
    hr = g_pStore->GetFolderInfo(m_pInfo->idGroup, &info);
    if (FAILED(hr))
    {
        goto Failure;
    }
    
    if (m_pInfo->fIMAP)
    {
        // Get highest Msg ID the brute-force way (IMAP doesn't set dwClientHigh)
        GetHighestCachedMsgID(m_pFolder, &m_dwPrevHigh);
    }
    else
        m_dwPrevHigh = info.dwClientHigh;
    
    g_pStore->FreeRecord(&info);
    
    // Update the UI to an executing state
    Assert(m_pUI);
    m_pUI->UpdateEventState(m_eidCur, -1, NULL, MAKEINTRESOURCE(idsStateExecuting));
    m_fDownloadErrors = FALSE;
    
    // Check to see if the user wants us to download new headers
    if (GROUP_DOWNLOAD_FLAGS(m_pInfo->dwFlags))
    {
        if (!(m_pInfo->dwFlags & FOLDER_DOWNLOADALL) || m_pInfo->fIMAP)
            flags = SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS;
        else
            flags = SYNC_FOLDER_ALLFLAGS;

        // Update Progress
        SetGeneralProgress((LPSTR)idsLogCheckingNewMessages, m_pInfo->szGroup);
    }
    else
    {
        m_state = ONTS_ALLMSGS;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        
        return(S_OK);
    }
    
    // Before we download any headers, we need to make a note of what the current
    // server high is so we know which articles are new.
    
    hr = m_pFolder->Synchronize(flags, 0, (IStoreCallback *)this);
    Assert(hr != S_OK);
    
    if (hr == E_PENDING)
        hr = S_OK;
    
    if (m_pInfo->fIMAP)
    {
        m_pUI->SetAnimation(idanInbox, TRUE);    
        m_pBindCtx->Notify(DELIVERY_NOTIFY_RECEIVING, 0);
    }
    else
    {
        m_pUI->SetAnimation(idanDownloadNews, TRUE);    
        m_pBindCtx->Notify(DELIVERY_NOTIFY_RECEIVING_NEWS, 0);
    }
    
Failure:
    if (FAILED(hr))
    {
        // $$$$BUGBUG$$$$
        InsertError((LPSTR)idsLogErrorSwitchGroup, m_pInfo->szGroup, m_szAccount);
        m_fFailed = TRUE;
        
        m_state = ONTS_END;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    }
    
    return (hr);
}

//
//  FUNCTION:   COfflineTask::Download_AllMsgs()
//
//  PURPOSE:    
//              
//
HRESULT COfflineTask::Download_AllMsgs(void)
{
    HRESULT hr;
    DWORD cMsgs, cMsgsBuf;
    LPMESSAGEID pMsgId;
    MESSAGEIDLIST list;
    MESSAGEINFO MsgInfo = {0};
    HROWSET hRowset = NULL;
    
    // Check to see if we even want to download all messages
    if (!(m_pInfo->dwFlags & FOLDER_DOWNLOADALL))
    {
        m_state = ONTS_NEWMSGS;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        return(S_OK);
    }
    
    // We need to determine a list of messages to download.  What we're looking
    // to do is download all of the messages that we know about which are unread.
    // To do this, we need to find the intersection of the unread range list and
    // the known range list.
    
    // Create a Rowset
    hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, 0, &hRowset);
    if (FAILED(hr))
    {
        goto Failure;
    }
    
    cMsgs = 0;
    cMsgsBuf = 0;
    pMsgId = NULL;
    
    // Get the first message
    while (S_OK == m_pFolder->QueryRowset(hRowset, 1, (void **)&MsgInfo, NULL))
    {
        if (0 == (MsgInfo.dwFlags & ARF_HASBODY) && 0 == (MsgInfo.dwFlags & ARF_IGNORE))
        {
            if (cMsgs == cMsgsBuf)
            {
                if (!MemRealloc((void **)&pMsgId, (cMsgsBuf + CMSGIDALLOC) * sizeof(MESSAGEID)))
                {
                    m_pFolder->FreeRecord(&MsgInfo);
                    
                    hr = E_OUTOFMEMORY;
                    break;
                }
                
                cMsgsBuf += CMSGIDALLOC;
            }
            
            pMsgId[cMsgs] = MsgInfo.idMessage;
            cMsgs++;
        }
        
        // Free the header info
        m_pFolder->FreeRecord(&MsgInfo);
    }
    
    // Release Lock
    m_pFolder->CloseRowset(&hRowset);
    
    // TODO: error handling
    Assert(!FAILED(hr));
    
    // Check to see if we found anything 
    if (cMsgs == 0)
    {
        // Nothing to download.  We should move on to the marked download 
        // state.
        Assert(pMsgId == NULL);
        
        m_state = ONTS_MARKEDMSGS;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        return(S_OK);
    }
    
    // Update the general progress
    SetGeneralProgress((LPSTR)idsLogStartDownloadAll, m_pInfo->szGroup);
    
    list.cAllocated = 0;
    list.cMsgs = cMsgs;
    list.prgidMsg = pMsgId;
    
    // Ask for the first article
    hr = Article_Init(&list);
    
    if (pMsgId != NULL)
        MemFree(pMsgId);
    
Failure:
    if (FAILED(hr))
    {
        // $$$$BUGBUG$$$$
        InsertError((LPSTR)idsLogErrorSwitchGroup, m_pInfo->szGroup, m_szAccount);
        m_fFailed = TRUE;
        
        m_state = ONTS_END;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    }
    
    return (hr);
}

//
//  FUNCTION:   COfflineTask::Download_NewMsgs()
//
//  PURPOSE:    This function determines if there are any new messages to be
//              downloaded.  If so, it creates a list of message numbers that
//              need to be downloaded.
//
HRESULT COfflineTask::Download_NewMsgs(void)
{
    HRESULT         hr;
    ROWORDINAL      iRow = 0;
    BOOL            fFound;
    HROWSET         hRowset;
    DWORD           cMsgs, cMsgsBuf;
    LPMESSAGEID     pMsgId;
    MESSAGEIDLIST   list;
    MESSAGEINFO     Message = {0};
    
    // Check to see if there are even new messages to download
    // Check to see if we even want to download all messages
    if (!(m_pInfo->dwFlags & FOLDER_DOWNLOADNEW) || !m_fNewHeaders)
    {
        // Move the next state
        m_state = ONTS_MARKEDMSGS;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        return(S_OK);
    }
    
    // We've got new messages, build a range list of those message numbers.
    // This range list is essentially every number in the known range above
    // m_dwPrevHigh.
    
    hr = S_OK;
    
    cMsgs = 0;
    cMsgsBuf = 0;
    pMsgId = NULL;
    fFound = FALSE;
    
    // TODO: this method of figuring out if there are new msgs isn't going to work all
    // the time. if the previous high is removed from the store during syncing (cancelled
    // news post, deleted msg, expired news post, etc) and new headers are downloaded,
    // we won't pull down the new msgs. we need a better way of detecting new hdrs and
    // pulling down there bodies
    
    if (m_dwPrevHigh > 0)
    {
        Message.idMessage = (MESSAGEID)m_dwPrevHigh;
        
        // Find This Record.  If this fails, we go ahead and do a full scan which is less
        // efficient, but OK.
        if (DB_S_FOUND == m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, &iRow))
        {
            m_pFolder->FreeRecord(&Message);
        }
    }
    
    hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, 0, &hRowset);
    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(m_pFolder->SeekRowset(hRowset, SEEK_ROWSET_BEGIN, iRow, NULL)))
        {
            // Get the first message
            while (S_OK == m_pFolder->QueryRowset(hRowset, 1, (void **)&Message, NULL))
            {
                if (cMsgs == cMsgsBuf)
                {
                    if (!MemRealloc((void **)&pMsgId, (cMsgsBuf + CMSGIDALLOC) * sizeof(MESSAGEID)))
                    {
                        m_pFolder->FreeRecord(&Message);
                        
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    
                    cMsgsBuf += CMSGIDALLOC;
                }
                
                // It's possible to have already downloaded the body if the message was
                // watched.  It's also possible for the message to be part of an ignored
                // thread.
                if (0 == (Message.dwFlags & ARF_HASBODY) && 0 == (Message.dwFlags & ARF_IGNORE) && (Message.idMessage >= (MESSAGEID) m_dwPrevHigh))
                {
                    pMsgId[cMsgs] = Message.idMessage;
                    cMsgs++;
                }
                
                // Free the header info
                m_pFolder->FreeRecord(&Message);
            }
            
        }
        
        // Release Lock
        m_pFolder->CloseRowset(&hRowset);
    }
    
    // TODO: error handling
    Assert(!FAILED(hr));
    
    // Check to see if there was anything added
    if (cMsgs == 0)
    {
        // Nothing to download.  We should move on to the marked download 
        // state.
        
        m_state = ONTS_MARKEDMSGS;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        return(S_OK);
    }
    
    // Update the general progress
    SetGeneralProgress((LPSTR)idsLogStartDownloadAll, m_pInfo->szGroup);
    
    list.cAllocated = 0;
    list.cMsgs = cMsgs;
    list.prgidMsg = pMsgId;
    
    // Ask for the first article
    hr = Article_Init(&list);
    
    if (pMsgId != NULL)
        MemFree(pMsgId);
    
    return(hr);
}


//
//  FUNCTION:   COfflineTask::Download_MarkedMsgs()
//
//  PURPOSE:    
//              
//
HRESULT COfflineTask::Download_MarkedMsgs(void)
{
    HRESULT hr;
    HROWSET hRowset;
    DWORD cMsgs, cMsgsBuf;
    LPMESSAGEID pMsgId;
    MESSAGEIDLIST list;
    MESSAGEINFO MsgInfo;
    
    // Check to see if we even want to download marked messages
    if (!m_pInfo->fMarked)
    {
        // Move on to the next state
        m_state = ONTS_END;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        return(S_OK);
    }
    
    // We need to determine a list of messages to download.  What we're looking
    // to do is download all of the messages that are marked which are unread.
    // To do this, we need to find the intersection of the unread range list and
    // the marked range list.
    
    // Create a Rowset
    hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, 0, &hRowset);
    if (FAILED(hr))
    {
        goto Failure;
    }
    
    cMsgs = 0;
    cMsgsBuf = 0;
    pMsgId = NULL;
    
    // Get the first message
    while (S_OK == m_pFolder->QueryRowset(hRowset, 1, (void **)&MsgInfo, NULL))
    {
        if (((MsgInfo.dwFlags & ARF_DOWNLOAD) || (MsgInfo.dwFlags & ARF_WATCH)) && 0 == (MsgInfo.dwFlags & ARF_HASBODY))
        {
            if (cMsgs == cMsgsBuf)
            {
                if (!MemRealloc((void **)&pMsgId, (cMsgsBuf + CMSGIDALLOC) * sizeof(MESSAGEID)))
                {
                    m_pFolder->FreeRecord(&MsgInfo);
                    
                    hr = E_OUTOFMEMORY;
                    break;
                }
                
                cMsgsBuf += CMSGIDALLOC;
            }
            
            pMsgId[cMsgs] = MsgInfo.idMessage;
            cMsgs++;
        }
        
        // Free the header info
        m_pFolder->FreeRecord(&MsgInfo);
    }
    
    // Release Lock
    m_pFolder->CloseRowset(&hRowset);
    
    // TODO: error handling
    Assert(!FAILED(hr));
    
    // Check to see if we found anything 
    if (cMsgs == 0)
    {
        // Nothing to download.  We should move on to next state.
        
        m_state = ONTS_END;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
        return(S_OK);
    }
    
    // Update the general progress
    SetGeneralProgress((LPSTR)idsLogStartDownloadAll, m_pInfo->szGroup);
    
    list.cAllocated = 0;
    list.cMsgs = cMsgs;
    list.prgidMsg = pMsgId;
    
    // Ask for the first article
    hr = Article_Init(&list);
    
    if (pMsgId != NULL)
        MemFree(pMsgId);
    
Failure:
    if (FAILED(hr))
    {
        // $$$$BUGBUG$$$$
        InsertError((LPSTR)idsLogErrorSwitchGroup, m_pInfo->szGroup, m_szAccount);
        m_fFailed = TRUE;
        
        m_state = ONTS_END;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    }
    
    return (hr);
}


//
//  FUNCTION:   COfflineTask::Download_Done()
//
//  PURPOSE:    
//              
//
HRESULT COfflineTask::Download_Done(void)
{
    // Make sure we don't get freed before we can clean up
    AddRef();
    
    // Tell the spooler we're done
    Assert(m_pBindCtx);
    m_pBindCtx->Notify(DELIVERY_NOTIFY_COMPLETE, m_dwNewInboxMsgs);
    
    if (m_fCancel)
        m_pBindCtx->EventDone(m_eidCur, EVENT_CANCELED);
    else if (m_fFailed)
        m_pBindCtx->EventDone(m_eidCur, EVENT_FAILED);
    else if (m_fDownloadErrors)
        m_pBindCtx->EventDone(m_eidCur, EVENT_WARNINGS);
    else
        m_pBindCtx->EventDone(m_eidCur, EVENT_SUCCEEDED);
    
    m_cEvents--;
    
    if (m_pFolder != NULL)
    {
        m_pFolder->Close();
        m_pFolder->Release();
        m_pFolder = NULL;
    }
    
    m_state = ONTS_IDLE;
    
    SafeMemFree(m_pInfo);
    
    Release();
    return (S_OK);
}


//
//  FUNCTION:   COfflineTask::InsertError()
//
//  PURPOSE:    This function is a wrapper for the ISpoolerUI::InsertError()
//              that takes the responsibility of loading the string resource
//              and constructing the error message.
//
void COfflineTask::InsertError(const TCHAR *pFmt, ...)
{
    int         i;
    va_list     pArgs;
    LPCTSTR     pszT; 
    TCHAR       szFmt[CCHMAX_STRINGRES];
    DWORD       cbWritten;
    TCHAR       szBuf[2 * CCHMAX_STRINGRES];
    
    // If we were passed a string resource ID, then we need to load it
    if (IS_INTRESOURCE(pFmt))
    {
        AthLoadString(PtrToUlong(pFmt), szFmt, ARRAYSIZE(szFmt));
        pszT = szFmt;
    }
    else
        pszT = pFmt;
    
    // Format the string
    va_start(pArgs, pFmt);
    i = wvsprintf(szBuf, pszT, pArgs);
    va_end(pArgs);
    
    // Send the string to the UI
    m_pUI->InsertError(m_eidCur, szBuf);
}


//
//  FUNCTION:   COfflineTask::SetSpecificProgress()
//
//  PURPOSE:    This function is a wrapper for the ISpoolerUI::SetSpecificProgress()
//              that takes the responsibility of loading the string resource
//              and constructing the error message.
//
void COfflineTask::SetSpecificProgress(const TCHAR *pFmt, ...)
{
    int         i;
    va_list     pArgs;
    LPCTSTR     pszT; 
    TCHAR       szFmt[CCHMAX_STRINGRES];
    DWORD       cbWritten;
    TCHAR       szBuf[2 * CCHMAX_STRINGRES];
    
    // If we were passed a string resource ID, then we need to load it
    if (IS_INTRESOURCE(pFmt))
    {
        AthLoadString(PtrToUlong(pFmt), szFmt, ARRAYSIZE(szFmt));
        pszT = szFmt;
    }
    else
        pszT = pFmt;
    
    // Format the string
    va_start(pArgs, pFmt);
    i = wvsprintf(szBuf, pszT, pArgs);
    va_end(pArgs);
    
    // Send the string to the UI
    m_pUI->SetSpecificProgress(szBuf);
}


//
//  FUNCTION:   COfflineTask::SetGeneralProgress()
//
//  PURPOSE:    This function is a wrapper for the ISpoolerUI::SetGeneralProgress()
//              that takes the responsibility of loading the string resource
//              and constructing the error message.
//
void COfflineTask::SetGeneralProgress(const TCHAR *pFmt, ...)
{
    int         i;
    va_list     pArgs;
    LPCTSTR     pszT; 
    TCHAR       szFmt[CCHMAX_STRINGRES];
    DWORD       cbWritten;
    TCHAR       szBuf[2 * CCHMAX_STRINGRES];
    
    // If we were passed a string resource ID, then we need to load it
    if (IS_INTRESOURCE(pFmt))
    {
        AthLoadString(PtrToUlong(pFmt), szFmt, ARRAYSIZE(szFmt));
        pszT = szFmt;
    }
    else
        pszT = pFmt;
    
    // Format the string
    va_start(pArgs, pFmt);
    i = wvsprintf(szBuf, pszT, pArgs);
    va_end(pArgs);
    
    // Send the string to the UI
    m_pUI->SetGeneralProgress(szBuf);
}


//
//  FUNCTION:   COfflineTask::Article_Init()
//
//  PURPOSE:    Initializes the article download substate machine.
//
//  PARAMETERS:
//      <in> pRange - Range list of articles to download.
//
HRESULT COfflineTask::Article_Init(MESSAGEIDLIST *pList)
{
    HRESULT hr;
    
    Assert(pList != NULL);
    Assert(pList->cMsgs > 0);
    Assert(m_pList == NULL);
    
    hr = CloneMessageIDList(pList, &m_pList);
    if (FAILED(hr))
        return(hr);
    
    // Determine the first and the size
    m_cDownloaded = 0;
    m_cCur = 0;
    m_dwNewInboxMsgs = 0;
    
    // Set up the UI
    SetSpecificProgress((LPSTR)idsIMAPDnldProgressFmt, 0, m_pList->cMsgs);
    m_pUI->SetProgressRange((WORD)m_pList->cMsgs);        
    
    // Request the first one
    m_as = ARTICLE_GETNEXT;
    PostMessage(m_hwnd, NTM_NEXTARTICLESTATE, 0, 0);
    
    return(S_OK);
}


//
//  FUNCTION:   COfflineTask::Article_GetNext()
//
//  PURPOSE:    Determines the next article in the range of articles to
//              download and requests that article from the server.
//
HRESULT COfflineTask::Article_GetNext(void)
{
    HRESULT hr;
    LPMIMEMESSAGE pMsg = NULL;
    
    if (NULL == m_pFolder)
        return(S_OK);
    
    // Find out the next article number
    if (m_cCur == m_pList->cMsgs)
    {
        // We're done.  Exit.
        m_as = ARTICLE_END;
        PostMessage(m_hwnd, NTM_NEXTARTICLESTATE, 0, 0);
        return(S_OK);
    }
    
    m_cDownloaded++;
    // (YST) Bug 97397 We should send notification message from here too, because this is 
    // only one availble place for HTTP (fIMAP is set for HTTP).
    if(m_pInfo->fIMAP)
        OnProgress(SOT_NEW_MAIL_NOTIFICATION, 1, 0, NULL);
    
    // Update the progress UI
    SetSpecificProgress((LPSTR)idsIMAPDnldProgressFmt, m_cDownloaded, m_pList->cMsgs);
    m_pUI->IncrementProgress(1);
    
    // Ask for the article
    hr = m_pFolder->OpenMessage(m_pList->prgidMsg[m_cCur], 0, &pMsg, (IStoreCallback *)this);
    
    if (pMsg != NULL)
        pMsg->Release();
    m_cCur++;
    
    if (hr == E_PENDING)
    {
        m_as = ARTICLE_ONRESP;
    }
    else
    {
        // Whatever happened, we should move on to the next article.
        m_as = ARTICLE_GETNEXT;
        PostMessage(m_hwnd, NTM_NEXTARTICLESTATE, 0, 0);
    }
    
    return(S_OK);
}

//
//  FUNCTION:   COfflineTask::Article_Done()
//
//  PURPOSE:    When we've downloaded the last article, this function cleans
//              up and moves us to the next state.
//
HRESULT COfflineTask::Article_Done(void)
{
    // Free the range list we were working off of
    MemFree(m_pList);
    m_pList = NULL;
    
    // Move to the next state.  The next state is either get marked or done.
    if (m_state == ONTS_MARKEDMSGS)
        m_state = ONTS_END;
    else
        m_state = ONTS_MARKEDMSGS;
    
    PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    
    return(S_OK);
}

STDMETHODIMP COfflineTask::IsDialogMessage(LPMSG pMsg)
{
    return S_FALSE;
}

STDMETHODIMP COfflineTask::OnFlagsChanged(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
    
    return (S_OK);
}

STDMETHODIMP COfflineTask::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    // Hold onto this
    Assert(m_tyOperation == SOT_INVALID);
    
    if (pCancel)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }
    m_tyOperation = tyOperation;
    
    m_dwPrev = 0;
    m_dwLast = 0;
    
    // Party On
    return(S_OK);
}

STDMETHODIMP COfflineTask::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);
    
    // NOTE: that you can get more than one type of value for tyOperation.
    //       Most likely, you will get SOT_CONNECTION_STATUS and then the
    //       operation that you might expect. See HotStore.idl and look for
    //       the STOREOPERATION enumeration type for more info.
    
    switch (tyOperation)
    {
        case SOT_CONNECTION_STATUS:
            break;
        
        case SOT_NEW_MAIL_NOTIFICATION:
            m_dwNewInboxMsgs += dwCurrent;
            break;
        
        default:
            if (m_state == ONTS_INIT)
            {
                // Update UI
                if (dwMax > m_dwLast)
                {
                    m_dwLast = dwMax;
                    m_pUI->SetProgressRange((WORD)m_dwLast);
                }
            
                SetSpecificProgress((LPSTR)idsDownloadingHeaders, dwCurrent, m_dwLast);
                m_pUI->IncrementProgress((WORD) (dwCurrent - m_dwPrev));
                m_dwPrev = dwCurrent;            
            }
    } // switch
    
    // Done
    return(S_OK);
}

STDMETHODIMP COfflineTask::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);
    
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

STDMETHODIMP COfflineTask::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND hwnd;
    BOOL fPrompt = TRUE;
    
    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;
    
    // Call into general CanConnect Utility
    if ((m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)) || (dwFlags & CC_FLAG_DONTPROMPT))
        fPrompt = FALSE;
    
    return CallbackCanConnect(pszAccountId, hwnd, fPrompt);
}

STDMETHODIMP COfflineTask::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    HWND hwnd;
    
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);
    
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)) &&
        !(ISFLAGSET(pServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) &&
        '\0' == pServer->szPassword[0]))
        return(S_FALSE);
    
    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;
    
    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(hwnd, pServer, ixpServerType);
}

STDMETHODIMP COfflineTask::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete,
                                      LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    HRESULT hr;
    DWORD dw;
    BOOL fUserCancel = FALSE;
    
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);
    
    Assert(m_tyOperation != SOT_INVALID);
    if (m_tyOperation != tyOperation)
        return(S_OK);
    
    switch (hrComplete)
    {
        case STORE_E_EXPIRED:
        case IXP_E_HTTP_NOT_MODIFIED:
            // Completely ignore errors due to expired/deleted messages
            hrComplete = S_OK;
            break;
        
        case STORE_E_OPERATION_CANCELED:
        case HR_E_USER_CANCEL_CONNECT:
        case IXP_E_USER_CANCEL:
            fUserCancel = TRUE;
            break;
    }
    
    if (FAILED(hrComplete))
    {
        LPSTR       pszOpDescription = NULL;
        LPSTR       pszSubject = NULL;
        MESSAGEINFO Message;
        BOOL        fFreeMsgInfo = FALSE;
        char        szBuf[CCHMAX_STRINGRES], szFmt[CCHMAX_STRINGRES];
        
        switch (tyOperation)
        {
            case SOT_GET_MESSAGE:
                // we've already incremented m_cCur by the time we get this
                Assert((m_cCur - 1) < m_pList->cMsgs);
                Message.idMessage = m_pList->prgidMsg[m_cCur - 1];
            
                pszOpDescription = MAKEINTRESOURCE(idsNewsTaskArticleError);
                if (DB_S_FOUND == m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL))
                {
                    fFreeMsgInfo = TRUE;
                    pszSubject = Message.pszSubject;
                }
            
                break; // case SOT_GET_MESSAGE
            
            case SOT_SYNC_FOLDER:
                LoadString(g_hLocRes, idsHeaderDownloadFailureFmt, szFmt, sizeof(szFmt));
                wsprintf(szBuf, szFmt, (NULL == m_pInfo) ? c_szEmpty : m_pInfo->szGroup);
                pszOpDescription = szBuf;
                break;
            
            default:
                LoadString(g_hLocRes, idsMessageSyncFailureFmt, szFmt, sizeof(szFmt));
                wsprintf(szBuf, szFmt, (NULL == m_pInfo) ? c_szEmpty : m_pInfo->szGroup);
                pszOpDescription = szBuf;
                break; // default case
        } // switch
        
        m_fDownloadErrors = TRUE;
        if (NULL != pErrorInfo)
        {
            Assert(pErrorInfo->hrResult == hrComplete); // These two should not be different
            TaskUtil_InsertTransportError(ISFLAGCLEAR(m_dwFlags, DELIVER_NOUI), m_pUI, m_eidCur,
                pErrorInfo, pszOpDescription, pszSubject);
        }
        
        if (fFreeMsgInfo)
            m_pFolder->FreeRecord(&Message);
    }
    
    if (fUserCancel)
    {
        // User has cancelled the OnLogonPrompt dialog, so abort EVERYTHING
        Cancel();
    }
    else if (m_state == ONTS_INIT)
    {
        SetSpecificProgress((LPSTR)idsDownloadingHeaders, m_dwLast, m_dwLast);
        m_pUI->IncrementProgress((WORD) (m_dwLast - m_dwPrev));
        
        // Set a flag if we actually downloaded new headers
        m_fNewHeaders = (m_dwLast > 0);
        
        // Move to the next state
        m_state = ONTS_ALLMSGS;
        PostMessage(m_hwnd, NTM_NEXTSTATE, 0, 0);
    }
    else
    {
        m_as = ARTICLE_GETNEXT;
        PostMessage(m_hwnd, NTM_NEXTARTICLESTATE, 0, 0);
    }
    
    // Release your cancel object
    SafeRelease(m_pCancel);
    m_tyOperation = SOT_INVALID;
    
    // Done
    return(S_OK);
}

STDMETHODIMP COfflineTask::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    HWND hwnd;
    
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);
    
    // Raid 55082 - SPOOLER: SPA/SSL auth to NNTP does not display cert warning and fails.
#if 0
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);
#endif
    
    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;
    
    // Call into my swanky utility
    return CallbackOnPrompt(hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}

STDMETHODIMP COfflineTask::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}

STDMETHODIMP COfflineTask::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);
    
    if (m_pUI)
    {
        return m_pUI->GetWindow(phwndParent);
    }
    else
    {
        *phwndParent = NULL;
        return E_FAIL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\pop3task.h ===
// --------------------------------------------------------------------------------
// Pop3task.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __POP3TASK_H
#define __POP3TASK_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "spoolapi.h"
#include "imnxport.h"
#include "oerules.h"
#include "taskutil.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
interface ILogFile;

// --------------------------------------------------------------------------------
// POP3EVENT_xxx Types
// --------------------------------------------------------------------------------
typedef enum tagPOP3EVENTTYPE {
    POP3EVENT_CHECKMAIL,
    POP3EVENT_DOWNLOADMAIL,
    POP3EVENT_CLEANUP
} POP3EVENTTYPE;

// --------------------------------------------------------------------------------
// POP3STATE_xxxx
// --------------------------------------------------------------------------------
#define POP3STATE_LEAVEONSERVER     FLAG01      // Leave on server
#define POP3STATE_DELETEEXPIRED     FLAG02      // Delete expired messages
#define POP3STATE_SYNCDELETED       FLAG03      // Synchronized deleted items
#define POP3STATE_CLEANUPCACHE      FLAG04      // Cleanup cache when done
#define POP3STATE_GETUIDLS          FLAG05      // Get uidls for all messages
#define POP3STATE_PDR               FLAG06      // Pre-download rules
#define POP3STATE_PDRSIZEONLY       FLAG07      // Pre-download rules by size only
#define POP3STATE_NOPOSTRULES       FLAG08      // No post download rules
#define POP3STATE_CANCELPENDING     FLAG09      // There is a pending cacel
#define POP3STATE_ONDISCONNECT      FLAG10      // OnStatus(IXP_DISCONNECT) was called
#define POP3STATE_LOGONSUCCESS      FLAG11      // Logon was successful
#define POP3STATE_EXECUTEFAILED     FLAG12
#define POP3STATE_BODYRULES         FLAG13

// --------------------------------------------------------------------------------
// POP3ITEM_xxx Flags
// --------------------------------------------------------------------------------
#define POP3ITEM_DELETEOFFSERVER    FLAG01
#define POP3ITEM_DELETED            FLAG02
#define POP3ITEM_DELETECACHEDUIDL   FLAG03
#define POP3ITEM_CACHEUIDL          FLAG04
#define POP3ITEM_DOWNLOAD           FLAG05
#define POP3ITEM_DOWNLOADSUCCESS    FLAG06
#define POP3ITEM_CHECKEDINBOXRULE   FLAG07
#define POP3ITEM_HASINBOXRULE       FLAG08
#define POP3ITEM_DESTINATIONKNOWN   FLAG09
#define POP3ITEM_DOWNLOADED         FLAG10
#define POP3ITEM_DELEBYRULE         FLAG11
#define POP3ITEM_LEFTBYRULE         FLAG12

// --------------------------------------------------------------------------------
// POP3UIDLSUPPORT
// --------------------------------------------------------------------------------
typedef enum tagPOP3UIDLSUPPORT {
    UIDL_SUPPORT_NONE,
    UIDL_SUPPORT_TESTING_UIDL_COMMAND,
    UIDL_SUPPORT_USE_UIDL_COMMAND,
    UIDL_SUPPORT_TESTING_TOP_COMMAND,
    UIDL_SUPPORT_USE_TOP_COMMAND
} POP3UIDLSUPPORT;

// --------------------------------------------------------------------------------
// POP3STATE
// --------------------------------------------------------------------------------
typedef enum tagPOP3STATE {
    POP3STATE_NONE,
    POP3STATE_GETTINGUIDLS,
    POP3STATE_DOWNLOADING,
    POP3STATE_DELETING,
    POP3STATE_UIDLSYNC
} POP3STATE;

// --------------------------------------------------------------------------------
// POP3METRICS
// --------------------------------------------------------------------------------
typedef struct tagPOP3METRICS {
    DWORD               cbTotal;                // Total number of bytes on the server
    DWORD               cDownload;              // Number of messages to download
    DWORD               cbDownload;             // Number of bytes to download
    DWORD               cDelete;                // Number of messages to delete
    DWORD               cLeftByRule;            // Count of messages left on server due to inbox rule
    DWORD               cDeleByRule;            // Count of messages dele on server due to inbox rule
    DWORD               cTopMsgs;               // Server Side Rules
    DWORD               iCurrent;               // Current message number being downloaded
    DWORD               cDownloaded;            // Number of messages downloaded
    DWORD               cInfiniteLoopAutoGens;  // Number of auto-forward/replys rejected because of loop
    DWORD               cPartials;              // Number of Partial Seen for the download
} POP3METRICS, *LPPOP3METRICS;

// --------------------------------------------------------------------------------
// MSGPART
// --------------------------------------------------------------------------------
typedef struct tagMSGPART {
    WORD                iPart;
    MESSAGEID           msgid;
} MSGPART, *LPMSGPART;

// --------------------------------------------------------------------------------
// PARTIALMSG
// --------------------------------------------------------------------------------
typedef struct tagPARTIALMSG {
    TCHAR               szAccount[CCHMAX_ACCOUNT_NAME];
    LPSTR               pszId;
    WORD                cTotalParts;
    ULONG               cAlloc;
    ULONG               cMsgParts;
    LPMSGPART           pMsgParts;
} PARTIALMSG, *LPPARTIALMSG;

// --------------------------------------------------------------------------------
// POP3FOLDERINFO
// --------------------------------------------------------------------------------
typedef struct tagPOP3FOLDERINFO {
    IMessageFolder     *pFolder;                // Current Folder
    IStream            *pStream;                // Stream in which current message is going to must call EndMessageStreamIn...
    FILEADDRESS         faStream;               // Stream we created
    BOOL                fCommitted;             // Has the stream been comitted
} POP3FOLDERINFO, *LPPOP3FOLDERINFO;

// --------------------------------------------------------------------------------
// POP3ITEMINFO
// --------------------------------------------------------------------------------
typedef struct tagPOP3ITEM {
    DWORD               dwFlags;                // POP3ITEM_xxx Flags
    DWORD               cbSize;                 // Size of this item
    DWORD               dwProgressCur;          // Used to maintain perfect progress
    LPSTR               pszUidl;                // UIDL of this item
    ACT_ITEM *          pActList;               // Inbox Rule Actions that should be applied
    ULONG               cActList;
} POP3ITEM, *LPPOP3ITEM;

// --------------------------------------------------------------------------------
// POP3ITEMTABLE
// --------------------------------------------------------------------------------
typedef struct tagPOP3ITEMTABLE {
    DWORD               cItems;                 // Number of events in prgEvent
    DWORD               cAlloc;                 // Number of items allocated in prgEvent
    LPPOP3ITEM          prgItem;                // Array of events
} POP3ITEMTABLE, *LPPOP3ITEMTABLE;

// ------------------------------------------------------------------------------------
// New Mail Sound
// ------------------------------------------------------------------------------------
typedef BOOL (WINAPI * PFNSNDPLAYSOUND)(LPTSTR szSoundName, UINT fuOptions);

// --------------------------------------------------------------------------------
// SMARTLOGINFO
// --------------------------------------------------------------------------------
typedef struct tagSMARTLOGINFO {
    LPSTR               pszAccount;             // Account to log
    LPSTR               pszProperty;            // Property to query
    LPSTR               pszValue;               // Value to query for
    LPSTR               pszLogFile;             // Logfile to write from and CC to...
    IStream            *pStmFile;               // Stream to the file
} SMARTLOGINFO, *LPSMARTLOGINFO;

// --------------------------------------------------------------------------------
// CPop3Task
// --------------------------------------------------------------------------------
class CPop3Task : public ISpoolerTask, 
                  public IPOP3Callback, 
                  public ITimeoutCallback,
                  public ITransportCallbackService
{
public:
    // ----------------------------------------------------------------------------
    // CSmtpTask
    // ----------------------------------------------------------------------------
    CPop3Task(void);
    ~CPop3Task(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // ISpoolerTask
    // ---------------------------------------------------------------------------
    STDMETHODIMP Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx);
    STDMETHODIMP BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder);
    STDMETHODIMP Execute(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP Cancel(void);
    STDMETHODIMP ShowProperties(HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie) {
        return TrapError(E_NOTIMPL); }
    STDMETHODIMP GetExtendedDetails(EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails) {
        return TrapError(E_NOTIMPL); }
    STDMETHODIMP IsDialogMessage(LPMSG pMsg);
    STDMETHODIMP OnFlagsChanged(DWORD dwFlags);

    // --------------------------------------------------------------------------------
    // ITransportCallbackService Members
    // --------------------------------------------------------------------------------
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent) {
        TraceCall("CPop3Task::GetParentWindow");
        if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
            return TraceResult(E_FAIL);
        if (m_pUI)
            return m_pUI->GetWindow(phwndParent);
        return TraceResult(E_FAIL);
    }

    STDMETHODIMP GetAccount(LPDWORD pdwServerType, IImnAccount **ppAccount) {
        Assert(ppAccount && m_pAccount);
        *pdwServerType = SRV_POP3;
        *ppAccount = m_pAccount;
        (*ppAccount)->AddRef();
        return(S_OK);
    }

    // --------------------------------------------------------------------------------
    // ITransportCallback Members
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pInetServer, IInternetTransport *pTransport);
    STDMETHODIMP_(INT) OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport);
    STDMETHODIMP OnStatus(IXPSTATUS ixpstatus, IInternetTransport *pTransport);
    STDMETHODIMP OnError(IXPSTATUS ixpstatus, LPIXPRESULT pResult, IInternetTransport *pTransport);
    STDMETHODIMP OnCommand(CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport);

    // --------------------------------------------------------------------------------
    // IPOP3Callback
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnResponse(LPPOP3RESPONSE pResponse);

    // --------------------------------------------------------------------------------
    // ITimeoutCallback
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

private:
    // ---------------------------------------------------------------------------
    // Private Methods
    // ---------------------------------------------------------------------------
    TASKRESULTTYPE _CatchResult(HRESULT hr);
    TASKRESULTTYPE _CatchResult(POP3COMMAND command, LPIXPRESULT pResult);
    HRESULT _HrLockUidlCache(void);
    HRESULT _HrOnStatResponse(LPPOP3RESPONSE pResponse);
    HRESULT _HrOnListResponse(LPPOP3RESPONSE pResponse);
    HRESULT _HrOnUidlResponse(LPPOP3RESPONSE pResponse);
    HRESULT _HrStartDownloading(void);
    HRESULT _HrOnTopResponse(LPPOP3RESPONSE pResponse);
    HRESULT _HrNextTopForInboxRule(DWORD dwPopIdCurrent);
    HRESULT _HrGetUidlFromHeaderStream(IStream *pStream, LPSTR *ppszUidl, IMimePropertySet **ppHeader);
    HRESULT _HrRetrieveNextMessage(DWORD dwPopIdCurrent);
    HRESULT _HrDeleteNextMessage(DWORD dwPopIdCurrent);
    HRESULT _HrOnRetrResponse(LPPOP3RESPONSE pResponse);
    HRESULT _HrFinishMessageDownload(DWORD dwPopId);
    HRESULT _HrStartDeleteCycle(void);
    HRESULT _HrOpenFolder(IMessageFolder *pFolder);
    HRESULT _HrStartServerSideRules(void);
    HRESULT _HrStitchPartials(void);
    HRESULT _HrBuildFolderPartialMsgs(IMessageFolder *pFolder, LPPARTIALMSG *ppPartialMsgs, ULONG *pcPartialMsgs, ULONG *pcTotalParts);
    BOOL _FUidlExpired(LPUIDLRECORD pUidlInfo);
    void _QSortMsgParts(LPMSGPART pMsgParts, LONG left, LONG right);
    void _CleanupUidlCache(void);
    void _DoPostDownloadActions(LPPOP3ITEM pItem, MESSAGEID idMessage, IMessageFolder *pFolder, IMimeMessage *pMessage, BOOL *pfDeleteOffServer);
    void _CloseFolder(void);
    void _ComputeItemInboxRule(LPPOP3ITEM pItem, LPSTREAM pStream, IMimePropertySet *pHeaderIn, IMimeMessage * pIMMsg, BOOL fServerRules);
    void _GetItemFlagsFromUidl(LPPOP3ITEM pItem);
    void _DoProgress(void);
    void _ResetObject(BOOL fDeconstruct);
    void _FreeItemTableElements(void);
    void _OnKnownRuleActions(LPPOP3ITEM pItem, ACT_ITEM * pActions, ULONG cActions, BOOL fServerRules);
    void _FreePartialMsgs(LPPARTIALMSG pPartialMsgs, ULONG cPartialMsgs);
    void _ReleaseFolderObjects(void);
    HRESULT _HrDoUidlSynchronize(void);
    void _FreeSmartLog(void);
    HRESULT _InitializeSmartLog(void);
    void _DoSmartLog(IMimeMessage *pMessage);
    HRESULT _ReadSmartLogEntry(HKEY hKey, LPCSTR pszKey, LPSTR *ppszValue);
    HRESULT _GetMoveFolder(LPPOP3ITEM pItem, IMessageFolder ** ppFolder);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    DWORD                   m_cRef;              // Reference Coutning
    INETSERVER              m_rServer;           // Server information
    DWORD                   m_dwFlags;           // DELIVER_xxx flags
    ISpoolerBindContext    *m_pSpoolCtx;         // Spooler bind contexting
    IImnAccount            *m_pAccount;          // Internet Account
    IPOP3Transport         *m_pTransport;        // SMTP transport    
    POP3ITEMTABLE           m_rTable;            // Item Table
    ISpoolerUI             *m_pUI;               // SpoolerUI
    IMessageFolder         *m_pInbox;            // The Inbox
    IMessageFolder         *m_pOutbox;           // The Inbox
    IOEExecRules           *m_pIExecRules;       // Inbox Rules
    IOERule                *m_pIRuleSender;      // Block Sender Rule
    IOERule                *m_pIRuleJunk;        // Junk Mail Rule
    IDatabase              *m_pUidlCache;        // POP3 uidl Cache
    DWORD                   m_dwState;           // State
    POP3UIDLSUPPORT         m_uidlsupport;       // How does the server support uidl
    DWORD                   m_dwExpireDays;      // Used with option POP3STATE_DELETEEXPIRED
    EVENTID                 m_eidEvent;          // Current Event Ids        
    DWORD                   m_dwProgressMax;     // Max Progress
    DWORD                   m_dwProgressCur;     // Current Progress
    WORD                    m_wProgress;         // Percentage progress
    HRESULT                 m_hrResult;          // Event Result
    IStream                *m_pStream;           // Temporary Stream object
    POP3STATE               m_state;             // Current State
    POP3METRICS             m_rMetrics;          // Poll/Download Metrics
    POP3FOLDERINFO          m_rFolder;           // Current foldering being written to
    HWND                    m_hwndTimeout;       // Timeout Prompt
    ILogFile               *m_pLogFile;          // LogFile
    LPSMARTLOGINFO          m_pSmartLog;         // Smart logging information
    CHAR                    m_szAccountId[CCHMAX_ACCOUNT_NAME];
    CRITICAL_SECTION        m_cs;                // Thread Safety
};

#endif // __POP3TASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\smtptask.h ===
// --------------------------------------------------------------------------------
// Smtptask.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __SMTPTASK_H
#define __SMTPTASK_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "spoolapi.h"
#include "imnxport.h"
#include "taskutil.h"
#include "storutil.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
typedef struct tagMAILMSGHDR *LPMAILMSGHDR;
interface ILogFile;
interface IMimeMessage;
interface IMimeEnumAddressTypes;

// --------------------------------------------------------------------------------
// State
// --------------------------------------------------------------------------------
#define SMTPSTATE_CANCELED      FLAG01
#define SMTPSTATE_DEFAULT       FLAG02
#define SMTPSTATE_ASKEDDEFAULT  FLAG03
#define SMTPSTATE_USEDEFAULT    FLAG04
#define SMTPSTATE_EXECUTEFAILED FLAG05


// --------------------------------------------------------------------------------
// SMTPTASKEVENT_xxx Flags
// --------------------------------------------------------------------------------
#define SMTPEVENT_SPLITPART     FLAG01          // Sending a split part
#define SMTPEVENT_COMPLETE      FLAG02          // The event was completed

// --------------------------------------------------------------------------------
// SMTPEVENTINFO
// --------------------------------------------------------------------------------
typedef struct tagSMTPEVENTINFO {
    DWORD               dwFlags;                // Flags
    MESSAGEID           idMessage;              // Store Information
    DWORD               cbEvent;                // Size of the message
    DWORD               cbEventSent;            // Size of the message
    DWORD               cbSentTotal;            // Where m_cbSent should be after this
    DWORD               cRecipients;            // Recipient
    IMimeMessage       *pMessage;               // Message to send
    DWORD               iPart;                  // Part dwPart of cTotalParts
    DWORD               cParts;                 // Part dwPart of cTotalParts
    DWORD               cbParts;                // Number of bytes of original message
    HRESULT             hrResult;               // Result of this event
} SMTPEVENTINFO, *LPSMTPEVENTINFO;

// --------------------------------------------------------------------------------
// SMTPEVENTTABLE
// --------------------------------------------------------------------------------
typedef struct tagSMTPEVENTTABLE {
    DWORD               iEvent;                 // Current Event
    DWORD               cCompleted;             // Number of events completed
    DWORD               cEvents;                // Number of events in prgEvent
    DWORD               cAlloc;                 // Number of items allocated in prgEvent
    LPSMTPEVENTINFO     prgEvent;               // Array of events
} SMTPEVENTTABLE, *LPSMTPEVENTTABLE;

// --------------------------------------------------------------------------------
// CSmtpTask
// --------------------------------------------------------------------------------
class CSmtpTask : public ISpoolerTask, 
                  public ISMTPCallback, 
                  public ITimeoutCallback,
                  public ITransportCallbackService,
                  public IStoreCallback
{
public:
    // ----------------------------------------------------------------------------
    // CSmtpTask
    // ----------------------------------------------------------------------------
    CSmtpTask(void);
    ~CSmtpTask(void);
    
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // ---------------------------------------------------------------------------
    // ISpoolerTask
    // ---------------------------------------------------------------------------
    STDMETHODIMP Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx);
    STDMETHODIMP BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder);
    STDMETHODIMP Execute(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie);
    STDMETHODIMP ShowProperties(HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie) {
        return TrapError(E_NOTIMPL); }
    STDMETHODIMP GetExtendedDetails(EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails) {
        return TrapError(E_NOTIMPL); }
    STDMETHODIMP Cancel(void);
    STDMETHODIMP IsDialogMessage(LPMSG pMsg);
    STDMETHODIMP OnFlagsChanged(DWORD dwFlags);
    
    // --------------------------------------------------------------------------------
    // ITransportCallbackService Members
    // --------------------------------------------------------------------------------
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent) {
        TraceCall("CSmtpTask::GetParentWindow");
        if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
            return TraceResult(E_FAIL);
        if (m_pUI)
            return m_pUI->GetWindow(phwndParent);
        return TraceResult(E_FAIL);
    }

    STDMETHODIMP GetAccount(LPDWORD pdwServerType, IImnAccount **ppAccount) {
        Assert(ppAccount && m_pAccount);
        *pdwServerType = SRV_SMTP;
        *ppAccount = m_pAccount;
        (*ppAccount)->AddRef();
        return(S_OK);
    }
    
    // --------------------------------------------------------------------------------
    // ITransportCallback Members
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pInetServer, IInternetTransport *pTransport);
    STDMETHODIMP_(INT) OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport);
    STDMETHODIMP OnStatus(IXPSTATUS ixpstatus, IInternetTransport *pTransport);
    STDMETHODIMP OnError(IXPSTATUS ixpstatus, LPIXPRESULT pResult, IInternetTransport *pTransport);
    STDMETHODIMP OnCommand(CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport);
    
    // --------------------------------------------------------------------------------
    // ISMTPCallback
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnResponse(LPSMTPRESPONSE pResponse);
    
    // --------------------------------------------------------------------------------
    // ITimeoutCallback
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnTimeoutResponse(TIMEOUTRESPONSE eResponse);
    
    // --------------------------------------------------------------------------------
    // IStoreCallback Interface
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);

private:
    // ---------------------------------------------------------------------------
    // Private Methods
    // ---------------------------------------------------------------------------
    HRESULT _HrAppendOutboxMessage(LPCSTR pszAccount, LPMESSAGEINFO pMsgInfo, BOOL fSplitMsgs, DWORD cbMaxPart);
    HRESULT _HrAppendEventTable(LPSMTPEVENTINFO *ppEvent);
    HRESULT _HrAppendSplitMessage(LPMESSAGEINFO pMsgInfo, DWORD cbMaxPart);
    HRESULT _HrOpenMessage(MESSAGEID dwMsgId, IMimeMessage **ppMessage);
    HRESULT _ExecuteSMTP(EVENTID eid, DWORD_PTR dwTwinkie);
    HRESULT _ExecuteUpload(EVENTID eid, DWORD_PTR dwTwinkie);
    void _FreeEventTableElements(void);
    void _ResetObject(BOOL fDeconstruct);
    
    // ---------------------------------------------------------------------------
    // Error / Progress Methods
    // ---------------------------------------------------------------------------
    TASKRESULTTYPE _CatchResult(LPIXPRESULT pResult, INETSERVER *pServer, IXPTYPE ixpType);
    TASKRESULTTYPE _CatchResult(HRESULT hrResult, IXPTYPE ixpType);
    void _DoProgress(void);
    
    // ---------------------------------------------------------------------------
    // Event State Methods
    // ---------------------------------------------------------------------------
    HRESULT _HrStartCurrentEvent(void);
    HRESULT _HrCommandMAIL(void);
    HRESULT _HrCommandRCPT(void);
    HRESULT _HrSendDataStream(void);
    HRESULT _HrFinishCurrentEvent(HRESULT hrResult);
    HRESULT _HrStartNextEvent(void);
    HRESULT _HrOnConnected(void);
    HRESULT _OnDisconnectComplete(void);
    void _OnStreamProgress(LPSMTPSTREAM pInfo);
    
private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    DWORD                   m_cRef;              // Reference Coutning
    INETSERVER              m_rServer;           // Server information
    DWORD                   m_dwFlags;           // DELIVER_xxx flags
    ISpoolerBindContext    *m_pSpoolCtx;         // Spooler bind contexting
    IImnAccount            *m_pAccount;          // Internet Account
    ISMTPTransport         *m_pTransport;        // SMTP transport    
    IMessageFolder         *m_pOutbox;           // The outbox
    IMessageFolder         *m_pSentItems;
    SMTPEVENTTABLE          m_rTable;            // Event Table
    DWORD                   m_cbTotal;           // Total number of bytes to send
    DWORD                   m_cbSent;            // Total number of bytes to send
    WORD                    m_wProgress;         // Current progress index
    EVENTID                 m_idEvent;           // EventId for SMTP message send
    EVENTID                 m_idEventUpload;     // EventId for SMTP message send
    ISpoolerUI             *m_pUI;               // SpoolerUI
    DWORD                   m_dwState;           // State
    IMimeEnumAddressTypes  *m_pAdrEnum;          // Address Enumerator
    HWND                    m_hwndTimeout;       // Handle to timeout window
    ILogFile               *m_pLogFile;          // Logfile
    CRITICAL_SECTION        m_cs;                // Thread Safety

    // Callback 
    MESSAGEIDLIST           m_rList;
    IOperationCancel       *m_pCancel;
    STOREOPERATIONTYPE      m_tyOperation;    
};

// --------------------------------------------------------------------------------
// CMessageIdStream
// --------------------------------------------------------------------------------
class CMessageIdStream : public IStream
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CMessageIdStream(IStream *pStream);
    ~CMessageIdStream(void) { m_pStream->Release(); }
    
    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP_(ULONG) AddRef(void) { return ++m_cRef; }
    STDMETHODIMP_(ULONG) Release(void) {
        if (0 != --m_cRef)
            return m_cRef;
        delete this;
        return 0;
    }
    
    // -------------------------------------------------------------------------
    // IStream Not implemented Methods
    // -------------------------------------------------------------------------
    STDMETHODIMP Stat(STATSTG *, DWORD)  { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP Write(const void *, ULONG, ULONG *)  { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP SetSize(ULARGE_INTEGER) { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *) { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP Commit(DWORD)  { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP Revert(void)  { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD)  { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD)  { Assert(FALSE); return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM *)  { Assert(FALSE); return E_NOTIMPL; }
    
    STDMETHODIMP Read(LPVOID pv, ULONG cbWanted, ULONG *pcbRead);
    STDMETHODIMP Seek(LARGE_INTEGER liMove, DWORD dwOrigin, ULARGE_INTEGER *pulNew);
    
    // -------------------------------------------------------------------------
    // CMessageIdStream - Returns the length of the messageid
    // -------------------------------------------------------------------------
    ULONG CchMessageId(void) { return m_cchMessageId; }
    
private:
    IStream             *m_pStream;
    CHAR                 m_szMessageId[512];
    ULONG                m_cchMessageId;
    ULONG                m_cbIndex;
    ULONG                m_cRef;
};

#endif // __SMTPTASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\smtptask.cpp ===
// --------------------------------------------------------------------------------
// Smtptask.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "smtptask.h"
#include "mimeutil.h"
#include "goptions.h"
#include "strconst.h"
#include "xputil.h"
#include "resource.h"
#include "shlwapip.h" 
#include "spoolui.h"
#include "thormsgs.h"
#include "flagconv.h"
#include "ourguid.h"
#include "msgfldr.h"
#include "storecb.h"
#include "demand.h"
#include "taskutil.h"

// --------------------------------------------------------------------------------
// Data Types
// --------------------------------------------------------------------------------
typedef enum tagSMTPEVENTTYPE
    { 
    EVENT_SMTP,
    EVENT_IMAPUPLOAD
    } SMTPEVENTTYPE;

// --------------------------------------------------------------------------------
// CURRENTSMTPEVENT
// --------------------------------------------------------------------------------
#define CURRENTSMTPEVENT(_rTable) (&_rTable.prgEvent[_rTable.iEvent])


// --------------------------------------------------------------------------------
// CMessageIdStream::CMessageIdStream
// --------------------------------------------------------------------------------
CMessageIdStream::CMessageIdStream(IStream *pStream) : m_pStream(pStream) 
{
    // Reference count
    m_cRef = 1;

    // Addref the source stream
    m_pStream->AddRef();

    // Format the string
    ULONG cchPrefix = wsprintf(m_szMessageId, "%s: ", STR_HDR_MESSAGEID);

    // Generate a message Id
    if (FAILED(MimeOleGenerateMID(m_szMessageId + cchPrefix, sizeof(m_szMessageId) - cchPrefix, FALSE)))
    {
        Assert(FALSE);
        *m_szMessageId = '\0';
        m_cchMessageId = 0;
    }

    // Otherwise, fixup the message id so that <mid>\r\n
    else
    {
        lstrcat(m_szMessageId, "\r\n");
        m_cchMessageId = lstrlen(m_szMessageId);
    }

    // Iniailize Index
    m_cbIndex = 0;
}

// --------------------------------------------------------------------------------
// CMessageIdStream::Seek
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageIdStream::Seek(LARGE_INTEGER liMove, DWORD dwOrigin, ULARGE_INTEGER *pulNew) 
{ 
    // Only supported case
    if (STREAM_SEEK_SET != dwOrigin && 0 != liMove.LowPart && 0 != liMove.HighPart && 0 != m_cbIndex) 
    {
        Assert(FALSE);
        return E_NOTIMPL; 
    }

    // Otheriwse, set new position
    else if (pulNew)
    {
        pulNew->HighPart = 0;
        pulNew->LowPart = 0;
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageIdStream::Read
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageIdStream::Read(LPVOID pv, ULONG cbWanted, ULONG *pcbRead) 
{
    // Locals
    HRESULT hr=S_OK;

    // Reading from m_szMessageId ?
    if (m_cbIndex < m_cchMessageId)
    {
        // Compute amount I can read from m_cchMessageId
        ULONG cbReadMsgId = min(m_cchMessageId - m_cbIndex, cbWanted);

        // Init pcbRead
        if (pcbRead)
            *pcbRead = 0;

        // If we have some ?
        if (cbReadMsgId)
        {
            // Copy memory
            CopyMemory(pv, m_szMessageId + m_cbIndex, cbReadMsgId);

            // Increment index
            m_cbIndex += cbReadMsgId;
        }

        // If there is still some left to read...
        if (cbReadMsgId < cbWanted)
            hr = m_pStream->Read(((LPBYTE)pv + cbReadMsgId), cbWanted - cbReadMsgId, pcbRead);

        // Fixup pcbRead
        if (pcbRead)
            (*pcbRead) += cbReadMsgId;
    }

    // Otherwise, read from source stream
    else
        hr = m_pStream->Read(pv, cbWanted, pcbRead);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::CSmtpTask
// --------------------------------------------------------------------------------
CSmtpTask::CSmtpTask(void)
{
    m_cRef = 1;
    m_dwFlags = 0;
    m_pSpoolCtx = NULL;
    m_pAccount = NULL;
    m_pTransport = NULL;
    m_pOutbox = NULL;
    m_pSentItems = NULL;
    m_cbTotal = 0;
    m_cbSent = 0;
    m_wProgress = 0;
    m_idEvent = INVALID_EVENT;
    m_idEventUpload = INVALID_EVENT;
    m_pUI = NULL;
    m_dwState = 0;
    m_pAdrEnum = NULL;
    m_hwndTimeout = NULL;
    m_pLogFile = NULL;
    ZeroMemory(&m_rServer, sizeof(INETSERVER));
    ZeroMemory(&m_rTable, sizeof(SMTPEVENTTABLE));
    ZeroMemory(&m_rList, sizeof(MESSAGEIDLIST));
    m_pCancel = NULL;
    m_tyOperation = SOT_INVALID;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CSmtpTask::~CSmtpTask
// --------------------------------------------------------------------------------
CSmtpTask::~CSmtpTask(void)
{
    // Reset the Object
    _ResetObject(TRUE);

    // Kill the critical section
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CSmtpTask::_ResetObject
// --------------------------------------------------------------------------------
void CSmtpTask::_ResetObject(BOOL fDeconstruct)
{
    // Make sure the transport is disconnect
    if (m_pTransport)
    {
        m_pTransport->Release();
        m_pTransport = NULL;
    }

    // Release the Outbox
    SafeRelease(m_pAccount);
    SafeRelease(m_pOutbox);
    SafeRelease(m_pSentItems);
    SafeRelease(m_pAdrEnum);
    SafeRelease(m_pSpoolCtx);
    SafeRelease(m_pUI);
    SafeRelease(m_pLogFile);
    SafeRelease(m_pCancel);
    SafeMemFree(m_rList.prgidMsg);
    ZeroMemory(&m_rList, sizeof(MESSAGEIDLIST));

    // Free the event table elements
    _FreeEventTableElements();

    // Deconstructing
    if (fDeconstruct)
    {
        // Free Event Table
        SafeMemFree(m_rTable.prgEvent);
    }

    // Otherwise, reset some vars
    else
    {
        // Reset total byte count
        m_cbTotal = 0;
        m_idEvent = INVALID_EVENT;
        m_cbSent = 0;
        m_wProgress = 0;
        ZeroMemory(&m_rServer, sizeof(INETSERVER));
    }
}

// --------------------------------------------------------------------------------
// CSmtpTask::Init
// --------------------------------------------------------------------------------
void CSmtpTask::_FreeEventTableElements(void)
{
    // Loop the table of events
    for (ULONG i=0; i<m_rTable.cEvents; i++)
    {
        // Release the Message
        SafeRelease(m_rTable.prgEvent[i].pMessage);
    }

    // No Events
    m_rTable.cEvents = 0;
}

// --------------------------------------------------------------------------------
// CSmtpTask::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(ISpoolerTask *)this;
    else if (IID_ISpoolerTask == riid)
        *ppv = (ISpoolerTask *)this;
    else if (IID_ITimeoutCallback == riid)
        *ppv = (ITimeoutCallback *) this;
    else if (IID_ITransportCallbackService == riid)
        *ppv = (ITransportCallbackService *) this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::CSmtpTask
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSmtpTask::AddRef(void)
{
    EnterCriticalSection(&m_cs);
    ULONG cRef = ++m_cRef;
    LeaveCriticalSection(&m_cs);
    return cRef;
}

// --------------------------------------------------------------------------------
// CSmtpTask::CSmtpTask
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSmtpTask::Release(void)
{
    EnterCriticalSection(&m_cs);
    ULONG cRef = --m_cRef;
    LeaveCriticalSection(&m_cs);
    if (0 != cRef)
        return cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CSmtpTask::Init
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::Init(DWORD dwFlags, ISpoolerBindContext *pBindCtx)
{
    // Invalid Arg
    if (NULL == pBindCtx)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Reset this object
    _ResetObject(FALSE);

    // Save the Activity Flags - DELIVER_xxx
    m_dwFlags = dwFlags;

    // Hold onto the bind context
    Assert(NULL == m_pSpoolCtx);
    m_pSpoolCtx = pBindCtx;
    m_pSpoolCtx->AddRef();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::BuildEvents
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::BuildEvents(ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       fSplitMsgs;
    FOLDERINFO  Folder;
    FOLDERID    id;
    DWORD       cbMaxPart;
    CHAR        szRes[255];
    CHAR        szMessage[255];
    CHAR        szAccount[CCHMAX_ACCOUNT_NAME];
    CHAR        szDefault[CCHMAX_ACCOUNT_NAME];
    MESSAGEINFO MsgInfo={0};
    HROWSET     hRowset=NULL;

    // Invalid Arg
    if (NULL == pSpoolerUI || NULL == pAccount)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate State
    Assert(NULL == m_pTransport && NULL == m_pAccount && NULL == m_pOutbox && 0 == m_rTable.cEvents);
    Assert(NULL == m_pSentItems);

    // Save the UI Object
    m_pUI = pSpoolerUI;
    m_pUI->AddRef();

    // Release current Account
    m_pAccount = pAccount;
    m_pAccount->AddRef();

    // Get the Account Name
    CHECKHR(hr = m_pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccount, ARRAYSIZE(szAccount)));

    // Split Messages ?
    if (FAILED(m_pAccount->GetPropDw(AP_SMTP_SPLIT_MESSAGES, &fSplitMsgs)))
        fSplitMsgs = FALSE;

    // Split Size
    if (FAILED(m_pAccount->GetPropDw(AP_SMTP_SPLIT_SIZE, &cbMaxPart)))
    {
        fSplitMsgs = FALSE;
        cbMaxPart = 0;
    }

    // Else, convert cbMaxPart for kilobytes to bytes
    else
        cbMaxPart *= 1024;

    // Get the default Account
    if (SUCCEEDED(g_pAcctMan->GetDefaultAccountName(ACCT_MAIL, szDefault, ARRAYSIZE(szDefault))))
    {
        if (lstrcmpi(szDefault, szAccount) == 0)
            FLAGSET(m_dwState, SMTPSTATE_DEFAULT);
    }

    // Get the outbox
    CHECKHR(hr = m_pSpoolCtx->BindToObject(IID_CLocalStoreOutbox, (LPVOID *)&m_pOutbox));

    // Create a Rowset
    CHECKHR(hr = m_pOutbox->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Loop
    while (S_OK == m_pOutbox->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL))
    {
        // Process Store Header
        CHECKHR(hr = _HrAppendOutboxMessage(szAccount, &MsgInfo, fSplitMsgs, cbMaxPart));

        // Free Current
        m_pOutbox->FreeRecord(&MsgInfo);
    } 

    // If no messages, were done
    if (0 == m_rTable.cEvents)
        goto exit;

    // Get a SMTP log file
    m_pSpoolCtx->BindToObject(IID_CSmtpLogFile, (LPVOID *)&m_pLogFile);

    // Format the string
    LOADSTRING(IDS_SPS_SMTPEVENT, szRes);

    // Build the message
    wsprintf(szMessage, szRes, m_rTable.cEvents, szAccount);

    // Register the event
    CHECKHR(hr = m_pSpoolCtx->RegisterEvent(szMessage, (ISpoolerTask *)this, EVENT_SMTP, m_pAccount, &m_idEvent));

    // Get SentItems
    if (DwGetOption(OPT_SAVESENTMSGS))
    {
        // Get Sent Items Folder
        CHECKHR(hr = TaskUtil_OpenSentItemsFolder(m_pAccount, &m_pSentItems));

        // Get the Folder Id
        m_pSentItems->GetFolderId(&id);

        // Get the folder information
        CHECKHR(hr = g_pStore->GetFolderInfo(id, &Folder));

        // If not a local folder, then we will need to do an upload
        if (Folder.tyFolder != FOLDER_LOCAL)
        {
            // Get event string
            LOADSTRING(IDS_SPS_MOVEEVENT, szRes);

            // Format the message
            wsprintf(szMessage, szRes, szAccount);

            // Register Upload Event
            CHECKHR(hr = m_pSpoolCtx->RegisterEvent(szMessage, (ISpoolerTask *)this, EVENT_IMAPUPLOAD, m_pAccount, &m_idEventUpload));
        }

        // Free the Record
        g_pStore->FreeRecord(&Folder);
    }

exit:
    // Cleanup
    if (m_pOutbox)
    {
        m_pOutbox->CloseRowset(&hRowset);
        m_pOutbox->FreeRecord(&MsgInfo);
    }

    // Failure
    if (FAILED(hr))
    {
        _CatchResult(hr, IXP_SMTP);
        _ResetObject(FALSE);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrAppendEventTable
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrAppendEventTable(LPSMTPEVENTINFO *ppEvent)
{
    // Locals
    HRESULT hr=S_OK;

    // Add an item to the event list
    if (m_rTable.cEvents + 1 > m_rTable.cAlloc)
    {
        // Realloc the table
        CHECKHR(hr = HrRealloc((LPVOID *)&m_rTable.prgEvent, sizeof(SMTPEVENTINFO) * (m_rTable.cAlloc + 10)));

        // Increment cAlloc
        m_rTable.cAlloc += 10;
    }

    // Readability
    *ppEvent = &m_rTable.prgEvent[m_rTable.cEvents];

    // ZeroInit
    ZeroMemory(*ppEvent, sizeof(SMTPEVENTINFO));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrAppendOutboxMessage
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrAppendOutboxMessage(LPCSTR pszAccount, LPMESSAGEINFO pMsgInfo, 
    BOOL fSplitMsgs, DWORD cbMaxPart)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSMTPEVENTINFO pEvent;
    IImnAccount    *pAccount=NULL;

    // Invalid Arg
    Assert(pszAccount && pMsgInfo);

    // Has this message been submitted and is it a mail message
    if((pMsgInfo->dwFlags & (ARF_SUBMITTED | ARF_NEWSMSG)) != ARF_SUBMITTED)
        goto exit;

    // Empty Account Name
    if (NULL == pMsgInfo->pszAcctId || FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pMsgInfo->pszAcctId, &pAccount)))
    {
        // Not the Default Account
        if (!ISFLAGSET(m_dwState, SMTPSTATE_DEFAULT) || ISFLAGSET(m_dwFlags, DELIVER_NOUI))
            goto exit;

        // Have I asked the user if they want to use the default account
        if (!ISFLAGSET(m_dwState, SMTPSTATE_ASKEDDEFAULT))
        {
            // Get hwndParent
            HWND hwndParent;
            if (FAILED(m_pUI->GetWindow(&hwndParent)))
                hwndParent = NULL;

            // Message
            if (AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(IDS_SPS_SMTPUSEDEFAULT), NULL, MB_YESNO|MB_ICONEXCLAMATION ) == IDYES)
                FLAGSET(m_dwState, SMTPSTATE_USEDEFAULT);
            else
                goto exit;

            // I've Asked, don't ask again
            FLAGSET(m_dwState, SMTPSTATE_ASKEDDEFAULT);
        }

        // Not using default
        else if (!ISFLAGSET(m_dwState, SMTPSTATE_USEDEFAULT))
            goto exit;
    }

    // Use this account
    else if (lstrcmpi(pMsgInfo->pszAcctName, pszAccount) != 0)
        goto exit;

    // Split the Message ?
    if (TRUE == fSplitMsgs && pMsgInfo->cbMessage >= cbMaxPart)
    {
        // Make sure the total number of messages is less than 100
        if (100 <= (pMsgInfo->cbMessage / cbMaxPart))
        {
            HWND    hwndParent;
            CHAR    rgchBuff[CCHMAX_STRINGRES + 20];
            CHAR    rgchRes[CCHMAX_STRINGRES];
            DWORD   cbMaxPartCount;
            
            // Figure out the new message part size
            cbMaxPartCount = pMsgInfo->cbMessage / 100;

            // Round the new message part size to the
            // closest power of 2
            if (0x80000000 <= cbMaxPartCount)
            {
                // Can't round up any higher
                cbMaxPart = cbMaxPartCount;
            }
            else
            {
                cbMaxPart = 1;
                do
                {
                    cbMaxPart *= 2;
                } while ( 0 != (cbMaxPartCount /= 2));
            }

            // Get the UI window
            if (FAILED(m_pUI->GetWindow(&hwndParent)))
                hwndParent = NULL;

            if (NULL == AthLoadString(idsErrTooManySplitMsgs, rgchRes, sizeof(rgchRes)))
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            // Display the warning string
            wsprintf(rgchBuff, rgchRes, cbMaxPart / 1024);
            if (AthMessageBox(hwndParent, MAKEINTRESOURCE(idsAthenaMail), rgchBuff, NULL, MB_YESNO|MB_ICONEXCLAMATION ) != IDYES)
                goto exit;
        }
        
        // Split and Add the message
        CHECKHR(hr = _HrAppendSplitMessage(pMsgInfo, cbMaxPart));
    }

    // Otherwise, simply add the message as normal
    else
    {
        // Append the Table
        CHECKHR(hr = _HrAppendEventTable(&pEvent));

        // Save the store message id
        pEvent->idMessage = pMsgInfo->idMessage;

        // Save Message Size + 100 which is the average MID that is added on
        pEvent->cbEvent = pMsgInfo->cbMessage;

        // Increment total send byte count
        m_cbTotal += pEvent->cbEvent;

        // Running Sent Total
        pEvent->cbSentTotal = m_cbTotal;

        // Increment Number of event
        m_rTable.cEvents++;
    }

exit:
    // Cleanup
    SafeRelease(pAccount);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrAppendSplitMessage
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrAppendSplitMessage(LPMESSAGEINFO pMsgInfo, DWORD cbMaxPart)
{
    // Locals
    HRESULT                  hr=S_OK;
    ULONG                    c;
    ULONG                    iPart=1;
    ULONG                    cParts;
    IMimeMessage            *pMessage=NULL;
    IMimeMessage            *pMsgPart=NULL;
    IMimeMessageParts       *pParts=NULL;
    IMimeEnumMessageParts   *pEnum=NULL;
    LPSMTPEVENTINFO          pEvent;

    // Invalid Arg
    Assert(pMsgInfo);

    // Lets open the message from the Outbox
    CHECKHR(hr = _HrOpenMessage(pMsgInfo->idMessage, &pMessage));

    // Split the message
    CHECKHR(hr = pMessage->SplitMessage(cbMaxPart, &pParts));

    // Get Total Parts
    CHECKHR(hr = pParts->CountParts(&cParts));

    // Walk the list of messages
    CHECKHR(hr = pParts->EnumParts(&pEnum));

    // Walk the parts and add them into the event list
    while(SUCCEEDED(pEnum->Next(1, &pMsgPart, &c)) && 1 == c)
    {
        // Append the Table
        CHECKHR(hr = _HrAppendEventTable(&pEvent));

        // Event Type
        FLAGSET(pEvent->dwFlags, SMTPEVENT_SPLITPART);

        // Split Information
        pEvent->iPart = iPart;
        pEvent->cParts = cParts;
        pEvent->cbParts = pMsgInfo->cbMessage;

        // Save the message part
        pEvent->pMessage = pMsgPart;
        pMsgPart = NULL;

        // Save Message Size
        pEvent->pMessage->GetMessageSize(&pEvent->cbEvent, 0);

        // Increment total send byte count
        m_cbTotal += pEvent->cbEvent;

        // Running Sent Total
        pEvent->cbSentTotal = m_cbTotal;

        // Increment Number of event
        m_rTable.cEvents++;

        // Increment iPart
        iPart++;
    }

    // Have the last split message free the header info
    pEvent->idMessage = pMsgInfo->idMessage;

exit:
    // Cleanup
    SafeRelease(pMessage);
    SafeRelease(pParts);
    SafeRelease(pMsgPart);
    SafeRelease(pEnum);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CSmtpTask::_HrOpenMessage
// ------------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrOpenMessage(MESSAGEID idMessage, IMimeMessage **ppMessage)
{
    // Locals
    HRESULT         hr=S_OK;

    // Check Params
    Assert(ppMessage && m_pOutbox);

    // Init
    *ppMessage = NULL;

    // Stream in message
    CHECKHR(hr = m_pOutbox->OpenMessage(idMessage, OPEN_MESSAGE_SECURE  , ppMessage, NOSTORECALLBACK));

    // remove an X-Unsent headers before sending
    (*ppMessage)->DeleteBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_XUNSENT));

exit:
    // Failure
    if (FAILED(hr))
        SafeRelease((*ppMessage));

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::Execute
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::Execute(EVENTID eid, DWORD_PTR dwTwinkie)
{
    HRESULT hr = E_FAIL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // What is the event type
    if (EVENT_SMTP == dwTwinkie)
    {
        // Better not have a transport yet...
        Assert(NULL == m_pTransport);

        // Create the Transport Object
        CHECKHR(hr = CreateSMTPTransport(&m_pTransport));

        // Init the Transport
        CHECKHR(hr = m_pTransport->InitNew(NULL, (ISMTPCallback *)this));

        // Fill an INETSERVER structure from the account object
        CHECKHR(hr = m_pTransport->InetServerFromAccount(m_pAccount, &m_rServer));

        // Use IP Address for HELO command ?
        if (DwGetOption(OPT_SMTPUSEIPFORHELO))
            FLAGSET(m_rServer.dwFlags, ISF_SMTP_USEIPFORHELO);

        // If this account is set to always prompt for password and password isn't already cached, show UI so we can prompt user for password
        if (ISFLAGSET(m_rServer.dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) && FAILED(GetPassword(m_rServer.dwPort, m_rServer.szServerName, m_rServer.szUserName, NULL, 0)))
            m_pUI->ShowWindow(SW_SHOW);

        // Execute SMTP Event
        hr = _ExecuteSMTP(eid, dwTwinkie);
    }

    // Otherwise, do IMAP Event
    else if (EVENT_IMAPUPLOAD == dwTwinkie)
        hr = _ExecuteUpload(eid, dwTwinkie);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

STDMETHODIMP CSmtpTask::CancelEvent(EVENTID eid, DWORD_PTR dwTwinkie)
{
    return(S_OK);
}

// --------------------------------------------------------------------------------
// CSmtpTask::_ExecuteSMTP
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_ExecuteSMTP(EVENTID eid, DWORD_PTR dwTwinkie)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szRes[CCHMAX_RES];
    CHAR        szBuf[CCHMAX_RES + CCHMAX_SERVER_NAME];
    DWORD       cb;

    // I only handle on event
    Assert(m_pAccount && m_idEvent == eid && m_pUI && m_pTransport && m_rTable.cEvents > 0);

    // Set the animation
    m_pUI->SetAnimation(idanOutbox, TRUE);

    // Setup Progress Meter
    m_pUI->SetProgressRange(100);

    // Connecting to ...
    LoadString(g_hLocRes, idsInetMailConnectingHost, szRes, ARRAYSIZE(szRes));
    wsprintf(szBuf, szRes, m_rServer.szAccount);
    m_pUI->SetGeneralProgress(szBuf);

    // Notify
    m_pSpoolCtx->Notify(DELIVERY_NOTIFY_CONNECTING, 0);

    // Connect
    CHECKHR(hr = m_pTransport->Connect(&m_rServer, TRUE, TRUE));

exit:
    // Failure
    if (FAILED(hr))
    {
        FLAGSET(m_dwState, SMTPSTATE_EXECUTEFAILED);
        _CatchResult(hr, IXP_SMTP);

        // Hands Off my callback: otherwise we leak like a stuck pig
        SideAssert(m_pTransport->HandsOffCallback() == S_OK);
    }

    return hr;
} // _ExecuteSMTP

HRESULT CSmtpTask::_ExecuteUpload(EVENTID eid, DWORD_PTR dwTwinkie)
{
    // Locals
    HRESULT             hr=S_OK;
    ADJUSTFLAGS         Flags;

    // I only handle on event
    Assert(m_pAccount && m_idEventUpload == eid && m_pUI && m_pTransport && m_rTable.cEvents > 0);

    // Invalid State
    Assert(m_pOutbox);
    Assert(m_pSentItems != NULL);

    // Are the Ids
    if (m_rList.cMsgs)
    {
        // Setup Flags
        Flags.dwAdd = ARF_READ;
        Flags.dwRemove = ARF_SUBMITTED | ARF_UNSENT;

        // Move the message from the sent items folder
        hr = m_pOutbox->CopyMessages(m_pSentItems, COPY_MESSAGE_MOVE, &m_rList, &Flags, NULL, this);
        Assert(FAILED(hr));
        if (hr == E_PENDING)
        {
            hr = S_OK;
        }
        else
        {
            IXPTYPE ixpType;

            FLAGSET(m_dwState, SMTPSTATE_EXECUTEFAILED);
    
            // Remap the Error Result
            hr = TrapError(SP_E_CANT_MOVETO_SENTITEMS);

            // Show an error in the spooler dialog
            ixpType = m_pTransport->GetIXPType();
            _CatchResult(hr, ixpType);
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
} // _ExecuteSMTP

// --------------------------------------------------------------------------------
// CSmtpTask::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Is there currently a timeout dialog
    if (m_hwndTimeout)
    {
        // Set foreground
        SetForegroundWindow(m_hwndTimeout);
    }
    else
    {
        // Not suppose to be showing UI ?
        if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
        {
            hr = S_FALSE;
            goto exit;
        }

        // Do Timeout Dialog
        m_hwndTimeout = TaskUtil_HwndOnTimeout(m_rServer.szServerName, m_rServer.szAccount, "SMTP", m_rServer.dwTimeout, (ITimeoutCallback *) this);

        // Couldn't create the dialog
        if (NULL == m_hwndTimeout)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Always tell the transport to keep on trucking
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnLogonPrompt(LPINETSERVER pInetServer, IInternetTransport *pTransport)
{
    // Locals
    HRESULT hr=S_FALSE;
    SMTPAUTHTYPE authtype;
    char szPassword[CCHMAX_PASSWORD];

    // Check if we have a cached password that's different from current password
    hr = GetPassword(pInetServer->dwPort, pInetServer->szServerName, pInetServer->szUserName,
        szPassword, sizeof(szPassword));
    if (SUCCEEDED(hr) && 0 != lstrcmp(szPassword, pInetServer->szPassword))
    {
        lstrcpyn(pInetServer->szPassword, szPassword, sizeof(pInetServer->szPassword));
        return S_OK;
    }

    hr = S_FALSE; // Re-initialize

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // NOERRORS...
    if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
        goto exit;

    // TaskUtil_OnLogonPrompt
    hr = TaskUtil_OnLogonPrompt(m_pAccount, m_pUI, NULL, pInetServer, AP_SMTP_USERNAME,
                                AP_SMTP_PASSWORD, AP_SMTP_PROMPT_PASSWORD, FALSE);

    // Cache the password if the user slected ok
    if (S_OK == hr)
    {
        // Save the password
        SavePassword(pInetServer->dwPort, pInetServer->szServerName,
            pInetServer->szUserName, pInetServer->szPassword);

        // Lets switch the account to using the logon information...
        authtype = SMTP_AUTH_USE_SMTP_SETTINGS;
        m_pAccount->SetPropDw(AP_SMTP_USE_SICILY, (DWORD)authtype);

        // Save the changes
        m_pAccount->SaveChanges();
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CSmtpTask::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport)
{
    // Locals
    HWND        hwnd;
    INT         nAnswer;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Raid 55082 - SPOOLER: SPA/SSL auth to NNTP does not display cert warning and fails.
#if 0
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(0);
#endif
        
    // Invalid State
    Assert(m_pUI);

    // Get Window
    if (FAILED(m_pUI->GetWindow(&hwnd)))
        hwnd = NULL;

    // I assume this is a critical prompt, so I will not check for no UI mode
    nAnswer = MessageBox(hwnd, pszText, pszCaption, uType);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return nAnswer;
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnStatus(IXPSTATUS ixpstatus, IInternetTransport *pTransport)
{
    // Locals
    EVENTCOMPLETEDSTATUS tyEventStatus=EVENT_SUCCEEDED;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid State
    Assert(m_pUI && m_pSpoolCtx);

    // Feed the the IXP status to the UI object
    m_pUI->SetSpecificProgress(MAKEINTRESOURCE(XPUtil_StatusToString(ixpstatus)));

    // Disconnected
    if (ixpstatus == IXP_DISCONNECTED)
    {
        // Kill the timeout dialog
        if (m_hwndTimeout)
        {
            DestroyWindow(m_hwndTimeout);
            m_hwndTimeout = NULL;
        }

        // _OnDisconnectComplete
        HRESULT hrDisconnect = _OnDisconnectComplete();

        // Reset the progress
        // m_pUI->SetProgressRange(100);

        // Set the animation
        m_pUI->SetAnimation(idanOutbox, FALSE);

        // Determine 
        if (ISFLAGSET(m_dwState, SMTPSTATE_CANCELED))
            tyEventStatus = EVENT_CANCELED;
        else if (m_rTable.cCompleted == 0 && m_rTable.cEvents > 0)
            tyEventStatus = EVENT_FAILED;
        else if (m_rTable.cCompleted && m_rTable.cEvents && m_rTable.cCompleted < m_rTable.cEvents)
            tyEventStatus = EVENT_WARNINGS;
        else if (FAILED(hrDisconnect))
            tyEventStatus = EVENT_WARNINGS;

        // Result
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_RESULT, tyEventStatus);

        // Result
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_COMPLETE, 0);

        // Hands Off my callback
        if (m_pTransport)
            SideAssert(m_pTransport->HandsOffCallback() == S_OK);

        // This task is complete
        if (!ISFLAGSET(m_dwState, SMTPSTATE_EXECUTEFAILED))
            m_pSpoolCtx->EventDone(m_idEvent, tyEventStatus);
    }

    // Authorizing
    else if (ixpstatus == IXP_AUTHORIZING)
        m_pSpoolCtx->Notify(DELIVERY_NOTIFY_AUTHORIZING, 0);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnError(IXPSTATUS ixpstatus, LPIXPRESULT pResult, IInternetTransport *pTransport)
{
    INETSERVER  rServer;
    HRESULT     hrResult;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid State
    Assert(m_pUI);

    // Insert Error Into UI
    if (m_pTransport)
    {
        hrResult = pTransport->GetServerInfo(&rServer);
        if (FAILED(hrResult))
            CopyMemory(&rServer, &m_rServer, sizeof(rServer));
    }

    _CatchResult(pResult, &rServer, IXP_SMTP);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnCommand(CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport)
{
    // Logging
    if (m_pLogFile && pszLine)
    {
        // Response
        if (CMD_RESP == cmdtype)
            m_pLogFile->WriteLog(LOGFILE_RX, pszLine);

        // Send
        else if (CMD_SEND == cmdtype)
            m_pLogFile->WriteLog(LOGFILE_TX, pszLine);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_CatchResult
// --------------------------------------------------------------------------------
TASKRESULTTYPE CSmtpTask::_CatchResult(HRESULT hr, IXPTYPE ixpType)
{
    // Locals
    IXPRESULT   rResult;

    // Build an IXPRESULT
    ZeroMemory(&rResult, sizeof(IXPRESULT));
    rResult.hrResult = hr;

    // Get the SMTP Result Type
    return _CatchResult(&rResult, &m_rServer, ixpType);
}

// --------------------------------------------------------------------------------
// CSmtpTask::_CatchResult
// --------------------------------------------------------------------------------
TASKRESULTTYPE CSmtpTask::_CatchResult(LPIXPRESULT pResult, INETSERVER *pServer, IXPTYPE ixpType)
{
    // Locals
    HWND            hwndParent;
    TASKRESULTTYPE  tyTaskResult=TASKRESULT_FAILURE;
    LPSTR           pszSubject=NULL;

    // If Succeeded
    if (SUCCEEDED(pResult->hrResult))
        return TASKRESULT_SUCCESS;

    // Is there is a current event, get the subject
    if (m_rTable.prgEvent && m_rTable.prgEvent[m_rTable.iEvent].pMessage)
    {
        // Get the subject
        if (FAILED(MimeOleGetBodyPropA(m_rTable.prgEvent[m_rTable.iEvent].pMessage, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &pszSubject)))
            pszSubject = NULL;
    }

    // Get Window
    if (NULL == m_pUI || FAILED(m_pUI->GetWindow(&hwndParent)))
        hwndParent = NULL;

    // Process generic protocol errro
    tyTaskResult = TaskUtil_FBaseTransportError(ixpType, m_idEvent, pResult, pServer, pszSubject, m_pUI,
                                                !ISFLAGSET(m_dwFlags, DELIVER_NOUI), hwndParent);

    // Have a Transport
    if (m_pTransport)
    {
        // If Task Failure, drop the connection
        if (TASKRESULT_FAILURE == tyTaskResult)
        {
            // Roast the current connection
            m_pTransport->DropConnection();
        }

        // If Event Failure...
        else if (TASKRESULT_EVENTFAILED == tyTaskResult)
        {
            // Goto Next Event
            if (FAILED(_HrFinishCurrentEvent(pResult->hrResult)))
            {
                // Roast the current connection
                m_pTransport->DropConnection();
            }
        }
    }

    // Cleanup
    SafeMemFree(pszSubject);

    // Return Result
    return tyTaskResult;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_DoProgress
// --------------------------------------------------------------------------------
void CSmtpTask::_DoProgress(void)
{
    // Locals
    WORD            wProgress;
    WORD            wDelta;
    LPSMTPEVENTINFO pEvent;

    // Invalid Arg
    Assert(m_cbTotal > 0 && m_pUI);

    // Compute Current Progress Index
    wProgress = (WORD)((m_cbSent * 100) / m_cbTotal);

    // Compute Delta
    wDelta = wProgress - m_wProgress;

    // Progress Delta
    if (wDelta > 0)
    {
        // Incremenet Progress
        m_pUI->IncrementProgress(wDelta);

        // Increment my wProgress
        m_wProgress += wDelta;

        // Don't go over 100 percent
        Assert(m_wProgress <= 100);
    }
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnResponse(LPSMTPRESPONSE pResponse)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    if (pResponse)
    {
        // Handle the Error
        if (TASKRESULT_SUCCESS != _CatchResult(&pResponse->rIxpResult, &m_rServer, IXP_SMTP))
            goto exit;

        // Handle Command Type
        switch(pResponse->command)
        {
        case SMTP_CONNECTED:
            // CommandRSET
            _CatchResult(_HrOnConnected(), IXP_SMTP);

            // Done
            break;

        case SMTP_RSET:
            // Progress
            _DoProgress();

            // Send the current message
            _CatchResult(_HrStartCurrentEvent(), IXP_SMTP);

            // Done
            break;

        case SMTP_MAIL:
            // Reset the address enumerator
            Assert(m_pAdrEnum);
            m_pAdrEnum->Reset();

            // CommandRCPT
            _CatchResult(_HrCommandRCPT(), IXP_SMTP);

            // Done
            break;

        case SMTP_RCPT:
            // CommandRCPT -> CommandDATA
            _CatchResult(_HrCommandRCPT(), IXP_SMTP);

            // Done
            break;

        case SMTP_DATA:
            // Send the data stream
            _CatchResult(_HrSendDataStream(), IXP_SMTP);

            // Done
            break;

        case SMTP_SEND_STREAM:
            // Increment Current Progress
            _OnStreamProgress(&pResponse->rStreamInfo);

            // Done
            break;

        case SMTP_DOT:
            // Finish the Current Event
            _CatchResult(_HrFinishCurrentEvent(S_OK), IXP_SMTP);

            // Done
            break;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrOnConnected
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrOnConnected(void)
{
    // Locals
    CHAR        szRes[CCHMAX_RES];
    CHAR        szMsg[CCHMAX_RES+CCHMAX_RES];

    // Progress
    LOADSTRING(IDS_SPS_SMTPPROGGEN, szRes);
    wsprintf(szMsg, szRes, m_rServer.szAccount);

    // Set General Progress
    m_pUI->SetGeneralProgress(szMsg);

    // Progress
    _DoProgress();

    // Notify
    m_pSpoolCtx->Notify(DELIVERY_NOTIFY_SENDING, 0);

    // Send the current message
    _CatchResult(_HrStartCurrentEvent(), IXP_SMTP);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrStartCurrentEvent
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrStartCurrentEvent(void)
{
    // Locals
    HRESULT             hr=S_OK;
    LPSMTPEVENTINFO     pEvent;
    IMimeAddressTable  *pAddrTable=NULL;
    CHAR                szRes[CCHMAX_RES];
    CHAR                szMsg[CCHMAX_RES + CCHMAX_ACCOUNT_NAME];

    // Invalid Arg
    Assert(m_rTable.iEvent < m_rTable.cEvents);

    // Get the current event
    pEvent = CURRENTSMTPEVENT(m_rTable);

    // Is this a partial message
    if (ISFLAGSET(pEvent->dwFlags, SMTPEVENT_SPLITPART))
    {
        LOADSTRING(IDS_SPS_SMTPPROGRESS_SPLIT, szRes);
        wsprintf(szMsg, szRes, m_rTable.iEvent + 1, m_rTable.cEvents, pEvent->iPart, pEvent->cParts);
    }

    // Otherwise
    else
    {
        LOADSTRING(IDS_SPS_SMTPPROGRESS, szRes);
        wsprintf(szMsg, szRes, m_rTable.iEvent + 1, m_rTable.cEvents);
    }

    // Set Specific Progress
    m_pUI->SetSpecificProgress(szMsg);

    // If mail is coming from the outbox
    if (!ISFLAGSET(pEvent->dwFlags, SMTPEVENT_SPLITPART))
    {
        // Open Store Message
        if (FAILED(_HrOpenMessage(pEvent->idMessage, &pEvent->pMessage)))
        {
            hr = TrapError(SP_E_SMTP_CANTOPENMESSAGE);
            goto exit;
        }
    }

    // We better have a message object at this point
    else if (NULL == pEvent->pMessage)
    {
        Assert(FALSE);
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Catch Result
    CHECKHR(hr = _HrCommandMAIL());

exit:
    // Cleanup
    SafeRelease(pAddrTable);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CSmtpTask::_HrCommandMAIL
// ------------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrCommandMAIL(void)
{
    // Locals
    HRESULT             hr=S_OK;
    HRESULT             hrFind;
    IMimeAddressTable  *pAdrTable=NULL;
    ADDRESSPROPS        rAddress;
    ULONG               c;
    LPSMTPEVENTINFO     pEvent;

    // Get the current smtp event
    pEvent = CURRENTSMTPEVENT(m_rTable);

    // Init
    ZeroMemory(&rAddress, sizeof(ADDRESSPROPS));

    // Check State
    Assert(m_pTransport && pEvent->pMessage);

    // Release Current Enumerator
    SafeRelease(m_pAdrEnum);

    // Get the Sender...
    CHECKHR(hr = pEvent->pMessage->GetAddressTable(&pAdrTable));

    // Get Enumerator
    CHECKHR(hr = pAdrTable->EnumTypes(IAT_KNOWN, IAP_ADRTYPE | IAP_EMAIL, &m_pAdrEnum));

    // Loop Enumerator
    while (SUCCEEDED(m_pAdrEnum->Next(1, &rAddress, &c)) && c == 1)
    {
        // Not IAT_FROM
        if (NULL == rAddress.pszEmail || IAT_FROM != rAddress.dwAdrType)
        {
            g_pMoleAlloc->FreeAddressProps(&rAddress);
            continue;
        }

        // Send the command
        CHECKHR(hr = m_pTransport->CommandMAIL(rAddress.pszEmail));

        // Done
        goto exit;
    }

    // No Sender
    hr = TrapError(IXP_E_SMTP_NO_SENDER);

exit:
    // Cleanup
    SafeRelease(pAdrTable);
    g_pMoleAlloc->FreeAddressProps(&rAddress);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CSmtpTask::_HrCommandRCPT
// ------------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrCommandRCPT(void)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               dwAdrType;
    DWORD               c;
    LPSTR               pszEmail=NULL;
    ADDRESSPROPS        rAddress;
    LPSMTPEVENTINFO     pEvent;

    // Get the current smtp event
    pEvent = CURRENTSMTPEVENT(m_rTable);

    // Init
    ZeroMemory(&rAddress, sizeof(ADDRESSPROPS));

    // Check State
    Assert(m_pAdrEnum && m_pTransport && pEvent->pMessage);

    // Walk the enumerator for the next recipient
    while (SUCCEEDED(m_pAdrEnum->Next(1, &rAddress, &c)) && c == 1)
    {
        // Get Type
        if (rAddress.pszEmail && ISFLAGSET(IAT_RECIPS, rAddress.dwAdrType))
        {
            // Send the command
            CHECKHR(hr = m_pTransport->CommandRCPT(rAddress.pszEmail));

            // Count Recipients
            pEvent->cRecipients++;

            // Done
            goto exit;
        }

        // Release
        g_pMoleAlloc->FreeAddressProps(&rAddress);
    }

    // Release the Enumerator
    SafeRelease(m_pAdrEnum);

    // No Recipients
    if (0 == pEvent->cRecipients)
    {
        hr = TrapError(IXP_E_SMTP_NO_RECIPIENTS);
        goto exit;
    }

    // Send the Data Command
    CHECKHR(hr = m_pTransport->CommandDATA());

exit:
    // Cleanup
    g_pMoleAlloc->FreeAddressProps(&rAddress);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrSendDataStream
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrSendDataStream(void)
{
    // Locals
    HRESULT                 hr=S_OK;
    LPSTREAM                pStream=NULL;
    LPSTREAM                pStmActual;
    LPSTR                   pszBCC=NULL;
    LPSTR                   pszTo=NULL;
    LPSTR                   pszMessageId=NULL;
    LPSMTPEVENTINFO         pEvent;
    CMessageIdStream       *pStmWrapper=NULL;

    // Get the current smtp event
    pEvent = CURRENTSMTPEVENT(m_rTable);

    // Check State
    Assert(m_pTransport && pEvent->pMessage);

    // See if BCC is set
    if (SUCCEEDED(MimeOleGetBodyPropA(pEvent->pMessage, HBODY_ROOT, PIDTOSTR(PID_HDR_BCC), NOFLAGS, &pszBCC)))
    {
        // Locals
        LPSTR pszToAppend=NULL;

        // RAID-20750 - If the to line is not set, then we will set it to "Undisclosed Recipient"
        // or the SMTP gateways will put the BCC into the to line.
        if (FAILED(MimeOleGetBodyPropA(pEvent->pMessage, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, &pszTo)))
        {
            // Raid-9691: We were just putting <Undiscolsed Recipient>, which was an illegal email address (bad for Exchange Server)
            pszToAppend = "To: <Undisclosed-Recipient:;>\r\n";
        }

        // Raid-2705: If this fails, just get the message source
        if (FAILED(MimeOleStripHeaders(pEvent->pMessage, HBODY_ROOT, STR_HDR_BCC, pszToAppend, &pStream)))
        {
            // Get Message Stream
            CHECKHR(hr = pEvent->pMessage->GetMessageSource(&pStream, 0));
        }
    }

    // Otherwise, just get the message source
    else
    {
        // Get Message Stream
        CHECKHR(hr = pEvent->pMessage->GetMessageSource(&pStream, 0));
    }

    // Lets see if the message has a message-id already
    if (FAILED(MimeOleGetBodyPropA(pEvent->pMessage, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &pszMessageId)))
    {
        // Create a wrapper for this stream that will output the messageid
        CHECKALLOC(pStmWrapper = new CMessageIdStream(pStream));

        // Adjust pEvent->cbEvent
        pEvent->cbEvent += pStmWrapper->CchMessageId();

        // Increment total
        m_cbTotal += pStmWrapper->CchMessageId();

        // Increment pEvent->cbSentTotal
        pEvent->cbSentTotal += pStmWrapper->CchMessageId();

        // Reset pStream
        pStmActual = (IStream *)pStmWrapper;
    }
    else
        pStmActual = pStream;

    // Send the stream
    CHECKHR(hr = m_pTransport->SendDataStream(pStmActual, pEvent->cbEvent));

exit:
    // Cleanup
    SafeRelease(pStream);
    SafeRelease(pStmWrapper);
    SafeMemFree(pszBCC);
    SafeMemFree(pszTo);
    SafeMemFree(pszMessageId);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_OnStreamProgress
// --------------------------------------------------------------------------------
void CSmtpTask::_OnStreamProgress(LPSMTPSTREAM pInfo)
{
    // Locals
    LPSMTPEVENTINFO     pEvent;

    // Get the current smtp event
    pEvent = CURRENTSMTPEVENT(m_rTable);

    // Increment Status
    pEvent->cbEventSent += pInfo->cbIncrement;
    Assert(pEvent->cbEventSent == pInfo->cbCurrent);

    // Increment total sent
    m_cbSent += pInfo->cbIncrement;

    // Do Progress
    _DoProgress();
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrFinishCurrentEvent
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrFinishCurrentEvent(HRESULT hrResult)
{
    // Locals
    HRESULT             hr=S_OK;
    LPSMTPEVENTINFO     pEvent;

    // Get the current smtp event
    pEvent = CURRENTSMTPEVENT(m_rTable);

    // Save the Event Result
    pEvent->hrResult = hrResult;

    // If the Event Failed...
    if (FAILED(pEvent->hrResult))
    {
        // If this message was part of a split group, skip all pars in this group
        if (ISFLAGSET(pEvent->dwFlags, SMTPEVENT_SPLITPART))
        {
            // Compute Next Event
            ULONG iNextEvent = m_rTable.iEvent + (pEvent->cParts - pEvent->iPart) + 1;

            // Increment to last part
            while(m_rTable.iEvent < iNextEvent && m_rTable.iEvent < m_rTable.cEvents)
            {
                // Goto next event
                m_rTable.iEvent++;

                // Fail this event
                _CatchResult(SP_E_SENDINGSPLITGROUP, IXP_SMTP);

                // Fixup m_cbSent to be correct
                m_cbSent = m_rTable.prgEvent[m_rTable.iEvent].cbSentTotal;

                // Update progress
                _DoProgress();
            }
        }
    }

    // Otherwise
    else
    {
        // Mark the event as complete
        FLAGSET(pEvent->dwFlags, SMTPEVENT_COMPLETE);

        // Increment number of completed events
        m_rTable.cCompleted++;
    }

    // Go to next message
    CHECKHR(hr = _HrStartNextEvent());

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_HrStartNextEvent
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_HrStartNextEvent(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Fixup m_cbSent to be correct
    m_cbSent = m_rTable.prgEvent[m_rTable.iEvent].cbSentTotal;

    // Are we done yet ?
    if (m_rTable.iEvent + 1 == m_rTable.cEvents)
    {
        // Update progress
        _DoProgress();

        // Disconnect from the server
        CHECKHR(hr = m_pTransport->Disconnect());
    }

    // Oterhwise, Increment Event and send rset
    else
    {
        // Next Event
        m_rTable.iEvent++;

        // Update progress
        _DoProgress();

        // Send Reset Command
        CHECKHR(hr = m_pTransport->CommandRSET());
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::_OnDisconnectComplete
// --------------------------------------------------------------------------------
HRESULT CSmtpTask::_OnDisconnectComplete(void)
{
    // Locals
    HRESULT             hr=S_OK;
    PDWORD_PTR          prgdwIds=NULL;
    DWORD               cIds=0;
    DWORD               cIdsAlloc=0;
    DWORD               i;
    LPSMTPEVENTINFO     pEvent;
    ADJUSTFLAGS         Flags;

    // Invalid State
    Assert(m_pOutbox);

    // Walk through the list of events
    for (i=0; i<m_rTable.cEvents; i++)
    {
        // Readability
        pEvent = &m_rTable.prgEvent[i];

        // If this event was in the outbox
        if (0 != pEvent->idMessage && ISFLAGSET(pEvent->dwFlags, SMTPEVENT_COMPLETE))
        {
            // Insert into my array of message ids
            if (cIds + 1 > cIdsAlloc)
            {
                // Realloc
                CHECKHR(hr = HrRealloc((LPVOID *)&prgdwIds, sizeof(DWORD) * (cIdsAlloc + 10)));

                // Increment cIdsAlloc
                cIdsAlloc += 10;
            }

            // Set Message Id
            prgdwIds[cIds++] = (DWORD_PTR)pEvent->idMessage;
        }
    }

    // Setup List
    m_rList.cMsgs = cIds;
    m_rList.prgidMsg = (LPMESSAGEID)prgdwIds;
    prgdwIds = NULL;

    if (m_rList.cMsgs)
    {
        Flags.dwAdd = ARF_READ;
        Flags.dwRemove = ARF_SUBMITTED | ARF_UNSENT;

        if (m_idEventUpload == INVALID_EVENT)
        {
            if (DwGetOption(OPT_SAVESENTMSGS))
            {
                Assert(m_pSentItems != NULL);

                // Move the message from the sent items folder
                CHECKHR(hr = m_pOutbox->CopyMessages(m_pSentItems, COPY_MESSAGE_MOVE, &m_rList, &Flags, NULL, NOSTORECALLBACK));
            }
            else
            {
                // Delete the messages
                CHECKHR(hr = m_pOutbox->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &m_rList, NULL, NOSTORECALLBACK));
            }
        }
        else
        {
            // Raid-7639: OE sends message over and over when runs out of disk space.
            m_pOutbox->SetMessageFlags(&m_rList, &Flags, NULL, NOSTORECALLBACK);
        }
    }

exit:
    // Cleanup
    SafeMemFree(prgdwIds);

    // Done
    return hr;
}


// --------------------------------------------------------------------------------
// CSmtpTask::Cancel
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::Cancel(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Cancelled
    FLAGSET(m_dwState, SMTPSTATE_CANCELED);

    // Simply drop the connection
    if (m_pTransport)
        m_pTransport->DropConnection();

    if (m_pCancel != NULL)
        m_pCancel->Cancel(CT_ABORT);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnTimeoutResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Should have a handle to the timeout window
    Assert(m_hwndTimeout);

    // No timeout window handle
    m_hwndTimeout = NULL;

    // Stop ?
    if (TIMEOUT_RESPONSE_STOP == eResponse)
    {
        // Cancelled
        FLAGSET(m_dwState, SMTPSTATE_CANCELED);

        // Report error and drop connection
        _CatchResult(IXP_E_TIMEOUT, IXP_SMTP);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSmtpTask::IsDialogMessage
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::IsDialogMessage(LPMSG pMsg)
{
    HRESULT hr=S_FALSE;
    EnterCriticalSection(&m_cs);
    if (m_hwndTimeout && IsWindow(m_hwndTimeout))
        hr = (TRUE == ::IsDialogMessage(m_hwndTimeout, pMsg)) ? S_OK : S_FALSE;
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CSmtpTask::OnFlagsChanged
// --------------------------------------------------------------------------------
STDMETHODIMP CSmtpTask::OnFlagsChanged(DWORD dwFlags)
    {
    EnterCriticalSection(&m_cs);
    m_dwFlags = dwFlags;
    LeaveCriticalSection(&m_cs);

    return (S_OK);
    }

STDMETHODIMP CSmtpTask::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    char szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];

    // Hold onto this
    Assert(m_tyOperation == SOT_INVALID);

    if (pCancel)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }
    m_tyOperation = tyOperation;

    // Set the animation
    m_pUI->SetAnimation(idanOutbox, TRUE);

    // Setup Progress Meter
    m_pUI->SetProgressRange(100);

    m_wProgress = 0;

    LOADSTRING(IDS_SPS_MOVEPROGRESS, szRes);
    wsprintf(szBuf, szRes, 1, m_rList.cMsgs);

    m_pUI->SetSpecificProgress(szBuf);

    // Party On
    return(S_OK);
}

STDMETHODIMP CSmtpTask::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    char szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    WORD wProgress, wDelta;

    // NOTE: that you can get more than one type of value for tyOperation.
    //       Most likely, you will get SOT_CONNECTION_STATUS and then the
    //       operation that you might expect. See HotStore.idl and look for
    //       the STOREOPERATION enumeration type for more info.
 
    if (tyOperation == SOT_CONNECTION_STATUS)
    {
        // Connecting to ...
        LoadString(g_hLocRes, idsInetMailConnectingHost, szRes, ARRAYSIZE(szRes));
        wsprintf(szBuf, szRes, m_rServer.szAccount);
        m_pUI->SetGeneralProgress(szBuf);
    }
    else if (tyOperation == SOT_COPYMOVE_MESSAGE)
    {
        // Compute Current Progress Index
        wProgress = (WORD)((dwCurrent * 100) / dwMax);

        // Compute Delta
        wDelta = wProgress - m_wProgress;

        // Progress Delta
        if (wDelta > 0)
        {
            // Incremenet Progress
            m_pUI->IncrementProgress(wDelta);

            // Increment my wProgress
            m_wProgress += wDelta;

            // Don't go over 100 percent
            Assert(m_wProgress <= 100);
        }

        if (dwCurrent < dwMax)
        {
            LOADSTRING(IDS_SPS_MOVEPROGRESS, szRes);
            wsprintf(szBuf, szRes, dwCurrent + 1, dwMax);

            // Set Specific Progress
            m_pUI->SetSpecificProgress(szBuf);
        }
    }

    // Done
    return(S_OK);
}

STDMETHODIMP CSmtpTask::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    // Is there currently a timeout dialog
    if (m_hwndTimeout)
    {
        // Set foreground
        SetForegroundWindow(m_hwndTimeout);
    }
    else
    {
        LPCSTR pszProtocol;

        // Not suppose to be showing UI ?
        if (ISFLAGSET(m_dwFlags, DELIVER_NOUI))
            return(S_FALSE);

        // Do Timeout Dialog
        GetProtocolString(&pszProtocol, ixpServerType);
        if (pServer)
        {
            m_hwndTimeout = TaskUtil_HwndOnTimeout(pServer->szServerName, pServer->szAccount,
                pszProtocol, pServer->dwTimeout, (ITimeoutCallback *) this);

            // Couldn't create the dialog
            if (NULL == m_hwndTimeout)
                return(S_FALSE);
        }
    }

    return(S_OK);
}

STDMETHODIMP CSmtpTask::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND hwnd;
    BOOL fPrompt = TRUE;

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into general CanConnect Utility
    if ((m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)) || (dwFlags & CC_FLAG_DONTPROMPT))
        fPrompt = FALSE;

    return CallbackCanConnect(pszAccountId, hwnd, fPrompt);
}

STDMETHODIMP CSmtpTask::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    HWND hwnd;

    if (m_hwndTimeout)
    {
        DestroyWindow(m_hwndTimeout);
        m_hwndTimeout = NULL;
    }

    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(hwnd, pServer, ixpServerType);
}

STDMETHODIMP CSmtpTask::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete,
                                   LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    HRESULT hr;
    char szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES * 2], szSubject[64];
    EVENTCOMPLETEDSTATUS tyEventStatus;

    if (m_hwndTimeout)
    {
        DestroyWindow(m_hwndTimeout);
        m_hwndTimeout = NULL;
    }

    IxpAssert(m_tyOperation != SOT_INVALID);
    if (m_tyOperation != tyOperation)
        return(S_OK);

    Assert(tyOperation == SOT_COPYMOVE_MESSAGE);

    // Figure out if we succeeded or failed
    if (FAILED(hrComplete))
    {
        Assert(m_pUI);

        if (NULL != pErrorInfo)
        {
            IXPRESULT   ixpResult;
            INETSERVER  rServer;
            char        szProblem[CCHMAX_STRINGRES];
            int         iLen;

            // Prepend sent items text error text to supplied problem
            Assert(tyOperation == SOT_COPYMOVE_MESSAGE);
            iLen = LoadString(g_hLocRes, IDS_SP_E_CANT_MOVETO_SENTITEMS, szProblem, sizeof(szProblem));
            if (iLen < sizeof(szProblem) - 1)
            {
                szProblem[iLen] = ' ';
                iLen += 1;
                szProblem[iLen] = '\0';
            }
            if (NULL != pErrorInfo->pszProblem)
                lstrcpyn(szProblem + iLen, pErrorInfo->pszProblem, sizeof(szProblem) - iLen);

            TaskUtil_SplitStoreError(&ixpResult, &rServer, pErrorInfo);
            ixpResult.pszProblem = szProblem;

            _CatchResult(&ixpResult, &rServer, pErrorInfo->ixpType);
        }
        else
        {
            // Remap the Error Result
            hr = TrapError(SP_E_CANT_MOVETO_SENTITEMS);

            // Show an error in the spooler dialog
            _CatchResult(hr, IXP_IMAP); // Without a STOREERROR, we just have to guess
        }
    }

    m_pUI->SetAnimation(idanOutbox, FALSE);

    if (ISFLAGSET(m_dwState, SMTPSTATE_CANCELED))
        tyEventStatus = EVENT_CANCELED;
    else if (SUCCEEDED(hrComplete))
        tyEventStatus = EVENT_SUCCEEDED;
    else
        tyEventStatus = EVENT_FAILED;

    // Result
    m_pSpoolCtx->Notify(DELIVERY_NOTIFY_RESULT, tyEventStatus);

    // Result
    m_pSpoolCtx->Notify(DELIVERY_NOTIFY_COMPLETE, 0);

    m_pSpoolCtx->EventDone(m_idEventUpload, tyEventStatus);

    // Release your cancel object
    SafeRelease(m_pCancel);
    m_tyOperation = SOT_INVALID;

    // Done
    return(S_OK);
}

STDMETHODIMP CSmtpTask::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    HWND hwnd;

    // Close any timeout dialog, if present
    if (m_hwndTimeout)
    {
        DestroyWindow(m_hwndTimeout);
        m_hwndTimeout = NULL;
    }

    // Raid 55082 - SPOOLER: SPA/SSL auth to NNTP does not display cert warning and fails.
#if 0
    if (!!(m_dwFlags & (DELIVER_NOUI | DELIVER_BACKGROUND)))
        return(E_FAIL);
#endif

    if (m_pUI)
        m_pUI->GetWindow(&hwnd);
    else
        hwnd = NULL;

    // Call into my swanky utility
    return CallbackOnPrompt(hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\spoolapi.h ===
// ---------------------------------------------------------------------------------------
// Spoolapi.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// ---------------------------------------------------------------------------------------
#ifndef __SPOOLAPI_H
#define __SPOOLAPI_H

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
extern BOOL g_fCheckOutboxOnShutdown;

// ---------------------------------------------------------------------------------------
// Forward Decls
// ---------------------------------------------------------------------------------------
interface ISpoolerEngine;
interface ISpoolerBindContext;
interface ISpoolerTask;
interface ISpoolerUI;
interface IImnAccount;

#include "error.h"  // This get's the ATH_HR_x() macros
               

// ---------------------------------------------------------------------------------------
// Errors
// ---------------------------------------------------------------------------------------
#define SP_HR_FIRST 0x2000
#define SP_E_ALREADYINITIALIZED                         ATH_HR_E(SP_HR_FIRST + 1)
#define SP_E_UNINITIALIZED                              ATH_HR_E(SP_HR_FIRST + 2)
#define SP_E_EVENTNOTFOUND                              ATH_HR_E(SP_HR_FIRST + 3)
#define SP_E_EXECUTING                                  ATH_HR_E(SP_HR_FIRST + 4)
#define SP_E_CANNOTCONNECT                              ATH_HR_E(SP_HR_FIRST + 5)
#define SP_E_HTTP_NOSENDMSGURL                          ATH_HR_E(SP_HR_FIRST + 6)
#define SP_E_HTTP_SERVICEDOESNTWORK                     ATH_HR_E(SP_HR_FIRST + 7)
#define SP_E_HTTP_NODELETESUPPORT                       ATH_HR_E(SP_HR_FIRST + 8)
#define SP_E_HTTP_CANTMODIFYMSNFOLDER                   ATH_HR_E(SP_HR_FIRST + 9)

// ---------------------------------------------------------------------------------------
// SMTP Task Errors
// ---------------------------------------------------------------------------------------
#define SP_E_SMTP_CANTOPENMESSAGE                       ATH_HR_E(SP_HR_FIRST + 200)
#define SP_E_SENDINGSPLITGROUP                          ATH_HR_E(SP_HR_FIRST + 202)
#define SP_E_CANTLEAVEONSERVER                          ATH_HR_E(SP_HR_FIRST + 203)
#define SP_E_CANTLOCKUIDLCACHE                          ATH_HR_E(SP_HR_FIRST + 204)
#define SP_E_POP3_RETR                                  ATH_HR_E(SP_HR_FIRST + 205)
#define SP_E_CANT_MOVETO_SENTITEMS                      ATH_HR_E(SP_HR_FIRST + 206)

// ---------------------------------------------------------------------------------------
// Spooler Types
// ---------------------------------------------------------------------------------------
typedef DWORD EVENTID;
typedef LPDWORD LPEVENTID;

// ---------------------------------------------------------------------------------------
// Spooler Delivery Types
// ---------------------------------------------------------------------------------------

// Common delivery flags
#define DELIVER_COMMON_MASK              0x000000FF
#define DELIVER_BACKGROUND               0x00000001   // No progress UI, but will show errors at the end if DELIVER_NOUI not specified
#define DELIVER_NOUI                     0x00000002   // No UI at all.  Errors are silently ignored.
#define DELIVER_NODIAL                   0x00000004   // Not allowed to change the current connection
#define DELIVER_POLL                     0x00000008   // Poll for new messages
#define DELIVER_QUEUE                    0x00000010   // A request was made while busy
#define DELIVER_SHOW                     0x00000020   // Simply show the spooler UI
#define DELIVER_REFRESH                  0x00000040   // Simply refresh based on background, noui
#define DELIVER_DIAL_ALWAYS              0x00000080

// Mail delivery flags
#define DELIVER_MAIL_MASK                0x0000FF00
#define DELIVER_SEND                     0x00000100
#define DELIVER_MAIL_RECV                0x00000200
#define DELIVER_MAIL_NOSKIP              0x00000400
#define DELIVER_MAIL_SENDRECV            (DELIVER_SEND | DELIVER_MAIL_RECV | DELIVER_IMAP_TYPE \
                                          | DELIVER_HTTP_TYPE | DELIVER_SMTP_TYPE)

//Flag to distinguish between Send&Receive and synchronize
#define DELIVER_OFFLINE_SYNC             0x00000800               

//Flag to distinguish between Send&Receive triggered by timer and Send&Receive invoked by the user
//We need to distinguish these because we hangup the phone in the first case, if we dialed
#define DELIVER_AT_INTERVALS             0x00001000               
#define DELIVER_OFFLINE_HEADERS          0x00002000
#define DELIVER_OFFLINE_NEW              0x00004000
#define DELIVER_OFFLINE_ALL              0x00008000
#define DELIVER_OFFLINE_MARKED           0x00010000
#define DELIVER_NOSKIP                   0x00020000
#define DELIVER_NO_NEWSPOLL              0x00040000
#define DELIVER_WATCH                    0x00080000

//The first three bits are reserved for Server Types
#define DELIVER_NEWS_TYPE                0x00100000
#define DELIVER_IMAP_TYPE                0x00200000
#define DELIVER_HTTP_TYPE                0x00400000
#define DELIVER_SMTP_TYPE                0x00800000


#define DELIVER_MAIL_SEND                (DELIVER_SEND | DELIVER_SMTP_TYPE | DELIVER_HTTP_TYPE)
#define DELIVER_NEWS_SEND                (DELIVER_SEND | DELIVER_NEWS_TYPE)

#define DELIVER_SERVER_TYPE_MASK         0x00F00000
#define DELIVER_SERVER_TYPE_ALL          0x00F00000

#define DELIVER_OFFLINE_FLAGS            (DELIVER_OFFLINE_HEADERS | DELIVER_OFFLINE_NEW | \
                                          DELIVER_OFFLINE_ALL | DELIVER_OFFLINE_MARKED)

#define DELIVER_IMAP_MASK                (DELIVER_IMAP_TYPE | DELIVER_OFFLINE_FLAGS)
#define DELIVER_NEWS_MASK                (DELIVER_NEWS_TYPE | DELIVER_OFFLINE_FLAGS)

/*
// News delivery flags
#define DELIVER_NEWS_MASK                0x007F0000
#define DELIVER_NEWS_SEND                0x00010000

// IMAP delivery flags
#define DELIVER_IMAP_MASK                0x007E0000


// Combined News and IMAP delivery flags
#define DELIVER_NEWSIMAP_OFFLINE         0x00020000 // General offline for server, when "Sync Now" button in AcctView pushed
#define DELIVER_NEWSIMAP_OFFLINE_HEADERS 0x00040000
#define DELIVER_NEWSIMAP_OFFLINE_NEW     0x00080000
#define DELIVER_NEWSIMAP_OFFLINE_ALL     0x00100000
#define DELIVER_NEWSIMAP_OFFLINE_MARKED  0x00200000
#define DELIVER_NEWSIMAP_OFFLINE_FLAGS   (DELIVER_NEWSIMAP_OFFLINE_HEADERS | DELIVER_NEWSIMAP_OFFLINE_NEW | DELIVER_NEWSIMAP_OFFLINE_ALL | DELIVER_NEWSIMAP_OFFLINE_MARKED)
#define DELIVER_NEWSIMAP_NOSKIP          0x00400000
*/


// Combinations
#define DELIVER_BACKGROUND_POLL         (DELIVER_NODIAL | DELIVER_BACKGROUND | DELIVER_NOUI | DELIVER_POLL | DELIVER_WATCH | \
                                         DELIVER_MAIL_RECV | DELIVER_SEND | DELIVER_SERVER_TYPE_ALL)

#define DELIVER_BACKGROUND_POLL_DIAL    (DELIVER_BACKGROUND | DELIVER_NOUI | DELIVER_POLL | DELIVER_WATCH | \
                                         DELIVER_MAIL_RECV | DELIVER_SEND | DELIVER_SERVER_TYPE_ALL)

#define DELIVER_BACKGROUND_POLL_DIAL_ALWAYS (DELIVER_DIAL_ALWAYS | DELIVER_BACKGROUND | DELIVER_NOUI | DELIVER_POLL | DELIVER_WATCH | \
                                             DELIVER_MAIL_RECV | DELIVER_SEND | DELIVER_SERVER_TYPE_ALL)

#define DELIVER_UPDATE_ALL              (DELIVER_MAIL_RECV | DELIVER_SEND | DELIVER_POLL | DELIVER_WATCH | \
                                         DELIVER_OFFLINE_FLAGS | DELIVER_SERVER_TYPE_ALL)

// ---------------------------------------------------------------------------------------
// Event completion types
// ---------------------------------------------------------------------------------------
typedef enum tagEVENTCOMPLETEDSTATUS {
    EVENT_SUCCEEDED,
    EVENT_WARNINGS,
    EVENT_FAILED,
    EVENT_CANCELED
} EVENTCOMPLETEDSTATUS;

// ------------------------------------------------------------------------------------
// DELIVERYNOTIFYTYPE
// ------------------------------------------------------------------------------------
typedef enum tagDELIVERYNOTIFYTYPE {
    DELIVERY_NOTIFY_STARTING,       // Sent by spengine when a delivery cycle starts
    DELIVERY_NOTIFY_CONNECTING,
    DELIVERY_NOTIFY_SECURE,
    DELIVERY_NOTIFY_UNSECURE,
    DELIVERY_NOTIFY_AUTHORIZING,
    DELIVERY_NOTIFY_CHECKING,
    DELIVERY_NOTIFY_CHECKING_NEWS,
    DELIVERY_NOTIFY_SENDING,
    DELIVERY_NOTIFY_SENDING_NEWS,
    DELIVERY_NOTIFY_RECEIVING,
    DELIVERY_NOTIFY_RECEIVING_NEWS,
    DELIVERY_NOTIFY_COMPLETE,       // lParam == n new messages
    DELIVERY_NOTIFY_RESULT,         // lParam == EVENTCOMPLETEDSTATUS
    DELIVERY_NOTIFY_ALLDONE         // Sent by spengine when all tasks have completed
} DELIVERYNOTIFYTYPE;

// ------------------------------------------------------------------------------------
// TRAYICONTYPE
// ------------------------------------------------------------------------------------
typedef enum tagTRAYICONTYPE {
    TRAYICON_ADD,
    TRAYICON_REMOVE
} TRAYICONTYPE;

// ---------------------------------------------------------------------------------------
// IID_ISpoolerEngine
// ---------------------------------------------------------------------------------------
DECLARE_INTERFACE_(ISpoolerEngine, IUnknown)
{
    // -----------------------------------------------------------------------------------
    // IUnknown members
    // -----------------------------------------------------------------------------------
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // -----------------------------------------------------------------------------------
    // ISpooerEngine members
    // -----------------------------------------------------------------------------------
    STDMETHOD(Init)(THIS_ ISpoolerUI *pUI, BOOL fPoll) PURE;
    STDMETHOD(StartDelivery)(THIS_ HWND hwnd, LPCSTR pszAcctID, FOLDERID idFolder, DWORD dwFlags) PURE;
    STDMETHOD(Close)(THIS) PURE;
    STDMETHOD(Advise)(THIS_ HWND hwndView, BOOL fRegister) PURE;
    STDMETHOD(GetThreadInfo)(THIS_ LPDWORD pdwThreadId, HTHREAD* phThread) PURE;
    STDMETHOD(UpdateTrayIcon)(THIS_ TRAYICONTYPE type) PURE;
    STDMETHOD(IsDialogMessage)(THIS_ LPMSG pMsg) PURE;
    STDMETHOD(OnStartupFinished)(THIS) PURE;
};

// ---------------------------------------------------------------------------------------
// IID_ISpoolerBindContext
// ---------------------------------------------------------------------------------------
DECLARE_INTERFACE_(ISpoolerBindContext, IUnknown)
{
    // -----------------------------------------------------------------------------------
    // IUnknown members
    // -----------------------------------------------------------------------------------
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // -----------------------------------------------------------------------------------
    // ISpoolerBindContext members
    // -----------------------------------------------------------------------------------
    STDMETHOD(UpdateTrayIcon)(THIS_ TRAYICONTYPE type) PURE;
    STDMETHOD(RegisterEvent)(THIS_ LPCSTR pszDescription, ISpoolerTask *pTask, DWORD_PTR dwTwinkie, IImnAccount *pAccount, LPEVENTID peid) PURE;
    STDMETHOD(EventDone)(THIS_ EVENTID eid, EVENTCOMPLETEDSTATUS status) PURE;
    STDMETHOD(BindToObject)(THIS_ REFIID riid, LPVOID *ppvObject) PURE;
    STDMETHOD(TaskFromEventId)(THIS_ EVENTID eid, ISpoolerTask *ppTask) PURE;
    STDMETHOD(OnWindowMessage)(THIS_ HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD(Cancel)(THIS) PURE;
    STDMETHOD(Notify)(THIS_ DELIVERYNOTIFYTYPE notify, LPARAM lParam) PURE;
    STDMETHOD(PumpMessages)(THIS) PURE;
    STDMETHOD(UIShutdown)(THIS) PURE;
    STDMETHOD(OnUIChange)(THIS_ BOOL fVisible) PURE;
    STDMETHOD_(LRESULT, QueryEndSession)(THIS_ WPARAM wParam, LPARAM lParam) PURE;
};

// ---------------------------------------------------------------------------------------
// IID_ISpoolerTask
// ---------------------------------------------------------------------------------------
DECLARE_INTERFACE_(ISpoolerTask, IUnknown)
{
    // -----------------------------------------------------------------------------------
    // IUnknown members
    // -----------------------------------------------------------------------------------
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // -----------------------------------------------------------------------------------
    // ISpoolerTask members
    // -----------------------------------------------------------------------------------
    STDMETHOD(Init)(THIS_ DWORD dwFlags, ISpoolerBindContext *pBindCtx) PURE;
    STDMETHOD(BuildEvents)(THIS_ ISpoolerUI *pSpoolerUI, IImnAccount *pAccount, FOLDERID idFolder) PURE;
    STDMETHOD(Execute)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie) PURE;
    STDMETHOD(CancelEvent)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie) PURE;
    STDMETHOD(ShowProperties)(THIS_ HWND hwndParent, EVENTID eid, DWORD_PTR dwTwinkie) PURE;
    STDMETHOD(GetExtendedDetails)(THIS_ EVENTID eid, DWORD_PTR dwTwinkie, LPSTR *ppszDetails) PURE; 
    STDMETHOD(Cancel)(THIS) PURE;
    STDMETHOD(IsDialogMessage)(THIS_ LPMSG pMsg) PURE;
    STDMETHOD(OnFlagsChanged)(THIS_ DWORD dwFlags) PURE;
};

// ---------------------------------------------------------------------------------------
// IID_ISpoolerUI
// ---------------------------------------------------------------------------------------
DECLARE_INTERFACE_(ISpoolerUI, IUnknown)
{
    // -----------------------------------------------------------------------------------
    // IUnknown members
    // -----------------------------------------------------------------------------------
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // -----------------------------------------------------------------------------------
    // ISpoolerUI members
    // -----------------------------------------------------------------------------------
    STDMETHOD(Init)(THIS_ HWND hwndParent) PURE;
    STDMETHOD(RegisterBindContext)(THIS_ ISpoolerBindContext *pBindCtx) PURE;
    STDMETHOD(InsertEvent)(THIS_ EVENTID eid, LPCSTR pszDescription, LPCWSTR pszConnection) PURE;
    STDMETHOD(InsertError)(THIS_ EVENTID eid, LPCSTR pszError) PURE;
    STDMETHOD(UpdateEventState)(THIS_ EVENTID eid, INT nIcon, LPCSTR pszDescription, LPCSTR pszStatus) PURE;
    STDMETHOD(SetProgressRange)(THIS_ WORD wMax) PURE;
    STDMETHOD(SetProgressPosition)(WORD wPos) PURE;
    STDMETHOD(IncrementProgress)(THIS_ WORD  wDelta) PURE;
    STDMETHOD(SetGeneralProgress)(THIS_ LPCSTR pszProgress) PURE;
    STDMETHOD(SetSpecificProgress)(THIS_ LPCSTR pszProgress) PURE;
    STDMETHOD(SetAnimation)(THIS_ INT nAnimationID, BOOL fPlay) PURE;
    STDMETHOD(EnsureVisible)(THIS_ EVENTID eid) PURE;
    STDMETHOD(ShowWindow)(THIS_ INT nCmdShow) PURE;
    STDMETHOD(GetWindow)(THIS_ HWND *pHwnd) PURE;
    STDMETHOD(StartDelivery)(THIS) PURE;            
    STDMETHOD(GoIdle)(THIS_ BOOL fErrors, BOOL fShutdown, BOOL fNoSync) PURE;
    STDMETHOD(ClearEvents)(THIS) PURE;
    STDMETHOD(SetTaskCounts)(THIS_ DWORD cSucceeded, DWORD cTotal) PURE;
    STDMETHOD(IsDialogMessage)(THIS_ LPMSG pMsg) PURE;
    STDMETHOD(Close)(THIS) PURE;
    STDMETHOD(ChangeHangupOption)(THIS_ BOOL fEnable, DWORD dwOption) PURE;
    STDMETHOD(AreThereErrors)(THIS) PURE;
    STDMETHOD(Shutdown)(THIS) PURE;
};

// ------------------------------------------------------------------------------------
// Exported C Functions
// ------------------------------------------------------------------------------------
#ifdef __cplusplus
extern "C" {
#endif

typedef HRESULT (APIENTRY *PFNCREATESPOOLERUI)(ISpoolerUI **ppSpoolerUI);

HRESULT CreateThreadedSpooler(
        /* in */     PFNCREATESPOOLERUI       pfnCreateUI,
        /* out */    ISpoolerEngine         **ppSpooler,
        /* in */     BOOL                     fPoll);

HRESULT CloseThreadedSpooler(
        /* in */     ISpoolerEngine *pSpooler);

#ifdef __cplusplus
}
#endif

#endif // __SPOOLAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\spengine.cpp ===
// --------------------------------------------------------------------------------
// Spengine.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "spengine.h"
#include "strconst.h"
#include "spoolui.h"
#include "thormsgs.h"
#include "newstask.h"
#include "goptions.h"
#include "conman.h"
#include "resource.h"
#include "ontask.h"
#include "smtptask.h"
#include "pop3task.h"
#include "instance.h"
#include "shlwapip.h" 
#include "ourguid.h"
#include "demand.h"
#include "storutil.h"
#include "msgfldr.h"
#include "httptask.h"
#include "watchtsk.h"
#include "shared.h"
#include "util.h"

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
BOOL g_fCheckOutboxOnShutdown=FALSE;

extern HANDLE  hSmapiEvent;     // Added for Bug# 62129 (v-snatar)

// --------------------------------------------------------------------------------
// ISSPOOLERTHREAD
// --------------------------------------------------------------------------------
#define ISSPOOLERTHREAD \
    (m_dwThreadId == GetCurrentThreadId())

// --------------------------------------------------------------------------------
// CSpoolerEngine::CSpoolerEngine
// --------------------------------------------------------------------------------
CSpoolerEngine::CSpoolerEngine(void)
    {
    m_cRef = 1;
    m_pUI = NULL;
    m_dwState = 0;
    m_dwFlags = 0;
    m_dwQueued = 0;
    m_pAcctMan = NULL;
    m_pUidlCache = NULL;
    m_hwndUI = NULL;
    m_pszAcctID = NULL;
    m_idFolder = FOLDERID_INVALID;
    m_dwThreadId = GetCurrentThreadId();
    m_hThread = GetCurrentThread();
    ZeroMemory(&m_rViewRegister, sizeof(VIEWREGISTER));
    ZeroMemory(&m_rEventTable, sizeof(SPOOLEREVENTTABLE));
    m_fBackgroundPollPending = FALSE;
    m_dwPollInterval = 0;
    m_cCurEvent = FALSE;
    m_hwndTray = NULL;
    m_fRasSpooled = FALSE;
    m_fOfflineWhenDone = FALSE;
    m_pPop3LogFile = NULL;
    m_pSmtpLogFile = NULL;
    m_fIDialed = FALSE;
    m_cSyncEvent = 0;
    m_fNoSyncEvent = FALSE;
    InitializeCriticalSection(&m_cs);
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::~CSpoolerEngine
// --------------------------------------------------------------------------------
CSpoolerEngine::~CSpoolerEngine(void)
    {

    Assert(m_rEventTable.prgEvents == NULL);
    Assert(ISSPOOLERTHREAD);
    if (g_pConMan)
        g_pConMan->Unadvise((IConnectionNotify *) this);
    OptionUnadvise(m_hwndUI);
    SafeRelease(m_pUI);
    SafeRelease(m_pAcctMan);
    SafeRelease(m_pUidlCache);
    SafeRelease(m_pSmtpLogFile);
    SafeRelease(m_pPop3LogFile);
    SafeMemFree(m_pszAcctID);
    ReleaseMem(m_rViewRegister.rghwndView);
    DeleteCriticalSection(&m_cs);
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    // Locals
    HRESULT hr=S_OK;
    
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);
    
    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(ISpoolerEngine *)this;
    else if (IID_ISpoolerEngine == riid)
        *ppv = (ISpoolerEngine *)this;
    else if (IID_ISpoolerBindContext == riid)
        *ppv = (ISpoolerBindContext *)this;
    else
        {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
        }
    
    // AddRef It
    ((IUnknown *)*ppv)->AddRef();
    
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSpoolerEngine::AddRef(void)
    {
    EnterCriticalSection(&m_cs);
    ULONG cRef = ++m_cRef;
    LeaveCriticalSection(&m_cs);
    return cRef;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSpoolerEngine::Release(void)
    {
    EnterCriticalSection(&m_cs);
    ULONG cRef = --m_cRef;
    LeaveCriticalSection(&m_cs);
    if (0 != cRef)
        return cRef;
    delete this;
    return 0;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::Init
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::Init(ISpoolerUI *pUI, BOOL fPoll)
    {
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dw;


    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Already Inited
    if (m_pAcctMan)
        {
        Assert(FALSE);
        goto exit;
        }
    
    // Create Default Spooler UI Object
    if (NULL == pUI)
        {
        // Create a Serdy UI object
        CHECKALLOC(m_pUI = (ISpoolerUI *)new CSpoolerDlg);
        
        // Create
        CHECKHR(hr = m_pUI->Init(GetDesktopWindow()));
        }
    
    // Otherwise, assume pUI
    else
        {
        m_pUI = pUI;
        m_pUI->AddRef();
        }
    
    // Register SpoolerBindContext with the UI object
    m_pUI->RegisterBindContext((ISpoolerBindContext *)this);
    
    // Get the window handle of the spooler UI
    m_pUI->GetWindow(&m_hwndUI);

    // Get Me An Account Manager
    Assert(NULL == m_pAcctMan);
    CHECKHR(hr = HrCreateAccountManager(&m_pAcctMan));

    // Advise on the connection status
    Assert(g_pConMan);
    g_pConMan->Advise((IConnectionNotify *) this);

exit:

    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
    }


HRESULT CSpoolerEngine::OnStartupFinished(void)
    {
    DWORD dw;


    // Start Polling...
    dw = DwGetOption(OPT_POLLFORMSGS);
    if (dw != OPTION_OFF)
        SetTimer(m_hwndUI, IMAIL_POOLFORMAIL, dw, NULL);

    // Advise Options
    OptionAdvise(m_hwndUI);

    return (S_OK);
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::StartDelivery
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::StartDelivery(HWND hwnd, LPCSTR pszAcctID, FOLDERID idFolder, DWORD dwFlags)
{
    // Locals
    HRESULT  hr=S_OK;

    
    // No Flags
    if (0 == dwFlags || (DELIVER_SHOW != dwFlags && 0 == (dwFlags & ~DELIVER_COMMON_MASK)))
        return TrapError(E_INVALIDARG);

    // Check to see if we're working offline
    Assert(g_pConMan);


    if (DELIVER_SHOW != dwFlags && g_pConMan->IsGlobalOffline())
    {
        if (IDNO == AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                  0, MB_YESNO | MB_ICONEXCLAMATION ))
        {
            return (S_OK);
        }
        else
        {
            g_pConMan->SetGlobalOffline(FALSE);
        }
    }
    
    // Enter Critical Section
    EnterCriticalSection(&m_cs);

    // If were busy...
    if (!ISFLAGSET(m_dwState, SPSTATE_BUSY))
    {
        // Don't need this anymore
        SafeMemFree(m_pszAcctID);
    
        // Save the Account Name
        if (pszAcctID)
            CHECKALLOC(m_pszAcctID = PszDupA(pszAcctID));

        // Save the folder ID
        m_idFolder = idFolder;
    
        // Lets enter the busy state
        FLAGSET(m_dwState, SPSTATE_BUSY);                                    
    }
    else
        FLAGSET(dwFlags, DELIVER_REFRESH);

    // Process the outbox
    Assert(m_hwndUI && IsWindow(m_hwndUI));
    PostMessage(m_hwndUI, IMAIL_DELIVERNOW, 0, dwFlags);
    
exit:
    // Leave Critical Section
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::_HrStartDeliveryActual
// --------------------------------------------------------------------------------
HRESULT CSpoolerEngine::_HrStartDeliveryActual(DWORD dwFlags)
    {
    // Locals
    HRESULT             hr=S_OK;
    IImnAccount        *pAccount=NULL;
    ACCOUNTTABLE        rTable;
    IImnEnumAccounts   *pEnum=NULL;
    DWORD               dw;
    ULONG               c;
    MSG                 msg;
    ULONG               iConnectoid;
    ULONG               i;
    CHAR                szConnectoid[CCHMAX_CONNECTOID];
    
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    ZeroMemory(&rTable, sizeof(ACCOUNTTABLE));

    m_cSyncEvent = 0;
    m_fNoSyncEvent = FALSE;

    // If we are currently busy...
    if (ISFLAGSET(dwFlags, DELIVER_REFRESH))
        {
        // If we are currently with no UI, and new request is for ui
        if (ISFLAGSET(m_dwFlags, DELIVER_NOUI) && !ISFLAGSET(dwFlags, DELIVER_NOUI))
            FLAGCLEAR(m_dwFlags, DELIVER_NOUI);

        // If we are currently doing a background poll
        if (ISFLAGSET(m_dwFlags, DELIVER_BACKGROUND) && !ISFLAGSET(dwFlags, DELIVER_BACKGROUND))
            FLAGCLEAR(m_dwFlags, DELIVER_BACKGROUND);

        // If not running with now ui, set to foreground
        if (!ISFLAGSET(m_dwFlags, DELIVER_NOUI) && !ISFLAGSET(m_dwFlags, DELIVER_BACKGROUND))
            {
            m_pUI->ShowWindow(SW_SHOW);
            SetForegroundWindow(m_hwndUI);
            }

        // Should I queue an outbox delivery?
        if (0 == m_dwQueued && ISFLAGSET(dwFlags, DELIVER_QUEUE))
            {
            m_dwQueued = dwFlags;
            FLAGCLEAR(m_dwQueued, DELIVER_REFRESH);
            FLAGCLEAR(m_dwQueued, DELIVER_QUEUE);
            }

        // Done
        goto exit;
        }

    // Simply show the ui ?
    if (ISFLAGSET(dwFlags, DELIVER_SHOW))
        {
        m_pUI->ShowWindow(SW_SHOW);
        SetForegroundWindow(m_hwndUI);
        FLAGCLEAR(m_dwState, SPSTATE_BUSY);
        goto exit;
        }

    // Reset
    m_pUI->ClearEvents();
    m_pUI->SetTaskCounts(0, 0);
    m_pUI->StartDelivery();

    // Save these flags
    m_dwFlags = dwFlags;

    // Show the UI if necessary
    if (!ISFLAGSET(m_dwFlags, DELIVER_BACKGROUND))
        {
        m_pUI->ShowWindow(SW_SHOW);
        SetForegroundWindow(m_hwndUI);
        }
    else
        {
        // If the invoker called for background, but the UI is already visible,
        // then remove the flags
        if (IsWindowVisible(m_hwndUI))
            {
            FLAGCLEAR(m_dwFlags, DELIVER_BACKGROUND);
            FLAGCLEAR(m_dwFlags, DELIVER_NOUI);
            }
        }

#if 0
    // Raid 43695: Spooler: News post with a CC causes an SMTP error
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }
#endif

    // Single Account Polling...
    if (m_pszAcctID)
        {
        // Add the Account into the Account Table
        CHECKHR(hr = _HrAppendAccountTable(&rTable, m_pszAcctID, ALL_ACCT_SERVERS));
        }
    
    // Otherwise, polling all accounts
    else
    {
        // Determine the types of servers we're going to queue up

        DWORD   dwServers = 0, dw;

        if (m_dwFlags & DELIVER_SMTP_TYPE)
            dwServers |= SRV_SMTP;

        if (m_dwFlags & DELIVER_NEWS_TYPE && !(g_dwAthenaMode & MODE_MAILONLY))
            dwServers |= SRV_NNTP;

        if (m_dwFlags & DELIVER_HTTP_TYPE && !(g_dwAthenaMode & MODE_NEWSONLY))
            dwServers |= SRV_HTTPMAIL;
    
        if (m_dwFlags & DELIVER_IMAP_TYPE && !(g_dwAthenaMode & MODE_NEWSONLY))
            dwServers |= SRV_IMAP;

        if ((m_dwFlags & DELIVER_MAIL_RECV) && !(g_dwAthenaMode & MODE_NEWSONLY))
            dwServers |= SRV_POP3;

        // Enumerate the accounts
        CHECKHR(hr = m_pAcctMan->Enumerate(dwServers, &pEnum));

        // Sort by Account Name
        pEnum->SortByAccountName();
        
        // Add all the accounts into the Account Table
        while (SUCCEEDED(pEnum->GetNext(&pAccount)))
            {
            // Add Account Into the Account Table
            CHECKHR(hr = _HrAppendAccountTable(&rTable, pAccount, dwServers));
            
            // Release
            SafeRelease(pAccount);
            }
        }
    
    // No Accounts...
    if (0 == rTable.cAccounts)
        goto exit;
    
    // Sort the Account Table by Connnection Name
    if (rTable.cRasAccts)
        {
        Assert(rTable.prgRasAcct);
        _SortAccountTableByConnName(0, rTable.cRasAccts - 1, rTable.prgRasAcct);
        }

    m_fRasSpooled = FALSE;
    m_fIDialed = FALSE;

    // Raid-46334: MAIL: Time to build a Task List.  First loop through the LAN list and build tasks from those accounts.
    for (dw = 0; dw < rTable.cLanAccts; dw++)
        {
        if (ISFLAGSET(rTable.prgLanAcct[dw].dwServers, SRV_POP3) ||
            ISFLAGSET(rTable.prgLanAcct[dw].dwServers, SRV_SMTP) ||
            ISFLAGSET(rTable.prgLanAcct[dw].dwServers, SRV_IMAP) ||
            ISFLAGSET(rTable.prgLanAcct[dw].dwServers, SRV_HTTPMAIL))
            {
            Assert(rTable.prgLanAcct[dw].pAccount);
            _HrCreateTaskObject(&(rTable.prgLanAcct[dw]));
            SafeRelease(rTable.prgLanAcct[dw].pAccount);
            }
        }

    // Raid-46334: NEWS: Time to build a Task List.  First loop through the LAN/news list and build tasks from those accounts.
    for (dw = 0; dw < rTable.cLanAccts; dw++)
        {
        if (ISFLAGSET(rTable.prgLanAcct[dw].dwServers, SRV_NNTP))
            {
            Assert(rTable.prgLanAcct[dw].pAccount);
            _HrCreateTaskObject(&(rTable.prgLanAcct[dw]));
            SafeRelease(rTable.prgLanAcct[dw].pAccount);
            }
        else
            Assert(NULL == rTable.prgLanAcct[dw].pAccount);
        }
    
    // Now walk the list of RAS accounts and add those to the task list
    iConnectoid = 0;
    while(iConnectoid < rTable.cRasAccts)
        {
        // Indirect Sort
        i = rTable.prgRasAcct[iConnectoid].dwSort;

        // Save current connectoid
        lstrcpyn(szConnectoid, rTable.prgRasAcct[i].szConnectoid, ARRAYSIZE(szConnectoid));

        // Insert Ras Accounts
        // TODO Add HTTP accounts to it too.
        _InsertRasAccounts(&rTable, szConnectoid, SRV_POP3 | SRV_SMTP | SRV_IMAP | SRV_HTTPMAIL);

        // Insert Ras Accounts
        _InsertRasAccounts(&rTable, szConnectoid, SRV_NNTP);

        // Move iConnectoid to next unique connectoid
        while(1)
            {
            // Increment iConnectoid
            iConnectoid++;

            // Done
            if (iConnectoid >= rTable.cRasAccts)
                break;

            // Indirect Sort
            i = rTable.prgRasAcct[iConnectoid].dwSort;

            // Next connectoid
            if (lstrcmpi(szConnectoid, rTable.prgRasAcct[i].szConnectoid) != 0)
                break;
            }
        }
    
    // Execute the first task
    m_cCurEvent = -1;

    m_fNoSyncEvent = (ISFLAGSET(m_dwFlags, DELIVER_OFFLINE_SYNC) && m_pszAcctID != NULL && m_cSyncEvent == 0);

    // Toggle Hangup When Done option
    m_pUI->ChangeHangupOption(m_fRasSpooled, DwGetOption(OPT_DIALUP_HANGUP_DONE));

    // $$HACK$$
    EnableWindow(GetDlgItem(m_hwndUI, IDC_SP_STOP), TRUE);

    // Notify
    Notify(DELIVERY_NOTIFY_STARTING, 0);

    // Start Next Task
    PostMessage(m_hwndUI, IMAIL_NEXTTASK, 0, 0);

exit:
    // Failure
    if (FAILED(hr) || 0 == m_rEventTable.cEvents && !ISFLAGSET(dwFlags, DELIVER_SHOW))
        {
        // Not Busy
        FLAGCLEAR(m_dwState, SPSTATE_BUSY);

        // Forces a next task
        PostMessage(m_hwndUI, IMAIL_NEXTTASK, 0, 0);
        
        // No Flags
        m_dwFlags = 0;
        }
    
    // Cleanup
    SafeRelease(pEnum);
    SafeRelease(pAccount);
    SafeMemFree(m_pszAcctID);
    SafeMemFree(rTable.prgLanAcct);
    SafeMemFree(rTable.prgRasAcct);
    
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::_InsertRasAccounts
// --------------------------------------------------------------------------------
void CSpoolerEngine::_InsertRasAccounts(LPACCOUNTTABLE pTable, LPCSTR pszConnectoid, DWORD dwSrvTypes)
    {
    // Locals
    ULONG       j;
    ULONG       i;

    // Loop through the ras accounts and insert account on szConnetoid that are mail accounts
    for (j=0; j<pTable->cRasAccts; j++)
        {
        // Indirect
        i = pTable->prgRasAcct[j].dwSort;

        // Is a mail account
        if (pTable->prgRasAcct[i].dwServers & dwSrvTypes)
            {
            // On this connectoid
            if (lstrcmpi(pszConnectoid, pTable->prgRasAcct[i].szConnectoid) == 0)
                {
                // We better have an account
                Assert(pTable->prgRasAcct[i].pAccount);

                // If dialog allowed or we can connect to the account
                if (0 == (m_dwFlags & DELIVER_NODIAL) || S_OK == g_pConMan->CanConnect(pTable->prgRasAcct[i].pAccount))
                    {
                    _HrCreateTaskObject(&(pTable->prgRasAcct[i]));
                    }

                // Release the account, we've added it
                SafeRelease(pTable->prgRasAcct[i].pAccount);
                }
            }
        }
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::_SortAccountTableByConnName
// --------------------------------------------------------------------------------
void CSpoolerEngine::_SortAccountTableByConnName(LONG left, LONG right, LPSPOOLERACCOUNT prgRasAcct)
    {
    // Locals
    register    long i, j;
    DWORD       k, temp;
    
    i = left;
    j = right;
    k = prgRasAcct[(i + j) / 2].dwSort;
    
    do  
        {
        while(lstrcmpiA(prgRasAcct[prgRasAcct[i].dwSort].szConnectoid, prgRasAcct[k].szConnectoid) < 0 && i < right)
            i++;
        while (lstrcmpiA(prgRasAcct[prgRasAcct[j].dwSort].szConnectoid, prgRasAcct[k].szConnectoid) > 0 && j > left)
            j--;
        
        if (i <= j)
            {
            temp = prgRasAcct[i].dwSort;
            prgRasAcct[i].dwSort = prgRasAcct[j].dwSort;
            prgRasAcct[j].dwSort = temp;
            i++; j--;
            }
        
        } while (i <= j);
        
    if (left < j)
        _SortAccountTableByConnName(left, j, prgRasAcct);
    if (i < right)
        _SortAccountTableByConnName(i, right, prgRasAcct);
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::_HrAppendAccountTable
// --------------------------------------------------------------------------------
HRESULT CSpoolerEngine::_HrAppendAccountTable(LPACCOUNTTABLE pTable, LPCSTR pszAcctID, DWORD dwServers)
    {
    // Locals
    HRESULT         hr=S_OK;
    IImnAccount    *pAccount=NULL;
    
    // Invalid Arg
    Assert(pTable && pszAcctID);
    
    // Does the Account Exist...
    CHECKHR(hr = m_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_pszAcctID, &pAccount));
    
    // Actual Append
    CHECKHR(hr = _HrAppendAccountTable(pTable, pAccount, dwServers));
    
exit:
    // Cleanup
    SafeRelease(pAccount);
    
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::_HrAppendAccountTable
// --------------------------------------------------------------------------------
HRESULT CSpoolerEngine::_HrAppendAccountTable(LPACCOUNTTABLE pTable, IImnAccount *pAccount, DWORD   dwServers)
    {
    // Locals
    HRESULT             hr=S_OK;
    LPSPOOLERACCOUNT    pSpoolAcct;
    DWORD               dwConnType;
    CHAR                szConnectoid[CCHMAX_CONNECTOID];
    
    // InvalidArg
    Assert(pTable && pAccount);
    
    // Init
    *szConnectoid = '\0';
    
    // Get the Account Connection Type
    if (FAILED(pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnType)))
        {
        // Default to Manual Connection
        dwConnType = CONNECTION_TYPE_MANUAL;
        }
    
    // Otheriwse, get the connectoid if its a RAS connection
    //else if (CONNECTION_TYPE_RAS == dwConnType || CONNECTION_TYPE_INETSETTINGS == dwConnType)
    else if (CONNECTION_TYPE_RAS == dwConnType)
        {
        // AP_RAS_CONNECTOID
        if (FAILED(pAccount->GetPropSz(AP_RAS_CONNECTOID, szConnectoid, ARRAYSIZE(szConnectoid))))
            {
            // Default to Lan Connection
            dwConnType = CONNECTION_TYPE_MANUAL;
            }
        }
    else if (CONNECTION_TYPE_INETSETTINGS == dwConnType)
    {
        DWORD   dwFlags;

        InternetGetConnectedStateExA(&dwFlags, szConnectoid, ARRAYSIZE(szConnectoid), 0);
        if (!!(dwFlags & INTERNET_CONNECTION_MODEM))
        {
            dwConnType = CONNECTION_TYPE_RAS;
        }
        else
        {
            dwConnType = CONNECTION_TYPE_LAN;
        }
    }
    
    // Which Table Should I insert into - LAN OR RAS
      if (CONNECTION_TYPE_RAS == dwConnType)
        {
        // Better have a Connectoid
        Assert(FIsEmptyA(szConnectoid) == FALSE);
        
        // Grow the Table
        if (pTable->cRasAccts + 1 > pTable->cRasAlloc)
            {
            // Temp
            LPSPOOLERACCOUNT pRealloc=pTable->prgRasAcct;
            
            // Realloc
            CHECKALLOC(pTable->prgRasAcct = (LPSPOOLERACCOUNT)g_pMalloc->Realloc((LPVOID)pRealloc, (pTable->cRasAlloc + 5) * sizeof(SPOOLERACCOUNT)));
            
            // Grow
            pTable->cRasAlloc += 5;
            }
        
        // Readability
        pSpoolAcct = &pTable->prgRasAcct[pTable->cRasAccts];
        }
    
    // Otherwise, LAN
    else
        {
        // Grow the Table
        if (pTable->cLanAccts + 1 > pTable->cLanAlloc)
            {
            // Temp
            LPSPOOLERACCOUNT pRealloc=pTable->prgLanAcct;
            
            // Realloc
            CHECKALLOC(pTable->prgLanAcct = (LPSPOOLERACCOUNT)g_pMalloc->Realloc((LPVOID)pRealloc, (pTable->cLanAlloc + 5) * sizeof(SPOOLERACCOUNT)));
            
            // Grow
            pTable->cLanAlloc += 5;
            }
        
        // Readability
        pSpoolAcct = &pTable->prgLanAcct[pTable->cLanAccts];
        }
    
    // Zero
    ZeroMemory(pSpoolAcct, sizeof(SPOOLERACCOUNT));
    
    // AddRef the Account
    pSpoolAcct->pAccount = pAccount;
    pSpoolAcct->pAccount->AddRef();
    
    // Get the servers supported by the account
    CHECKHR(hr = pAccount->GetServerTypes(&pSpoolAcct->dwServers));

    //Mask the servers returned by the acctman with the servers we want to spool
    pSpoolAcct->dwServers &= dwServers;
    
    /*
    if (pSpoolAcct->dwServers & (SRV_HTTPMAIL | SRV_IMAP))
    {
        //For each of these two servers, set the sync flags. See Bug# 51895
        m_dwFlags |= (DELIVER_NEWSIMAP_OFFLINE | DELIVER_NEWSIMAP_OFFLINE_FLAGS);
    }
    */

    // Save Connection Type
    pSpoolAcct->dwConnType = dwConnType;
    
    // Save Connectoid
    lstrcpy(pSpoolAcct->szConnectoid, szConnectoid);
    
    // Increment Count and set the sort index
//    if (CONNECTION_TYPE_RAS == dwConnType || dwConnType == CONNECTION_TYPE_INETSETTINGS)
      if (CONNECTION_TYPE_RAS == dwConnType)
        {
        pSpoolAcct->dwSort = pTable->cRasAccts;
        pTable->cRasAccts++;
        }
    else
        {
        pSpoolAcct->dwSort = pTable->cLanAccts;
        pTable->cLanAccts++;
        }
    
    // Total Acount
    pTable->cAccounts++;
    
exit:
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::Close
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::Close(void)
    {
    // Locals
    HRESULT     hr=S_OK;
    
    // Thread Safety
    EnterCriticalSection(&m_cs);

    _StopPolling();
    
    // Was I Threaded ?
    if (NULL != m_hThread)
        {
        hr = TrapError(E_FAIL);
        goto exit;
        }
    
    // Shutdown
    CHECKHR(hr = Shutdown());
    
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::Notify
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::Notify(DELIVERYNOTIFYTYPE notify, LPARAM lParam)
{
    // Locals
    ULONG i;

    // Enter it
    EnterCriticalSection(&m_cs);

    // Same thread we were created on...
    Assert(ISSPOOLERTHREAD);

    // Loop through registered views
    for (i=0; i<m_rViewRegister.cViewAlloc; i++)
        if (m_rViewRegister.rghwndView[i] != 0 && IsWindow(m_rViewRegister.rghwndView[i]))
            PostMessage(m_rViewRegister.rghwndView[i], MVM_SPOOLERDELIVERY, (WPARAM)notify, lParam);

    // Enter it
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::Advise
// --------------------------------------------------------------------------------
#define VIEW_TABLE_GROWSIZE 8
STDMETHODIMP CSpoolerEngine::Advise(HWND hwndView, BOOL fRegister)
    {
    // Locals
    ULONG           i;
    HRESULT         hr=S_OK;
    
    // Enter it
    EnterCriticalSection(&m_cs);
    
    // If NULL view handle...
    if (!hwndView)
        {
        hr = TrapError(E_FAIL);
        goto exit;
        }
    
    // Are we registering the window
    if (fRegister)
        {
        // Do we need to grow the register array
        if (m_rViewRegister.cViewAlloc == m_rViewRegister.cView)
            {
            // Add some more
            m_rViewRegister.cViewAlloc += VIEW_TABLE_GROWSIZE;
            
            // Realloc the array
            if (!MemRealloc((LPVOID *)&m_rViewRegister.rghwndView, sizeof(HWND) * m_rViewRegister.cViewAlloc))
                {
                m_rViewRegister.cViewAlloc -= VIEW_TABLE_GROWSIZE;
                hr = TrapError(E_OUTOFMEMORY);
                goto exit;
                }
            
            // Zeroinit the new items
            ZeroMemory(&m_rViewRegister.rghwndView[m_rViewRegister.cView], sizeof(HWND) * (m_rViewRegister.cViewAlloc - m_rViewRegister.cView));
            }
        
        // Fill the first NULL item with the new view
        for (i=0; i<m_rViewRegister.cViewAlloc; i++)
            {
            // If empty, lets fill it
            if (!m_rViewRegister.rghwndView[i])
                {
                m_rViewRegister.rghwndView[i] = hwndView;
                m_rViewRegister.cView++;
                break;
                }
            }
        
        // Did we insert it ?
        AssertSz(i != m_rViewRegister.cViewAlloc, "didn't find a hole??");
        }
    
    // Otherwise, find and remove the view
    else
        {
        // Look for hwndView
        for (i=0; i<m_rViewRegister.cViewAlloc; i++)
            {
            // Is this it
            if (m_rViewRegister.rghwndView[i] == hwndView)
                {
                m_rViewRegister.rghwndView[i] = NULL;
                m_rViewRegister.cView--;
                break;
                }
            }
        }
    
exit:
    // Leave CS
    LeaveCriticalSection(&m_cs);
    
    // If this is the first view to register, and there is a background poll pending, lets do it...
    if (fRegister && m_rViewRegister.cView == 1 && m_fBackgroundPollPending)
        {
        StartDelivery(NULL, NULL, FOLDERID_INVALID, DELIVER_BACKGROUND_POLL);
        m_fBackgroundPollPending = FALSE;
        }
    else if (m_rViewRegister.cView == 0)
        {
        // remove the notify icon if there aren't any views registered
        UpdateTrayIcon(TRAYICON_REMOVE);
        }
    
    // Done    
    return hr;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::UpdateTrayIcon
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::UpdateTrayIcon(TRAYICONTYPE type)
    {
    // Locals
    NOTIFYICONDATA  nid;
    HWND            hwnd=NULL;
    ULONG           i;

    // Enter it
    EnterCriticalSection(&m_cs);

    // Add the icon...
    if (TRAYICON_ADD == type)
    {
        // Loop through registered views
        for (i=0; i<m_rViewRegister.cViewAlloc; i++)
        {
            if (m_rViewRegister.rghwndView[i] && IsWindow(m_rViewRegister.rghwndView[i]))
            {
                hwnd = m_rViewRegister.rghwndView[i];
                break;
            }
        }

        // No window...
        if (hwnd == NULL)
            goto exit;
    }

    // Otherwise, if no notify window, were done
    else if (m_hwndTray == NULL)
        goto exit;

    // Set Tray Notify Icon Data
    nid.cbSize = sizeof(NOTIFYICONDATA);
    nid.uID = 0;
    nid.uFlags = NIF_ICON | NIF_TIP | NIF_MESSAGE;
    nid.uCallbackMessage = MVM_NOTIFYICONEVENT;
    nid.hIcon = LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiNewMailNotify));
    LoadString(g_hLocRes, idsNewMailNotify, nid.szTip, sizeof(nid.szTip));

    // Hmmm
    if (TRAYICON_REMOVE == type || (m_hwndTray != NULL && m_hwndTray != hwnd))
    {
        nid.hWnd = m_hwndTray;
        Shell_NotifyIcon(NIM_DELETE, &nid);
        m_hwndTray = NULL;
    }

    // Add
    if (TRAYICON_ADD == type)
    {
        nid.hWnd = hwnd;
        Shell_NotifyIcon(NIM_ADD, &nid);
        m_hwndTray = hwnd;
    }

exit:
    // Leave CS
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::RegisterEvent
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::RegisterEvent(LPCSTR pszDescription, ISpoolerTask *pTask, 
                                           DWORD_PTR dwTwinkie, IImnAccount *pAccount,
                                           LPEVENTID peid)
    {
    HRESULT hr = S_OK;
    LPSPOOLEREVENT pEvent = NULL;
    LPWSTR pwszConn = NULL;
    WCHAR  wsz[CCHMAX_STRINGRES];
    
    // Verify the input parameters
    if (FIsEmptyA(pszDescription) || pTask == NULL)
        return (E_INVALIDARG);
    
    EnterCriticalSection(&m_cs);
    
    // Grow the Table
    if (m_rEventTable.cEvents + 1 > m_rEventTable.cEventsAlloc)
        {
        // Temp
        LPSPOOLEREVENT pRealloc = m_rEventTable.prgEvents;
        
        // Realloc
        CHECKALLOC(m_rEventTable.prgEvents = (LPSPOOLEREVENT) g_pMalloc->Realloc((LPVOID)pRealloc, (m_rEventTable.cEventsAlloc + 5) * sizeof(SPOOLEREVENT)));
        
        // Grow
        m_rEventTable.cEventsAlloc += 5;
        }

    pEvent = &m_rEventTable.prgEvents[m_rEventTable.cEvents];
    
    // Insert the event
    pEvent->eid = m_rEventTable.cEvents;
    pEvent->pSpoolerTask = pTask;
    pEvent->pSpoolerTask->AddRef();
    pEvent->dwTwinkie = dwTwinkie;
    pEvent->pAccount = pAccount;
    pEvent->pAccount->AddRef();

    // Get the Account Connection Type
    if (FAILED(pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &pEvent->dwConnType)))
        {
        // Default to Manual Connection
        pEvent->dwConnType = CONNECTION_TYPE_MANUAL;
        }
    
    // Otheriwse, get the connectoid if its a RAS connection
    //else if (CONNECTION_TYPE_RAS == pEvent->dwConnType || CONNECTION_TYPE_INETSETTINGS == pEvent->dwConnType)
    else if (CONNECTION_TYPE_RAS == pEvent->dwConnType)
    {
        // AP_RAS_CONNECTOID
        if (FAILED(pAccount->GetPropSz(AP_RAS_CONNECTOID, pEvent->szConnectoid, ARRAYSIZE(pEvent->szConnectoid))))
        {
            // Default to Lan Connection
            pEvent->dwConnType = CONNECTION_TYPE_MANUAL;
        }
    }
    else if (CONNECTION_TYPE_INETSETTINGS == pEvent->dwConnType)
    {
        DWORD   dwFlags = 0;

        InternetGetConnectedStateExA(&dwFlags, pEvent->szConnectoid, ARRAYSIZE(pEvent->szConnectoid), 0);
        if (!!(dwFlags & INTERNET_CONNECTION_MODEM))
        {
            pEvent->dwConnType = CONNECTION_TYPE_RAS;
        }
        else
        {
            pEvent->dwConnType = CONNECTION_TYPE_LAN;
        }
    }

    // Get the connection name to put in the task list
    if (pEvent->dwConnType == CONNECTION_TYPE_LAN)
    {
        AthLoadStringW(idsConnectionLAN, wsz, ARRAYSIZE(wsz));
        pwszConn = wsz;
    }
    else if (pEvent->dwConnType == CONNECTION_TYPE_MANUAL)
    {
        AthLoadStringW(idsConnectionManual, wsz, ARRAYSIZE(wsz));
        pwszConn = wsz;
        m_fRasSpooled = TRUE;
    }
    else
    {
        IF_NULLEXIT(pwszConn = PszToUnicode(CP_ACP, pEvent->szConnectoid));
        m_fRasSpooled = TRUE;
    }

    // Add the event description to the UI
    if (m_pUI)
    {
        m_pUI->InsertEvent(m_rEventTable.prgEvents[m_rEventTable.cEvents].eid, pszDescription, pwszConn);
        m_pUI->SetTaskCounts(0, m_rEventTable.cEvents + 1);
    }
    
    // Check to see if the task cares about the event id
    if (peid)
        *peid = m_rEventTable.prgEvents[m_rEventTable.cEvents].eid;
    
    m_rEventTable.cEvents++;

exit:
    if (pwszConn != wsz)
        MemFree(pwszConn);
    LeaveCriticalSection(&m_cs);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::EventDone
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::EventDone(EVENTID eid, EVENTCOMPLETEDSTATUS status)
    {
    LPSPOOLEREVENT pEvent;

    // Update the UI
    if (EVENT_SUCCEEDED == status)
        {
        m_rEventTable.cSucceeded++;
        m_pUI->SetTaskCounts(m_rEventTable.cSucceeded, m_rEventTable.cEvents);
        m_pUI->UpdateEventState(eid, IMAGE_CHECK, NULL, MAKEINTRESOURCE(idsStateCompleted));
        }
    else if (EVENT_WARNINGS == status)
        {
        m_pUI->UpdateEventState(eid, IMAGE_WARNING, NULL, MAKEINTRESOURCE(idsStateWarnings));
        }
    else if (EVENT_FAILED == status)
        {
        m_pUI->UpdateEventState(eid, IMAGE_ERROR, NULL, MAKEINTRESOURCE(idsStateFailed));
        }
    else if (EVENT_CANCELED == status)
        {
        m_pUI->UpdateEventState(eid, IMAGE_WARNING, NULL, MAKEINTRESOURCE(idsStateCanceled));
        }

    // When an event completes, we can move to the next item in the queue unless
    // we're done.
    if (!ISFLAGCLEAR(m_dwState, SPSTATE_CANCEL))
    {
        m_cCurEvent++;
        pEvent = &m_rEventTable.prgEvents[m_cCurEvent];
        for ( ; m_cCurEvent < m_rEventTable.cEvents; m_cCurEvent++, pEvent++)
        {
            pEvent->pSpoolerTask->CancelEvent(pEvent->eid, pEvent->dwTwinkie);
        }
    }

    // Next Task
    PostMessage(m_hwndUI, IMAIL_NEXTTASK, 0, 0);
    
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::_OpenMailLogFile
// --------------------------------------------------------------------------------
HRESULT CSpoolerEngine::_OpenMailLogFile(DWORD dwOptionId, LPCSTR pszPrefix, 
    LPCSTR pszFileName, ILogFile **ppLogFile)
{
    // Locals
    HRESULT hr=S_OK;
    CHAR    szLogFile[MAX_PATH];
    CHAR    szDirectory[MAX_PATH];
    DWORD   dw;

    // Invalid Args
    Assert(pszPrefix && ppLogFile);

    // Log file path
    dw = GetOption(dwOptionId, szLogFile, ARRAYSIZE(szLogFile));

    // If we found a filepath and the file exists
    if (0 == dw || FALSE == PathFileExists(szLogFile))
    {
        // Get the Store Root Directory
        GetStoreRootDirectory(szDirectory, ARRAYSIZE(szDirectory));

        // Ends with a backslash ?
        IF_FAILEXIT(hr = MakeFilePath(szDirectory, pszFileName, c_szEmpty, szLogFile, ARRAYSIZE(szLogFile)));

        // Reset the Option
        SetOption(dwOptionId, szLogFile, lstrlen(szLogFile) + 1, NULL, 0);
    }

    // Create the log file
    IF_FAILEXIT(hr = CreateLogFile(g_hInst, szLogFile, pszPrefix, DONT_TRUNCATE, ppLogFile,
        FILE_SHARE_READ | FILE_SHARE_WRITE));

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::BindToObject
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::BindToObject(REFIID riid, void **ppvObject)
    {
    // Locals
    HRESULT     hr=S_OK;
    
    // Invalid Arg
    if (NULL == ppvObject)
        return TrapError(E_INVALIDARG);
    
    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // IID_ISpoolerBindContext
    if (IID_ISpoolerBindContext == riid)
        *ppvObject = (ISpoolerBindContext *)this;

    // IID_CUidlCache
    else if (IID_CUidlCache == riid)
    {
        // Doesn't Exist
        if (NULL == m_pUidlCache)
            {
            // Open the Cache
            CHECKHR(hr = OpenUidlCache(&m_pUidlCache));
            }

        // AddRef it
        m_pUidlCache->AddRef();
        
        // Return It
        *ppvObject = (IDatabase *)m_pUidlCache;
    }
    
    // IImnAccountManager
    else if (IID_IImnAccountManager == riid)
        {
        // Doesn't Exist
        if (NULL == m_pAcctMan)
            {
            AssertSz(FALSE, "The Account Manager Could Not Be Created.");
            hr = TrapError(E_FAIL);
            goto exit;
            }

        // AddRef It
        m_pAcctMan->AddRef();
        
        // Return It
        *ppvObject = (IImnAccountManager *)m_pAcctMan;
        }
    
    // ISpoolerUI
    else if (IID_ISpoolerUI == riid)
        {
        // Doesn't Exist
        if (NULL == m_pUI)
            {
            AssertSz(FALSE, "The Spooler UI Object Could Not Be Created.");
            hr = TrapError(E_FAIL);
            goto exit;
            }

        // AddRef It
        m_pUI->AddRef();
        
        // Return It
        *ppvObject = (ISpoolerUI *)m_pUI;
        }

    // IID_CLocalStoreDeleted
    else if (IID_CLocalStoreDeleted == riid)
        {
        // Open Special Folder
        CHECKHR(hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_DELETED, (IMessageFolder **)ppvObject));
        }
    
    // IID_CLocalStoreInbox
    else if (IID_CLocalStoreInbox == riid)
        {
        // Open Special Folder
        CHECKHR(hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_INBOX, (IMessageFolder **)ppvObject));
        }
    
    // IID_CLocalStoreOutbox
    else if (IID_CLocalStoreOutbox == riid)
        {
        // Open Special Folder
        CHECKHR(hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_OUTBOX, (IMessageFolder **)ppvObject));
        }
    
    // IID_CLocalStoreSentItems
    else if (IID_CLocalStoreSentItems == riid)
        {
        // Open Special Folder
        CHECKHR(hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_SENT, (IMessageFolder **)ppvObject));
        }

    // IID_CPop3LogFile
    else if (IID_CPop3LogFile == riid)
        {   
        // Create logging objects
        if (!DwGetOption(OPT_MAILLOG))
            {
            hr = TrapError(E_FAIL);
            goto exit;
            }


        // Do I have the logfile yet ?
        if (NULL == m_pPop3LogFile)
            {
            // Open the log file
            CHECKHR(hr = _OpenMailLogFile(OPT_MAILPOP3LOGFILE, "POP3", c_szDefaultPop3Log, &m_pPop3LogFile));
            }

        // AddRef It
        m_pPop3LogFile->AddRef();

        // Return It
        *ppvObject = (ILogFile *)m_pPop3LogFile;
        }

    // IID_CSmtpLogFile
    else if (IID_CSmtpLogFile == riid)
        {   
        // Create logging objects
        if (!DwGetOption(OPT_MAILLOG))
            {
            hr = TrapError(E_FAIL);
            goto exit;
            }

        // Do I have the logfile yet ?
        if (NULL == m_pSmtpLogFile)
            {
            // Open the log file
            CHECKHR(hr = _OpenMailLogFile(OPT_MAILSMTPLOGFILE, "SMTP", c_szDefaultSmtpLog, &m_pSmtpLogFile));
            }

        // AddRef It
        m_pSmtpLogFile->AddRef();

        // Return It
        *ppvObject = (ILogFile *)m_pSmtpLogFile;
        }
    
    // E_NOTINTERFACE
    else
        {
        hr = TrapError(E_NOINTERFACE);
        goto exit;
        }
    
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::TaskFromEventId
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::TaskFromEventId(EVENTID eid, ISpoolerTask *ppTask)
    {
    return S_OK;
    }


// --------------------------------------------------------------------------------
// CSpoolerEngine::Cancel
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::Cancel(void)
    {
    EnterCriticalSection(&m_cs);

    if (ISFLAGSET(m_dwState, SPSTATE_BUSY))
        {
        Assert(m_rEventTable.cEvents && m_rEventTable.prgEvents);    
        FLAGSET(m_dwState, SPSTATE_CANCEL);
        if (m_rEventTable.prgEvents && m_rEventTable.prgEvents[m_cCurEvent].pSpoolerTask)
            m_rEventTable.prgEvents[m_cCurEvent].pSpoolerTask->Cancel();
        }

    LeaveCriticalSection(&m_cs);

    return S_OK;
    }



// --------------------------------------------------------------------------------
// CSpoolerEngine::GetThreadInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::GetThreadInfo(LPDWORD pdwThreadId, HTHREAD* phThread)
    {
    // Invalid Arg
    if (NULL == pdwThreadId || NULL == phThread)
        return TrapError(E_INVALIDARG);
    
    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Return It
    *pdwThreadId = m_dwThreadId;
    *phThread = m_hThread;
    
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::QueryEndSession
// --------------------------------------------------------------------------------
STDMETHODIMP_(LRESULT) CSpoolerEngine::QueryEndSession(WPARAM wParam, LPARAM lParam)
    {
    if (ISFLAGSET(m_dwState, SPSTATE_BUSY))
        {
        if (AthMessageBoxW(NULL, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsAbortDownload), NULL, MB_YESNO|MB_ICONEXCLAMATION ) == IDNO)
            return FALSE;
        }
    Cancel();
    return TRUE;
    }

// --------------------------------------------------------------------------------
// CSpoolerEngine::Shutdown
// --------------------------------------------------------------------------------
HRESULT CSpoolerEngine::Shutdown(void)
    {
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Better shutdown on the same thread we started on
    Assert(ISSPOOLERTHREAD);

    // Stop Polling
    _StopPolling();

    // Are we currently busy
    _ShutdownTasks();
    
    // If we're executing, then we need to stop and release all the tasks
    for (UINT i = 0; i < m_rEventTable.cEvents; i++)
        {
        SafeRelease(m_rEventTable.prgEvents[i].pSpoolerTask);
        SafeRelease(m_rEventTable.prgEvents[i].pAccount);
        }
    
    // Release Objects
    SafeRelease(m_pUI);
    SafeRelease(m_pAcctMan);
    SafeRelease(m_pUidlCache);
    SafeMemFree(m_pszAcctID);
    
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return S_OK;
    }


// --------------------------------------------------------------------------------
// CSpoolerEngine::Shutdown
// --------------------------------------------------------------------------------
void CSpoolerEngine::_ShutdownTasks(void)
{
    // Locals
    HRESULT              hr=S_OK;
    MSG                  msg;
    BOOL                 fFlushOutbox=FALSE;
    IMessageFolder      *pOutbox=NULL;
    int                  ResId;
    BOOL                 fOffline = FALSE;


    // Clear queued events
    m_dwQueued = 0;

    // Check for unsent mail
    if (g_fCheckOutboxOnShutdown)
    {
        // Open the Outbox
        if (SUCCEEDED(BindToObject(IID_CLocalStoreOutbox, (LPVOID *)&pOutbox)))
        {
            // Locals
            HROWSET hRowset=NULL;
            MESSAGEINFO MsgInfo={0};

            // Create a Rowset
            if (SUCCEEDED(pOutbox->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset)))
            {
                // While 
                while (S_OK == pOutbox->QueryRowset(hRowset, 1, (LPVOID *)&MsgInfo, NULL))
                {
                    // Has this message been submitted and is it a mail message
                    if (((MsgInfo.dwFlags & (ARF_SUBMITTED | ARF_NEWSMSG)) == ARF_SUBMITTED) &&
                        (!ISFLAGSET(m_dwState, SPSTATE_BUSY)))
                    {
                        fOffline = g_pConMan->IsGlobalOffline();

                        if (fOffline)
                            ResId = idsWarnUnsentMailOffline;
                        else
                            ResId = idsWarnUnsentMail;

                        // Prompt to flush the outbox
                        if (AthMessageBoxW(NULL, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(ResId), NULL, MB_YESNO|MB_ICONEXCLAMATION ) == IDYES)
                        {
                            // Go online
                            if (fOffline)
                                g_pConMan->SetGlobalOffline(FALSE);

                            // Flush on exit
                            fFlushOutbox = TRUE;
                        }

                        // Done
                        break;
                    }
                
                    // Free MsgInfo
                    pOutbox->FreeRecord(&MsgInfo);
                }

                // Free MsgInfo
                pOutbox->FreeRecord(&MsgInfo);

                // Close the Rowset
                pOutbox->CloseRowset(&hRowset);
            }
        }
    }

    // Release outbox
    SafeRelease(pOutbox);

    // Set Shutdown state
    FLAGSET(m_dwState, SPSTATE_SHUTDOWN);

    // If not busy now, start the flush
    if (!ISFLAGSET(m_dwState, SPSTATE_BUSY))
    {
        // Flush the Outbox
        if (fFlushOutbox)
        {
            // No need to flush again
            fFlushOutbox = FALSE;

            // Start the delivery
            _HrStartDeliveryActual(DELIVER_SEND | DELIVER_SMTP_TYPE | DELIVER_HTTP_TYPE );

            // We are busy
            FLAGSET(m_dwState, SPSTATE_BUSY);
        }

        // Otheriwse, were done...
        else
            goto exit;
    }

    // We must wait for current cycle to finish
    if (ISFLAGSET(m_dwState, SPSTATE_BUSY))
    {
        // Lets show progress...
        FLAGCLEAR(m_dwFlags, DELIVER_NOUI | DELIVER_BACKGROUND);

        // Show the ui object
        m_pUI->ShowWindow(SW_SHOW);
        SetForegroundWindow(m_hwndUI);

        // Here's a nice hack to disable the Hide button
        EnableWindow(GetDlgItem(m_hwndUI, IDC_SP_MINIMIZE), FALSE);

        // Set focus on the dialog
        SetFocus(m_hwndUI);

        // Set the focus onto the Stop Button
        SetFocus(GetDlgItem(m_hwndUI, IDC_SP_STOP));

        // Pump messages until current cycle is complete
        while(GetMessage(&msg, NULL, 0, 0))
        {
            // Give the message to the UI object
            if (m_pUI->IsDialogMessage(&msg) == S_FALSE && IsDialogMessage(&msg) == S_FALSE)
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            // If no cycle, were done
            if (!ISFLAGSET(m_dwState, SPSTATE_BUSY))
            {
                // Do the Outbox
                if (fFlushOutbox)
                {
                    // Were the errors...
                    if (S_OK == m_pUI->AreThereErrors())
                    {
                        // Errors were encountered during the last Delivery Cycle. Would you still like to send the messages that are in your Outbox?
                        if (AthMessageBoxW(NULL, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsWarnErrorUnsentMail), NULL, MB_YESNO | MB_ICONEXCLAMATION ) == IDNO)
                            break;
                    }

                    // No need to flush again
                    fFlushOutbox = FALSE;

                    // Start the delivery
                    _HrStartDeliveryActual(DELIVER_SEND | DELIVER_SMTP_TYPE | DELIVER_HTTP_TYPE );

                    // We are busy
                    FLAGSET(m_dwState, SPSTATE_BUSY);
                }
                else
                    break;
            }
        }
    }

    // Were the errors...
    if (S_OK == m_pUI->AreThereErrors() && !g_pInstance->SwitchingUsers())
    {
        // Tell the ui to go into Shutdown Mode
        m_pUI->Shutdown();

        // Show the ui object
        m_pUI->ShowWindow(SW_SHOW);
        SetForegroundWindow(m_hwndUI);

        // We are busy
        FLAGCLEAR(m_dwState, SPSTATE_UISHUTDOWN);

        // Set the focus onto the Stop Button
        SetFocus(GetDlgItem(m_hwndUI, IDC_SP_MINIMIZE));

        // Pump messages until current cycle is complete
        while(GetMessage(&msg, NULL, 0, 0))
        {
            // Give the message to the UI object
            if (m_pUI->IsDialogMessage(&msg) == S_FALSE && IsDialogMessage(&msg) == S_FALSE)
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            // User Pressed close yet ?
            if (ISFLAGSET(m_dwState, SPSTATE_UISHUTDOWN))
                break;
        }
    }

exit:
    // Cleanup
    SafeRelease(pOutbox);

    // Done
    return;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::UIShutdown
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::UIShutdown(void)
{
    EnterCriticalSection(&m_cs);
    FLAGSET(m_dwState, SPSTATE_UISHUTDOWN);
    LeaveCriticalSection(&m_cs);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::PumpMessages
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::PumpMessages(void)
{
    // Locals
    MSG     msg;
    BOOL    fQuit=FALSE;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Pump messages until current cycle is complete
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
        // WM_QUIT
        if (WM_QUIT == msg.message)
            {
            // Make a note that a quit was received
            fQuit = TRUE;

            // If not running with now ui, set to foreground
            if (FALSE == IsWindowVisible(m_hwndUI))
                {
                m_pUI->ShowWindow(SW_SHOW);
                SetForegroundWindow(m_hwndUI);
                }
            }

        // Give the message to the UI object
        if (m_pUI->IsDialogMessage(&msg) == S_FALSE && IsDialogMessage(&msg) == S_FALSE)
            {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            }
        }

    // Repost the quit message
    if (fQuit)
        PostThreadMessage(m_dwThreadId, WM_QUIT, 0, 0);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSpoolerEngine::OnWindowMessage - S_OK (I Handled the message)
// --------------------------------------------------------------------------------
STDMETHODIMP CSpoolerEngine::OnWindowMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dw;
    
    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Handle the window message
    switch(uMsg)
        {
        case IMAIL_DELIVERNOW:
            _HrStartDeliveryActual((DWORD)lParam);
            break;

        case IMAIL_NEXTTASK:
            _HrStartNextEvent();
            break;            
        
        case WM_TIMER:
            if (wParam == IMAIL_POOLFORMAIL)
                {
                KillTimer(hwnd, IMAIL_POOLFORMAIL);
                _DoBackgroundPoll();
                }
            break;

        case CM_OPTIONADVISE:
            // Check to see if the polling option changed
            if (wParam == OPT_POLLFORMSGS)
                {
                dw = DwGetOption(OPT_POLLFORMSGS);
                if (dw != OPTION_OFF)
                    {
                    if (dw != m_dwPollInterval)
                        {
                        KillTimer(hwnd, IMAIL_POOLFORMAIL);
                        SetTimer(hwnd, IMAIL_POOLFORMAIL, dw, NULL);
                        m_dwPollInterval = dw;
                        }
                    }
                else
                    {
                    KillTimer(hwnd, IMAIL_POOLFORMAIL);
                    m_dwPollInterval = 0;
                    }
                }

            // Check to see if the hang up option changed
            if (wParam == OPT_DIALUP_HANGUP_DONE)
                {
                dw = DwGetOption(OPT_DIALUP_HANGUP_DONE);
                m_pUI->ChangeHangupOption(m_fRasSpooled, dw);
                }

            break;

        default:
            hr = S_FALSE;
            break;
        }
    
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
    }


HRESULT CSpoolerEngine::_HrCreateTaskObject(LPSPOOLERACCOUNT pSpoolerAcct)
{
    DWORD           cEvents, cEventsT;
    HRESULT         hr=S_OK;

    // Let's try pumping messages to see if this get's any smoother
    MSG msg;
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        // Give the message to the UI object
        if (m_pUI->IsDialogMessage(&msg) == S_FALSE)
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    
    // Create the appropriate task object.  Start with SMTP
    if (pSpoolerAcct->dwServers & SRV_SMTP && m_dwFlags & DELIVER_SEND)
    {
        CSmtpTask *pSmtpTask = new CSmtpTask();
        if (pSmtpTask)
        {
            // Initialize the news task
            if (SUCCEEDED(hr = pSmtpTask->Init(m_dwFlags, (ISpoolerBindContext *) this)))
            {
                // Tell the task to build it's event list
                hr = pSmtpTask->BuildEvents(m_pUI, pSpoolerAcct->pAccount, 0);
            }

            pSmtpTask->Release();
        }
    }

    // HTTPMail Servers
    if ((!!(pSpoolerAcct->dwServers & SRV_HTTPMAIL)) && (!!(m_dwFlags & (DELIVER_SEND | DELIVER_POLL))))
    {
/*		DWORD dw;
		if (SUCCEEDED(pSpoolerAcct->pAccount->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dw)) && dw)
		{
			if(HideHotmail())
				return(hr);
		}
*/
        CHTTPTask *pHTTPTask = new CHTTPTask();
        if (pHTTPTask)
        {
            // initialize the http mail task
            if (SUCCEEDED(hr = pHTTPTask->Init(m_dwFlags, (ISpoolerBindContext *)this)))
                hr = pHTTPTask->BuildEvents(m_pUI, pSpoolerAcct->pAccount, 0);

            pHTTPTask->Release();
        }
    }
    
    // POP3 Servers
    if (pSpoolerAcct->dwServers & SRV_POP3 && m_dwFlags & DELIVER_MAIL_RECV)
    {
        // Skipping Marked Pop3 Accounts
        DWORD dw=FALSE;
        if (ISFLAGSET(m_dwFlags, DELIVER_NOSKIP) || FAILED(pSpoolerAcct->pAccount->GetPropDw(AP_POP3_SKIP, &dw)) || FALSE == dw)
        {
            CPop3Task *pPop3Task = new CPop3Task();
            if (pPop3Task)
            {
                // Initialize the news task
                if (SUCCEEDED(hr = pPop3Task->Init(m_dwFlags, (ISpoolerBindContext *) this)))
                {
                    // Tell the task to build it's event list
                    hr = pPop3Task->BuildEvents(m_pUI, pSpoolerAcct->pAccount, 0);
                }

                pPop3Task->Release();
            }
        }
    }

    // Servers that support offline sync
    if ((pSpoolerAcct->dwServers & (SRV_NNTP | SRV_IMAP | SRV_HTTPMAIL)))
    {
        if (!!((DELIVER_POLL | DELIVER_SEND) & m_dwFlags))
        {
            CNewsTask *pNewsTask = new CNewsTask();
            if (pNewsTask)
            {
                // Initialize the news task
                if (SUCCEEDED(hr = pNewsTask->Init(m_dwFlags, (ISpoolerBindContext *) this)))
                {
                    // Tell the task to build it's event list
                    hr = pNewsTask->BuildEvents(m_pUI, pSpoolerAcct->pAccount, 0);
                }

                pNewsTask->Release();
            }
        }

        if ((m_dwFlags & DELIVER_WATCH) && !(m_dwFlags & DELIVER_NO_NEWSPOLL) 
            && (pSpoolerAcct->dwServers & SRV_NNTP))
        {
            CWatchTask *pWatchTask = new CWatchTask();

            if (pWatchTask)
            {
                if (SUCCEEDED(hr = pWatchTask->Init(m_dwFlags, (ISpoolerBindContext *) this)))
                {
                    hr = pWatchTask->BuildEvents(m_pUI, pSpoolerAcct->pAccount, m_idFolder);
                }

                pWatchTask->Release();
            }
        }       
        
        cEvents = m_rEventTable.cEvents;

        if (m_dwFlags & DELIVER_OFFLINE_FLAGS)
        {
            COfflineTask *pOfflineTask = new COfflineTask();
            if (pOfflineTask)
            {
                // Initialize the offline task
                if (SUCCEEDED(hr = pOfflineTask->Init(m_dwFlags, (ISpoolerBindContext *) this)))
                {
                    // Tell the task to build it's event list
                    hr = pOfflineTask->BuildEvents(m_pUI, pSpoolerAcct->pAccount, m_idFolder);
                }
                
                pOfflineTask->Release();    
            }
        }

        cEventsT = m_rEventTable.cEvents;
        m_cSyncEvent += (cEventsT - cEvents);
    }

    return (hr);
    }

STDMETHODIMP CSpoolerEngine::IsDialogMessage(LPMSG pMsg)
    {
    HRESULT hr=S_FALSE;
    EnterCriticalSection(&m_cs);
    if (ISFLAGSET(m_dwState, SPSTATE_BUSY) && (LONG)m_cCurEvent >= 0 && m_cCurEvent < m_rEventTable.cEvents && m_rEventTable.prgEvents[m_cCurEvent].pSpoolerTask)
       hr = m_rEventTable.prgEvents[m_cCurEvent].pSpoolerTask->IsDialogMessage(pMsg);
    LeaveCriticalSection(&m_cs);
    return hr;
    }

HRESULT CSpoolerEngine::_HrStartNextEvent(void)
{
    HRESULT        hr = S_OK;
    TCHAR          szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    TCHAR          szBuf2[CCHMAX_CONNECTOID + 2];

    EnterCriticalSection(&m_cs);

    // RAID-30804 Release the current task. This makes sure that objects like the pop3 object
    // release it's locks on the store.
    if ((LONG)m_cCurEvent >= 0 && m_cCurEvent < m_rEventTable.cEvents)
    {
        SafeRelease(m_rEventTable.prgEvents[m_cCurEvent].pSpoolerTask);
    }

    // Advance to the next event
    m_cCurEvent++;

    // Check to see if that pushes us over the edge
    if (m_cCurEvent >= m_rEventTable.cEvents)
    {
        _HrGoIdle();
    }
    else
    {
        LPSPOOLEREVENT pEvent = &m_rEventTable.prgEvents[m_cCurEvent];

        // Check to see if we need to connect first
        if (pEvent->dwConnType == CONNECTION_TYPE_RAS)
        {
            // Check to see if we need to connect
            if (m_cCurEvent == 0 || (0 != lstrcmpi(pEvent->szConnectoid, m_rEventTable.prgEvents[m_cCurEvent - 1].szConnectoid)) || S_OK != g_pConMan->CanConnect(pEvent->szConnectoid))
            {
                hr = _HrDoRasConnect(pEvent);

                if (hr == HR_E_OFFLINE || hr == HR_E_USER_CANCEL_CONNECT || hr == HR_E_DIALING_INPROGRESS)
                {
                    for (m_cCurEvent; m_cCurEvent < m_rEventTable.cEvents; m_cCurEvent++)
                    {
                        // Mark the event as cancelled
                        m_pUI->UpdateEventState(m_cCurEvent, IMAGE_WARNING, NULL, MAKEINTRESOURCE(idsStateCanceled));
                        
                        //This is a hack to not show errors. In this case we just want to behave as though this 
                        //operation succeeded.
                        m_rEventTable.cSucceeded++;
                        
                        // Check to see if we've found a different connection yet
                        if ((m_cCurEvent == m_rEventTable.cEvents - 1) || 
                             0 != lstrcmpi(m_rEventTable.prgEvents[m_cCurEvent].szConnectoid, m_rEventTable.prgEvents[m_cCurEvent + 1].szConnectoid))
                            break;
                    }
                }
                else 
                if (FAILED(hr))
                {
                    // We need to mark all the events for this connection as failed as
                    // well.
                    for (m_cCurEvent; m_cCurEvent < m_rEventTable.cEvents; m_cCurEvent++)
                    {
                        // Mark the event as failed
                        m_pUI->UpdateEventState(m_cCurEvent, IMAGE_ERROR, NULL, MAKEINTRESOURCE(idsStateFailed));                        

                        // Check to see if we've found a different connection yet
                        if ((m_cCurEvent == m_rEventTable.cEvents - 1) || 
                             0 != lstrcmpi(m_rEventTable.prgEvents[m_cCurEvent].szConnectoid, m_rEventTable.prgEvents[m_cCurEvent + 1].szConnectoid))
                            break;
                    }

                    // Insert an error for this failure
                    AthLoadString(idsRasErrorGeneralWithName, szRes, ARRAYSIZE(szRes));
                    wsprintf(szBuf, szRes, PszEscapeMenuStringA(m_rEventTable.prgEvents[m_cCurEvent].szConnectoid, szBuf2, sizeof(szBuf2) / sizeof(TCHAR)));
                    m_pUI->InsertError(m_cCurEvent, szBuf);
                    hr = E_FAIL;
                }

                if (hr != S_OK)
                {
                    // Move on to the next task
                    PostMessage(m_hwndUI, IMAIL_NEXTTASK, 0, 0);
                    goto exit;
                }
            }
        }

        if (FAILED(pEvent->pSpoolerTask->Execute(pEvent->eid, pEvent->dwTwinkie))) 
        {                   
            m_pUI->UpdateEventState(pEvent->eid, IMAGE_ERROR, NULL, MAKEINTRESOURCE(idsStateFailed));
            PostMessage(m_hwndUI, IMAIL_NEXTTASK, 0, 0);
        }
        else
            m_pUI->UpdateEventState(pEvent->eid, IMAGE_EXECUTE, NULL, MAKEINTRESOURCE(idsStateExecuting));
    }

exit:
    LeaveCriticalSection(&m_cs);

    //return (S_OK);
    return hr;
}


HRESULT CSpoolerEngine::_HrDoRasConnect(const LPSPOOLEREVENT pEvent)
    {
    HRESULT hr;
    HWND hwndParent = m_hwndUI;

    // Check to see if we already can connect
    hr = g_pConMan->CanConnect(pEvent->pAccount);
    if (S_OK == hr)
        return (S_OK);

    // Check to see if we're allowed to dial
    if (m_dwFlags & DELIVER_NODIAL)
        return (E_FAIL);

    if (m_dwFlags & DELIVER_DIAL_ALWAYS)
    {
        if (hr == HR_E_OFFLINE)
        {
            g_pConMan->SetGlobalOffline(FALSE);
            m_fOfflineWhenDone = TRUE;
        }
    }

    // Check to see if the parent window exists and is visible
    if (!IsWindow(hwndParent) || !IsWindowVisible(hwndParent))
    {

        // Parent the UI to the browser window
        hwndParent = FindWindowEx(NULL, NULL, c_szBrowserWndClass, 0);
    }

    // Try to connect
    hr = g_pConMan->Connect(pEvent->pAccount, hwndParent, TRUE);
    if (S_OK == hr)
        {
        m_fIDialed = TRUE;
        return S_OK;
        }
    else
        return hr;
    }

HRESULT CSpoolerEngine::_HrGoIdle(void)
    {
    EnterCriticalSection(&m_cs);

    // We need to hangup every time to be compatible with OE4. Bug# 75222
    if (m_fRasSpooled && g_pConMan)
    {
        if (!!DwGetOption(OPT_DIALUP_HANGUP_DONE))
        {
            g_pConMan->Disconnect(m_hwndUI, FALSE, FALSE, FALSE);
        }
    }

    // Check to see if we need to go offline now
    // I'm disabling this for bug #17578.
    if (m_fOfflineWhenDone)
    {
        g_pConMan->SetGlobalOffline(TRUE);
        m_fOfflineWhenDone = FALSE;
    }

    // Tell the UI to idle
    if (ISFLAGSET(m_dwState, SPSTATE_CANCEL))
        m_pUI->GoIdle(m_dwState, ISFLAGSET(m_dwState, SPSTATE_SHUTDOWN), FALSE);
    else
        m_pUI->GoIdle(m_rEventTable.cSucceeded != m_rEventTable.cEvents, ISFLAGSET(m_dwState, SPSTATE_SHUTDOWN),
                        m_fNoSyncEvent && 0 == (m_dwFlags & DELIVER_BACKGROUND));

    // If we're running background and there was errors, then we should show the UI
    if (m_dwFlags & DELIVER_BACKGROUND && !(m_dwFlags & DELIVER_NOUI) &&
        m_rEventTable.cSucceeded != m_rEventTable.cEvents)
        {
        m_pUI->ShowWindow(SW_SHOW);
        SetForegroundWindow(m_hwndUI);
        }

    // Free the event table
    for (UINT i = 0; i < m_rEventTable.cEvents; i++)
        {
        SafeRelease(m_rEventTable.prgEvents[i].pSpoolerTask);
        SafeRelease(m_rEventTable.prgEvents[i].pAccount);
        }

    SafeMemFree(m_rEventTable.prgEvents);
    ZeroMemory(&m_rEventTable, sizeof(SPOOLEREVENTTABLE));

    // Leave the busy state
    FLAGCLEAR(m_dwState, SPSTATE_CANCEL);
    FLAGCLEAR(m_dwState, SPSTATE_BUSY);

    // Notify
    Notify(DELIVERY_NOTIFY_ALLDONE, 0);

    // Is Something Queued, and the current poll was a success ?
    if (!ISFLAGSET(m_dwState, SPSTATE_SHUTDOWN))
        {
        if (m_rEventTable.cSucceeded == m_rEventTable.cEvents && m_dwQueued)
            StartDelivery(NULL, NULL, FOLDERID_INVALID, m_dwQueued);
        else
            _StartPolling();
        }

    // Nothing is queued now
    m_dwQueued = 0;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Added Bug# 62129 (v-snatar)
    SetEvent(hSmapiEvent);
    
    return (S_OK);
    }

// ------------------------------------------------------------------------------------
// CSpoolerEngine::_DoBackgroundPoll
// ------------------------------------------------------------------------------------
void CSpoolerEngine::_DoBackgroundPoll(void)
{
    BOOL    fFound = FALSE;
    ULONG   i;
    DWORD   dw;
    DWORD   dwFlags = 0;

    dw = DwGetOption(OPT_DIAL_DURING_POLL);

    switch (dw)
    {
        case DIAL_ALWAYS:
        {
            //connect always
            if (g_pConMan && g_pConMan->IsGlobalOffline())
            {
                g_pConMan->SetGlobalOffline(FALSE);
                m_fOfflineWhenDone = TRUE;
            }
            dwFlags = DELIVER_BACKGROUND_POLL_DIAL_ALWAYS;
            break;
        }

        case DIAL_IF_NOT_OFFLINE: 
        case DO_NOT_DIAL:
        {
            if (g_pConMan && g_pConMan->IsGlobalOffline())
            {
                _StartPolling();
                return;
            }
            if (dw == DIAL_IF_NOT_OFFLINE)
            {
                dwFlags = DELIVER_BACKGROUND_POLL_DIAL;
            }
            else
            {
                dwFlags = DELIVER_BACKGROUND_POLL;
            }
            break;
        }

        default:
            dwFlags = DELIVER_BACKGROUND_POLL_DIAL_ALWAYS;
    }
    
    //We need this flag to tell the spooler that this polling is triggered by the timer.
    //In this case the spooler hangs up the phone if it dialed, irrespective of the option OPT_HANGUP_WHEN_DONE
    dwFlags |= DELIVER_AT_INTERVALS | DELIVER_OFFLINE_FLAGS;

    // Same thread we were created on...
    Assert(ISSPOOLERTHREAD);

    EnterCriticalSection(&m_cs);

    // Are there any registered views...
    for (i = 0; i < m_rViewRegister.cViewAlloc; i++)
    {
        // Is there a view handle
        if (m_rViewRegister.rghwndView[i] && IsWindow(m_rViewRegister.rghwndView[i]))
        {
            fFound=TRUE;
            break;
        }
    }

    LeaveCriticalSection(&m_cs);

    // If at least one view is registered we poll, otherwise we wait
    if (fFound)
    {
        StartDelivery(NULL, NULL, FOLDERID_INVALID, dwFlags);
    }
    else
        m_fBackgroundPollPending = TRUE;
}

void CSpoolerEngine::_StartPolling(void)
    {
    DWORD dw = DwGetOption(OPT_POLLFORMSGS);
    if (dw != OPTION_OFF)
        {
        KillTimer(m_hwndUI, IMAIL_POOLFORMAIL); 

        SetTimer(m_hwndUI, IMAIL_POOLFORMAIL, dw, NULL);
        }
    }

void CSpoolerEngine::_StopPolling(void)
    {
    KillTimer(m_hwndUI, IMAIL_POOLFORMAIL);
    }


STDMETHODIMP CSpoolerEngine::OnUIChange(BOOL fVisible)
    {
    EnterCriticalSection(&m_cs);

    // Check to see if we need to notify the tasks
    if (ISFLAGSET(m_dwState, SPSTATE_BUSY))
        {
        // Check to see if our flags are up to date
        if (fVisible)
            {
            FLAGCLEAR(m_dwFlags, DELIVER_NOUI);
            FLAGCLEAR(m_dwFlags, DELIVER_BACKGROUND);
            }
        else
            {
            FLAGSET(m_dwFlags, DELIVER_BACKGROUND);
            }

        for (UINT i = m_cCurEvent; i < m_rEventTable.cEvents; i++)
            {
            if (m_rEventTable.prgEvents[i].pSpoolerTask)
                {
                m_rEventTable.prgEvents[i].pSpoolerTask->OnFlagsChanged(m_dwFlags);
                }
            }
        }

    LeaveCriticalSection(&m_cs);

    return (S_OK);
    }

STDMETHODIMP CSpoolerEngine::OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, 
                                                CConnectionManager *pConMan)
{

    // If we're not busy, and the user has background polling turned on, then
    // we should fire a poll right now
    /* Bug# 75222
    if (nCode == CONNNOTIFY_CONNECTED && OPTION_OFF != DwGetOption(OPT_POLLFORMSGS))
    {
        if (!ISFLAGSET(m_dwState, SPSTATE_BUSY))
        {
            SendMessage(m_hwndUI, WM_TIMER, IMAIL_POOLFORMAIL, 0);
        }
    }
    */
    // If the user just chose "Work Offline", then we cancel anything that's in progress
    if (nCode == CONNNOTIFY_WORKOFFLINE && !!pvData)
    {
        if (ISFLAGSET(m_dwState, SPSTATE_BUSY))
        {
            Cancel();
        }
    }

    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\spengine.h ===
// --------------------------------------------------------------------------------
// Spengine.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __SPENGINE_H
#define __SPENGINE_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "spoolapi.h"
#include "imnact.h"
#include "conman.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
interface ILogFile;
interface IImnAccountManager;

// --------------------------------------------------------------------------------
// Spooler State
// --------------------------------------------------------------------------------
#define SPSTATE_INIT            FLAG01      // The spooler has been initialized
#define SPSTATE_BUSY            FLAG02      // The spooler is currently working
#define SPSTATE_CANCEL          FLAG03      // The user hit stop
#define SPSTATE_SHUTDOWN        FLAG04      // The spooler is shutting down
#define SPSTATE_UISHUTDOWN      FLAG05      // ::UIShutdown

// ------------------------------------------------------------------------------------
// NOTIFYTABLE
// ------------------------------------------------------------------------------------
typedef struct tagNOTIFYTABLE {
    ULONG               cAlloc;             // Number of array items allocated
    ULONG               cNotify;            // Number of registered views
    HWND               *prghwndNotify;      // Array of view who want notifications
} NOTIFYTABLE, *LPNOTIFYTABLE;

// ------------------------------------------------------------------------------------
// SPOOLERACCOUNT
// ------------------------------------------------------------------------------------
typedef struct tagSPOOLERACCOUNT {
    CHAR                szConnectoid[CCHMAX_CONNECTOID]; // RAS Connectoid Name
    DWORD               dwSort;             // Inverted Sort Index
    DWORD               dwConnType;         // CONNECTION_TYPE_XXXX (imnact.h)
    DWORD               dwServers;          // Support Server Types on this account
    IImnAccount        *pAccount;           // The Account Object
} SPOOLERACCOUNT, *LPSPOOLERACCOUNT;

// ------------------------------------------------------------------------------------
// ACCOUNTTABLE
// ------------------------------------------------------------------------------------
typedef struct tagACCOUNTTABLE {
    ULONG               cAccounts;          // cRasAccts + cLanAccts
    ULONG               cLanAlloc;          // Number of elements allocated;
    ULONG               cLanAccts;          // Number of valid lan/manual accounts
    ULONG               cRasAlloc;          // Number of elements allocated;
    ULONG               cRasAccts;          // Number of valid lan/manual accounts
    LPSPOOLERACCOUNT    prgLanAcct;         // Array of elements
    LPSPOOLERACCOUNT    prgRasAcct;         // Array of elements
} ACCOUNTTABLE, *LPACCOUNTTABLE;

// ------------------------------------------------------------------------------------
// SPOOLERTASKTYPE
// ------------------------------------------------------------------------------------
typedef enum tagSPOOLERTASKTYPE {
    TASK_POP3,                              // POP3 Task
    TASK_SMTP,                              // SMTP Task
    TASK_NNTP,                              // NNTP Task
    TASK_IMAP                               // IMAP Task
} SPOOLERTASKTYPE;

// ------------------------------------------------------------------------------------
// SPOOLEREVENT
// ------------------------------------------------------------------------------------
typedef struct tagSPOOLEREVENT {
    CHAR                szConnectoid[CCHMAX_CONNECTOID]; // RAS Connectoid Name
    DWORD               dwConnType;         // Connection Type
    IImnAccount        *pAccount;           // Account object for this task
    EVENTID             eid;                // Event ID
    ISpoolerTask       *pSpoolerTask;       // Pointer to Task Object
    DWORD_PTR           dwTwinkie;          // Event extra data
} SPOOLEREVENT, *LPSPOOLEREVENT;

// ------------------------------------------------------------------------------------
// SPOOLEREVENTTABLE
// ------------------------------------------------------------------------------------
typedef struct tagSPOOLEREVENTTABLE {
    DWORD               cEvents;
    DWORD               cSucceeded;
    DWORD               cEventsAlloc;
    LPSPOOLEREVENT      prgEvents;
} SPOOLEREVENTTABLE, *LPSPOOLEREVENTTABLE;

// ------------------------------------------------------------------------------------
// VIEWREGISTER
// ------------------------------------------------------------------------------------
typedef struct tagVIEWREGISTER {
    ULONG               cViewAlloc;     // Number of array items allocated
    HWND               *rghwndView;     // Array of view who want notifications
    ULONG               cView;          // Number of registered views
} VIEWREGISTER, *LPVIEWREGISTER;

#define     ALL_ACCT_SERVERS    0xffffffff

// --------------------------------------------------------------------------------
// CSpoolerEngine
// --------------------------------------------------------------------------------
#ifndef WIN16  // No RAS support in Win16
class CSpoolerEngine : public ISpoolerEngine, ISpoolerBindContext, IConnectionNotify
#else
class CSpoolerEngine : public ISpoolerEngine, ISpoolerBindContext
#endif
{
    friend HRESULT CreateThreadedSpooler(PFNCREATESPOOLERUI pfnCreateUI, ISpoolerEngine **ppSpooler, BOOL fPoll);

public:
    // ----------------------------------------------------------------------------
    // CSpoolerEngine
    // ----------------------------------------------------------------------------
    CSpoolerEngine(void);
    ~CSpoolerEngine(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // ISpoolerEngine members
    // ---------------------------------------------------------------------------
    STDMETHODIMP Init(ISpoolerUI *pUI, BOOL fPoll);
    STDMETHODIMP StartDelivery(HWND hwnd, LPCSTR pszAcctID, FOLDERID idFolder, DWORD dwFlags);
    STDMETHODIMP Close(void);
    STDMETHODIMP Advise(HWND hwndView, BOOL fRegister);
    STDMETHODIMP UpdateTrayIcon(TRAYICONTYPE type);
    STDMETHODIMP GetThreadInfo(LPDWORD pdwThreadId, HTHREAD* phThread);
    STDMETHODIMP OnStartupFinished(void);

    // ---------------------------------------------------------------------------
    // ISpoolerBindContext members
    // ---------------------------------------------------------------------------
    STDMETHODIMP RegisterEvent(LPCSTR pszDescription, ISpoolerTask *pTask, DWORD_PTR dwTwinkie, 
                               IImnAccount *pAccount, LPEVENTID peid);
    STDMETHODIMP EventDone(EVENTID eid, EVENTCOMPLETEDSTATUS status);
    STDMETHODIMP BindToObject(REFIID riid, void **ppvObject);
    STDMETHODIMP TaskFromEventId(EVENTID eid, ISpoolerTask *ppTask);
    STDMETHODIMP OnWindowMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP Cancel(void);
    STDMETHODIMP Notify(DELIVERYNOTIFYTYPE notify, LPARAM lParam);
    STDMETHODIMP IsDialogMessage(LPMSG pMsg);
    STDMETHODIMP PumpMessages(void);
    STDMETHODIMP UIShutdown(void);
    STDMETHODIMP OnUIChange(BOOL fVisible);
    STDMETHODIMP_(LRESULT) QueryEndSession(WPARAM wParam, LPARAM lParam);

#ifndef WIN16  // No RAS support in Win16
    // ---------------------------------------------------------------------------
    // IConnectionNotify
    // ---------------------------------------------------------------------------
    STDMETHODIMP OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, CConnectionManager *pConMan);
#endif //!WIN16


    // ---------------------------------------------------------------------------
    // CSpoolerEngine members
    // ---------------------------------------------------------------------------
    HRESULT Shutdown(void);

private:
    // ---------------------------------------------------------------------------
    // Private Members
    // ---------------------------------------------------------------------------
    HRESULT _HrStartDeliveryActual(DWORD dwFlags);
    HRESULT _HrAppendAccountTable(LPACCOUNTTABLE pTable, LPCSTR pszAcctID, DWORD    dwServers);
    HRESULT _HrAppendAccountTable(LPACCOUNTTABLE pTable, IImnAccount *pAccount, DWORD dwServers);
#ifndef WIN16  // No RAS support in Win16
    void _InsertRasAccounts(LPACCOUNTTABLE pTable, LPCSTR pszConnectoid, DWORD dwSrvTypes);
    void _SortAccountTableByConnName(LONG left, LONG right, LPSPOOLERACCOUNT prgRasAcct);
#endif
    HRESULT _HrCreateTaskObject(LPSPOOLERACCOUNT pSpoolerAcct);
    HRESULT _HrStartNextEvent(void);
    HRESULT _HrGoIdle(void);
    void _ShutdownTasks(void);
    void _DoBackgroundPoll(void);
    void _StartPolling(void);
    void _StopPolling(void);
    HRESULT _HrDoRasConnect(const LPSPOOLEREVENT pEvent);
    HRESULT _OpenMailLogFile(DWORD dwOptionId, LPCSTR pszPrefix, LPCSTR pszFileName, ILogFile **ppLogFile);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    ULONG               m_cRef;                     // Reference count
    DWORD               m_dwThreadId;               // Thread Id of this spooler
    HTHREAD             m_hThread;                  // Handle to my own thread
    ISpoolerUI         *m_pUI;                      // Spooler UI
    DWORD               m_dwState;                  // Spooler Engine State
    IImnAccountManager *m_pAcctMan;                 // The Account Manager
    IDatabase          *m_pUidlCache;               // POP3 uidl Cache
    DWORD               m_dwFlags;                  // Current DELIVERYFLAGS
    HWND                m_hwndUI;                   // Spooler Window
    LPSTR               m_pszAcctID;                // Work on a specific account
    FOLDERID            m_idFolder;                 // Work on a specific folder or group
    CRITICAL_SECTION    m_cs;                       // Thread Safety
    SPOOLEREVENTTABLE   m_rEventTable;              // Table of events
    BOOL                m_fBackgroundPollPending;
    VIEWREGISTER        m_rViewRegister;            // Registered Views
    DWORD               m_dwPollInterval;           // Duration between background polling
    HWND                m_hwndTray;                 // The tray icon window
    DWORD               m_cCurEvent;                // Index of the currently executing event
    DWORD               m_dwQueued;                 // Queued Polling Flags
    BOOL                m_fRasSpooled;              // Use this for the Hangup when done options
    BOOL                m_fOfflineWhenDone;         // Toggle the Work Offline state after spool
    ILogFile           *m_pPop3LogFile;
    ILogFile           *m_pSmtpLogFile;
    BOOL                m_fIDialed;
    DWORD               m_cSyncEvent;
    BOOL                m_fNoSyncEvent;
};

#endif // __SPENGINE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\spooler\spoolui.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     spoolui.cpp
//
//  PURPOSE:    Implements the spooler UI dialogs.
//

#include "pch.hxx"
#include "resource.h"
#include "spoolui.h"
#include "goptions.h"
#include "imnact.h"
#include "thormsgs.h"
#include "shlwapip.h" 
#include "spengine.h"
#include "ourguid.h"
#include "demand.h"
#include "menures.h"
#include "multiusr.h"

ASSERTDATA

static const char c_szWndProc[] = "WndProc";

//
//  FUNCTION:   CSpoolerDlg::CSpoolerDlg()
//
//  PURPOSE:    Initializes the member variables of the spooler ui object.
//
CSpoolerDlg::CSpoolerDlg()
    {
    m_cRef = 1;
    
    m_pBindCtx = NULL;
    
    m_hwnd = NULL;
    m_hwndOwner = NULL;
    m_hwndEvents = NULL;
    m_hwndErrors = NULL;
    
    InitializeCriticalSection(&m_cs);
   
    m_himlImages = NULL;

    m_fTack = FALSE;
    m_iTab = 0;
    m_fIdle = FALSE;
    m_fErrors = FALSE;
    m_fShutdown = FALSE;
    m_fSaveSize = FALSE;

    m_fExpanded = TRUE;
    ZeroMemory(&m_rcDlg, sizeof(RECT));
    m_cyCollapsed = 0;

    m_szCount[0] = '\0';
    
    m_hIcon=NULL;
    m_hIconSm=NULL;
    m_dwIdentCookie = 0;
    }

//
//  FUNCTION:   CSpoolerDlg::~CSpoolerDlg()
//
//  PURPOSE:    Frees any resources allocated during the life of the class.
//
CSpoolerDlg::~CSpoolerDlg()
    {
    GoIdle(TRUE, FALSE, FALSE);

    if (m_hwnd && IsWindow(m_hwnd))
        DestroyWindow(m_hwnd);
    if (m_himlImages)
        ImageList_Destroy(m_himlImages);
    SafeRelease(m_pBindCtx);
    DeleteCriticalSection(&m_cs);
    if (m_hIcon)
        SideAssert(DestroyIcon(m_hIcon));
    if (m_hIconSm)
        SideAssert(DestroyIcon(m_hIconSm));

    }


//
//  FUNCTION:   CSpoolerDlg::Init()
//
//  PURPOSE:    Creates the spooler dialog.  The dialog is not initially 
//              visible.
//
//  PARAMETERS:
//      <in> hwndOwner - Handle of the window to parent the dialog to.
//
//  RETURN VALUE:
//      S_OK - The dialog was created and initialized
//      E_OUTOFMEMORY - The dialog could not be created
//      E_INVALIDARG - Think about it.
//
HRESULT CSpoolerDlg::Init(HWND hwndOwner)
    {
    int iReturn = -1;
    HWND hwnd, hwndActive;
    
    // Verify the arguments
    if (!IsWindow(hwndOwner))
        return (E_INVALIDARG);
    
    // Make a copy    
    m_hwndOwner = hwndOwner;
    
    // Invoke the dialog
    hwndActive = GetForegroundWindow();

    hwnd = CreateDialogParam(g_hLocRes, MAKEINTRESOURCE(iddSpoolerDlg), m_hwndOwner,
           SpoolerDlgProc, (LPARAM) this);

    if (hwndActive != GetForegroundWindow())
        SetForegroundWindow(hwndActive);

    // Set the dialog icon
    m_hIcon = (HICON) LoadImage(g_hLocRes, MAKEINTRESOURCE(idiMail), IMAGE_ICON, 32, 32, 0);
    SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
    m_hIconSm = (HICON) LoadImage(g_hLocRes, MAKEINTRESOURCE(idiMail), IMAGE_ICON, 16, 16, 0);
    SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

    SetTaskCounts(0, 0);

    // Register with identity manager
    SideAssert(SUCCEEDED(MU_RegisterIdentityNotifier((IUnknown *)(ISpoolerUI *)this, &m_dwIdentCookie)));

    return (IsWindow(hwnd) ? S_OK : E_OUTOFMEMORY);
    }
    
    
HRESULT CSpoolerDlg::QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
    if (NULL == *ppvObj)
        return (E_INVALIDARG);
        
    *ppvObj = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID)(IUnknown *)(ISpoolerUI *) this;
    
    else if (IsEqualIID(riid, IID_ISpoolerUI))
        *ppvObj = (LPVOID)(ISpoolerUI *) this;

    else if (IsEqualIID(riid, IID_IIdentityChangeNotify))
        *ppvObj = (LPVOID)(IIdentityChangeNotify *) this;

    if (NULL == *ppvObj)    
        return (E_NOINTERFACE);
    
    AddRef();
    return (S_OK);    
    }


ULONG CSpoolerDlg::AddRef(void)
    {
    m_cRef++;
    return (m_cRef);
    }    


ULONG CSpoolerDlg::Release(void)
    {
    ULONG cRefT = --m_cRef;
    
    if (0 == m_cRef)
        delete this;
    
    return (cRefT);    
    }


//
//  FUNCTION:   CSpoolerDlg::RegisterBindContext()
//
//  PURPOSE:    Allows the spooler engine to provide us with a bind context
//              interface for us to call back into.
//
//  PARAMETERS:
//      <in> pBindCtx - Pointer to the engine's bind context interface
//
//  RETURN VALUE:
//      E_INVALIDARG
//      S_OK
//
HRESULT CSpoolerDlg::RegisterBindContext(ISpoolerBindContext *pBindCtx)
    {
    if (NULL == pBindCtx)
        return (E_INVALIDARG);
    
    EnterCriticalSection(&m_cs);    
    
    m_pBindCtx = pBindCtx;
    m_pBindCtx->AddRef();
    
    LeaveCriticalSection(&m_cs);
    
    return (S_OK);    
    }


//
//  FUNCTION:   CSpoolerDlg::InsertEvent()
//
//  PURPOSE:    Allows a caller to insert an event into our event list UI.
//
//  PARAMETERS:
//      <in> eid - Event ID for this new event
//      <in> pszDescription - Description of the event
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//      E_OUTOFMEMORY
//
HRESULT CSpoolerDlg::InsertEvent(EVENTID eid, LPCTSTR pszDescription, 
                                 LPCWSTR pwszConnection)
{
    HRESULT hr=S_OK;
    LV_ITEM lvi;
    int     iItem = -1;
    TCHAR   szRes[CCHMAX_STRINGRES];
    
    // Verify the arguments
    if (0 == pszDescription)
        return (E_INVALIDARG);

    EnterCriticalSection(&m_cs);    
    
    // Make sure the listview has been initialized
    if (!IsWindow(m_hwndEvents))    
        hr = SP_E_UNINITIALIZED;    
    else
    {
        // Insert the item into the listview
        ZeroMemory(&lvi, sizeof(LV_ITEM));
        lvi.mask     = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        lvi.iItem    = ListView_GetItemCount(m_hwndEvents);
        lvi.iSubItem = 0;
        lvi.lParam   = (LPARAM) eid;
        lvi.iImage   = IMAGE_BLANK;
        
        if (IS_INTRESOURCE(pszDescription))
        {
            AthLoadString(PtrToUlong(pszDescription), szRes, ARRAYSIZE(szRes));
            lvi.pszText = szRes;
        }
        else
            lvi.pszText  = (LPTSTR) pszDescription;

        iItem = ListView_InsertItem(m_hwndEvents, &lvi);    
        Assert(iItem != -1);
        if (iItem == -1)    
            hr = E_OUTOFMEMORY;
        else
        {
            LVITEMW     lviw = {0};
            
            lviw.iSubItem = 2;
            lviw.pszText  = (LPWSTR)pwszConnection;
            SendMessage(m_hwndEvents, LVM_SETITEMTEXTW, (WPARAM)iItem, (LPARAM)&lviw);
        }
    }

    LeaveCriticalSection(&m_cs);
       
    return hr;
}    

    
//
//  FUNCTION:   CSpoolerDlg::InsertError()
//
//  PURPOSE:    Allows a task to insert an error into our error list UI.
//
//  PARAMETERS:
//      <in> eid      - The event ID of the event that had the error.
//      <in> pszError - Description of the error. 
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//      E_OUTOFMEMORY
//
HRESULT CSpoolerDlg::InsertError(EVENTID eid, LPCTSTR pszError)
    {
    HRESULT  hr = S_OK;
    LBDATA  *pData = NULL;
    int      nItem;
    HDC      hdc;
    HFONT    hfont;

    // Verify the arguments
    if (0 == pszError)
        return (E_INVALIDARG);

    EnterCriticalSection(&m_cs);    
    
    // Make sure the listview has been initialized
    if (!IsWindow(m_hwndErrors))    
        hr = SP_E_UNINITIALIZED;    
    else
        {
        // Allocate a struct for the item data
        if (!MemAlloc((LPVOID *) &pData, sizeof(LBDATA)))
            {
            hr = E_OUTOFMEMORY;
            goto exit;
            }

        pData->eid = eid;

        // Check to see if we need to load the string ourselves
        if (IS_INTRESOURCE(pszError))
            {
            pData->pszText = AthLoadString(PtrToUlong(pszError), 0, 0);
            }
        else
            pData->pszText = PszDupA(pszError);

        // Get the size of the string
        hfont = (HFONT) SendMessage(m_hwnd, WM_GETFONT, 0, 0);

        hdc = GetDC(m_hwndErrors);
        SelectFont(hdc, hfont);

        SetRect(&(pData->rcText), 0, 0, m_cxErrors - BULLET_WIDTH - 4, 0);
        // bug #47453, add DT_INTERNAL flag so that on FE platform (PRC and TC)
        // two list items is not overlapping. 
        DrawText(hdc, pData->pszText, -1, &(pData->rcText), DT_CALCRECT | DT_WORDBREAK | DT_INTERNAL);
        ReleaseDC(m_hwndErrors, hdc);

        pData->rcText.bottom += 4;
        
        // Add the item data
        nItem = ListBox_AddItemData(m_hwndErrors, pData);    
        }

exit:
    LeaveCriticalSection(&m_cs);    
    return hr;
    }


//
//  FUNCTION:   CSpoolerDlg::UpdateEventState()
//
//  PURPOSE:    Allows a task to update the description and state of an event.
//
//  PARAMETERS:
//      <in> eid            - ID of the event to update
//      <in> nImage         - Image to display for the item.  If this is -1, 
//                            the image is not changed.
//      <in> pszDescription - Description for the item.  If this is NULL, the 
//                            description is not changed.
//      <in> pszStatus      - Status of the item.  If this is NULL, the status
//                            is not changed.
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//      SP_E_EVENTNOTFOUND
//      E_UNEXPECTED
//
HRESULT CSpoolerDlg::UpdateEventState(EVENTID eid, INT nImage, 
                                      LPCTSTR pszDescription, LPCTSTR pszStatus)
    {
    LV_ITEM     lvi;
    LV_FINDINFO lvfi;
    int         iItem = -1;
    BOOL        fSuccess = FALSE;
    HRESULT     hr = S_OK;
    TCHAR       szRes[CCHMAX_STRINGRES];
    
    EnterCriticalSection(&m_cs);

    ZeroMemory(&lvi, sizeof(LV_ITEM));

    // See if we're initialized
    if (!IsWindow(m_hwndEvents))
        {
        hr = SP_E_UNINITIALIZED;
        goto exit;
        }
    
    // Start by finding the event in our list
    lvfi.flags  = LVFI_PARAM;
    lvfi.psz    = 0;
    lvfi.lParam = eid;    
    
    iItem = ListView_FindItem(m_hwndEvents, -1, &lvfi);
    if (-1 == iItem)
        {
        hr = SP_E_EVENTNOTFOUND;
        goto exit;
        }
    
    // Update the image and description
    lvi.mask = 0;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;    
    
    // Set up the image info
    if (-1 != nImage)    
        {
        lvi.mask = LVIF_IMAGE;
        lvi.iImage = nImage;
        }
        
    // Set up the description text
    if (NULL != pszDescription)
        {
        // Check to see if we need to load the string ourselves
        if (IS_INTRESOURCE(pszDescription))
            {
            AthLoadString(PtrToUlong(pszDescription), szRes, ARRAYSIZE(szRes));
            lvi.pszText = szRes;
            }
        else
            lvi.pszText  = (LPTSTR) pszDescription;

        lvi.mask |= LVIF_TEXT;
        }
    
    if (lvi.mask)
        fSuccess = ListView_SetItem(m_hwndEvents, &lvi);
    
    // Update the status
    if (NULL != pszStatus)
        {
        // Check to see if we need to load the string ourselves
        if (IS_INTRESOURCE(pszStatus))
            {
            AthLoadString(PtrToUlong(pszStatus), szRes, ARRAYSIZE(szRes));
            lvi.pszText = szRes;
            }
        else
            lvi.pszText  = (LPTSTR) pszStatus;

        lvi.mask     = LVIF_TEXT;
        lvi.iSubItem = 1;           
        
        ListView_SetItemText(m_hwndEvents, lvi.iItem, 1, lvi.pszText); /* fSuccess = fSuccess && */
        }
        
    hr = fSuccess ? S_OK : E_UNEXPECTED;

exit:
    LeaveCriticalSection(&m_cs);
    return (hr);
    }


//
//  FUNCTION:   CSpoolerDlg::SetProgressRange()
//
//  PURPOSE:    Resets the progress bar to zero, and then sets the upper bound
//              to the specified amount.
//
//  PARAMETERS:
//      <in> wMax - New maximum range for the progress bar
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::SetProgressRange(WORD wMax)
    {
    HWND    hwndProg = GetDlgItem(m_hwnd, IDC_SP_PROGRESS_BAR);
    HRESULT hr = S_OK;
    
    if (wMax == 0)
        return (E_INVALIDARG);
    
    EnterCriticalSection(&m_cs);

    // Make sure we have a progress bar
    if (!IsWindow(hwndProg))
        hr = SP_E_UNINITIALIZED;
    else
        {
        // Reset the progress bar    
        SendMessage(hwndProg, PBM_SETPOS, 0, 0);
    
        // Set the new range
        SendMessage(hwndProg, PBM_SETRANGE, 0, MAKELPARAM(0, wMax));
        }
    
    LeaveCriticalSection(&m_cs);    
    return (hr);
    }


//
//  FUNCTION:   CSpoolerDlg::IncrementProgress()
//
//  PURPOSE:    Increments the progress bar by a specified amount.
//
//  PARAMETERS:
//      <in> wDelta - Amount to increment the progress bar by
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::IncrementProgress(WORD wDelta)
    {
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cs);
    
    if (!IsWindow(m_hwnd))
        hr = SP_E_UNINITIALIZED;
    else        
        SendDlgItemMessage(m_hwnd, IDC_SP_PROGRESS_BAR, PBM_DELTAPOS, wDelta, 0);

    LeaveCriticalSection(&m_cs);    
    return (hr);
    }


//
//  FUNCTION:   CSpoolerDlg::SetProgressPosition()
//
//  PURPOSE:    Sets the progress bar to a specific position.
//
//  PARAMETERS:
//      <in> wPos - Position to set progress bar to
//
//  RETURN VALUE:
//      E_INVALIDARG
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::SetProgressPosition(WORD wPos)
    {
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cs);
    
    if (wPos < 0)
        hr = E_INVALIDARG;
    else if (!IsWindow(m_hwnd))
        hr = SP_E_UNINITIALIZED;
    else
        SendDlgItemMessage(m_hwnd, IDC_SP_PROGRESS_BAR, PBM_SETPOS, wPos, 0);

    LeaveCriticalSection(&m_cs);
    return (hr);
    }

//
//  FUNCTION:   CSpoolerDlg::SetGeneralProgress()
//
//  PURPOSE:    Allows the caller to update the general progress text.
//
//  PARAMETERS:
//      <in> pszProgress - New progress string
//
//  RETURN VALUE:
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::SetGeneralProgress(LPCTSTR pszProgress)
    {
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cs);

    if (!IsWindow(m_hwnd))
        hr = SP_E_UNINITIALIZED;
    else
        {
        if (pszProgress)
            SetDlgItemText(m_hwnd, IDC_SP_GENERAL_PROG, pszProgress);
        else
            SetDlgItemText(m_hwnd, IDC_SP_GENERAL_PROG, _T(""));
        }

    LeaveCriticalSection(&m_cs);    
    return (hr);    
    }    


//
//  FUNCTION:   CSpoolerDlg::SetSpecificProgress()
//
//  PURPOSE:    Allows the caller to update the specific progress text.
//
//  PARAMETERS:
//      <in> pszProgress - New progress string
//
//  RETURN VALUE:
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::SetSpecificProgress(LPCTSTR pszProgress)
    {
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cs);

    if (!IsWindow(m_hwnd))
        hr = SP_E_UNINITIALIZED;
    else
        {
        TCHAR szRes[CCHMAX_STRINGRES];
        if (IS_INTRESOURCE(pszProgress))
            {
            AthLoadString(PtrToUlong(pszProgress), szRes, ARRAYSIZE(szRes));
            pszProgress = szRes;
            }

        if (pszProgress)
            SetDlgItemText(m_hwnd, IDC_SP_SPECIFIC_PROG, pszProgress);
        else
            SetDlgItemText(m_hwnd, IDC_SP_SPECIFIC_PROG, _T(""));
        }
    
    LeaveCriticalSection(&m_cs);    
    return (hr);
    }    


//
//  FUNCTION:   CSpoolerDlg::SetAnimation()
//
//  PURPOSE:    Allows the caller to choose which animation is playing
//
//  PARAMETERS:
//      <in> nAnimationID - New resource id for the animation
//      <in> fPlay - TRUE if we should start animating it.
//
//  RETURN VALUE:
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::SetAnimation(int nAnimationID, BOOL fPlay)
    {
    HRESULT hr = S_OK;
    HWND    hwndAni;

    EnterCriticalSection(&m_cs);
#ifndef _WIN64
    if (!IsWindow(m_hwnd) || !IsWindow(GetDlgItem(m_hwnd, IDC_SP_ANIMATE)))
        hr = SP_E_UNINITIALIZED;
    else
        {
        hwndAni = GetDlgItem(m_hwnd, IDC_SP_ANIMATE);
        Animate_Close(hwndAni);

        if (IsWindow(m_hwnd) && IsWindow(GetDlgItem(m_hwnd, IDC_SP_ANIMATE)))
            {
            Animate_OpenEx(hwndAni, g_hLocRes, MAKEINTRESOURCE(nAnimationID));

            if (fPlay)
                Animate_Play(hwndAni, 0, -1, -1);
            }
        }
#endif // _WIN64    
    LeaveCriticalSection(&m_cs);    
    return (hr);
    }    


//
//  FUNCTION:   CSpoolerDlg::EnsureVisible()
//
//  PURPOSE:    Ensures that the specified event is visible within the listview
//
//  PARAMETERS:
//      <in> eid - Event ID to make sure is visible
//
//  RETURN VALUE:
//      SP_E_UNINITIALIZED
//      SP_E_EVENTNOTFOUND
//      S_OK
//
HRESULT CSpoolerDlg::EnsureVisible(EVENTID eid)
    {
    LV_FINDINFO lvfi;
    int         iItem = -1;
    HRESULT     hr = S_OK;
    
    EnterCriticalSection(&m_cs);

    // See if we're initialized
    if (!IsWindow(m_hwndEvents))
        hr = SP_E_UNINITIALIZED;
    else
        {
        // Start by finding the event in our list
        lvfi.flags  = LVFI_PARAM;
        lvfi.psz    = 0;
        lvfi.lParam = eid;
    
        iItem = ListView_FindItem(m_hwndEvents, -1, &lvfi);       
    
        // Now tell the listview to make sure it's visible
        if (-1 != iItem)
            ListView_EnsureVisible(m_hwndEvents, iItem, FALSE);

        hr = (iItem == -1) ? SP_E_EVENTNOTFOUND : S_OK;
        }
    
    LeaveCriticalSection(&m_cs);
    return (hr);
    }


//
//  FUNCTION:   CSpoolerDlg::ShowWindow()
//
//  PURPOSE:    Shows or hides the spooler dialog
//
//  PARAMETERS:
//      <in> nCmdShow - This is the same as the ShowWindow() API
//
//  RETURN VALUE:
//      SP_E_UNINITIALIZED
//      S_OK
//
HRESULT CSpoolerDlg::ShowWindow(int nCmdShow)
    {
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_cs);

    if (!IsWindow(m_hwnd))
        hr = SP_E_UNINITIALIZED;
    else
        {
        ::ShowWindow(m_hwnd, nCmdShow);
        if (m_pBindCtx)
            m_pBindCtx->OnUIChange(nCmdShow == SW_SHOW);
        }       

    LeaveCriticalSection(&m_cs);
    
    return (hr);
    }


//
//  FUNCTION:   CSpoolerDlg::StartDelivery()
//
//  PURPOSE:    Tells the dialog the delivery has begun.
//
//  RETURN VALUE:
//      S_OK
//      SP_E_UNINITIALIZED
//
HRESULT CSpoolerDlg::StartDelivery(void)
    {
    HRESULT hr = SP_E_UNINITIALIZED;

    EnterCriticalSection(&m_cs);

    if (IsWindow(m_hwnd))
        {
        //Animate_Play(GetDlgItem(m_hwnd, IDC_SP_ANIMATE), 0, -1, -1);
        
        TabCtrl_SetCurSel(GetDlgItem(m_hwnd, IDC_SP_TABS), TAB_TASKS);
        OnTabChange(0);

        ToggleStatics(FALSE);
        SetDlgItemText(m_hwnd, IDC_SP_GENERAL_PROG, _T(""));
        SetDlgItemText(m_hwnd, IDC_SP_SPECIFIC_PROG, _T(""));
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_STOP), FALSE);

        hr = S_OK;
        }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }


//
//  FUNCTION:   CSpoolerDlg::ClearEvents()
//
//  PURPOSE:    Clears any events and errors out of the listviews.
//
//  RETURN VALUE:
//      S_OK
//      SP_E_UNINITIALIZED
//
HRESULT CSpoolerDlg::ClearEvents(void)
    {
    HRESULT hr = SP_E_UNINITIALIZED;

    EnterCriticalSection(&m_cs);

    if (IsWindow(m_hwnd))
        {
        m_fErrors = FALSE;
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_STOP), FALSE);
        ListView_DeleteAllItems(m_hwndEvents);
        ListBox_ResetContent(m_hwndErrors);
        hr = S_OK;
        }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }


HRESULT CSpoolerDlg::SetTaskCounts(DWORD cSucceeded, DWORD cTotal)
    {
    TCHAR szBuf[CCHMAX_STRINGRES];
    HRESULT hr = SP_E_UNINITIALIZED;

    EnterCriticalSection(&m_cs);
    
    if (IsWindow(m_hwnd))
        {
        wsprintf(szBuf, m_szCount, cSucceeded, cTotal);
        SetDlgItemText(m_hwnd, IDC_SP_OVERALL_STATUS, szBuf);
        hr = S_OK;
        }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }


HRESULT CSpoolerDlg::AreThereErrors(void)
    {
    EnterCriticalSection(&m_cs);
    HRESULT hr = (m_fErrors ? S_OK : S_FALSE);
    LeaveCriticalSection(&m_cs);
    return hr;
    }

HRESULT CSpoolerDlg::Shutdown(void)
    {
    CHAR szRes[255];

    EnterCriticalSection(&m_cs);

    m_fShutdown = TRUE;

    if (IsWindow(m_hwnd))
        {
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_STOP), FALSE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_MINIMIZE), TRUE);

        LoadString(g_hLocRes, idsClose, szRes, ARRAYSIZE(szRes));
        SetDlgItemText(m_hwnd, IDC_SP_MINIMIZE, szRes);
        }

    LeaveCriticalSection(&m_cs);

    return S_OK;
    }

//
//  FUNCTION:   CSpoolerDlg::GoIdle()
//
//  PURPOSE:    Tells the dialog the delivery has ended.
//
//  PARAMETERS:
//      <in> fErrors - TRUE if errors occured during the download.
//
//  RETURN VALUE:
//      S_OK
//      SP_E_UNINITIALIZED
//
HRESULT CSpoolerDlg::GoIdle(BOOL fErrors, BOOL fShutdown, BOOL fNoSync)
    {
    HRESULT hr = SP_E_UNINITIALIZED;
    TCHAR   szRes[CCHMAX_STRINGRES];

    EnterCriticalSection(&m_cs);

    if (IsWindow(m_hwnd))
        {
        // Stop the animation
#ifndef _WIN64
        Animate_Close(GetDlgItem(m_hwnd, IDC_SP_ANIMATE));
#endif 
        hr = S_OK;

        ToggleStatics(TRUE);
        EnableWindow(GetDlgItem(m_hwnd, IDC_SP_STOP), FALSE);

        if (ISFLAGSET(fErrors, SPSTATE_CANCEL))
        {
            m_fErrors = TRUE;
            ExpandCollapse(TRUE);
            TabCtrl_SetCurSel(GetDlgItem(m_hwnd, IDC_SP_TABS), TAB_TASKS);
            OnTabChange(0);

            AthLoadString(idsSpoolerUserCancel, szRes, ARRAYSIZE(szRes));
            SetDlgItemText(m_hwnd, IDC_SP_IDLETEXT, szRes);
            SendDlgItemMessage(m_hwnd, IDC_SP_IDLEICON, STM_SETICON, 
                               (WPARAM) LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiError)), 0);
        }
        // Also if there were errors, we should switch to the error page
        else if (fErrors)
            {
            m_fErrors = TRUE;
            ExpandCollapse(TRUE);
            TabCtrl_SetCurSel(GetDlgItem(m_hwnd, IDC_SP_TABS), TAB_ERRORS);
            OnTabChange(0);

            AthLoadString(idsSpoolerIdleErrors, szRes, ARRAYSIZE(szRes));
            SetDlgItemText(m_hwnd, IDC_SP_IDLETEXT, szRes);
            SendDlgItemMessage(m_hwnd, IDC_SP_IDLEICON, STM_SETICON, 
                               (WPARAM) LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiError)), 0);
            }
        else
            {
            AthLoadString(idsSpoolerIdle, szRes, ARRAYSIZE(szRes));
            SetDlgItemText(m_hwnd, IDC_SP_IDLETEXT, szRes);
            SendDlgItemMessage(m_hwnd, IDC_SP_IDLEICON, STM_SETICON, 
                               (WPARAM) LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiMailNews)), 0);

            if (fNoSync)
                AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsNothingToSync), NULL, MB_OK | MB_ICONEXCLAMATION);

            // Determine if we need to hide the dialog
            UINT state = (UINT) SendDlgItemMessage(m_hwnd, IDC_SP_TOOLBAR, TB_GETSTATE, IDC_SP_TACK, 0);
            if (!(state & TBSTATE_CHECKED))
                ShowWindow(SW_HIDE);
            }
        }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }


//
//  FUNCTION:   CSpoolerDlg::IsDialogMessage()
//
//  PURPOSE:    Allows the dialog to retrieve messages from the message loop.
//
//  PARAMETERS:
//      <in> pMsg - Pointer to the message for us to examine.
//
//  RETURN VALUE:
//      Returns S_OK if we eat the message, S_FALSE otherwise.
//
HRESULT CSpoolerDlg::IsDialogMessage(LPMSG pMsg)
    {
    HRESULT hr;
    BOOL    fEaten = FALSE;
    BOOL    fBack = FALSE;
    
    EnterCriticalSection(&m_cs);

    // Intended for modeless timeout dialog running on this thread?
    HWND hwndTimeout = (HWND)TlsGetValue(g_dwTlsTimeout);
    if (hwndTimeout && ::IsDialogMessage(hwndTimeout, pMsg))
        return(S_OK);

    if (pMsg->message == WM_KEYDOWN && (GetAsyncKeyState(VK_CONTROL) < 0))
        {
        switch (pMsg->wParam)
            {
            case VK_TAB:
                fBack = GetAsyncKeyState(VK_SHIFT) < 0;
                break;

            case VK_PRIOR:  // VK_PAGE_UP
            case VK_NEXT:   // VK_PAGE_DOWN
                fBack = (pMsg->wParam == VK_PRIOR);
                break;

            default:
                goto NoKeys;
            }

        int iCur = TabCtrl_GetCurSel(GetDlgItem(m_hwnd, IDC_SP_TABS));

        // tab in reverse if shift is down
        if (fBack)
            iCur += (TAB_MAX - 1);
        else
            iCur+