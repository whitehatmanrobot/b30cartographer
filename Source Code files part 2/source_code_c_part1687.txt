kard
|
| history:
|   25-Jul-1997 <rbkunz> created.
|
\*---------------------------------------------------------------------------*/

// Application Includes Section.
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>

#define C_RUNTIME_IO_ERROR -1
#define C_RUNTIME_SEEK_ERROR -1L

#define NT_VER_5 5
#define NT_VER_4 4

#define MAX_ARGS 3

#define MAX_RESBUF  128

#define IDS_ERR_FORMAT      1
#define IDS_ERR_ERROR       2
#define IDS_ERR_GENERIC     3
#define IDS_ERR_BADCAB      4
#define IDS_ERR_INVPARM     5
#define IDS_ERR_NOMEM       6
#define IDS_ERR_INVNAME     7
#define IDS_ERR_NODAT       8
#define IDS_ERR_CABFAIL     9
#define IDS_ERR_NOPRTUI    10
#define IDS_ERR_PRTUIENTRY 11
#define IDS_ERR_PRTUIFAIL  12
#define IDS_ERR_NOSUPPORT  13



typedef struct _FILENODE {
    PTSTR               pFileName;
    struct _FILENODE *  pNextFile;
} FILENODE, *PFILENODE;

typedef struct {
    PTSTR       pFullCABPath;
    PTSTR       pCABDir;
    PTSTR       pCABName;
    PTSTR       pTempDir;
    PFILENODE   pFileList;
} WPNPINFO, *PWPNPINFO;


// Local function declarations
//
BOOL    AdjustFileTime( INT_PTR hf, USHORT date, USHORT time );
DWORD   Attr32FromAttrFAT( WORD attrMSDOS );
LPWSTR  WCFromMB(LPCSTR lpszStr);
LPWSTR  WCFromTC(LPCTSTR lpszStr);
LPTSTR  BuildFileName(LPCTSTR lpszPath, LPCTSTR lpszName);
LPTSTR  FindRChar(LPTSTR lpszStr, CHAR cch);
LPTSTR  GetDirectory(LPTSTR lpszFile, LPDWORD lpdwReturn);
LPTSTR  GetName(LPTSTR lpszFile, LPDWORD ldwReturn);

#if 0
// These 4 functions are (probably) not needed anymore
// We will call printUI, and printUI will call SetupX API's to verify files via a catalog file
//
BOOL    RemoveExecutableFiles(PWPNPINFO pInfo);
BOOL    IsExecutableFile(PTSTR pFile);
DWORD   CheckFile(PTSTR lpszFile, LPDWORD lpAuthError);
DWORD   VerifyFiles(PWPNPINFO pInfo, LPDWORD lpAuthError);
#endif

PTSTR   GetCABName(PTSTR pCmdLine, LPDWORD lpdwReturn);
BOOL    AddFileToList(PWPNPINFO pInfo, PTSTR lpszFile);
VOID    CleanupFileList(PWPNPINFO pInfo);
BOOL    Extract(PWPNPINFO pInfo);
LPTSTR  GetWPNPSetupLibName(LPDWORD lpdwReturn);
DWORD   InvokePrintWizard(PWPNPINFO pInfo, LPDWORD lpAuthError);
DWORD   WebPnPCABInstall(LPTSTR lpszCABName, LPDWORD lpAuthError);
LPCTSTR LookupErrorString(DWORD dwErrorCode);
VOID    CheckErrors(DWORD dwErrorCode, DWORD dwAuthError);

INT WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\thunk\win95\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
#***************************************************************************/

buildall:
    cd..   
    nmake /f makefile.inc
    cd $(ALT_PROJECT_TARGET)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\thunk\makefile.inc ===
PROJPATH=win95\obj\i386


all: $(PROJPATH)\32to16.asm $(PROJPATH)\thk32.obj $(PROJPATH)\thk16.obj

$(PROJPATH)\32to16.asm: 32to16.thk
    thunk /p1 /P1 -t thk 32to16.thk -o $(PROJPATH)\32to16.asm

$(PROJPATH)\thk32.obj: $(PROJPATH)\32to16.asm
    ml /DIS_32 /c /W3 /nologo /coff /Fo $(PROJPATH)\thk32.obj $(PROJPATH)\32to16.asm

$(PROJPATH)\thk16.obj: $(PROJPATH)\32to16.asm
    ml /DIS_16 /c /W3 /nologo /Fo $(PROJPATH)\thk16.obj $(PROJPATH)\32to16.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\inc\lpsi.h ===
/***************************************************************************
  *
  * File Name: LPSI.H
  *
  * Copyright Hewlett-Packard Company 1997 
  * All rights reserved.
  *
  * 11311 Chinden Blvd.
  * Boise, Idaho  83714
  *
  *   
  * Description: contains macros, the SETUPINFO structure and other 
  * definitions for WPNPINST.DLL
  *
  * Author:  Garth Schmeling
  *
  * Modification history:
  *
  * Date		Initials		Change description
  *
  * 10-10-97	GFS				Initial checkin
  *
  *
  *
  ***************************************************************************/

#ifndef _LPSI_H_
#define _LPSI_H_

//---------------------------------------------------------
// Macros
//---------------------------------------------------------
#define _MAX_NAME_              32
#define _MAX_PATH_              256
#define MAX_COLOR_PATH          30
#define MAX_DEVICE_ID_LEN		200
#define NSTRINGS                6
#define CMD_INSTALL_DRIVER		373

#define IS                      ==
#define ISNT                    !=
#define OR                      ||
#define AND                     &&


//---------------------------------------------------------
// Setup Info Structure
//---------------------------------------------------------
#pragma pack(1)                      // 1 Byte Packing
typedef struct tagSETUPINFO {

    char            szPortMonitor[2 * _MAX_PATH_];
    char            szPrintProcessor[2 * _MAX_PATH_];
    char            szVendorSetup[2 * _MAX_PATH_];
    char            szVendorInstaller[2 * _MAX_PATH_];
	char            ShareName[_MAX_PATH_];
	char            INFfileName[_MAX_PATH_];
    char            szPort[_MAX_PATH_];
    char            szDriverFile[_MAX_PATH_];
    char            szDataFile[_MAX_PATH_];
    char            szConfigFile[_MAX_PATH_];
    char            szHelpFile[_MAX_PATH_];
	char            szDriverDir[_MAX_PATH_];
	char            BinName[_MAX_PATH_];
    char            szFriendly[_MAX_PATH_];
    char            szModel[_MAX_PATH_];
    char            szDefaultDataType[_MAX_PATH_];
    int				dwDriverVersion;
    int				dwUniqueID;
    int				bNetPrinter;
    int				wFilesUsed;
    int				wFilesAllocated;
    int				wRetryTimeout;
    int				wDNSTimeout;
    int				bDontQueueFiles;
    int				bNoTestPage;
    int				hModelInf;
	int				wCommand;
	int				nRes1;
    LPBYTE          lpPrinterInfo2;
    LPBYTE          lpDriverInfo3;
    LPBYTE          lpFiles;
    LPBYTE          lpVcpInfo;
} SETUPINFO, FAR *LPSI;

#endif // _LPSI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\thunk\sources.inc ===
!IF 0
/*---------------------------------------------------------------------------*\
| MODULE: sources
|
|   Builds the thunk objects necessary to link the 16/32 dlls.
|
| history:
|   15-Dec-1997 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
!ENDIF

#PASS0ONLY     = 1
#NOPASS0       = 1
TARGETNAME    =
TARGETTYPE    = NOTARGET
TARGETPATH    =
SOURCES_OPTIONS = -c0
SOURCES       =
NTTARGETFILE1 = buildall

SOURCES_USED  = ..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\inc\errormap.h ===
/***************************************************************************
  *
  * File Name: ERRORMAP.H
  *
  * Copyright Hewlett-Packard Company 1997 
  * All rights reserved.
  *
  * 11311 Chinden Blvd.
  * Boise, Idaho  83714
  *
  *   
  * Description: contains the error codes for WPNPINST.DLL
  *
  * Author:  Garth Schmeling
  *
  * Modification history:
  *
  * Date		Initials		Change description
  *
  * 10-10-97	GFS				Initial checkin
  *
  *
  *
  ***************************************************************************/

#ifndef _ERROR_MAP_H
#define _ERROR_MAP_H

//-----------------------------------
// Error Mappings
//-----------------------------------

#define RET_OK            0
#define URL_ERROR       (600)

typedef UINT RETERR;

// Web Pnp Error Definitions
//
enum _RET_ERR {

    RET_ALLOC_ERR = (URL_ERROR + 1),
    RET_INVALID_INFFILE,
    RET_SECT_NOT_FOUND,
    RET_DRIVER_NODE_ERROR,
    RET_INVALID_PRINTER_DRIVER,
    RET_INVALID_DLL,
	RET_DRIVER_NOT_FOUND,
	RET_DRIVER_FOUND,
	RET_NO_UNIQUE_NAME,
	RET_USER_CANCEL,
	RET_FILE_COPY_ERROR,
	RET_ADD_PRINTER_ERROR,
	RET_BROWSE_ERROR,
	RET_INVALID_DAT_FILE
};

#endif // _ERROR_MAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\inc\msdefine.h ===
/***************************************************************************
  *
  * File Name: MSDEFINE.H
  *
  * Copyright Hewlett-Packard Company 1997 
  * All rights reserved.
  *
  * 11311 Chinden Blvd.
  * Boise, Idaho  83714
  *
  *   
  * Description: contains definitions for WPNPINST.DLL found in the MS build
  * tree.  Should not need to be checked into MS tree.
  *
  * Author:  Garth Schmeling
  *        
  * Modification history:
  *
  * Date		Initials		Change description
  *
  * 10-10-97	GFS				Initial checkin
  *
  *
  *
  ***************************************************************************/

// definitions found in MS Win9x build system

#define SZMESSAGESERVERCLASS			"Windows 32-bit VxD Message Server"
#define PROCNAME_EXTDEVMODEPROPSHEET	"EXTDEVICEMODEPROPSHEET"
#define PROCNAME_EXTDEVICEMODE			"EXTDEVICEMODE"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\inc\hpmemory.h ===
/***************************************************************************
  *
  * File Name: HPMEMORY.H
  *
  * Copyright Hewlett-Packard Company 1997 
  * All rights reserved.
  *
  * 11311 Chinden Blvd.
  * Boise, Idaho  83714
  *
  *   
  * Description: contains memory functions used in WPNPINST.DLL
  *
  * Author:  Garth Schmeling
  *        
  * Modification history:
  *
  * Date		Initials		Change description
  *
  * 10-10-97	GFS				Initial checkin
  *
  *
  *
  ***************************************************************************/

#ifndef _HP_MEMORY_H_
#define _HP_MEMORY_H_

#include <windowsx.h>

//-----------------------------------
//  GlobalAlloc Functions
//-----------------------------------

#ifdef WIN32
#define HP_GLOBAL_ALLOC_DLL(cb)               GlobalAllocPtr(GHND,cb)
#define HP_GLOBAL_REALLOC_DLL(lp,cbNew,flags) GlobalReAllocPtr(lp,cbNew,flags)
#else
#define HP_GLOBAL_ALLOC_DLL(cb)               GlobalAllocPtr(GHND | GMEM_DDESHARE, cb)
#define HP_GLOBAL_REALLOC_DLL(lp,cbNew,flags) GlobalReAllocPtr(lp, cbNew, flags)
#endif
#define HP_GLOBAL_FREE(lp)                    GlobalFreePtr(lp)


#endif // _HP_MEMORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\webptprn\globals.h ===
/*---------------------------------------------------------------------------*\
| MODULE: globals.h
|
|   This module defines the global variables used throughout the program.
|
|
| Copyright (C) 1996-1998 Hewlett Packard Company
| Copyright (C) 1996-1998 Microsoft Corporation
|
| history:
|   15-Dec-1996 <chriswil> created.
|
\*---------------------------------------------------------------------------*/

extern HINSTANCE g_hInst;

/*-----------------------------------*\
| Unlocalizable Strings
\*-----------------------------------*/
extern CONST TCHAR g_szFilApp      [];
extern CONST TCHAR g_szFilInetpp   [];
extern CONST TCHAR g_szFilOlePrn   [];
extern CONST TCHAR g_szFilIns16    [];
extern CONST TCHAR g_szFilIns32    [];
extern CONST TCHAR g_szFilInsEx    [];
extern CONST TCHAR g_szFilInit     [];

extern CONST TCHAR g_szPPName      [];
extern CONST TCHAR g_szRename      [];
extern CONST TCHAR g_szHttp        [];
extern CONST TCHAR g_szHttps       [];
extern CONST TCHAR g_szExec        [];
extern CONST TCHAR g_szCmdUns      [];

extern CONST TCHAR g_szRegCabKey   [];
extern CONST TCHAR g_szRegCabCmd   [];
extern CONST TCHAR g_szRegUninstall[];
extern CONST TCHAR g_szRegUnsKey   [];
extern CONST TCHAR g_szRegDspNam   [];
extern CONST TCHAR g_szRegUnsNam   [];
extern CONST TCHAR g_szRegUnsVal   [];


/*-----------------------------------*\
| Localizable Strings
\*-----------------------------------*/
extern LPTSTR g_szMsgAdd;
extern LPTSTR g_szMsgDel;
extern LPTSTR g_szMsgReboot;
extern LPTSTR g_szMsgUninstall;
extern LPTSTR g_szMsgFailCpy;
extern LPTSTR g_szMsgFailAdd;
extern LPTSTR g_szMsgFailAsc;
extern LPTSTR g_szRegDspVal;
extern LPTSTR g_szMsgOsVerHead;
extern LPTSTR g_szMsgOsVerMsg;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\webptprn\webptprn.cxx ===
/*---------------------------------------------------------------------------*\
| MODULE: webptprn.cxx
|
|   This is the main entry-point module for the application.
|
|   Routines
|   --------
|   WinMain
|
|
| Copyright (C) 1996-1998 Hewlett Packard Company
| Copyright (C) 1996-1998 Microsoft Corporation
|
| history:
|   15-Dec-1996 <chriswil> created.
|
\*---------------------------------------------------------------------------*/

#include "webptprn.h"

#define memAlloc(cbSize)    (LPVOID)LocalAlloc(LPTR, cbSize)
#define memFree(pvMem)      LocalFree((LPVOID)pvMem)

#define strFree(pszStr) {if (pszStr) GlobalFree((HANDLE)pszStr);}

/*****************************************************************************\
* strAlloc
*
*   Allocates a string from the heap.  This pointer must be freed with
*   a call to strFree().
*
\*****************************************************************************/
LPTSTR strAlloc(
    LPCTSTR pszSrc)
{
    DWORD  cbSize;
    LPTSTR pszDst = NULL;


    cbSize = (pszSrc ? ((lstrlen(pszSrc) + 1) * sizeof(TCHAR)) : 0);

    if (cbSize) {

        if (pszDst = (LPTSTR)GlobalAlloc(GPTR, cbSize))
            CopyMemory(pszDst, pszSrc, cbSize);
    }

    return pszDst;
}


/*****************************************************************************\
* strLoad
*
*   Get string from resource based upon the ID passed in.
*
\*****************************************************************************/
LPTSTR strLoad(
    UINT ids)
{
    char szStr[MAX_RESBUF];


    if (LoadString(g_hInst, ids, szStr, sizeof(szStr)) == 0)
        szStr[0] = TEXT('\0');

    return strAlloc(szStr);
}


/*****************************************************************************\
* InitStrings
*
*
\*****************************************************************************/
BOOL InitStrings(VOID)
{
    g_szMsgAdd       = strLoad(IDS_MSG_ADD);
    g_szMsgDel       = strLoad(IDS_MSG_DEL);
    g_szMsgReboot    = strLoad(IDS_MSG_REBOOT);
    g_szMsgUninstall = strLoad(IDS_MSG_UNINSTALL);
    g_szMsgFailCpy   = strLoad(IDS_ERR_COPY);
    g_szMsgFailAdd   = strLoad(IDS_ERR_ADD);
    g_szMsgFailAsc   = strLoad(IDS_ERR_ASC);
    g_szRegDspVal    = strLoad(IDS_REG_DISPLAY);
    g_szMsgOsVerHead = strLoad(IDS_ERR_OSVERHEAD);
    g_szMsgOsVerMsg  = strLoad(IDS_ERR_OSVERMSG);


    return (g_szMsgAdd       &&
            g_szMsgDel       &&
            g_szMsgReboot    &&
            g_szMsgUninstall &&
            g_szMsgFailCpy   &&
            g_szMsgFailAdd   &&
            g_szMsgFailAsc   &&
            g_szRegDspVal    &&
            g_szMsgOsVerHead &&
            g_szMsgOsVerMsg
           );
}


/*****************************************************************************\
* FreeeStrings
*
*
\*****************************************************************************/
VOID FreeStrings(VOID)
{
    strFree(g_szMsgAdd);
    strFree(g_szMsgDel);
    strFree(g_szMsgReboot);
    strFree(g_szMsgUninstall);
    strFree(g_szMsgFailCpy);
    strFree(g_szMsgFailAdd);
    strFree(g_szMsgFailAsc);
    strFree(g_szRegDspVal);
    strFree(g_szMsgOsVerHead);
    strFree(g_szMsgOsVerMsg);
}


/*---------------------------------------------------------------------------*\
| pp_StrSize
|
|   Returns the bytes occupied by the string.
|
\*---------------------------------------------------------------------------*/
_inline DWORD pp_StrSize(
    LPCTSTR lpszStr)
{
    return (lpszStr ? ((lstrlen(lpszStr) + 1) * sizeof(TCHAR)) : 0);
}


/*---------------------------------------------------------------------------*\
| pp_AddFileAssociation
|
|   Add the .webpnp to the file-associations.
|
\*---------------------------------------------------------------------------*/
BOOL pp_AddFileAssociation(VOID)
{
    LONG lRet;
    HKEY hkPath;
    BOOL bRet = FALSE;


    lRet = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                          g_szRegCabKey,
                          0,
                          NULL,
                          0,
                          KEY_WRITE,
                          NULL,
                          &hkPath,
                          NULL);

    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hkPath,
                             NULL,
                             0,
                             REG_SZ,
                             (LPBYTE)g_szRegCabCmd,
                             pp_StrSize(g_szRegCabCmd));

        bRet = (lRet == ERROR_SUCCESS ? TRUE : FALSE);

        RegCloseKey(hkPath);
    }

    return bRet;
}


/*---------------------------------------------------------------------------*\
| pp_BuildName
|
|   Return a fully-qualified path/name.
|
\*---------------------------------------------------------------------------*/
LPTSTR pp_BuildName(
    LPCTSTR lpszPath,
    LPCTSTR lpszFile)
{
    DWORD  cbSize;
    LPTSTR lpszFull;

    static CONST TCHAR s_szFmt[] = TEXT("%s\\%s");


    // Calculate the size necessary to hold the full-path filename.
    //
    cbSize = pp_StrSize(lpszPath) + pp_StrSize(s_szFmt) + pp_StrSize(lpszFile);


    if (lpszFull = (LPTSTR)memAlloc(cbSize))
        wsprintf(lpszFull, s_szFmt, lpszPath, lpszFile);

    return lpszFull;
}


/*---------------------------------------------------------------------------*\
| pp_CurDir
|
|   Return CURRENT directory.
|
\*---------------------------------------------------------------------------*/
LPTSTR pp_CurDir(VOID)
{
    DWORD  cbSize;
    DWORD  cch;
    LPTSTR lpszDir = NULL;


    cbSize = GetCurrentDirectory(0, NULL);

    if (cbSize && (lpszDir = (LPTSTR)memAlloc(cbSize * sizeof(TCHAR)))) {

        GetCurrentDirectory(cbSize, lpszDir);

        if (cch = lstrlen(lpszDir)) {

            cch--;

            if (*(lpszDir + cch) == TEXT('\\'))
                *(lpszDir + cch) = TEXT('\0');
        }
    }

    return lpszDir;
}


/*---------------------------------------------------------------------------*\
| pp_SysDir
|
|   Return SYSTEM directory.
|
\*---------------------------------------------------------------------------*/
LPTSTR pp_SysDir(VOID)
{
    DWORD  cbSize;
    LPTSTR lpszDir = NULL;


    cbSize = GetSystemDirectory(NULL, 0);

    if (cbSize && (lpszDir = (LPTSTR)memAlloc(cbSize * sizeof(TCHAR))))
        GetSystemDirectory(lpszDir, cbSize);

    return lpszDir;
}


/*---------------------------------------------------------------------------*\
| pp_WinDir
|
|   Return WINDOWS directory.
|
\*---------------------------------------------------------------------------*/
LPTSTR pp_WinDir(VOID)
{
    DWORD  cbSize;
    LPTSTR lpszDir = NULL;


    cbSize = GetWindowsDirectory(NULL, 0);

    if (cbSize && (lpszDir = (LPTSTR)memAlloc(cbSize * sizeof(TCHAR))))
        GetWindowsDirectory(lpszDir, cbSize);

    return lpszDir;
}


/*---------------------------------------------------------------------------*\
| pp_TmpDir
|
|   Return TEMP directory.
|
\*---------------------------------------------------------------------------*/
LPTSTR pp_TmpDir(VOID)
{
    DWORD  cbSize;
    DWORD  cch;
    LPTSTR lpszDir = NULL;


    cbSize = GetTempPath(0, NULL);

    if (cbSize && (lpszDir = (LPTSTR)memAlloc(cbSize * sizeof(TCHAR)))) {

        GetTempPath(cbSize, lpszDir);

        if (cch = lstrlen(lpszDir)) {

            cch--;

            if (*(lpszDir + cch) == TEXT('\\'))
                *(lpszDir + cch) = TEXT('\0');
        }
    }

    return lpszDir;
}


/*---------------------------------------------------------------------------*\
| pp_AddCOM
|
|   This copies com-objects the destination directory.
|
\*---------------------------------------------------------------------------*/
BOOL pp_AddCOM(
    LPCTSTR lpszSDir,
    LPCTSTR lpszDDir,
    LPCTSTR lpszFile)
{
    LPTSTR lpszSrc;
    LPTSTR lpszDst;
    BOOL   bRet = FALSE;


    if (lpszSrc = pp_BuildName(lpszSDir, lpszFile)) {

        if (lpszDst = pp_BuildName(lpszDDir, lpszFile)) {

            bRet = CopyFile(lpszSrc, lpszDst, FALSE);

            memFree(lpszDst);
        }

        memFree(lpszSrc);
    }

    return bRet;
}


/*---------------------------------------------------------------------------*\
| pp_CopyFile
|
|   Copy the file to the temporary directory, then set up the wininit.ini
|   for delayed-boot-copy.
|
\*---------------------------------------------------------------------------*/
BOOL pp_CopyFile(
    LPCTSTR lpszCDir,
    LPCTSTR lpszSDir,
    LPCTSTR lpszTDir,
    LPCTSTR lpszFile)
{
    LPTSTR lpszSrc;
    LPTSTR lpszDst;
    LPTSTR lpszTmp;
    BOOL   bRet = FALSE;


    if (lpszSrc = pp_BuildName(lpszCDir, lpszFile)) {

        if (lpszDst = pp_BuildName(lpszSDir, lpszFile)) {

            if (lpszTmp = pp_BuildName(lpszTDir, lpszFile)) {

                if (CopyFile(lpszSrc, lpszTmp, FALSE)) {

                    bRet = WritePrivateProfileString(g_szRename,
                                                     lpszDst,
                                                     lpszTmp,
                                                     g_szFilInit);
                }

                memFree(lpszTmp);
            }

            memFree(lpszDst);
        }

        memFree(lpszSrc);
    }

    return bRet;
}


/*---------------------------------------------------------------------------*\
| pp_CopyFiles
|
|   This routine first copies the files to the temp-directory, then does
|   the necessary setup to have them copied upon boot.
|
\*---------------------------------------------------------------------------*/
BOOL pp_CopyFiles(VOID)
{
    LPTSTR lpszCDir;
    LPTSTR lpszSDir;
    LPTSTR lpszTDir;
    BOOL   bRet = FALSE;


    if (lpszCDir = pp_CurDir()) {

        if (lpszSDir = pp_SysDir()) {

            if (lpszTDir = pp_TmpDir()) {

                // Copy the oleprn to the system-directory in case this
                // is the first time of install.  This is necessary since
                // we do som COM-registration if called from WPNPINS.EXE.
                //
                pp_AddCOM(lpszCDir, lpszSDir, g_szFilOlePrn);


                // Copy the files to a temp-directory for installation
                // at boot-time.
                //
                if (pp_CopyFile(lpszCDir, lpszSDir, lpszTDir, g_szFilApp)    &&
                    pp_CopyFile(lpszCDir, lpszSDir, lpszTDir, g_szFilInetpp) &&
                    pp_CopyFile(lpszCDir, lpszSDir, lpszTDir, g_szFilOlePrn) &&
                    pp_CopyFile(lpszCDir, lpszSDir, lpszTDir, g_szFilInsEx)  &&
                    pp_CopyFile(lpszCDir, lpszSDir, lpszTDir, g_szFilIns16)  &&
                    pp_CopyFile(lpszCDir, lpszSDir, lpszTDir, g_szFilIns32)) {

                    bRet = TRUE;
                }

                memFree(lpszTDir);
            }

            memFree(lpszSDir);
        }

        memFree(lpszCDir);
    }

    return bRet;
}


/*---------------------------------------------------------------------------*\
| pp_AddProvidor
|
|   Adds the print-provider to the registry.
|
\*---------------------------------------------------------------------------*/
BOOL pp_AddProvidor(VOID)
{
    PROVIDOR_INFO_1 pi1;

    pi1.pName        = (LPTSTR)g_szPPName;
    pi1.pEnvironment = NULL;
    pi1.pDLLName     = (LPTSTR)g_szFilInetpp;

    return AddPrintProvidor(NULL, 1, (LPBYTE)&pi1);
}


/*---------------------------------------------------------------------------*\
| pp_AddRegistry
|
|   Writes out the uninstall-section in the registry.
|
\*---------------------------------------------------------------------------*/
BOOL pp_AddRegistry(VOID)
{
    HKEY hKey;
    HKEY hUns;
    LONG lRet;


    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        g_szRegUninstall,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey);


    if (lRet == ERROR_SUCCESS) {

        lRet = RegOpenKeyEx(hKey,
                            g_szRegUnsKey,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hUns);

        if (lRet != ERROR_SUCCESS) {

            lRet = RegCreateKeyEx(hKey,
                                  g_szRegUnsKey,
                                  0,
                                  NULL,
                                  0,
                                  KEY_WRITE,
                                  NULL,
                                  &hUns,
                                  NULL);

            if (lRet == ERROR_SUCCESS) {

                RegSetValueEx(hUns,
                              g_szRegDspNam,
                              0,
                              REG_SZ,
                              (LPBYTE)g_szRegDspVal,
                              pp_StrSize(g_szRegDspVal));

                RegSetValueEx(hUns,
                              g_szRegUnsNam,
                              0,
                              REG_SZ,
                              (LPBYTE)g_szRegUnsVal,
                              pp_StrSize(g_szRegUnsVal));

                RegCloseKey(hUns);
            }
        }

        RegCloseKey(hKey);
    }

    return (lRet == ERROR_SUCCESS);
}


/*---------------------------------------------------------------------------*\
| pp_DelProvidor
|
|   Removes the print-provider from the registry.
|
\*---------------------------------------------------------------------------*/
BOOL pp_DelProvidor(VOID)
{
    return DeletePrintProvidor(NULL, NULL, (LPTSTR)g_szPPName);
}


/*---------------------------------------------------------------------------*\
| pp_DelRegistry
|
|   Removes the uninstall registry settings.
|
\*---------------------------------------------------------------------------*/
BOOL pp_DelRegistry(VOID)
{
    HKEY hKey;
    LONG lRet;


    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        g_szRegUninstall,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey);


    if (lRet == ERROR_SUCCESS) {

        lRet = RegDeleteKey(hKey, g_szRegUnsKey);

        RegCloseKey(hKey);
    }

    return (lRet == ERROR_SUCCESS);
}


/*---------------------------------------------------------------------------*\
| pp_DelFile
|
|   Remove the file from the system.
|
\*---------------------------------------------------------------------------*/
BOOL pp_DelFile(
    HANDLE  hFile,
    LPCTSTR lpszSDir,
    LPCTSTR lpszFile)
{
    LPTSTR lpszSrc;
    DWORD  cbWr;
    DWORD  cch;
    TCHAR  szBuf[MAX_BUFFER];
    BOOL   bRet = FALSE;


    if (lpszSrc = pp_BuildName(lpszSDir, lpszFile)) {

        cch = wsprintf(szBuf, TEXT("NUL=%s\r\n"), lpszSrc);

        bRet = WriteFile(hFile, szBuf, cch, &cbWr, NULL);

        memFree(lpszSrc);
    }

    return bRet;
}


/*---------------------------------------------------------------------------*\
| pp_DelFiles
|
|   Deletes the files from the system (delayed delete).
|
\*---------------------------------------------------------------------------*/
BOOL pp_DelFiles(VOID)
{
    HANDLE hFile;
    LPTSTR lpszWDir;
    LPTSTR lpszSDir;
    LPTSTR lpszWFile;
    DWORD  cch;
    DWORD  cbWr;
    TCHAR  szBuf[MAX_BUFFER];
    BOOL   bRet = FALSE;


    if (lpszWDir = pp_WinDir()) {

        if (lpszSDir = pp_SysDir()) {

            if (lpszWFile = pp_BuildName(lpszWDir, g_szFilInit)) {

                hFile = CreateFile(lpszWFile,
                                   GENERIC_READ | GENERIC_WRITE,
                                   0,
                                   NULL,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);

                if (hFile && (hFile != INVALID_HANDLE_VALUE)) {

                    cch = wsprintf(szBuf, TEXT("[%s]\r\n"), g_szRename);

                    WriteFile(hFile, szBuf, cch, &cbWr, NULL);

                    pp_DelFile(hFile, lpszSDir, g_szFilApp);
                    pp_DelFile(hFile, lpszSDir, g_szFilInetpp);
                    pp_DelFile(hFile, lpszSDir, g_szFilOlePrn);
                    pp_DelFile(hFile, lpszSDir, g_szFilInsEx);
                    pp_DelFile(hFile, lpszSDir, g_szFilIns16);
                    pp_DelFile(hFile, lpszSDir, g_szFilIns32);

                    CloseHandle(hFile);

                    bRet = TRUE;
                }

                memFree(lpszWFile);
            }

            memFree(lpszSDir);
        }

        memFree(lpszWDir);
    }

    return bRet;
}


/*---------------------------------------------------------------------------*\
| pp_Sync
|
|   Synchronize.  This will not return until the process is terminated.
|
\*---------------------------------------------------------------------------*/
BOOL pp_Sync(
    HANDLE hProcess)
{
    DWORD dwObj;
    DWORD dwExitCode = 0;


    while (TRUE) {

        dwObj = WaitForSingleObject(hProcess, INFINITE);


        // Look for the exit type.
        //
        switch (dwObj) {

        // The process handle triggered the wait.  Let's get the
        // exit-code and return whether the success.  Otherwise,
        // drop through and return the failure.
        //
        case WAIT_OBJECT_0:
            GetExitCodeProcess(hProcess, &dwExitCode);

            if (dwExitCode == 0)
                return TRUE;


        // Something failed in the call.  We failed.
        //
        case WAIT_FAILED:
            return FALSE;
        }
    }
}


/*---------------------------------------------------------------------------*\
| pp_Exec
|
|   Execute the process.
|
\*---------------------------------------------------------------------------*/
BOOL pp_Exec(
    LPCTSTR lpszComFile)
{
    PROCESS_INFORMATION pi;
    STARTUPINFO         sti;
    LPTSTR              lpszCmd;
    DWORD               cbSize;
    BOOL                bSuccess = FALSE;


    // Calculate enough space to hold the command-line arguments.
    //
    cbSize = (lstrlen(lpszComFile) + lstrlen(g_szExec) + 1) * sizeof(TCHAR);


    // Allocate the command-line for the create-process call.
    //
    if (lpszCmd = (LPTSTR)memAlloc(cbSize)) {

        // Initialize startup-info fields.
        //
        memset(&sti, 0, sizeof(STARTUPINFO));
        sti.cb = sizeof(STARTUPINFO);

        // Build the command-line string that exec's regsvr32.
        //
        wsprintf(lpszCmd, g_szExec, lpszComFile);


        // Exec the process.
        //
        if (EXEC_PROCESS(lpszCmd, &sti, &pi)) {

            CloseHandle(pi.hThread);

            // This will wait until the process if finished generating
            // the file.  The return from this indicates whether the
            // generation succeeded or not.
            //
            pp_Sync(pi.hProcess);

            CloseHandle(pi.hProcess);
        }

        memFree(lpszCmd);
    }

    return bSuccess;
}


/*---------------------------------------------------------------------------*\
| pp_DelCOM
|
|   Unregisters the COM object.
|
\*---------------------------------------------------------------------------*/
BOOL pp_DelCOM(VOID)
{
    LPTSTR lpszSDir;
    LPTSTR lpszDst;
    BOOL   bRet = FALSE;


    if (lpszSDir = pp_SysDir()) {

        if (lpszDst = pp_BuildName(lpszSDir, g_szFilOlePrn)) {

            pp_Exec(lpszDst);

            memFree(lpszDst);
        }

        memFree(lpszSDir);
    }

    return bRet;
}


/*---------------------------------------------------------------------------*\
| pp_DelPrinters
|
|   Deletes all the printers with URL-ports.
|
\*---------------------------------------------------------------------------*/
BOOL pp_DelPrinters(VOID)
{
    LPPRINTER_INFO_5 pi5;
    HANDLE           hPrn;
    DWORD            cbSize;
    DWORD            cPrt;
    DWORD            idx;
    DWORD            cch;
    BOOL             bRet = FALSE;


    // Get the size necessary to hold all enumerated printers.
    //
    cbSize = 0;
    EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 5, NULL, 0, &cbSize, &cPrt);


    if (cbSize && (pi5 = (LPPRINTER_INFO_5)memAlloc(cbSize))) {

        cPrt = 0;
        if (EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 5, (LPBYTE)pi5, cbSize, &cbSize, &cPrt)) {

            bRet = TRUE;

            for (idx = 0; idx < cPrt; idx++) {

                if ((_strnicmp((pi5+idx)->pPortName, g_szHttp , lstrlen(g_szHttp )) == 0) ||
                    (_strnicmp((pi5+idx)->pPortName, g_szHttps, lstrlen(g_szHttps)) == 0)) {

                    if (OpenPrinter((pi5+idx)->pPrinterName, &hPrn, NULL)) {

                        DeletePrinter(hPrn);

                        ClosePrinter(hPrn);
                    }
                }
            }
        }

        memFree(pi5);
    }

    return bRet;
}

/*---------------------------------------------------------- entry routine --*\
| WinMain
|
|   This is the process entry-point routine.  This is the basis for all
|   application events.
|
\*---------------------------------------------------------------------------*/
int PASCAL WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    LPSTR     lpszCmd,
    int       nShow)
{
    OSVERSIONINFO OsVersion;
    int iRet = RC_WEXTRACT_AWARE;


    UNREFPARM(nShow);
    UNREFPARM(hPrevInst);

    g_hInst = hInst;

    if (InitStrings()) {

        OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    
        if (GetVersionEx(&OsVersion)) {  // If we can't get the OSVersion, we assume it's alright
            // Check that we are on Win9X, then check that the version is not millenium
            // We assume that millenium is Version 5 or higher            
            if (OsVersion.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS ||
                (OsVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && 
                   OsVersion.dwMajorVersion > 4 )) { 

                MessageBox( NULL, g_szMsgOsVerMsg, g_szMsgOsVerHead, MB_OK | MB_ICONINFORMATION);
                                                      
                goto cleanup;
            }
        }
       
        if (lpszCmd && (lstrcmpi(lpszCmd, g_szCmdUns) == 0)) {
            // We were asked to uninstall, not from inside WEXTRACT, so return 0 if we return
            iRet = 0;

            if (MessageBox(NULL, g_szMsgUninstall, g_szMsgDel, MB_YESNO | MB_ICONQUESTION) == IDYES) {

                pp_DelPrinters();
                pp_DelProvidor();
                pp_DelRegistry();
                pp_DelCOM();
                pp_DelFiles();

                if (MessageBox(NULL, g_szMsgReboot, g_szMsgDel, MB_YESNO | MB_ICONINFORMATION) == IDYES)
                    ExitWindowsEx(EWX_REBOOT, 0);
            }

        } else {

            if (pp_AddFileAssociation()) {

                if (pp_CopyFiles()) {

                    pp_AddProvidor();
                    pp_AddRegistry();

                    iRet |= REBOOT_YES | REBOOT_ALWAYS;

                } else {

                    MessageBox(NULL, g_szMsgFailCpy, g_szMsgAdd, MB_OK);
                }

            } else {

                MessageBox(NULL, g_szMsgFailAsc, g_szMsgAdd, MB_OK);
            }
        }

cleanup:

        FreeStrings();
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\cmstrip.c ===
/*
   stripper: strips asm comments, blanks lines, and spurious spaces
   (except spaces following the exception strings, listed below.)
*/

#include <stdio.h>

char *
ScanWhite( ps )
char **ps;
{
    char *s = *ps;

    while (*s != ' ' && *s != '\t' && *s)
	s++;
    *ps = s;
    if (*s)
	return s;
    else
	return NULL;
}

char *
SkipWhite( ps )
char **ps;
{
    char *s = *ps;

    while (*s == ' ' || *s == '\t')
	s++;
    *ps = s;
    if (*s)
	return s;
    else
	return NULL;
}

char inBuf[ 256 ];
char outBuf[ 256 ];


main()
{
    char
	*inStr,
	*outStr,
	*str;
    int inLen,
	outLen,
	tabcnt;

    long totSaved = 0L;

    unlink( "cmacros.bak" );			    /*	    */
    rename( "cmacros.bak", "cmacros.inc" );	    /*	    */
    freopen( "cmacros.mas", "r", stdin );	    /*	    */
    freopen( "cmacros.inc", "w", stdout );	    /*	    */
    fprintf( stderr, "cmacros.mas => cmacros.inc" );
    fflush( stderr );

    while (inStr = gets( inBuf ))
    {
	inLen = strlen( inBuf );
	outStr = outBuf;

	tabcnt=0;
	if (inBuf[inLen-1] == '@')
	    tabcnt=1;

	while (SkipWhite( &inStr ))
	{
	    if (*inStr == ';')
		break;

	    str = inStr;
	    ScanWhite( &inStr );
	    if (tabcnt > 0 && tabcnt < 3)
	    {
		*outStr++ = '\t';
		tabcnt++;
	    }
	    else
	    {
		if (outStr != outBuf)
		    *outStr++ = ' ';
	    }
	    while (str != inStr)
		*outStr++ = *str++;
	}

	if (outLen = outStr - outBuf)
	{
	    *outStr++ = 0;
	    puts( outBuf );
	}

	totSaved += (inLen - outLen);
    }

    fprintf( stderr, " [OK]  %ld blanks stripped\n", totSaved );
    exit( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to hlls
(C)Copyright Microsoft Corp. 1984-1988
$
.xcref
.xcref ??_out
ifndef ?QUIET
?QUIET  equ 1
endif
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
ifdef PMODE
?pmd=1
??_out <! 286 protect mode>
else
?pmd=0
endif
ifdef ?386regs
if ?386regs
??_out <! 386 registers enabled>
endif
else
?386regs=0
endif
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<Pascal calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
ifdef ?pmd
.286p
endif
if ?386regs
.xcref ?n,?ax,?eax,?bx,?ebx
.xcref ?cx,?ecx,?dx,?edx
.xcref ?si,?esi,?di,?edi,?es,?ds,?fs
.xcref ?gs
else
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
endif
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5,?pmd,?lds,?exp
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?lds = 0
?exp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
if ?386regs
?n = 0000000000000000b
?ax = 0000000000000001b
?eax = 0000000000000010b
?bx = 0000000000000100b
?ebx = 0000000000001000b
?cx = 0000000000010000b
?ecx = 0000000000100000b
?dx = 0000000001000000b
?edx = 0000000010000000b
?si = 0000000100000000b
?esi = 0000001000000000b
?di = 0000010000000000b
?edi = 0000100000000000b
?ds = 0001000000000000b
?es = 0010000000000000b
?fs = 0100000000000000b
?gs = 1000000000000000b
else
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
endif
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
if ?386regs
mpush macro r
irp x,<ax,eax,bx,ebx,cx,ecx,dx,edx,si,esi,di,edi,ds,es,fs,gs>
if (r and ?&&x)
	push	x
endif
endm
endm
else
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
endif
if ?386regs
mpop macro r
irp x,<gs,fs,es,ds,edi,di,esi,si,edx,dx,ecx,cx,ebx,bx,eax,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
else
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
endif
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
.ERRNDEF ?&&x
n=n or ?&&x
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
if ?pmd
parmR macro n,r,r2
??error <Sorry: ParmR can't be used with PMODE=1>
endm
else
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
?lds=0
?exp=0
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
ifidn <x>,<LOADDS>
?lds=1
endif
ifidn <x>,<EXPORTED>
?exp=1
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp+?exp+?lds
ife ?nx
ife ?pmd
?ia=2
endif
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
ife ?386regs
?pas = ?pas and (not (?sp+?cs+?ss))
endif
if ?uf
if ?386regs
?pas = ?pas and (not (?si+?di))
else
?pas = ?pas and (not (?bp+?si+?di))
endif
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w+?exp+?lds
if ?pmd
ife ?nd
if ?lds
mov ax,_DATA
else
if ?exp
mov ax,ds
nop
endif
endif
endif
ife ?nx
if ???+?po
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
push ds
if ?lds+?exp
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
else
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
endif
else
if ?pmd
if ?exp
mov ax,ds
nop
else
if ?lds
mov ax,_DATA
endif
endif
if ?ff+???+?po+?rp
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
if ?exp+?lds
push ds
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
ife ?pmd
	sub	sp,???
endif
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w+?exp+?lds
if ?pmd
ife ?nx
pop ds
endif
ife ?nx
if ?chkstk1+???+?po
leave
endif
else
if ?ff+???+?po+?rp
leave
endif
endif
else
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
endif
else
if ?pmd
if ?ff+???+?po+?rp
leave
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\custcntl.h ===
/*****************************************************************************\
*                                                                             *
* custcntl.h -  Custom Control Library header file                            *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_CUSTCNTL
#define _INC_CUSTCNTL

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/*
 * Every custom control DLL must have three functions present,
 * and they must be exported by the following ordinals.
 */
#define CCINFOORD       2       /* information function ordinal */
#define CCSTYLEORD      3       /* styles function ordinal */
#define CCFLAGSORD      4       /* translate flags function ordinal */

/* general size definitions */
#define CTLTYPES        12      /* max number of control types */
#define CTLDESCR        22      /* max size of description */
#define CTLCLASS        20      /* max size of class name */
#define CTLTITLE        94      /* max size of control text */

/*
 * CONTROL STYLE DATA STRUCTURE
 *
 * This data structure is used by the class style dialog function
 * to set and/or reset various control attributes.
 *
 */
typedef struct tagCTLSTYLE
{
    UINT    wX;                 /* x origin of control */
    UINT    wY;                 /* y origin of control */
    UINT    wCx;                /* width of control */
    UINT    wCy;                /* height of control */
    UINT    wId;                /* control child id */
    DWORD   dwStyle;            /* control style */
    char    szClass[CTLCLASS];  /* name of control class */
    char    szTitle[CTLTITLE];  /* control text */
} CTLSTYLE;
typedef CTLSTYLE *      PCTLSTYLE;
typedef CTLSTYLE FAR*   LPCTLSTYLE;

/*
 * CONTROL DATA STRUCTURE
 *
 * This data structure is returned by the control options function
 * when inquiring about the capabilities of a particular control.
 * Each control may contain various types (with predefined style
 * bits) under one general class.
 *
 * The width and height fields are used to provide the host
 * application with a suggested size.  The values in these fields
 * are in rc coordinates.
 *
 */
typedef struct tagCTLTYPE
{
    UINT    wType;              /* type style */
    UINT    wWidth;             /* suggested width */
    UINT    wHeight;            /* suggested height */
    DWORD   dwStyle;            /* default style */
    char    szDescr[CTLDESCR];  /* description */
} CTLTYPE;

typedef struct tagCTLINFO
{
    UINT    wVersion;           /* control version */
    UINT    wCtlTypes;          /* control types */
    char    szClass[CTLCLASS];  /* control class name */
    char    szTitle[CTLTITLE];  /* control title */
    char    szReserved[10];     /* reserved for future use */
    CTLTYPE Type[CTLTYPES];     /* control type list */
} CTLINFO;
typedef CTLINFO *       PCTLINFO;
typedef CTLINFO FAR*    LPCTLINFO;

/* These two function prototypes are used by the dialog editor */
#ifdef STRICT
typedef DWORD   (CALLBACK* LPFNSTRTOID)(LPCSTR);
#else
typedef DWORD   (CALLBACK* LPFNSTRTOID)(LPSTR);
#endif
typedef UINT    (CALLBACK* LPFNIDTOSTR)(UINT, LPSTR, UINT);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_CUSTCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\convdll.inc ===
WLOINITDLL      macro
                local cd_start, cd_patch, cd_init, WIN_NOP, WIN_PPLI
                local cd_end
         EXTRN   GETMODULEUSAGE:FAR
         EXTRN   INITTASK:FAR
         EXTRN   __WINFLAGS:abs

cd_start:
                push    ax
                push    bx
                push    cx
                push    dx
                push    es

                mov	ax, __WINFLAGS
                or	ax,ax
                jns     WIN_NOP

                pop     es
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                call    INITTASK-5
cd_patch:
                jmp     short cd_init
                nop
                xor     ax, ax
                retf
cd_init:        jmp     short cd_end

WIN_NOP:
                jmp     short WIN_PPLI
                jmp     short WIN_PPLI
                push    di
                call    GETMODULEUSAGE
                dec     ax
                jz      WIN_PPLI
                inc     ax
                add     sp,10
                retf

WIN_PPLI:
                pop     es
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                jmp     short cd_end
                db      "C", "D", "D", 1, 0
		dw      cd_patch - cd_start
		dw      WIN_NOP - cd_start
		dw      cd_end - cd_start
cd_end:

endm
        WLOINITDLL

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\webptprn\globals.cxx ===
/*---------------------------------------------------------------------------*\
| MODULE: globals.cxx
|
|   This module declares the global variables used throughout the program.
|
|
| Copyright (C) 1996-1998 Hewlett Packard Company
| Copyright (C) 1996-1998 Microsoft Corporation
|
| history:
|   15-Dec-1996 <chriswil> created.
|
\*---------------------------------------------------------------------------*/

#include "webptprn.h"

HINSTANCE g_hInst = NULL;

/*-----------------------------------*\
| Unlocalizable Strings
\*-----------------------------------*/
CONST TCHAR g_szFilApp      [] = TEXT("webptprn.exe");
CONST TCHAR g_szFilInetpp   [] = TEXT("inetpp.dll");
CONST TCHAR g_szFilOlePrn   [] = TEXT("oleprn.dll");
CONST TCHAR g_szFilIns16    [] = TEXT("wpnpin16.dll");
CONST TCHAR g_szFilIns32    [] = TEXT("wpnpin32.dll");
CONST TCHAR g_szFilInsEx    [] = TEXT("wpnpinst.exe");
CONST TCHAR g_szFilInit     [] = TEXT("wininit.ini");

CONST TCHAR g_szPPName      [] = TEXT("Internet Print Provider");
CONST TCHAR g_szRename      [] = TEXT("Rename");
CONST TCHAR g_szHttp        [] = TEXT("http://");
CONST TCHAR g_szHttps       [] = TEXT("https://");
CONST TCHAR g_szExec        [] = TEXT("regsvr32 /u /s %s");
CONST TCHAR g_szCmdUns      [] = TEXT("/u");

CONST TCHAR g_szRegCabKey   [] = TEXT(".webpnp\\Shell\\Open\\Command");
CONST TCHAR g_szRegCabCmd   [] = TEXT("wpnpinst.exe %1");
CONST TCHAR g_szRegUninstall[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall");
CONST TCHAR g_szRegUnsKey   [] = TEXT("WebPnp");
CONST TCHAR g_szRegDspNam   [] = TEXT("DisplayName");
CONST TCHAR g_szRegUnsNam   [] = TEXT("UninstallString");
CONST TCHAR g_szRegUnsVal   [] = TEXT("webptprn.exe /u");


/*-----------------------------------*\
| Localizable Strings
\*-----------------------------------*/
LPTSTR g_szMsgAdd       = NULL;
LPTSTR g_szMsgDel       = NULL;
LPTSTR g_szMsgReboot    = NULL;
LPTSTR g_szMsgUninstall = NULL;
LPTSTR g_szMsgFailCpy   = NULL;
LPTSTR g_szMsgFailAdd   = NULL;
LPTSTR g_szMsgFailAsc   = NULL;
LPTSTR g_szRegDspVal    = NULL;
LPTSTR g_szMsgOsVerHead = NULL;
LPTSTR g_szMsgOsVerMsg  = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\dde.h ===
/*****************************************************************************\
*                                                                             *
* dde.h -       Dynamic Data Exchange structures and definitions              *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_DDE
#define _INC_DDE

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* DDE window messages */

#define WM_DDE_FIRST	    0x03E0
#define WM_DDE_INITIATE     (WM_DDE_FIRST)
#define WM_DDE_TERMINATE    (WM_DDE_FIRST+1)
#define WM_DDE_ADVISE	    (WM_DDE_FIRST+2)
#define WM_DDE_UNADVISE     (WM_DDE_FIRST+3)
#define WM_DDE_ACK	    (WM_DDE_FIRST+4)
#define WM_DDE_DATA	    (WM_DDE_FIRST+5)
#define WM_DDE_REQUEST	    (WM_DDE_FIRST+6)
#define WM_DDE_POKE	    (WM_DDE_FIRST+7)
#define WM_DDE_EXECUTE	    (WM_DDE_FIRST+8)
#define WM_DDE_LAST	    (WM_DDE_FIRST+8)

/****************************************************************************\
*       DDEACK structure
*
*       Structure of wStatus (LOWORD(lParam)) in WM_DDE_ACK message
*       sent in response to a WM_DDE_DATA, WM_DDE_REQUEST, WM_DDE_POKE,
*       WM_DDE_ADVISE, or WM_DDE_UNADVISE message.
*
\****************************************************************************/

typedef struct tagDDEACK
{
    WORD    bAppReturnCode:8,
            reserved:6,
            fBusy:1,
            fAck:1;
} DDEACK;

/****************************************************************************\
*       DDEADVISE structure
*
*       WM_DDE_ADVISE parameter structure for hOptions (LOWORD(lParam))
*
\****************************************************************************/

typedef struct tagDDEADVISE
{
    WORD    reserved:14,
            fDeferUpd:1,
            fAckReq:1;
    short   cfFormat;
} DDEADVISE;

/****************************************************************************\
*       DDEDATA structure
*
*       WM_DDE_DATA parameter structure for hData (LOWORD(lParam)).
*       The actual size of this structure depends on the size of
*       the Value array.
*
\****************************************************************************/

typedef struct tagDDEDATA
{
    WORD    unused:12,
            fResponse:1,
            fRelease:1,
            reserved:1,
            fAckReq:1;
    short   cfFormat;
    BYTE     Value[1];
} DDEDATA;


/****************************************************************************\
*       DDEPOKE structure
*
*       WM_DDE_POKE parameter structure for hData (LOWORD(lParam)).
*       The actual size of this structure depends on the size of
*       the Value array.
*
\****************************************************************************/

typedef struct tagDDEPOKE
{
    WORD    unused:13,  /* Earlier versions of DDE.H incorrectly */
                        /* 12 unused bits.                       */
            fRelease:1,
            fReserved:2;
    short   cfFormat;
    BYTE    Value[1];   /* This member was named rgb[1] in previous */
                        /* versions of DDE.H                        */

} DDEPOKE;

/****************************************************************************\
* The following typedef's were used in previous versions of the Windows SDK.
* They are still valid.  The above typedef's define exactly the same structures
* as those below.  The above typedef names are recommended, however, as they
* are more meaningful.
*
* Note that the DDEPOKE structure typedef'ed in earlier versions of DDE.H did
* not correctly define the bit positions.
\****************************************************************************/

typedef struct tagDDELN
{
    WORD    unused:13,
            fRelease:1,
            fDeferUpd:1,
            fAckReq:1;
    short   cfFormat;
} DDELN;

typedef struct tagDDEUP
{
    WORD    unused:12,
            fAck:1,
            fRelease:1,
            fReserved:1,
            fAckReq:1;
    short   cfFormat;
    BYTE    rgb[1];
} DDEUP;

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_DDE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\commdlg.h ===
/*****************************************************************************\
*                                                                             *
* commdlg.h -   Common dialog functions, types, and definitions               *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_COMMDLG
#define _INC_COMMDLG

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

typedef struct tagOFN
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HINSTANCE hInstance;
    LPCSTR  lpstrFilter;
    LPSTR   lpstrCustomFilter;
    DWORD   nMaxCustFilter;
    DWORD   nFilterIndex;
    LPSTR   lpstrFile;
    DWORD   nMaxFile;
    LPSTR   lpstrFileTitle;
    DWORD   nMaxFileTitle;
    LPCSTR  lpstrInitialDir;
    LPCSTR  lpstrTitle;
    DWORD   Flags;
    UINT    nFileOffset;
    UINT    nFileExtension;
    LPCSTR  lpstrDefExt;
    LPARAM  lCustData;
    UINT    (CALLBACK *lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
}   OPENFILENAME;
typedef OPENFILENAME FAR* LPOPENFILENAME;

BOOL    WINAPI GetOpenFileName(OPENFILENAME FAR*);
BOOL    WINAPI GetSaveFileName(OPENFILENAME FAR*);
int     WINAPI GetFileTitle(LPCSTR, LPSTR, UINT);

#define OFN_READONLY                 0x00000001
#define OFN_OVERWRITEPROMPT          0x00000002
#define OFN_HIDEREADONLY             0x00000004
#define OFN_NOCHANGEDIR              0x00000008
#define OFN_SHOWHELP                 0x00000010
#define OFN_ENABLEHOOK               0x00000020
#define OFN_ENABLETEMPLATE           0x00000040
#define OFN_ENABLETEMPLATEHANDLE     0x00000080
#define OFN_NOVALIDATE               0x00000100
#define OFN_ALLOWMULTISELECT         0x00000200
#define OFN_EXTENSIONDIFFERENT       0x00000400
#define OFN_PATHMUSTEXIST            0x00000800
#define OFN_FILEMUSTEXIST            0x00001000
#define OFN_CREATEPROMPT             0x00002000
#define OFN_SHAREAWARE               0x00004000
#define OFN_NOREADONLYRETURN         0x00008000
#define OFN_NOTESTFILECREATE         0x00010000

/* Return values for the registered message sent to the hook function
 * when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
 * filename to be accepted, OFN_SHARENOWARN rejects the name but puts
 * up no warning (returned when the app has already put up a warning
 * message), and OFN_SHAREWARN puts up the default warning message
 * for sharing violations.
 *
 * Note:  Undefined return values map to OFN_SHAREWARN, but are
 *        reserved for future use.
 */

#define OFN_SHAREFALLTHROUGH     2
#define OFN_SHARENOWARN          1
#define OFN_SHAREWARN            0

typedef struct tagCHOOSECOLOR
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HWND    hInstance;
    COLORREF rgbResult;
    COLORREF FAR* lpCustColors;
    DWORD   Flags;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
} CHOOSECOLOR;
typedef CHOOSECOLOR FAR *LPCHOOSECOLOR;

BOOL    WINAPI ChooseColor(CHOOSECOLOR FAR*);

#define CC_RGBINIT               0x00000001
#define CC_FULLOPEN              0x00000002
#define CC_PREVENTFULLOPEN       0x00000004
#define CC_SHOWHELP              0x00000008
#define CC_ENABLEHOOK            0x00000010
#define CC_ENABLETEMPLATE        0x00000020
#define CC_ENABLETEMPLATEHANDLE  0x00000040

typedef struct tagFINDREPLACE
{
    DWORD    lStructSize;            /* size of this struct 0x20 */
    HWND     hwndOwner;              /* handle to owner's window */
    HINSTANCE hInstance;             /* instance handle of.EXE that
                                      * contains cust. dlg. template
                                      */
    DWORD    Flags;                  /* one or more of the FR_?? */
    LPSTR    lpstrFindWhat;          /* ptr. to search string    */
    LPSTR    lpstrReplaceWith;       /* ptr. to replace string   */
    UINT     wFindWhatLen;           /* size of find buffer      */
    UINT     wReplaceWithLen;        /* size of replace buffer   */
    LPARAM   lCustData;              /* data passed to hook fn.  */
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
                                     /* ptr. to hook fn. or NULL */
    LPCSTR   lpTemplateName;         /* custom template name     */
} FINDREPLACE;
typedef FINDREPLACE FAR *LPFINDREPLACE;

#define FR_DOWN 			0x00000001
#define FR_WHOLEWORD			0x00000002
#define FR_MATCHCASE			0x00000004
#define FR_FINDNEXT			0x00000008
#define FR_REPLACE			0x00000010
#define FR_REPLACEALL			0x00000020
#define FR_DIALOGTERM			0x00000040
#define FR_SHOWHELP			0x00000080
#define FR_ENABLEHOOK			0x00000100
#define FR_ENABLETEMPLATE		0x00000200
#define FR_NOUPDOWN			0x00000400
#define FR_NOMATCHCASE			0x00000800
#define FR_NOWHOLEWORD			0x00001000
#define FR_ENABLETEMPLATEHANDLE 	0x00002000
#define FR_HIDEUPDOWN			0x00004000
#define FR_HIDEMATCHCASE		0x00008000
#define FR_HIDEWHOLEWORD		0x00010000

HWND    WINAPI FindText(FINDREPLACE FAR*);
HWND    WINAPI ReplaceText(FINDREPLACE FAR*);

typedef struct tagCHOOSEFONT
{
    DWORD	    lStructSize;	/* */
    HWND	    hwndOwner;		/* caller's window handle   */
    HDC 	    hDC;		/* printer DC/IC or NULL    */
    LOGFONT FAR*    lpLogFont;          /* ptr. to a LOGFONT struct */
    int		    iPointSize;		/* 10 * size in points of selected font */
    DWORD	    Flags;		/* enum. type flags	    */
    COLORREF        rgbColors;          /* returned text color      */
    LPARAM          lCustData;          /* data passed to hook fn.  */
    UINT (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
					/* ptr. to hook function    */
    LPCSTR          lpTemplateName;     /* custom template name     */
    HINSTANCE       hInstance;          /* instance handle of.EXE that
					 * contains cust. dlg. template
					 */
    LPSTR	    lpszStyle;		/* return the style field here 
					 * must be LF_FACESIZE or bigger */
    UINT            nFontType;          /* same value reported to the EnumFonts
					 * call back with the extra FONTTYPE_ 
					 * bits added */
    int		    nSizeMin;		/* minimum pt size allowed & */
    int		    nSizeMax;		/* max pt size allowed if    */
					/* CF_LIMITSIZE is used      */
} CHOOSEFONT;
typedef CHOOSEFONT FAR *LPCHOOSEFONT;

BOOL WINAPI ChooseFont(CHOOSEFONT FAR*);

#define CF_SCREENFONTS		     0x00000001
#define CF_PRINTERFONTS 	     0x00000002
#define CF_BOTH 		     (CF_SCREENFONTS | CF_PRINTERFONTS)
#define CF_SHOWHELP		     0x00000004L
#define CF_ENABLEHOOK		     0x00000008L
#define CF_ENABLETEMPLATE	     0x00000010L
#define CF_ENABLETEMPLATEHANDLE      0x00000020L
#define CF_INITTOLOGFONTSTRUCT       0x00000040L
#define CF_USESTYLE		     0x00000080L
#define CF_EFFECTS		     0x00000100L
#define CF_APPLY		     0x00000200L
#define CF_ANSIONLY		     0x00000400L
#define CF_NOVECTORFONTS	     0x00000800L
#define CF_NOOEMFONTS		     CF_NOVECTORFONTS
#define CF_NOSIMULATIONS	     0x00001000L
#define CF_LIMITSIZE		     0x00002000L
#define CF_FIXEDPITCHONLY	     0x00004000L
#define CF_WYSIWYG		     0x00008000L /* must also have CF_SCREENFONTS & CF_PRINTERFONTS */
#define CF_FORCEFONTEXIST	     0x00010000L
#define CF_SCALABLEONLY		     0x00020000L
#define CF_TTONLY		     0x00040000L
#define CF_NOFACESEL		     0x00080000L
#define CF_NOSTYLESEL		     0x00100000L
#define CF_NOSIZESEL		     0x00200000L

/* these are extra nFontType bits that are added to what is returned to the
 * EnumFonts callback routine */

#define SIMULATED_FONTTYPE	0x8000
#define PRINTER_FONTTYPE	0x4000
#define SCREEN_FONTTYPE		0x2000
#define BOLD_FONTTYPE		0x0100
#define ITALIC_FONTTYPE		0x0200
#define REGULAR_FONTTYPE	0x0400

#define WM_CHOOSEFONT_GETLOGFONT	(WM_USER + 1)


/* strings used to obtain unique window message for communication
 * between dialog and caller
 */
#define LBSELCHSTRING  "commdlg_LBSelChangedNotify"
#define SHAREVISTRING  "commdlg_ShareViolation"
#define FILEOKSTRING   "commdlg_FileNameOK"
#define COLOROKSTRING  "commdlg_ColorOK"
#define SETRGBSTRING   "commdlg_SetRGBColor"
#define FINDMSGSTRING  "commdlg_FindReplace"
#define HELPMSGSTRING  "commdlg_help"

/* HIWORD values for lParam of commdlg_LBSelChangeNotify message */
#define CD_LBSELNOITEMS -1
#define CD_LBSELCHANGE   0
#define CD_LBSELSUB      1
#define CD_LBSELADD      2

typedef struct tagPD
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HGLOBAL hDevMode;
    HGLOBAL hDevNames;
    HDC     hDC;
    DWORD   Flags;
    UINT    nFromPage;
    UINT    nToPage;
    UINT    nMinPage;
    UINT    nMaxPage;
    UINT    nCopies;
    HINSTANCE hInstance;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnPrintHook)(HWND, UINT, WPARAM, LPARAM);
    UINT    (CALLBACK* lpfnSetupHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpPrintTemplateName;
    LPCSTR  lpSetupTemplateName;
    HGLOBAL hPrintTemplate;
    HGLOBAL hSetupTemplate;
} PRINTDLG;
typedef PRINTDLG  FAR* LPPRINTDLG;

BOOL    WINAPI PrintDlg(PRINTDLG FAR*);

#define PD_ALLPAGES                  0x00000000
#define PD_SELECTION                 0x00000001
#define PD_PAGENUMS                  0x00000002
#define PD_NOSELECTION               0x00000004
#define PD_NOPAGENUMS                0x00000008
#define PD_COLLATE                   0x00000010
#define PD_PRINTTOFILE               0x00000020
#define PD_PRINTSETUP                0x00000040
#define PD_NOWARNING                 0x00000080
#define PD_RETURNDC                  0x00000100
#define PD_RETURNIC                  0x00000200
#define PD_RETURNDEFAULT             0x00000400
#define PD_SHOWHELP                  0x00000800
#define PD_ENABLEPRINTHOOK           0x00001000
#define PD_ENABLESETUPHOOK           0x00002000
#define PD_ENABLEPRINTTEMPLATE       0x00004000
#define PD_ENABLESETUPTEMPLATE       0x00008000
#define PD_ENABLEPRINTTEMPLATEHANDLE 0x00010000
#define PD_ENABLESETUPTEMPLATEHANDLE 0x00020000
#define PD_USEDEVMODECOPIES          0x00040000
#define PD_DISABLEPRINTTOFILE        0x00080000
#define PD_HIDEPRINTTOFILE           0x00100000

typedef struct tagDEVNAMES
{
    UINT wDriverOffset;
    UINT wDeviceOffset;
    UINT wOutputOffset;
    UINT wDefault;
} DEVNAMES;
typedef DEVNAMES FAR* LPDEVNAMES;

#define DN_DEFAULTPRN      0x0001

DWORD   WINAPI CommDlgExtendedError(void);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_COMMDLG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\webptprn\webptprn.h ===
/*---------------------------------------------------------------------------*\
| MODULE: webptprn.h
|
|   This is the main header module for the application.
|
|
| Copyright (C) 1996-1998 Hewlett Packard Company
| Copyright (C) 1996-1998 Microsoft Corporation
|
| history:
|   15-Dec-1996 <chriswil> created.
|
\*---------------------------------------------------------------------------*/

#include <windows.h>
#include <winspool.h>
#include <winver.h>
#include "globals.h"

#define MAX_BUFFER  255
#define MAX_RESBUF  128
#define MSG_BUFSIZE 256


#define IDS_MSG_ADD        1
#define IDS_MSG_DEL        2
#define IDS_MSG_REBOOT     3
#define IDS_MSG_UNINSTALL  4
#define IDS_ERR_COPY       5
#define IDS_ERR_ADD        6
#define IDS_ERR_ASC        7
#define IDS_REG_DISPLAY    8
#define IDS_ERR_OSVERHEAD  9
#define IDS_ERR_OSVERMSG   10

// MLAWRENC: This is actually defined in "\inet\setup\iexpress\common\res.h", but I don't want
// to create an interdependency, so redifine it here.

#if (!defined(RC_WEXTRACT_AWARE))
    #define RC_WEXTRACT_AWARE       0xAA000000  // means cabpack aware func return code
#endif

#if (!defined(REBOOT_YES))
    #define REBOOT_YES              0x00000001  // this bit off means no reboot
#endif

#if (!defined(REBOOT_ALWAYS))
    #define REBOOT_ALWAYS           0x00000002  // if REBOOT_YES is on and this bit on means always reboot
                                                //                         this bit is off means reboot if need
#endif


#define UNREFPARM(parm)  (parm)


// Function Macro mappings.
//
#define EXEC_PROCESS(lpszCmd, psi, ppi) \
    CreateProcess(NULL, lpszCmd, NULL, NULL, FALSE, 0, NULL, NULL, psi, ppi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for the library
*   functions related to directory handling and creation.
*
****/

#ifndef _INC_DIRECT

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

/* function prototypes */

int __cdecl _chdir(const char *);
int __cdecl _chdrive(int);
char * __cdecl _getcwd(char *, int);
char * __cdecl _getdcwd(int, char *, int);
int __cdecl _getdrive(void);
int __cdecl _mkdir(const char *);
int __cdecl _rmdir(const char *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */
int __cdecl chdir(const char *);
char * __cdecl getcwd(char *, int);
int __cdecl mkdir(const char *);
int __cdecl rmdir(const char *);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_DIRECT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\dbcs.h ===
/*
** dbcs.h - DBCS functions prototypes for DOS apps.
*/

extern int IsDBCSLeadByte(unsigned char uch);
extern unsigned char far *AnsiNext(unsigned char far *puch);
extern unsigned char far *AnsiPrev(unsigned char far *psz, unsigned char far *puch);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\dbcs.c ===
/*
** dbcs.c - DBCS functions for DOS apps.
**
** Written by RokaH and DavidDi.
*/


/* Headers
**********/

#include <dos.h>
#include <ctype.h>

#include <dbcs.h>


/*
** int IsDBCSLeadByte(unsigned char uch);
**
** Check to see if a character is a DBCS lead byte.
**
** Arguments:  uch - charcter to examine
**
** Returns:    int - 1 if the character is a DBCS lead byte.  0 if not.
**
** Globals:    none
*/
int IsDBCSLeadByte(unsigned char uch)
{
   static unsigned char far *DBCSLeadByteTable = 0;
   union REGS inregs, outregs;
   struct SREGS segregs;
   unsigned char far *puch;

   if (DBCSLeadByteTable == 0)
   {
      /*
      ** Get DBCS lead byte table.  This function has been supported since
      ** DBCS MS-DOS 2.21.
      */
      inregs.x.ax = 0x6300;
      intdosx(&inregs, &outregs, &segregs);

      FP_OFF(DBCSLeadByteTable) = outregs.x.si;
      FP_SEG(DBCSLeadByteTable) = segregs.ds;
   }

   /* See if the given byte is in any of the table's lead byte ranges. */
   for (puch = DBCSLeadByteTable; puch[0] || puch[1]; puch += 2)
      if (uch >= puch[0] && uch <= puch[1])
         return(1);

   return(0);
}


/*
** unsigned char *AnsiNext(unsigned char *puch);
**
** Moves to the next character in a string.
**
** Arguments:  puch - pointer to current location in string
**
** Returns:    char * - Pointer to next character in string.
**
** Globals:    none
**
** N.b., if puch points to a null character, AnsiNext() will return puch.
*/
unsigned char far *AnsiNext(unsigned char far *puch)
{
   if (*puch == '\0')
      return(puch);
   else if (IsDBCSLeadByte(*puch))
      puch++;

   puch++;

   return(puch);
}


/*
** unsigned char *AnsiPrev(unsigned char *psz, unsigned char *puch);
**
** Moves back one character in a string.
**
** Arguments:  psz  - pointer to start of string
**             puch - pointer to current location in string
**
** Returns:    char * - Pointer to previous character in string.
**
** Globals:    none
**
** N.b., if puch <= psz, AnsiPrev() will return psz.
**
** This function is implemented in a very slow fashion because we do not wish
** to trust that the given string is necessarily DBCS "safe," i.e., contains
** only single-byte characters and valid DBCS characters.  So we start from
** the beginning of the string and work our way forward.
*/
unsigned char far *AnsiPrev(unsigned char far *psz, unsigned char far *puch)
{
   unsigned char far *puchPrevious;

   do
   {
      puchPrevious = psz;
      psz = AnsiNext(psz);
   } while (*psz != '\0' && psz < puch);

   return(puchPrevious);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\drivinit.h ===
/* OBSOLETE: Use print.h instead */
#include <print.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\debug.h ===
/* This include file contains the functions needed by debuggers which run
 * under windows. 
 */

/* USER functions */
BOOL FAR PASCAL QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
BOOL FAR PASCAL LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG FAR PASCAL GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState. 
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004

/* Kernel procedures */
void FAR PASCAL DirectedYield(HANDLE hTask);

/* Debug hook to support debugging through other hooks. 
 */
#define WH_DEBUG        9

typedef struct tagDEBUGHOOKSTRUCT
  {
    WORD   hAppHookTask;   //"hTask" of the task that installed the app hook
    DWORD  dwUnUsed;       // This field is unused.
    LONG   lAppHooklParam; //"lParam" of the App hook.
    WORD   wAppHookwParam; //"wParam" of the App hook.
    int	   iAppHookCode;   //"iCode" of the App hook.
  } DEBUGHOOKSTRUCT;

typedef DEBUGHOOKSTRUCT FAR *LPDEBUGHOOKSTRUCT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\dlgs.h ===
/*****************************************************************************\
*                                                                             *
* dlgs.h -      Common dialog's dialog element ID numbers                     *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_DLGS
#define _INC_DLGS

#define ctlFirst    0x0400
#define ctlLast     0x04ff
    /* Push buttons */
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f
    /* Checkboxes */
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f
    /* Radio buttons */
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f
    /* Groups, frames, rectangles, and icons */
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f
    /* Edit controls */
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f
    /* Scroll bars */
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

/* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 */
#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544

#endif  /* !_INC_DLGS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\dosx.inc ===
;******************************************************************************
;
;   Copyright (c) Microsoft Corporation 1989-1990.
;
;   Title:	DOSX.INC - Equates and Structures for 286 DOS Extender
;			   Int 2Fh Interface
;
;   Version:	3.00
;
;   Date:	27-Jun-1989
;
;   Author:	JEM
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   27-Jun-1989 JEM Original
;
;==============================================================================


DOSXFunc	EQU	46h		;286 DOS Extender Int 2Fh Multiplex ID


; DOSX Int 2Fh subfunctions

DOSXQuery	EQU	00h		;Query DOS Extender installation
DOSXSuspend	EQU	01h		;Suspend Network posting call
DOSXResume	EQU	02h		;Resume Network posting call
DOSXAbort	EQU	03h		;Abort Child application call
DOSXInfo	EQU	04h		;Get Info structure pointer call

DOSXLast	EQU	DOSXInfo	;Last valid Int 2Fh request


; Structure returned in ES:BX by DOSXInfo call

DOSXInfoTbl	struc
DOSXInfoVer	dw	?		;version # of info structure
hXMSHeap	dw	?		;XMS handle to DOSX heap block
selAppBlk	dw	?		;1st selector to application memory blk
cbAppBlk	dd	?		;size in bytes of app memory block
ckReservedLow	dw	?		;size in K of low memory to reserve
DOSXInfoTbl	ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\debugsys.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	DEBUGSYS.INC - VMM debugging include file
;
;   Version:	1.00
;
;   Date:	13-Jun-1988
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;	       README	README	 README	   README    README
;
; The "master copy" of this file lives in the WIN386 include directory.
; If another copy of this file is ever checked in anywhere, the copy
; should be checked periodically to make sure it is identical with the
; master copy.
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   13-Jun-1988 RAL
;   24-Oct-1988 RAP changed INT from 2E to 41, and added functions for
;		    Windows to notify the debugger about segment selectors
;   14-Dec-1988 RAP split services into ones available through INT 41h
;		    for non-ring 0 clients and those available through INT 21h
;		    for ring 0 clients
;   11-Dec-1990 ERH Merged WIN386 copy with file actually used by the
;		    debugger.
;   11-Dec-1990 ERH Merged file describing real mode services with this
;		    one.
;
;==============================================================================

;******************************************************************************
;
;  Real mode Debugger services:
;
;

D386_RM_Int		equ 68h	; hooked by the debugger in real mode.

D386_Id			equ 0F386h ; debugger identification code

D386_MIN		equ 43h	; minimum INT 68 function code

D386_Identify		equ 43h	; returns debugger identification, if debugger
				; loaded

D386_Prepare_PMode	equ 44h	; partially prepare for protected mode operation
				; a pointer to a procedure is returned so that
				; the IDT can also be set in protected mode
				; INPUT:
				;   AL	0  - retail version of Win386
				;	1  - debugging version
				;   BX	a valid selector that gives access
				;	to all of memory
				;   CX	first of 2 selectors reserved for
				;	WDeb386 to use
				;   DX	is GDT selector
				;   DS:SI pointer to working copy of GDT
				;   ES:DI pointer to working copy of IDT
				;
				; RETURN:
				;   ES:EDI points to a protected mode procedure
				;   (selector:offset32) that can be called
				;   to set the IDT when it has been created.
				;   This protected mode procedure takes a
				;   pointer to the PMode IDT in ES:EDI.

D386_Real_Mode_Init	equ 45h	; re-init fro real mode after entering pmode

D386_Set_Switches	equ 46h	; set debugging switches
				;  BL = verbose switch
				;	- 00b - no segment display
				;	- 01b - display win386 segments only
				;	- 10b - display ring 1 segments only
				;	- 11b - display win386 & ring 1 segs
				;  BH = conditional brkpts
				;	0 - off
				;	1 - on
				; -1 for BX means no change (default)

D386_Execute_Cond	equ 47h	; execute conditional BP (/B option)
				; ES:SI points to NUL terminated string
				; to print if conditional flag set.

D386_Set_Baudrate	equ 49h	; set com port baud rate
				; BX = baud rate

D386_Reinit		equ 4ah	; reinitialize debugger for protected mode
				;  AL  0  - retail version of Win386
				;	  1  - debugging version of Win386
				;	  2  - 286 DOS extender (3.0)
				;	  3  - 286 DOS extender under VCPI (3.1)
				;	  4  - 286 DOS extender (3.1)
				;  BX  a valid selector that gives access
				;      to all of memory
				;  CX  first of 2 selectors reserved for
				;      wdeb386 to use
				;  DX  is GDT selector
				;
				;  This function can after a function 45h only
				;  if function	44 was executed in the past on
				;  the IDT/GDT.

D386_Def_Deb_Segs	equ 4bh	; define debugger's segments

D386_Set_Com_Port	equ 4ch	; set com port number
				; BX = com port number
				; returns AX != 0, error bad com port

D386_Link_Sym		equ 4dh	; link sym file map
				; ES:DI pointer to AddrS struc in front of
				; sym file map.
				; BX = loader ID (used to unlink sym file maps)
				; A loader ID of 0 is used for all the maps
				; wdeb386 loads via /S is ran as a program and
				; -1 is used by the device driver version.  All
				; loader IDs of 0 are automaticly unlinked when
				; wdeb386 exits.

D386_Unlink_Sym		equ 4eh	; unlink sym file maps
				; BX = loader ID - this routine looks at all
				; of the maps that are currently linked and
				; removes the ones that were loaded with this
				; ID.

D386_Remove_Segs	equ 4fh	; remove any undefined segments from the
				;  name module's symbols
				; ES:DI pointer to module name

D386_Load_Segment	equ 50h	; defines the actual segment/selector for a
				; loaded segment to allow for symbol processing
				; INPUT:
				;  AL segment type   0	- code selector
				;		     1	- data selector
				;		    10h - code segment
				;		    11h - data segment
				;		    40h - code segment & sel
				;		    41h - data segment & sel
				;		    80h - device driver code seg
				;		    81h - device driver data seg
				;  If AL < 80h then
				;    BX segment #
				;    CX actual segment/selector
				;    DX actual selector	 (if 40h or 41h)
				;    ES:DI pointer to module name
				;  Else
				;    ES:DI points to D386_Device_Params struc
				;
				; RETURN:
				;    AL = 1, if successful, else 0

D386_Display_Char	equ 51h	; display a character to the debugging terminal
				; AL = char to display

D386_Display_Str	equ 52h	; display a string to the debugging terminal
				; ES:SI points to NUL terminated string

D386_IsVxDInstalled	equ 53h	; returns if debug VxD has been installed
				; AL == 0 if not install, AL != 0 if installed

D386_VxDInstall		equ 54h	; sets that the debug VxD installed/uninstalled
				; BL == 0 if uninstall, BL != 0 if installed

D386_RegisterDotCmd	equ 55h	; registers dot command
				; BL = command letter
				; CX:SI = address of dot command routine
				; DX:DI = address of help text
				; returns AX == 0, no errors
				;	  AX != 0, dot command already used
				;		   or out of dot commands
				; Dot command routine:
				;   AL = command character
				;   DS:SI = linear address of command line
				;	    terminated by a NULL or ";".
				;   DS,ES = debugger's data selector
				;   returns AX == 0, no errors
				;	    AX !=0, command line or option error

D386_DeRegisterDotCmd	equ 56h	; de-registers dot command
				; BL = command letter

D386_Printf		equ 57h	; Printf
				; (DS:SI) = address of format string
				; (ES:DI) = address of the start of parameters
				; set DS_Printf for format char information

D386_Link_Sym_Phys	equ 58h	; link symbol file with physical address
				; (DX:CX) = physical address of one extra 
	 			;  paragraph front of map file image.
				; (SI) = XMS handle (0 if just physical)
				; (BX) = load id

D386_CheckMap		equ 59h	; DX:DI = pointer to module name
				; returns AX != 0, map found
				;	  AX == 0, map not found

D386_SetAutoLoadSym	equ 5ah	; (BL) != 0, auto load symbols
				; (BL) == 0, don't auto load symbols

D386_SetTeftiPort	equ 5bh	; (BX) = TEFTI port address

D386_ExecDebugCommand	equ 5ch	; execute debugger command script
				; (DS:SI) = ptr to debugger command script str
				; (CX) = size of script

D386_LoadCodeDataHigh	equ 5dh	; makes the debugger copy its code/data high
				; (DX:BX) = physical address to put debugger

D386_SetWinVersion	equ 5eh	; sets Windows version number
				; (DI) = Version number (default if this
				; api not called is 0300h).

D386_MAX		equ 5eh	; maximum INT 68 function code

; D386_Load_Segment type equates:

ST_code_sel	equ 0		; code selector
ST_data_sel	equ 1		; data selector
ST_code_seg	equ 10h		; code segment
ST_data_seg	equ 11h		; data segment
ST_dual_code	equ 40h		; code segment and selector
ST_dual_data	equ 41h		; data segment and selector
ST_device_code	equ 80h		; device driver code segment
ST_device_data	equ 81h		; device driver data segment

; D386_Load_Segment device load parameters structure

D386_Device_Params STRUC
DD_logical_seg	dw  ?	; logical segment # from map
DD_actual_sel	dw  ?	; actual selector value
DD_base		dd  ?	; linear address offset for start of segment
DD_length	dd  ?	; actual length of segment
DD_name		df  ?	; 16:32 ptr to null terminated device name
DD_sym_name	df  ?	; 16:32 ptr to null terminated symbolic
			; module name  (i.e. Win386)
DD_alias_sel	dw  ?	; alias selector value (0 = none)
D386_Device_Params ENDS

;
; VCPI information, passed to debugger when client is DOS Extender
; running as a VCPI client.  This information is used to get into
; and out of protected mode when running under a VCPI server.
;
;
; This structure is also used by the DOS Extender.
;
WdebVCPIInfo	  STRUC
;
; Enter protected mode information.
;
	fnVCPI	df	?	; VCPI protect mode server entry point
	rdsVCPI	dw	?	; Selector for VCPI server
;
; Enter v86 mode information.
;
	laVTP	dd	?	; linear address of data structure containing
				; values for system registers.
	Port67	dw	?	; Qualitas magic port for emulating INT 67h
WdebVCPIInfo	  ENDS
;
; The following structure contains the system register contents for the
; VCPI server to use when switching to protected mode.  It is taken
; from dxvcpi.inc in the DOSX project, and is part of the VCPI spec.
;
VTP	struc
	zaCr3VTP	dd	0	; physical addr of page directory
	laGdtrVTP	dd	0	; linear addr in first meg of gdtr
	laIdtrVTP	dd	0	; linear addr in first meg of idtr
	selLdtVTP	dw	0	; selector of ldt
	selTrVTP	dw	0	; selector of tr
	ipVTP		dw	0	; 48-bit address of protect
	unusedVTP	dw	0	;   mode entry point to xfer to
	csVTP		dw	0	;
VTP	ends

VCPI_RM_CALLOUT_INT	equ	67h	; v86 mode call to VCPI server
;
; Send this value in AX to the VCPI server to request V86 to protected
; mode switch or protected to V86 mode switch.
;
VCPI_PROT_ENTRY		equ	0DE0CH


;******************************************************************************
;
;  Protected mode Debugger services:
;
;


Debug_Serv_Int	     equ 41h	; Interrupt that calls Deb386 to perform
				; debugging I/O, AX selects the function as
				; described by the following equates

DS_Out_Char	equ	0	; function to display the char in DL
DS_In_Char	equ	1	; function to read a char into AL
DS_Out_Str	equ	2	; function to display a NUL terminated string
				; pointed to by DS:ESI
DS_Is_Char	equ	3	; Non blocking In_Chr

DS_DebLoaded	equ    4Fh	; check to see if the debugger is installed and
				; knows how to deal with protected mode programs
				; return AX = F386h, if true
DS_DebPresent	equ   0F386h

DS_Out_Str16	equ    12h	; function to display a NUL terminated string
				; pointed to by DS:SI
				; (same as function 2, but for 16 bit callers)

DS_ForcedGO16	equ    40h	; enter the debugger and perform the equivalent
				; of a GO command to force a stop at the
				; specified CS:IP
				; CX is the desired CS
				; BX is the desired IP

DS_LinkMap	equ    45h	; DX:(E)DI = ptr to paragraph in front of map

DS_UnlinkMap	equ    46h	; DX:(E)DI = ptr to paragraph in front of map

DS_CheckMap	equ    47h	; DX:(E)DI = pointer to module name
				; returns AX != 0, map found
				;	  AX == 0, map not found

DS_IsAutoLoadSym equ   48h	; returns AX != 0, auto load symbols
				; 	  AX == 0, don't auto load symbols

DS_LoadSeg	equ    50h	; define a segment value for the
				; debugger's symbol handling
				; SI type   0  - code selector
				;	    1  - data selector
				;	   80h - code segment
				;	   81h - data segment
				; BX segment #
				; CX actual segment/selector
				; DX data instance
				; ES:(E)DI pointer to module name

DS_LoadSeg_32	equ  0150h	; Define a 32-bit segment for Windows 32
				; SI type   0  - code selector
				;	    1  - data selector
				; DX:EBX points to a D386_Device_Params STRUC
				; with all the necessaries in it

DS_MoveSeg	equ    51h	; notify the debugger that a segment has moved
				; BX old segment value
				; CX new segment value

DS_FreeSeg	equ    52h	; notify the debugger that a segment has been
				; freed
				; BX segment value

DS_FreeSeg_32	equ  0152h	; notify the debugger that a segment has been
				; freed
				; BX segment number
				; DX:EDI pointer to module name

DS_DGH		equ    56h	; register "dump global heap" handler
				; BX is code offset
				; CX is code segment
DS_DFL		equ    57h	; register "dump free list" handler
				; BX is code offset
				; CX is code segment
DS_DLL		equ    58h	; register "dump LRU list" handler
				; BX is code offset
				; CX is code segment

DS_StartTask	equ    59h	; notify debugger that a new task is starting
				; BX is task handle
				; task's initial registers are stored on the
				; stack:
				;	push	cs
				;	push	ip
				;	pusha
				;	push	ds
				;	push	es
				;	push	ss
				;	push	sp

DS_Kernel_Vars	equ    5ah	; Used by the Windows kernel to tell the
				; debugger the location of kernel variables
				; used in the heap dump commands.
				; BX = version number of this data (03a0h)
				; DX:CX points to:
				;	WORD	 hGlobalHeap	****
				;	WORD	 pGlobalHeap	****
				;	WORD	 hExeHead	****
				;	WORD	 hExeSweep
				;	WORD	 topPDB
				;	WORD	 headPDB
				;	WORD	 topsizePDB
				;	WORD	 headTDB	****
				;	WORD	 curTDB		****
				;	WORD	 loadTDB
				;	WORD	 LockTDB
				;	WORD	 SelTableLen	****
				;	DWORD	 SelTableStart	****
				;
				; The starred fields are used by the
				; heap dump commands which are internal
				; to WDEB386.


DS_VCPI_Notify	equ    5bh	; notify debugger that DOS extender is
				; running under a VCPI implementation,
				; and register VCPI protect mode interface
				; ES:DI points to a data structure used to
				; get from V86 mode to Pmode under VCPI.
				; This is defined in the VCPI version
				; 1.0 spec.
DS_ReleaseSeg	equ    5ch	; This does the same as a DS_FreeSeg, but
				; it restores any breakpoints first.

DS_POSTLOAD	=	60h	; Used by the RegisterPTrace interface
DS_EXITCALL	=	62h	; Somebody will fill these in if we ever
DS_INT2		=	63h	; figure out what they are supposed to do.
DS_LOADDLL	=	64h
DS_DELMODULE	=	65h

DS_NEWTASK	=	0BH
DS_FLUSHTASK	=	0CH
DS_SWITCHOUT	=	0DH
DS_SWITCHIN	=	0EH

DS_IntRings	equ    20h	; function to tell debugger which INT 1's & 3's
				; to grab
				; BX = 0, grab only ring 0 ints
				; BX != 0, grab all ints
DS_IncludeSegs	equ    21h	; function to tell debugger to go ahead and
				; process INT 1's & 3's which occur in this
				; DX:DI points to list of selectors
				;   (1 word per entry)
				; CX = # of selectors (maximum of 20)
				;   CX = 0, to remove the list of segs
MaxDebugSegs = 20

DS_CondBP	equ 0F001h	; conditional break pt, if the command line
				; switch /B is given when the debugger is run
				; or the conditional flag is later set, then
				; this int should cause the program to break
				; into the debugger, else this int should be
				; ignored!
				; ESI points to a nul terminated string to
				; display if break is to happen.

DS_ForcedBP	equ 0F002h	; break pt, which accomplishes the same thing
				; as an INT 1 or an INT 3, but is a break point
				; that should be permanently left in the code,
				; so that a random search of source code would
				; not result in the accidental removal of this
				; necessary break_pt

DS_ForcedGO	equ 0F003h	; enter the debugger and perform the equivalent
				; of a GO command to force a stop at the
				; specified CS:EIP
				; CX is the desired CS
				; EBX is the desired EIP

DS_HardINT1	equ 0F004h	; check to see if INT 1 hooked for all rings
				; ENTER: nothing
				; EXIT: AX = 0, if no, 1, if yes

DS_FatalFault	equ 0F005h	; check if fault is hooked by debugger via VSF
				; ENTRY BX = trap number
				;	DX = error code
				;	CX:(E)SI = address of CS:(E)IP
				; EXIT: AL == 0, handle fault normally
				;	AL != 0, handled by debugger

DS_Out_Symbol	equ    0Fh	; find the symbol nearest to the address in
				; CX:EBX and display the result in the format
				; symbol name <+offset>
				; the offset is only included if needed, and
				; no CR&LF is displayed

DS_Disasm_Ins	equ    10h	; function to disassemble the instruction
				; pointed to by DS:ESI

DS_RegisterDotCommand  equ 70h	; registers a 32 bit dot command handler

;	This interface is used to register wdeb386 dot commands by FLAT 32
;	bit code.  The following conditions apply:
;
;	* The code will be run at ring 0
;	* Interrupts may not be enabled
;	* Must not access any not present pages or load invalid selectors
;	* Must stay on the stack called with when calling INT 41 services
;	* Must not change DS or ES from the FLAT selector
;
;	The help text is printed when .? is executed in the order of
;	registration.  The text must include CR/LF at the end; nothing
;	is added to the help text.
;
;	ENTRY:	(AX) = 0070h
;		(BL) = dot command to register
;		(ESI) = linear address of dot command routine
;		    Dot command routine:
;			ENTRY:	(AL) = command character
;				(DS, ES) = flat data selector
;
;			EXIT:	(AX) == 0, no errors
;				(AX) !=0, command line or option error
;
;			NOTE:	MUST return with a 32 bit FAR return (retfd)
;		(EDI) = linear address of help text
;
;	EXIT:	(AX) == 0, no errors
;		(AX) != 0, dot command already used or out of dot commands

DS_RegisterDotCommand16 equ 71h	; registers a 16 bit dot command handler

;	This interface is used to register wdeb386 dot commands by 16 bit
;	code.  The following conditions apply:
;
;	* The code will be run at ring 0 or in real mode
;	* Interrupts may not be enabled
;	* Must not access any not present pages or load invalid selectors
;	* Must stay on the stack called with when calling INT 41 services
;
;	The help text is printed when .? is executed in the order of
;	registration.  The text must include CR/LF at the end; nothing
;	is added to the help text.
;
;	ENTRY:	(AX) = 0071h
;		(BL) = dot command to register
;		(CX:SI) = address of dot command routine
;		    Dot command routine:
;			ENTRY:	(AL) = command character
;				(DS, ES) = debugger's data selector
;
;			EXIT:	(AX) == 0, no errors
;				(AX) != 0, command line or option error
;
;			NOTE:	MUST return with a 16 bit FAR return (retf)
;		(DX:DI) = address of help text
;
;	EXIT:	(AX) == 0, no errors
;		(AX) != 0, dot command already used or out of dot commands

DS_DeRegisterDotCommand equ 72h	; de-registers 16 or 32 bit dot command

;	This interface is used to de-register wdeb386 dot commands registered
;	by the above 16 or 32 bit services.  Care should be used not to
;	de-register dot commands that weren't registered by your code.
;
;	ENTRY:	(AX) = 0072h
;		(BL) = dot command to de-register
;
;	EXIT:	NONE

DS_Printf	equ	73h	; print formatted output

;	This function allows formatted output with the standard "C"
;	printf syntax.
;
;	ENTRY:	(AX) = 0073h
;		(DS:ESI) = address of format string
;		(ES:EDI) = address of the start of the dword arguments
;
;	EXIT:	NONE
;
;	Supported types are:
;
;	%%							%
;	%[l][h]c						character
;	%[-][+][ ][0][width][.precision][l][h][p][n]d		decimal
;	%[-][0][width][.precision][l][h][p][n]u			unsigned decimal
;	%[-][#][0][width][.precision][l][h][p][n]x		hex
;	%[-][#][0][width][.precision][l][h][p][n]X		hex
;	%[-][0][width][.precision][l][h][p][n]o			octal
;	%[-][0][width][.precision][l][h][p][n]b			binary
;	%[-][width][.precision][l][h][a][F]s			string
;	%[-][width][.precision][l][h][a][p][n][F][L][H][N]S	symbol
;	%[-][width][.precision][l][h][a][p][n][F][L][H][N]G	group:symbol
;	%[-][width][.precision][l][h][a][p][n][F][L][H][N]M	map:group:symbol
;	%[-][width][.precision][l][h][a][p][n][F][L][H][N]A	address
;
;	Where "width" or "precision" is a decimal number or the '*' 
;	character; '*' causes the field width or precision to be picked
;	up from the next parameter. []'ed parameters are optional.
;
;	"\r", "\t", "\n", "\a", "\b", are supported directly.
;
;	Prefixes
;	--------
;
;	Used with c,d,u,x,X,o,b:
;
;	Parameter Argument Size
;	-----------------------
;	word					h
;	dword					l
;
;	Used with s,S,G,M,A:
;
;	Address Argument Size
;	---------------------
;	16 bit DS relative			h
;	16:16 segment:offset			hF or Fh
;	32 bit flat relative			l
;	16:32 segment:offset (2 dwords)		lF or Fl
;	pointer to AddrS structure		a
;
;	Used with S,G,M,A:
;
;	Address Display Size or Format
;	------------------------------
;	16 bit offset				H
;	32 bit offset				L
;	offset only				N
;
;	Default display size depends on the "386env" flag setting.
;
;	Used with S,G,M:
;
;	gets the previous symbol		p
;	gets the next symbol			n
;
;	Used with A:
;
;	gets the previous symbol address	p
;	gets the next symbol address		n
;
;	Used with d,u,x,X,o,b:
;
;	gets the previous symbol offset		p
;	gets the next symbol offset		n
;

DS_Printf16	equ	74h	; print formatted 16 bit output

;	This function allows formatted output with the standard "C"
;	printf syntax.
;
;	ENTRY:	(AX) = 0074h
;		(DS:SI) = address of format string
;		(ES:DI) = address of the start of the word or dword arguments
;
;	EXIT:	NONE
;
;	The format options and parameters are the same as DS_Printf except
;	the default parameter size is a word (the h option is implicit).
;

DS_GetRegisterSet equ 75h	; get the debugger's registers

;	This function copies the current register set.
;
;	ENTRY:	(AX) = 0075h
;		(DS:ESI) = address of SaveRegs_Struc structure
;
;	EXIT:	NONE
;

DS_SetAlternateRegisterSet equ 76h	; set the debugger's registers

;	This function temporary sets the debugger's registers to values
;	passed in the structure.  If an "r" command is executed or the
;	debugged code is returned to (via the "g", "t" or "p" commands),
;	the register set reverts to the debugged code's registers.
;
;	ENTRY:	(AX) = 0076h
;		(CX) = thread ID, 0 use current thread ID
;		(DS:ESI) = address of SaveRegs_Struc structure
;
;	EXIT:	NONE
;

DS_GetCommandLineChar equ  77h	; get a character from the command line

;	This services gets the next character off the command line.
;
;	ENTRY:	(AX) = 0077h
;		(BL) == 0 just peek the character, don't increment text pointer
;		          leading white space isn't ignored
;		(BL) != 0 get the character, increment text pointer
;			  leading white space is skipped
;
;	EXIT:	(AL) = command line character
;		(AH) == 0 if no more characters (EOL)
;		(AH) != 0 if more characters
;

DS_EvaluateExpression equ  78h	; evaluate debugger command line expression

;	Expressions can be numbers of various radices, symbols, addresses
;	or an combination of the above hooked together with various
;	operators.  Expressions are separated by blanks or commas.  This
;	function is passed a pointer to the beginning of the text of the
;	expression (i.e. "%80003444+4232").  The expression is either
;	evaluated down into a dword value if there are no addresses or 
;	into a linear address.
;
;	ENTRY:	(AX) = 0078h
;
;	EXIT:	(AX) == 0, returning a data value
;		(AX) != 0, returning a linear address
;		(EBX) = return value
;
;	NOTE:	If the expression is invalid, this service will not
;		return.  A message is printed and control returns to
;		the command loop.
;

DS_VerifyMemory	equ	79h	; verify the memory is valid and present

;	ENTRY:	(AX) = 0079h
;		(ECX) = length of memory region
;		(DS:ESI) = address of memory to verify
;
;	EXIT:	(AX) == 0, no errors
;		(AX) != 0, invalid memory

DS_PrintRegisters equ 7ah	; print the register set (the "r" command)

;	This function prints (just like the "r" command) the either the
;	debugged code's registers or the alternate register set, set with
;	DS_SetAlternateRegisterSet function.
;
;	ENTRY:	(AX) = 007ah
;
;	EXIT:	NONE
;
;	NOTE:	If the CS:EIP is invalid, this service will not return
;		because of an error when the code is disassembled.  A 
;		message is printed and control returns to the command loop.
;

DS_PrintStackDump equ 7bh	; dumps the [E]BP stack chain (the "k" command)

;	This function prints (just like the "k" command) the stack dump
;	based on the current register set that may have been set with 
;	DS_SetAlternateRegisterSet function.
;
;	ENTRY:	(AX) = 007bh
;		(BX) = flags
;			01h - verbose stack dump
;			02h - 16 bit stack dump
;			04h - 32 bit stack dump
;
;	EXIT:	NONE
;
;	NOTE:	If the CS:EIP or SS:EBP are invalid, this service will not
;		return because of an error when accessing the stack.  A 
;		message is printed and control returns to the command loop.
;

DS_SetThreadID	equ  7ch	; sets the debugger's thread ID

;	This function sets what the debugger thinks the thread ID is
;	for memory address in other address contexts.  It stays set
;	until the debugged code is returned to (via "g", "t" or "p")
;	or set back to 0.
;
;	ENTRY:	(AX) = 007ch
;		(CX) = thread ID or 0 for currently executed thread
;
;	EXIT:	NONE

DS_ExecDebugCommand equ  7dh	; execute debugger command script

;	This service allows any debugger command to be executed.  In can
;	be a multi-lined script with the lines separated by CR, LF.  MUST
;	have a "g" command at the end of script so the debugger doesn't
;	stop while in the INT 41.
;
;	ENTRY:	(AX) = 007dh
;		(DS:ESI) = pointer to debugger command script string
;		(CX) = size of script
;
;	EXIT:	NONE

;
;   Interupt and services that Win386 provides to the debugger
;

Win386_Query_Int    equ 22h	; interrupt for Win386 protected mode
				; interface requests

Win386_Alive	    equ 0	; function 0, query Win386 installation
Win386_Q_Ack	    equ 0F386h	;	good response from func 43h, of
				;	INT 68h & func 4fh of INT 41h

Win386_Query	    equ 1	; function 1, query Win386 state
				;	ds:esi points to command string
				;	that Win386 needs to process
				;	ds:edi points to the SaveRegs_Struc
				;	that the debugger has stored all the
				;	client register state into.
				;	(Win386 just writes the query
				;	answers directly to the output
				;	device, so no response is
				;	returned)

Win386_PhysToLinr   equ 2	; function 2, have Win386 convert a
				;	physical address into a valid
				;	linear address that Deb386 can
				;	use.  esi is physicaladdress
				;	cx is # of bytes required
				;	returns esi as linear address
				;	returns ax = 1, if okay, else
				;	0, if request couldn't be
				;	completed

Win386_AddrValid    equ 3	; function 3, have Win386 check the
				;	validity of a linear address
				;	esi is linear address to check
				;	cx is # of bytes required
				;	returns ax = 1, if address okay
				;	else ax = 0

Win386_MapVM	    equ 4	; function 4, make sure that the VM's
				;	low memory is mapped in, in case
				; it is touched (a count is maintained)
Win386_UnmapVM	    equ 5	; function 5, map out the VM's low
				; memory (dec the count)
Win386_GetDLAddr    equ 6	; function 6, return offset of dyna-link
				;	service.  EBX = Device ID << 10h +
				;	Service #.  Returns EAX = Offset.
Max_Win386_Services equ 6


SaveRegs_Struc STRUC
Debug_EAX	dd	?
Debug_EBX	dd	?
Debug_ECX	dd	?
Debug_EDX	dd	?
Debug_ESP	dd	?
Debug_EBP	dd	?
Debug_ESI	dd	?
Debug_EDI	dd	?
Debug_ES	dw	?
Debug_SS	dw	?
Debug_DS	dw	?
Debug_FS	dw	?
Debug_GS	dw	?
Debug_EIP	dd	?
Debug_CS	dw	?
		dd	?
Debug_EFlags	dd	?
Debug_CR0	dd	?
Debug_GDT	dq	?
Debug_IDT	dq	?
Debug_LDT	dw	?
Debug_TR	dw	?
Debug_CR2	dd	?
Debug_CR3	dd	?
Debug_DR0	dd	?
Debug_DR1	dd	?
Debug_DR2	dd	?
Debug_DR3	dd	?
Debug_DR6	dd	?
Debug_DR7	dd	?
Debug_DR7_2	dd	?
Debug_TR6	dd	?
Debug_TR7	dd	?
Debug_TrapNumber dw	-1		; -1 means no trap number
Debug_ErrorCode	dw	0		; 0 means no error code
SaveRegs_Struc ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\cpl.h ===
/*****************************************************************************\
*                                                                             *
* cpl.h -       Control panel extension DLL definitions                       *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
******************************************************************************
*  General rules for being installed in the Control Panel:
*
*      1) The DLL must export a function named CPlApplet which will handle
*         the messages discussed below.
*      2) If the applet needs to save information in CONTROL.INI minimize
*         clutter by using the application name [MMCPL.appletname].
*      2) If the applet is refrenced in CONTROL.INI under [MMCPL] use
*         the following form:
*              ...
*              [MMCPL]
*              uniqueName=c:\mydir\myapplet.dll
*              ...
*
*
*  The order applet DLL's are loaded by CONTROL.EXE is:
*
*      1) MAIN.CPL is loaded from the windows system directory.
*
*      2) Installable drivers that are loaded and export the
*         CplApplet() routine.
*
*      3) DLL's specified in the [MMCPL] section of CONTROL.INI.
*
*      4) DLL's named *.CPL from windows system directory.
*
*/
#ifndef _INC_CPL
#define _INC_CPL

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * CONTROL.EXE will answer this message and launch an applet
 *
 * WM_CPL_LAUNCH
 *
 *      wParam      - window handle of calling app
 *      lParam      - LPSTR of name of applet to launch
 *
 * WM_CPL_LAUNCHED
 *
 *      wParam      - TRUE/FALSE if applet was launched
 *      lParam      - NULL
 *
 * CONTROL.EXE will post this message to the caller when the applet returns
 * (ie., when wParam is a valid window handle)
 *
 */
#define WM_CPL_LAUNCH   (WM_USER+1000)
#define WM_CPL_LAUNCHED (WM_USER+1001)

/* A function prototype for CPlApplet() */

typedef LRESULT (CALLBACK *APPLET_PROC)(HWND hwndCpl, UINT msg, LPARAM lParam1, LPARAM lParam2);

/* The data structure CPlApplet() must fill in. */

typedef struct tagCPLINFO
{
    int     idIcon;     /* icon resource id, provided by CPlApplet() */
    int     idName;     /* name string res. id, provided by CPlApplet() */
    int     idInfo;     /* info string res. id, provided by CPlApplet() */
    LONG    lData;      /* user defined data */
} CPLINFO, *PCPLINFO, FAR *LPCPLINFO;

typedef struct tagNEWCPLINFO
{
    DWORD       dwSize;         /* similar to the commdlg */
    DWORD	dwFlags;
    DWORD       dwHelpContext;  /* help context to use */
    LONG        lData;          /* user defined data */
    HICON       hIcon;          /* icon to use, this is owned by CONTROL.EXE (may be deleted) */
    char        szName[32];     /* short name */
    char        szInfo[64];     /* long name (status line) */
    char        szHelpFile[128];/* path to help file to use */
} NEWCPLINFO, *PNEWCPLINFO, FAR *LPNEWCPLINFO;


/* The messages CPlApplet() must handle: */

#define CPL_INIT        1
/*  This message is sent to indicate CPlApplet() was found. */
/*  lParam1 and lParam2 are not defined. */
/*  Return TRUE or FALSE indicating whether the control panel should proceed. */


#define CPL_GETCOUNT    2
/*  This message is sent to determine the number of applets to be displayed. */
/*  lParam1 and lParam2 are not defined. */
/*  Return the number of applets you wish to display in the control */
/*  panel window. */


#define CPL_INQUIRE     3
/*  This message is sent for information about each applet. */
/*  lParam1 is the applet number to register, a value from 0 to */
/*  (CPL_GETCOUNT - 1).  lParam2 is a far ptr to a CPLINFO structure. */
/*  Fill in CPL_INFO's idIcon, idName, idInfo and lData fields with */
/*  the resource id for an icon to display, name and description string ids, */
/*  and a long data item associated with applet #lParam1. */


#define CPL_SELECT      4
/*  This message is sent when the applet's icon has been clicked upon. */
/*  lParam1 is the applet number which was selected.  lParam2 is the */
/*  applet's lData value. */


#define CPL_DBLCLK      5
/*  This message is sent when the applet's icon has been double-clicked */
/*  upon.  lParam1 is the applet number which was selected.  lParam2 is the */
/*  applet's lData value. */
/*  This message should initiate the applet's dialog box. */


#define CPL_STOP        6
/*  This message is sent for each applet when the control panel is exiting. */
/*  lParam1 is the applet number.  lParam2 is the applet's lData  value. */
/*  Do applet specific cleaning up here. */


#define CPL_EXIT        7
/*  This message is sent just before the control panel calls FreeLibrary. */
/*  lParam1 and lParam2 are not defined. */
/*  Do non-applet specific cleaning up here. */


#define CPL_NEWINQUIRE	8
/* this is the same as CPL_INQUIRE execpt lParam2 is a pointer to a */
/* NEWCPLINFO structure.  this will be sent before the CPL_INQUIRE */
/* and if it is responed to (return != 0) CPL_INQUIRE will not be sent */

#define CPL_DO_PRINTER_SETUP	100	/* ;Internal */
#define CPL_DO_NETPRN_SETUP	101	/* ;Internal */

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_CPL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\ddeml.h ===
/*****************************************************************************\
*                                                                             *
*  ddeml.h -    DDEML API header file                                         *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/
#ifndef _INC_DDEML
#define _INC_DDEML

#ifndef RC_INVOKED
#pragma pack(1)
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {                /* Assume C declarations for C++ */
#endif /* __cplusplus */

#ifndef _INC_WINDOWS    /* If not included with 3.1 headers... */
#define LPCSTR      LPSTR
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

#ifndef DECLARE_HANDLE32
#ifdef STRICT
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ _far* name
#else   /* STRICT */
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */
#endif  /* !DECLARE_HANDLE32 */

#define EXPENTRY    WINAPI

/******** public types ********/

DECLARE_HANDLE32(HCONVLIST);
DECLARE_HANDLE32(HCONV);
DECLARE_HANDLE32(HSZ);
DECLARE_HANDLE32(HDDEDATA);

/* the following structure is for use with XTYP_WILDCONNECT processing. */

typedef struct tagHSZPAIR
{
    HSZ hszSvc;
    HSZ hszTopic;
} HSZPAIR;
typedef HSZPAIR FAR *PHSZPAIR;

/* The following structure is used by DdeConnect() and DdeConnectList() and
   by XTYP_CONNECT and XTYP_WILDCONNECT callbacks. */

typedef struct tagCONVCONTEXT
{
    UINT        cb;             /* set to sizeof(CONVCONTEXT) */
    UINT        wFlags;         /* none currently defined. */
    UINT        wCountryID;     /* country code for topic/item strings used. */
    int         iCodePage;      /* codepage used for topic/item strings. */
    DWORD       dwLangID;       /* language ID for topic/item strings. */
    DWORD       dwSecurity;     /* Private security code. */
} CONVCONTEXT;
typedef CONVCONTEXT FAR *PCONVCONTEXT;

/* The following structure is used by DdeQueryConvInfo(): */

typedef struct tagCONVINFO
{
    DWORD   cb;            /* sizeof(CONVINFO)  */
    DWORD   hUser;         /* user specified field  */
    HCONV   hConvPartner;  /* hConv on other end or 0 if non-ddemgr partner  */
    HSZ     hszSvcPartner; /* app name of partner if obtainable  */
    HSZ     hszServiceReq; /* AppName requested for connection  */
    HSZ     hszTopic;      /* Topic name for conversation  */
    HSZ     hszItem;       /* transaction item name or NULL if quiescent  */
    UINT    wFmt;          /* transaction format or NULL if quiescent  */
    UINT    wType;         /* XTYP_ for current transaction  */
    UINT    wStatus;       /* ST_ constant for current conversation  */
    UINT    wConvst;       /* XST_ constant for current transaction  */
    UINT    wLastError;    /* last transaction error.  */
    HCONVLIST hConvList;   /* parent hConvList if this conversation is in a list */
    CONVCONTEXT ConvCtxt;  /* conversation context */
    HWND    hwnd;          /* Added to allow access for NetDDE. */
    HWND    hwndPartner;   /* Added to allow access for NetDDE. */
} CONVINFO;
typedef CONVINFO FAR *PCONVINFO;

/***** conversation states (usState) *****/

#define     XST_NULL              0  /* quiescent states */
#define     XST_INCOMPLETE        1
#define     XST_CONNECTED         2
#define     XST_INIT1             3  /* mid-initiation states */
#define     XST_INIT2             4
#define     XST_REQSENT           5  /* active conversation states */
#define     XST_DATARCVD          6
#define     XST_POKESENT          7
#define     XST_POKEACKRCVD       8
#define     XST_EXECSENT          9
#define     XST_EXECACKRCVD      10
#define     XST_ADVSENT          11
#define     XST_UNADVSENT        12
#define     XST_ADVACKRCVD       13
#define     XST_UNADVACKRCVD     14
#define     XST_ADVDATASENT      15
#define     XST_ADVDATAACKRCVD   16

/* used in LOWORD(dwData1) of XTYP_ADVREQ callbacks... */
#define     CADV_LATEACK         0xFFFF

/***** conversation status bits (fsStatus) *****/

#define     ST_CONNECTED        0x0001
#define     ST_ADVISE           0x0002
#define     ST_ISLOCAL          0x0004
#define     ST_BLOCKED          0x0008
#define     ST_CLIENT           0x0010
#define     ST_TERMINATED       0x0020
#define     ST_INLIST           0x0040
#define     ST_BLOCKNEXT        0x0080
#define     ST_ISSELF           0x0100

/* DDE constants for wStatus field */

#define DDE_FACK	  	0x8000
#define DDE_FBUSY	  	0x4000
#define DDE_FDEFERUPD		0x4000
#define DDE_FACKREQ	        0x8000
#define DDE_FRELEASE  		0x2000
#define DDE_FREQUESTED		0x1000
#define DDE_FACKRESERVED	0x3ff0
#define DDE_FADVRESERVED	0x3fff
#define DDE_FDATRESERVED	0x4fff
#define DDE_FPOKRESERVED	0xdfff
#define DDE_FAPPSTATUS		0x00ff
#define DDE_FNOTPROCESSED   0x0000

/***** message filter hook types *****/

#define     MSGF_DDEMGR             0x8001

/***** codepage constants ****/

#define CP_WINANSI      1004    /* default codepage for windows & old DDE convs. */

/***** transaction types *****/

#define     XTYPF_NOBLOCK            0x0002  /* CBR_BLOCK will not work */
#define     XTYPF_NODATA             0x0004  /* DDE_FDEFERUPD */
#define     XTYPF_ACKREQ             0x0008  /* DDE_FACKREQ */

#define     XCLASS_MASK              0xFC00
#define     XCLASS_BOOL              0x1000
#define     XCLASS_DATA              0x2000
#define     XCLASS_FLAGS             0x4000
#define     XCLASS_NOTIFICATION      0x8000

#define     XTYP_ERROR              (0x0000 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK )
#define     XTYP_ADVDATA            (0x0010 | XCLASS_FLAGS         )
#define     XTYP_ADVREQ             (0x0020 | XCLASS_DATA | XTYPF_NOBLOCK )
#define     XTYP_ADVSTART           (0x0030 | XCLASS_BOOL          )
#define     XTYP_ADVSTOP            (0x0040 | XCLASS_NOTIFICATION)
#define     XTYP_EXECUTE            (0x0050 | XCLASS_FLAGS         )
#define     XTYP_CONNECT            (0x0060 | XCLASS_BOOL | XTYPF_NOBLOCK)
#define     XTYP_CONNECT_CONFIRM    (0x0070 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_XACT_COMPLETE      (0x0080 | XCLASS_NOTIFICATION  )
#define     XTYP_POKE               (0x0090 | XCLASS_FLAGS         )
#define     XTYP_REGISTER           (0x00A0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_REQUEST            (0x00B0 | XCLASS_DATA          )
#define     XTYP_DISCONNECT         (0x00C0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_UNREGISTER         (0x00D0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_WILDCONNECT        (0x00E0 | XCLASS_DATA | XTYPF_NOBLOCK)

#define     XTYP_MASK                0x00F0
#define     XTYP_SHIFT               4  /* shift to turn XTYP_ into an index */

/***** Timeout constants *****/

#define     TIMEOUT_ASYNC           -1L

/***** Transaction ID constants *****/

#define     QID_SYNC                -1L

/****** public strings used in DDE ******/

#define SZDDESYS_TOPIC          "System"
#define SZDDESYS_ITEM_TOPICS    "Topics"
#define SZDDESYS_ITEM_SYSITEMS  "SysItems"
#define SZDDESYS_ITEM_RTNMSG    "ReturnMessage"
#define SZDDESYS_ITEM_STATUS    "Status"
#define SZDDESYS_ITEM_FORMATS   "Formats"
#define SZDDESYS_ITEM_HELP      "Help"
#define SZDDE_ITEM_ITEMLIST     "TopicItemList"


/****** API entry points ******/

typedef HDDEDATA CALLBACK FNCALLBACK(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);
typedef FNCALLBACK *PFNCALLBACK;

#define     CBR_BLOCK                0xffffffffL

/* DLL registration functions */

UINT    WINAPI DdeInitialize(DWORD FAR* pidInst, PFNCALLBACK pfnCallback,
                DWORD afCmd, DWORD ulRes);

/*
 * Callback filter flags for use with standard apps.
 */

#define     CBF_FAIL_SELFCONNECTIONS     0x00001000
#define     CBF_FAIL_CONNECTIONS         0x00002000
#define     CBF_FAIL_ADVISES             0x00004000
#define     CBF_FAIL_EXECUTES            0x00008000
#define     CBF_FAIL_POKES               0x00010000
#define     CBF_FAIL_REQUESTS            0x00020000
#define     CBF_FAIL_ALLSVRXACTIONS      0x0003f000

#define     CBF_SKIP_CONNECT_CONFIRMS    0x00040000
#define     CBF_SKIP_REGISTRATIONS       0x00080000
#define     CBF_SKIP_UNREGISTRATIONS     0x00100000
#define     CBF_SKIP_DISCONNECTS         0x00200000
#define     CBF_SKIP_ALLNOTIFICATIONS    0x003c0000

/*
 * Application command flags
 */
#define     APPCMD_CLIENTONLY            0x00000010L
#define     APPCMD_FILTERINITS           0x00000020L
#define     APPCMD_MASK                  0x00000FF0L

/*
 * Application classification flags
 */
#define     APPCLASS_STANDARD            0x00000000L
#define     APPCLASS_MASK                0x0000000FL


BOOL    WINAPI DdeUninitialize(DWORD idInst);

/* conversation enumeration functions */

HCONVLIST WINAPI DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic,
            HCONVLIST hConvList, CONVCONTEXT FAR* pCC);
HCONV   WINAPI DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev);
BOOL    WINAPI DdeDisconnectList(HCONVLIST hConvList);

/* conversation control functions */

HCONV   WINAPI DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic,
            CONVCONTEXT FAR* pCC);
BOOL    WINAPI DdeDisconnect(HCONV hConv);
HCONV   WINAPI DdeReconnect(HCONV hConv);

UINT    WINAPI DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, CONVINFO FAR* pConvInfo);
BOOL    WINAPI DdeSetUserHandle(HCONV hConv, DWORD id, DWORD hUser);

BOOL    WINAPI DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction);


/* app server interface functions */

BOOL    WINAPI DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem);
BOOL    WINAPI DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd);

#define EC_ENABLEALL            0
#define EC_ENABLEONE            ST_BLOCKNEXT
#define EC_DISABLE              ST_BLOCKED
#define EC_QUERYWAITING         2

HDDEDATA WINAPI DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd);

#define DNS_REGISTER        0x0001
#define DNS_UNREGISTER      0x0002
#define DNS_FILTERON        0x0004
#define DNS_FILTEROFF       0x0008

/* app client interface functions */

HDDEDATA WINAPI DdeClientTransaction(void FAR* pData, DWORD cbData,
        HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType,
        DWORD dwTimeout, DWORD FAR* pdwResult);

/* data transfer functions */

HDDEDATA WINAPI DdeCreateDataHandle(DWORD idInst, void FAR* pSrc, DWORD cb,
            DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd);
HDDEDATA WINAPI DdeAddData(HDDEDATA hData, void FAR* pSrc, DWORD cb, DWORD cbOff);
DWORD   WINAPI DdeGetData(HDDEDATA hData, void FAR* pDst, DWORD cbMax, DWORD cbOff);
BYTE FAR* WINAPI DdeAccessData(HDDEDATA hData, DWORD FAR* pcbDataSize);
BOOL    WINAPI DdeUnaccessData(HDDEDATA hData);
BOOL    WINAPI DdeFreeDataHandle(HDDEDATA hData);

#define     HDATA_APPOWNED          0x0001



UINT WINAPI DdeGetLastError(DWORD idInst);

#define     DMLERR_NO_ERROR                    0       /* must be 0 */

#define     DMLERR_FIRST                       0x4000

#define     DMLERR_ADVACKTIMEOUT               0x4000
#define     DMLERR_BUSY                        0x4001
#define     DMLERR_DATAACKTIMEOUT              0x4002
#define     DMLERR_DLL_NOT_INITIALIZED         0x4003
#define     DMLERR_DLL_USAGE                   0x4004
#define     DMLERR_EXECACKTIMEOUT              0x4005
#define     DMLERR_INVALIDPARAMETER            0x4006
#define     DMLERR_LOW_MEMORY                  0x4007
#define     DMLERR_MEMORY_ERROR                0x4008
#define     DMLERR_NOTPROCESSED                0x4009
#define     DMLERR_NO_CONV_ESTABLISHED         0x400a
#define     DMLERR_POKEACKTIMEOUT              0x400b
#define     DMLERR_POSTMSG_FAILED              0x400c
#define     DMLERR_REENTRANCY                  0x400d
#define     DMLERR_SERVER_DIED                 0x400e
#define     DMLERR_SYS_ERROR                   0x400f
#define     DMLERR_UNADVACKTIMEOUT             0x4010
#define     DMLERR_UNFOUND_QUEUE_ID            0x4011

#define     DMLERR_LAST                        0x4011

HSZ     WINAPI DdeCreateStringHandle(DWORD idInst, LPCSTR psz, int iCodePage);
DWORD   WINAPI DdeQueryString(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage);
BOOL    WINAPI DdeFreeStringHandle(DWORD idInst, HSZ hsz);
BOOL    WINAPI DdeKeepStringHandle(DWORD idInst, HSZ hsz);
int     WINAPI DdeCmpStringHandles(HSZ hsz1, HSZ hsz2);


#ifndef NODDEMLSPY
/* */
/* DDEML public debugging header file info */
/* */

typedef struct tagMONMSGSTRUCT
{
    UINT    cb;
    HWND    hwndTo;
    DWORD   dwTime;
    HANDLE  hTask;
    UINT    wMsg;
    WPARAM  wParam;
    LPARAM  lParam;
} MONMSGSTRUCT;

typedef struct tagMONCBSTRUCT
{
    UINT   cb;
    WORD   wReserved;
    DWORD  dwTime;
    HANDLE hTask;
    DWORD  dwRet;
    UINT   wType;
    UINT   wFmt;
    HCONV  hConv;
    HSZ    hsz1;
    HSZ    hsz2;
    HDDEDATA hData;
    DWORD  dwData1;
    DWORD  dwData2;
} MONCBSTRUCT;

typedef struct tagMONHSZSTRUCT
{
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    WORD   wReserved;
    char   str[1];
} MONHSZSTRUCT;

#define MH_CREATE   1
#define MH_KEEP     2
#define MH_DELETE   3
#define MH_CLEANUP  4


typedef struct tagMONERRSTRUCT
{
    UINT    cb;
    UINT    wLastError;
    DWORD   dwTime;
    HANDLE  hTask;
} MONERRSTRUCT;

typedef struct tagMONLINKSTRUCT
{
    UINT    cb;
    DWORD   dwTime;
    HANDLE  hTask;
    BOOL    fEstablished;
    BOOL    fNoData;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HSZ     hszItem;
    UINT    wFmt;
    BOOL    fServer;
    HCONV   hConvServer;
    HCONV   hConvClient;
} MONLINKSTRUCT;

typedef struct tagMONCONVSTRUCT
{
    UINT    cb;
    BOOL    fConnect;
    DWORD   dwTime;
    HANDLE  hTask;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HCONV   hConvClient;
    HCONV   hConvServer;
} MONCONVSTRUCT;

#define     MAX_MONITORS            4
#define     APPCLASS_MONITOR        0x00000001L
#define     XTYP_MONITOR            (0x00F0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)

/*
 * Callback filter flags for use with MONITOR apps - 0 implies no monitor
 * callbacks.
 */
#define     MF_HSZ_INFO                  0x01000000
#define     MF_SENDMSGS                  0x02000000
#define     MF_POSTMSGS                  0x04000000
#define     MF_CALLBACKS                 0x08000000
#define     MF_ERRORS                    0x10000000
#define     MF_LINKS                     0x20000000
#define     MF_CONV                      0x40000000

#define     MF_MASK                      0xFF000000
#endif /* NODDEMLSPY */

#ifdef __cplusplus
}
#endif

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif /* _INC_DDEML */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\ime.h ===
//
//
//  IME.H - East Asia Input Method Editor definitions
//
//

#ifdef DBCS_IME

//
//  virtual key
//
#ifdef JAPAN
#define VK_DBE_ALPHANUMERIC	0x0f0
#define VK_DBE_KATAKANA		0x0f1
#define VK_DBE_HIRAGANA		0x0f2
#define VK_DBE_SBCSCHAR		0x0f3
#define VK_DBE_DBCSCHAR		0x0f4
#define VK_DBE_ROMAN		0x0f5
#define VK_DBE_NOROMAN		0x0f6
#define VK_DBE_IME_WORDREGISTER	0x0f7
#define VK_DBE_IME_DIALOG	0x0f8
#define VK_DBE_FLUSH		0x0f9
#define VK_DBE_CODEINPUT	0x0fa
#define VK_DBE_NOCODEINPUT	0x0fb
#endif // JAPAN
#ifdef TAIWAN
#define VK_OEM_SEMICLN		0x0ba	//   ;	** :
#define VK_OEM_EQUAL		0x0bb	//   =	** +
#define VK_OEM_COMMA		0x0bc	//   ,	** <
#define VK_OEM_MINUS		0x0bd	//   -	** _
#define VK_OEM_PERIOD		0x0be	//   .	** >
#define VK_OEM_SLASH		0x0bf	//   /	** ?
#define VK_OEM_3		0x0c0	//   `	** ~
#define VK_OEM_LBRACKET 	0x0db	//   [	** {
#define VK_OEM_BSLASH		0x0dc	//   \  ** |
#define VK_OEM_RBRACKET 	0x0dd	//   ]	** |
#define VK_OEM_QUOTE		0x0de	//   '  ** "
#endif // TAIWAN

//
//  switch for wParam of IME_MOVECONVERTWINDOW
//
#define MCW_DEFAULT		0x00
#define MCW_RECT		0x01
#define MCW_WINDOW		0x02
#define MCW_SCREEN		0x04
#define MCW_VERTICAL		0x08
#define MCW_CMD 		0x06	// command mask

//
//  switch for wParam of IME_SET_MODE and IME_GET_MODE
//
//
#if defined(JAPAN) || defined(TAIWAN)
#define IME_MODE_ALPHANUMERIC	0x0001
#define IME_MODE_KATAKANA	0x0002
#define IME_MODE_HIRAGANA	0x0004
#define IME_MODE_SBCSCHAR	0x0008
#define IME_MODE_DBCSCHAR	0x0010
#define IME_MODE_ROMAN		0x0020
#define IME_MODE_NOROMAN	0x0040
#define IME_MODE_CODEINPUT	0x0080
#define IME_MODE_NOCODEINPUT	0x0100
#endif // JAPAN || TAIWAN
#ifdef KOREA
#define IME_MODE_ALPHANUMERIC	0x0001
#define IME_MODE_SBCSCHAR       0x0002
#define IME_MODE_HANJACONVERT   0x0004
#endif // KOREA

//
//  IME function code
//
#define	IME_QUERY		0x03
#define IME_SETOPEN		0x04
#define	IME_GETOPEN		0x05
#define IME_ENABLE		0x06							/* ;Internal */
#define IME_MOVECONVERTWINDOW	0x08
#define IME_SET_MODE		0x10
#define IME_GET_MODE		0x11
#define IME_SETFONT		0x12
#define IME_SENDKEY		0x13
#define IME_DESTROY		0x14							/* ;Internal */
#define IME_PRIVATE		0x15
#define IME_WINDOWUPDATE	0x16
#define	IME_SELECT		0x17							/* ;Internal */
#define IME_WORDREGISTER	0x18
#ifdef KOREA
#define IME_CODECONVERT         0x20
#define IME_CONVERTLIST         0x21
#define IME_AUTOMATA            0x30
#define IME_HANJAMODE           0x31
#define IME_GETLEVEL            0x40
#define IME_SETLEVEL            0x41
#endif // KOREA
#ifdef TAIWAN
#define IME_SETUSRFONT		0x20
#define IME_QUERYUSRFONT	0x21
#define IME_INPUTKEYTOSEQUENCE	0x22
#define IME_SEQUENCETOINTERNAL	0x23
#define IME_QUERYIMEINFO	0x24
#define IME_DIALOG		0x25
#endif // TAIWAN

//
//  error code
//
#define IME_RS_ERROR		0x01	// genetal error
#define IME_RS_NOIME		0x02	// IME is not installed
#define IME_RS_TOOLONG		0x05	// given string is too long
#define IME_RS_ILLEGAL		0x06	// illegal charactor(s) is string
#define IME_RS_NOTFOUND 	0x07	// no (more) candidate
#define IME_RS_NOROOM		0x0a	// no disk/memory space
#define IME_RS_DISKERROR	0x0e	// disk I/O error

//
//  messge id
//
#define WM_IME_REPORT		0x0280	// WM_KANJIFIRST
#define IR_STRINGSTART		0x100
#define IR_STRINGEND		0x101
#define IR_MOREROOM		0x110
#define IR_OPENCONVERT		0x120
#define IR_CHANGECONVERT	0x121
#define IR_CLOSECONVERT		0x122
#define IR_FULLCONVERT		0x123
#define IR_IMESELECT		0x130
#define IR_STRING		0x140

//
//  IMM functions
//
typedef struct tagIMESTRUCT {
    WORD	fnc;		// function code
    WORD	wParam; 	// word parameter
    WORD	wCount; 	// word counter
    WORD	dchSource;	// offset to src from top of memory object
    WORD	dchDest;	// offset to dst from top of memory object
    LONG	lParam1;
    LONG	lParam2;
    LONG	lParam3;
} IMESTRUCT;
typedef IMESTRUCT      *PIMESTRUCT;
typedef IMESTRUCT NEAR *NPIMESTRUCT;
typedef IMESTRUCT FAR  *LPIMESTRUCT;

short FAR PASCAL SendIMEMessage( HWND, DWORD );
#ifdef TAIWAN
LONG FAR PASCAL WINNLSIMEControl(HWND,HWND,LPIMESTRUCT);
#endif

//
//  miscellaneous
//
#ifdef TAIWAN
#define STATUSWINEXTRA		10
#endif

#ifdef KOREA
//
//  ----- definitions for level2 apps -----
//

typedef unsigned char far *LPKSTR ;

/* VK from the keyboard driver */
#define VK_FINAL		0x18	// dummy VK to make final on mouse down
#define VK_IME_DIALOG		0xf1

#define CP_HWND			0
#define CP_OPEN			1
//#define CP_DIRECT		2
#define CP_LEVEL                3

#define lpSource(lpks) (LPSTR)((LPSTR)lpks+lpks->dchSource)
#define lpDest(lpks)   (LPSTR)((LPSTR)lpks+lpks->dchDest)

//
//  ----- definitions for level3 apps -----
//

/* VK to send to Applications */
#define VK_CONVERT		0x1C
#define VK_NONCONVERT		0x1D
#define VK_ACCEPT		0x1E
#define VK_MODECHANGE		0x1F

/* IME_CODECONVERT subfunctions */
#define IME_BANJAtoJUNJA        0x13
#define IME_JUNJAtoBANJA        0x14
#define IME_JOHABtoKS           0x15
#define IME_KStoJOHAB           0x16

/* IME_AUTOMATA subfunctions */
#define IMEA_INIT               0x01
#define IMEA_NEXT               0x02
#define IMEA_PREV               0x03

/* IME_HANJAMODE subfunctions */
#define IME_REQUEST_CONVERT     0x01
#define IME_ENABLE_CONVERT      0x02

/* IME_MOVEIMEWINDOW subfunctions */
#define INTERIM_WINDOW          0x00
#define MODE_WINDOW             0x01
#define HANJA_WINDOW            0x02

#endif // KOREA

#endif // DBCS_IME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\gpfix.inc ===
; GPFix.inc - definitions for GP exception handler code
; usage -
;  1) include gpfix.inc
;  2) bracket critical code with "beg_fault_trap handler" and
;     "end_fault_trap"
;  3) define a handler entry point where execution should continue
;    a) this must be in the same code segment as the faulty code
;    b) two extra words (fault IP/fault) will be pushed on the stack when
;	an exception occurs.  They should be popped before continuing.
;	This can be done with the 'fault_fix_stack' macro.
;	They are there if you want to determine which instruction faulted.
;    c) This handler can do whatever it likes.	Usually, it will return
;	an error code to the caller.
;  4) if you don't want to worry about the extra values on the stack,
;     use the fix_fault_stack macro to remove them

_bft_count = 0
_eft_count = 0

_bft_	macro	handler, count
	_bft_&count:
	_hft_&count = handler
endm

;
; Begin fault critical region.  'handler' is the address of
; the exception handler to jmp to if a fault occurs.
;
beg_fault_trap	macro	handler
	if _bft_count - _eft_count
		.err
		%out Mismatched beg_fault_trap/end_fault_trap pairs in beg_fault_trap
	endif
	_bft_ handler, %_bft_count
	_bft_count = _bft_count + 1
endm

_eft_	macro	count
	_eft_&count:
  _GPFIX    SEGMENT
        dw  seg _bft_&count, _bft_&count, _eft_&count, _hft_&count
  _GPFIX    ENDS
endm

;
; End fault critical region.
;
end_fault_trap  macro
	_eft_ %_eft_count
	_eft_count = _eft_count+1
	if _bft_count - _eft_count
            .err
            %out Mismatched beg_fault_trap/end_fault_trap pairs in end_fault_trap
	endif
endm

;
; Clean up stack in fault handler.
;
fault_fix_stack	macro
        add     sp, 4
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\int31.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	INT31.INC - Equates and Structures for Int 31h Interface
;
;   Version:	3.00
;
;   Date:	22-May-1989
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   22-May-1989 RAL Original
;
;==============================================================================



Int31_Sel_Mgt		EQU	00h
    SelMgt_Alloc_Sel	EQU	00h
    SelMgt_Free_Sel	EQU	01h
    SelMgt_Seg_To_Sel	EQU	02h
    SelMgt_Get_LDT_Base EQU	03h
    SelMgt_Lock_Sel	EQU	04h
    SelMgt_Unlock_Sel	EQU	05h
    SelMgt_Get_Base	EQU	06h
    SelMgt_Set_Base	EQU	07h
    SelMgt_Set_Limit	EQU	08h
    SelMgt_Set_Acc_Bits EQU	09h
    SelMgt_Alias_Sel	EQU	0Ah
    SelMgt_Get_Desc	EQU	0Bh
    SelMgt_Set_Desc	EQU	0Ch

Int31_DOS_Mem_Mgt	EQU	01h
    DOSMem_Allocate	EQU	00h
    DOSMem_Free 	EQU	01h
    DOSMem_Resize	EQU	02h

Int31_Int_Serv		EQU	02h
    Int_Get_Real_Vec	EQU	00h
    Int_Set_Real_Vec	EQU	01h
    Int_Get_Excep_Vec	EQU	02h
    Int_Set_Excep_Vec	EQU	03h

Int31_Trans_Serv	EQU	03h
    Trans_Sim_Int	EQU	00h
    Trans_Far_Call	EQU	01h
    Trans_Call_Int_Proc EQU	02h
    Trans_Call_Back	EQU	03h
    Trans_Free_CB	EQU	04h

Int31_Get_Version	EQU	04h

Int31_Mem_Mgt		EQU	05h
    MemMgt_Get_Info	EQU	00h
    MemMgt_Allocate	EQU	01h
    MemMgt_Free 	EQU	02h
    MemMgt_Resize	EQU	03h

Int31_Page_Lock 	EQU	06h
    Lock_Region 	EQU	00h
    Unlock_Region	EQU	01h
    Mark_Pageable	EQU	02h
    Mark_Not_Pageable	EQU	03h

Int31_Demand_Page_Tune	EQU	07h
    Page_Candidate	EQU	00h
    Page_Discard	EQU	01h

Int31_Map_Phys_Addr	EQU	08h

Int31_Virt_Int_State	EQU	09h
    Get_Clear_Int_State EQU	00h
    Get_Set_Int_State	EQU	01h
    Get_Int_State	EQU	02h


Real_Mode_Call_Struc	STRUC
RealMode_EDI	dd	?
RealMode_ESI	dd	?
RealMode_EBP	dd	?
		dd	?
RealMode_EBX	dd	?
RealMode_EDX	dd	?
RealMode_ECX	dd	?
RealMode_EAX	dd	?
RealMode_Flags	dw	?
RealMode_ES	dw	?
RealMode_DS	dw	?
RealMode_FS	dw	?
RealMode_GS	dw	?
RealMode_IP	dw	?
RealMode_CS	dw	?
RealMode_SP	dw	?
RealMode_SS	dw	?
Real_Mode_Call_Struc	ENDS


Real_Mode_Word_Regs	STRUC
RealMode_DI	dw	?
		dw	?
RealMode_SI	dw	?
		dw	?
RealMode_BP	dw	?
		dw	?
		dd	?
RealMode_BX	dw	?
		dw	?
RealMode_DX	dw	?
		dw	?
RealMode_CX	dw	?
		dw	?
RealMode_AX	dw	?
Real_Mode_Word_Regs	ENDS


Real_Mode_Byte_Regs	STRUC
		dd	4 dup (?)
RealMode_BL	db	?
RealMode_BH	db	?
		dw	?
RealMode_DL	db	?
RealMode_DH	db	?
		dw	?
RealMode_CL	db	?
RealMode_CH	db	?
		dw	?
RealMode_AL	db	?
RealMode_AH	db	?
Real_Mode_Byte_Regs	ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\locking.h ===
/***
*sys\locking.h - flags for locking() function
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the flags for the locking() function.
*   [System V]
*
****/

#ifndef _INC_LOCKING

#define _LK_UNLCK   0   /* unlock the file region */
#define _LK_LOCK    1   /* lock the file region */
#define _LK_NBLCK   2   /* non-blocking lock */
#define _LK_RLCK    3   /* lock for writing */
#define _LK_NBRLCK  4   /* non-blocking lock for writing */

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define LK_UNLCK       _LK_UNLCK
#define LK_LOCK        _LK_LOCK
#define LK_NBLCK       _LK_NBLCK
#define LK_RLCK        _LK_RLCK
#define LK_NBRLCK      _LK_NBRLCK
#endif 

#define _INC_LOCKING
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\gdidefs.inc ===
;/*
;***************************************************************************
;									   *
;   Copyright (C) 1983,1984,1985 by Microsoft Inc.			   *
;									   *
;***************************************************************************



;	GDI Definitions for Device Drivers
;
;	Since most of the routines only need a portion of these definitions,
;	conditional assembly flags have been defined in the various files
;	to only include portions as needed (as opposed to having a lot of
;	include files to mess with).  The flags are as follows:
;
;	incFont 	include font definitions
;	incDevice	include device definitions
;	incLogical	include logical object definitions
;	incDrawmode	include DrawMode structure definition
;	incOutput	include Output definitions
;	incControl	include Control definitions

page
;	General definitions that almost everyone will use.



;	Physical Bitmap Structure
;
;	Bitmap data structure passed to OEM routines.  Defines the location and
;	size of a main memory bitmap.



BITMAP		struc							    ;*/ typedef struct {		 /*

  bmType	    dw	0	; 0 means main memory bitmap.  Non-zero     ;*/ short int bmType;		 /*
				; is number of physical display and format
				; of the rest of the structure known only
				; to device driver
  bmWidth	    dw	0	; Width of bitmap in pixels		    ;*/ unsigned short int bmWidth;	 /*
  bmHeight	    dw	0	; Height of bitmap in pixels		    ;*/ unsigned short int bmHeight;	 /*
  bmWidthBytes	    dw	0	; #bytes per scan line			    ;*/ unsigned short int bmWidthBytes; /*
  bmPlanes	    db	0	; # of planes in bitmap 		    ;*/ BYTE		   bmPlanes;	 /*
  bmBitsPixel	    db	0	; # of bits per pixel			    ;*/ BYTE		   bmBitsPixel;  /*
  bmBits	    dd	0	; Far pointer to bits of main memory bitmap ;*/ BYTE FAR	  *bmBits;	 /*
  bmWidthPlanes     dd	0	; Product of bmWidthBytes and bmHeight	    ;*/ unsigned long int  bmWidthPlanes;/*
  bmlpPDevice	    dd	0	; Pointer to associated PDevice 	    ;*/ BYTE FAR	  *bmlpPDevice;  /*
  bmSegmentIndex    dw	0	; Index to plaens next segment if non-zero  ;*/ unsigned short int bmSegmentIndex; /*
  bmScanSegment     dw	0	; Number of scans per segment		    ;*/ unsigned short int bmScanSegment; /*
  bmFillBytes	    dw	0	; Number of unused bytes per segment	    ;*/ unsigned short int bmFillBytes;   /*
		    dw	0						    ;*/ unsigned short int futureUse4;	  /*
		    dw	0						    ;*/ unsigned short int futureUse5;	  /*
BITMAP		    ends						    ;*/ } BITMAP;			  /*

; structures used for Device Independent Bitmap (DIB) processing.
; all taken out of Presentation Manager's documentation 
;  Tuesday 25-October-1988 15:04   -by-   Ron Gery [rong]

; C definitions are provided below (separately).

; triple used in PM1.1 (BitmapCoreInfo) format color table
RGBTriple	    struc	
  rgbtBlue 	    db	0
  rgbtGreen 	    db	0
  rgbtRed 	    db	0
RGBTriple	    ends

; RGB DWORD used in PM2.0 format color table
RGBQuad		    struc
  rgbBlue 	    db	0
  rgbGreen 	    db	0
  rgbRed 	    db	0
  rgbReserved 	    db	0
RGBQuad		    ends

BitmapCoreHeader    struc
  bcSize 	    dd	0
  bcWidth 	    dw	0
  bcHeight 	    dw	0
  bcPlanes 	    dw	0
  bcBitCount 	    dw	0
BitmapCoreHeader    ends

; new format bitmap structure based on PM2.0 format DCR.
;  Tuesday 23-May-1989 16:05   -by-   Ron Gery [rong]

BitmapInfoHeader    struc
  biSize 	    dd	0
  biWidth 	    dd	0
  biHeight 	    dd	0
  biPlanes 	    dw	0
  biBitCount 	    dw	0

  biCompression	    dd  0
  biSizeImage 	    dd	0
  biXPelsPerMeter   dd	0
  biYPelsPerMeter   dd	0
  biClrUsed	    dd	0
  biClrImportant    dd	0
BitmapInfoHeader    ends

BitmapInfo	    struc
  bmiHeader	db (size BitmapInfoHeader) DUP (?)
  bmiColors	db ?			; array of RGBQUADS
BitmapInfo	    ends

BitmapCoreInfo	    struc
  bmciHeader	db (size BitmapCoreHeader) DUP (?)
  bmciColors	db ?			; array of RGBTRIPLES
BitmapCoreInfo	    ends

BI_RGB          equ    0h
BI_RLE8         equ    1h
BI_RLE4         equ    2h

	if	0

*/
/* C definitions for DIBs, as defined in windows.h */

typedef struct {
	DWORD	bcSize;
	WORD	bcWidth;
	WORD	bcHeight;
	WORD	bcPlanes;
	WORD	bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR *LPBITMAPCOREHEADER;
typedef BITMAPCOREHEADER *PBITMAPCOREHEADER;

typedef struct {
  	DWORD	   biSize;
  	DWORD	   biWidth;
  	DWORD	   biHeight;
  	WORD	   biPlanes;
  	WORD	   biBitCount;

	DWORD	   biCompression;
	DWORD	   biSizeImage;
	DWORD	   biXPelsPerMeter;
	DWORD	   biYPelsPerMeter;
	DWORD	   biClrUsed;
	DWORD	   biClrImportant;
} BITMAPINFOHEADER;

typedef BITMAPINFOHEADER FAR *LPBITMAPINFOHEADER;
typedef BITMAPINFOHEADER *PBITMAPINFOHEADER;

typedef struct {
	BYTE	rgbtBlue;
	BYTE	rgbtGreen;
	BYTE	rgbtRed;
} RGBTRIPLE;

typedef struct {
	BYTE	rgbBlue;
	BYTE	rgbGreen;
	BYTE	rgbRed;
	BYTE	rgbReserved;
} RGBQUAD;

typedef struct { 
    BITMAPCOREHEADER	bmicHeader;
    RGBQUAD		bmiColors[1];
} BITMAPINFO;

typedef BITMAPINFO FAR *LPBITMAPINFO;
typedef BITMAPINFO *PBITMAPINFO;


/* currently, if the low byte of biCompression is non zero, 
 * it must be one of following */

#define BI_RGB              0x00
#define BI_RLE8             0x01
#define BI_RLE4             0x02

#define BITMAP_SELECTED     0x01
#define BITMAP_64K	    0x01

#define DIBSIGNATURE	    0x4944
/*
	endif

    if	    0
*/
#ifndef NOPTRC
/*
    endif


PTTYPE		struc							    ;*/ typedef     struct {	    /*

  xcoord	dw	0		;x coordinate of point		    ;*/ short int xcoord;	    /*
  ycoord	dw	0		;y coordinate of point		    ;*/ short int ycoord;	    /*

PTTYPE		ends							    ;*/ } PTTYPE;		    /*
									    ;*/ typedef PTTYPE *PPOINT;     /*
									    ;*/ typedef PTTYPE FAR *LPPOINT; /*
    if	    0
*/
#define     POINT   PTTYPE
/*
    endif



RECT		struc							    ;*/ typedef struct {	    /*

  left		dw	0						    ;*/ short int left, 	    /*
  top		dw	0						    ;*/ 	  top,		    /*
  right 	dw	0						    ;*/ 	  right,	    /*
  bottom	dw	0						    ;*/ 	  bottom;	    /*

RECT		ends							    ;*/ } RECT; 		    /*
									    ;*/ typedef RECT  *PRECT;	    /*

    if	    0
*/
#endif
/*
    endif


BOXTYPE 	struc							    ;*/ typedef     struct {	    /*

  min		db	SIZE PTTYPE dup (?)   ;x,y starting coord	    ;*/ PTTYPE min;		    /*
  ext		db	SIZE PTTYPE dup (?)   ;x,y extents		    ;*/ PTTYPE ext;		    /*

BOXTYPE 	ends							    ;*/ } BOXTYPE;		    /*


									    ;*/ typedef RECT  FAR * LPRECT; /*

page
;	Logical Object Definitions  - incLogical
		ifdef	incLogical
		if	incLogical



OBJ_PEN 	equ	1
OBJ_BRUSH	equ	2
OBJ_FONT	equ	3

    if	0
*/
/* Object definitions used by GDI support routines written in C */

#define OBJ_PEN 	1
#define OBJ_BRUSH	2
#define OBJ_FONT	3
/*
    endif


LogBrush	struc							    ;*/ typedef struct {	    /*

  lbStyle	dw	0		;Style of logical BRUSH 	    ;*/ unsigned short int lbStyle; /*
  lbColor	dd	0		;RGB color			    ;*/ unsigned long int  lbColor; /*
  lbHatch	dw	0		;Hatching style 		    ;*/ unsigned short int lbHatch; /*
  lbBkColor	dd	0		;Background color for hatched brush ;*/ unsigned long int lbBkColor;/*

LogBrush	ends							    ;*/ } LOGBRUSH;		    /*

lbPattern      =       lbColor		; pointer to physical pattern

    if	0
*/
#define lbPattern	lbColor
/*
    endif



;	Brush styles defined by GDI

BS_SOLID	equ	0
BS_HOLLOW	equ	1
BS_HATCHED	equ	2
BS_PATTERN	equ	3

MaxBrushStyle	equ	3



;	Hatched Brush hatching styles defined by GDI

HS_HORIZONTAL	equ	0		; Horizontal		 -----
HS_VERTICAL	equ	1		; Vertical		 |||||
HS_FDIAGONAL	equ	2		; Foreward Diagonal	 /////
HS_BDIAGONAL	equ	3		; Backward Diagonal	 \\\\\
HS_CROSS	equ	4		; Cross 		 +++++
HS_DIAGCROSS	equ	5		; Diagonal Cross	 XXXXX

MaxHatchStyle	equ	5

    if	0
*/
/* Brush Style definitions used by GDI support routines written in C */

#define     BS_SOLID		0
#define     BS_HOLLOW		1
#define     BS_HATCHED		2
#define     BS_PATTERN		3

#define     MaxBrushStyle	3


/* Hatch Style definitions used by GDI support routines written in C */

#define     HS_HORIZONTAL	0	/* ----- */
#define     HS_VERTICAL 	1	/* ||||| */
#define     HS_FDIAGONAL	2	/* ///// */
#define     HS_BDIAGONAL	3	/* \\\\\ */
#define     HS_CROSS		4	/* +++++ */
#define     HS_DIAGCROSS	5	/* xxxxx */

#define     MaxHatchStyle	5
/*
    endif




;	Logical Pen Structure

LogPen		struc							    ;*/ typedef struct {	    /*

  lopnStyle	dw	0		;(solid, hollow, dashed..)	    ;*/ unsigned short int lopnStyle;/*
  lopnWidth	dw	0		;This is really a point type	    ;*/ PTTYPE		   lopnWidth;/*
		dw	0
  lopnColor	dd	0						    ;*/ unsigned long int  lopnColor;/*

LogPen		ends							    ;*/ } LOGPEN;		    /*

		errnz	<(SIZE PTTYPE) -4>



;	Line Style definitions

LS_SOLID	equ	  0
LS_DASHED	equ	  1
LS_DOTTED	equ	  2
LS_DOTDASHED	equ	  3
LS_DASHDOTDOT	equ	  4
LS_NOLINE	equ	  5
LS_INSIDEFRAME	equ	  6

MaxLineStyle	equ	LS_NOLINE

    if	0
*/
/* Line Style definitions used by GDI support routines written in C */

#define     LS_SOLID		0
#define     LS_DASHED		1
#define     LS_DOTTED		2
#define     LS_DOTDASHED	3
#define     LS_DASHDOTDOT	4
#define     LS_NOLINE		5
#define     LS_INSIDEFRAME	6
#define     MaxLineStyle	LS_NOLINE
/*
    endif



; Various constants for defining a logical font.
OUT_DEFAULT_PRECIS	equ	0
OUT_STRING_PRECIS	equ	1
OUT_CHARACTER_PRECIS	equ	2
OUT_STROKE_PRECIS	equ	3
OUT_TT_PRECIS		equ	4
OUT_DEVICE_PRECIS	equ	5
OUT_RASTER_PRECIS	equ	6
OUT_TT_ONLY_PRECIS	equ	7

CLIP_DEFAULT_PRECIS	equ	0
CLIP_CHARACTER_PRECIS	equ	1
CLIP_STROKE_PRECIS	equ	2
CLIP_MASK		equ	00Fh
CLIP_LH_ANGLES		equ	010h
CLIP_TT_ALWAYS		equ	020h
CLIP_EMBEDDED		equ	080h

DEFAULT_QUALITY 	equ	0
DRAFT_QUALITY		equ	1
PROOF_QUALITY		equ	2

DEFAULT_PITCH		equ	0
FIXED_PITCH		equ	1
VARIABLE_PITCH		equ	2

ANSI_CHARSET		equ	0
DEFAULT_CHARSET 	equ	1
SYMBOL_CHARSET		equ	2
SHIFTJIS_CHARSET	equ	128
HANGEUL_CHARSET 	equ	129
CHINESEBIG5_CHARSET	equ	136
OEM_CHARSET		equ	255



;	GDI font families.
FF_DONTCARE		equ 00000000b	; Don't care or don't know.
FF_ROMAN		equ 00010000b	; Variable stroke width, serifed.
					; Times Roman, Century Schoolbook, etc.
FF_SWISS		equ 00100000b	; Variable stroke width, sans-serifed.
					; Helvetica, Swiss, etc.
FF_MODERN		equ 00110000b	; Constant stroke width, serifed or sans-serifed.
					; Pica, Elite, Courier, etc.
FF_SCRIPT		equ 01000000b	; Cursive, etc.
FF_DECORATIVE		equ 01010000b	; Old English, etc.


;	Font weights lightest to darkest.
FW_DONTCARE		equ	0d
FW_THIN 		equ	100d
FW_EXTRALIGHT		equ	200d
FW_LIGHT		equ	300d
FW_NORMAL		equ	400d
FW_MEDIUM		equ	500d
FW_SEMIBOLD		equ	600d
FW_BOLD 		equ	700d
FW_EXTRABOLD		equ	800d
FW_HEAVY		equ	900d

FW_ULTRALIGHT		equ	FW_EXTRALIGHT
FW_REGULAR		equ	FW_NORMAL
FW_DEMIBOLD		equ	FW_SEMIBOLD
FW_ULTRABOLD		equ	FW_EXTRABOLD
FW_BLACK		equ	FW_HEAVY


; Enumeration font types.
RASTER_FONTTYPE 	equ	1
DEVICE_FONTTYPE 	equ	2

    if	0
*/

/* The size to allocate for the lfFaceName field in the logical font. */
#ifndef     LF_FACESIZE
#define     LF_FACESIZE     32
#endif

/* Various constants for defining a logical font. */
#define     OUT_DEFAULT_PRECIS	    0
#define     OUT_STRING_PRECIS	    1
#define     OUT_CHARACTER_PRECIS    2
#define     OUT_STROKE_PRECIS	    3
#define     OUT_TT_PRECIS	    4
#define     OUT_DEVICE_PRECIS	    5
#define     OUT_RASTER_PRECIS	    6
#define     OUT_TT_ONLY_PRECIS	    7

#define     CLIP_DEFAULT_PRECIS     0
#define     CLIP_CHARACTER_PRECIS   1
#define     CLIP_STROKE_PRECIS	    2
#define     CLIP_MASK		    0x0F
#define     CLIP_LH_ANGLES	    0x10
#define     CLIP_TT_ALWAYS	    0x20
#define     CLIP_EMBEDDED	    0x80

#define     DEFAULT_QUALITY	    0
#define     DRAFT_QUALITY	    1
#define     PROOF_QUALITY	    2

#define     DEFAULT_PITCH	    0
#define     FIXED_PITCH 	    1
#define     VARIABLE_PITCH	    2

#define     ANSI_CHARSET	    0
#define     DEFAULT_CHARSET	    1
#define     SYMBOL_CHARSET	    2
#define     SHIFTJIS_CHARSET	    128
#define     HANGEUL_CHARSET	    129
#define     CHINESEBIG5_CHARSET     136
#define     OEM_CHARSET 	    255


/*	GDI font families.						*/
#define FF_DONTCARE	(0<<4)	/* Don't care or don't know.		*/
#define FF_ROMAN	(1<<4)	/* Variable stroke width, serifed.	*/
				/* Times Roman, Century Schoolbook, etc.*/
#define FF_SWISS	(2<<4)	/* Variable stroke width, sans-serifed. */
				/* Helvetica, Swiss, etc.		*/
#define FF_MODERN	(3<<4)	/* Constant stroke width, serifed or sans-serifed. */
				/* Pica, Elite, Courier, etc.		*/
#define FF_SCRIPT	(4<<4)	/* Cursive, etc.			*/
#define FF_DECORATIVE	(5<<4)	/* Old English, etc.			*/


/*	Font weights lightest to darkest.				*/
#define FW_DONTCARE		0
#define FW_THIN 		100
#define FW_EXTRALIGHT		200
#define FW_LIGHT		300
#define FW_NORMAL		400
#define FW_MEDIUM		500
#define FW_SEMIBOLD		600
#define FW_BOLD 		700
#define FW_EXTRABOLD		800
#define FW_HEAVY		900

#define FW_ULTRALIGHT		FW_EXTRALIGHT
#define FW_REGULAR		FW_NORMAL
#define FW_DEMIBOLD		FW_SEMIBOLD
#define FW_ULTRABOLD		FW_EXTRABOLD
#define FW_BLACK		FW_HEAVY

/* Enumeration font types. */
#define     RASTER_FONTTYPE	    1
#define     DEVICE_FONTTYPE	    2

/*
    endif


LogFont 	struc							    ;*/ typedef     struct  {	       /*

  lfHeight	      dw      0 					    ;*/ short int lfHeight;	       /*
  lfWidth	      dw      0 					    ;*/ short int lfWidth;	       /*
  lfEscapement	      dw      0 					    ;*/ short int lfEscapement;        /*
  lfOrientation       dw      0 					    ;*/ short int lfOrientation;       /*
  lfWeight	      dw      0 					    ;*/ short int lfWeight;	       /*
  lfItalic	      db      0 					    ;*/ BYTE lfItalic;		       /*
  lfUnderline	      db      0 					    ;*/ BYTE lfUnderline;	       /*
  lfStrikeOut	      db      0 					    ;*/ BYTE lfStrikeOut;	       /*
  lfCharSet	      db      0 					    ;*/ BYTE lfCharSet; 	       /*
  lfOutPrecision      db      0 					    ;*/ BYTE lfOutPrecision;	       /*
  lfClipPrecision     db      0 					    ;*/ BYTE lfClipPrecision;	       /*
  lfQuality	      db      0 					    ;*/ BYTE lfQuality; 	       /*
  lfPitchAndFamily    db      0 					    ;*/ BYTE lfPitchAndFamily;	       /*
  lfFaceName	      db      0 ; A variable length field for the face name.;*/ BYTE lfFaceName[LF_FACESIZE];  /*

LogFont 	ends							    ;*/ } LOGFONT;		       /*


		endif
		endif
page
;		Device Definitions - incDevice


		ifdef	incDevice
		if	incDevice


InquireInfo	=	00000001b	;Inquire Device GDI Info
EnableDevice	=	00000000b	;Enable Device
InfoContext	=	    8000h	;Inquire/Enable for information context



;		Device Technologies

DT_PLOTTER	equ	0		; Vector plotter
DT_RASDISPLAY	equ	1		; Raster display
DT_RASPRINTER	equ	2		; Raster printer
DT_RASCAMERA	equ	3		; Raster camera
DT_CHARSTREAM	equ	4		; Character-stream, PLP
DT_METAFILE	equ	5		; Metafile, VDM
DT_DISPFILE	equ	6		; Display-file


;		Curve Capabilities

CC_NONE 	equ	00000000B	; Curves not supported
CC_CIRCLES	equ	00000001B	; Can do circles
CC_PIE		equ	00000010B	; Can do pie wedges
CC_CHORD	equ	00000100B	; Can do chord arcs
CC_ELLIPSES	equ	00001000B	; Can do ellipese
CC_WIDE 	equ	00010000B	; Can do wide lines
CC_STYLED	equ	00100000B	; Can do styled lines
CC_WIDESTYLED	equ	01000000B	; Can do wide styled lines
CC_INTERIORS	equ	10000000B	; Can do interiors
CC_ROUNDRECT	equ    0100000000B	; Can do round rectangles


;		Line Capabilities

LC_NONE 	equ	00000000B	; Lines not supported
;		equ	00000001B	;
LC_POLYLINE	equ	00000010B	; Can do polylines
LC_MARKER	equ	00000100B	; Can do markers
LC_POLYMARKER	equ	00001000B	; Can do polymarkers
LC_WIDE 	equ	00010000B	; Can do wide lines
LC_STYLED	equ	00100000B	; Can do styled lines
LC_WIDESTYLED	equ	01000000B	; Can do wide styled lines
LC_INTERIORS	equ	10000000B	; Can do interiors


;		Polygonal Capabilities

PC_NONE 	equ	00000000B	; Polygonals not supported
PC_POLYGON	equ	00000001B	; Can do polygons
PC_RECTANGLE	equ	00000010B	; Can do rectangles
PC_WINDPOLYGON	equ	00000100B	; Can do winding polygons
PC_TRAPEZOID	equ	00000100B	; Can do trapezoids
PC_SCANLINE	equ	00001000B	; Can do scanlines
PC_WIDE 	equ	00010000B	; Can do wide borders
PC_STYLED	equ	00100000B	; Can do styled borders
PC_WIDESTYLED	equ	01000000B	; Can do wide styled borders
PC_INTERIORS	equ	10000000B	; Can do interiors

;		Clipping Capabilities

CP_NONE 	equ	00000000B	; No clipping at device level
CP_RECTANGLE	equ	00000001B	; Device Output clips to rectangles

;		Text Capabilities

TC_NONE 	equ 0000000000000000B	; Text not supported
TC_OP_CHARACTER equ 0000000000000001B	; Can do OutputPrecision   CHARACTER
TC_OP_STROKE	equ 0000000000000010B	; Can do OutputPrecision   STROKE
TC_CP_STROKE	equ 0000000000000100B	; Can do ClipPrecision	   STROKE
TC_CR_90	equ 0000000000001000B	; Can do CharRotAbility    90
TC_CR_ANY	equ 0000000000010000B	; Can do CharRotAbility    ANY
TC_SF_X_YINDEP	equ 0000000000100000B	; Can do ScaleFreedom	   X_YINDEPENDENT
TC_SA_DOUBLE	equ 0000000001000000B	; Can do ScaleAbility	   DOUBLE
TC_SA_INTEGER	equ 0000000010000000B	; Can do ScaleAbility	   INTEGER
TC_SA_CONTIN	equ 0000000100000000B	; Can do ScaleAbility	   CONTINUOUS
TC_EA_DOUBLE	equ 0000001000000000B	; Can do EmboldenAbility   DOUBLE
TC_IA_ABLE	equ 0000010000000000B	; Can do ItalisizeAbility  ABLE
TC_UA_ABLE	equ 0000100000000000B	; Can do UnderlineAbility  ABLE
TC_SO_ABLE	equ 0001000000000000B	; Can do StrikeOutAbility  ABLE
TC_RA_ABLE	equ 0010000000000000B	; Can do RasterFontAble    ABLE
TC_VA_ABLE	equ 0100000000000000B	; Can do VectorFontAble    ABLE
TC_RESERVED	equ 1000000000000000B	; Reserved. Must be returned zero.


;		Raster Capabilities

RC_NONE 	equ 0000000000000000b	; No Raster Capabilities
RC_BITBLT	equ 0000000000000001b	; Can do bitblt
RC_BANDING	equ 0000000000000010b	; Requires banding support
RC_SCALING	equ 0000000000000100b	; Requires scaling support
RC_BITMAP64	equ 0000000000001000b	; supports >64k bitmaps
RC_GDI20_OUTPUT	equ 0000000000010000b	; supports Window 2.0 output functions
RC_GDI20_STATE	equ 0000000000100000b	; DC has state block
RC_SAVEBITMAP	equ 0000000001000000b	; can save bitmaps locally
RC_DI_BITMAP	equ 0000000010000000b	; can do device independent bitmaps
RC_PALETTE	equ 0000000100000000b	; can do color palette management
RC_DIBTODEV	equ 0000001000000000b	; can do SetDIBitsToDevice
RC_BIGFONT	equ 0000010000000000b	; does BIGFONTs
RC_STRETCHBLT	equ 0000100000000000b	; can do StretchBlt
RC_FLOODFILL	equ 0001000000000000b	; can do FloodFill
RC_STRETCHDIB	equ 0010000000000000b	; can do StretchDIBits
RC_OP_DX_OUTPUT equ 0100000000000000b   ; can do opaque ext text out

;	DC Management Flags

DC_SPDevice   equ 00000001b	;Seperate PDevice required per device/filename
DC_1PDevice   equ 00000010b	;Only 1 PDevice allowed per device/filename
DC_IgnoreDFNP equ 00000100b	;Ignore device/filename pairs when matching


;	dpCaps1 capability bits

C1_TRANSPARENT	equ 0000000000000001b	; supports transparency
TC_TT_ABLE	equ 0000000000000010b	; can do TT fonts through DDI or brute
C1_TT_CR_ANY	equ 0000000000000100b	; can do rotated TT fonts

    if	0
*/

#define     InquireInfo     0x01	/* Inquire Device GDI Info	   */
#define     EnableDevice    0x00	/* Enable Device		   */
#define     InfoContext     0x8000	/* Inquire/Enable for info context */


/*		Device Technologies				   */

#define     DT_PLOTTER		0	/* Vector plotter	   */
#define     DT_RASDISPLAY	1	/* Raster display	   */
#define     DT_RASPRINTER	2	/* Raster printer	   */
#define     DT_RASCAMERA	3	/* Raster camera	   */
#define     DT_CHARSTREAM	4	/* Character-stream, PLP   */
#define     DT_METAFILE 	5	/* Metafile, VDM	   */
#define     DT_DISPFILE 	6	/* Display-file 	   */

/*		Curve Capabilities				   */

#define     CC_NONE	    00000000	/* Curves not supported    */
#define     CC_CIRCLES	    00000001	/* Can do circles	   */
#define     CC_PIE	    00000002	/* Can do pie wedges	   */
#define     CC_CHORD	    00000004	/* Can do chord arcs	   */
#define     CC_ELLIPSES     00000010	/* Can do ellipese	   */
#define     CC_WIDE	    00000020	/* Can do wide lines	   */
#define     CC_STYLED	    00000040	/* Can do styled lines	   */
#define     CC_WIDESTYLED   00000100	/* Can do wide styled lines*/
#define     CC_INTERIORS    00000200	/* Can do interiors	   */
#define     CC_ROUNDRECT    0x0100	/* Can do round rectangles */

/*		 Line Capabilities				   */

#define     LC_NONE	    00000000	/* Lines not supported	   */
#define     LC_POLYLINE     00000002	/* Can do polylines	   */
#define     LC_MARKER	    00000004	/* Can do markers	   */
#define     LC_POLYMARKER   00000010	/* Can do polymarkers	   */
#define     LC_WIDE	    00000020	/* Can do wide lines	   */
#define     LC_STYLED	    00000040	/* Can do styled lines	   */
#define     LC_WIDESTYLED   00000100	/* Can do wide styled lines*/
#define     LC_INTERIORS    00000200	/* Can do interiors	   */

/*		 Polygonal Capabilities 			   */

#define     PC_NONE	    00000000	/* Polygonals not supported*/
#define     PC_POLYGON	    00000001	/* Can do polygons	   */
#define     PC_RECTANGLE    00000002	/* Can do rectangles	   */
#define     PC_WINDPOLYGON  00000004	/* Can do winding polygons */
#define     PC_TRAPEZOID    00000004	/* Can do trapezoids	   */
#define     PC_SCANLINE     00000010	/* Can do scanlines	   */
#define     PC_WIDE	    00000020	/* Can do wide borders	   */
#define     PC_STYLED	    00000040	/* Can do styled borders   */
#define     PC_WIDESTYLED   00000100	/* Can do wide styled borders*/
#define     PC_INTERIORS    00000200	/* Can do interiors	   */

/*		 Polygonal Capabilities 			   */

#define     CP_NONE	    00000000	/* no clipping of Output   */
#define     CP_RECTANGLE    00000001	/* Output clipped to Rects */

/*		 Text Capabilities					    */

#define TC_OP_CHARACTER 0000001     /* Can do OutputPrecision	CHARACTER      */
#define TC_OP_STROKE	0000002     /* Can do OutputPrecision	STROKE	       */
#define TC_CP_STROKE	0000004     /* Can do ClipPrecision	STROKE	       */
#define TC_CR_90	0000010     /* Can do CharRotAbility	90	       */
#define TC_CR_ANY	0000020     /* Can do CharRotAbility	ANY	       */
#define TC_SF_X_YINDEP	0000040     /* Can do ScaleFreedom	X_YINDEPENDENT */
#define TC_SA_DOUBLE	0000100     /* Can do ScaleAbility	DOUBLE	       */
#define TC_SA_INTEGER	0000200     /* Can do ScaleAbility	INTEGER        */
#define TC_SA_CONTIN	0000400     /* Can do ScaleAbility	CONTINUOUS     */
#define TC_EA_DOUBLE	0001000     /* Can do EmboldenAbility	DOUBLE	       */
#define TC_IA_ABLE	0002000     /* Can do ItalisizeAbility	ABLE	       */
#define TC_UA_ABLE	0004000     /* Can do UnderlineAbility	ABLE	       */
#define TC_SO_ABLE	0010000     /* Can do StrikeOutAbility	ABLE	       */
#define TC_RA_ABLE	0020000     /* Can do RasterFontAble	ABLE	       */
#define TC_VA_ABLE	0040000     /* Can do VectorFontAble	ABLE	       */
#define TC_RESERVED	0100000     /* Reserved. Must be returned zero.        */

/*		 Raster Capabilities				   */

#define RC_NONE 	00000000    /* No Raster Capabilities	   */
#define RC_BITBLT	00000001    /* Can do bitblt		   */
#define RC_BANDING	00000002    /* Requires banding support    */
#define RC_SCALING	00000004    /* Requires scaling support    */
#define RC_BITMAP64	00000010    /* supports >64k bitmaps	   */
#define RC_GDI20_OUTPUT 00000020    /* support Windows 2.0 functions */
#define RC_GDI20_STATE	00000040    /* dc has a state block	   */
#define	RC_SAVEBITMAP	00000100    /* can save bitmaps locally	   */

#define RC_DI_BITMAP	00000200    /* can do device independent bitmaps*/
#define RC_PALETTE	00000400    /* can do color palette management	*/
#define RC_DIBTODEV	00001000    /* can do SetDIBitsToDevice 	*/
#define RC_BIGFONT	00002000    /* does BIGFONTs			*/
#define RC_STRETCHBLT	00004000    /* can do StretchBlt		*/
#define RC_FLOODFILL	00010000    /* can do FloodFill 		*/
#define RC_STRETCHDIB	00020000    /* can do StretchDIBits		*/

/*	DC Management Flags					   */

#define DC_SPDevice	0000001     /* Seperate PDevice required per device/filename */
#define DC_1PDevice	0000002     /* Only 1 PDevice allowed per device/filename    */
#define DC_IgnoreDFNP	0000004     /* Ignore device/filename pairs when matching    */

/*	dpCaps1 capability bits 					    */

#define C1_TRANSPARENT	0x0001	    /* supports transparency		    */
#define TC_TT_ABLE	0x0002	    /* can do TT fonts through DDI or brute */
#define C1_TT_CR_ANY	0x0004	    /* can do rotated TT fonts	    */

/*
	endif

GDIINFO 	struc							    ;*/ typedef struct {	   /*

  dpVersion	dw	0	; Version = 0100h for now		    ;*/ short int dpVersion;	   /*
  dpTechnology	dw	0	; Device classification 		    ;*/ short int dpTechnology;    /*
  dpHorzSize	dw	0	; Horizontal size in millimeters	    ;*/ short int dpHorzSize;	   /*
  dpVertSize	dw	0	; Vertical   size in millimeters	    ;*/ short int dpVertSize;	   /*
  dpHorzRes	dw	0	; Horizontal width in pixels		    ;*/ short int dpHorzRes;	   /*
  dpVertRes	dw	0	; Vertical   width in pixels		    ;*/ short int dpVertRes;	   /*
  dpBitsPixel	dw	0	; Number of bits per pixel		    ;*/ short int dpBitsPixel;	   /*
  dpPlanes	dw	0	; Number of planes			    ;*/ short int dpPlanes;	   /*
  dpNumBrushes	dw	0	; Number of brushes the device has	    ;*/ short int dpNumBrushes;    /*
  dpNumPens	dw	0	; Number of pens the device has 	    ;*/ short int dpNumPens;	   /*
		dw	0	; Number of markers the device has	    ;*/ short int futureuse;	   /*
  dpNumFonts	dw	0	; Number of fonts the device has	    ;*/ short int dpNumFonts;	   /*
  dpNumColors	dw	0	; Number of colors in color table	    ;*/ short int dpNumColors;	   /*
  dpDEVICEsize	dw	0	; Size required for the device descriptor   ;*/ short int dpDEVICEsize;    /*
  dpCurves	dw	0	; Curves    capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpCurves;	   /*
  dpLines	dw	0	; Line	    capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpLines;	   /*
  dpPolygonals	dw	0	; Polygonal capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpPolygonals; /*
  dpText	dw	0	; Text	    capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpText;	   /*
  dpClip	dw	0	; Clipping  capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpClip;	   /*
  dpRaster	dw	0	; Bitblt    capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpRaster;	   /*
  dpAspectX	dw	0	; Length of X leg			    ;*/ short int dpAspectX;	   /*
  dpAspectY	dw	0	; Length of Y leg			    ;*/ short int dpAspectY;	   /*
  dpAspectXY	dw	0	; Length of hypotenuse			    ;*/ short int dpAspectXY;	   /*
  dpStyleLen	dw	0	; Length of segment for line styles	    ;*/ short int dpStyleLen;	   /*
  dpMLoWin	dw	0	; Metric  Lo res WinX,WinY  (PTTYPE)	    ;*/ PTTYPE	  dpMLoWin;	   /*
		dw	0
  dpMLoVpt	dw	0	; Metric  Lo res VptX,VptY  (PTTYPE)	    ;*/ PTTYPE	  dpMLoVpt;	   /*
		dw	0
  dpMHiWin	dw	0	; Metric  Hi res WinX,WinY  (PTTYPE)	    ;*/ PTTYPE	  dpMHiWin;	   /*
		dw	0
  dpMHiVpt	dw	0	; Metric  Hi res VptX,VptY  (PTTYPE)	    ;*/ PTTYPE	  dpMHiVpt;	   /*
		dw	0
  dpELoWin	dw	0	; English Lo res WinX,WinY  (PTTYPE)	    ;*/ PTTYPE	  dpELoWin;	   /*
		dw	0
  dpELoVpt	dw	0	; English Lo res VptX,VptY  (PTTYPE)	    ;*/ PTTYPE	  dpELoVpt;	   /*
		dw	0
  dpEHiWin	dw	0	; English Hi res WinX,WinY  (PTTYPE)	    ;*/ PTTYPE	  dpEHiWin;	   /*
		dw	0
  dpEHiVpt	dw	0	; English Hi res VptX,VptY  (PTTYPE)	    ;*/ PTTYPE	  dpEHiVpt;	   /*
		dw	0
  dpTwpWin	dw	0	; Twips 	 WinX,WinY  (PTTYPE)	    ;*/ PTTYPE	  dpTwpWin;	   /*
		dw	0
  dpTwpVpt	dw	0	; Twips 	 VptX,VptY  (PTTYPE)	    ;*/ PTTYPE	  dpTwpVpt;	   /*
		dw	0
  dpLogPixelsX	dw	0	;Logical pixels/inch in X		    ;*/ short int dpLogPixelsX;    /*
  dpLogPixelsY	dw	0	;Logical pixels/inch in Y		    ;*/ short int dpLogPixelsY;    /*
  dpDCManage	dw	0	;DC Management flags			    ;*/ short int dpDCManage;	   /*
  dpCaps1	dw	0	; more capability bits			    ;*/ unsigned short int dpCaps1;	/*
  dpSpotSizeX	dw	0						    ;*/ short int futureuse4;		/*
		dw	0						    ;*/ short int futureuse5;		/*
  dpSpotSizeY	dw	0						    ;*/ short int futureuse6;		/*
		dw	0						    ;*/ short int futureuse7;		/*

; start of entries in version 3.0 of this structure

  dpNumPalReg	dw	0	; Number of entries in device's palette	    ;*/ WORD dpNumPalReg;	   /*
  dpPalReserved	dw	0	; Number of reserved entries palette	    ;*/ WORD dpPalReserved;	   /*
  dpColorRes	dw	0	; bits of color resolution (total)	    ;*/ WORD dpColorRes;	   /*
GDIINFO 	ends							    ;*/ } GDIINFO;		   /*

		endif
		endif


page
;	Font Definitions
		ifdef	incFont
		if	incFont


PF_BITS_IS_ADDRESS  equ     4
PF_DEVICE_REALIZED  equ     10000000B
PF_RASTER_TYPE	    equ     0
PF_VECTOR_TYPE	    equ     1
PF_OTHER1_TYPE	    equ     2
PF_OTHER2_TYPE	    equ     3


    if	0
*/

/* This bit in the dfType field signals that the dfBitsOffset field is an
   absolute memory address and should not be altered. */
#define PF_BITS_IS_ADDRESS  4

/* This bit in the dfType field signals that the font is device realized. */
#define PF_DEVICE_REALIZED  0x80

/* These bits in the dfType give the fonttype -
       raster, vector, other1, other2. */
#define PF_RASTER_TYPE	    0
#define PF_VECTOR_TYPE	    1
#define PF_OTHER1_TYPE	    2
#define PF_OTHER2_TYPE	    3

/* The size to allocate for the dfMaps field in the physical font. */
#ifndef     DF_MAPSIZE
#define     DF_MAPSIZE	    1
#endif

/*
    endif


;	Font data structure passed to OEM routines.  Refer to chapters 12 and
;	13 of the OEM adaptation guide for a complete description.


FONTINFO	struc							    ;*/ typedef     struct  {	       /*

  dfType	    dw	    0	; Type field for the font.		    ;*/ short int   dfType;	       /*
  dfPoints	    dw	    0	; Point size of font.			    ;*/ short int   dfPoints;	       /*
  dfVertRes	    dw	    0	; Vertical digitization.		    ;*/ short int   dfVertRes;	       /*
  dfHorizRes	    dw	    0	; Horizontal digitization.		    ;*/ short int   dfHorizRes;        /*
  dfAscent	    dw	    0	; Baseline offset from char cell top.	    ;*/ short int   dfAscent;	       /*
  dfInternalLeading dw	    0	; Internal leading included in font	    ;*/ short int   dfInternalLeading; /*
  dfExternalLeading dw	    0	; Prefered extra space between lines	    ;*/ short int   dfExternalLeading; /*
  dfItalic	    db	    0	; Flag specifying if italic.		    ;*/ BYTE	    dfItalic;	       /*
  dfUnderline	    db	    0	; Flag specifying if underlined.	    ;*/ BYTE	    dfUnderline;       /*
  dfStrikeOut	    db	    0	; Flag specifying if struck out.	    ;*/ BYTE	    dfStrikeOut;       /*
  dfWeight	    dw	    0	; Weight of font.			    ;*/ short int   dfWeight;	       /*
  dfCharSet	    db	    0	; Character set of font.		    ;*/ BYTE	    dfCharSet;	       /*
  dfPixWidth	    dw	    0	; Width field for the font.		    ;*/ short int   dfPixWidth;        /*
  dfPixHeight	    dw	    0	; Height field for the font.		    ;*/ short int   dfPixHeight;       /*
  dfPitchAndFamily  db	    0	; Flag specifying variable pitch, family.   ;*/ BYTE	    dfPitchAndFamily;  /*
  dfAvgWidth	    dw	    0	; Average character width.		    ;*/ short int   dfAvgWidth;        /*
  dfMaxWidth	    dw	    0	; Maximum character width.		    ;*/ short int   dfMaxWidth;        /*
  dfFirstChar	    db	    0	; First character in the font.		    ;*/ BYTE	    dfFirstChar;       /*
  dfLastChar	    db	    0	; Last character in the font.		    ;*/ BYTE	    dfLastChar;        /*
  dfDefaultChar     db	    0	; Default character for out of range.	    ;*/ BYTE	    dfDefaultChar;     /*
  dfBreakChar	    db	    0	; Character to define wordbreaks.	    ;*/ BYTE	    dfBreakChar;       /*
  dfWidthBytes	    dw	    0	; Number of bytes in each row.		    ;*/ short int   dfWidthBytes;      /*
  dfDevice	    dd	    0	; Offset to device name.		    ;*/ unsigned long int   dfDevice;  /*
  dfFace	    dd	    0	; Offset to face name.			    ;*/ unsigned long int   dfFace;    /*
  dfBitsPointer     dd	    0	; Bits pointer. 			    ;*/ unsigned long int   dfBitsPointer;/*
  dfBitsOffset	    dd	    0	; Offset to the begining of the bitmap.     ;*/ unsigned long int   dfBitsOffset;/*
				; On the disk, this is relative to the
				; begining of the file. In memory this is
				; relative to the begining of this structure.
  dfReservedByte    db	    0	; filler byte to WORD-align charoffset      ;*/ BYTE dfReservedByte;		/*
  dfCharOffset	    dw	    0	; Area for storing the character offsets,   ;*/ unsigned short dfMaps[DF_MAPSIZE];/*
				; facename, device name (opt), and bitmap.

FONTINFO	ends							    ;*/ } FONTINFO;		       /*

SCALABLEFONTINFO    struc						    ;*/ typedef     struct  {	       /*
  erType	    dw	    0	; Type field for the font.		    ;*/ short int   erType;	       /*
  erPoints	    dw	    0	; Point size of font.			    ;*/ short int   erPoints;	       /*
  erVertRes	    dw	    0	; Vertical digitization.		    ;*/ short int   erVertRes;	       /*
  erHorizRes	    dw	    0	; Horizontal digitization.		    ;*/ short int   erHorizRes;        /*
  erAscent	    dw	    0	; Baseline offset from char cell top.	    ;*/ short int   erAscent;	       /*
  erInternalLeading dw	    0	; Internal leading included in font	    ;*/ short int   erInternalLeading; /*
  erExternalLeading dw	    0	; Prefered extra space between lines	    ;*/ short int   erExternalLeading; /*
  erItalic	    db	    0	; Flag specifying if italic.		    ;*/ BYTE	    erItalic;	       /*
  erUnderline	    db	    0	; Flag specifying if underlined.	    ;*/ BYTE	    erUnderline;       /*
  erStrikeOut	    db	    0	; Flag specifying if struck out.	    ;*/ BYTE	    erStrikeOut;       /*
  erWeight	    dw	    0	; Weight of font.			    ;*/ short int   erWeight;	       /*
  erCharSet	    db	    0	; Character set of font.		    ;*/ BYTE	    erCharSet;	       /*
  erPixWidth	    dw	    0	; Width field for the font.		    ;*/ short int   erPixWidth;        /*
  erPixHeight	    dw	    0	; Height field for the font.		    ;*/ short int   erPixHeight;       /*
  erPitchAndFamily  db	    0	; Flag specifying pitch and family.	    ;*/ BYTE	    erPitchAndFamily;  /*
  erAvgWidth	    dw	    0	; Average character width.		    ;*/ short int   erAvgWidth;        /*
  erMaxWidth	    dw	    0	; Maximum character width.		    ;*/ short int   erMaxWidth;        /*
  erFirstChar	    db	    0	; First character in the font.		    ;*/ BYTE	    erFirstChar;       /*
  erLastChar	    db	    0	; Last character in the font.		    ;*/ BYTE	    erLastChar;        /*
  erDefaultChar     db	    0	; Default character for out of range.	    ;*/ BYTE	    erDefaultChar;     /*
  erBreakChar	    db	    0	; Character to define wordbreaks.	    ;*/ BYTE	    erBreakChar;       /*
  erWidthBytes	    dw	    0	; Number of bytes in each row.		    ;*/ short int   erWidthBytes;      /*
  erDevice	    dd	    0	; Offset to device name.		    ;*/ unsigned long int   erDevice;  /*
  erFace	    dd	    0	; Offset to face name.			    ;*/ unsigned long int   erFace;    /*
  erBitsPointer     dd	    0	; Bits pointer. 			    ;*/ unsigned long int   erBitsPointer;/*
  erBitsOffset	    dd	    0	; Offset to the begining of the bitmap.     ;*/ unsigned long int   erBitsOffset;/*
  erFlags	    db	    0	; flags, and word align the stuff to come   ;*/ BYTE erReservedByte;		/*
  erUnderlinePos    dw	    0	; underline position relative to cell origin	;*/ short int	erUnderlinePos;  /*
  erUnderlineThick  dw	    0	; underline thickness				;*/ short int	erUnderlineThick;/*
  erStrikeoutPos    dw	    0	; Strikeout position relative to cell origin	;*/ short int	erStrikeoutPos;  /*
  erStrikeoutThick  dw	    0	; strikeout thickness				;*/ short int	erStrikeoutThick;/*
SCALABLEFONTINFO    ends						    ;*/ } SCALABLEFONTINFO;	       /*




TEXTXFORM	struc							    ;*/ typedef     struct  {	       /*

  ftHeight	      dw  0						    ;*/ short int ftHeight;	       /*
  ftWidth	      dw  0						    ;*/ short int ftWidth;	       /*
  ftEscapement	      dw  0						    ;*/ short int ftEscapement;        /*
  ftOrientation       dw  0						    ;*/ short int ftOrientation;       /*
  ftWeight	      dw  0						    ;*/ short int ftWeight;	       /*
  ftItalic	      db  0						    ;*/ BYTE ftItalic;		       /*
  ftUnderline	      db  0						    ;*/ BYTE ftUnderline;	       /*
  ftStrikeOut	      db  0						    ;*/ BYTE ftStrikeOut;	       /*
  ftOutPrecision      db  0						    ;*/ BYTE ftOutPrecision;	       /*
  ftClipPrecision     db  0						    ;*/ BYTE ftClipPrecision;	       /*
  ftAccelerator       dw  0						    ;*/ unsigned short int	       /*
									    ;*/ 		ftAccelerator; /*
  ftOverhang	      dw  0						    ;*/ short int ftOverhang;	       /*

TEXTXFORM	ends							    ;*/ } TEXTXFORM;		       /*



TEXTMETRIC	struc							    ;*/ typedef struct {	       /*

  tmHeight		dw  0	  ; Ascent+Descent			    ;*/ short int tmHeight;	       /*
  tmAscent		dw  0	  ; Pixels above the baseline		    ;*/ short int tmAscent;	       /*
  tmDescent		dw  0	  ; Pixels below the baseline		    ;*/ short int tmDescent;	       /*
  tmInternalLeading	dw  0	  ; Internal leading included in font	    ;*/ short int tmInternalLeading;   /*
  tmExternalLeading	dw  0	  ; Prefered extra space between lines	    ;*/ short int tmExternalLeading;   /*
  tmAveCharWidth	dw  0	  ; Of the letter 'X'			    ;*/ short int tmAveCharWidth;      /*
  tmMaxCharWidth	dw  0						    ;*/ short int tmMaxCharWidth;      /*
  tmWeight		dw  0						    ;*/ short int tmWeight;	       /*
  tmItalic		db  0						    ;*/ BYTE	  tmItalic;	       /*
  tmUnderlined		db  0						    ;*/ BYTE	  tmUnderlined;        /*
  tmStruckOut		db  0						    ;*/ BYTE	  tmStruckOut;	       /*
  tmFirstChar		db  0						    ;*/ BYTE	  tmFirstChar;	       /*
  tmLastChar		db  0						    ;*/ BYTE	  tmLastChar;	       /*
  tmDefaultChar 	db  0	  ; dfDefaultChar+dfFirstChar		    ;*/ BYTE	  tmDefaultChar;       /*
  tmBreakChar		db  0	  ; dfBreakChar+dfFirstChar		    ;*/ BYTE	  tmBreakChar;	       /*
  tmPitchAndFamily	db  0	  ; Low bit zero if fixed pitch, one if     ;*/ BYTE	  tmPitchAndFamily;    /*
				  ; variable. Family in high nibble.
  tmCharSet		db  0						    ;*/ BYTE	  tmCharSet;	       /*
  tmOverhang		dw  0						    ;*/ short int tmOverhang;	       /*
  tmDigitizedAspectX	dw  0	  ; Digitization aspect ratio		    ;*/ short int tmDigitizedAspectX;  /*
  tmDigitizedAspectY	dw  0	  ; in X and Y. 			    ;*/ short int tmDigitizedAspectY;  /*

TEXTMETRIC     ends							    ;*/ } TEXTMETRIC;		       /*



		endif
		endif
page
;	Drawing mode definitions - incDrawMode


		ifdef	incDrawMode
		if	incDrawMode


DRAWMODE	struc							    ;*/ typedef     struct {	     /*

  Rop2		dw	0	;The 16-bit encoded Logical op		    ;*/ short int	  Rop2;       /*
  bkMode	dw	0	;Background Mode (for text only)	    ;*/ short int	  bkMode;     /*
  bkColor	dd	0	;Physical background Color		    ;*/ unsigned long int bkColor;    /*
  TextColor	dd	0	;Physical text (forground) color	    ;*/ unsigned long int TextColor;  /*
  TBreakExtra	dw	0	; total pixles to stuff into a line	    ;*/ short int	  TBreakExtra;/*
  BreakExtra	dw	0	; div(TBreakExtra, BreakCount)		    ;*/ short int	  BreakExtra; /*
  BreakErr	dw	0	; running error term			    ;*/ short int	  BreakErr;   /*
  BreakRem	dw	0	; mod(TBreakExtra, BreakCount)		    ;*/ short int	  BreakRem;   /*
  BreakCount	dw	0	; count of breaks in the line		    ;*/ short int	  BreakCount; /*
  CharExtra	dw	0	; extra pixles to stuff after each char     ;*/ short int	  CharExtra;  /*
				;   (used to space out a font)
  LbkColor	dd	0	;Logical background color		    ;*/ unsigned long int LbkColor;   /*
  LTextColor	dd	0	;Logical Text (forground) color 	    ;*/ unsigned long int LTextColor; /*

DRAWMODE	ends							    ;*/ } DRAWMODE;		      /*



;	Background Mode definitions

TRANSPARENT	equ	1
OPAQUE		equ	2

    if	0
*/
/* Background Mode definitions used by GDI support routines written in C */

#define     TRANSPARENT 	1
#define     OPAQUE		2
/*
    endif



		endif
		endif
page
;	Output Definitions - incOutput

		ifdef	incOutput
		if	incOutput


;	Output Style definitions used by GDI


OS_ARC		equ	3
OS_SCANLINES	equ	4
OS_RECTANGLE	equ	6
OS_ELLIPSE	equ	7
OS_MARKER	equ	8
OS_POLYLINE	equ	18
OS_TRAPEZOID	equ	20
OS_POLYGON	equ	22
OS_PIE		equ	23
OS_POLYMARKER	equ	24
OS_CHORD	equ	39
OS_CIRCLE	equ	55

OS_BEGINNSCAN	equ	80
OS_ENDNSCAN	equ	81
    if	0
*/

/* Output Style definitions used by GDI support routines written in C */

#define     OS_ARC		3
#define     OS_SCANLINES	4
#define     OS_RECTANGLE	6
#define     OS_ELLIPSE		7
#define     OS_MARKER		8
#define     OS_POLYLINE 	18
#define     OS_TRAPEZOID	20
#define     OS_POLYGON		22
#define     OS_PIE		23
#define     OS_POLYMARKER	24
#define     OS_CHORD		39
#define     OS_CIRCLE		55

#define	    OS_BEGINNSCAN	80
#define	    OS_ENDNSCAN		81
/*
    endif


		endif
		endif


		ifdef	incControl
		if	incControl

OEM_FAILED	equ	8000000

;	GDI escape constants

NEWFRAME          equ     1
ABORTDOC	  equ     2
NEXTBAND          equ     3
SETCOLORTABLE     equ     4
GETCOLORTABLE     equ     5
FLUSHOUTPUT       equ     6
DRAFTMODE         equ     7
QUERYESCSUPPORT   equ     8
SETPRINTERDC	  equ	  9
SETABORTPROC      equ     9
STARTDOC          equ     10
ENDDOC            equ     11
GETPHYSPAGESIZE   equ     12
GETPRINTINGOFFSET equ     13
GETSCALINGFACTOR  equ     14
MFCOMMENT         equ     15
GETPENWIDTH       equ     16
SETCOPYCOUNT      equ     17
SELECTPAPERSOURCE equ     18
DEVICEDATA	  equ     19
PASSTHROUGH       equ     19
GETTECHNOLGY	  equ     20
GETTECHNOLOGY	  equ     20
SETLINECAP	  equ	  21
SETLINEJOIN	   equ 	  22
SETMITERLIMIT	   equ 	  23
BANDINFO	   equ 	  24
DRAWPATTERNRECT    equ 	  25
GETVECTORPENSIZE   equ 	  26
GETVECTORBRUSHSIZE equ 	  27
ENABLEDUPLEX	   equ 	  28
GETSETPAPERBINS    equ 	  29
GETSETPRINTORIENT  equ 	  30
ENUMPAPERBINS	   equ 	  31
SETDIBSCALING	   equ 	  32
EPSPRINTING        equ 	  33
ENUMPAPERMETRICS   equ 	  34
GETSETPAPERMETRICS equ 	  35
POSTSCRIPT_DATA	   equ 	  37
POSTSCRIPT_IGNORE  equ 	  38
MOUSETRAILS	   equ 	  39
RESETDEVICE	   equ	  128
GETEXTENDEDTEXTMETRICS equ 256
GETEXTENTTABLE         equ 257
GETPAIRKERNTABLE       equ 258
GETTRACKKERNTABLE      equ 259
EXTTEXTOUT             equ 512
GETFACENAME	       equ 513
ENABLERELATIVEWIDTHS   equ 768
ENABLEPAIRKERNING      equ 769
SETKERNTRACK           equ 770
SETALLJUSTVALUES       equ 771
SETCHARSET	       equ 772

STRETCHBLT             equ 2048
BEGIN_PATH	       equ 4096
CLIP_TO_PATH	       equ 4097
END_PATH	       equ 4098
EXT_DEVICE_CAPS	       equ 4099
RESTORE_CTM	       equ 4100
SAVE_CTM	       equ 4101
SET_ARC_DIRECTION      equ 4102
SET_BACKGROUND_COLOR   equ 4103
SET_POLY_MODE	       equ 4104
SET_SCREEN_ANGLE       equ 4105
SET_SPREAD	       equ 4106
TRANSFORM_CTM	       equ 4107
SET_CLIP_BOX	       equ 4108
SET_BOUNDS             equ 4109


    if 0
*/
#define OEM_FAILED	    0x80000000L

#define NEWFRAME		     1
#define ABORTDOC		     2
#define NEXTBAND		     3
#define SETCOLORTABLE		     4
#define GETCOLORTABLE		     5
#define FLUSHOUTPUT		     6
#define DRAFTMODE		     7
#define QUERYESCSUPPORT 	     8
#define SETPRINTERDC		     9		// DDK - between GDI and Driver
#define SETABORTPROC		     9		// SDK - between APP and GDI
#define STARTDOC		     10
#define ENDDOC			     11
#define GETPHYSPAGESIZE 	     12
#define GETPRINTINGOFFSET	     13
#define GETSCALINGFACTOR	     14
#define MFCOMMENT		     15
#define GETPENWIDTH		     16
#define SETCOPYCOUNT		     17
#define SELECTPAPERSOURCE	     18
#define DEVICEDATA		     19
#define PASSTHROUGH		     19
#define GETTECHNOLGY		     20
#define GETTECHNOLOGY		     20
#define SETLINECAP		     21
#define SETLINEJOIN		     22
#define SETMITERLIMIT		     23
#define BANDINFO		     24
#define DRAWPATTERNRECT 	     25
#define GETVECTORPENSIZE	     26
#define GETVECTORBRUSHSIZE	     27
#define ENABLEDUPLEX		     28
#define GETSETPAPERBINS 	     29
#define GETSETPRINTORIENT	     30
#define ENUMPAPERBINS		     31
#define SETDIBSCALING		     32
#define EPSPRINTING        	     33
#define ENUMPAPERMETRICS   	     34
#define GETSETPAPERMETRICS 	     35
#define POSTSCRIPT_DATA		     37
#define POSTSCRIPT_IGNORE	     38
#define RESETDEVICE		     128
#define GETEXTENDEDTEXTMETRICS	     256
#define GETEXTENTTABLE		     257
#define GETPAIRKERNTABLE	     258
#define GETTRACKKERNTABLE	     259
#define EXTTEXTOUT		     512
#define GETFACENAME		     513
#define ENABLERELATIVEWIDTHS	     768
#define ENABLEPAIRKERNING	     769
#define SETKERNTRACK		     770
#define SETALLJUSTVALUES	     771
#define SETCHARSET		     772

#define STRETCHBLT		     2048
#define BEGIN_PATH		     4096
#define CLIP_TO_PATH		     4097
#define END_PATH		     4098
#define EXT_DEVICE_CAPS		     4099
#define RESTORE_CTM		     4100
#define SAVE_CTM	             4101
#define SET_ARC_DIRECTION	     4102
#define SET_BACKGROUND_COLOR	     4103
#define SET_POLY_MODE		     4104
#define SET_SCREEN_ANGLE	     4105
#define SET_SPREAD		     4106
#define TRANSFORM_CTM		     4107
#define SET_CLIP_BOX		     4108
#define SET_BOUNDS                   4109

typedef FONTINFO    FAR *LPFONTINFO;
typedef DRAWMODE    FAR *LPDRAWMODE;
typedef TEXTXFORM   FAR *LPTEXTXFORM;
typedef TEXTMETRIC  FAR *LPTEXTMETRIC;
typedef LOGFONT     FAR *LPLOGFONT;
typedef LOGPEN	    FAR *LPLOGPEN;
typedef LOGBRUSH    FAR *LPLOGBRUSH;
typedef BITMAP	    FAR *LPBITMAP;
typedef FARPROC     FAR *LPFARPROC;
typedef GDIINFO     FAR *LPGDIINFO;
typedef SCALABLEFONTINFO FAR * LPSCALABLEFONTINFO;


/*
    endif



		endif
		endif
;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\lzdos.h ===
/* OBSOLETE: Replaced by #define LIB/#include <lzexpand.h> */
#ifndef LIB
#define LIB
#endif
#include <lzexpand.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\layer.inc ===
;=======================================================
;
; Macros stolen from cmacros.inc (so we don't have to include it all)
;
    .286p

externNP    macro   n
    irp x,<n>
	extrn x:near
    endm
endm

externFP    macro   n
    irp x,<n>
	extrn x:far
    endm
endm

externW     macro   w
    irp x,<w>
        extrn x:word
    endm
endm

assumes     macro s,ln
    assume  s:_&ln
endm

createSeg   macro n,ln,a,co,cl,grp
    n segment a co '&cl'
    n ends
endm

sBegin	    macro   seg
    assume  cs:_&seg
    _&seg   segment
endm

sEnd	    macro   seg
    _&seg ends
    assume  cs:nothing
endm

errnz macro x				;;display error if expression is <>0
  if2
    if x				;;if expression is non-zero,
      errnz1  <x>,%(x)
    endif
  endif
endm

errnz1 macro x1,x2
  = *errnz* x1 = x2
  .err
endm

errn$ macro l,x 			;;error if <$-label1 (exp2)> <>0
  errnz   <offset $ - offset l x>
endm

createSeg _DATA,DATA,WORD,PUBLIC,DATA

;=======================================================
;
; Error API definitions
;
ExternFP    <HandleParamError>

; error codes
include logerror.inc

;================================================================
;   Variable and temporary initialization

VLseg  equ <>	   ; Holds current segment name

VLopen = 0
VLerrnotinvoked  = 0
ifndef VLnogenpall
VLnogenpall = 0
endif

VLnogen        = 0
VLnogenparm    = 0

VLsavees       = 0
VLsavebx       = 0

;if1
if 1

;================================================================
;   Utility macros

;---------------------------------------------------------------------------
;
; lodsw cs:[si]
;
cslodsw macro
	db  2eh     ;; CS override
	lodsw
endm

;---------------------------------------------------------------------------
;
; lodsb cs:[si]
;
cslodsb macro
	db  2eh     ;; CS override
	lodsb
endm

SkipTwoBytes macro
	db	0A9h	;; Opcode for CMP AX,(immediate word)
endm

;---------------------------------------------------------------------------
;
; Define a as the concatenation of b & c
;
concat	macro	a,b,c,d,e,f
a	equ	<b&c&d&e&f>
endm

;---------------------------------------------------------------------------
;
; Assign a to b.
;
equate	macro	a,b
	a   = b
endm

;
; Print a message
;
_print	macro a,b,c
if2
	%out   a&b&c
endif
endm


;===============================================================

;---------------------------------------------------------------------------
;
; _gensub   LABEL
;
; Causes per-segment subroutine code associated with type LABEL
; to be generated, by setting the genLABEL&lseg flag.
;
_gensub2    macro   l,s
    gen&l&s = 1
endm

_gensub macro   l
        _gensub2    <l>,%VLseg
endm

;---------------------------------------------------------------------------
; _SwitchSeg
;
; Switches current segment to seg, creating the segment if needed.
;
_SwitchSeg   macro   seg,oldseg
    ifdifi  <&seg>,<oldseg>

      ifnb  <oldseg>
sEnd oldseg
      endif

    concat  <VLseg>,seg,

;createSeg _&seg,seg,BYTE,PUBLIC,CODE
createSeg _&seg,seg,WORD,PUBLIC,CODE

sBegin seg
assumes CS,seg

    endif
endm


;---------------------------------------------------------------------------
; API
;
API	macro	rettype,name,seg,optlist

    if	VLopen
	APIEND
    endif

VLname equ <name>
VLcbparms      = 0
VLcbskip       = 0
VLerrnotinvoked= 1
VLopen	       = 1
VLnogen        = 0
VLnogenparm    = 0
VLasm	       = 0
VLfunnyframe   = 0
VLnodata       = 0
VLcargs        = 0
VLplist        equ <>
VLATMframe     = 0	    ; special entry/exit code sequence for ATM's patching
VLATMfrmds     = 0	    ; ATM entry/exit code: mov ax,_DATA at beginning.

VLsavees	= 0
VLsavebx        = 0
	_SwitchSeg seg,%VLseg

    irp opt,<optlist>

      ifidni  <opt>,<NOGEN>
      VLnogen = 1
      endif

      ifidni  <opt>,<VOID>
      VLnogen = 1
      endif

      ifidni  <opt>,<ASM>
      VLasm = 1
      endif

ifndef WOW
      ; don't need that bp and ds stuff

      ifidni  <opt>,<ATMFRAME>
      VLATMframe = 1
      endif

      ifidni  <opt>,<ATMFRAMEDS>
      VLATMfrmds = 1
      VLATMframe = 1
      endif
endif

      ifidni  <opt>,<FUNNYFRAME>
      VLfunnyframe = 1
      endif

      ifidni  <opt>,<NODATA>
      VLnodata = 1
      endif

      ifidni  <opt>,<DEBUGONLY>
        ifndef DEBUG
        VLnogen = 1
        endif
      endif

      ifidni  <opt>,<C>
      VLcargs  = 1
      endif

      ifidni  <opt>,<SAVEES>
      VLsavees  = 2     ; sizeof(ES)
      endif

      ifidni  <opt>,<SAVEBX>
      VLsavebx  = 2     ; sizeof(BX)
      endif

    endm

concat	<VLsegoffset>,<seg>,<offset>
concat	<VLnameerror>,<name>,<_error>
concat	<VLnamecbparms>,<name>,<cbparms>

    if1
equate %VLnamecbparms, %VLcbparms
    else
equate %VLnamecbparms, %VLnamecbparms
    endif

    ife VLnogen

    ife VLcargs
concat	<VLiname>,<I>,<name>
ExternNP I&name

public	name
name:

    else
concat	<VLiname>,<_I>,<name>
ExternNP _I&name

public	_&name
_&name:

    endif

VLframe =   0			; no frame set up yet.

    endif  ; VLnogen

endm	;; VL

;---------------------------------------------------------------------------
; APIERR
;
; Optionally used after parameter decls to begin error handling code
;
APIERR	macro	opts

    ife VLnogen
      ife VLframe
	_print	<Nothing to validate for >,%VLiname
      else
	pop	dx		; pop off error handler address
	pop	bp		; restore BP
       if VLATMframe
	dec	bp		; fix BP back up
       endif
       if VLsavees
	pop	es
       endif
       if VLsavebx
        pop     bx
       endif
      endif
	jmp	VLiname 	; jmp to internal routine.

equate %VLnamecbparms, %VLcbparms

VLnameerror:
	VLerrnotinvoked  = 0

    endif ; VLnogen

endm	;; APIERR

;---------------------------------------------------------------------------
; APIEND
;
; Used after APIERR to terminate error handling code.
;
APIEND	macro

_PurgeParms %VLplist

    ife VLnogen

    if	VLerrnotinvoked
	APIERR
    endif
    if VLsavees
	pop	es
    endif
    if VLsavebx
        pop     bx
    endif
    ife VLcargs
	retf	VLcbparms
    else
	retf
    endif

VLopen = 0

    endif   ; VLnogen

endm	;; APIEND

;---------------------------------------------------------------------------
;
; _FlsFrame - Generate frame code
;
_FlsFrame   macro
    ife VLframe
     if VLATMfrmds
	mov	ax,_DATA
     endif
     if VLsavebx
        push    bx
     endif
     if VLsavees
	push	es
     endif
     if VLATMframe
	inc	bp
	push	bp
	mov	bp,sp
	push	ds		    ; push ds and pop it off.
	pop	ds		    ; (we need to pop DS rather than
				    ;  something fast like pop AX because
				    ; ATM doesn't preserve DS itself)
     else
	push	bp
	mov	bp,sp
     endif
	push	offset VLnameerror  ; push address of error handler
    VLframe = 1
    endif
endm

;---------------------------------------------------------------------------
; _ChkName
;
; Ensure name was specified

_ChkName    macro name
    ifb <name>
	_print <Missing parameter name in >,%VLiname
    endif
endm

;---------------------------------------------------------------------------
; _ParmOpts
;
; Parse parameter option flags
;
_ParmOpts  macro opts

    VLnogenparm = VLnogenpall

    irp opt,<opts>
	ifidni	<opt>,<DEBUGONLY>
	ifndef DEBUG
	    VLnogenparm = 1
	endif
	ifidni	<opt>,<NOGEN>
	    VLnogenparm = 1
	endif
	endif
    endm
endm

;---------------------------------------------------------------------------
; _DefParm name,cb,opts
;
; Take care of default parameter stuff, such as defining argument.
;
_DP_Add     macro   old,new
    ifb     <old>
VLplist equ <new>
    else
VLplist equ <old,new>
    endif
endm

_DefParm   macro   name,cb,opts
	_ChkName    <name>
	_ParmOpts   <opts>

  if VLcargs
concat  _P_&name,<[bp]+6+>,%(VLcbparms+VLsavees+VLsavebx)
	VLcbparms=VLcbparms+(cb)
  else
	VLcbparms=VLcbparms+(cb)
concat  _P_&name,<[bp]+6->,%VLcbparms,<+>,%(VLnamecbparms+VLsavees+VLsavebx)
  endif

_DP_Add     %VLplist,<_P_&name>

    VLgen = 1
    if VLnogenparm or VLnogen
        VLgen = 0
    endif
endm

;----------------------------------------------------------------------------
;
; _GenParm  name, cb, opts
;
_GenParm    macro   name,cb,opts
    _DefParm	<name>,<cb>,<opts>
    if VLgen
	_FlsFrame
    endif
endm

lcall2	macro	op,label,seg
	op	label&seg
endm

lcall	macro	label
	lcall2	<call>,<label>,%VLseg
endm

ljmp	macro	label
	lcall2	<jmp>,<label>,%VLseg
endm

;
; _PurgeParms - purge list of parameters we've defined
;
_PurgeParms   macro   list
    irp sym,<list>
sym equ <>
    endm
endm

;---------------------------------------------------------------------------
; LAYER_START
;
; Used before any VL invocations
;
LAYER_START macro
assumes ds,DATA

endm

;---------------------------------------------------------------------------
; LAYER_END
;
; Ends all VL definitions
;
LAYER_END   macro
    if VLsopen
	ENDSTRUCT
    endif
    if VLopen
	APIEND
    endif
    if VLerrnotinvoked
	APIERR
    endif
endm

;=========================================================================
;
; Structure related macros
;
; Structure globals

VLsopen =0

;
; STRUCT - begins a structure declaration
;
STRUCT	macro	name,opts
  if VLsopen
	ENDSTRUCT
  endif
  VLsopen=1

concat	VLcbs,<VLcbs>,name
VLcbstruct  =	0
endm

;
; ENDSTRUCT macro - terminates a STRUCT declaration
;
ENDSTRUCT   macro
equate	%VLcbs,%VLcbstruct

VLsopen =0
endm

;
; Define simple field macro, given:
;   f = macro name
;   cb = size of field
;
_SSize	macro	cb,opts
VLcbstruct  =	VLcbstruct + (cb)
endm

_DefSimpleF macro   f,cb
    f	&macro	name,opts
	equate	_F_&&name,%VLcbstruct
	_SSize	cb
    &endm
endm

_DefSimpleF F_char,1
_DefSimpleF F_BYTE,1

_DefSimpleF F_int,2
_DefSimpleF F_WORD,2
_DefSimpleF F_BOOL,2
_DefSimpleF F_FLAGS,2

_DefSimpleF F_LONG,4
_DefSimpleF F_DWORD,4

_DefSimpleF F_intMBZ,2
_DefSimpleF F_DWORDMBZ,4

_DefSimpleF F_LPVOID,4
_DefSimpleF F_CLPSTR,4
_DefSimpleF F_CLPSTR0,4
_DefSimpleF F_LPSTR,4

_DefSimpleF F_POINT,4
_DefSimpleF F_RECT,8

ifdef WOW
_DefSimpleF F_LARGEPOINT,8
endif

F_RGB	macro	name,cb,opts
    equate  _F_&name,%VLcbstruct
    _SSize  cb
endm

F_RGCH	equ	<F_RGB>

F_RGW	macro	name,cw,opts
    equate  _F_&name,%VLcbstruct
    _SSize  (cw*2)
endm

;
; Generate a P_?LP???? macro, given:
;
; n = parameter macro name (e.g., P_LPRECT)
; r = handler routine name (e.g., LP)
; cb = size of buffer
;
; The generated macro checks only whether the
; buffer is big enough.
;
_GenLP	macro	n,r,cb
    &n	    &macro   name,opts
        _GenParm    <name>,4,<opts>
        if VLgen
	    mov     ax,_P_&&name
	    mov     cx,_P_&&name+2
	    mov     bx,cb
	    lcall   &r
            _gensub <LP>
	endif
    &endm
endm

;=========================================================================
;
; Generic parameter macros
;
P_2	macro	name, opts
	_DefParm      <name>,2,<opts>
endm

P_4	macro	name, opts
	_DefParm      <name>,4,<opts>
endm

P_8     macro   name, opts
        _DefParm      <name>,8,<opts>
endm

P_char	    equ <P_2>
P_int	    equ <P_2>
P_BYTE	    equ <P_2>
P_BOOL	    equ <P_2>
P_WORD	    equ <P_2>

P_WORDMBZ   equ <P_2>
P_WORDMBNZ  equ <P_2>

P_LONG	    equ <P_4>
P_DWORD     equ <P_4>

;
; Generic handle
;
P_H	macro	name, opts
    _GenParm    <name>,2,<opts>
    if VLgen
;	mov	ax,_P_&name
;	lcall	H
;	 _gensub H
    endif
endm

;
; Generic handle or NULL
;
P_H0	equ	<P_2>

;
; Ensure signed value is min <= value <= max
;
P_RVALUE    macro   name, min, max, opts
        local   valok
    _GenParm    <name>,2,<opts>
    if VLgen
	mov	ax,_P_&name
	cmp	ax,min
	jl	@F
	cmp	ax,max
        jle     valok
@@:
        mov     bx,ERR_BAD_VALUE or ERR_WARNING
        lcall   Inval_Param_
valok:
    endif
endm

;
; Ensure signed value is 0 <= value <= max
;
P_VALUE     macro   name, max, opts
    _GenParm    <name>,2,<opts>
    if VLgen
	mov	ax,_P_&name
	cmp	ax,max
	jbe	@F		    ;; unsigned comparison to catch < 0.
        mov     bx,ERR_BAD_VALUE or ERR_WARNING
        lcall   Inval_Param_
@@:
    endif
endm

;
; Ensure unsigned value is value <= max
;
P_UVALUE    equ <P_VALUE>

;
; Ensure signed value is 0 <= value <= max
;
P_VALUEW     macro   name, max, opts
    _GenParm    <name>,2,<opts>
    if VLgen
	mov	ax,_P_&name
	cmp	ax,max
	jbe	@F		    ;; unsigned comparison to catch < 0.
        mov     bx,ERR_BAD_VALUE or ERR_WARNING
        lcall   Inval_Param_
@@:
    endif
endm

;
; Ensure unsigned value is value <= max
;
P_UVALUEW    equ <P_VALUEW>

;
; Ensure signed byte value is min <= value <= max
;
if 0
P_BVALUE	macro	name,max,opts
    _GenParm    <name>,2,<opts>
    if VLGen
	mov	al,_P_&name
	cmp	al,max
	jle	@F
	lcall	ErrorBValue
@@:
    endif
endm
else
P_BVALUE    equ <P_2>
endif

;
; Ensure that no incorrect bits are set in a flags word
; (i.e., (name & ~valid) == 0)
;
P_FLAGS     macro   name, valid, opts
  _DefParm  <name>,2,<opts>
  if not(valid)
    if VLgen
	_FlsFrame
	mov	ax,_P_&name
      ife (low(not(valid)))
	test	ah,high(not(valid))
      else
       ife (high(not(valid)))
	test	al,low(not(valid))
       else
	test	ax,not(valid)
       endif
      endif
	jz	@F
        mov     bx,ERR_BAD_FLAGS or ERR_WARNING
        lcall   Inval_Param_
@@:
    endif
  endif
endm

;
; Ensure that no incorrect bits are set in a flags dword
; (i.e., (name & ~valid) == 0)
;
P_DFLAGS    macro   name, valid_l, valid_h, opts
        local   flagok
  _DefParm   <name>,4,<opts>
  if not(valid_l) or not(valid_h)
    if VLgen
	_FlsFrame
	mov	ax,_P_&name
	mov	cx,_P_&name+2
      if not(valid_l)
	test	ax,not(valid_l)
       if not(valid_h)
	jnz	@F
       else
        jz      flagok
       endif
      endif
      if not(valid_h)
	test	cx,not(valid_h)
        jz      flagok
@@:
      endif
        mov     bx,ERR_BAD_DFLAGS or ERR_WARNING
        lcall   Inval_Param_
flagok:
    endif
  endif
endm

;
; P_LPFN   - function pointer
; P_LPFN0  - function pointer or NULL
;
P_LPFN	macro	name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
	mov	ax,_P_&name
	mov	cx,_P_&name+2
	lcall	LPFN
        _gensub LPFN
    endif
endm

P_LPFN0 macro	name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
	mov	ax,_P_&name
	mov	cx,_P_&name+2
	lcall	LPFN0
        _gensub LPFN
    endif
endm

_GenBuf macro p,r
    P_&p  &macro   lpch, cch, opts
	_DefParm    <lpch>,4,<opts>
	_DefParm    <cch>,2,<opts>
        if VLgen
	    _FlsFrame
	    mov     ax,_P_&&lpch
	    mov     cx,_P_&&lpch+2
	    mov     bx,_P_&&cch
	    lcall   &r
            _gensub LP
	endif
    &endm
endm

_GenBufspl macro p,r
    P_&p  &macro   lpch, cch, opts
	_DefParm    <lpch>,4,<opts>
	_DefParm    <cch>,2,<opts>
        if VLgen
	    _FlsFrame
	    mov     ax,_P_&&lpch
	    mov     cx,_P_&&lpch+2
	    lea	    bx,_P_&&cch
	    lcall   &r
            _gensub LPBUF
	endif
    &endm
endm

_GenBufspl <LPBUFFER>,<LPBUF>
_GenBuf <CLPBUFFER>,<CLP>
_GenBufspl <LPBUFFER0>,<LPBUF0>
_GenBuf <CLPBUFFER0>,<CLP0>

;
; If pszBuf is valid, set its first byte to 0
;
E_SETEMPTY  macro   pszBuf,cchBuf,opts
        push    bp
	mov	bp,sp
	mov	cx,_P_&cchBuf
        mov     bx,_P_&pszBuf
        mov     dx,_P_&pszBuf+2
	pop	bp
        lcall   SETEMPTY
        _gensub SETEMPTY
endm

; Same as above, but with no supplied count
;
E_SETEMPTYNC  macro   pszBuf,opts
        push    bp
        mov     bp,sp
        mov     cx,1
        mov     bx,_P_&pszBuf
        mov     dx,_P_&pszBuf+2
        pop     bp
        lcall   SETEMPTY
        _gensub SETEMPTY
endm

_GenLP	<P_LPSTR>,<LP>,1
_GenLP	<P_LPSTR0>,<LP0>,1

P_CLPSTR macro   name,cch,opts
    _GenParm    <name>,4,<opts>
    if VLgen
	mov	ax,_P_&name
	mov	cx,_P_&name+2
    ifb <cch>
        mov     bx,-1
    else
        mov     bx,cch
    endif
	lcall	CLPSZ
        _gensub LPSZ
    endif
endm

P_CLPSTR0 macro   name,cch,opts
    _GenParm    <name>,4,<opts>
    if VLgen
	mov	ax,_P_&name
	mov	cx,_P_&name+2
    ifb <cch>
        mov     bx,-1
    else
        mov     bx,cch
    endif
	lcall	CLPSZ0
        _gensub LPSZ
    endif
endm

_GenLP	<P_LPVOID>,<LP>,1
_GenLP	<P_LPVOID0>,<LP0>,1
_GenLP	<P_CLPVOID>,<CLP>,1
_GenLP	<P_CLPVOID0>,<CLP0>,1

_GenLP	<P_LPBYTE>,<LP>,1
_GenLP	<P_LPBYTE0>,<LP0>,1
_GenLP	<P_CLPBYTE>,<CLP>,1
_GenLP	<P_CLPBYTE0>,<CLP0>,1

_GenLP	<P_LPINT>,<LP>,2
_GenLP	<P_LPINT0>,<LP0>,2
_GenLP	<P_CLPINT>,<CLP>,2
_GenLP	<P_CLPINT0>,<CLP0>,2

_GenLP	<P_LPWORD>,<LP>,2
_GenLP	<P_LPWORD0>,<LP0>,2
_GenLP	<P_CLPWORD>,<CLP>,2
_GenLP	<P_CLPWORD0>,<CLP0>,2

_GenLP	<P_LPBOOL>,<LP>,2
_GenLP	<P_LPBOOL0>,<LP0>,2
_GenLP	<P_CLPBOOL>,<CLP>,2
_GenLP	<P_CLPBOOL0>,<CLP0>,2

_GenLP	<P_LPLONG>,<LP>,4
_GenLP	<P_LPLONG0>,<LP0>,4
_GenLP	<P_CLPLONG>,<CLP>,4
_GenLP	<P_CLPLONG0>,<CLP0>,4

_GenLP	<P_LPDWORD>,<LP>,4
_GenLP	<P_LPDWORD0>,<LP0>,4
_GenLP	<P_CLPDWORD>,<CLP>,4
_GenLP	<P_CLPDWORD0>,<CLP0>,4

;=======================================================================
;
; Common USER types
;
STRUCT	<POINT>
F_int	     x
F_int	     y
ENDSTRUCT

STRUCT <LARGEPOINT>
F_LONG      x
F_LONG      y
ENDSTRUCT


_GenLP	<P_LPPOINT>,<LP>,%VLcbsPOINT
_GenLP	<P_LPPOINT0>,<LP0>,%VLcbsPOINT
_GenLP	<P_CLPPOINT>,<CLP>,%VLcbsPOINT
_GenLP	<P_CLPPOINT0>,<CLP0>,%VLcbsPOINT
P_POINT     equ <P_4>

_GenLP  <P_LPLARGEPOINT>,<LP>,%VLcbsLARGEPOINT
P_LARGEPOINT equ <P_8>

STRUCT	<RECT>
F_int	     left
F_int	     top
F_int	     right
F_int	     bottom
ENDSTRUCT

_GenLP	<P_LPRECT>,<LP>,%VLcbsRECT
_GenLP	<P_LPRECT0>,<LP0>,%VLcbsRECT
_GenLP	<P_CLPRECT>,<CLP>,%VLcbsRECT
_GenLP	<P_CLPRECT0>,<CLP0>,%VLcbsRECT

;=======================================================================
;
; Common KERNEL types
;
P_GHANDLE   macro   h,opts
    _GenParm   <h>,2,<opts>
    if VLgen
       mov     ax,_P_&h
       lcall   GHANDLE
        _gensub GHANDLE
    endif

endm

P_GHANDLE0  macro   h,opts
    _GenParm   <h>,2,<opts>
    if VLgen
       mov     ax,_P_&h
       lcall   GHANDLE0
        _gensub GHANDLE
    endif
endm

P_GHANDLE32  macro   h,opts
    _GenParm   <h>,2,<opts>
    if VLgen
       mov ax,_P_&h
       test al, 0100b    ;let zero & BOGUSGDT hInst's through
       jz   @F
       lcall   GHANDLE
        _gensub GHANDLE
       @@:
    endif
endm

P_HANDLE    equ <P_H>
P_HANDLE0   equ <P_H0>

P_ATOM	    equ <P_H>

P_HINSTANCE equ <P_GHANDLE>
P_HINSTANCE0 equ <P_GHANDLE0>
P_HINSTANCE32 equ <P_GHANDLE32>

P_HMODULE   equ <P_GHANDLE>
P_HMODULE0  equ <P_GHANDLE0>

P_HTASK     equ <P_GHANDLE>
P_HTASK0    equ <P_GHANDLE0>

P_CLPSTRATOM macro   name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
	mov	ax,_P_&name
	mov	cx,_P_&name+2
	lcall	CLPSTRATOM
        _gensub LPSZ
    endif
endm

P_CLPSTRATOM0 macro name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
	mov	ax,_P_&name
	mov	cx,_P_&name+2
	lcall	CLPSTRATOM0
        _gensub LPSZ
    endif
endm

P_CLPSTRRSRC  equ <P_CLPSTRATOM>
P_CLPSTRRSRC0 equ <P_CLPSTRATOM0>

;---------------------------------------------------------------------------
; LAYER_EXPAND	lseg
;
; Expands per-segment validation boilerplate code into segment lseg
;
LAYER_EXPAND	macro	lseg
.list
.lall
    _SwitchSeg	&lseg,%VLseg

public	VStart&lseg
VStart&lseg:

EXTRA_EXPAND    lseg

;
; Handle validation
;
ifdef genH&lseg

public H&lseg
H&lseg:
	or	ax,ax
        jz      @F
	ret
@@:
        mov     bx,ERR_BAD_HANDLE
        jmp     short Inval_Param_&lseg

endif   ; genH&lseg

ifdef genGHANDLE&lseg

public GHANDLE0&lseg
GHANDLE0&lseg:
	or	ax,ax		; accept NULL
	jz	GHexit&lseg

public GHANDLE&lseg
GHANDLE&lseg:
	test	al,0100b	; Reject GDT selectors
        jz      GHerr&lseg
	cmp	ax,0ffffh	; special case: -1 -> DS
	jz	GHexit&lseg
	lar	dx,ax		; is it a valid selector?
        jnz     GHerr&lseg
GHexit&lseg:
	ret

GHerr&lseg:
        mov     bx,ERR_BAD_GLOBAL_HANDLE
        jmp     short Inval_Param_&lseg

endif   ; genGHANDLE&lseg

ifdef genLPFN&lseg

;
; Function pointer validation
;
public LPFN0&lseg
LPFN0&lseg:
	mov	bx,ax	    ; Allow NULL
	or	bx,cx
	jz	LPFN_exit&lseg

public LPFN&lseg
LPFN&lseg:
beg_fault_trap  LPFNbad&lseg
        lar     bx,cx
        jnz     LPFNerr&lseg
        test    bh,8
        jz      LPFNerr&lseg
        mov     es,cx       ; validate pointer & offset
        mov     bx,ax
        mov     al,es:[bx]
end_fault_trap

ifdef DEBUG
;
; Make sure the function is exported by
; ensuring that the first instructions are NOT
; push ds, pop ax or mov ax,ds.
;
	mov	bx,es:[bx]+2

        cmp     bx,0581eh                   ; Push ds, pop ax instructions?
        jz      LPFNerr&lseg                ; Yes, must be an error.
        cmp     bx,0d88ch                   ; Mov ax,ds instruction?
        jz      LPFNerr&lseg                ; No, we're ok, so jump ahead
endif	; DEBUG

LPFN_exit&lseg:
	ret

LPFNbad&lseg:
	fault_fix_stack
LPFNerr&lseg:
        mov     bx,ERR_BAD_FUNC_PTR
        jmp     short Inval_Param_&lseg

endif   ; genLPFN&lseg

public Inval_Param_&lseg
Inval_Param_&lseg:
        pop     dx          ; convert near return addr to far
        push    cs
	push	dx
	jmp	HandleParamError

ifdef genLP&lseg

public LP0&lseg
LP0&lseg:
	or	ax,ax	    ; if cx:ax == NULL, exit
	jnz	@F
	jcxz	CLPexit&lseg
@@:
public LP&lseg
LP&lseg:
beg_fault_trap  CLPbad&lseg
        mov     es,cx
        or      bx,bx           ; cb == 0?
        jz      CLPexit&lseg    ; yes: just check selector
        dec     bx
        add     bx,ax
        jc      CLPbad1&lseg    ; check 16 bit overflow
        or      byte ptr es:[bx],0  ; check write permission, limit
end_fault_trap
        ret

public CLP0&lseg
CLP0&lseg:
        or      ax,ax           ; Accept ax:cx == 0
	jnz	@F
	jcxz	CLPexit&lseg
@@:
public CLP&lseg
CLP&lseg:
beg_fault_trap  CLPbad&lseg
        mov     es,cx
        or      bx,bx           ; cb == 0?
        jz      CLPexit&lseg    ; yes: just check selector
        dec     bx
        add     bx,ax
        jc      CLPbad1&lseg    ; check 16 bit overflow
        mov     bl,es:[bx]      ; check read permission, limit
end_fault_trap

public CLPexit&lseg
CLPexit&lseg:
	ret

CLPbad&lseg:
	fault_fix_stack
CLPbad1&lseg:
        mov     bx,ERR_BAD_PTR
	jmp	Inval_Param_&lseg

endif   ; genLP&lseg

ifdef	genLPBUF&lseg
public LPBUF0&lseg
LPBUF0&lseg:
	or	ax,ax	    ; if cx:ax == NULL, exit
	jnz	@F
	jcxz	LPBUFexit&lseg
@@:
public LPBUF&lseg
LPBUF&lseg:
beg_fault_trap  LPBUFbad&lseg
        mov     es,cx
        mov     cx, word ptr ss:[bx]	; cb == 0?
        jcxz    LPBUFexit&lseg		; yes: just check selector
	mov	dx, bx		
	mov	bx, ax
        or      byte ptr es:[bx],0  	; check write permission, start
	mov	bx, dx
LPBUFpast1&lseg:
        dec     cx
        add     cx,ax
	jnc	@f			; 16-bit overflow
	mov	bx, 0ffffh
	mov	cx, bx
        or      byte ptr es:[bx],0  	; check write permission, 64k-1
	jmp	LPBUFov&lseg
@@:
	mov	bx, cx
        or      byte ptr es:[bx],0  	; check write permission, end
	ret
end_fault_trap

public LPBUFexit&lseg
LPBUFexit&lseg:
	ret
LPBUFbad&lseg:
	mov	bx, dx
	pop	dx			; fault ip
	add	sp, 2			; fault
	cmp	dx, offset LPBUFpast1&lseg
	jb	LPBUFbad1&lseg

	mov	dx, es
	lsl	cx, dx
	jnz	LPBUFbad1&lseg		; should not occur, we have loaded es
LPBUFov&lseg:
	sub	cx, ax			; max legal cb
	inc	cx
	mov	word ptr ss:[bx], cx	; fix cb passed by user on stack
	mov	cx, es			; HandleParamError prints cx:ax
        mov     bx,ERR_BAD_PTR or ERR_WARNING
	jmp	Inval_Param_&lseg
LPBUFbad1&lseg:
	mov	cx, es			; HandleParamError prints cx:ax
        mov     bx,ERR_BAD_PTR
	jmp	Inval_Param_&lseg
endif	; genLPBUF&lseg

ifdef   genLPSZ&lseg

;
; cx:ax -> const pointer to z-terminated string or MAKEINTATOM atom.
;
public CLPSTRATOM0&lseg
CLPSTRATOM0&lseg:
        jcxz    CLPSZexit&lseg  ; If selector is NULL, then all is well.

public CLPSTRATOM&lseg
CLPSTRATOM&lseg:
	jcxz	@F		; if selector == 0, then may be atom.
        mov     bx,256          ; max string length of 255 characters.
	jmp	short CLPSZ&lseg
@@:
	or	ax,ax		; offset == 0? if so, it's bogus
	jz	ErrorStrPtr&lseg
CLPSZexit&lseg:
	ret
;
; cx:ax => const pointer to zero-terminated string.
; bx    => Maximum string length (including zero terminator)
;
public CLPSZ0&lseg
CLPSZ0&lseg:
        mov     dx,ax
        or      dx,cx
        jz      CLPSZexit&lseg
public CLPSZ&lseg
CLPSZ&lseg:
        push    di              ; preserve these regs
        push    cx
        mov     dx,ax           ; preserve original ax in dx
beg_fault_trap  LPSZfault&lseg
        mov     es,cx
        mov     di,ax

	xor	ax,ax
	mov	cx,-1
	cld
	repnz	scasb
end_fault_trap
        neg     cx              ; cx = string length + 1
        dec     cx
        cmp     cx,bx           ; error if string length + 1 > cchMax

        pop     cx              ; restore regs before branching
        pop     di
        xchg    ax,dx

        ja      ErrorStrPtr&lseg ; jump if error
        ret

LPSZfault&lseg:
        fault_fix_stack
        pop     cx              ; restore regs
        pop     di
        xchg    ax,dx

public ErrorStrPtr&lseg
ErrorStrPtr&lseg:
	mov	bx,ERR_BAD_STRING_PTR
	jmp	Inval_Param_&lseg

endif   ; genLPSZ&lseg

ifdef   genSETEMPTY&lseg

public  SETEMPTY&lseg
SETEMPTY&lseg:
        jcxz    SETEMPTYexit&lseg   ; 0-length buffer: do nothing.
beg_fault_trap    SETEMPTYbad&lseg
        mov     es,dx
        mov     byte ptr es:[bx],0  ; jam in a zero terminator
end_fault_trap
SETEMPTYexit&lseg:
	xor	ax,ax
	cwd
        ret

SETEMPTYbad&lseg:
        fault_fix_stack
        jmp     short SETEMPTYexit&lseg

endif   ; genSETEMPTY&lseg

public VEnd&lseg
VEnd&lseg:

sEnd	%VLseg
VLseg equ <>

endm	;LAYER_EXPAND

endif	;; IF1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\klayer.inc ===
;=======================================================
;
; Macros stolen from cmacros.inc (so we don't have to include it all)
;
    .286p

externNP    macro   n
    irp x,<n>
    extrn x:near
    endm
endm

externFP    macro   n
    irp x,<n>
    extrn x:far
    endm
endm

externW     macro   w
    irp x,<w>
        extrn x:word
    endm
endm

assumes     macro s,ln
    assume  s:_&ln
endm

createSeg   macro n,ln,a,co,cl,grp
    n segment a co '&cl'
    n ends
endm

sBegin      macro   seg
    assume  cs:_&seg
    _&seg   segment
endm

sEnd        macro   seg
    _&seg ends
    assume  cs:nothing
endm

errnz macro x               ;;display error if expression is <>0
  if2
    if x                ;;if expression is non-zero,
      errnz1  <x>,%(x)
    endif
  endif
endm

errnz1 macro x1,x2
  = *errnz* x1 = x2
  .err
endm

errn$ macro l,x             ;;error if <$-label1 (exp2)> <>0
  errnz   <offset $ - offset l x>
endm

createSeg _DATA,DATA,WORD,PUBLIC,DATA

;=======================================================
;
; Error API definitions
;
ExternFP    <HandleParamError>

; error codes
include logerror.inc

;================================================================
;   Variable and temporary initialization

VLseg  equ <>      ; Holds current segment name

VLopen = 0
VLerrnotinvoked  = 0
ifndef VLnogenpall
VLnogenpall = 0
endif

VLnogen        = 0
VLnogenparm    = 0

VLsavees       = 0
VLsavebx       = 0

;if1
if 1

;================================================================
;   Utility macros

;---------------------------------------------------------------------------
;
; lodsw cs:[si]
;
cslodsw macro
    db  2eh     ;; CS override
    lodsw
endm

;---------------------------------------------------------------------------
;
; lodsb cs:[si]
;
cslodsb macro
    db  2eh     ;; CS override
    lodsb
endm

SkipTwoBytes macro
    db  0A9h    ;; Opcode for CMP AX,(immediate word)
endm

;---------------------------------------------------------------------------
;
; Define a as the concatenation of b & c
;
concat  macro   a,b,c,d,e,f
a   equ <b&c&d&e&f>
endm

;---------------------------------------------------------------------------
;
; Assign a to b.
;
equate  macro   a,b
    a   = b
endm

;
; Print a message
;
_print  macro a,b,c
if2
    %out   a&b&c
endif
endm


;===============================================================

;---------------------------------------------------------------------------
;
; _gensub   LABEL
;
; Causes per-segment subroutine code associated with type LABEL
; to be generated, by setting the genLABEL&lseg flag.
;
_gensub2    macro   l,s
    gen&l&s = 1
endm

_gensub macro   l
        _gensub2    <l>,%VLseg
endm

;---------------------------------------------------------------------------
; _SwitchSeg
;
; Switches current segment to seg, creating the segment if needed.
;
_SwitchSeg   macro   seg,oldseg
    ifdifi  <&seg>,<oldseg>

      ifnb  <oldseg>
sEnd oldseg
      endif

    concat  <VLseg>,seg,

createSeg _&seg,seg,WORD,PUBLIC,CODE

sBegin seg
assumes CS,seg

    endif
endm


;---------------------------------------------------------------------------
; API
;
API macro   rettype,name,seg,optlist

    if  VLopen
    APIEND
    endif

VLname equ <name>
VLcbparms      = 0
VLcbskip       = 0
VLerrnotinvoked= 1
VLopen         = 1
VLnogen        = 0
VLnogenparm    = 0
VLasm          = 0
VLfunnyframe   = 0
VLnodata       = 0
VLcargs        = 0
VLplist        equ <>
VLATMframe     = 0      ; special entry/exit code sequence for ATM's patching
VLATMfrmds     = 0      ; ATM entry/exit code: mov ax,_DATA at beginning.

VLsavees    = 0
VLsavebx        = 0
    _SwitchSeg seg,%VLseg

    irp opt,<optlist>

      ifidni  <opt>,<NOGEN>
      VLnogen = 1
      endif

      ifidni  <opt>,<VOID>
      VLnogen = 1
      endif

      ifidni  <opt>,<ASM>
      VLasm = 1
      endif

      ifidni  <opt>,<ATMFRAME>
      VLATMframe = 1
      endif

      ifidni  <opt>,<ATMFRAMEDS>
      VLATMfrmds = 1
      VLATMframe = 1
      endif

      ifidni  <opt>,<FUNNYFRAME>
      VLfunnyframe = 1
      endif

      ifidni  <opt>,<NODATA>
      VLnodata = 1
      endif

      ifidni  <opt>,<DEBUGONLY>
        ifndef DEBUG
        VLnogen = 1
        endif
      endif

      ifidni  <opt>,<C>
      VLcargs  = 1
      endif

      ifidni  <opt>,<SAVEES>
      VLsavees  = 2     ; sizeof(ES)
      endif

      ifidni  <opt>,<SAVEBX>
      VLsavebx  = 2     ; sizeof(BX)
      endif

    endm

concat  <VLsegoffset>,<seg>,<offset>
concat  <VLnameerror>,<name>,<_error>
concat  <VLnamecbparms>,<name>,<cbparms>

    if1
equate %VLnamecbparms, %VLcbparms
    else
equate %VLnamecbparms, %VLnamecbparms
    endif

    ife VLnogen

    ife VLcargs
concat  <VLiname>,<I>,<name>
ExternNP I&name

public  name
name:
    else
concat  <VLiname>,<_I>,<name>
ExternNP _I&name

public  _&name
_&name:
    endif

VLframe =   0           ; no frame set up yet.

    endif  ; VLnogen

endm    ;; VL

;---------------------------------------------------------------------------
; APIERR
;
; Optionally used after parameter decls to begin error handling code
;
APIERR  macro   opts

    ife VLnogen
      ife VLframe
    _print  <Nothing to validate for >,%VLiname
      else
    pop dx      ; pop off error handler address
    pop bp      ; restore BP
       if VLATMframe
    dec bp      ; fix BP back up
       endif
       if VLsavees
    pop es
       endif
       if VLsavebx
        pop     bx
       endif
      endif
    jmp VLiname     ; jmp to internal routine.

equate %VLnamecbparms, %VLcbparms

VLnameerror:
    VLerrnotinvoked  = 0

    endif ; VLnogen

endm    ;; APIERR

;---------------------------------------------------------------------------
; APIEND
;
; Used after APIERR to terminate error handling code.
;
APIEND  macro

_PurgeParms %VLplist

    ife VLnogen

    if  VLerrnotinvoked
    APIERR
    endif
    if VLsavees
    pop es
    endif
    if VLsavebx
        pop     bx
    endif
    ife VLcargs
    retf    VLcbparms
    else
    retf
    endif

VLopen = 0

    endif   ; VLnogen

endm    ;; APIEND

;---------------------------------------------------------------------------
;
; _FlsFrame - Generate frame code
;
_FlsFrame   macro
    ife VLframe
     if VLATMfrmds
    mov ax,_DATA
     endif
     if VLsavebx
        push    bx
     endif
     if VLsavees
    push    es
     endif
     if VLATMframe
    inc bp
    push    bp
    mov bp,sp
    push    ds          ; push ds and pop it off.
    pop ds          ; (we need to pop DS rather than
                    ;  something fast like pop AX because
                    ; ATM doesn't preserve DS itself)
     else
    push    bp
    mov bp,sp
     endif
    push    offset VLnameerror  ; push address of error handler
    VLframe = 1
    endif
endm

;---------------------------------------------------------------------------
; _ChkName
;
; Ensure name was specified

_ChkName    macro name
    ifb <name>
    _print <Missing parameter name in >,%VLiname
    endif
endm

;---------------------------------------------------------------------------
; _ParmOpts
;
; Parse parameter option flags
;
_ParmOpts  macro opts

    VLnogenparm = VLnogenpall

    irp opt,<opts>
    ifidni  <opt>,<DEBUGONLY>
    ifndef DEBUG
        VLnogenparm = 1
    endif
    ifidni  <opt>,<NOGEN>
        VLnogenparm = 1
    endif
    endif
    endm
endm

;---------------------------------------------------------------------------
; _DefParm name,cb,opts
;
; Take care of default parameter stuff, such as defining argument.
;
_DP_Add     macro   old,new
    ifb     <old>
VLplist equ <new>
    else
VLplist equ <old,new>
    endif
endm

_DefParm   macro   name,cb,opts
    _ChkName    <name>
    _ParmOpts   <opts>

  if VLcargs
concat  _P_&name,<[bp]+6+>,%(VLcbparms+VLsavees+VLsavebx)
    VLcbparms=VLcbparms+(cb)
  else
    VLcbparms=VLcbparms+(cb)
concat  _P_&name,<[bp]+6->,%VLcbparms,<+>,%(VLnamecbparms+VLsavees+VLsavebx)
  endif

_DP_Add     %VLplist,<_P_&name>

    VLgen = 1
    if VLnogenparm or VLnogen
        VLgen = 0
    endif
endm

;----------------------------------------------------------------------------
;
; _GenParm  name, cb, opts
;
_GenParm    macro   name,cb,opts
    _DefParm    <name>,<cb>,<opts>
    if VLgen
    _FlsFrame
    endif
endm

lcall2  macro   op,label,seg
    op  label&seg
endm

lcall   macro   label
    lcall2  <call>,<label>,%VLseg
endm

ljmp    macro   label
    lcall2  <jmp>,<label>,%VLseg
endm

;
; _PurgeParms - purge list of parameters we've defined
;
_PurgeParms   macro   list
    irp sym,<list>
sym equ <>
    endm
endm

;---------------------------------------------------------------------------
; LAYER_START
;
; Used before any VL invocations
;
LAYER_START macro
assumes ds,DATA

endm

;---------------------------------------------------------------------------
; LAYER_END
;
; Ends all VL definitions
;
LAYER_END   macro
    if VLsopen
    ENDSTRUCT
    endif
    if VLopen
    APIEND
    endif
    if VLerrnotinvoked
    APIERR
    endif
endm

;=========================================================================
;
; Structure related macros
;
; Structure globals

VLsopen =0

;
; STRUCT - begins a structure declaration
;
STRUCT  macro   name,opts
  if VLsopen
    ENDSTRUCT
  endif
  VLsopen=1

concat  VLcbs,<VLcbs>,name
VLcbstruct  =   0
endm

;
; ENDSTRUCT macro - terminates a STRUCT declaration
;
ENDSTRUCT   macro
equate  %VLcbs,%VLcbstruct

VLsopen =0
endm

;
; Define simple field macro, given:
;   f = macro name
;   cb = size of field
;
_SSize  macro   cb,opts
VLcbstruct  =   VLcbstruct + (cb)
endm

_DefSimpleF macro   f,cb
    f   &macro  name,opts
    equate  _F_&&name,%VLcbstruct
    _SSize  cb
    &endm
endm

_DefSimpleF F_char,1
_DefSimpleF F_BYTE,1

_DefSimpleF F_int,2
_DefSimpleF F_WORD,2
_DefSimpleF F_BOOL,2
_DefSimpleF F_FLAGS,2

_DefSimpleF F_LONG,4
_DefSimpleF F_DWORD,4

_DefSimpleF F_intMBZ,2
_DefSimpleF F_DWORDMBZ,4

_DefSimpleF F_LPVOID,4
_DefSimpleF F_CLPSTR,4
_DefSimpleF F_CLPSTR0,4
_DefSimpleF F_LPSTR,4

_DefSimpleF F_POINT,4
_DefSimpleF F_RECT,8

F_RGB   macro   name,cb,opts
    equate  _F_&name,%VLcbstruct
    _SSize  cb
endm

F_RGCH  equ <F_RGB>

F_RGW   macro   name,cw,opts
    equate  _F_&name,%VLcbstruct
    _SSize  (cw*2)
endm

;
; Generate a P_?LP???? macro, given:
;
; n = parameter macro name (e.g., P_LPRECT)
; r = handler routine name (e.g., LP)
; cb = size of buffer
;
; The generated macro checks only whether the
; buffer is big enough.
;
_GenLP  macro   n,r,cb
    &n      &macro   name,opts
        _GenParm    <name>,4,<opts>
        if VLgen
        mov     ax,_P_&&name
        mov     cx,_P_&&name+2
        mov     bx,cb
        lcall   &r
            _gensub <LP>
    endif
    &endm
endm

;=========================================================================
;
; Generic parameter macros
;
P_2 macro   name, opts
    _DefParm      <name>,2,<opts>
endm

P_4 macro   name, opts
    _DefParm      <name>,4,<opts>
endm

P_char      equ <P_2>
P_int       equ <P_2>
P_BYTE      equ <P_2>
P_BOOL      equ <P_2>
P_WORD      equ <P_2>

P_WORDMBZ   equ <P_2>
P_WORDMBNZ  equ <P_2>

P_LONG      equ <P_4>
P_DWORD     equ <P_4>

;
; Generic handle
;
P_H macro   name, opts
    _GenParm    <name>,2,<opts>
    if VLgen
    mov ax,_P_&name
    lcall   H
        _gensub H
    endif
endm

;
; Generic handle or NULL
;
P_H0    equ <P_2>

;
; Ensure signed value is min <= value <= max
;
P_RVALUE    macro   name, min, max, opts
        local   valok
    _GenParm    <name>,2,<opts>
    if VLgen
    mov ax,_P_&name
    cmp ax,min
    jl  @F
    cmp ax,max
        jle     valok
@@:
        mov     bx,ERR_BAD_VALUE or ERR_WARNING
        lcall   Inval_Param_
valok:
    endif
endm

;
; Ensure signed value is 0 <= value <= max
;
P_VALUE     macro   name, max, opts
    _GenParm    <name>,2,<opts>
    if VLgen
    mov ax,_P_&name
    cmp ax,max
    jbe @F          ;; unsigned comparison to catch < 0.
        mov     bx,ERR_BAD_VALUE or ERR_WARNING
        lcall   Inval_Param_
@@:
    endif
endm

;
; Ensure unsigned value is value <= max
;
P_UVALUE    equ <P_VALUE>

;
; Ensure signed value is 0 <= value <= max
;
P_VALUEW     macro   name, max, opts
    _GenParm    <name>,2,<opts>
    if VLgen
    mov ax,_P_&name
    cmp ax,max
    jbe @F          ;; unsigned comparison to catch < 0.
        mov     bx,ERR_BAD_VALUE or ERR_WARNING
        lcall   Inval_Param_
@@:
    endif
endm

;
; Ensure unsigned value is value <= max
;
P_UVALUEW    equ <P_VALUEW>

;
; Ensure signed byte value is min <= value <= max
;
if 0
P_BVALUE    macro   name,max,opts
    _GenParm    <name>,2,<opts>
    if VLGen
    mov al,_P_&name
    cmp al,max
    jle @F
    lcall   ErrorBValue
@@:
    endif
endm
else
P_BVALUE    equ <P_2>
endif

;
; Ensure that no incorrect bits are set in a flags word
; (i.e., (name & ~valid) == 0)
;
P_FLAGS     macro   name, valid, opts
  _DefParm  <name>,2,<opts>
  if not(valid)
    if VLgen
    _FlsFrame
    mov ax,_P_&name
      ife (low(not(valid)))
    test    ah,high(not(valid))
      else
       ife (high(not(valid)))
    test    al,low(not(valid))
       else
    test    ax,not(valid)
       endif
      endif
    jz  @F
        mov     bx,ERR_BAD_FLAGS or ERR_WARNING
        lcall   Inval_Param_
@@:
    endif
  endif
endm

;
; Ensure that no incorrect bits are set in a flags dword
; (i.e., (name & ~valid) == 0)
;
P_DFLAGS    macro   name, valid_l, valid_h, opts
        local   flagok
  _DefParm   <name>,4,<opts>
  if not(valid_l) or not(valid_h)
    if VLgen
    _FlsFrame
    mov ax,_P_&name
    mov cx,_P_&name+2
      if not(valid_l)
    test    ax,not(valid_l)
       if not(valid_h)
    jnz @F
       else
        jz      flagok
       endif
      endif
      if not(valid_h)
    test    cx,not(valid_h)
        jz      flagok
@@:
      endif
        mov     bx,ERR_BAD_DFLAGS or ERR_WARNING
        lcall   Inval_Param_
flagok:
    endif
  endif
endm

;
; P_LPFN   - function pointer
; P_LPFN0  - function pointer or NULL
;
P_LPFN  macro   name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
    mov ax,_P_&name
    mov cx,_P_&name+2
    lcall   LPFN
        _gensub LPFN
    endif
endm

P_LPFN0 macro   name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
    mov ax,_P_&name
    mov cx,_P_&name+2
    lcall   LPFN0
        _gensub LPFN
    endif
endm

_GenBuf macro p,r
    P_&p  &macro   lpch, cch, opts
    _DefParm    <lpch>,4,<opts>
    _DefParm    <cch>,2,<opts>
        if VLgen
        _FlsFrame
        mov     ax,_P_&&lpch
        mov     cx,_P_&&lpch+2
        mov     bx,_P_&&cch
        lcall   &r
            _gensub LP
    endif
    &endm
endm

_GenBufspl macro p,r
    P_&p  &macro   lpch, cch, opts
    _DefParm    <lpch>,4,<opts>
    _DefParm    <cch>,2,<opts>
        if VLgen
        _FlsFrame
        mov     ax,_P_&&lpch
        mov     cx,_P_&&lpch+2
        lea     bx,_P_&&cch
        lcall   &r
            _gensub LPBUF
    endif
    &endm
endm

_GenBufspl <LPBUFFER>,<LPBUF>
_GenBuf <CLPBUFFER>,<CLP>
_GenBufspl <LPBUFFER0>,<LPBUF0>
_GenBuf <CLPBUFFER0>,<CLP0>

;
; If pszBuf is valid, set its first byte to 0
;
E_SETEMPTY  macro   pszBuf,cchBuf,opts
        push    bp
    mov bp,sp
    mov cx,_P_&cchBuf
        mov     bx,_P_&pszBuf
        mov     dx,_P_&pszBuf+2
    pop bp
        lcall   SETEMPTY
        _gensub SETEMPTY
endm

; Same as above, but with no supplied count
;
E_SETEMPTYNC  macro   pszBuf,opts
        push    bp
        mov     bp,sp
        mov     cx,1
        mov     bx,_P_&pszBuf
        mov     dx,_P_&pszBuf+2
        pop     bp
        lcall   SETEMPTY
        _gensub SETEMPTY
endm

_GenLP  <P_LPSTR>,<LP>,1
_GenLP  <P_LPSTR0>,<LP0>,1

P_CLPSTR macro   name,cch,opts
    _GenParm    <name>,4,<opts>
    if VLgen
    mov ax,_P_&name
    mov cx,_P_&name+2
    ifb <cch>
        mov     bx,-1
    else
        mov     bx,cch
    endif
    lcall   CLPSZ
        _gensub LPSZ
    endif
endm

P_CLPSTR0 macro   name,cch,opts
    _GenParm    <name>,4,<opts>
    if VLgen
    mov ax,_P_&name
    mov cx,_P_&name+2
    ifb <cch>
        mov     bx,-1
    else
        mov     bx,cch
    endif
    lcall   CLPSZ0
        _gensub LPSZ
    endif
endm

_GenLP  <P_LPVOID>,<LP>,1
_GenLP  <P_LPVOID0>,<LP0>,1
_GenLP  <P_CLPVOID>,<CLP>,1
_GenLP  <P_CLPVOID0>,<CLP0>,1

_GenLP  <P_LPBYTE>,<LP>,1
_GenLP  <P_LPBYTE0>,<LP0>,1
_GenLP  <P_CLPBYTE>,<CLP>,1
_GenLP  <P_CLPBYTE0>,<CLP0>,1

_GenLP  <P_LPINT>,<LP>,2
_GenLP  <P_LPINT0>,<LP0>,2
_GenLP  <P_CLPINT>,<CLP>,2
_GenLP  <P_CLPINT0>,<CLP0>,2

_GenLP  <P_LPWORD>,<LP>,2
_GenLP  <P_LPWORD0>,<LP0>,2
_GenLP  <P_CLPWORD>,<CLP>,2
_GenLP  <P_CLPWORD0>,<CLP0>,2

_GenLP  <P_LPBOOL>,<LP>,2
_GenLP  <P_LPBOOL0>,<LP0>,2
_GenLP  <P_CLPBOOL>,<CLP>,2
_GenLP  <P_CLPBOOL0>,<CLP0>,2

_GenLP  <P_LPLONG>,<LP>,4
_GenLP  <P_LPLONG0>,<LP0>,4
_GenLP  <P_CLPLONG>,<CLP>,4
_GenLP  <P_CLPLONG0>,<CLP0>,4

_GenLP  <P_LPDWORD>,<LP>,4
_GenLP  <P_LPDWORD0>,<LP0>,4
_GenLP  <P_CLPDWORD>,<CLP>,4
_GenLP  <P_CLPDWORD0>,<CLP0>,4

;=======================================================================
;
; Common USER types
;
STRUCT  <POINT>
F_int        x
F_int        y
ENDSTRUCT

_GenLP  <P_LPPOINT>,<LP>,%VLcbsPOINT
_GenLP  <P_LPPOINT0>,<LP0>,%VLcbsPOINT
_GenLP  <P_CLPPOINT>,<CLP>,%VLcbsPOINT
_GenLP  <P_CLPPOINT0>,<CLP0>,%VLcbsPOINT
P_POINT     equ <P_4>

STRUCT  <RECT>
F_int        left
F_int        top
F_int        right
F_int        bottom
ENDSTRUCT

_GenLP  <P_LPRECT>,<LP>,%VLcbsRECT
_GenLP  <P_LPRECT0>,<LP0>,%VLcbsRECT
_GenLP  <P_CLPRECT>,<CLP>,%VLcbsRECT
_GenLP  <P_CLPRECT0>,<CLP0>,%VLcbsRECT

;=======================================================================
;
; Common KERNEL types
;
P_GHANDLE   macro   h,opts
    _GenParm   <h>,2,<opts>
    if VLgen
    mov ax,_P_&h
    lcall   GHANDLE
        _gensub GHANDLE
    endif

endm

P_GHANDLE0  macro   h,opts
    _GenParm   <h>,2,<opts>
    if VLgen
    mov ax,_P_&h
    lcall   GHANDLE0
        _gensub GHANDLE
    endif
endm

P_GHANDLE32  macro   h,opts
    _GenParm   <h>,2,<opts>
    if VLgen
    mov ax,_P_&h
    test al, 0100b;
    jz   @F
    lcall   GHANDLE
    @@:
    endif
endm

P_HANDLE    equ <P_H>
P_HANDLE0   equ <P_H0>

P_ATOM      equ <P_H>

P_HINSTANCE equ <P_GHANDLE>
P_HINSTANCE0 equ <P_GHANDLE0>

P_HMODULE   equ <P_GHANDLE>
P_HMODULE0  equ <P_GHANDLE0>
P_HMODULE32 equ <P_GHANDLE32>

P_HTASK     equ <P_GHANDLE>
P_HTASK0    equ <P_GHANDLE0>

P_CLPSTRATOM macro   name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
    mov ax,_P_&name
    mov cx,_P_&name+2
    lcall   CLPSTRATOM
        _gensub LPSZ
    endif
endm

P_CLPSTRATOM0 macro name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
    mov ax,_P_&name
    mov cx,_P_&name+2
    lcall   CLPSTRATOM0
        _gensub LPSZ
    endif
endm

P_CLPSTRRSRC  equ <P_CLPSTRATOM>
P_CLPSTRRSRC0 equ <P_CLPSTRATOM0>

;---------------------------------------------------------------------------
; LAYER_EXPAND  lseg
;
; Expands per-segment validation boilerplate code into segment lseg
;
LAYER_EXPAND    macro   lseg
.list
.lall
    _SwitchSeg  &lseg,%VLseg

public  VStart&lseg
VStart&lseg:

EXTRA_EXPAND    lseg

;
; Handle validation
;
ifdef genH&lseg

public H&lseg
H&lseg:
    or  ax,ax
        jz      @F
    ret
@@:
        mov     bx,ERR_BAD_HANDLE
        jmp     short Inval_Param_&lseg

endif   ; genH&lseg

ifdef genGHANDLE&lseg

public GHANDLE0&lseg
GHANDLE0&lseg:
    or  ax,ax       ; accept NULL
    jz  GHexit&lseg

public GHANDLE&lseg
GHANDLE&lseg:
    test    al,0100b    ; Reject GDT selectors
    jnz      GHldt&lseg
                        ; not yet. Some WOW cursor/icon handles
    cmp  ax, 0f000h     ; look like GDT sels and are > 0xf000
    jae  GHexit&lseg
    jmp  GHerr&lseg     ; Reject GDT sels now.

GHldt&lseg:
    cmp ax,0ffffh   ; special case: -1 -> DS
    jz  GHexit&lseg
    lar dx,ax       ; is it a valid selector?
        jnz     GHerr&lseg
GHexit&lseg:
    ret

GHerr&lseg:
        mov     bx,ERR_BAD_GLOBAL_HANDLE
        jmp     short Inval_Param_&lseg

endif   ; genGHANDLE&lseg

ifdef genLPFN&lseg

;
; Function pointer validation
;
public LPFN0&lseg
LPFN0&lseg:
    mov bx,ax       ; Allow NULL
    or  bx,cx
    jz  LPFN_exit&lseg

public LPFN&lseg
LPFN&lseg:
beg_fault_trap  LPFNbad&lseg
        lar     bx,cx
        jnz     LPFNerr&lseg
        test    bh,8
        jz      LPFNerr&lseg
        mov     es,cx       ; validate pointer & offset
        mov     bx,ax
        mov     al,es:[bx]
end_fault_trap

ifdef DEBUG
;
; Make sure the function is exported by
; ensuring that the first instructions are NOT
; push ds, pop ax or mov ax,ds.
;
    mov bx,es:[bx]+2

        cmp     bx,0581eh                   ; Push ds, pop ax instructions?
        jz      LPFNerr&lseg                ; Yes, must be an error.
        cmp     bx,0d88ch                   ; Mov ax,ds instruction?
        jz      LPFNerr&lseg                ; No, we're ok, so jump ahead
endif   ; DEBUG

LPFN_exit&lseg:
    ret

LPFNbad&lseg:
    fault_fix_stack
LPFNerr&lseg:
        mov     bx,ERR_BAD_FUNC_PTR
        jmp     short Inval_Param_&lseg

endif   ; genLPFN&lseg

public Inval_Param_&lseg
Inval_Param_&lseg:
        pop     dx          ; convert near return addr to far
        push    cs
        push    dx
        jmp     HandleParamError

ifdef genLP&lseg

public LP0&lseg
LP0&lseg:
    or  ax,ax       ; if cx:ax == NULL, exit
    jnz @F
    jcxz    CLPexit&lseg
@@:
public LP&lseg
LP&lseg:
beg_fault_trap  CLPbad&lseg
        mov     es,cx
        or      bx,bx           ; cb == 0?
        jz      CLPexit&lseg    ; yes: just check selector
        dec     bx
        add     bx,ax
        jc      CLPbad1&lseg    ; check 16 bit overflow
        or      byte ptr es:[bx],0  ; check write permission, limit
end_fault_trap
        ret

public CLP0&lseg
CLP0&lseg:
        or      ax,ax           ; Accept ax:cx == 0
    jnz @F
    jcxz    CLPexit&lseg
@@:
public CLP&lseg
CLP&lseg:
beg_fault_trap  CLPbad&lseg
        mov     es,cx
        or      bx,bx           ; cb == 0?
        jz      CLPexit&lseg    ; yes: just check selector
        dec     bx
        add     bx,ax
        jc      CLPbad1&lseg    ; check 16 bit overflow
        mov     bl,es:[bx]      ; check read permission, limit
end_fault_trap

public CLPexit&lseg
CLPexit&lseg:
    ret

CLPbad&lseg:
    fault_fix_stack
CLPbad1&lseg:
        mov     bx,ERR_BAD_PTR
    jmp Inval_Param_&lseg

endif   ; genLP&lseg

ifdef   genLPBUF&lseg
public LPBUF0&lseg
LPBUF0&lseg:
    or  ax,ax       ; if cx:ax == NULL, exit
    jnz @F
    jcxz    LPBUFexit&lseg
@@:
public LPBUF&lseg
LPBUF&lseg:
beg_fault_trap  LPBUFbad&lseg
        mov     es,cx
        mov     cx, word ptr ss:[bx]    ; cb == 0?
        jcxz    LPBUFexit&lseg      ; yes: just check selector
    mov dx, bx
    mov bx, ax
        or      byte ptr es:[bx],0      ; check write permission, start
    mov bx, dx
LPBUFpast1&lseg:
        dec     cx
        add     cx,ax
    jnc @f          ; 16-bit overflow
    mov bx, 0ffffh
    mov cx, bx
        or      byte ptr es:[bx],0      ; check write permission, 64k-1
    jmp LPBUFov&lseg
@@:
    mov bx, cx
        or      byte ptr es:[bx],0      ; check write permission, end
    ret
end_fault_trap

public LPBUFexit&lseg
LPBUFexit&lseg:
    ret
LPBUFbad&lseg:
    mov bx, dx
    pop dx          ; fault ip
    add sp, 2           ; fault
    cmp dx, offset LPBUFpast1&lseg
    jb  LPBUFbad1&lseg

    mov dx, es
    lsl cx, dx
    jnz LPBUFbad1&lseg      ; should not occur, we have loaded es
LPBUFov&lseg:
    sub cx, ax          ; max legal cb
    inc cx
    mov word ptr ss:[bx], cx    ; fix cb passed by user on stack
    mov cx, es          ; HandleParamError prints cx:ax
        mov     bx,ERR_BAD_PTR or ERR_WARNING
    jmp Inval_Param_&lseg
LPBUFbad1&lseg:
    mov cx, es          ; HandleParamError prints cx:ax
        mov     bx,ERR_BAD_PTR
    jmp Inval_Param_&lseg
endif   ; genLPBUF&lseg

ifdef   genLPSZ&lseg

;
; cx:ax -> const pointer to z-terminated string or MAKEINTATOM atom.
;
public CLPSTRATOM0&lseg
CLPSTRATOM0&lseg:
        jcxz    CLPSZexit&lseg  ; If selector is NULL, then all is well.

public CLPSTRATOM&lseg
CLPSTRATOM&lseg:
    jcxz    @F      ; if selector == 0, then may be atom.
        mov     bx,256          ; max string length of 255 characters.
    jmp short CLPSZ&lseg
@@:
    or  ax,ax       ; offset == 0? if so, it's bogus
    jz  ErrorStrPtr&lseg
CLPSZexit&lseg:
    ret
;
; cx:ax => const pointer to zero-terminated string.
; bx    => Maximum string length (including zero terminator)
;
public CLPSZ0&lseg
CLPSZ0&lseg:
        mov     dx,ax
        or      dx,cx
        jz      CLPSZexit&lseg
public CLPSZ&lseg
CLPSZ&lseg:
        push    di              ; preserve these regs
        push    cx
        mov     dx,ax           ; preserve original ax in dx
beg_fault_trap  LPSZfault&lseg
        mov     es,cx
        mov     di,ax

    xor ax,ax
    mov cx,-1
    cld
    repnz   scasb
end_fault_trap
        neg     cx              ; cx = string length + 1
        dec     cx
        cmp     cx,bx           ; error if string length + 1 > cchMax

        pop     cx              ; restore regs before branching
        pop     di
        xchg    ax,dx

        ja      ErrorStrPtr&lseg ; jump if error
        ret

LPSZfault&lseg:
        fault_fix_stack
        pop     cx              ; restore regs
        pop     di
        xchg    ax,dx

public ErrorStrPtr&lseg
ErrorStrPtr&lseg:
    mov bx,ERR_BAD_STRING_PTR
    jmp Inval_Param_&lseg

endif   ; genLPSZ&lseg

ifdef   genSETEMPTY&lseg

public  SETEMPTY&lseg
SETEMPTY&lseg:
        jcxz    SETEMPTYexit&lseg   ; 0-length buffer: do nothing.
beg_fault_trap    SETEMPTYbad&lseg
        mov     es,dx
        mov     byte ptr es:[bx],0  ; jam in a zero terminator
end_fault_trap
SETEMPTYexit&lseg:
    xor ax,ax
    cwd
        ret

SETEMPTYbad&lseg:
        fault_fix_stack
        jmp     short SETEMPTYexit&lseg

endif   ; genSETEMPTY&lseg

public VEnd&lseg
VEnd&lseg:

sEnd    %VLseg
VLseg equ <>

endm    ;LAYER_EXPAND

endif   ;; IF1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the low-level
*	file handling and I/O functions.
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* function prototypes */

int _FAR_ _cdecl access(const char _FAR_ *, int);
int _FAR_ _cdecl chmod(const char _FAR_ *, int);
int _FAR_ _cdecl chsize(int, long);
int _FAR_ _cdecl close(int);
int _FAR_ _cdecl creat(const char _FAR_ *, int);
int _FAR_ _cdecl dup(int);
int _FAR_ _cdecl dup2(int, int);
int _FAR_ _cdecl eof(int);
long _FAR_ _cdecl filelength(int);
int _FAR_ _cdecl isatty(int);
int _FAR_ _cdecl locking(int, int, long);
long _FAR_ _cdecl lseek(int, long, int);
char _FAR_ * _FAR_ _cdecl mktemp(char _FAR_ *);
int _FAR_ _cdecl open(const char _FAR_ *, int, ...);
int _FAR_ _cdecl _pipe(int _FAR_ *, unsigned int, int);
int _FAR_ _cdecl read(int, void _FAR_ *, unsigned int);
int _FAR_ _cdecl remove(const char _FAR_ *);
int _FAR_ _cdecl rename(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl setmode(int, int);
int _FAR_ _cdecl sopen(const char _FAR_ *, int, int, ...);
long _FAR_ _cdecl tell(int);
int _FAR_ _cdecl umask(int);
int _FAR_ _cdecl unlink(const char _FAR_ *);
int _FAR_ _cdecl write(int, const void _FAR_ *, unsigned int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\lzexpand.h ===
/*****************************************************************************\
*                                                                             *
* lzexpand.h    Public interfaces for LZEXPAND.DLL.                           *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               NOTE: windows.h must be included first if LIB is NOT #defined *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with LZEXP?.LIB (default is for LZEXPAND.DLL)
*                 NOTE: Not compatible with windows.h if LIB is #defined
*
\*****************************************************************************/

#ifndef _INC_LZEXPAND
#define _INC_LZEXPAND

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#define LZAPI       _pascal

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#endif  /* WINAPI */

#else   /* LIB */

#define LZAPI       _far _pascal

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/****** Error return codes ***************************************************/

#define LZERROR_BADINHANDLE   (-1)  /* invalid input handle */
#define LZERROR_BADOUTHANDLE  (-2)  /* invalid output handle */
#define LZERROR_READ          (-3)  /* corrupt compressed file format */
#define LZERROR_WRITE         (-4)  /* out of space for output file */
#define LZERROR_GLOBALLOC     (-5)  /* insufficient memory for LZFile struct */
#define LZERROR_GLOBLOCK      (-6)  /* bad global handle */
#define LZERROR_BADVALUE      (-7)  /* input parameter out of range */
#define LZERROR_UNKNOWNALG    (-8)  /* compression algorithm not recognized */

/****** Public functions *****************************************************/

int     LZAPI LZStart(void);
void    LZAPI LZDone(void);
LONG    LZAPI CopyLZFile(HFILE, HFILE);
LONG    LZAPI LZCopy(HFILE, HFILE);
HFILE   LZAPI LZInit(HFILE);
int     LZAPI GetExpandedName(LPCSTR, LPSTR);
HFILE   LZAPI LZOpenFile(LPCSTR, OFSTRUCT FAR*, UINT);
LONG    LZAPI LZSeek(HFILE, LONG, int);
int     LZAPI LZRead(HFILE, void FAR*, int);
void    LZAPI LZClose(HFILE);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif  /* _INC_LZEXPAND */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\logerror.inc ===
;---------------------------------------------------------------------------
; Added for Win 31 style Parameter Validation.
;
; Note: This file was copied AS IT IS from Win 31 golden sources and MUST
;	NOT be changed unless it changes in Win 31.
;
; History : Added on 14-April-92 by Chandan Chauhan (ChandanC)
;
;---------------------------------------------------------------------------


;/****** LogParamError/LogError values */

;/* Error modifier bits */

ERR_WARNING             equ 08000h
ERR_PARAM               equ 04000h

;/* Internal error value masks */       ;/* ;Internal */
ERR_TYPE_MASK           equ 00fffh      ;/* ;Internal */
ERR_FLAGS_MASK          equ 0c000h      ;/* ;Internal */
                                        ;/* ;Internal */
ERR_SIZE_MASK           equ 03000h
ERR_SIZE_SHIFT          equ 12
ERR_BYTE                equ 01000h
ERR_WORD                equ 02000h
ERR_DWORD               equ 03000h

;/****** LogParamError() values */

;/* Generic parameter values */
ERR_BAD_VALUE           equ 06001h
ERR_BAD_FLAGS           equ 06002h
ERR_BAD_INDEX           equ 06003h
ERR_BAD_DVALUE          equ 07004h
ERR_BAD_DFLAGS          equ 07005h
ERR_BAD_DINDEX          equ 07006h
ERR_BAD_PTR             equ 07007h
ERR_BAD_FUNC_PTR        equ 07008h
ERR_BAD_SELECTOR        equ 06009h
ERR_BAD_STRING_PTR      equ 0700ah
ERR_BAD_HANDLE          equ 0600bh

;/* KERNEL parameter errors */
ERR_BAD_HINSTANCE       equ 06020h
ERR_BAD_HMODULE         equ 06021h
ERR_BAD_GLOBAL_HANDLE   equ 06022h
ERR_BAD_LOCAL_HANDLE    equ 06023h
ERR_BAD_ATOM            equ 06024h
ERR_BAD_HFILE           equ 06025h

;/* USER parameter errors */
ERR_BAD_HWND            equ 06040h
ERR_BAD_HMENU           equ 06041h
ERR_BAD_HCURSOR         equ 06042h
ERR_BAD_HICON           equ 06043h
ERR_BAD_HDWP            equ 06044h
ERR_BAD_CID             equ 06045h
ERR_BAD_HDRVR           equ 06046h

;/* GDI parameter errors */
ERR_BAD_COORDS          equ 07060h
ERR_BAD_GDI_OBJECT      equ 06061h
ERR_BAD_HDC             equ 06062h
ERR_BAD_HPEN            equ 06063h
ERR_BAD_HFONT           equ 06064h
ERR_BAD_HBRUSH          equ 06065h
ERR_BAD_HBITMAP         equ 06066h
ERR_BAD_HRGN            equ 06067h
ERR_BAD_HPALETTE        equ 06068h
ERR_BAD_HMETAFILE       equ 06069h

;/* Debug fill constants */

DBGFILL_ALLOC           equ 0fdh
DBGFILL_FREE            equ 0fbh
DBGFILL_BUFFER          equ 0f9h
DBGFILL_STACK           equ 0f7h

;/**** LogError() values */

;/* KERNEL errors */
ERR_GALLOC              equ 00001h  ;/* GlobalAlloc Failed */
ERR_GREALLOC            equ 00002h  ;/* GlobalReAlloc Failed */
ERR_GLOCK               equ 00003h  ;/* GlobalLock Failed */
ERR_LALLOC              equ 00004h  ;/* LocalAlloc Failed */
ERR_LREALLOC            equ 00005h  ;/* LocalReAlloc Failed */
ERR_LLOCK               equ 00006h  ;/* LocalLock Failed */
ERR_ALLOCRES            equ 00007h  ;/* AllocResource Failed */
ERR_LOCKRES             equ 00008h  ;/* LockResource Failed */
ERR_LOADMODULE          equ 00009h  ;/* LoadModule failed  */

;/* USER errors */
ERR_CREATEDLG           equ 00040h  ;/* Create Dlg failure due to LoadMenu failure */
ERR_CREATEDLG2          equ 00041h  ;/* Create Dlg failure due to CreateWindow Failure */
ERR_REGISTERCLASS       equ 00042h  ;/* RegisterClass failure due to Class already registered */
ERR_DCBUSY              equ 00043h  ;/* DC Cache is full */
ERR_CREATEWND           equ 00044h  ;/* Create Wnd failed due to class not found */
ERR_STRUCEXTRA          equ 00045h  ;/* Unallocated Extra space is used */
ERR_LOADSTR             equ 00046h  ;/* LoadString() failed */
ERR_LOADMENU            equ 00047h  ;/* LoadMenu Failed     */
ERR_NESTEDBEGINPAINT    equ 00048h  ;/* Nested BeginPaint() calls */
ERR_BADINDEX            equ 00049h  ;/* Bad index to Get/Set Class/Window Word/Long */
ERR_CREATEMENU          equ 0004ah  ;/* Error creating menu */

;/* GDI errors */
ERR_CREATEDC            equ 00080h  ;/* CreateDC/CreateIC etc., failure */
ERR_CREATEMETA          equ 00081h  ;/* CreateMetafile failure */
ERR_DELOBJSELECTED      equ 00082h  ;/* Bitmap being deleted is selected into DC */
ERR_SELBITMAP           equ 00083h  ;/* Bitmap being selected is already selected elsewhere */

;****** DebugOutput definitions

; [Windows] DebugOptions field values

DBO_CHECKHEAP       equ 00001h

DBO_BUFFERFILL      equ 00004h
DBO_COMPAT          equ 00008h
DBO_DISABLEGPTRAPPING equ 00010h
DBO_CHECKFREE       equ 00020h
DBO_RIP_STACK	    equ 00040h

DBO_SILENT          equ 08000h

DBO_PARAMBREAK      equ 00000h  ; Obsolete: was 04000h
DBO_TRACEBREAK      equ 02000h
DBO_WARNINGBREAK    equ 01000h
DBO_NOERRORBREAK    equ 00800h
DBO_NOFATALBREAK    equ 00400h
DBO_TRACEON         equ 00000h  ; Obsolete: was 00200h
DBO_INT3BREAK       equ 00100h

; flags values

DBF_TRACE           equ 00000h
DBF_WARNING         equ 04000h
DBF_ERROR           equ 08000h
DBF_FATAL           equ 0c000h

DBF_SEVMASK         equ 0c000h
DBF_FILTERMASK      equ 03fffh

; [Windows] DebugFilter and flags values

DBF_INTERNAL        equ 00000h  ; Obsolete: was 02000h
DBF_KERNEL          equ 01000h
DBF_KRN_MEMMAN      equ 00001h
DBF_KRN_LOADMODULE  equ 00002h
DBF_KRN_SEGMENTLOAD equ 00004h
DBF_USER            equ 00800h
DBF_GDI             equ 00400h
DBF_COMPAT          equ 00000h  ; Obsolete: was 00200h
DBF_LOGERROR        equ 00000h  ; Obsolete: was 00100h
DBF_PARAMERROR      equ 00000h  ; Obsolete: was 00080h
DBF_MMSYSTEM        equ 00040h
DBF_PENWIN          equ 00020h
DBF_APPLICATION     equ 00010h
DBF_DRIVER          equ 00008h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\logerror.h ===
/****************************************************************************\
 *
 * LogError() and LogParamError() definitions
 *
 * Excerpted from WINDOWS.H, since that file isn't included by GDI & KERNEL.
\****************************************************************************/

/* If windows.h already included, don't redefine any of this. */
/* Include the stuff if NOLOGERROR was defined, though. */
#if (!defined(_INC_WINDOWS) || defined(NOLOGERROR))

#ifdef WINAPI
void WINAPI LogError(WORD err, void FAR* lpInfo);
void WINAPI LogParamError(WORD err, FARPROC lpfn, void FAR* param);
#endif

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING		0x8000
#define ERR_PARAM		0x4000

/* Internal error value masks */	    /* ;Internal */
#define ERR_TYPE_MASK		0x0fff	    /* ;Internal */
#define ERR_FLAGS_MASK		0xc000	    /* ;Internal */
					    /* ;Internal */
#define ERR_SIZE_MASK		0x3000
#define ERR_SIZE_SHIFT		12
#define ERR_BYTE                0x1000
#define ERR_WORD                0x2000
#define ERR_DWORD               0x3000

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE           0x6001
#define ERR_BAD_FLAGS           0x6002
#define ERR_BAD_INDEX           0x6003
#define ERR_BAD_DVALUE		0x7004
#define ERR_BAD_DFLAGS		0x7005
#define ERR_BAD_DINDEX		0x7006
#define ERR_BAD_PTR		0x7007
#define ERR_BAD_FUNC_PTR	0x7008
#define ERR_BAD_SELECTOR        0x6009
#define ERR_BAD_STRING_PTR	0x700a
#define ERR_BAD_HANDLE          0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS		0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069

/* Debug fill constants */

#define DBGFILL_ALLOC		0xfd
#define DBGFILL_FREE		0xfb
#define DBGFILL_BUFFER		0xf9
#define DBGFILL_STACK		0xf7

/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001  /* GlobalAlloc Failed */
#define ERR_GREALLOC            0x0002  /* GlobalReAlloc Failed */
#define ERR_GLOCK               0x0003  /* GlobalLock Failed */
#define ERR_LALLOC              0x0004  /* LocalAlloc Failed */
#define ERR_LREALLOC            0x0005  /* LocalReAlloc Failed */
#define ERR_LLOCK               0x0006  /* LocalLock Failed */
#define ERR_ALLOCRES            0x0007  /* AllocResource Failed */
#define ERR_LOCKRES             0x0008  /* LockResource Failed */
#define ERR_LOADMODULE          0x0009  /* LoadModule failed  */

/* USER errors */
#define ERR_CREATEDLG           0x0040  /* Create Dlg failure due to LoadMenu failure */
#define ERR_CREATEDLG2          0x0041  /* Create Dlg failure due to CreateWindow Failure */
#define ERR_REGISTERCLASS       0x0042  /* RegisterClass failure due to Class already registered */
#define ERR_DCBUSY              0x0043  /* DC Cache is full */
#define ERR_CREATEWND           0x0044  /* Create Wnd failed due to class not found */
#define ERR_STRUCEXTRA          0x0045  /* Unallocated Extra space is used */
#define ERR_LOADSTR             0x0046  /* LoadString() failed */
#define ERR_LOADMENU            0x0047  /* LoadMenu Failed     */
#define ERR_NESTEDBEGINPAINT    0x0048  /* Nested BeginPaint() calls */
#define ERR_BADINDEX            0x0049  /* Bad index to Get/Set Class/Window Word/Long */
#define ERR_CREATEMENU          0x004a  /* Error creating menu */

/* GDI errors */
#define ERR_CREATEDC            0x0080  /* CreateDC/CreateIC etc., failure */
#define ERR_CREATEMETA          0x0081  /* CreateMetafile failure */
#define ERR_DELOBJSELECTED      0x0082  /* Bitmap being deleted is selected into DC */
#define ERR_SELBITMAP           0x0083  /* Bitmap being selected is already selected elsewhere */

/* Debugging information support (DEBUG SYSTEM ONLY) */

#ifdef WINAPI

typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
} WINDEBUGINFO;

BOOL WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);
void WINAPI DebugFillBuffer(void FAR* lpb, UINT cb);

#endif

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS         0x0001
#define WDI_FILTER          0x0002
#define WDI_ALLOCBREAK      0x0004
#define WDI_VALID           0x0007  /* ;Internal */

/* dwOptions values */
#define DBO_CHECKHEAP       0x0001
#define DBO_FREEFILL        0x0002
#define DBO_BUFFERFILL      0x0004
#define DBO_COMPAT          0x0008
#define DBO_DISABLEGPTRAPPING 0x0010
#define DBO_CHECKFREE       0x0020
#define DBO_RIP_STACK	    0x0040

#define DBO_SILENT          0x8000

#define DBO_PARAMBREAK      0x0000  /* ;Internal *//* Obsolete: was 0x4000 */
#define DBO_TRACEBREAK      0x2000
#define DBO_WARNINGBREAK    0x1000
#define DBO_NOERRORBREAK    0x0800
#define DBO_NOFATALBREAK    0x0400
#define DBO_TRACEON         0x0000  /* ;Internal *//* Obsolete: was 0x0200 */
#define DBO_INT3BREAK       0x0100

/* dwFilter values */
#define DBF_TRACE           0x0000
#define DBF_WARNING         0x4000
#define DBF_ERROR           0x8000
#define DBF_FATAL           0xc000
#define DBF_SEVMASK         0xc000  /* ;Internal */
#define DBF_FILTERMASK      0x3fff  /* ;Internal */
#define DBF_INTERNAL        0x0000  /* ;Internal *//* Obsolete: was 0x2000 */
#define DBF_KERNEL          0x1000
#define DBF_KRN_MEMMAN      0x0001
#define DBF_KRN_LOADMODULE  0x0002
#define DBF_KRN_SEGMENTLOAD 0x0004
#define DBF_USER            0x0800
#define DBF_GDI             0x0400
#define DBF_COMPAT          0x0000  /* ;Internal *//* Obsolete: was 0x0200 */
#define DBF_LOGERROR        0x0000  /* ;Internal *//* Obsolete: was 0x0100 */
#define DBF_PARAMERROR      0x0000  /* ;Internal *//* Obsolete: was 0x0080 */
#define DBF_MMSYSTEM        0x0040
#define DBF_PENWIN          0x0020
#define DBF_APPLICATION     0x0010
#define DBF_DRIVER          0x0008

#endif  /* _INC_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for the
*	buffer (memory) manipulation routines.
*	[System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


/* function prototypes */

void _FAR_ * _FAR_ _cdecl memccpy(void _FAR_ *, const void _FAR_ *,
	int, unsigned int);
void _FAR_ * _FAR_ _cdecl memchr(const void _FAR_ *, int, size_t);
int _FAR_ _cdecl memcmp(const void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memcpy(void _FAR_ *, const void _FAR_ *,
	size_t);
int _FAR_ _cdecl memicmp(const void _FAR_ *, const void _FAR_ *,
	unsigned int);
void _FAR_ * _FAR_ _cdecl memset(void _FAR_ *, int, size_t);
void _FAR_ _cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);


/* model independent function prototypes */

void _far * _far _cdecl _fmemccpy(void _far *, const void _far *,
	int, unsigned int);
void _far * _far _cdecl _fmemchr(const void _far *, int, size_t);
int _far _cdecl _fmemcmp(const void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemcpy(void _far *, const void _far *,
	size_t);
int _far _cdecl _fmemicmp(const void _far *, const void _far *,
	unsigned int);
void _far * _far _cdecl _fmemset(void _far *, int, size_t);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\msdefine.h ===
/***************************************************************************
  *
  * File Name: MSDEFINE.H
  *
  * Copyright Hewlett-Packard Company 1997 
  * All rights reserved.
  *
  * 11311 Chinden Blvd.
  * Boise, Idaho  83714
  *
  *   
  * Description: contains definitions for WPNPINST.DLL found in the MS build
  * tree.  Should not need to be checked into MS tree.
  *
  * Author:  Garth Schmeling
  *        
  * Modification history:
  *
  * Date		Initials		Change description
  *
  * 10-10-97	GFS				Initial checkin
  *
  *
  *
  ***************************************************************************/

// definitions found in MS Win9x build system

#define SZMESSAGESERVERCLASS			"Windows 32-bit VxD Message Server"
#define PROCNAME_EXTDEVMODEPROPSHEET	"EXTDEVICEMODEPROPSHEET"
#define PROCNAME_EXTDEVICEMODE			"EXTDEVICEMODE"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\mmddk.inc ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   MMDDK.INC - Multimedia assembly language structures & constants
;               for the Development Kit
;
;   Copyright (c) Microsoft Corporation 1990. All rights reserved
;
;
;   If defined, the following flags inhibit inclusion of the indicated items:
;
;        NOTIMERDEV        - The Timer Device
;        NOJOYDEV          - The Joystick Device
; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;     If defined, the following flags inhibit inclusion
;     of the indicated items:
; 
;         MMNOMIDIDEV         - MIDI support
;         MMNOWAVEDEV         - Waveform support
;         MMNOAUXDEV          - Auxiliary output support
;         MMNOTIMERDEV        - Timer support
;         MMNOJOYDEV          - Joystick support
;         MMNOMCIDEV          - MCI support
;         MMNOTASKDEV         - Task support
;

OFFSEL	STRUC
Off	dw  ?
Sel	dw  ?
OFFSEL	ENDS

LOHI	STRUC
Lo	dw  ?
Hi	dw  ?
LOHI	ENDS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                      Helper functions for drivers
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DCB_NOSWITCH    equ   0008h           ; don't switch stacks for callback
DCB_TYPEMASK    equ   0007h           ; callback type mask
DCB_NULL        equ   0000h           ; unknown callback type

; flags for wFlags parameter of DriverCallback()
DCB_WINDOW     equ    0001h           ; dwCallback is a HWND
DCB_TASK       equ    0002h           ; dwCallback is a HTASK
DCB_FUNCTION   equ    0003h           ; dwCallback is a FARPROC

; device ID for 386 AUTODMA VxD 
VADMAD_Device_ID    equ    0444h

ifndef	MMNOWAVEDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
;                      Waveform device driver support
; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; maximum number of wave device drivers loaded
MAXWAVEDRIVERS equ    10


; waveform input and output device open information structure
WAVEOPENDESC struc
    wod_hWave         dw    ?        ; handle
    wod_lpFormat      dd    ?        ; format of wave data
    wod_dwCallback    dd    ?        ; callback
    wod_dwInstance    dd    ?        ; app's private instance information
WAVEOPENDESC ends

;  message sent by mmsystem to wodMessage(), widMessage(), modMessage(),
;  and midMessage() when it initializes the wave and midi drivers 

DRVM_USER             equ    4000h
DRVM_INIT             equ    100
WODM_INIT             equ    DRVM_INIT
WIDM_INIT             equ    DRVM_INIT
MODM_INIT             equ    DRVM_INIT
MIDM_INIT             equ    DRVM_INIT
AUXM_INIT             equ    DRVM_INIT

; messages sent to wodMessage() entry-point function
WODM_GETNUMDEVS       equ    3
WODM_GETDEVCAPS       equ    4
WODM_OPEN             equ    5
WODM_CLOSE            equ    6
WODM_PREPARE          equ    7
WODM_UNPREPARE        equ    8
WODM_WRITE            equ    9
WODM_PAUSE            equ    10
WODM_RESTART          equ    11
WODM_RESET            equ    12 
WODM_GETPOS           equ    13
WODM_GETPITCH         equ    14
WODM_SETPITCH         equ    15
WODM_GETVOLUME        equ    16
WODM_SETVOLUME        equ    17
WODM_GETPLAYBACKRATE  equ    18
WODM_SETPLAYBACKRATE  equ    19
WODM_BREAKLOOP        equ    20

; messages sent to widMessage() entry-point function
WIDM_GETNUMDEVS  equ    50
WIDM_GETDEVCAPS  equ    51
WIDM_OPEN        equ    52
WIDM_CLOSE       equ    53
WIDM_PREPARE     equ    54
WIDM_UNPREPARE   equ    55
WIDM_ADDBUFFER   equ    56
WIDM_START       equ    57
WIDM_STOP        equ    58
WIDM_RESET       equ    59
WIDM_GETPOS      equ    60

endif	;ifndef MMNOWAVEDEV


ifndef	MMNOMIDIDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                         MIDI device driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; maximum number of MIDI device drivers loaded
MAXMIDIDRIVERS equ    10

; MIDI input and output device open information structure
MIDIOPENDESC struc
    mod_hMidi         dw    ?        ; handle
    mod_dwCallback    dd    ?        ; callback
    mod_dwInstance    dd    ?        ; app's private instance information
MIDIOPENDESC ends

; messages sent to modMessage() entry-point function
MODM_GETNUMDEVS     equ    1
MODM_GETDEVCAPS     equ    2
MODM_OPEN           equ    3
MODM_CLOSE          equ    4
MODM_PREPARE        equ    5
MODM_UNPREPARE      equ    6
MODM_DATA           equ    7
MODM_LONGDATA       equ    8
MODM_RESET          equ    9
MODM_GETVOLUME      equ    10
MODM_SETVOLUME      equ    11
MODM_CACHEPATCHES       equ    12      
MODM_CACHEDRUMPATCHES   equ    13     

; messages sent to midMessage() entry-point function
MIDM_GETNUMDEVS  equ    53
MIDM_GETDEVCAPS  equ    54
MIDM_OPEN        equ    55
MIDM_CLOSE       equ    56
MIDM_PREPARE     equ    57
MIDM_UNPREPARE   equ    58
MIDM_ADDBUFFER   equ    59
MIDM_START       equ    60
MIDM_STOP        equ    61
MIDM_RESET       equ    62

endif	;ifndef MMNOMIDIDEV


ifndef	MMNOAUXDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                   Auxiliary audio device driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; maximum number of auxiliary device drivers loaded
MAXAUXDRIVERS equ    10

; messages sent to auxMessage() entry-point function
AUXDM_GETNUMDEVS    equ    3
AUXDM_GETDEVCAPS    equ    4
AUXDM_GETVOLUME     equ    5
AUXDM_SETVOLUME     equ    6

endif	;ifndef MMNOAUXDEV


ifndef	MMNOTIMERDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Timer device driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TIMEREVENT struc
    te_wDelay         dw    ?     ; delay required
    te_wResolution    dw    ?     ; resolution required
    te_lpFunction     dd    ?     ; ptr to callback function
    te_dwUser         dd    ?     ; user DWORD
    te_wFlags         dw    ?     ; defines how to program event
TIMEREVENT ends

; messages sent to tddMessage() function
TDD_KILLTIMEREVENT  equ    DRV_RESERVED+0  ; indices into a table of
TDD_SETTIMEREVENT   equ    DRV_RESERVED+4  ; functions; thus offset by
TDD_GETSYSTEMTIME   equ    DRV_RESERVED+8  ; four each time...
TDD_GETDEVCAPS      equ    DRV_RESERVED+12 ; room for future expansion
TDD_BEGINMINPERIOD  equ    DRV_RESERVED+16 ; room for future expansion
TDD_ENDMINPERIOD    equ    DRV_RESERVED+20 ; room for future expansion

endif	;ifndef MMNOTIMERDEV


ifndef	MMNOJOYDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                      Joystick device driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; joystick calibration info structure
JOYCALIBRATE struc
    jcal_wXbase     dw    ?
    jcal_wXdelta    dw    ?
    jcal_wYbase     dw    ?
    jcal_wYdelta    dw    ?
    jcal_wZbase     dw    ?
    jcal_wZdelta    dw    ?
JOYCALIBRATE ends

; messages sent to joystick driver's DriverProc() function
JDD_GETNUMDEVS      equ    DRV_RESERVED+0001h
JDD_GETDEVCAPS      equ    DRV_RESERVED+0002h
JDD_GETPOS          equ    DRV_RESERVED+0101h
JDD_SETCALIBRATION  equ    DRV_RESERVED+0102h

endif	;ifndef MMNOJOYDEV


ifndef	MMNOMCIDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       MCI device driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; internal MCI messages
MCI_OPEN_DRIVER             equ    0801h
MCI_CLOSE_DRIVER            equ    0802h

MAKEMCIRESOURCE MACRO a,b
        mov     ax,a
        mov     dx,b
        ENDM

; string return values only used with MAKEMCIRESOURCE
MCI_FALSE                       equ    (MCI_STRING_OFFSET + 19)
MCI_TRUE                        equ    (MCI_STRING_OFFSET + 20)

; resource string return values
MCI_FORMAT_RETURN_BASE          equ    MCI_FORMAT_MILLISECONDS_S
MCI_FORMAT_MILLISECONDS_S       equ    (MCI_STRING_OFFSET + 21)
MCI_FORMAT_HMS_S                equ    (MCI_STRING_OFFSET + 22)
MCI_FORMAT_MSF_S                equ    (MCI_STRING_OFFSET + 23)
MCI_FORMAT_FRAMES_S             equ    (MCI_STRING_OFFSET + 24)
MCI_FORMAT_SMPTE_24_S           equ    (MCI_STRING_OFFSET + 25)
MCI_FORMAT_SMPTE_25_S           equ    (MCI_STRING_OFFSET + 26)
MCI_FORMAT_SMPTE_30_S           equ    (MCI_STRING_OFFSET + 27)
MCI_FORMAT_SMPTE_30DROP_S       equ    (MCI_STRING_OFFSET + 28)
MCI_FORMAT_BYTES_S              equ    (MCI_STRING_OFFSET + 29)
MCI_FORMAT_SAMPLES_S            equ    (MCI_STRING_OFFSET + 30)
MCI_FORMAT_TMSF_S               equ    (MCI_STRING_OFFSET + 31)

MCI_VD_FORMAT_TRACK_S           equ    (MCI_VD_OFFSET + 5)

WAVE_FORMAT_PCM_S               equ    (MCI_WAVE_OFFSET + 0)
WAVE_MAPPER_S                   equ    (MCI_WAVE_OFFSET + 1)

MCI_SEQ_MAPPER_S                equ    (MCI_SEQ_OFFSET + 5)
MCI_SEQ_FILE_S                  equ    (MCI_SEQ_OFFSET + 6)
MCI_SEQ_MIDI_S                  equ    (MCI_SEQ_OFFSET + 7)
MCI_SEQ_SMPTE_S                 equ    (MCI_SEQ_OFFSET + 8)
MCI_SEQ_FORMAT_SONGPTR_S        equ    (MCI_SEQ_OFFSET + 9)
MCI_SEQ_NONE_S                  equ    (MCI_SEQ_OFFSET + 10)
MIDIMAPPER_S                    equ    (MCI_SEQ_OFFSET + 11)

; parameters for internal version of MCI_OPEN message sent from
; mciOpenDevice() to the driver
MCI_OPEN_DRIVER_PARMS struc
    mciodrv_wDeviceID           dw    ? ; device ID
    mciodrv_lpstrParams         dw    ? ; parameter string for entry in SYSTEM.INI
    mciodrv_wCustomCommandTable dw    ? ; custom command table (0FFFFh if none)
                                        ; filled in by the driver
    mciodrv_wType               dw    ? ; driver type filled in by the driver
MCI_OPEN_DRIVER_PARMS ends

; maximum length of an MCI device type
MCI_MAX_DEVICE_TYPE_LENGTH equ    80

; flags for mciSendCommandInternal() which direct mciSendString() how to
; interpret the return value
MCI_RESOURCE_RETURNED       equ    00010000h  ; resource ID
MCI_COLONIZED3_RETURN       equ    00020000h  ; colonized ID, 3 bytes data
MCI_COLONIZED4_RETURN       equ    00040000h  ; colonized ID, 4 bytes data
MCI_INTEGER_RETURNED        equ    00080000h  ; integer conversion needed
MCI_RESOURCE_DRIVER         equ    00100000h  ; driver owns returned resource

; invalid command table ID
MCI_NO_COMMAND_TABLE    equ    0FFFFh

; command table information type tags
MCI_COMMAND_HEAD        equ    0
MCI_STRING              equ    1
MCI_INTEGER             equ    2
MCI_END_COMMAND         equ    3
MCI_RETURN              equ    4
MCI_FLAG                equ    5
MCI_END_COMMAND_LIST    equ    6
MCI_RECT                equ    7
MCI_CONSTANT            equ    8
MCI_END_CONSTANT        equ    9

endif	;ifndef MMNOMCIDEV


ifndef	MMNOTASKDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                              Task support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; error return values
TASKERR_NOTASKSUPPORT equ    1
TASKERR_OUTOFMEMORY   equ    2

endif	;ifndef MMNOTASKDEV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\mmddk.h ===
/****************************************************************************/
/*                                                                          */
/*      MMDDK.H - Include file for Multimedia Device Development Kit        */
/*                                                                          */
/*      Note: You must include the WINDOWS.H and MMSYSTEM.H header files    */
/*            before including this file.                                   */
/*                                                                          */
/*      Copyright (c) 1990-1991, Microsoft Corp.  All rights reserved.      */
/*                                                                          */
/****************************************************************************/


/*    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *        MMNOMIDIDEV         - MIDI support
 *        MMNOWAVEDEV         - Waveform support
 *        MMNOAUXDEV          - Auxiliary output support
 *        MMNOTIMERDEV        - Timer support
 *        MMNOJOYDEV          - Joystick support
 *        MMNOMCIDEV          - MCI support
 *        MMNOTASKDEV         - Task support
 */
#ifdef  NOMIDIDEV               /* ;Internal */
#define MMNOMIDIDEV             /* ;Internal */
#endif  /*ifdef NOMIDIDEV */    /* ;Internal */
#ifdef  NOWAVEDEV               /* ;Internal */
#define MMNOWAVEDEV             /* ;Internal */
#endif  /*ifdef NOWAVEDEV */    /* ;Internal */
#ifdef  NOAUXDEV                /* ;Internal */
#define MMNOAUXDEV              /* ;Internal */
#endif  /*ifdef NOAUXDEV */     /* ;Internal */
#ifdef  NOTIMERDEV              /* ;Internal */
#define MMNOTIMERDEV            /* ;Internal */
#endif  /*ifdef NOTIMERDEV */   /* ;Internal */
#ifdef  NOJOYDEV                /* ;Internal */
#define MMNOJOYDEV              /* ;Internal */
#endif  /*ifdef NOJOYDEV */     /* ;Internal */
#ifdef  NOMCIDEV                /* ;Internal */
#define MMNOMCIDEV              /* ;Internal */
#endif  /*ifdef NOMCIDEV */     /* ;Internal */
#ifdef  NOTASKDEV               /* ;Internal */
#define MMNOTASKDEV             /* ;Internal */
#endif  /*ifdef NOTASKDEV*/     /* ;Internal */

#ifndef _INC_MMDDK
#define _INC_MMDDK   /* #defined if mmddk.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/***************************************************************************

                       Helper functions for drivers

***************************************************************************/

#define DCB_NOSWITCH   0x0008           /* don't switch stacks for callback */
#define DCB_TYPEMASK   0x0007           /* callback type mask */
#define DCB_NULL       0x0000           /* unknown callback type */

/* flags for wFlags parameter of DriverCallback() */
#define DCB_WINDOW     0x0001           /* dwCallback is a HWND */
#define DCB_TASK       0x0002           /* dwCallback is a HTASK */
#define DCB_FUNCTION   0x0003           /* dwCallback is a FARPROC */

BOOL WINAPI DriverCallback(DWORD dwCallback, UINT uFlags,
    HANDLE hDevice, UINT uMessage, DWORD dwUser, DWORD dwParam1, DWORD dwParam2);
void WINAPI StackEnter(void);
void WINAPI StackLeave(void);

/* generic prototype for audio device driver entry-point functions */
/* midMessage(), modMessage(), widMessage(), wodMessage(), auxMessage() */
typedef DWORD (CALLBACK SOUNDDEVMSGPROC)(UINT uDeviceID, UINT uMessage,
    DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);
typedef SOUNDDEVMSGPROC FAR *LPSOUNDDEVMSGPROC;

/* device ID for 386 AUTODMA VxD */
#define VADMAD_Device_ID    0X0444

#ifndef MMNOWAVEDEV
/****************************************************************************
 
                       Waveform device driver support
 
****************************************************************************/

/* maximum number of wave device drivers loaded */
#define MAXWAVEDRIVERS 10


/* waveform input and output device open information structure */
typedef struct waveopendesc_tag {
    HWAVE          hWave;             /* handle */
    const WAVEFORMAT FAR* lpFormat;   /* format of wave data */
    DWORD          dwCallback;        /* callback */
    DWORD          dwInstance;        /* app's private instance information */
} WAVEOPENDESC;
typedef WAVEOPENDESC FAR *LPWAVEOPENDESC;

#define DRVM_USER             0x4000

/* 
 * Message sent by mmsystem to wodMessage(), widMessage(), modMessage(),
 * and midMessage() when it initializes the wave and midi drivers 
 */

#define DRVM_INIT             100
#define WODM_INIT             DRVM_INIT
#define WIDM_INIT             DRVM_INIT
#define MODM_INIT             DRVM_INIT
#define MIDM_INIT             DRVM_INIT
#define AUXM_INIT             DRVM_INIT

/* messages sent to wodMessage() entry-point function */
#define WODM_GETNUMDEVS       3
#define WODM_GETDEVCAPS       4
#define WODM_OPEN             5
#define WODM_CLOSE            6
#define WODM_PREPARE          7
#define WODM_UNPREPARE        8
#define WODM_WRITE            9
#define WODM_PAUSE            10
#define WODM_RESTART          11
#define WODM_RESET            12 
#define WODM_GETPOS           13
#define WODM_GETPITCH         14
#define WODM_SETPITCH         15
#define WODM_GETVOLUME        16
#define WODM_SETVOLUME        17
#define WODM_GETPLAYBACKRATE  18
#define WODM_SETPLAYBACKRATE  19
#define WODM_BREAKLOOP        20

/* messages sent to widMessage() entry-point function */
#define WIDM_GETNUMDEVS  50
#define WIDM_GETDEVCAPS  51
#define WIDM_OPEN        52
#define WIDM_CLOSE       53
#define WIDM_PREPARE     54
#define WIDM_UNPREPARE   55
#define WIDM_ADDBUFFER   56
#define WIDM_START       57
#define WIDM_STOP        58
#define WIDM_RESET       59
#define WIDM_GETPOS      60

#endif  /*ifndef MMNOWAVEDEV */


#ifndef MMNOMIDIDEV
/****************************************************************************

                          MIDI device driver support

****************************************************************************/

/* maximum number of MIDI device drivers loaded */
#define MAXMIDIDRIVERS 10

/* MIDI input and output device open information structure */
typedef struct midiopendesc_tag {
    HMIDI          hMidi;             /* handle */
    DWORD          dwCallback;        /* callback */
    DWORD          dwInstance;        /* app's private instance information */
} MIDIOPENDESC;
typedef MIDIOPENDESC FAR *LPMIDIOPENDESC;

/* messages sent to modMessage() entry-point function */
#define MODM_GETNUMDEVS     1
#define MODM_GETDEVCAPS     2
#define MODM_OPEN           3
#define MODM_CLOSE          4
#define MODM_PREPARE        5
#define MODM_UNPREPARE      6
#define MODM_DATA           7
#define MODM_LONGDATA       8
#define MODM_RESET          9
#define MODM_GETVOLUME      10
#define MODM_SETVOLUME      11
#define MODM_CACHEPATCHES       12      
#define MODM_CACHEDRUMPATCHES   13     

/* messages sent to midMessage() entry-point function */
#define MIDM_GETNUMDEVS  53
#define MIDM_GETDEVCAPS  54
#define MIDM_OPEN        55
#define MIDM_CLOSE       56
#define MIDM_PREPARE     57
#define MIDM_UNPREPARE   58
#define MIDM_ADDBUFFER   59
#define MIDM_START       60
#define MIDM_STOP        61
#define MIDM_RESET       62

#endif  /*ifndef MMNOMIDIDEV */


#ifndef MMNOAUXDEV
/****************************************************************************

                    Auxiliary audio device driver support

****************************************************************************/

/* maximum number of auxiliary device drivers loaded */
#define MAXAUXDRIVERS 10

/* messages sent to auxMessage() entry-point function */
#define AUXDM_GETNUMDEVS    3
#define AUXDM_GETDEVCAPS    4
#define AUXDM_GETVOLUME     5
#define AUXDM_SETVOLUME     6

#endif  /*ifndef MMNOAUXDEV */


#ifndef MMNOTIMERDEV
/****************************************************************************

                        Timer device driver support

****************************************************************************/

typedef struct timerevent_tag {
    UINT                wDelay;         /* delay required */
    UINT                wResolution;    /* resolution required */
    LPTIMECALLBACK      lpFunction;     /* ptr to callback function */
    DWORD               dwUser;         /* user DWORD */
    UINT                wFlags;         /* defines how to program event */
} TIMEREVENT;
typedef TIMEREVENT FAR *LPTIMEREVENT;

/* messages sent to tddMessage() function */
#define TDD_KILLTIMEREVENT  DRV_RESERVED+0  /* indices into a table of */
#define TDD_SETTIMEREVENT   DRV_RESERVED+4  /* functions; thus offset by */
#define TDD_GETSYSTEMTIME   DRV_RESERVED+8  /* four each time... */
#define TDD_GETDEVCAPS      DRV_RESERVED+12 /* room for future expansion */
#define TDD_BEGINMINPERIOD  DRV_RESERVED+16 /* room for future expansion */
#define TDD_ENDMINPERIOD    DRV_RESERVED+20 /* room for future expansion */

#endif  /*ifndef MMNOTIMERDEV */


#ifndef MMNOJOYDEV
/****************************************************************************

                       Joystick device driver support

****************************************************************************/

/* joystick calibration info structure */
typedef struct joycalibrate_tag {
    UINT    wXbase;
    UINT    wXdelta;
    UINT    wYbase;
    UINT    wYdelta;
    UINT    wZbase;
    UINT    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;

/* prototype for joystick message function */
typedef UINT (CALLBACK JOYDEVMSGPROC)(DWORD dwID, UINT uMessage, LPARAM lParam1, LPARAM lParam2);
typedef JOYDEVMSGPROC FAR *LPJOYDEVMSGPROC;

/* messages sent to joystick driver's DriverProc() function */
#define JDD_GETNUMDEVS      DRV_RESERVED+0x0001
#define JDD_GETDEVCAPS      DRV_RESERVED+0x0002
#define JDD_GETPOS          DRV_RESERVED+0x0101
#define JDD_SETCALIBRATION  DRV_RESERVED+0x0102

#endif  /*ifndef MMNOJOYDEV */


#ifndef MMNOMCIDEV
/****************************************************************************

                        MCI device driver support

****************************************************************************/

/* internal MCI messages */
#define MCI_OPEN_DRIVER             0x0801
#define MCI_CLOSE_DRIVER            0x0802

#define MAKEMCIRESOURCE(wRet, wRes) MAKELRESULT((wRet), (wRes))

/* string return values only used with MAKEMCIRESOURCE */
#define MCI_FALSE                       (MCI_STRING_OFFSET + 19)
#define MCI_TRUE                        (MCI_STRING_OFFSET + 20)

/* resource string return values */
#define MCI_FORMAT_RETURN_BASE          MCI_FORMAT_MILLISECONDS_S
#define MCI_FORMAT_MILLISECONDS_S       (MCI_STRING_OFFSET + 21)
#define MCI_FORMAT_HMS_S                (MCI_STRING_OFFSET + 22)
#define MCI_FORMAT_MSF_S                (MCI_STRING_OFFSET + 23)
#define MCI_FORMAT_FRAMES_S             (MCI_STRING_OFFSET + 24)
#define MCI_FORMAT_SMPTE_24_S           (MCI_STRING_OFFSET + 25)
#define MCI_FORMAT_SMPTE_25_S           (MCI_STRING_OFFSET + 26)
#define MCI_FORMAT_SMPTE_30_S           (MCI_STRING_OFFSET + 27)
#define MCI_FORMAT_SMPTE_30DROP_S       (MCI_STRING_OFFSET + 28)
#define MCI_FORMAT_BYTES_S              (MCI_STRING_OFFSET + 29)
#define MCI_FORMAT_SAMPLES_S            (MCI_STRING_OFFSET + 30)
#define MCI_FORMAT_TMSF_S               (MCI_STRING_OFFSET + 31)

#define MCI_VD_FORMAT_TRACK_S           (MCI_VD_OFFSET + 5)

#define WAVE_FORMAT_PCM_S               (MCI_WAVE_OFFSET + 0)
#define WAVE_MAPPER_S                   (MCI_WAVE_OFFSET + 1)

#define MCI_SEQ_MAPPER_S                (MCI_SEQ_OFFSET + 5)
#define MCI_SEQ_FILE_S                  (MCI_SEQ_OFFSET + 6)
#define MCI_SEQ_MIDI_S                  (MCI_SEQ_OFFSET + 7)
#define MCI_SEQ_SMPTE_S                 (MCI_SEQ_OFFSET + 8)
#define MCI_SEQ_FORMAT_SONGPTR_S        (MCI_SEQ_OFFSET + 9)
#define MCI_SEQ_NONE_S                  (MCI_SEQ_OFFSET + 10)
#define MIDIMAPPER_S                    (MCI_SEQ_OFFSET + 11)

/* parameters for internal version of MCI_OPEN message sent from */
/* mciOpenDevice() to the driver */
typedef struct {
    UINT    wDeviceID;             /* device ID */
    LPCSTR  lpstrParams;           /* parameter string for entry in SYSTEM.INI */
    UINT    wCustomCommandTable;   /* custom command table (0xFFFF if none) */
                                   /* filled in by the driver */
    UINT    wType;                 /* driver type */
                                   /* filled in by the driver */
} MCI_OPEN_DRIVER_PARMS;
typedef MCI_OPEN_DRIVER_PARMS FAR * LPMCI_OPEN_DRIVER_PARMS;

/* maximum length of an MCI device type */
#define MCI_MAX_DEVICE_TYPE_LENGTH 80

/* flags for mciSendCommandInternal() which direct mciSendString() how to */
/* interpret the return value */
#define MCI_RESOURCE_RETURNED       0x00010000  /* resource ID */
#define MCI_COLONIZED3_RETURN       0x00020000  /* colonized ID, 3 bytes data */
#define MCI_COLONIZED4_RETURN       0x00040000  /* colonized ID, 4 bytes data */
#define MCI_INTEGER_RETURNED        0x00080000  /* integer conversion needed */
#define MCI_RESOURCE_DRIVER         0x00100000  /* driver owns returned resource */

/* invalid command table ID */
#define MCI_NO_COMMAND_TABLE    0xFFFF

/* command table information type tags */
#define MCI_COMMAND_HEAD        0
#define MCI_STRING              1
#define MCI_INTEGER             2
#define MCI_END_COMMAND         3
#define MCI_RETURN              4
#define MCI_FLAG                5
#define MCI_END_COMMAND_LIST    6
#define MCI_RECT                7
#define MCI_CONSTANT            8
#define MCI_END_CONSTANT        9

/* function prototypes for MCI driver functions */
DWORD WINAPI mciGetDriverData(UINT uDeviceID);
BOOL  WINAPI mciSetDriverData(UINT uDeviceID, DWORD dwData);
UINT  WINAPI mciDriverYield(UINT uDeviceID);
BOOL  WINAPI mciDriverNotify(HWND hwndCallback, UINT uDeviceID,
    UINT uStatus);
UINT  WINAPI mciLoadCommandResource(HINSTANCE hInstance,
    LPCSTR lpResName, UINT uType);
BOOL  WINAPI mciFreeCommandResource(UINT uTable);

#endif  /*ifndef MMNOMCIDEV */


#ifndef MMNOTASKDEV
/*****************************************************************************

                               Task support

*****************************************************************************/

/* error return values */
#define TASKERR_NOTASKSUPPORT 1
#define TASKERR_OUTOFMEMORY   2

/* task support function prototypes */
#ifdef  BUILDDLL                                                /* ;Internal */
typedef void (FAR PASCAL TASKCALLBACK) (DWORD dwInst);          /* ;Internal */
#else   /*ifdef BUILDDLL*/                                      /* ;Internal */
typedef void (CALLBACK TASKCALLBACK) (DWORD dwInst);
#endif  /*ifdef BUILDDLL*/                                      /* ;Internal */

typedef TASKCALLBACK FAR *LPTASKCALLBACK;

UINT    WINAPI mmTaskCreate(LPTASKCALLBACK lpfnTaskProc, HTASK FAR * lphTask, DWORD dwInst);
UINT    WINAPI mmTaskBlock(HTASK h);
BOOL    WINAPI mmTaskSignal(HTASK h);
void    WINAPI mmTaskYield(void);
HTASK   WINAPI mmGetCurrentTask(void);

#endif  /*ifndef MMNOTASKDEV */

#define MMDDKINC                /* ;Internal */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif  /* _INC_MMDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\multires.h ===
/************************************************************************/
/*									*/
/*	MultiRes.H							*/
/*									*/
/*		This contains the data structures of the new format 	*/
/*	for the resources;						*/
/*									*/
/*	History:							*/
/*	    Created Nov, 1988  by Sankar				*/
/*									*/
/************************************************************************/



/*  The width of the name field in the Data for the group resources */
#define  NAMELEN    14

/*  The bits per pixel can be 1, 4, 8 or 24 in the PM bitmap format */
#define  MAXBITSPERPIXEL   24

#define  DEVICEDEP   1
#define  DEVICEINDEP 2


/* Header of the resource file in the new format */

struct   tagNEWHEADER
{
	WORD  Reserved;
	WORD  ResType;
	WORD  ResCount;
};

typedef struct tagNEWHEADER  FAR *LPNEWHEADER;

struct   tagICONDIR
{
        BYTE  Width;            /* 16, 32, 64 */
        BYTE  Height;           /* 16, 32, 64 */
        BYTE  ColorCount;       /* 2, 8, 16 */
        BYTE  reserved;
};

struct   tagCURSORDIR
{
	WORD  Width;
	WORD  Height;
};


/*  Structure of each entry in resource directory */

struct  tagRESDIR
{
	union  
	{
	    struct  tagICONDIR  Icon;
	    struct  tagCURSORDIR  Cursor;
	}   ResInfo;

	WORD   Planes;
	WORD   BitCount;
	DWORD  BytesInRes;
        WORD   idIcon; 
};

typedef struct tagRESDIR  FAR *LPRESDIR;

typedef   BITMAPINFOHEADER   *PBMPHEADER;
typedef	  BITMAPINFOHEADER FAR  *LPBMPHEADER;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\newexe.inc ===
savedCS = 4
savedIP = 2
savedBP = 0
savedDS = -2

EMAGIC  = 05A4Dh
ERESWDS =  0010h
ENEWHDR =  003Eh
ENEWEXE =  0040h

EXE_HDR     STRUC
e_magic     DW  ?               ; magic in same location
e_cblp      DW  ?
e_cp        DW  ?
e_crlc      DW  ?
e_cparhdr   DW  ?
e_minalloc  DW  ?
e_maxalloc  DW  ?
e_ss        DW  ?
e_sp        DW  ?
e_csum      DW  ?
e_cs        DW  ?
e_ip        DW  ?
e_lfarlc    DW  ?
e_ovno      DW  ?
e_res       DW  ERESWDS DUP (?)
e_lfanew    DD  ?
EXE_HDR     ENDS


NEMAGIC     = 454Eh
NERESBYTES  = 0

NEW_EXE         STRUC
ne_magic        DW  ?           ; Magic value 'NE'
ne_ver          DB  ?           ; version number
ne_rev          DB  ?           ; revision number
ne_enttab       DW  ?           ; offset to entry table
ne_cbenttab     DW  ?           ; number of bytes in entry table

ne_crc          DD  ?           ; CRC of file

ne_flags        DW  ?           ; flag word
ne_autodata     DW  ?           ; segment number of auto data segment
ne_heap         DW  ?           ; initial size of local heap
ne_stack        DW  ?           ; initial size of stack

ne_csip         DD  ?           ; CS:IP start address
ne_sssp         DD  ?           ; SS:SP initial stack pointer.  0 if
                                ; stack size word non-zero

ne_cseg         DW  ?           ; number of segment in segment table
ne_cmod         DW  ?           ; number of entries in module reference table
ne_cbnrestab    DW  ?           ; number of bytes in non-resident name table

ne_segtab       DW  ?           ; NE relative offset to segment table
ne_rsrctab      DW  ?           ; NE relative offset to resource table
ne_restab       DW  ?           ; NE relative offset to resident name table
ne_modtab       DW  ?           ; NE relative offset to module reference table
ne_imptab       DW  ?           ; NE relative offset to imported name table
ne_nrestab      DD  ?           ; file offset to non-resident name table
ne_cmovent      DW  ?           ; Count of movable entries
ne_align        DW  ?           ; Alignment shift count for segment data
ne_cres         DW  ?           ; Count of resource segments
ne_exetyp	DB  ?		; Target operating system
ne_flagsothers	DB  ?		; Other .EXE flags
ne_pretthunks   DW  ?           ; offset to return thunks
ne_psegrefbytes DW  ?           ; offset to segment ref. bytes
ne_swaparea     DW  ?           ; Minimum code swap area size
ne_expver       DW  ?           ; Expected Windows version number
NEW_EXE         ENDS

; Chksum not supported unless ne_psegcsum defined in NEW_EXE structure

ne_psegcsum = word ptr ne_exetyp
ne_onextexe = word ptr ne_crc

; New 3.0 Gang Load area description

ne_gang_start	= ne_pretthunks
ne_gang_length	= ne_psegrefbytes

NEW_EXE1        STRUC
                DW  ?
ne_usage        DW  ?
                DW  ?
ne_pnextexe     DW  ?
ne_pautodata    DW  ?
ne_pfileinfo    DW  ?
NEW_EXE1        ENDS

NENOTP          = 8000h         ; Not a process (i.e. a library module)
NEPRIVLIB       = 4000h         ; A library which lives above the line
NEIERR          = 2000h         ; Errors in image
NEAPPTYP        = 0700h         ; Application type mask
NENOTWINCOMPAT  = 0100h         ; Not compatible with P.M. Windowing
NEWINCOMPAT     = 0200h         ; Compatible with P.M. Windowing
NEWINAPI        = 0300h         ; Uses P.M. Windowing API
NEFLTP          = 0080h         ; Floating-point instructions
NEI386          = 0040h         ; 386 instructions
NEI286          = 0020h         ; 286 instructions
NEI086          = 0010h         ; 8086 instructions
NEPROT          = 0008h         ; Runs in protected mode only
NEPPLI          = 0004h         ; Per-Process Library Initialization
NEINST          = 0002h         ; Instance data
NESOLO          = 0001h         ; Solo data

; Below are the private bits used by the Windows 2.0 loader.  All are
; in the file, with the exception of NENONRES and NEWINPROT which are
; runtime only flags.
;

NEWINPROT	= NEIERR
NENONRES        = NEFLTP        ; Contains non-resident code segments
NEALLOCHIGH     = NEI386        ; Private allocs above the line okay
NEEMSSEPINST    = NEI286        ; Want each instance in separate
NELIM32         = NEI086        ; Uses LIM 3.2 API (Intel Above board)

; Following private bit is a runtime only flag used only ROM Windows.

NEMODINROM	= NEEMSSEPINST	; Module loaded from ROM

;
;  Format of NE_FLAGSOTHERS(x):
;
;      7 6 5 4 3 2 1 0	- bit no
;	       | | | |
;	       | | | +---------------- Support for long file names
;	       | | +------------------ 2.x app runs in protect mode
;	       | +-------------------- 2.x app gets prop. font
;	       +---------------------- Contains gangload area
;

NELONGNAMES     = 1h
NEINFONT        = 2h            ; WIN30 - 2.x app runs in 3.x prot mode
NEINPROT        = 4h            ; WIN30 - 2.x app gets proportional font
NEGANGLOAD      = 8h            ; WIN30 - Contains gangload area
NEASSUMENODEP   = 10h           ; WIN40 - DllEntryPoint known not to exit
NEINTLAPP       = 40h           ; WIN31 - intl versions use this.
NEHASPATCH      = 80h           ; WIN40 - Some segs of this module get patched

; Target operating systems

NE_UNKNOWN	= 0		; Unknown (any "new-format" OS)
NE_OS2		= 1		; Microsoft/IBM OS/2 (default)
NE_WINDOWS	= 2		; Microsoft Windows
NE_DOS4 	= 3		; Microsoft MS-DOS 4.x
NE_DEV386	= 4		; Microsoft Windows 386


ifndef NO_APPLOADER
NEAPPLOADER     = 0800h         ; set if application has its own loader
endif ;!NO_APPLOADER


NEW_SEG         STRUC
ns_sector       DW  ?   ; logical sector number in file of start of segment
ns_cbseg        DW  ?   ; number bytes in file
ns_flags        DW  ?   ; segment flags
ns_minalloc     DW  ?   ; minimum number bytes to allocate for segment
NEW_SEG         ENDS

NEW_SEG1        STRUC
                DB  SIZE NEW_SEG DUP (?)
ns_handle       DW  ?   ; Handle to segment (0 if not loaded)
NEW_SEG1        ENDS

NSTYPE          =  0007h    ; Segment type mask
NSCODE          =  0000h    ; Code segment
NSDATA          =  0001h    ; Data segment
NSITER          =  0008h    ; Iterated segment data
NSMOVE          =  0010h    ; Moveable segment
NSSHARE         =  0020h    ; Shareable segment
NSPRELOAD       =  0040h    ; Preload this segment
NSERONLY        =  0080h    ; EXECUTE ONLY code/READ ONLY data segment
NSRELOC         =  0100h    ; Relocation information following segment data
NSDPL           =  0C00h    ; 286 DPL bits
NSDISCARD       =  1000h    ; Discard priority bits
NS286DOS        = 0EE06h    ; These bits only used by 286DOS

NSALIGN         = 9         ; Default alignment shift count for seg. data

NSALLOCED       = 0002h     ; set if ns_handle points to uninitialized mem.
NSLOADED        = 0004h     ; set if ns_handle points to initialized mem.
NSUSESDATA      = 0400h     ; set if an entry point in this segment uses
                            ; the automatic data segment of a SOLO library

NSGETHIGH	= 0200h
NSINDIRECT	= 2000h
NSWINCODE	= 4000h     ; flag for code

NSKCACHED	= 0800h		; cached by kernel
NSPRIVLIB	= NSITER
NSNOTP		= 8000h

NSINROM 	= NSINDIRECT	; segment is loaded in ROM
NSCOMPR 	= NSGETHIGH	; segment is compressed in ROM

ifndef NO_APPLOADER
NSCACHED	= 8000h		;* in AppLoader Cache
endif ;!NO_APPLOADER


NEW_RSRC        STRUC
rs_align        DW  ?
NEW_RSRC        ENDS

RSORDID         = 08000h    ; If high bit of rt_id or rn_id set then integer id

RSRC_TYPEINFO   STRUC
rt_id           DW  ?
rt_nres         DW  ?
rt_proc         DD  ?
RSRC_TYPEINFO   ENDS

RSRC_NAMEINFO   STRUC
rn_offset       DW  ?
rn_length       DW  ?
rn_flags        DW  ?
rn_id           DW  ?
rn_handle       DW  ?
rn_usage        DW  ?
RSRC_NAMEINFO   ENDS
RNMOVE          = 00010h    ; Moveable resource
RNPURE          = 00020h    ; Pure resource (read only)
RNPRELOAD       = 00040h    ; Preload this resource
RNDISCARD       = 01000h    ; Discard bit
RNLOADED	= 00004h    ; True if handler proc return handle
RNCOMPR 	= 00200h    ; Resource is compressed in ROM
RNINROM 	= 02000h    ; Resource is loaded in ROM (run time flag)

RNUNUSED	= 0CD8Bh    ; Unused resource flags

ENTFIXED        STRUC
entflags        DB  ?
entoffset       DW  ?
ENTFIXED        ENDS

if SWAPPRO

ENTMOVEABLE	STRUC
		DB  ?			; Entry flags
entsar		DB  5 DUP (?)		; sar cs:[xxxx] instruction
		DW  ?			; INT 0F0H for swap profiler
entjmpfarop	DB  ?
entjmpfaroff	DW  ?
entjmpfarseg	DW  ?
ENTMOVEABLE	ENDS

ENTSWAPPED	STRUC
		DB  ?			; Entry flags
		DB  5 DUP (?)		; sar cs:[xxxx] instruction
		DW  ?			; INT 0F0H for swap profiler
entintop	DB  ?
entintvec	DB  ?
entintsegno	DB  ?
entintoff	DW  ?
ENTSWAPPED	ENDS

else		; no swap profiler

ENTMOVEABLE	STRUC
		DB  ?			; Entry flags
entsar		DB  5 DUP (?)		; sar cs:[xxxx] instruction
entjmpfarop	DB  ?
entjmpfaroff	DW  ?
entjmpfarseg	DW  ?
ENTMOVEABLE	ENDS

ENTSWAPPED	STRUC
		DB  ?			; Entry flags
		DB  5 DUP (?)		; sar cs:[xxxx] instruction
entintop	DB  ?
entintvec	DB  ?
entintsegno	DB  ?
entintoff	DW  ?
ENTSWAPPED	ENDS

endif		; if swap profiler

errnz <SIZE ENTMOVEABLE - SIZE ENTSWAPPED>

PENT		STRUC
penttype	DB  ?
pentflags	DB  ?
pentsegno	DB  ?
pentoffset	DW  ?
PENT		ENDS

PM_EntStruc	STRUC
PM_EntStart	dw	?
PM_EntEnd	dw	?
PM_EntNext	dw	?
PM_EntStruc	ENDS

ENT_UNUSED	= 000h
ENT_ABSSEG      = 0FEh
ENT_MOVEABLE    = 0FFh
ENT_PUBLIC      = 001h
ENT_DATA        = 002h
INTOPCODE       = 0CDh

if SWAPPRO
SWAPVECTOR	= 0F0h
endif

NEW_RLCINFO     STRUC
nr_nreloc       DW  ?
NEW_RLCINFO     ENDS

NEW_RLC         STRUC
nr_stype        DB  ?
nr_flags        DB  ?
nr_soff         DW  ?
nr_mod          DW  ?
nr_proc         DW  ?
NEW_RLC         ENDS
nr_segno        EQU nr_flags+3
nr_entry        EQU nr_proc

NRSTYP          = 07h
NRSBYTE         = 00h
NRSSEG          = 02h
NRSPTR          = 03h
NRSOFF          = 05h

NRADD           = 04h
NRRTYP          = 03h
NRRINT          = 00h
NRRORD          = 01h
NRRNAM          = 02h
OSFIXUP 	= 03h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\mmsystem.h ===
/****************************************************************************/
/*                                                                          */
/*        MMSYSTEM.H - Include file for Multimedia APIs                     */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1992, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/
#define BUILDDLL



/*    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *      MMNODRV          - Installable driver support
 *      MMNOSOUND        - Sound support
 *      MMNOWAVE         - Waveform support
 *      MMNOMIDI         - MIDI support
 *      MMNOAUX          - Auxiliary audio support
 *      MMNOTIMER        - Timer support
 *      MMNOJOY          - Joystick support
 *      MMNOMCI          - MCI support
 *      MMNOMMIO         - Multimedia file I/O support
 *      MMNOMMSYSTEM     - General MMSYSTEM functions
 */

#ifndef _INC_MMSYSTEM
#define _INC_MMSYSTEM   /* #defined if mmsystem.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifdef  BUILDDLL                                /* ;Internal */
#undef  WINAPI                                  /* ;Internal */
#define WINAPI          _loadds _far _pascal    /* ;Internal */
#undef  CALLBACK                                /* ;Internal */
#define CALLBACK        _loadds _far _pascal    /* ;Internal */
#endif  /* ifdef BUILDDLL */                    /* ;Internal */

/****************************************************************************

                    General constants and data types

****************************************************************************/

/* general constants */
#define MAXPNAMELEN      32     /* max product name length (including NULL) */
#define MAXERRORLENGTH   128    /* max error text length (including NULL) */

/* general data types */
typedef WORD    VERSION;        /* major (high byte), minor (low byte) */

/* MMTIME data structure */
typedef struct mmtime_tag {
    UINT    wType;              /* indicates the contents of the union */
    union {
        DWORD ms;               /* milliseconds */
        DWORD sample;           /* samples */
        DWORD cb;               /* byte count */
        struct {                /* SMPTE */
            BYTE hour;          /* hours */
            BYTE min;           /* minutes */
            BYTE sec;           /* seconds */
            BYTE frame;         /* frames  */
            BYTE fps;           /* frames per second */
            BYTE dummy;         /* pad */
            } smpte;
        struct {                /* MIDI */
            DWORD songptrpos;   /* song pointer position */
            } midi;
        } u;
    } MMTIME;
typedef MMTIME       *PMMTIME;
typedef MMTIME NEAR *NPMMTIME;
typedef MMTIME FAR  *LPMMTIME;

/* types for wType field in MMTIME struct */
#define TIME_MS         0x0001  /* time in milliseconds */
#define TIME_SAMPLES    0x0002  /* number of wave samples */
#define TIME_BYTES      0x0004  /* current byte offset */
#define TIME_SMPTE      0x0008  /* SMPTE time */
#define TIME_MIDI       0x0010  /* MIDI time */


/****************************************************************************

                    Multimedia Extensions Window Messages

****************************************************************************/

#define MM_JOY1MOVE         0x3A0           /* joystick */
#define MM_JOY2MOVE         0x3A1
#define MM_JOY1ZMOVE        0x3A2
#define MM_JOY2ZMOVE        0x3A3
#define MM_JOY1BUTTONDOWN   0x3B5
#define MM_JOY2BUTTONDOWN   0x3B6
#define MM_JOY1BUTTONUP     0x3B7
#define MM_JOY2BUTTONUP     0x3B8

#define MM_MCINOTIFY        0x3B9           /* MCI */
#define MM_MCISYSTEM_STRING 0x3CA           /* ;Internal */

#define MM_WOM_OPEN         0x3BB           /* waveform output */
#define MM_WOM_CLOSE        0x3BC
#define MM_WOM_DONE         0x3BD

#define MM_WIM_OPEN         0x3BE           /* waveform input */
#define MM_WIM_CLOSE        0x3BF
#define MM_WIM_DATA         0x3C0

#define MM_MIM_OPEN         0x3C1           /* MIDI input */
#define MM_MIM_CLOSE        0x3C2
#define MM_MIM_DATA         0x3C3
#define MM_MIM_LONGDATA     0x3C4
#define MM_MIM_ERROR        0x3C5
#define MM_MIM_LONGERROR    0x3C6

#define MM_MOM_OPEN         0x3C7           /* MIDI output */
#define MM_MOM_CLOSE        0x3C8
#define MM_MOM_DONE         0x3C9


/****************************************************************************

                String resource number bases (internal use)

****************************************************************************/

#define MMSYSERR_BASE          0
#define WAVERR_BASE            32
#define MIDIERR_BASE           64
#define TIMERR_BASE            96
#define JOYERR_BASE            160
#define MCIERR_BASE            256

#define MCI_STRING_OFFSET      512
#define MCI_VD_OFFSET          1024
#define MCI_CD_OFFSET          1088
#define MCI_WAVE_OFFSET        1152
#define MCI_SEQ_OFFSET         1216

/****************************************************************************

                        General error return values

****************************************************************************/

/* general error return values */
#define MMSYSERR_NOERROR      0                    /* no error */
#define MMSYSERR_ERROR        (MMSYSERR_BASE + 1)  /* unspecified error */
#define MMSYSERR_BADDEVICEID  (MMSYSERR_BASE + 2)  /* device ID out of range */
#define MMSYSERR_NOTENABLED   (MMSYSERR_BASE + 3)  /* driver failed enable */
#define MMSYSERR_ALLOCATED    (MMSYSERR_BASE + 4)  /* device already allocated */
#define MMSYSERR_INVALHANDLE  (MMSYSERR_BASE + 5)  /* device handle is invalid */
#define MMSYSERR_NODRIVER     (MMSYSERR_BASE + 6)  /* no device driver present */
#define MMSYSERR_NOMEM        (MMSYSERR_BASE + 7)  /* memory allocation error */
#define MMSYSERR_NOTSUPPORTED (MMSYSERR_BASE + 8)  /* function isn't supported */
#define MMSYSERR_BADERRNUM    (MMSYSERR_BASE + 9)  /* error value out of range */
#define MMSYSERR_INVALFLAG    (MMSYSERR_BASE + 10) /* invalid flag passed */
#define MMSYSERR_INVALPARAM   (MMSYSERR_BASE + 11) /* invalid parameter passed */
#define MMSYSERR_LASTERROR    (MMSYSERR_BASE + 11) /* last error in range */


#if (WINVER < 0x030a)
DECLARE_HANDLE(HDRVR);
#endif /* ifdef WINVER < 0x030a */

#ifndef MMNODRV
/****************************************************************************

                        Installable driver support

****************************************************************************/

#if (WINVER < 0x030a)

/* return values from DriverProc() function */
#define DRV_CANCEL              0x0000
#define DRV_OK                  0x0001
#define DRV_RESTART             0x0002

/* Driver messages */
#define DRV_LOAD                0x0001
#define DRV_ENABLE              0x0002
#define DRV_OPEN                0x0003
#define DRV_CLOSE               0x0004
#define DRV_DISABLE             0x0005
#define DRV_FREE                0x0006
#define DRV_CONFIGURE           0x0007
#define DRV_QUERYCONFIGURE      0x0008
#define DRV_INSTALL             0x0009
#define DRV_REMOVE              0x000A
#define DRV_RESERVED            0x0800
#define DRV_USER                0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO        *PDRVCONFIGINFO;
typedef DRVCONFIGINFO  NEAR *NPDRVCONFIGINFO;
typedef DRVCONFIGINFO  FAR  *LPDRVCONFIGINFO;

/* installable driver function prototypes */
LRESULT   WINAPI DrvClose(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);
HDRVR     WINAPI DrvOpen(LPCSTR szDriverName, LPCSTR szSectionName,
    LPARAM lParam2);
LRESULT   WINAPI DrvSendMessage(HDRVR hDriver, UINT uMessage,
    LPARAM lParam1, LPARAM lParam2);
HINSTANCE WINAPI DrvGetModuleHandle(HDRVR hDriver);

LRESULT WINAPI DrvDefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID,
    UINT uMessage, LPARAM lParam1, LPARAM lParam2);

#define DefDriverProc DrvDefDriverProc

#endif /* ifdef WINVER < 0x030a */

#if (WINVER >= 0x030a)

#ifdef DEBUG                                          /* ;Internal */
        LRESULT WINAPI DrvClose(HDRVR,LPARAM,LPARAM); /* ;Internal */
        HDRVR   WINAPI DrvOpen(LPCSTR,LPCSTR,LPARAM); /* ;Internal */
        #define OpenDriver DrvOpen                    /* ;Internal */
        #define CloseDriver DrvClose                  /* ;Internal */
#endif                                                /* ;Internal */

/* return values from DriverProc() function */
#define DRV_CANCEL             DRVCNF_CANCEL
#define DRV_OK                 DRVCNF_OK
#define DRV_RESTART            DRVCNF_RESTART

#endif /* ifdef WINVER >= 0x030a */

#define DRV_MCI_FIRST          DRV_RESERVED
#define DRV_MCI_LAST           (DRV_RESERVED + 0xFFF)

#endif  /* ifndef MMNODRV */


/****************************************************************************

                          Driver callback support

****************************************************************************/

/* flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and */
/* midiOutOpen() to specify the type of the dwCallback parameter. */

#define CALLBACK_TYPEMASK   0x00070000l    /* callback type mask */
#define CALLBACK_NULL       0x00000000l    /* no callback */
#define CALLBACK_WINDOW     0x00010000l    /* dwCallback is a HWND */
#define CALLBACK_TASK       0x00020000l    /* dwCallback is a HTASK */
#define CALLBACK_FUNCTION   0x00030000l    /* dwCallback is a FARPROC */

/* driver callback prototypes */
#ifdef  BUILDDLL                                /* ;Internal */
typedef void (FAR PASCAL DRVCALLBACK) (HDRVR h, UINT uMessage, DWORD dwUser, DWORD dw1, DWORD dw2);          /* ;Internal */
#else   /* ifdef BUILDDLL */                    /* ;Internal */
typedef void (CALLBACK DRVCALLBACK) (HDRVR h, UINT uMessage, DWORD dwUser, DWORD dw1, DWORD dw2);
#endif  /* ifdef BUILDDLL */                    /* ;Internal */

typedef DRVCALLBACK FAR *LPDRVCALLBACK;

/****************************************************************************

                         Manufacturer and product IDs

    Used with wMid and wPid fields in WAVEOUTCAPS, WAVEINCAPS,
    MIDIOUTCAPS, MIDIINCAPS, AUXCAPS, JOYCAPS structures.

****************************************************************************/

/* manufacturer IDs */
#define MM_MICROSOFT            1       /* Microsoft Corp. */

/* product IDs */
#define MM_MIDI_MAPPER          1       /* MIDI Mapper */
#define MM_WAVE_MAPPER          2       /* Wave Mapper */

#define MM_SNDBLST_MIDIOUT      3       /* Sound Blaster MIDI output port */
#define MM_SNDBLST_MIDIIN       4       /* Sound Blaster MIDI input port  */
#define MM_SNDBLST_SYNTH        5       /* Sound Blaster internal synthesizer */
#define MM_SNDBLST_WAVEOUT      6       /* Sound Blaster waveform output */
#define MM_SNDBLST_WAVEIN       7       /* Sound Blaster waveform input */

#define MM_ADLIB                9       /* Ad Lib-compatible synthesizer */

#define MM_MPU401_MIDIOUT       10      /* MPU401-compatible MIDI output port */
#define MM_MPU401_MIDIIN        11      /* MPU401-compatible MIDI input port */

#define MM_PC_JOYSTICK          12      /* Joystick adapter */


#ifndef MMNOMMSYSTEM
/****************************************************************************

                    General MMSYSTEM support

****************************************************************************/

WORD WINAPI mmsystemGetVersion(void);
void WINAPI OutputDebugStr(LPCSTR);

#endif  /* ifndef MMNOMMSYSTEM */


#ifndef MMNOSOUND
/****************************************************************************

                            Sound support

****************************************************************************/

BOOL WINAPI sndPlaySound(LPCSTR lpszSoundName, UINT uFlags);

/* flag values for wFlags parameter */
#define SND_SYNC            0x0000  /* play synchronously (default) */
#define SND_ASYNC           0x0001  /* play asynchronously */
#define SND_NODEFAULT       0x0002  /* don't use default sound */
#define SND_MEMORY          0x0004  /* lpszSoundName points to a memory file */
#define SND_LOOP            0x0008  /* loop the sound until next sndPlaySound */
#define SND_NOSTOP          0x0010  /* don't stop any currently playing sound */
#define SND_VALID           0x001F  /* valid flags */         /* ;Internal */

#endif  /* ifndef MMNOSOUND */


#ifndef MMNOWAVE
/****************************************************************************

                        Waveform audio support

****************************************************************************/

/* waveform audio error return values */
#define WAVERR_BADFORMAT      (WAVERR_BASE + 0)    /* unsupported wave format */
#define WAVERR_STILLPLAYING   (WAVERR_BASE + 1)    /* still something playing */
#define WAVERR_UNPREPARED     (WAVERR_BASE + 2)    /* header not prepared */
#define WAVERR_SYNC           (WAVERR_BASE + 3)    /* device is synchronous */
#define WAVERR_LASTERROR      (WAVERR_BASE + 3)    /* last error in range */

/* waveform audio data types */
DECLARE_HANDLE(HWAVE);
DECLARE_HANDLE(HWAVEIN);
DECLARE_HANDLE(HWAVEOUT);
typedef HWAVEIN FAR *LPHWAVEIN;
typedef HWAVEOUT FAR *LPHWAVEOUT;
typedef DRVCALLBACK WAVECALLBACK;
typedef WAVECALLBACK FAR *LPWAVECALLBACK;

/* wave callback messages */
#define WOM_OPEN        MM_WOM_OPEN
#define WOM_CLOSE       MM_WOM_CLOSE
#define WOM_DONE        MM_WOM_DONE
#define WIM_OPEN        MM_WIM_OPEN
#define WIM_CLOSE       MM_WIM_CLOSE
#define WIM_DATA        MM_WIM_DATA

/* device ID for wave device mapper */
#define WAVE_MAPPER     (-1)

/* flags for dwFlags parameter in waveOutOpen() and waveInOpen() */
#define  WAVE_FORMAT_QUERY     0x0001
#define  WAVE_ALLOWSYNC        0x0002
#define  WAVE_VALID            0x0003       /* ;Internal */

/* wave data block header */
typedef struct wavehdr_tag {
    LPSTR       lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* length of data buffer */
    DWORD       dwBytesRecorded;        /* used for input only */
    DWORD       dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwLoops;                /* loop control counter */
    struct wavehdr_tag far *lpNext;     /* reserved for driver */
    DWORD       reserved;               /* reserved for driver */
} WAVEHDR;
typedef WAVEHDR       *PWAVEHDR;
typedef WAVEHDR NEAR *NPWAVEHDR;
typedef WAVEHDR FAR  *LPWAVEHDR;

/* flags for dwFlags field of WAVEHDR */
#define WHDR_DONE       0x00000001  /* done bit */
#define WHDR_PREPARED   0x00000002  /* set if this header has been prepared */
#define WHDR_BEGINLOOP  0x00000004  /* loop start block */
#define WHDR_ENDLOOP    0x00000008  /* loop end block */
#define WHDR_INQUEUE    0x00000010  /* reserved for driver */
#define WHDR_VALID      0x0000001F  /* valid flags */     /* ;Internal */

/* waveform output device capabilities structure */
typedef struct waveoutcaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    UINT    wChannels;             /* number of sources supported */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPS;
typedef WAVEOUTCAPS       *PWAVEOUTCAPS;
typedef WAVEOUTCAPS NEAR *NPWAVEOUTCAPS;
typedef WAVEOUTCAPS FAR  *LPWAVEOUTCAPS;

/* flags for dwSupport field of WAVEOUTCAPS */
#define WAVECAPS_PITCH          0x0001   /* supports pitch control */
#define WAVECAPS_PLAYBACKRATE   0x0002   /* supports playback rate control */
#define WAVECAPS_VOLUME         0x0004   /* supports volume control */
#define WAVECAPS_LRVOLUME       0x0008   /* separate left-right volume control */
#define WAVECAPS_SYNC           0x0010

/* waveform input device capabilities structure */
typedef struct waveincaps_tag {
    UINT    wMid;                    /* manufacturer ID */
    UINT    wPid;                    /* product ID */
    VERSION vDriverVersion;          /* version of the driver */
    char    szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    UINT    wChannels;               /* number of channels supported */
} WAVEINCAPS;
typedef WAVEINCAPS       *PWAVEINCAPS;
typedef WAVEINCAPS NEAR *NPWAVEINCAPS;
typedef WAVEINCAPS FAR  *LPWAVEINCAPS;

/* defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS */
#define WAVE_INVALIDFORMAT     0x00000000       /* invalid format */
#define WAVE_FORMAT_1M08       0x00000001       /* 11.025 kHz, Mono,   8-bit  */
#define WAVE_FORMAT_1S08       0x00000002       /* 11.025 kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_1M16       0x00000004       /* 11.025 kHz, Mono,   16-bit */
#define WAVE_FORMAT_1S16       0x00000008       /* 11.025 kHz, Stereo, 16-bit */
#define WAVE_FORMAT_2M08       0x00000010       /* 22.05  kHz, Mono,   8-bit  */
#define WAVE_FORMAT_2S08       0x00000020       /* 22.05  kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_2M16       0x00000040       /* 22.05  kHz, Mono,   16-bit */
#define WAVE_FORMAT_2S16       0x00000080       /* 22.05  kHz, Stereo, 16-bit */
#define WAVE_FORMAT_4M08       0x00000100       /* 44.1   kHz, Mono,   8-bit  */
#define WAVE_FORMAT_4S08       0x00000200       /* 44.1   kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_4M16       0x00000400       /* 44.1   kHz, Mono,   16-bit */
#define WAVE_FORMAT_4S16       0x00000800       /* 44.1   kHz, Stereo, 16-bit */

/* general waveform format structure (information common to all formats) */
typedef struct waveformat_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo, etc.) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
} WAVEFORMAT;
typedef WAVEFORMAT       *PWAVEFORMAT;
typedef WAVEFORMAT NEAR *NPWAVEFORMAT;
typedef WAVEFORMAT FAR  *LPWAVEFORMAT;

/* flags for wFormatTag field of WAVEFORMAT */
#define WAVE_FORMAT_PCM     1

/* specific waveform format structure for PCM data */
typedef struct pcmwaveformat_tag {
    WAVEFORMAT  wf;
    WORD        wBitsPerSample;
} PCMWAVEFORMAT;
typedef PCMWAVEFORMAT       *PPCMWAVEFORMAT;
typedef PCMWAVEFORMAT NEAR *NPPCMWAVEFORMAT;
typedef PCMWAVEFORMAT FAR  *LPPCMWAVEFORMAT;

/* waveform audio function prototypes */
UINT WINAPI waveOutGetNumDevs(void);
UINT WINAPI waveOutGetDevCaps(UINT uDeviceID, WAVEOUTCAPS FAR* lpCaps,
    UINT uSize);
UINT WINAPI waveOutGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);
UINT WINAPI waveOutSetVolume(UINT uDeviceID, DWORD dwVolume);
UINT WINAPI waveOutGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI waveOutOpen(HWAVEOUT FAR* lphWaveOut, UINT uDeviceID,
    const WAVEFORMAT FAR* lpFormat, DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI waveOutClose(HWAVEOUT hWaveOut);
UINT WINAPI waveOutPrepareHeader(HWAVEOUT hWaveOut,
     WAVEHDR FAR* lpWaveOutHdr, UINT uSize);
UINT WINAPI waveOutUnprepareHeader(HWAVEOUT hWaveOut,
    WAVEHDR FAR* lpWaveOutHdr, UINT uSize);
UINT WINAPI waveOutWrite(HWAVEOUT hWaveOut, WAVEHDR FAR* lpWaveOutHdr,
    UINT uSize);
UINT WINAPI waveOutPause(HWAVEOUT hWaveOut);
UINT WINAPI waveOutRestart(HWAVEOUT hWaveOut);
UINT WINAPI waveOutReset(HWAVEOUT hWaveOut);
UINT WINAPI waveOutBreakLoop(HWAVEOUT hWaveOut);
UINT WINAPI waveOutGetPosition(HWAVEOUT hWaveOut, MMTIME FAR* lpInfo,
    UINT uSize);
UINT WINAPI waveOutGetPitch(HWAVEOUT hWaveOut, DWORD FAR* lpdwPitch);
UINT WINAPI waveOutSetPitch(HWAVEOUT hWaveOut, DWORD dwPitch);
UINT WINAPI waveOutGetPlaybackRate(HWAVEOUT hWaveOut, DWORD FAR* lpdwRate);
UINT WINAPI waveOutSetPlaybackRate(HWAVEOUT hWaveOut, DWORD dwRate);
UINT WINAPI waveOutGetID(HWAVEOUT hWaveOut, UINT FAR* lpuDeviceID);

#if (WINVER >= 0x030a)
DWORD WINAPI waveOutMessage(HWAVEOUT hWaveOut, UINT uMessage, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

UINT WINAPI waveInGetNumDevs(void);
UINT WINAPI waveInGetDevCaps(UINT uDeviceID, WAVEINCAPS FAR* lpCaps,
    UINT uSize);
UINT WINAPI waveInGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI waveInOpen(HWAVEIN FAR* lphWaveIn, UINT uDeviceID,
    const WAVEFORMAT FAR* lpFormat, DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI waveInClose(HWAVEIN hWaveIn);
UINT WINAPI waveInPrepareHeader(HWAVEIN hWaveIn,
    WAVEHDR FAR* lpWaveInHdr, UINT uSize);
UINT WINAPI waveInUnprepareHeader(HWAVEIN hWaveIn,
    WAVEHDR FAR* lpWaveInHdr, UINT uSize);
UINT WINAPI waveInAddBuffer(HWAVEIN hWaveIn,
    WAVEHDR FAR* lpWaveInHdr, UINT uSize);
UINT WINAPI waveInStart(HWAVEIN hWaveIn);
UINT WINAPI waveInStop(HWAVEIN hWaveIn);
UINT WINAPI waveInReset(HWAVEIN hWaveIn);
UINT WINAPI waveInGetPosition(HWAVEIN hWaveIn, MMTIME FAR* lpInfo,
    UINT uSize);
UINT WINAPI waveInGetID(HWAVEIN hWaveIn, UINT FAR* lpuDeviceID);

#if (WINVER >= 0x030a)
DWORD WINAPI waveInMessage(HWAVEIN hWaveIn, UINT uMessage, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

#endif  /* ifndef MMNOWAVE */


#ifndef MMNOMIDI
/****************************************************************************

                            MIDI audio support

****************************************************************************/

/* MIDI error return values */
#define MIDIERR_UNPREPARED    (MIDIERR_BASE + 0)   /* header not prepared */
#define MIDIERR_STILLPLAYING  (MIDIERR_BASE + 1)   /* still something playing */
#define MIDIERR_NOMAP         (MIDIERR_BASE + 2)   /* no current map */
#define MIDIERR_NOTREADY      (MIDIERR_BASE + 3)   /* hardware is still busy */
#define MIDIERR_NODEVICE      (MIDIERR_BASE + 4)   /* port no longer connected */
#define MIDIERR_INVALIDSETUP  (MIDIERR_BASE + 5)   /* invalid setup */
#define MIDIERR_LASTERROR     (MIDIERR_BASE + 5)   /* last error in range */

/* MIDI audio data types */
DECLARE_HANDLE(HMIDI);
DECLARE_HANDLE(HMIDIIN);
DECLARE_HANDLE(HMIDIOUT);
typedef HMIDIIN FAR *LPHMIDIIN;
typedef HMIDIOUT FAR *LPHMIDIOUT;
typedef DRVCALLBACK MIDICALLBACK;
typedef MIDICALLBACK FAR *LPMIDICALLBACK;
#define MIDIPATCHSIZE   128
typedef WORD PATCHARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPPATCHARRAY;
typedef WORD KEYARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPKEYARRAY;

/* MIDI callback messages */
#define MIM_OPEN        MM_MIM_OPEN
#define MIM_CLOSE       MM_MIM_CLOSE
#define MIM_DATA        MM_MIM_DATA
#define MIM_LONGDATA    MM_MIM_LONGDATA
#define MIM_ERROR       MM_MIM_ERROR
#define MIM_LONGERROR   MM_MIM_LONGERROR
#define MOM_OPEN        MM_MOM_OPEN
#define MOM_CLOSE       MM_MOM_CLOSE
#define MOM_DONE        MM_MOM_DONE

/* device ID for MIDI mapper */
#define MIDIMAPPER     (-1)
#define MIDI_MAPPER    (-1)

/* flags for wFlags parm of midiOutCachePatches(), midiOutCacheDrumPatches() */
#define MIDI_CACHE_ALL      1
#define MIDI_CACHE_BESTFIT  2
#define MIDI_CACHE_QUERY    3
#define MIDI_UNCACHE        4
#define	MIDI_CACHE_VALID    (MIDI_CACHE_ALL | MIDI_CACHE_BESTFIT | MIDI_CACHE_QUERY | MIDI_UNCACHE)	/* ;Internal */

/* MIDI output device capabilities structure */
typedef struct midioutcaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT    wTechnology;           /* type of device */
    UINT    wVoices;               /* # of voices (internal synth only) */
    UINT    wNotes;                /* max # of notes (internal synth only) */
    UINT    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPS;
typedef MIDIOUTCAPS       *PMIDIOUTCAPS;
typedef MIDIOUTCAPS NEAR *NPMIDIOUTCAPS;
typedef MIDIOUTCAPS FAR  *LPMIDIOUTCAPS;

/* flags for wTechnology field of MIDIOUTCAPS structure */
#define MOD_MIDIPORT    1  /* output port */
#define MOD_SYNTH       2  /* generic internal synth */
#define MOD_SQSYNTH     3  /* square wave internal synth */
#define MOD_FMSYNTH     4  /* FM internal synth */
#define MOD_MAPPER      5  /* MIDI mapper */

/* flags for dwSupport field of MIDIOUTCAPS structure */
#define MIDICAPS_VOLUME          0x0001  /* supports volume control */
#define MIDICAPS_LRVOLUME        0x0002  /* separate left-right volume control */
#define MIDICAPS_CACHE           0x0004

/* MIDI output device capabilities structure */
typedef struct midiincaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
} MIDIINCAPS;
typedef MIDIINCAPS      *PMIDIINCAPS;
typedef MIDIINCAPS NEAR *NPMIDIINCAPS;
typedef MIDIINCAPS FAR  *LPMIDIINCAPS;

/* MIDI data block header */
typedef struct midihdr_tag {
    LPSTR       lpData;               /* pointer to locked data block */
    DWORD       dwBufferLength;       /* length of data in data block */
    DWORD       dwBytesRecorded;      /* used for input only */
    DWORD       dwUser;               /* for client's use */
    DWORD       dwFlags;              /* assorted flags (see defines) */
    struct midihdr_tag far *lpNext;   /* reserved for driver */
    DWORD       reserved;             /* reserved for driver */
} MIDIHDR;
typedef MIDIHDR       *PMIDIHDR;
typedef MIDIHDR NEAR *NPMIDIHDR;
typedef MIDIHDR FAR  *LPMIDIHDR;

/* flags for dwFlags field of MIDIHDR structure */
#define MHDR_DONE       0x00000001       /* done bit */
#define MHDR_PREPARED   0x00000002       /* set if header prepared */
#define MHDR_INQUEUE    0x00000004       /* reserved for driver */
#define MHDR_VALID      0x00000007       /* valid flags */ /* ;Internal */

/* MIDI function prototypes */
UINT WINAPI midiOutGetNumDevs(void);
UINT WINAPI midiOutGetDevCaps(UINT uDeviceID,
    MIDIOUTCAPS FAR* lpCaps, UINT uSize);
UINT WINAPI midiOutGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);
UINT WINAPI midiOutSetVolume(UINT uDeviceID, DWORD dwVolume);
UINT WINAPI midiOutGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI midiOutOpen(HMIDIOUT FAR* lphMidiOut, UINT uDeviceID,
    DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI midiOutClose(HMIDIOUT hMidiOut);
UINT WINAPI midiOutPrepareHeader(HMIDIOUT hMidiOut,
    MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
UINT WINAPI midiOutUnprepareHeader(HMIDIOUT hMidiOut,
    MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
UINT WINAPI midiOutShortMsg(HMIDIOUT hMidiOut, DWORD dwMsg);
UINT WINAPI midiOutLongMsg(HMIDIOUT hMidiOut,
    MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
UINT WINAPI midiOutReset(HMIDIOUT hMidiOut);
UINT WINAPI midiOutCachePatches(HMIDIOUT hMidiOut,
    UINT uBank, WORD FAR* lpwPatchArray, UINT uFlags);
UINT WINAPI midiOutCacheDrumPatches(HMIDIOUT hMidiOut,
    UINT uPatch, WORD FAR* lpwKeyArray, UINT uFlags);
UINT WINAPI midiOutGetID(HMIDIOUT hMidiOut, UINT FAR* lpuDeviceID);

#if (WINVER >= 0x030a)
DWORD WINAPI midiOutMessage(HMIDIOUT hMidiOut, UINT uMessage, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

UINT WINAPI midiInGetNumDevs(void);
UINT WINAPI midiInGetDevCaps(UINT uDeviceID,
    LPMIDIINCAPS lpCaps, UINT uSize);
UINT WINAPI midiInGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI midiInOpen(HMIDIIN FAR* lphMidiIn, UINT uDeviceID,
    DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI midiInClose(HMIDIIN hMidiIn);
UINT WINAPI midiInPrepareHeader(HMIDIIN hMidiIn,
    MIDIHDR FAR* lpMidiInHdr, UINT uSize);
UINT WINAPI midiInUnprepareHeader(HMIDIIN hMidiIn,
    MIDIHDR FAR* lpMidiInHdr, UINT uSize);
UINT WINAPI midiInAddBuffer(HMIDIIN hMidiIn,
    MIDIHDR FAR* lpMidiInHdr, UINT uSize);
UINT WINAPI midiInStart(HMIDIIN hMidiIn);
UINT WINAPI midiInStop(HMIDIIN hMidiIn);
UINT WINAPI midiInReset(HMIDIIN hMidiIn);
UINT WINAPI midiInGetID(HMIDIIN hMidiIn, UINT FAR* lpuDeviceID);

#if (WINVER >= 0x030a)
DWORD WINAPI midiInMessage(HMIDIIN hMidiIn, UINT uMessage, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

#endif  /* ifndef MMNOMIDI */


#ifndef MMNOAUX
/****************************************************************************

                        Auxiliary audio support

****************************************************************************/

/* device ID for aux device mapper */
#define AUX_MAPPER     (-1)

/* Auxiliary audio device capabilities structure */
typedef struct auxcaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT    wTechnology;           /* type of device */
    DWORD   dwSupport;             /* functionality supported by driver */
} AUXCAPS;
typedef AUXCAPS       *PAUXCAPS;
typedef AUXCAPS NEAR *NPAUXCAPS;
typedef AUXCAPS FAR  *LPAUXCAPS;

/* flags for wTechnology field in AUXCAPS structure */
#define AUXCAPS_CDAUDIO    1       /* audio from internal CD-ROM drive */
#define AUXCAPS_AUXIN      2       /* audio from auxiliary input jacks */

/* flags for dwSupport field in AUXCAPS structure */
#define AUXCAPS_VOLUME          0x0001  /* supports volume control */
#define AUXCAPS_LRVOLUME        0x0002  /* separate left-right volume control */

/* auxiliary audio function prototypes */
UINT WINAPI auxGetNumDevs(void);
UINT WINAPI auxGetDevCaps(UINT uDeviceID, AUXCAPS FAR* lpCaps, UINT uSize);
UINT WINAPI auxSetVolume(UINT uDeviceID, DWORD dwVolume);
UINT WINAPI auxGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);

#if (WINVER >= 0x030a)
DWORD WINAPI auxOutMessage(UINT uDeviceID, UINT uMessage, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

#endif  /* ifndef MMNOAUX */


#ifndef MMNOTIMER
/****************************************************************************

                            Timer support

****************************************************************************/

/* timer error return values */
#define TIMERR_NOERROR        (0)                  /* no error */
#define TIMERR_NOCANDO        (TIMERR_BASE+1)      /* request not completed */
#define TIMERR_STRUCT         (TIMERR_BASE+33)     /* time struct size */

/* timer data types */
#ifdef  BUILDDLL                                   /* ;Internal */
typedef void (FAR PASCAL TIMECALLBACK) (UINT uTimerID, UINT uMessage, DWORD dwUser, DWORD dw1, DWORD dw2);           /* ;Internal */
#else   /* ifdef BUILDDLL */                       /* ;Internal */
typedef void (CALLBACK TIMECALLBACK) (UINT uTimerID, UINT uMessage, DWORD dwUser, DWORD dw1, DWORD dw2);
#endif  /* ifdef BUILDDLL */                       /* ;Internal */

typedef TIMECALLBACK FAR *LPTIMECALLBACK;

/* flags for wFlags parameter of timeSetEvent() function */
#define TIME_ONESHOT    0   /* program timer for single event */
#define TIME_PERIODIC   1   /* program for continuous periodic event */

/* timer device capabilities data structure */
typedef struct timecaps_tag {
    UINT    wPeriodMin;     /* minimum period supported  */
    UINT    wPeriodMax;     /* maximum period supported  */
    } TIMECAPS;
typedef TIMECAPS       *PTIMECAPS;
typedef TIMECAPS NEAR *NPTIMECAPS;
typedef TIMECAPS FAR  *LPTIMECAPS;

/* timer function prototypes */
UINT WINAPI timeGetSystemTime(MMTIME FAR* lpTime, UINT uSize);
DWORD WINAPI timeGetTime(void);
UINT WINAPI timeSetEvent(UINT uDelay, UINT uResolution,
    LPTIMECALLBACK lpFunction, DWORD dwUser, UINT uFlags);
UINT WINAPI timeKillEvent(UINT uTimerID);
UINT WINAPI timeGetDevCaps(TIMECAPS FAR* lpTimeCaps, UINT uSize);
UINT WINAPI timeBeginPeriod(UINT uPeriod);
UINT WINAPI timeEndPeriod(UINT uPeriod);

#endif  /* ifndef MMNOTIMER */


#ifndef MMNOJOY
/****************************************************************************

                            Joystick support

****************************************************************************/

/* joystick error return values */
#define JOYERR_NOERROR        (0)                  /* no error */
#define JOYERR_PARMS          (JOYERR_BASE+5)      /* bad parameters */
#define JOYERR_NOCANDO        (JOYERR_BASE+6)      /* request not completed */
#define JOYERR_UNPLUGGED      (JOYERR_BASE+7)      /* joystick is unplugged */

/* constants used with JOYINFO structure and MM_JOY* messages */
#define JOY_BUTTON1         0x0001
#define JOY_BUTTON2         0x0002
#define JOY_BUTTON3         0x0004
#define JOY_BUTTON4         0x0008
#define JOY_BUTTON1CHG      0x0100
#define JOY_BUTTON2CHG      0x0200
#define JOY_BUTTON3CHG      0x0400
#define JOY_BUTTON4CHG      0x0800

/* joystick ID constants */
#define JOYSTICKID1         0
#define JOYSTICKID2         1

/* joystick device capabilities data structure */
typedef struct joycaps_tag {
    UINT wMid;                  /* manufacturer ID */
    UINT wPid;                  /* product ID */
    char szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT wXmin;                 /* minimum x position value */
    UINT wXmax;                 /* maximum x position value */
    UINT wYmin;                 /* minimum y position value */
    UINT wYmax;                 /* maximum y position value */
    UINT wZmin;                 /* minimum z position value */
    UINT wZmax;                 /* maximum z position value */
    UINT wNumButtons;           /* number of buttons */
    UINT wPeriodMin;            /* minimum message period when captured */
    UINT wPeriodMax;            /* maximum message period when captured */
    } JOYCAPS;
typedef JOYCAPS       *PJOYCAPS;
typedef JOYCAPS NEAR *NPJOYCAPS;
typedef JOYCAPS FAR  *LPJOYCAPS;

/* joystick information data structure */
typedef struct joyinfo_tag {
    UINT wXpos;                 /* x position */
    UINT wYpos;                 /* y position */
    UINT wZpos;                 /* z position */
    UINT wButtons;              /* button states */
    } JOYINFO;
typedef JOYINFO       *PJOYINFO;
typedef JOYINFO NEAR *NPJOYINFO;
typedef JOYINFO FAR  *LPJOYINFO;

/* joystick function prototypes */
UINT WINAPI joyGetDevCaps(UINT uJoyID, JOYCAPS FAR* lpCaps, UINT uSize);
UINT WINAPI joyGetNumDevs(void);
UINT WINAPI joyGetPos(UINT uJoyID, JOYINFO FAR* lpInfo);
UINT WINAPI joyGetThreshold(UINT uJoyID, UINT FAR* lpuThreshold);
UINT WINAPI joyReleaseCapture(UINT uJoyID);
UINT WINAPI joySetCapture(HWND hwnd, UINT uJoyID, UINT uPeriod,
    BOOL bChanged);
UINT WINAPI joySetThreshold(UINT uJoyID, UINT uThreshold);
UINT WINAPI joySetCalibration(UINT uJoyID, UINT FAR* puXbase, /* ;Internal */
    UINT FAR* puXdelta, UINT FAR* puYbase, UINT FAR* puYdelta,/* ;Internal */
    UINT FAR* puZbase, UINT FAR* puZdelta);                   /* ;Internal */

#endif  /* ifndef MMNOJOY */


#ifndef MMNOMMIO
/****************************************************************************

                        Multimedia File I/O support

****************************************************************************/

/* MMIO error return values */
#define MMIOERR_BASE            256
#define MMIOERR_FILENOTFOUND    (MMIOERR_BASE + 1)  /* file not found */
#define MMIOERR_OUTOFMEMORY     (MMIOERR_BASE + 2)  /* out of memory */
#define MMIOERR_CANNOTOPEN      (MMIOERR_BASE + 3)  /* cannot open */
#define MMIOERR_CANNOTCLOSE     (MMIOERR_BASE + 4)  /* cannot close */
#define MMIOERR_CANNOTREAD      (MMIOERR_BASE + 5)  /* cannot read */
#define MMIOERR_CANNOTWRITE     (MMIOERR_BASE + 6)  /* cannot write */
#define MMIOERR_CANNOTSEEK      (MMIOERR_BASE + 7)  /* cannot seek */
#define MMIOERR_CANNOTEXPAND    (MMIOERR_BASE + 8)  /* cannot expand file */
#define MMIOERR_CHUNKNOTFOUND   (MMIOERR_BASE + 9)  /* chunk not found */
#define MMIOERR_UNBUFFERED      (MMIOERR_BASE + 10) /* file is unbuffered */

/* MMIO constants */
#define CFSEPCHAR       '+'             /* compound file name separator char. */

/* MMIO data types */
typedef DWORD           FOURCC;         /* a four character code */
typedef char _huge *    HPSTR;          /* a huge version of LPSTR */
DECLARE_HANDLE(HMMIO);                  /* a handle to an open file */
typedef LRESULT (CALLBACK MMIOPROC)(LPSTR lpmmioinfo, UINT uMessage,
            LPARAM lParam1, LPARAM lParam2);
typedef MMIOPROC FAR *LPMMIOPROC;

/* general MMIO information data structure */
typedef struct _MMIOINFO
{
        /* general fields */
        DWORD           dwFlags;        /* general status flags */
        FOURCC          fccIOProc;      /* pointer to I/O procedure */
        LPMMIOPROC      pIOProc;        /* pointer to I/O procedure */
        UINT            wErrorRet;      /* place for error to be returned */
        HTASK           htask;          /* alternate local task */

        /* fields maintained by MMIO functions during buffered I/O */
        LONG            cchBuffer;      /* size of I/O buffer (or 0L) */
        HPSTR           pchBuffer;      /* start of I/O buffer (or NULL) */
        HPSTR           pchNext;        /* pointer to next byte to read/write */
        HPSTR           pchEndRead;     /* pointer to last valid byte to read */
        HPSTR           pchEndWrite;    /* pointer to last byte to write */
        LONG            lBufOffset;     /* disk offset of start of buffer */

        /* fields maintained by I/O procedure */
        LONG            lDiskOffset;    /* disk offset of next read or write */
        DWORD           adwInfo[3];     /* data specific to type of MMIOPROC */

        /* other fields maintained by MMIO */
        DWORD           dwReserved1;    /* reserved for MMIO use */
        DWORD           dwReserved2;    /* reserved for MMIO use */
        HMMIO           hmmio;          /* handle to open file */
} MMIOINFO;
typedef MMIOINFO       *PMMIOINFO;
typedef MMIOINFO NEAR *NPMMIOINFO;
typedef MMIOINFO FAR  *LPMMIOINFO;

/* RIFF chunk information data structure */
typedef struct _MMCKINFO
{
        FOURCC          ckid;           /* chunk ID */
        DWORD           cksize;         /* chunk size */
        FOURCC          fccType;        /* form type or list type */
        DWORD           dwDataOffset;   /* offset of data portion of chunk */
        DWORD           dwFlags;        /* flags used by MMIO functions */
} MMCKINFO;
typedef MMCKINFO       *PMMCKINFO;
typedef MMCKINFO NEAR *NPMMCKINFO;
typedef MMCKINFO FAR  *LPMMCKINFO;

/* bit field masks */
#define MMIO_RWMODE     0x00000003      /* open file for reading/writing/both */
#define MMIO_SHAREMODE  0x00000070      /* file sharing mode number */

/* constants for dwFlags field of MMIOINFO */
#define MMIO_CREATE     0x00001000      /* create new file (or truncate file) */
#define MMIO_PARSE      0x00000100      /* parse new file returning path */
#define MMIO_DELETE     0x00000200      /* create new file (or truncate file) */
#define MMIO_EXIST      0x00004000      /* checks for existence of file */
#define MMIO_ALLOCBUF   0x00010000      /* mmioOpen() should allocate a buffer */
#define MMIO_GETTEMP    0x00020000      /* mmioOpen() should retrieve temp name */

#define MMIO_DIRTY      0x10000000      /* I/O buffer is dirty */

#define MMIO_OPEN_VALID 0x0003FFFF      /* valid flags for mmioOpen */ /* ;Internal */
#define	MMIO_FLUSH_VALID MMIO_EMPTYBUF	/* valid flags for mmioFlush */ /* ;Internal */
#define	MMIO_ADVANCE_VALID (MMIO_WRITE | MMIO_READ)	/* valid flags for mmioAdvance */ /* ;Internal */
#define	MMIO_FOURCC_VALID MMIO_TOUPPER	/* valid flags for mmioStringToFOURCC */ /* ;Internal */
#define	MMIO_DESCEND_VALID (MMIO_FINDCHUNK | MMIO_FINDRIFF | MMIO_FINDLIST) /* ;Internal */
#define	MMIO_CREATE_VALID (MMIO_CREATERIFF | MMIO_CREATELIST)	/* ;Internal */

/* read/write mode numbers (bit field MMIO_RWMODE) */
#define MMIO_READ       0x00000000      /* open file for reading only */
#define MMIO_WRITE      0x00000001      /* open file for writing only */
#define MMIO_READWRITE  0x00000002      /* open file for reading and writing */

/* share mode numbers (bit field MMIO_SHAREMODE) */
#define MMIO_COMPAT     0x00000000      /* compatibility mode */
#define MMIO_EXCLUSIVE  0x00000010      /* exclusive-access mode */
#define MMIO_DENYWRITE  0x00000020      /* deny writing to other processes */
#define MMIO_DENYREAD   0x00000030      /* deny reading to other processes */
#define MMIO_DENYNONE   0x00000040      /* deny nothing to other processes */

/* various MMIO flags */
#define MMIO_FHOPEN             0x0010  /* mmioClose: keep file handle open */
#define MMIO_EMPTYBUF           0x0010  /* mmioFlush: empty the I/O buffer */
#define MMIO_TOUPPER            0x0010  /* mmioStringToFOURCC: to u-case */
#define MMIO_INSTALLPROC    0x00010000  /* mmioInstallIOProc: install MMIOProc */
#define MMIO_GLOBALPROC     0x10000000  /* mmioInstallIOProc: install globally */
#define MMIO_REMOVEPROC     0x00020000  /* mmioInstallIOProc: remove MMIOProc */
#define MMIO_FINDPROC       0x00040000  /* mmioInstallIOProc: find an MMIOProc */
#define MMIO_FINDCHUNK          0x0010  /* mmioDescend: find a chunk by ID */
#define MMIO_FINDRIFF           0x0020  /* mmioDescend: find a LIST chunk */
#define MMIO_FINDLIST           0x0040  /* mmioDescend: find a RIFF chunk */
#define MMIO_CREATERIFF         0x0020  /* mmioCreateChunk: make a LIST chunk */
#define MMIO_CREATELIST         0x0040  /* mmioCreateChunk: make a RIFF chunk */

#define MMIO_VALIDPROC      0x10070000  /* valid for mmioInstallIOProc */ /* ;Internal */

/* message numbers for MMIOPROC I/O procedure functions */
#define MMIOM_READ      MMIO_READ       /* read */
#define MMIOM_WRITE    MMIO_WRITE       /* write */
#define MMIOM_SEEK              2       /* seek to a new position in file */
#define MMIOM_OPEN              3       /* open file */
#define MMIOM_CLOSE             4       /* close file */
#define MMIOM_WRITEFLUSH        5       /* write and flush */

#if (WINVER >= 0x030a)
#define MMIOM_RENAME            6       /* rename specified file */
#endif /* ifdef WINVER >= 0x030a */

#define MMIOM_USER         0x8000       /* beginning of user-defined messages */

/* standard four character codes */
#define FOURCC_RIFF     mmioFOURCC('R', 'I', 'F', 'F')
#define FOURCC_LIST     mmioFOURCC('L', 'I', 'S', 'T')

/* four character codes used to identify standard built-in I/O procedures */
#define FOURCC_DOS      mmioFOURCC('D', 'O', 'S', ' ')
#define FOURCC_MEM      mmioFOURCC('M', 'E', 'M', ' ')

/* flags for mmioSeek() */
#ifndef SEEK_SET
#define SEEK_SET        0               /* seek to an absolute position */
#define SEEK_CUR        1               /* seek relative to current position */
#define SEEK_END        2               /* seek relative to end of file */
#endif  /* ifndef SEEK_SET */

/* other constants */
#define MMIO_DEFAULTBUFFER      8192    /* default buffer size */

/* MMIO macros */
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
                ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )

/* MMIO function prototypes */
FOURCC WINAPI mmioStringToFOURCC(LPCSTR sz, UINT uFlags);
LPMMIOPROC WINAPI mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc,
    DWORD dwFlags);
HMMIO WINAPI mmioOpen(LPSTR szFileName, MMIOINFO FAR* lpmmioinfo,
    DWORD dwOpenFlags);

#if (WINVER >= 0x030a)
UINT WINAPI mmioRename(LPCSTR szFileName, LPCSTR szNewFileName,
     MMIOINFO FAR* lpmmioinfo, DWORD dwRenameFlags);
#endif /* ifdef WINVER >= 0x030a */

UINT WINAPI mmioClose(HMMIO hmmio, UINT uFlags);
LONG WINAPI mmioRead(HMMIO hmmio, HPSTR pch, LONG cch);
LONG WINAPI mmioWrite(HMMIO hmmio, const char _huge* pch, LONG cch);
LONG WINAPI mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin);
UINT WINAPI mmioGetInfo(HMMIO hmmio, MMIOINFO FAR* lpmmioinfo, UINT uFlags);
UINT WINAPI mmioSetInfo(HMMIO hmmio, const MMIOINFO FAR* lpmmioinfo, UINT uFlags);
UINT WINAPI mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer,
    UINT uFlags);
UINT WINAPI mmioFlush(HMMIO hmmio, UINT uFlags);
UINT WINAPI mmioAdvance(HMMIO hmmio, MMIOINFO FAR* lpmmioinfo, UINT uFlags);
LRESULT WINAPI mmioSendMessage(HMMIO hmmio, UINT uMessage,
    LPARAM lParam1, LPARAM lParam2);
UINT WINAPI mmioDescend(HMMIO hmmio, MMCKINFO FAR* lpck,
    const MMCKINFO FAR* lpckParent, UINT uFlags);
UINT WINAPI mmioAscend(HMMIO hmmio, MMCKINFO FAR* lpck, UINT uFlags);
UINT WINAPI mmioCreateChunk(HMMIO hmmio, MMCKINFO FAR* lpck, UINT uFlags);

#endif  /* ifndef MMNOMMIO */


#ifndef MMNOMCI
/****************************************************************************

                            MCI support

****************************************************************************/

typedef UINT (CALLBACK *YIELDPROC) (UINT uDeviceID, DWORD dwYieldData);

/* MCI function prototypes */
DWORD WINAPI mciSendCommand (UINT uDeviceID, UINT uMessage,
    DWORD dwParam1, DWORD dwParam2);
DWORD WINAPI mciSendString (LPCSTR lpstrCommand,
    LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
UINT WINAPI mciGetDeviceID (LPCSTR lpstrName);
UINT WINAPI mciGetDeviceIDFromElementID (DWORD dwElementID,
    LPCSTR lpstrType);
BOOL WINAPI mciGetErrorString (DWORD wError, LPSTR lpstrBuffer,
    UINT uLength);
BOOL WINAPI mciSetYieldProc (UINT uDeviceID, YIELDPROC fpYieldProc,
    DWORD dwYieldData);

#if (WINVER >= 0x030a)
HTASK WINAPI mciGetCreatorTask(UINT uDeviceID);
YIELDPROC WINAPI mciGetYieldProc (UINT uDeviceID, DWORD FAR* lpdwYieldData);
#endif /* ifdef WINVER >= 0x030a */

#if (WINVER < 0x030a)
BOOL WINAPI mciExecute (LPCSTR lpstrCommand);
#endif /* ifdef WINVER < 0x030a */

/* MCI error return values */
#define MCIERR_INVALID_DEVICE_ID        (MCIERR_BASE + 1)
#define MCIERR_UNRECOGNIZED_KEYWORD     (MCIERR_BASE + 3)
#define MCIERR_UNRECOGNIZED_COMMAND     (MCIERR_BASE + 5)
#define MCIERR_HARDWARE                 (MCIERR_BASE + 6)
#define MCIERR_INVALID_DEVICE_NAME      (MCIERR_BASE + 7)
#define MCIERR_OUT_OF_MEMORY            (MCIERR_BASE + 8)
#define MCIERR_DEVICE_OPEN              (MCIERR_BASE + 9)
#define MCIERR_CANNOT_LOAD_DRIVER       (MCIERR_BASE + 10)
#define MCIERR_MISSING_COMMAND_STRING   (MCIERR_BASE + 11)
#define MCIERR_PARAM_OVERFLOW           (MCIERR_BASE + 12)
#define MCIERR_MISSING_STRING_ARGUMENT  (MCIERR_BASE + 13)
#define MCIERR_BAD_INTEGER              (MCIERR_BASE + 14)
#define MCIERR_PARSER_INTERNAL          (MCIERR_BASE + 15)
#define MCIERR_DRIVER_INTERNAL          (MCIERR_BASE + 16)
#define MCIERR_MISSING_PARAMETER        (MCIERR_BASE + 17)
#define MCIERR_UNSUPPORTED_FUNCTION     (MCIERR_BASE + 18)
#define MCIERR_FILE_NOT_FOUND           (MCIERR_BASE + 19)
#define MCIERR_DEVICE_NOT_READY         (MCIERR_BASE + 20)
#define MCIERR_INTERNAL                 (MCIERR_BASE + 21)
#define MCIERR_DRIVER                   (MCIERR_BASE + 22)
#define MCIERR_CANNOT_USE_ALL           (MCIERR_BASE + 23)
#define MCIERR_MULTIPLE                 (MCIERR_BASE + 24)
#define MCIERR_EXTENSION_NOT_FOUND      (MCIERR_BASE + 25)
#define MCIERR_OUTOFRANGE               (MCIERR_BASE + 26)
#define MCIERR_FLAGS_NOT_COMPATIBLE     (MCIERR_BASE + 28)
#define MCIERR_FILE_NOT_SAVED           (MCIERR_BASE + 30)
#define MCIERR_DEVICE_TYPE_REQUIRED     (MCIERR_BASE + 31)
#define MCIERR_DEVICE_LOCKED            (MCIERR_BASE + 32)
#define MCIERR_DUPLICATE_ALIAS          (MCIERR_BASE + 33)
#define MCIERR_BAD_CONSTANT             (MCIERR_BASE + 34)
#define MCIERR_MUST_USE_SHAREABLE       (MCIERR_BASE + 35)
#define MCIERR_MISSING_DEVICE_NAME      (MCIERR_BASE + 36)
#define MCIERR_BAD_TIME_FORMAT          (MCIERR_BASE + 37)
#define MCIERR_NO_CLOSING_QUOTE         (MCIERR_BASE + 38)
#define MCIERR_DUPLICATE_FLAGS          (MCIERR_BASE + 39)
#define MCIERR_INVALID_FILE             (MCIERR_BASE + 40)
#define MCIERR_NULL_PARAMETER_BLOCK     (MCIERR_BASE + 41)
#define MCIERR_UNNAMED_RESOURCE         (MCIERR_BASE + 42)
#define MCIERR_NEW_REQUIRES_ALIAS       (MCIERR_BASE + 43)
#define MCIERR_NOTIFY_ON_AUTO_OPEN      (MCIERR_BASE + 44)
#define MCIERR_NO_ELEMENT_ALLOWED       (MCIERR_BASE + 45)
#define MCIERR_NONAPPLICABLE_FUNCTION   (MCIERR_BASE + 46)
#define MCIERR_ILLEGAL_FOR_AUTO_OPEN    (MCIERR_BASE + 47)
#define MCIERR_FILENAME_REQUIRED        (MCIERR_BASE + 48)
#define MCIERR_EXTRA_CHARACTERS         (MCIERR_BASE + 49)
#define MCIERR_DEVICE_NOT_INSTALLED     (MCIERR_BASE + 50)
#define MCIERR_GET_CD                   (MCIERR_BASE + 51)
#define MCIERR_SET_CD                   (MCIERR_BASE + 52)
#define MCIERR_SET_DRIVE                (MCIERR_BASE + 53)
#define MCIERR_DEVICE_LENGTH            (MCIERR_BASE + 54)
#define MCIERR_DEVICE_ORD_LENGTH        (MCIERR_BASE + 55)
#define MCIERR_NO_INTEGER               (MCIERR_BASE + 56)

#define MCIERR_WAVE_OUTPUTSINUSE        (MCIERR_BASE + 64)
#define MCIERR_WAVE_SETOUTPUTINUSE      (MCIERR_BASE + 65)
#define MCIERR_WAVE_INPUTSINUSE         (MCIERR_BASE + 66)
#define MCIERR_WAVE_SETINPUTINUSE       (MCIERR_BASE + 67)
#define MCIERR_WAVE_OUTPUTUNSPECIFIED   (MCIERR_BASE + 68)
#define MCIERR_WAVE_INPUTUNSPECIFIED    (MCIERR_BASE + 69)
#define MCIERR_WAVE_OUTPUTSUNSUITABLE   (MCIERR_BASE + 70)
#define MCIERR_WAVE_SETOUTPUTUNSUITABLE (MCIERR_BASE + 71)
#define MCIERR_WAVE_INPUTSUNSUITABLE    (MCIERR_BASE + 72)
#define MCIERR_WAVE_SETINPUTUNSUITABLE  (MCIERR_BASE + 73)

#define MCIERR_SEQ_DIV_INCOMPATIBLE     (MCIERR_BASE + 80)
#define MCIERR_SEQ_PORT_INUSE           (MCIERR_BASE + 81)
#define MCIERR_SEQ_PORT_NONEXISTENT     (MCIERR_BASE + 82)
#define MCIERR_SEQ_PORT_MAPNODEVICE     (MCIERR_BASE + 83)
#define MCIERR_SEQ_PORT_MISCERROR       (MCIERR_BASE + 84)
#define MCIERR_SEQ_TIMER                (MCIERR_BASE + 85)
#define MCIERR_SEQ_PORTUNSPECIFIED      (MCIERR_BASE + 86)
#define MCIERR_SEQ_NOMIDIPRESENT        (MCIERR_BASE + 87)

#define MCIERR_NO_WINDOW                (MCIERR_BASE + 90)
#define MCIERR_CREATEWINDOW             (MCIERR_BASE + 91)
#define MCIERR_FILE_READ                (MCIERR_BASE + 92)
#define MCIERR_FILE_WRITE               (MCIERR_BASE + 93)

/* all custom device driver errors must be >= than this value */
#define MCIERR_CUSTOM_DRIVER_BASE       (MCIERR_BASE + 256)

/* MCI command message identifiers */
#define MCI_OPEN                        0x0803
#define MCI_CLOSE                       0x0804
#define MCI_ESCAPE                      0x0805
#define MCI_PLAY                        0x0806
#define MCI_SEEK                        0x0807
#define MCI_STOP                        0x0808
#define MCI_PAUSE                       0x0809
#define MCI_INFO                        0x080A
#define MCI_GETDEVCAPS                  0x080B
#define MCI_SPIN                        0x080C
#define MCI_SET                         0x080D
#define MCI_STEP                        0x080E
#define MCI_RECORD                      0x080F
#define MCI_SYSINFO                     0x0810
#define MCI_BREAK                       0x0811
#define MCI_SOUND                       0x0812
#define MCI_SAVE                        0x0813
#define MCI_STATUS                      0x0814
#define MCI_CUE                         0x0830
#define MCI_REALIZE                     0x0840
#define MCI_WINDOW                      0x0841
#define MCI_PUT                         0x0842
#define MCI_WHERE                       0x0843
#define MCI_FREEZE                      0x0844
#define MCI_UNFREEZE                    0x0845
#define MCI_LOAD                        0x0850
#define MCI_CUT                         0x0851
#define MCI_COPY                        0x0852
#define MCI_PASTE                       0x0853
#define MCI_UPDATE                      0x0854
#define MCI_RESUME                      0x0855
#define MCI_DELETE                      0x0856

/* all custom MCI command messages must be >= than this value */
#define MCI_USER_MESSAGES               (0x400 + DRV_MCI_FIRST)


/* device ID for "all devices" */
#define MCI_ALL_DEVICE_ID               0xFFFF

/* constants for predefined MCI device types */
#define MCI_DEVTYPE_VCR                 (MCI_STRING_OFFSET + 1)
#define MCI_DEVTYPE_VIDEODISC           (MCI_STRING_OFFSET + 2)
#define MCI_DEVTYPE_OVERLAY             (MCI_STRING_OFFSET + 3)
#define MCI_DEVTYPE_CD_AUDIO            (MCI_STRING_OFFSET + 4)
#define MCI_DEVTYPE_DAT                 (MCI_STRING_OFFSET + 5)
#define MCI_DEVTYPE_SCANNER             (MCI_STRING_OFFSET + 6)
#define MCI_DEVTYPE_ANIMATION           (MCI_STRING_OFFSET + 7)
#define MCI_DEVTYPE_DIGITAL_VIDEO       (MCI_STRING_OFFSET + 8)
#define MCI_DEVTYPE_OTHER               (MCI_STRING_OFFSET + 9)
#define MCI_DEVTYPE_WAVEFORM_AUDIO      (MCI_STRING_OFFSET + 10)
#define MCI_DEVTYPE_SEQUENCER           (MCI_STRING_OFFSET + 11)

#define MCI_DEVTYPE_FIRST               MCI_DEVTYPE_VCR
#define MCI_DEVTYPE_LAST                MCI_DEVTYPE_SEQUENCER

/* return values for 'status mode' command */
#define MCI_MODE_NOT_READY              (MCI_STRING_OFFSET + 12)
#define MCI_MODE_STOP                   (MCI_STRING_OFFSET + 13)
#define MCI_MODE_PLAY                   (MCI_STRING_OFFSET + 14)
#define MCI_MODE_RECORD                 (MCI_STRING_OFFSET + 15)
#define MCI_MODE_SEEK                   (MCI_STRING_OFFSET + 16)
#define MCI_MODE_PAUSE                  (MCI_STRING_OFFSET + 17)
#define MCI_MODE_OPEN                   (MCI_STRING_OFFSET + 18)

/* constants used in 'set time format' and 'status time format' commands */
#define MCI_FORMAT_MILLISECONDS         0
#define MCI_FORMAT_HMS                  1
#define MCI_FORMAT_MSF                  2
#define MCI_FORMAT_FRAMES               3
#define MCI_FORMAT_SMPTE_24             4
#define MCI_FORMAT_SMPTE_25             5
#define MCI_FORMAT_SMPTE_30             6
#define MCI_FORMAT_SMPTE_30DROP         7
#define MCI_FORMAT_BYTES                8
#define MCI_FORMAT_SAMPLES              9
#define MCI_FORMAT_TMSF                 10

/* MCI time format conversion macros */
#define MCI_MSF_MINUTE(msf)             ((BYTE)(msf))
#define MCI_MSF_SECOND(msf)             ((BYTE)(((WORD)(msf)) >> 8))
#define MCI_MSF_FRAME(msf)              ((BYTE)((msf)>>16))

#define MCI_MAKE_MSF(m, s, f)           ((DWORD)(((BYTE)(m) | \
                                                  ((WORD)(s)<<8)) | \
                                                 (((DWORD)(BYTE)(f))<<16)))

#define MCI_TMSF_TRACK(tmsf)            ((BYTE)(tmsf))
#define MCI_TMSF_MINUTE(tmsf)           ((BYTE)(((WORD)(tmsf)) >> 8))
#define MCI_TMSF_SECOND(tmsf)           ((BYTE)((tmsf)>>16))
#define MCI_TMSF_FRAME(tmsf)            ((BYTE)((tmsf)>>24))

#define MCI_MAKE_TMSF(t, m, s, f)       ((DWORD)(((BYTE)(t) | \
                                                  ((WORD)(m)<<8)) | \
                                                 (((DWORD)(BYTE)(s) | \
                                                   ((WORD)(f)<<8))<<16)))

#define MCI_HMS_HOUR(hms)               ((BYTE)(hms))
#define MCI_HMS_MINUTE(hms)             ((BYTE)(((WORD)(hms)) >> 8))
#define MCI_HMS_SECOND(hms)             ((BYTE)((hms)>>16))

#define MCI_MAKE_HMS(h, m, s)           ((DWORD)(((BYTE)(h) | \
                                                  ((WORD)(m)<<8)) | \
                                                 (((DWORD)(BYTE)(s))<<16)))


/* flags for wParam of MM_MCINOTIFY message */
#define MCI_NOTIFY_SUCCESSFUL           0x0001
#define MCI_NOTIFY_SUPERSEDED           0x0002
#define MCI_NOTIFY_ABORTED              0x0004
#define MCI_NOTIFY_FAILURE              0x0008


/* common flags for dwFlags parameter of MCI command messages */
#define MCI_NOTIFY                      0x00000001L
#define MCI_WAIT                        0x00000002L
#define MCI_FROM                        0x00000004L
#define MCI_TO                          0x00000008L
#define MCI_TRACK                       0x00000010L

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OPEN_SHAREABLE              0x00000100L
#define MCI_OPEN_ELEMENT                0x00000200L
#define MCI_OPEN_ALIAS                  0x00000400L
#define MCI_OPEN_ELEMENT_ID             0x00000800L
#define MCI_OPEN_TYPE_ID                0x00001000L
#define MCI_OPEN_TYPE                   0x00002000L

/* flags for dwFlags parameter of MCI_SEEK command message */
#define MCI_SEEK_TO_START               0x00000100L
#define MCI_SEEK_TO_END                 0x00000200L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_STATUS_ITEM                 0x00000100L
#define MCI_STATUS_START                0x00000200L

/* flags for dwItem field of the MCI_STATUS_PARMS parameter block */
#define MCI_STATUS_LENGTH               0x00000001L
#define MCI_STATUS_POSITION             0x00000002L
#define MCI_STATUS_NUMBER_OF_TRACKS     0x00000003L
#define MCI_STATUS_MODE                 0x00000004L
#define MCI_STATUS_MEDIA_PRESENT        0x00000005L
#define MCI_STATUS_TIME_FORMAT          0x00000006L
#define MCI_STATUS_READY                0x00000007L
#define MCI_STATUS_CURRENT_TRACK        0x00000008L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_INFO_PRODUCT                0x00000100L
#define MCI_INFO_FILE                   0x00000200L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_GETDEVCAPS_ITEM             0x00000100L

/* flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_GETDEVCAPS_CAN_RECORD       0x00000001L
#define MCI_GETDEVCAPS_HAS_AUDIO        0x00000002L
#define MCI_GETDEVCAPS_HAS_VIDEO        0x00000003L
#define MCI_GETDEVCAPS_DEVICE_TYPE      0x00000004L
#define MCI_GETDEVCAPS_USES_FILES       0x00000005L
#define MCI_GETDEVCAPS_COMPOUND_DEVICE  0x00000006L
#define MCI_GETDEVCAPS_CAN_EJECT        0x00000007L
#define MCI_GETDEVCAPS_CAN_PLAY         0x00000008L
#define MCI_GETDEVCAPS_CAN_SAVE         0x00000009L

/* flags for dwFlags parameter of MCI_SYSINFO command message */
#define MCI_SYSINFO_QUANTITY            0x00000100L
#define MCI_SYSINFO_OPEN                0x00000200L
#define MCI_SYSINFO_NAME                0x00000400L
#define MCI_SYSINFO_INSTALLNAME         0x00000800L

/* flags for dwFlags parameter of MCI_SET command message */
#define MCI_SET_DOOR_OPEN               0x00000100L
#define MCI_SET_DOOR_CLOSED             0x00000200L
#define MCI_SET_TIME_FORMAT             0x00000400L
#define MCI_SET_AUDIO                   0x00000800L
#define MCI_SET_VIDEO                   0x00001000L
#define MCI_SET_ON                      0x00002000L
#define MCI_SET_OFF                     0x00004000L

/* flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS */
#define MCI_SET_AUDIO_ALL               0x00000000L
#define MCI_SET_AUDIO_LEFT              0x00000001L
#define MCI_SET_AUDIO_RIGHT             0x00000002L

/* flags for dwFlags parameter of MCI_BREAK command message */
#define MCI_BREAK_KEY                   0x00000100L
#define MCI_BREAK_HWND                  0x00000200L
#define MCI_BREAK_OFF                   0x00000400L

/* flags for dwFlags parameter of MCI_RECORD command message */
#define MCI_RECORD_INSERT               0x00000100L
#define MCI_RECORD_OVERWRITE            0x00000200L

/* flags for dwFlags parameter of MCI_SOUND command message */
#define MCI_SOUND_NAME                  0x00000100L

/* flags for dwFlags parameter of MCI_SAVE command message */
#define MCI_SAVE_FILE                   0x00000100L

/* flags for dwFlags parameter of MCI_LOAD command message */
#define MCI_LOAD_FILE                   0x00000100L

/* generic parameter block for MCI command messages with no special parameters */
typedef struct tagMCI_GENERIC_PARMS {
    DWORD   dwCallback;
} MCI_GENERIC_PARMS;
typedef MCI_GENERIC_PARMS FAR *LPMCI_GENERIC_PARMS;

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
} MCI_OPEN_PARMS;
typedef MCI_OPEN_PARMS FAR *LPMCI_OPEN_PARMS;

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_PLAY_PARMS;
typedef MCI_PLAY_PARMS FAR *LPMCI_PLAY_PARMS;

/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
} MCI_SEEK_PARMS;
typedef MCI_SEEK_PARMS FAR *LPMCI_SEEK_PARMS;

/* parameter block for MCI_STATUS command message */
typedef struct tagMCI_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
} MCI_STATUS_PARMS;
typedef MCI_STATUS_PARMS FAR * LPMCI_STATUS_PARMS;

/* parameter block for MCI_INFO command message */
typedef struct tagMCI_INFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMS;
typedef MCI_INFO_PARMS FAR * LPMCI_INFO_PARMS;

/* parameter block for MCI_GETDEVCAPS command message */
typedef struct tagMCI_GETDEVCAPS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
} MCI_GETDEVCAPS_PARMS;
typedef MCI_GETDEVCAPS_PARMS FAR * LPMCI_GETDEVCAPS_PARMS;

/* parameter block for MCI_SYSINFO command message */
typedef struct tagMCI_SYSINFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
    UINT    wReserved0;
} MCI_SYSINFO_PARMS;
typedef MCI_SYSINFO_PARMS FAR * LPMCI_SYSINFO_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
} MCI_SET_PARMS;
typedef MCI_SET_PARMS FAR *LPMCI_SET_PARMS;

/* parameter block for MCI_BREAK command message */
typedef struct tagMCI_BREAK_PARMS {
    DWORD   dwCallback;
    int     nVirtKey;
    UINT    wReserved0;
    HWND    hwndBreak;
    UINT    wReserved1;
} MCI_BREAK_PARMS;
typedef MCI_BREAK_PARMS FAR * LPMCI_BREAK_PARMS;

/* parameter block for MCI_SOUND command message */
typedef struct tagMCI_SOUND_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrSoundName;
} MCI_SOUND_PARMS;
typedef MCI_SOUND_PARMS FAR * LPMCI_SOUND_PARMS;

/* parameter block for MCI_SAVE command message */
typedef struct tagMCI_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_SAVE_PARMS;
typedef MCI_SAVE_PARMS FAR * LPMCI_SAVE_PARMS;

/* parameter block for MCI_LOAD command message */
typedef struct tagMCI_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_LOAD_PARMS;
typedef MCI_LOAD_PARMS FAR * LPMCI_LOAD_PARMS;

/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_RECORD_PARMS;
typedef MCI_RECORD_PARMS FAR *LPMCI_RECORD_PARMS;


/* MCI extensions for videodisc devices */

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_STATUS_MODE) */
#define MCI_VD_MODE_PARK                (MCI_VD_OFFSET + 1)

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE) */
#define MCI_VD_MEDIA_CLV                (MCI_VD_OFFSET + 2)
#define MCI_VD_MEDIA_CAV                (MCI_VD_OFFSET + 3)
#define MCI_VD_MEDIA_OTHER              (MCI_VD_OFFSET + 4)

#define MCI_VD_FORMAT_TRACK             0x4001

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_VD_PLAY_REVERSE             0x00010000L
#define MCI_VD_PLAY_FAST                0x00020000L
#define MCI_VD_PLAY_SPEED               0x00040000L
#define MCI_VD_PLAY_SCAN                0x00080000L
#define MCI_VD_PLAY_SLOW                0x00100000L

/* flag for dwFlags parameter of MCI_SEEK command message */
#define MCI_VD_SEEK_REVERSE             0x00010000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_VD_STATUS_SPEED             0x00004002L
#define MCI_VD_STATUS_FORWARD           0x00004003L
#define MCI_VD_STATUS_MEDIA_TYPE        0x00004004L
#define MCI_VD_STATUS_SIDE              0x00004005L
#define MCI_VD_STATUS_DISC_SIZE         0x00004006L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_VD_GETDEVCAPS_CLV           0x00010000L
#define MCI_VD_GETDEVCAPS_CAV           0x00020000L

#define MCI_VD_SPIN_UP                  0x00010000L
#define MCI_VD_SPIN_DOWN                0x00020000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_VD_GETDEVCAPS_CAN_REVERSE   0x00004002L
#define MCI_VD_GETDEVCAPS_FAST_RATE     0x00004003L
#define MCI_VD_GETDEVCAPS_SLOW_RATE     0x00004004L
#define MCI_VD_GETDEVCAPS_NORMAL_RATE   0x00004005L

/* flags for the dwFlags parameter of MCI_STEP command message */
#define MCI_VD_STEP_FRAMES              0x00010000L
#define MCI_VD_STEP_REVERSE             0x00020000L

/* flag for the MCI_ESCAPE command message */
#define MCI_VD_ESCAPE_STRING            0x00000100L

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VD_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
    } MCI_VD_PLAY_PARMS;
typedef MCI_VD_PLAY_PARMS FAR *LPMCI_VD_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VD_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VD_STEP_PARMS;
typedef MCI_VD_STEP_PARMS FAR *LPMCI_VD_STEP_PARMS;

/* parameter block for MCI_ESCAPE command message */
typedef struct tagMCI_VD_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VD_ESCAPE_PARMS;
typedef MCI_VD_ESCAPE_PARMS FAR *LPMCI_VD_ESCAPE_PARMS;


/* MCI extensions for waveform audio devices */

/* flags for the dwFlags parameter of MCI_OPEN command message */
#define MCI_WAVE_OPEN_BUFFER            0x00010000L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_FORMATTAG          0x00010000L
#define MCI_WAVE_SET_CHANNELS           0x00020000L
#define MCI_WAVE_SET_SAMPLESPERSEC      0x00040000L
#define MCI_WAVE_SET_AVGBYTESPERSEC     0x00080000L
#define MCI_WAVE_SET_BLOCKALIGN         0x00100000L
#define MCI_WAVE_SET_BITSPERSAMPLE      0x00200000L

/* flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages */
#define MCI_WAVE_INPUT                  0x00400000L
#define MCI_WAVE_OUTPUT                 0x00800000L

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_WAVE_STATUS_FORMATTAG       0x00004001L
#define MCI_WAVE_STATUS_CHANNELS        0x00004002L
#define MCI_WAVE_STATUS_SAMPLESPERSEC   0x00004003L
#define MCI_WAVE_STATUS_AVGBYTESPERSEC  0x00004004L
#define MCI_WAVE_STATUS_BLOCKALIGN      0x00004005L
#define MCI_WAVE_STATUS_BITSPERSAMPLE   0x00004006L
#define MCI_WAVE_STATUS_LEVEL           0x00004007L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_ANYINPUT           0x04000000L
#define MCI_WAVE_SET_ANYOUTPUT          0x08000000L

/* flags for the dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_WAVE_GETDEVCAPS_INPUTS      0x00004001L
#define MCI_WAVE_GETDEVCAPS_OUTPUTS     0x00004002L

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_WAVE_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMS;
typedef MCI_WAVE_OPEN_PARMS FAR *LPMCI_WAVE_OPEN_PARMS;

/* parameter block for MCI_DELETE command message */
typedef struct tagMCI_WAVE_DELETE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_WAVE_DELETE_PARMS;
typedef MCI_WAVE_DELETE_PARMS FAR *LPMCI_WAVE_DELETE_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_WAVE_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    UINT    wInput;
    UINT    wReserved0;
    UINT    wOutput;
    UINT    wReserved1;
    UINT    wFormatTag;
    UINT    wReserved2;
    UINT    nChannels;
    UINT    wReserved3;
    DWORD   nSamplesPerSec;
    DWORD   nAvgBytesPerSec;
    UINT    nBlockAlign;
    UINT    wReserved4;
    UINT    wBitsPerSample;
    UINT    wReserved5;
} MCI_WAVE_SET_PARMS;
typedef MCI_WAVE_SET_PARMS FAR * LPMCI_WAVE_SET_PARMS;


/* MCI extensions for MIDI sequencer devices */

/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE) */
#define     MCI_SEQ_DIV_PPQN            (0 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_24        (1 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_25        (2 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30DROP    (3 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30        (4 + MCI_SEQ_OFFSET)

/* flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block */
/* MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER) */
#define     MCI_SEQ_FORMAT_SONGPTR      0x4001
#define     MCI_SEQ_FILE                0x4002
#define     MCI_SEQ_MIDI                0x4003
#define     MCI_SEQ_SMPTE               0x4004
#define     MCI_SEQ_NONE                65533

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_SEQ_STATUS_TEMPO            0x00004002L
#define MCI_SEQ_STATUS_PORT             0x00004003L
#define MCI_SEQ_STATUS_SLAVE            0x00004007L
#define MCI_SEQ_STATUS_MASTER           0x00004008L
#define MCI_SEQ_STATUS_OFFSET           0x00004009L
#define MCI_SEQ_STATUS_DIVTYPE          0x0000400AL

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_SEQ_SET_TEMPO               0x00010000L
#define MCI_SEQ_SET_PORT                0x00020000L
#define MCI_SEQ_SET_SLAVE               0x00040000L
#define MCI_SEQ_SET_MASTER              0x00080000L
#define MCI_SEQ_SET_OFFSET              0x01000000L

/* parameter block for MCI_SET command message */
typedef struct tagMCI_SEQ_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTempo;
    DWORD   dwPort;
    DWORD   dwSlave;
    DWORD   dwMaster;
    DWORD   dwOffset;
} MCI_SEQ_SET_PARMS;
typedef MCI_SEQ_SET_PARMS FAR * LPMCI_SEQ_SET_PARMS;


/* MCI extensions for animation devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_ANIM_OPEN_WS                0x00010000L
#define MCI_ANIM_OPEN_PARENT            0x00020000L
#define MCI_ANIM_OPEN_NOSTATIC          0x00040000L

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_ANIM_PLAY_SPEED             0x00010000L
#define MCI_ANIM_PLAY_REVERSE           0x00020000L
#define MCI_ANIM_PLAY_FAST              0x00040000L
#define MCI_ANIM_PLAY_SLOW              0x00080000L
#define MCI_ANIM_PLAY_SCAN              0x00100000L

/* flags for dwFlags parameter of MCI_STEP command message */
#define MCI_ANIM_STEP_REVERSE           0x00010000L
#define MCI_ANIM_STEP_FRAMES            0x00020000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_ANIM_STATUS_SPEED           0x00004001L
#define MCI_ANIM_STATUS_FORWARD         0x00004002L
#define MCI_ANIM_STATUS_HWND            0x00004003L
#define MCI_ANIM_STATUS_HPAL            0x00004004L
#define MCI_ANIM_STATUS_STRETCH         0x00004005L

/* flags for the dwFlags parameter of MCI_INFO command message */
#define MCI_ANIM_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_ANIM_GETDEVCAPS_CAN_REVERSE 0x00004001L
#define MCI_ANIM_GETDEVCAPS_FAST_RATE   0x00004002L
#define MCI_ANIM_GETDEVCAPS_SLOW_RATE   0x00004003L
#define MCI_ANIM_GETDEVCAPS_NORMAL_RATE 0x00004004L
#define MCI_ANIM_GETDEVCAPS_PALETTES    0x00004006L
#define MCI_ANIM_GETDEVCAPS_CAN_STRETCH 0x00004007L
#define MCI_ANIM_GETDEVCAPS_MAX_WINDOWS 0x00004008L

/* flags for the MCI_REALIZE command message */
#define MCI_ANIM_REALIZE_NORM           0x00010000L
#define MCI_ANIM_REALIZE_BKGD           0x00020000L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_ANIM_WINDOW_HWND            0x00010000L
#define MCI_ANIM_WINDOW_STATE           0x00040000L
#define MCI_ANIM_WINDOW_TEXT            0x00080000L
#define MCI_ANIM_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_ANIM_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block */
/* MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND) */
#define MCI_ANIM_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_ANIM_RECT                   0x00010000L
#define MCI_ANIM_PUT_SOURCE             0x00020000L
#define MCI_ANIM_PUT_DESTINATION        0x00040000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_ANIM_WHERE_SOURCE           0x00020000L
#define MCI_ANIM_WHERE_DESTINATION      0x00040000L

/* flags for dwFlags parameter of MCI_UPDATE command message */
#define MCI_ANIM_UPDATE_HDC             0x00020000L

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_ANIM_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
    UINT    wReserved1;
} MCI_ANIM_OPEN_PARMS;
typedef MCI_ANIM_OPEN_PARMS FAR *LPMCI_ANIM_OPEN_PARMS;

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_ANIM_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_ANIM_PLAY_PARMS;
typedef MCI_ANIM_PLAY_PARMS FAR *LPMCI_ANIM_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_ANIM_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_ANIM_STEP_PARMS;
typedef MCI_ANIM_STEP_PARMS FAR *LPMCI_ANIM_STEP_PARMS;

/* parameter block for MCI_WINDOW command message */
typedef struct tagMCI_ANIM_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    wReserved1;
    UINT    nCmdShow;
    UINT    wReserved2;
    LPCSTR  lpstrText;
} MCI_ANIM_WINDOW_PARMS;
typedef MCI_ANIM_WINDOW_PARMS FAR * LPMCI_ANIM_WINDOW_PARMS;

/* parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages */
typedef struct tagMCI_ANIM_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS FAR * LPMCI_ANIM_RECT_PARMS;

/* parameter block for MCI_UPDATE PARMS */
typedef struct tagMCI_ANIM_UPDATE_PARMS {
    DWORD   dwCallback;
    RECT    rc;
    HDC     hDC;
} MCI_ANIM_UPDATE_PARMS;
typedef MCI_ANIM_UPDATE_PARMS FAR * LPMCI_ANIM_UPDATE_PARMS;


/* MCI extensions for video overlay devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OVLY_OPEN_WS                0x00010000L
#define MCI_OVLY_OPEN_PARENT            0x00020000L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_OVLY_STATUS_HWND            0x00004001L
#define MCI_OVLY_STATUS_STRETCH         0x00004002L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_OVLY_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_OVLY_GETDEVCAPS_CAN_STRETCH 0x00004001L
#define MCI_OVLY_GETDEVCAPS_CAN_FREEZE  0x00004002L
#define MCI_OVLY_GETDEVCAPS_MAX_WINDOWS 0x00004003L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_OVLY_WINDOW_HWND            0x00010000L
#define MCI_OVLY_WINDOW_STATE           0x00040000L
#define MCI_OVLY_WINDOW_TEXT            0x00080000L
#define MCI_OVLY_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_OVLY_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block */
#define MCI_OVLY_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_OVLY_RECT                   0x00010000L
#define MCI_OVLY_PUT_SOURCE             0x00020000L
#define MCI_OVLY_PUT_DESTINATION        0x00040000L
#define MCI_OVLY_PUT_FRAME              0x00080000L
#define MCI_OVLY_PUT_VIDEO              0x00100000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_OVLY_WHERE_SOURCE           0x00020000L
#define MCI_OVLY_WHERE_DESTINATION      0x00040000L
#define MCI_OVLY_WHERE_FRAME            0x00080000L
#define MCI_OVLY_WHERE_VIDEO            0x00100000L

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_OVLY_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
    UINT    wReserved1;
 } MCI_OVLY_OPEN_PARMS;
typedef MCI_OVLY_OPEN_PARMS FAR *LPMCI_OVLY_OPEN_PARMS;

/* parameter block for MCI_WINDOW command message */
typedef struct tagMCI_OVLY_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    wReserved1;
    UINT    nCmdShow;
    UINT    wReserved2;
    LPCSTR  lpstrText;
} MCI_OVLY_WINDOW_PARMS;
typedef MCI_OVLY_WINDOW_PARMS FAR * LPMCI_OVLY_WINDOW_PARMS;

/* parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages */
typedef struct tagMCI_OVLY_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_OVLY_RECT_PARMS;
typedef MCI_OVLY_RECT_PARMS FAR * LPMCI_OVLY_RECT_PARMS;

/* parameter block for MCI_SAVE command message */
typedef struct tagMCI_OVLY_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMS;
typedef MCI_OVLY_SAVE_PARMS FAR * LPMCI_OVLY_SAVE_PARMS;

/* parameter block for MCI_LOAD command message */
typedef struct tagMCI_OVLY_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMS;
typedef MCI_OVLY_LOAD_PARMS FAR * LPMCI_OVLY_LOAD_PARMS;

#endif  /* ifndef MMNOMCI */

/****************************************************************************

                        DISPLAY Driver extensions

****************************************************************************/

#ifndef C1_TRANSPARENT
    #define CAPS1           94          /* other caps */
    #define C1_TRANSPARENT  0x0001      /* new raster cap */
    #define NEWTRANSPARENT  3           /* use with SetBkMode() */

    #define QUERYROPSUPPORT 40          /* use to determine ROP support */
#endif  /* ifndef C1_TRANSPARENT */

/****************************************************************************

                        DIB Driver extensions

****************************************************************************/

#define SELECTDIB       41                      /* DIB.DRV select dib escape */
#define DIBINDEX(n)     MAKELONG((n),0x10FF)


/****************************************************************************

                        ScreenSaver support

    The current application will receive a syscommand of SC_SCREENSAVE just
    before the screen saver is invoked.  If the app wishes to prevent a
    screen save, return non-zero value, otherwise call DefWindowProc().

****************************************************************************/

#ifndef SC_SCREENSAVE

    #define SC_SCREENSAVE   0xF140

#endif  /* ifndef SC_SCREENSAVE */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif  /* _INC_MMSYSTEM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\mmsystem.inc ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;         MMSYSTEM.INC - Multimedia assembly language structures & constants
;
;         Copyright (c) 1990-1992, Microsoft Corp.  All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;     If defined, the following flags inhibit inclusion
;     of the indicated items:
; 
;       MMNODRV          - Installable driver support
;       MMNOSOUND        - Sound support
;       MMNOWAVE         - Waveform support
;       MMNOMIDI         - MIDI support
;       MMNOAUX          - Auxiliary audio support
;       MMNOTIMER        - Timer support
;       MMNOJOY          - Joystick support
;       MMNOMCI          - MCI support
;       MMNOMMIO         - Multimedia file I/O support
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                   General constants and data types
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; general constants
MAXPNAMELEN        equ    32     ; max product name length (including NULL)
MAXERRORLENGTH     equ    128    ; max error text length (including NULL)

; MMTIME data structure
MMTIME	struc
    mmt_wType           dw    ?  ; indicates the contents of the union
    mmt_TimeUnion       dd    ?  ; union
MMTIME	ends

SMPTE struc
    smpte_hour      db    ?  ; hours
    smpte_min       db    ?  ; minutes
    smpte_sec       db    ?  ; seconds
    smpte_frame     db    ?  ; frames
    smpte_fps       db    ?  ; frames per second
    smpte_reserved  db    ?  ; pad
SMPTE ends

; types for wType field in MMTIME struct
TIME_MS         equ    0001h   ; time in milliseconds
TIME_SAMPLES    equ    0002h   ; number of wave samples
TIME_BYTES      equ    0004h   ; current byte offset
TIME_SMPTE      equ    0008h   ; SMPTE time
TIME_MIDI       equ    0010h   ; MIDI time


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                   Multimedia Extensions Window Messages
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MM_JOY1MOVE         equ    3A0h            ; joystick
MM_JOY2MOVE         equ    3A1h
MM_JOY1ZMOVE        equ    3A2h
MM_JOY2ZMOVE        equ    3A3h
MM_JOY1BUTTONDOWN   equ    3B5h
MM_JOY2BUTTONDOWN   equ    3B6h
MM_JOY1BUTTONUP     equ    3B7h
MM_JOY2BUTTONUP     equ    3B8h

MM_MCINOTIFY        equ    3B9h            ; MCI
MM_MCISYSTEM_STRING equ    3CAh

MM_WOM_OPEN         equ    3BBh            ; waveform output
MM_WOM_CLOSE        equ    3BCh
MM_WOM_DONE         equ    3BDh

MM_WIM_OPEN         equ    3BEh            ; waveform input
MM_WIM_CLOSE        equ    3BFh
MM_WIM_DATA         equ    3C0h

MM_MIM_OPEN         equ    3C1h            ; MIDI input
MM_MIM_CLOSE        equ    3C2h
MM_MIM_DATA         equ    3C3h
MM_MIM_LONGDATA     equ    3C4h
MM_MIM_ERROR        equ    3C5h
MM_MIM_LONGERROR    equ    3C6h

MM_MOM_OPEN         equ    3C7h            ; MIDI output
MM_MOM_CLOSE        equ    3C8h
MM_MOM_DONE         equ    3C9h


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;               String resource number bases (internal use)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MMSYSERR_BASE          equ    0
WAVERR_BASE            equ    32
MIDIERR_BASE           equ    64
TIMERR_BASE            equ    96
JOYERR_BASE            equ    160
MCIERR_BASE            equ    256

MCI_STRING_OFFSET      equ    512
MCI_VD_OFFSET          equ    1024
MCI_CD_OFFSET          equ    1088
MCI_WAVE_OFFSET        equ    1152
MCI_SEQ_OFFSET         equ    1216

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       General error return values
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; general error return values
MMSYSERR_NOERROR      equ    0                    ; no error
MMSYSERR_ERROR        equ    (MMSYSERR_BASE + 1)  ; unspecified error
MMSYSERR_BADDEVICEID  equ    (MMSYSERR_BASE + 2)  ; device ID out of range
MMSYSERR_NOTENABLED   equ    (MMSYSERR_BASE + 3)  ; driver failed enable
MMSYSERR_ALLOCATED    equ    (MMSYSERR_BASE + 4)  ; device already allocated
MMSYSERR_INVALHANDLE  equ    (MMSYSERR_BASE + 5)  ; device handle is invalid
MMSYSERR_NODRIVER     equ    (MMSYSERR_BASE + 6)  ; no device driver present
MMSYSERR_NOMEM        equ    (MMSYSERR_BASE + 7)  ; memory allocation error
MMSYSERR_NOTSUPPORTED equ    (MMSYSERR_BASE + 8)  ; function isn't supported
MMSYSERR_BADERRNUM    equ    (MMSYSERR_BASE + 9)  ; error value out of range
MMSYSERR_INVALFLAG    equ    (MMSYSERR_BASE + 10) ; invalid flags passed
MMSYSERR_INVALPARAM   equ    (MMSYSERR_BASE + 11) ; invalid parameter passed
MMSYSERR_LASTERROR    equ    (MMSYSERR_BASE + 11) ; last error in range


ifndef MMNODRV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Installable driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DRV_MCI_FIRST          equ    DRV_RESERVED
DRV_MCI_LAST           equ    (DRV_RESERVED + 0FFFh)

endif  ;ifndef MMNODRV


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                         Driver callback support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and
; midiOutOpen() to specify the type of the dwCallback parameter.
CALLBACK_TYPEMASK   equ    00070000h     ; callback type mask
CALLBACK_NULL       equ    00000000h     ; no callback
CALLBACK_WINDOW     equ    00010000h     ; dwCallback is a HWND
CALLBACK_TASK       equ    00020000h     ; dwCallback is a HTASK
CALLBACK_FUNCTION   equ    00030000h     ; dwCallback is a FARPROC

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                        Manufacturer and product IDs
;        
;   Used with wMid and wPid fields in WAVEOUTCAPS, WAVEINCAPS, 
;   MIDIOUTCAPS, MIDIINCAPS, AUXCAPS, JOYCAPS structures.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; manufacturer IDs
MM_MICROSOFT            equ    1       ; Microsoft Corp.

; product IDs
MM_MIDI_MAPPER          equ    1       ; MIDI Mapper
MM_WAVE_MAPPER          equ    2       ; Wave Mapper

MM_SNDBLST_MIDIOUT      equ    3       ; Sound Blaster MIDI output port
MM_SNDBLST_MIDIIN       equ    4       ; Sound Blaster MIDI input port
MM_SNDBLST_SYNTH        equ    5       ; Sound Blaster internal synthesizer
MM_SNDBLST_WAVEOUT      equ    6       ; Sound Blaster waveform output
MM_SNDBLST_WAVEIN       equ    7       ; Sound Blaster waveform input

MM_ADLIB                equ    9       ; Ad Lib-compatible synthesizer

MM_MPU401_MIDIOUT       equ    10      ; MPU401-compatible MIDI output port
MM_MPU401_MIDIIN        equ    11      ; MPU401-compatible MIDI input port

MM_PC_JOYSTICK          equ    12      ; Joystick adapter


ifndef MMNOSOUND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           Sound support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; flag values for wFlags parameter
SND_SYNC            equ    0000h   ; play synchronously (default)
SND_ASYNC           equ    0001h   ; play asynchronously
SND_NODEFAULT       equ    0002h   ; don't use default sound
SND_MEMORY          equ    0004h   ; lpszSoundName points to a memory file
SND_LOOP            equ    0008h   ; loop the sound until next sndPlaySound
SND_NOSTOP          equ    0010h   ; don't stop any currently playing sound
SND_VALID           equ    001Fh   ;Internal

endif  ;ifndef MMNOSOUND


ifndef MMNOWAVE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Waveform audio support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; waveform audio error return values
WAVERR_BADFORMAT      equ    (WAVERR_BASE + 0)    ; unsupported wave format
WAVERR_STILLPLAYING   equ    (WAVERR_BASE + 1)    ; still something playing
WAVERR_UNPREPARED     equ    (WAVERR_BASE + 2)    ; header not prepared
WAVERR_SYNC           equ    (WAVERR_BASE + 3)    ; device is synchronous
WAVERR_LASTERROR      equ    (WAVERR_BASE + 3)    ; last error in range

; wave callback messages
WOM_OPEN        equ    MM_WOM_OPEN
WOM_CLOSE       equ    MM_WOM_CLOSE
WOM_DONE        equ    MM_WOM_DONE
WIM_OPEN        equ    MM_WIM_OPEN
WIM_CLOSE       equ    MM_WIM_CLOSE
WIM_DATA        equ    MM_WIM_DATA

; device ID for wave device mapper
WAVE_MAPPER     equ    (-1)

; flags for dwFlags parameter in waveOutOpen() and waveInOpen()
WAVE_FORMAT_QUERY     equ    0001h
WAVE_ALLOWSYNC        equ    0002h
WAVE_VALID            equ    0003h      ;Internal

; wave data block header
WAVEHDR struc
    lpWaveData               dd    ?     ; pointer to locked data buffer
    dwWaveBufferLength       dd    ?     ; length of data buffer
    dwWaveBytesRecorded      dd    ?     ; used for input only
    dwWaveUser               dd    ?     ; for client's use
    dwWaveFlags              dd    ?     ; assorted flags (see defines)
    dwWaveLoops              dd    ?     ; loop control counter
    lpWaveNext               dd    ?     ; reserved for driver
    Wavereserved             dd    ?     ; reserved for driver
WAVEHDR ends

; flags for dwFlags field of WAVEHDR
WHDR_DONE       equ    00000001h   ; done bit
WHDR_PREPARED   equ    00000002h   ; set if this header has been prepared
WHDR_BEGINLOOP  equ    00000004h   ; loop start block
WHDR_ENDLOOP    equ    00000008h   ; loop end block
WHDR_INQUEUE    equ    00000010h   ; reserved for driver
WHDR_VALID      equ    0000001Fh   ;Internal

; waveform output device capabilities structure
WAVEOUTCAPS struc
    woc_wMid            dw      ?      ; manufacturer ID
    woc_wPid            dw      ?      ; product ID
    woc_vDriverVersion  dw      ?      ; version of the driver
    woc_szPname         db MAXPNAMELEN dup (?)  ; product name (NULL terminated string)
    woc_dwFormats       dd      ?      ; formats supported
    woc_wChannels       dw      ?      ; number of sources supported
    woc_dwSupport       dd      ?      ; functionality supported by driver
WAVEOUTCAPS ends

; flags for dwSupport field of WAVEOUTCAPS
WAVECAPS_PITCH          equ    0001h    ; supports pitch control
WAVECAPS_PLAYBACKRATE   equ    0002h    ; supports playback rate control
WAVECAPS_VOLUME         equ    0004h    ; supports volume control
WAVECAPS_LRVOLUME       equ    0008h    ; separate left-right volume control
WAVECAPS_SYNC           equ    0010h

; waveform input device capabilities structure
WAVEINCAPS struc
    wic_wMid            dw      ?      ; manufacturer ID
    wic_wPid            dw      ?      ; product ID
    wic_vDriverVersion  dw      ?      ; version of the driver
    wic_szPname         db MAXPNAMELEN dup (?)  ; product name (NULL terminated string)
    wic_dwFormats       dd      ?      ; formats supported
    wic_wChannels       dw      ?      ; number of channels supported
WAVEINCAPS ends

; defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS
WAVE_INVALIDFORMAT     equ    00000000h        ; invalid format
WAVE_FORMAT_1M08       equ    00000001h        ; 11.025 kHz, Mono,   8-bit
WAVE_FORMAT_1S08       equ    00000002h        ; 11.025 kHz, Stereo, 8-bit
WAVE_FORMAT_1M16       equ    00000004h        ; 11.025 kHz, Mono,   16-bit
WAVE_FORMAT_1S16       equ    00000008h        ; 11.025 kHz, Stereo, 16-bit
WAVE_FORMAT_2M08       equ    00000010h        ; 22.05  kHz, Mono,   8-bit
WAVE_FORMAT_2S08       equ    00000020h        ; 22.05  kHz, Stereo, 8-bit
WAVE_FORMAT_2M16       equ    00000040h        ; 22.05  kHz, Mono,   16-bit
WAVE_FORMAT_2S16       equ    00000080h        ; 22.05  kHz, Stereo, 16-bit
WAVE_FORMAT_4M08       equ    00000100h        ; 44.1   kHz, Mono,   8-bit
WAVE_FORMAT_4S08       equ    00000200h        ; 44.1   kHz, Stereo, 8-bit
WAVE_FORMAT_4M16       equ    00000400h        ; 44.1   kHz, Mono,   16-bit
WAVE_FORMAT_4S16       equ    00000800h        ; 44.1   kHz, Stereo, 16-bit

; general waveform format structure (information common to all formats)
WAVEFORMAT struc
    wfmt_wFormatTag       dw    ?   ; format type
    wfmt_nChannels        dw    ?   ; number of channels (i.e. mono, stereo, etc.)
    wfmt_nSamplesPerSec   dd    ?   ; sample rate
    wfmt_nAvgBytesPerSec  dd    ?   ; for buffer estimation
    wfmt_nBlockAlign      dw    ?   ; block size of data
WAVEFORMAT ends

; flags for wFormatTag field of WAVEFORMAT
WAVE_FORMAT_PCM     equ    1

; specific waveform format structure for PCM data
PCMWAVEFORMAT struc
    pcm_wf               db (SIZE WAVEFORMAT) dup (?)
    pcm_wBitsPerSample   dw    ?
PCMWAVEFORMAT ends

endif  ;ifndef MMNOWAVE


ifndef MMNOMIDI
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           MIDI audio support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; MIDI error return values
MIDIERR_UNPREPARED    equ    (MIDIERR_BASE + 0)   ; header not prepared
MIDIERR_STILLPLAYING  equ    (MIDIERR_BASE + 1)   ; still something playing
MIDIERR_NOMAP         equ    (MIDIERR_BASE + 2)   ; no current map
MIDIERR_NOTREADY      equ    (MIDIERR_BASE + 3)   ; hardware is still busy
MIDIERR_NODEVICE      equ    (MIDIERR_BASE + 4)   ; port no longer connected
MIDIERR_INVALIDSETUP  equ    (MIDIERR_BASE + 5)   ; invalid setup
MIDIERR_LASTERROR     equ    (MIDIERR_BASE + 5)   ; last error in range

; MIDI audio data types
MIDIPATCHSIZE   equ    128

; MIDI callback messages
MIM_OPEN        equ    MM_MIM_OPEN
MIM_CLOSE       equ    MM_MIM_CLOSE
MIM_DATA        equ    MM_MIM_DATA
MIM_LONGDATA    equ    MM_MIM_LONGDATA
MIM_ERROR       equ    MM_MIM_ERROR
MIM_LONGERROR   equ    MM_MIM_LONGERROR
MOM_OPEN        equ    MM_MOM_OPEN
MOM_CLOSE       equ    MM_MOM_CLOSE
MOM_DONE        equ    MM_MOM_DONE

; device ID for MIDI mapper
MIDIMAPPER     equ    (-1)
MIDI_MAPPER    equ    (-1)

; flags for wFlags parm of midiOutCachePatches(),       
; midiOutCacheDrumPatches()                             
MIDI_CACHE_ALL      equ    1                            
MIDI_CACHE_BESTFIT  equ    2                            
MIDI_CACHE_QUERY    equ    3                            
MIDI_UNCACHE        equ    4                            

; MIDI output device capabilities structure
MIDIOUTCAPS struc
    moc_wMid            dw    ?        ; manufacturer ID
    moc_wPid            dw    ?        ; product ID
    moc_vDriverVersion  dw    ?        ; version of the driver
    moc_szPname         db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
    moc_wTechnology     dw    ?        ; type of device
    moc_wVoices         dw    ?        ; # of voices (internal synth only)
    moc_wNotes          dw    ?        ; max # of notes (internal synth only)
    moc_wChannelMask    dw    ?        ; channels used (internal synth only)
    moc_dwSupport       dd    ?        ; functionality supported by driver
MIDIOUTCAPS ends

; flags for wTechnology field of MIDIOUTCAPS structure
MOD_MIDIPORT    equ    1  ; output port
MOD_SYNTH       equ    2  ; generic internal synth
MOD_SQSYNTH     equ    3  ; square wave internal synth
MOD_FMSYNTH     equ    4  ; FM internal synth
MOD_MAPPER      equ    5  ; MIDI mapper

; flags for dwSupport field of MIDIOUTCAPS structure
MIDICAPS_VOLUME          equ    0001h   ; supports volume control
MIDICAPS_LRVOLUME        equ    0002h   ; separate left-right volume control
MIDICAPS_CACHE           equ    0004h  

; MIDI output device capabilities structure
MIDIINCAPS struc
    mic_wMid            dw    ?       ; manufacturer ID
    mic_wPid            dw    ?       ; product ID
    mic_vDriverVersion  dw    ?       ; version of the driver
    mic_szPname         db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
MIDIINCAPS ends

; MIDI data block header
MIDIHDR struc
    lpMidiData            dd    ?      ; pointer to locked data block
    dwMidiBufferLength    dd    ?      ; length of data in data block
    dwMidiBytesRecorded   dd    ?      ; used for input only
    dwMidiUser            dd    ?      ; for client's use
    dwMidiFlags           dd    ?      ; assorted flags (see defines)
    lpMidiNext            dd    ?      ; reserved for driver
    Midireserved          dd    ?      ; reserved for driver
MIDIHDR ends

; flags for dwFlags field of MIDIHDR structure
MHDR_DONE       equ    00000001h        ; done bit
MHDR_PREPARED   equ    00000002h        ; set if header prepared
MHDR_INQUEUE    equ    00000004h        ; reserved for driver
MHDR_VALID      equ    00000007h        ;Internal

endif  ;ifndef MMNOMIDI


ifndef MMNOAUX
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Auxiliary audio support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; device ID for aux device mapper
AUX_MAPPER     equ    (-1)

; Auxiliary audio device capabilities structure
AUXCAPS struc
    acaps_wMid              dw    ?      ; manufacturer ID
    acaps_wPid              dw    ?      ; product ID
    acaps_vDriverVersion    dw    ?      ; version of the driver
    acaps_szPname           db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
    acaps_wTechnology       dw    ?      ; type of device
    acaps_dwSupport         dd    ?      ; functionality supported by driver
AUXCAPS ends

; flags for wTechnology field in AUXCAPS structure
AUXCAPS_CDAUDIO    equ    1       ; audio from internal CD-ROM drive
AUXCAPS_AUXIN      equ    2       ; audio from auxiliary input jacks

; flags for dwSupport field in AUXCAPS structure
AUXCAPS_VOLUME          equ    0001h   ; supports volume control
AUXCAPS_LRVOLUME        equ    0002h   ; separate left-right volume control

endif  ;ifndef MMNOAUX


ifndef MMNOTIMER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           Timer support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; timer error return values
TIMERR_NOERROR        equ    (0)                  ; no error
TIMERR_NOCANDO        equ    (TIMERR_BASE+1)      ; request not completed
TIMERR_STRUCT         equ    (TIMERR_BASE+33)     ; time struct size

; flags for wFlags parameter of timeSetEvent() function
TIME_ONESHOT    equ    0   ; program timer for single event
TIME_PERIODIC   equ    1   ; program for continuous periodic event

; timer device capabilities data structure
TIMECAPS struc
    tc_wPeriodMin    dw    ?     ; minimum period supported
    tc_wPeriodMax    dw    ?     ; maximum period supported
TIMECAPS ends

endif  ;ifndef MMNOTIMER


ifndef MMNOJOY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           Joystick support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; joystick error return values
JOYERR_NOERROR        equ    (0)                  ; no error
JOYERR_PARMS          equ    (JOYERR_BASE+5)      ; bad parameters
JOYERR_NOCANDO        equ    (JOYERR_BASE+6)      ; request not completed
JOYERR_UNPLUGGED      equ    (JOYERR_BASE+7)      ; joystick is unplugged

; constants used with JOYINFO structure and MM_JOY* messages
JOY_BUTTON1         equ    0001h
JOY_BUTTON2         equ    0002h
JOY_BUTTON3         equ    0004h
JOY_BUTTON4         equ    0008h
JOY_BUTTON1CHG      equ    0100h
JOY_BUTTON2CHG      equ    0200h
JOY_BUTTON3CHG      equ    0400h
JOY_BUTTON4CHG      equ    0800h

; joystick ID constants
JOYSTICKID1         equ    0
JOYSTICKID2         equ    1

; joystick device capabilities data structure
JOYCAPS struc
    jcaps_wMid         dw    ?    ; manufacturer ID
    jcaps_wPid         dw    ?    ; product ID
    jcaps_szPname      db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
    jcaps_wXmin        dw    ?    ; minimum x position value
    jcaps_wXmax        dw    ?    ; maximum x position value
    jcaps_wYmin        dw    ?    ; minimum y position value
    jcaps_wYmax        dw    ?    ; maximum y position value
    jcaps_wZmin        dw    ?    ; minimum z position value
    jcaps_wZmax        dw    ?    ; maximum z position value
    jcaps_wNumButtons  dw    ?    ; number of buttons
    jcaps_wPeriodMin   dw    ?    ; minimum message period when captured
    jcaps_wPeriodMax   dw    ?    ; maximum message period when captured
JOYCAPS ends

; joystick information data structure
JOYINFO struc
    jinfo_wXpos        dw    ?  ; x position
    jinfo_wYpos        dw    ?  ; y position
    jinfo_wZpos        dw    ?  ; z position
    jinfo_wButtons     dw    ?  ; button states
JOYINFO ends

endif  ;ifndef MMNOJOY

ifndef MMNOMMIO
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Multimedia File I/O support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; MMIO error return values
MMIOERR_BASE            equ    256
MMIOERR_FILENOTFOUND    equ    (MMIOERR_BASE + 1)  ; file not found
MMIOERR_OUTOFMEMORY     equ    (MMIOERR_BASE + 2)  ; out of memory
MMIOERR_CANNOTOPEN      equ    (MMIOERR_BASE + 3)  ; cannot open
MMIOERR_CANNOTCLOSE     equ    (MMIOERR_BASE + 4)  ; cannot close
MMIOERR_CANNOTREAD      equ    (MMIOERR_BASE + 5)  ; cannot read
MMIOERR_CANNOTWRITE     equ    (MMIOERR_BASE + 6)  ; cannot write
MMIOERR_CANNOTSEEK      equ    (MMIOERR_BASE + 7)  ; cannot seek
MMIOERR_CANNOTEXPAND    equ    (MMIOERR_BASE + 8)  ; cannot expand file
MMIOERR_CHUNKNOTFOUND   equ    (MMIOERR_BASE + 9)  ; chunk not found
MMIOERR_UNBUFFERED      equ    (MMIOERR_BASE + 10) ; file is unbuffered

; MMIO constants
CFSEPCHAR    equ   '+'             ; compound file name separator char.

; general MMIO information data structure
MMIOINFO struc
        ; general fields
    mmio_dwFlags        dd    ?      ; general status flags
    mmio_fccIOProc      dd    ?      ; pointer to I/O procedure
    mmio_pIOProc        dd    ?      ; pointer to I/O procedure
    mmio_wErrorRet      dw    ?      ; place for error to be returned
    mmio_htask          dw    ?      ; alternate local task

        ; fields maintained by MMIO functions during buffered I/O
    mmio_cchBuffer      dd    ?      ; size of I/O buffer (or 0L)
    mmio_pchBuffer      dd    ?      ; start of I/O buffer (or NULL)
    mmio_pchNext        dd    ?      ; pointer to next byte to read/write
    mmio_pchEndRead     dd    ?      ; pointer to last valid byte to read
    mmio_pchEndWrite    dd    ?      ; pointer to last byte to write
    mmio_lBufOffset     dd    ?      ; disk offset of start of buffer

        ; fields maintained by I/O procedure
    mmio_lDiskOffset    dd    ?      ; disk offset of next read or write
    mmio_adwInfo        dd 3 dup (?) ; data specific to type of MMIOPROC

        ; other fields maintained by MMIO
    mmio_dwReserved1    dd    ?      ; reserved for MMIO use
    mmio_dwReserved2    dd    ?      ; reserved for MMIO use
    mmio_hmmio          dw    ?      ; handle to open file
MMIOINFO ends

; RIFF chunk information data structure
MMCKINFO struc
    mmck_ckid          dd    ?  ; chunk ID
    mmck_cksize        dd    ?  ; chunk size
    mmck_fccType       dd    ?  ; form type or list type
    mmck_dwDataOffset  dd    ?  ; offset of data portion of chunk
    mmck_dwFlags       dd    ?  ; flags used by MMIO functions
MMCKINFO ends

; bit field masks
MMIO_RWMODE     equ    00000003h       ; open file for reading/writing/both
MMIO_SHAREMODE  equ    00000070h       ; file sharing mode number

; constants for dwFlags field of MMIOINFO
MMIO_CREATE     equ    00001000h       ; create new file (or truncate file)
MMIO_PARSE      equ    00000100h       ; parse new file returning path
MMIO_DELETE     equ    00000200h       ; create new file (or truncate file)
MMIO_EXIST      equ    00004000h       ; checks for existence of file
MMIO_ALLOCBUF   equ    00010000h       ; mmioOpen() should allocate a buffer
MMIO_GETTEMP    equ    00020000h       ; mmioOpen() should retrieve temp name

MMIO_DIRTY      equ    10000000h       ; I/O buffer is dirty

MMIO_OPEN_VALID equ    0003FFFFh       ;Internal

; read/write mode numbers (bit field MMIO_RWMODE)
MMIO_READ       equ    00000000h       ; open file for reading only
MMIO_WRITE      equ    00000001h       ; open file for writing only
MMIO_READWRITE  equ    00000002h       ; open file for reading and writing

; share mode numbers (bit field MMIO_SHAREMODE)
MMIO_COMPAT     equ    00000000h       ; compatibility mode
MMIO_EXCLUSIVE  equ    00000010h       ; exclusive-access mode
MMIO_DENYWRITE  equ    00000020h       ; deny writing to other processes
MMIO_DENYREAD   equ    00000030h       ; deny reading to other processes
MMIO_DENYNONE   equ    00000040h       ; deny nothing to other processes

; various MMIO flags
MMIO_FHOPEN             equ    0010h   ; mmioClose: keep file handle open
MMIO_EMPTYBUF           equ    0010h   ; mmioFlush: empty the I/O buffer
MMIO_TOUPPER            equ    0010h   ; mmioStringToFOURCC: to u-case
MMIO_INSTALLPROC    equ    00010000h   ; mmioInstallIOProc: install MMIOProc
MMIO_GLOBALPROC     equ    10000000h   ; mmioInstallIOProc: install globally
MMIO_REMOVEPROC     equ    00020000h   ; mmioInstallIOProc: remove MMIOProc
MMIO_FINDPROC       equ    00040000h   ; mmioInstallIOProc: find an MMIOProc
MMIO_FINDCHUNK          equ    0010h   ; mmioDescend: find a chunk by ID
MMIO_FINDRIFF           equ    0020h   ; mmioDescend: find a LIST chunk
MMIO_FINDLIST           equ    0040h   ; mmioDescend: find a RIFF chunk
MMIO_CREATERIFF         equ    0020h   ; mmioCreateChunk: make a LIST chunk
MMIO_CREATELIST         equ    0040h   ; mmioCreateChunk: make a RIFF chunk

MMIO_VALIDPROC          equ    10070000h  ;Internal

; message numbers for MMIOPROC I/O procedure functions
MMIOM_READ      equ    MMIO_READ       ; read
MMIOM_WRITE    equ    MMIO_WRITE       ; write
MMIOM_SEEK              equ    2       ; seek to a new position in file
MMIOM_OPEN              equ    3       ; open file
MMIOM_CLOSE             equ    4       ; close file
MMIOM_WRITEFLUSH        equ    5       ; write and flush
MMIOM_RENAME            equ    6       ; rename specified file
MMIOM_USER         equ    8000h        ; beginning of user-defined messages

mmioFOURCC MACRO ch0,ch1,ch2,ch3
        mov     al,ch0
        mov     ah,ch1
        mov     dl,ch2
        mov     dh,ch3
        ENDM

; standard four character codes
FOURCC_RIFF     equ    mmioFOURCC('R', 'I', 'F', 'F')
FOURCC_LIST     equ    mmioFOURCC('L', 'I', 'S', 'T')

; four character codes used to identify standard built-in I/O procedures
FOURCC_DOS      equ    mmioFOURCC('D', 'O', 'S', ' ')
FOURCC_MEM      equ    mmioFOURCC('M', 'E', 'M', ' ')

; flags for mmioSeek()
ifndef SEEK_SET
SEEK_SET        equ    0               ; seek to an absolute position
SEEK_CUR        equ    1               ; seek relative to current position
SEEK_END        equ    2               ; seek relative to end of file
endif  ;ifndef SEEK_SET

; other constants
MMIO_DEFAULTBUFFER      equ    8192    ; default buffer size

endif	;ifndef MMNOMMIO

ifndef MMNOMCI
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           MCI support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; MCI error return values
MCIERR_INVALID_DEVICE_ID        equ    (MCIERR_BASE + 1)
MCIERR_UNRECOGNIZED_KEYWORD     equ    (MCIERR_BASE + 3)
MCIERR_UNRECOGNIZED_COMMAND     equ    (MCIERR_BASE + 5)
MCIERR_HARDWARE                 equ    (MCIERR_BASE + 6)
MCIERR_INVALID_DEVICE_NAME      equ    (MCIERR_BASE + 7)
MCIERR_OUT_OF_MEMORY            equ    (MCIERR_BASE + 8)
MCIERR_DEVICE_OPEN              equ    (MCIERR_BASE + 9)
MCIERR_CANNOT_LOAD_DRIVER       equ    (MCIERR_BASE + 10)
MCIERR_MISSING_COMMAND_STRING   equ    (MCIERR_BASE + 11)
MCIERR_PARAM_OVERFLOW           equ    (MCIERR_BASE + 12)
MCIERR_MISSING_STRING_ARGUMENT  equ    (MCIERR_BASE + 13)
MCIERR_BAD_INTEGER              equ    (MCIERR_BASE + 14)
MCIERR_PARSER_INTERNAL          equ    (MCIERR_BASE + 15)
MCIERR_DRIVER_INTERNAL          equ    (MCIERR_BASE + 16)
MCIERR_MISSING_PARAMETER        equ    (MCIERR_BASE + 17)
MCIERR_UNSUPPORTED_FUNCTION     equ    (MCIERR_BASE + 18)
MCIERR_FILE_NOT_FOUND           equ    (MCIERR_BASE + 19)
MCIERR_DEVICE_NOT_READY         equ    (MCIERR_BASE + 20)
MCIERR_INTERNAL                 equ    (MCIERR_BASE + 21)
MCIERR_DRIVER                   equ    (MCIERR_BASE + 22)
MCIERR_CANNOT_USE_ALL           equ    (MCIERR_BASE + 23)
MCIERR_MULTIPLE                 equ    (MCIERR_BASE + 24)
MCIERR_EXTENSION_NOT_FOUND      equ    (MCIERR_BASE + 25)
MCIERR_OUTOFRANGE               equ    (MCIERR_BASE + 26)
MCIERR_FLAGS_NOT_COMPATIBLE     equ    (MCIERR_BASE + 28)
MCIERR_FILE_NOT_SAVED           equ    (MCIERR_BASE + 30)
MCIERR_DEVICE_TYPE_REQUIRED     equ    (MCIERR_BASE + 31)
MCIERR_DEVICE_LOCKED            equ    (MCIERR_BASE + 32)
MCIERR_DUPLICATE_ALIAS          equ    (MCIERR_BASE + 33)
MCIERR_BAD_CONSTANT             equ    (MCIERR_BASE + 34)
MCIERR_MUST_USE_SHAREABLE       equ    (MCIERR_BASE + 35)
MCIERR_MISSING_DEVICE_NAME      equ    (MCIERR_BASE + 36)
MCIERR_BAD_TIME_FORMAT          equ    (MCIERR_BASE + 37)
MCIERR_NO_CLOSING_QUOTE         equ    (MCIERR_BASE + 38)
MCIERR_DUPLICATE_FLAGS          equ    (MCIERR_BASE + 39)
MCIERR_INVALID_FILE             equ    (MCIERR_BASE + 40)
MCIERR_NULL_PARAMETER_BLOCK     equ    (MCIERR_BASE + 41)
MCIERR_UNNAMED_RESOURCE         equ    (MCIERR_BASE + 42)
MCIERR_NEW_REQUIRES_ALIAS       equ    (MCIERR_BASE + 43)
MCIERR_NOTIFY_ON_AUTO_OPEN      equ    (MCIERR_BASE + 44)
MCIERR_NO_ELEMENT_ALLOWED       equ    (MCIERR_BASE + 45)
MCIERR_NONAPPLICABLE_FUNCTION   equ    (MCIERR_BASE + 46)
MCIERR_ILLEGAL_FOR_AUTO_OPEN    equ    (MCIERR_BASE + 47)
MCIERR_FILENAME_REQUIRED        equ    (MCIERR_BASE + 48)
MCIERR_EXTRA_CHARACTERS         equ    (MCIERR_BASE + 49)
MCIERR_DEVICE_NOT_INSTALLED     equ    (MCIERR_BASE + 50)
MCIERR_GET_CD                   equ    (MCIERR_BASE + 51)
MCIERR_SET_CD                   equ    (MCIERR_BASE + 52)
MCIERR_SET_DRIVE                equ    (MCIERR_BASE + 53)
MCIERR_DEVICE_LENGTH            equ    (MCIERR_BASE + 54)
MCIERR_DEVICE_ORD_LENGTH        equ    (MCIERR_BASE + 55)
MCIERR_NO_INTEGER               equ    (MCIERR_BASE + 56)

MCIERR_WAVE_OUTPUTSINUSE        equ    (MCIERR_BASE + 64)
MCIERR_WAVE_SETOUTPUTINUSE      equ    (MCIERR_BASE + 65)
MCIERR_WAVE_INPUTSINUSE         equ    (MCIERR_BASE + 66)
MCIERR_WAVE_SETINPUTINUSE       equ    (MCIERR_BASE + 67)
MCIERR_WAVE_OUTPUTUNSPECIFIED   equ    (MCIERR_BASE + 68)
MCIERR_WAVE_INPUTUNSPECIFIED    equ    (MCIERR_BASE + 69)
MCIERR_WAVE_OUTPUTSUNSUITABLE   equ    (MCIERR_BASE + 70)
MCIERR_WAVE_SETOUTPUTUNSUITABLE equ    (MCIERR_BASE + 71)
MCIERR_WAVE_INPUTSUNSUITABLE    equ    (MCIERR_BASE + 72)
MCIERR_WAVE_SETINPUTUNSUITABLE  equ    (MCIERR_BASE + 73)

MCIERR_SEQ_DIV_INCOMPATIBLE     equ    (MCIERR_BASE + 80)
MCIERR_SEQ_PORT_INUSE           equ    (MCIERR_BASE + 81)
MCIERR_SEQ_PORT_NONEXISTENT     equ    (MCIERR_BASE + 82)
MCIERR_SEQ_PORT_MAPNODEVICE     equ    (MCIERR_BASE + 83)
MCIERR_SEQ_PORT_MISCERROR       equ    (MCIERR_BASE + 84)
MCIERR_SEQ_TIMER                equ    (MCIERR_BASE + 85)
MCIERR_SEQ_PORTUNSPECIFIED      equ    (MCIERR_BASE + 86)
MCIERR_SEQ_NOMIDIPRESENT        equ    (MCIERR_BASE + 87)

MCIERR_NO_WINDOW                equ    (MCIERR_BASE + 90)
MCIERR_CREATEWINDOW             equ    (MCIERR_BASE + 91)
MCIERR_FILE_READ                equ    (MCIERR_BASE + 92)
MCIERR_FILE_WRITE               equ    (MCIERR_BASE + 93)

; all custom device driver errors must be >= than this value
MCIERR_CUSTOM_DRIVER_BASE       equ    (MCIERR_BASE + 256)

; MCI command message identifiers
MCI_OPEN                        equ    0803h
MCI_CLOSE                       equ    0804h
MCI_ESCAPE                      equ    0805h
MCI_PLAY                        equ    0806h
MCI_SEEK                        equ    0807h
MCI_STOP                        equ    0808h
MCI_PAUSE                       equ    0809h
MCI_INFO                        equ    080Ah
MCI_GETDEVCAPS                  equ    080Bh
MCI_SPIN                        equ    080Ch
MCI_SET                         equ    080Dh
MCI_STEP                        equ    080Eh
MCI_RECORD                      equ    080Fh
MCI_SYSINFO                     equ    0810h
MCI_BREAK                       equ    0811h
MCI_SOUND                       equ    0812h
MCI_SAVE                        equ    0813h
MCI_STATUS                      equ    0814h
MCI_CUE                         equ    0830h
MCI_REALIZE                     equ    0840h
MCI_WINDOW                      equ    0841h
MCI_PUT                         equ    0842h
MCI_WHERE                       equ    0843h
MCI_FREEZE                      equ    0844h
MCI_UNFREEZE                    equ    0845h
MCI_LOAD                        equ    0850h
MCI_CUT                         equ    0851h
MCI_COPY                        equ    0852h
MCI_PASTE                       equ    0853h
MCI_UPDATE                      equ    0854h
MCI_RESUME                      equ    0855h
MCI_DELETE                      equ    0856h

; all custom MCI command messages must be >= than this value
MCI_USER_MESSAGES               equ    (400h + DRV_MCI_FIRST)


; device ID for "all devices"
MCI_ALL_DEVICE_ID               equ    0FFFFh

; constants for predefined MCI device types
MCI_DEVTYPE_VCR                 equ    (MCI_STRING_OFFSET + 1)
MCI_DEVTYPE_VIDEODISC           equ    (MCI_STRING_OFFSET + 2)
MCI_DEVTYPE_OVERLAY             equ    (MCI_STRING_OFFSET + 3)
MCI_DEVTYPE_CD_AUDIO            equ    (MCI_STRING_OFFSET + 4)
MCI_DEVTYPE_DAT                 equ    (MCI_STRING_OFFSET + 5)
MCI_DEVTYPE_SCANNER             equ    (MCI_STRING_OFFSET + 6)
MCI_DEVTYPE_ANIMATION           equ    (MCI_STRING_OFFSET + 7)
MCI_DEVTYPE_DIGITAL_VIDEO       equ    (MCI_STRING_OFFSET + 8)
MCI_DEVTYPE_OTHER               equ    (MCI_STRING_OFFSET + 9)
MCI_DEVTYPE_WAVEFORM_AUDIO      equ    (MCI_STRING_OFFSET + 10)
MCI_DEVTYPE_SEQUENCER           equ    (MCI_STRING_OFFSET + 11)

MCI_DEVTYPE_FIRST               equ    MCI_DEVTYPE_VCR
MCI_DEVTYPE_LAST                equ    MCI_DEVTYPE_SEQUENCER

; return values for 'status mode' command
MCI_MODE_NOT_READY              equ    (MCI_STRING_OFFSET + 12)
MCI_MODE_STOP                   equ    (MCI_STRING_OFFSET + 13)
MCI_MODE_PLAY                   equ    (MCI_STRING_OFFSET + 14)
MCI_MODE_RECORD                 equ    (MCI_STRING_OFFSET + 15)
MCI_MODE_SEEK                   equ    (MCI_STRING_OFFSET + 16)
MCI_MODE_PAUSE                  equ    (MCI_STRING_OFFSET + 17)
MCI_MODE_OPEN                   equ    (MCI_STRING_OFFSET + 18)

; constants used in 'set time format' and 'status time format' commands
MCI_FORMAT_MILLISECONDS         equ    0
MCI_FORMAT_HMS                  equ    1
MCI_FORMAT_MSF                  equ    2
MCI_FORMAT_FRAMES               equ    3
MCI_FORMAT_SMPTE_24             equ    4
MCI_FORMAT_SMPTE_25             equ    5
MCI_FORMAT_SMPTE_30             equ    6
MCI_FORMAT_SMPTE_30DROP         equ    7
MCI_FORMAT_BYTES                equ    8
MCI_FORMAT_SAMPLES              equ    9
MCI_FORMAT_TMSF                 equ    10

; flags for wParam of MM_MCINOTIFY message
MCI_NOTIFY_SUCCESSFUL           equ    0001h
MCI_NOTIFY_SUPERSEDED           equ    0002h
MCI_NOTIFY_ABORTED              equ    0004h
MCI_NOTIFY_FAILURE              equ    0008h


; common flags for dwFlags parameter of MCI command messages
MCI_NOTIFY                      equ    00000001h
MCI_WAIT                        equ    00000002h
MCI_FROM                        equ    00000004h
MCI_TO                          equ    00000008h
MCI_TRACK                       equ    00000010h

; flags for dwFlags parameter of MCI_OPEN command message
MCI_OPEN_SHAREABLE              equ    00000100h
MCI_OPEN_ELEMENT                equ    00000200h
MCI_OPEN_ALIAS                  equ    00000400h
MCI_OPEN_ELEMENT_ID             equ    00000800h
MCI_OPEN_TYPE_ID                equ    00001000h
MCI_OPEN_TYPE                   equ    00002000h

; flags for dwFlags parameter of MCI_SEEK command message
MCI_SEEK_TO_START               equ    00000100h
MCI_SEEK_TO_END                 equ    00000200h

; flags for dwFlags parameter of MCI_STATUS command message
MCI_STATUS_ITEM                 equ    00000100h
MCI_STATUS_START                equ    00000200h

; flags for dwItem field of the MCI_STATUS_PARMS parameter block
MCI_STATUS_LENGTH               equ    00000001h
MCI_STATUS_POSITION             equ    00000002h
MCI_STATUS_NUMBER_OF_TRACKS     equ    00000003h
MCI_STATUS_MODE                 equ    00000004h
MCI_STATUS_MEDIA_PRESENT        equ    00000005h
MCI_STATUS_TIME_FORMAT          equ    00000006h
MCI_STATUS_READY                equ    00000007h
MCI_STATUS_CURRENT_TRACK        equ    00000008h

; flags for dwFlags parameter of MCI_INFO command message
MCI_INFO_PRODUCT                equ    00000100h
MCI_INFO_FILE                   equ    00000200h

; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_GETDEVCAPS_ITEM             equ    00000100h

; flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block
MCI_GETDEVCAPS_CAN_RECORD       equ    00000001h
MCI_GETDEVCAPS_HAS_AUDIO        equ    00000002h
MCI_GETDEVCAPS_HAS_VIDEO        equ    00000003h
MCI_GETDEVCAPS_DEVICE_TYPE      equ    00000004h
MCI_GETDEVCAPS_USES_FILES       equ    00000005h
MCI_GETDEVCAPS_COMPOUND_DEVICE  equ    00000006h
MCI_GETDEVCAPS_CAN_EJECT        equ    00000007h
MCI_GETDEVCAPS_CAN_PLAY         equ    00000008h
MCI_GETDEVCAPS_CAN_SAVE         equ    00000009h

; flags for dwFlags parameter of MCI_SYSINFO command message
MCI_SYSINFO_QUANTITY            equ    00000100h
MCI_SYSINFO_OPEN                equ    00000200h
MCI_SYSINFO_NAME                equ    00000400h
MCI_SYSINFO_INSTALLNAME         equ    00000800h

; flags for dwFlags parameter of MCI_SET command message
MCI_SET_DOOR_OPEN               equ    00000100h
MCI_SET_DOOR_CLOSED             equ    00000200h
MCI_SET_TIME_FORMAT             equ    00000400h
MCI_SET_AUDIO                   equ    00000800h
MCI_SET_VIDEO                   equ    00001000h
MCI_SET_ON                      equ    00002000h
MCI_SET_OFF                     equ    00004000h

; flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS
MCI_SET_AUDIO_ALL               equ    00000000h
MCI_SET_AUDIO_LEFT              equ    00000001h
MCI_SET_AUDIO_RIGHT             equ    00000002h

; flags for dwFlags parameter of MCI_BREAK command message
MCI_BREAK_KEY                   equ    00000100h
MCI_BREAK_HWND                  equ    00000200h
MCI_BREAK_OFF                   equ    00000400h

; flags for dwFlags parameter of MCI_RECORD command message
MCI_RECORD_INSERT               equ    00000100h
MCI_RECORD_OVERWRITE            equ    00000200h

; flags for dwFlags parameter of MCI_SOUND command message
MCI_SOUND_NAME                  equ    00000100h

; flags for dwFlags parameter of MCI_SAVE command message
MCI_SAVE_FILE                   equ    00000100h

; flags for dwFlags parameter of MCI_LOAD command message
MCI_LOAD_FILE                   equ    00000100h

; generic parameter block for MCI command messages with no special parameters
MCI_GENERIC_PARMS struc
    mcigen_dwCallback         dd    ?
MCI_GENERIC_PARMS ends

; parameter block for MCI_OPEN command message
MCI_OPEN_PARMS struc
    mciopen_dwCallback        dd    ?
    mciopen_wDeviceID         dw    ?
    mciopen_wReserved0        dw    ?
    mciopen_lpstrDeviceType   dd    ?
    mciopen_lpstrElementName  dd    ?
    mciopen_lpstrAlias        dd    ?
MCI_OPEN_PARMS ends

; parameter block for MCI_PLAY command message
MCI_PLAY_PARMS struc
    mciplay_dwCallback        dd    ?
    mciplay_dwFrom            dd    ?
    mciplay_dwTo              dd    ?
MCI_PLAY_PARMS ends

; parameter block for MCI_SEEK command message
MCI_SEEK_PARMS struc
    mciseek_dwCallback        dd    ?
    mciseek_dwTo              dd    ?
MCI_SEEK_PARMS ends

; parameter block for MCI_STATUS command message
MCI_STATUS_PARMS struc
    mcistat_dwCallback        dd    ?
    mcistat_dwReturn          dd    ?
    mcistat_dwItem            dd    ?
    mcistat_dwTrack           dd    ?
MCI_STATUS_PARMS ends

; parameter block for MCI_INFO command message
MCI_INFO_PARMS struc
    mciinfo_dwCallback        dd    ?
    mciinfo_lpstrReturn       dd    ?
    mciinfo_dwRetSize         dd    ?
MCI_INFO_PARMS ends

; parameter block for MCI_GETDEVCAPS command message
MCI_GETDEVCAPS_PARMS struc
    mcigdc_dwCallback         dd    ?
    mcigdc_dwReturn           dd    ?
    mcigdc_dwItem             dd    ?
MCI_GETDEVCAPS_PARMS ends

; parameter block for MCI_SYSINFO command message
MCI_SYSINFO_PARMS struc
    mcisi_dwCallback          dd    ?
    mcisi_lpstrReturn         dd    ?
    mcisi_dwRetSize           dd    ?
    mcisi_dwNumber            dd    ?
    mcisi_wDeviceType         dw    ?
    mcisi_wReserved0          dw    ?
MCI_SYSINFO_PARMS ends

; parameter block for MCI_SET command message
MCI_SET_PARMS struc
    mciset_dwCallback         dd    ?
    mciset_dwTimeFormat       dd    ?
    mciset_dwAudio            dd    ?
MCI_SET_PARMS ends

; parameter block for MCI_BREAK command message
MCI_BREAK_PARMS struc
    mcibreak_dwCallback       dd    ?
    mcibreak_nVirtKey         dw    ?
    mcibreak_wReserved0       dw    ?
    mcibreak_hwndBreak        dw    ?
    mcibreak_wReserved1       dw    ?
MCI_BREAK_PARMS ends

; parameter block for MCI_SOUND command message
MCI_SOUND_PARMS struc
    mcisnd_dwCallback         dd    ?
    mcisnd_lpstrSoundName     dd    ?
MCI_SOUND_PARMS ends

; parameter block for MCI_SAVE command message
MCI_SAVE_PARMS struc
    mcisave_dwCallback        dd    ?
    mcisave_lpfilename        dd    ?
MCI_SAVE_PARMS ends

; parameter block for MCI_LOAD command message
MCI_LOAD_PARMS struc
    mciload_dwCallback        dd    ?
    mciload_lpfilename        dd    ?
MCI_LOAD_PARMS ends

; parameter block for MCI_RECORD command message
MCI_RECORD_PARMS struc
    mcirec_dwCallback         dd    ?
    mcirec_dwFrom             dd    ?
    mcirec_dwTo               dd    ?
MCI_RECORD_PARMS ends


;
; MCI extensions for videodisc devices
;

; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_STATUS_MODE)
MCI_VD_MODE_PARK                equ    (MCI_VD_OFFSET + 1)

; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE)
MCI_VD_MEDIA_CLV                equ    (MCI_VD_OFFSET + 2)
MCI_VD_MEDIA_CAV                equ    (MCI_VD_OFFSET + 3)
MCI_VD_MEDIA_OTHER              equ    (MCI_VD_OFFSET + 4)

MCI_VD_FORMAT_TRACK             equ    4001h

; flags for dwFlags parameter of MCI_PLAY command message
MCI_VD_PLAY_REVERSE             equ    00010000h
MCI_VD_PLAY_FAST                equ    00020000h
MCI_VD_PLAY_SPEED               equ    00040000h
MCI_VD_PLAY_SCAN                equ    00080000h
MCI_VD_PLAY_SLOW                equ    00100000h

; flag for dwFlags parameter of MCI_SEEK command message
MCI_VD_SEEK_REVERSE             equ    00010000h

; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_VD_STATUS_SPEED             equ    00004002h
MCI_VD_STATUS_FORWARD           equ    00004003h
MCI_VD_STATUS_MEDIA_TYPE        equ    00004004h
MCI_VD_STATUS_SIDE              equ    00004005h
MCI_VD_STATUS_DISC_SIZE         equ    00004006h

; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_VD_GETDEVCAPS_CLV           equ    00010000h
MCI_VD_GETDEVCAPS_CAV           equ    00020000h

MCI_VD_SPIN_UP                  equ    0001h
MCI_VD_SPIN_DOWN                equ    0002h

; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_VD_GETDEVCAPS_CAN_REVERSE   equ    00004002h
MCI_VD_GETDEVCAPS_FAST_RATE     equ    00004003h
MCI_VD_GETDEVCAPS_SLOW_RATE     equ    00004004h
MCI_VD_GETDEVCAPS_NORMAL_RATE   equ    00004005h

; flags for the dwFlags parameter of MCI_STEP command message
MCI_VD_STEP_FRAMES              equ    00010000h
MCI_VD_STEP_REVERSE             equ    00020000h

; flag for the MCI_ESCAPE command message
MCI_VD_ESCAPE_STRING            equ    00000100h

; parameter block for MCI_PLAY command message
MCI_VD_PLAY_PARMS struc
    mcivdplay_dwCallback      dd    ?
    mcivdplay_dwFrom          dd    ?
    mcivdplay_dwTo            dd    ?
    mcivdplay_dwSpeed         dd    ?
MCI_VD_PLAY_PARMS ends

; parameter block for MCI_STEP command message
MCI_VD_STEP_PARMS struc
    mcivdstep_dwCallback      dd    ?
    mcivdstep_dwFrames        dd    ?
MCI_VD_STEP_PARMS ends

; parameter block for MCI_ESCAPE command message
MCI_VD_ESCAPE_PARMS struc
    mcivcesc_dwCallback       dd    ?
    mcivcesc_lpstrCommand     dd    ?
MCI_VD_ESCAPE_PARMS ends


;
; MCI extensions for waveform audio devices
;

; flags for the dwFlags parameter of MCI_OPEN command message
MCI_WAVE_OPEN_BUFFER            equ    00010000h

; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_FORMATTAG          equ    00010000h
MCI_WAVE_SET_CHANNELS           equ    00020000h
MCI_WAVE_SET_SAMPLESPERSEC      equ    00040000h
MCI_WAVE_SET_AVGBYTESPERSEC     equ    00080000h
MCI_WAVE_SET_BLOCKALIGN         equ    00100000h
MCI_WAVE_SET_BITSPERSAMPLE      equ    00200000h

; flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages
MCI_WAVE_INPUT                  equ    00400000h
MCI_WAVE_OUTPUT                 equ    00800000h

; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_WAVE_STATUS_FORMATTAG       equ    00004001h
MCI_WAVE_STATUS_CHANNELS        equ    00004002h
MCI_WAVE_STATUS_SAMPLESPERSEC   equ    00004003h
MCI_WAVE_STATUS_AVGBYTESPERSEC  equ    00004004h
MCI_WAVE_STATUS_BLOCKALIGN      equ    00004005h
MCI_WAVE_STATUS_BITSPERSAMPLE   equ    00004006h
MCI_WAVE_STATUS_LEVEL           equ    00004007h

; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_ANYINPUT           equ    04000000h
MCI_WAVE_SET_ANYOUTPUT          equ    08000000h

; flags for the dwFlags parameter of MCI_GETDEVCAPS command message
MCI_WAVE_GETDEVCAPS_INPUTS      equ    00004001h
MCI_WAVE_GETDEVCAPS_OUTPUTS     equ    00004002h

; parameter block for MCI_OPEN command message
MCI_WAVE_OPEN_PARMS struc
    mciwopen_dwCallback       dd    ?
    mciwopen_wDeviceID        dw    ?
    mciwopen_wReserved0       dw    ?
    mciwopen_lpstrDeviceType  dd    ?
    mciwopen_lpstrElementName dd    ?
    mciwopen_lpstrAlias       dd    ?
    mciwopen_dwBufferSeconds  dd    ?
MCI_WAVE_OPEN_PARMS ends

; parameter block for MCI_DELETE command message
MCI_WAVE_DELETE_PARMS struc
    mciwdel_dwCallback        dd    ?
    mciwdel_dwFrom            dd    ?
    mciwdel_dwTo              dd    ?
MCI_WAVE_DELETE_PARMS ends

; parameter block for MCI_SET command message
MCI_WAVE_SET_PARMS struc
    mciwset_dwCallback        dd    ?
    mciwset_dwTimeFormat      dd    ?
    mciwset_dwAudio           dd    ?
    mciwset_wInput            dw    ?
    mciwset_wReserved0        dw    ?
    mciwset_wOutput           dw    ?
    mciwset_wReserved1        dw    ?
    mciwset_wFormatTag        dw    ?
    mciwset_wReserved2        dw    ?
    mciwset_nChannels         dw    ?
    mciwset_wReserved3        dw    ?
    mciwset_nSamplesPerSec    dw    ?
    mciwset_nAvgBytesPerSec   dw    ?
    mciwset_nBlockAlign       dw    ?
    mciwset_wReserved4        dw    ?
    mciwset_wBitsPerSample    dw    ?
    mciwset_wReserved5        dw    ?
MCI_WAVE_SET_PARMS ends


;
; MCI extensions for MIDI sequencer devices
;

; flags for the dwReturn field of MCI_STATUS_PARMS parameter block
; MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE)
MCI_SEQ_DIV_PPQN            equ    (0 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_24        equ    (1 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_25        equ    (2 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30DROP    equ    (3 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30        equ    (4 + MCI_SEQ_OFFSET)

; flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block
; MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER)
MCI_SEQ_FORMAT_SONGPTR      equ    4001h
MCI_SEQ_FILE                equ    4002h
MCI_SEQ_MIDI                equ    4003h
MCI_SEQ_SMPTE               equ    4004h
MCI_SEQ_NONE                equ    65533

; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_SEQ_STATUS_TEMPO            equ    00004002h
MCI_SEQ_STATUS_PORT             equ    00004003h
MCI_SEQ_STATUS_SLAVE            equ    00004007h
MCI_SEQ_STATUS_MASTER           equ    00004008h
MCI_SEQ_STATUS_OFFSET           equ    00004009h
MCI_SEQ_STATUS_DIVTYPE          equ    0000400Ah

; flags for the dwFlags parameter of MCI_SET command message
MCI_SEQ_SET_TEMPO               equ    00010000h
MCI_SEQ_SET_PORT                equ    00020000h
MCI_SEQ_SET_SLAVE               equ    00040000h
MCI_SEQ_SET_MASTER              equ    00080000h
MCI_SEQ_SET_OFFSET              equ    01000000h

; parameter block for MCI_SET command message
MCI_SEQ_SET_PARMS struc
    mcisset_dwCallback        dd    ?
    mcisset_dwTimeFormat      dd    ?
    mcisset_dwAudio           dd    ?
    mcisset_dwTempo           dd    ?
    mcisset_dwPort            dd    ?
    mcisset_dwSlave           dd    ?
    mcisset_dwMaster          dd    ?
    mcisset_dwOffset          dd    ?
MCI_SEQ_SET_PARMS ends


;
; MCI extensions for animation devices
;

; flags for dwFlags parameter of MCI_OPEN command message
MCI_ANIM_OPEN_WS                equ    00010000h
MCI_ANIM_OPEN_PARENT            equ    00020000h
MCI_ANIM_OPEN_NOSTATIC          equ    00040000h

; flags for dwFlags parameter of MCI_PLAY command message
MCI_ANIM_PLAY_SPEED             equ    00010000h
MCI_ANIM_PLAY_REVERSE           equ    00020000h
MCI_ANIM_PLAY_FAST              equ    00040000h
MCI_ANIM_PLAY_SLOW              equ    00080000h
MCI_ANIM_PLAY_SCAN              equ    00100000h

; flags for dwFlags parameter of MCI_STEP command message
MCI_ANIM_STEP_REVERSE           equ    00010000h
MCI_ANIM_STEP_FRAMES            equ    00020000h

; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_ANIM_STATUS_SPEED           equ    00004001h
MCI_ANIM_STATUS_FORWARD         equ    00004002h
MCI_ANIM_STATUS_HWND            equ    00004003h
MCI_ANIM_STATUS_HPAL            equ    00004004h
MCI_ANIM_STATUS_STRETCH         equ    00004005h

; flags for the dwFlags parameter of MCI_INFO command message
MCI_ANIM_INFO_TEXT              equ    00010000h

; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_ANIM_GETDEVCAPS_CAN_REVERSE equ    00004001h
MCI_ANIM_GETDEVCAPS_FAST_RATE   equ    00004002h
MCI_ANIM_GETDEVCAPS_SLOW_RATE   equ    00004003h
MCI_ANIM_GETDEVCAPS_NORMAL_RATE equ    00004004h
MCI_ANIM_GETDEVCAPS_PALETTES    equ    00004006h
MCI_ANIM_GETDEVCAPS_CAN_STRETCH equ    00004007h
MCI_ANIM_GETDEVCAPS_MAX_WINDOWS equ    00004008h

; flags for the MCI_REALIZE command message
MCI_ANIM_REALIZE_NORM           equ    00010000h
MCI_ANIM_REALIZE_BKGD           equ    00020000h

; flags for dwFlags parameter of MCI_WINDOW command message
MCI_ANIM_WINDOW_HWND            equ    00010000h
MCI_ANIM_WINDOW_STATE           equ    00040000h
MCI_ANIM_WINDOW_TEXT            equ    00080000h
MCI_ANIM_WINDOW_ENABLE_STRETCH  equ    00100000h
MCI_ANIM_WINDOW_DISABLE_STRETCH equ    00200000h

; flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block
; MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND)
MCI_ANIM_WINDOW_DEFAULT         equ    00000000h

; flags for dwFlags parameter of MCI_PUT command message
MCI_ANIM_RECT                   equ    00010000h
MCI_ANIM_PUT_SOURCE             equ    00020000h
MCI_ANIM_PUT_DESTINATION        equ    00040000h

; flags for dwFlags parameter of MCI_WHERE command message
MCI_ANIM_WHERE_SOURCE           equ    00020000h
MCI_ANIM_WHERE_DESTINATION      equ    00040000h

; flags for dwFlags parameter of MCI_UPDATE command message
MCI_ANIM_UPDATE_HDC             equ    00020000h

; parameter block for MCI_OPEN command message
MCI_ANIM_OPEN_PARMS struc
    mciaopen_dwCallback       dd    ?
    mciaopen_wDeviceID        dw    ?
    mciaopen_wReserved0       dw    ?
    mciaopen_lpstrDeviceType  dd    ?
    mciaopen_lpstrElementName dd    ?
    mciaopen_lpstrAlias       dd    ?
    mciaopen_dwStyle          dd    ?
    mciaopen_hWndParent       dw    ?
    mciaopen_wReserved1       dw    ?
MCI_ANIM_OPEN_PARMS ends

; parameter block for MCI_PLAY command message
MCI_ANIM_PLAY_PARMS struc
    mciaplay_dwCallback       dd    ?
    mciaplay_dwFrom           dd    ?
    mciaplay_dwTo             dd    ?
    mciaplay_dwSpeed          dd    ?
MCI_ANIM_PLAY_PARMS ends

; parameter block for MCI_STEP command message
MCI_ANIM_STEP_PARMS struc
    mciastep_dwCallback       dd    ?
    mciastep_dwFrames         dd    ?
MCI_ANIM_STEP_PARMS ends

; parameter block for MCI_WINDOW command message
MCI_ANIM_WINDOW_PARMS struc
    mciawin_dwCallback        dd    ?
    mciawin_hWnd              dw    ?
    mciawin_wReserved1        dw    ?
    mciawin_nCmdShow          dw    ?
    mciawin_wReserved2        dw    ?
    mciawin_lpstrText         dd    ?
MCI_ANIM_WINDOW_PARMS ends

; parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages
MCI_ANIM_RECT_PARMS struc
    mciarect_dwCallback       dd    ?
ifdef MCI_USE_OFFEXT
    mciarect_ptOffset         db (SIZE POINT) dup (?)
    mciarect_ptExtent         db (SIZE POINT) dup (?)
else	;ifdef MCI_USE_OFFEXT
    mciarect_rc               db (SIZE RECT) dup (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_ANIM_RECT_PARMS ends

; parameter block for MCI_UPDATE PARMS
MCI_ANIM_UPDATE_PARMS struc
    mciaupd_dwCallback        dd    ?
    mciaupd_rc                db (SIZE RECT) dup (?)
    mciaupd_hDC               dw    ?
MCI_ANIM_UPDATE_PARMS ends


;
; MCI extensions for video overlay devices
;

; flags for dwFlags parameter of MCI_OPEN command message
MCI_OVLY_OPEN_WS                equ    00010000h
MCI_OVLY_OPEN_PARENT            equ    00020000h

; flags for dwFlags parameter of MCI_STATUS command message
MCI_OVLY_STATUS_HWND            equ    00004001h
MCI_OVLY_STATUS_STRETCH         equ    00004002h

; flags for dwFlags parameter of MCI_INFO command message
MCI_OVLY_INFO_TEXT              equ    00010000h

; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_OVLY_GETDEVCAPS_CAN_STRETCH equ    00004001h
MCI_OVLY_GETDEVCAPS_CAN_FREEZE  equ    00004002h
MCI_OVLY_GETDEVCAPS_MAX_WINDOWS equ    00004003h

; flags for dwFlags parameter of MCI_WINDOW command message
MCI_OVLY_WINDOW_HWND            equ    00010000h
MCI_OVLY_WINDOW_STATE           equ    00040000h
MCI_OVLY_WINDOW_TEXT            equ    00080000h
MCI_OVLY_WINDOW_ENABLE_STRETCH  equ    00100000h
MCI_OVLY_WINDOW_DISABLE_STRETCH equ    00200000h

; flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block
MCI_OVLY_WINDOW_DEFAULT         equ    00000000h

; flags for dwFlags parameter of MCI_PUT command message
MCI_OVLY_RECT                   equ    00010000h
MCI_OVLY_PUT_SOURCE             equ    00020000h
MCI_OVLY_PUT_DESTINATION        equ    00040000h
MCI_OVLY_PUT_FRAME              equ    00080000h
MCI_OVLY_PUT_VIDEO              equ    00100000h

; flags for dwFlags parameter of MCI_WHERE command message
MCI_OVLY_WHERE_SOURCE           equ    00020000h
MCI_OVLY_WHERE_DESTINATION      equ    00040000h
MCI_OVLY_WHERE_FRAME            equ    00080000h
MCI_OVLY_WHERE_VIDEO            equ    00100000h

; parameter block for MCI_OPEN command message
MCI_OVLY_OPEN_PARMS struc
    mcioopen_dwCallback       dd    ?
    mcioopen_wDeviceID        dw    ?
    mcioopen_wReserved0       dw    ?
    mcioopen_lpstrDeviceType  dd    ?
    mcioopen_lpstrElementName dd    ?
    mcioopen_lpstrAlias       dd    ?
    mcioopen_dwStyle          dd    ?
    mcioopen_hWndParent       dw    ?
    mcioopen_wReserved1       dw    ?
MCI_OVLY_OPEN_PARMS ends

; parameter block for MCI_WINDOW command message
MCI_OVLY_WINDOW_PARMS struc
    mciowin_dwCallback        dd    ?
    mciowin_hWnd              dw    ?
    mciowin_wReserved1        dw    ?
    mciowin_nCmdShow          dw    ?
    mciowin_wReserved2        dw    ?
    mciowin_lpstrText         dd    ?
MCI_OVLY_WINDOW_PARMS ends

; parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages
MCI_OVLY_RECT_PARMS struc
    mciorect_dwCallback       dd    ?
ifdef MCI_USE_OFFEXT
    mciorect_ptOffset         db (SIZE POINT) dup (?)
    mciorect_ptExtent         db (SIZE POINT) dup (?)
else	;ifdef MCI_USE_OFFEXT
    mciorect_rc               db (SIZE RECT) dup (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_OVLY_RECT_PARMS ends

; parameter block for MCI_SAVE command message
MCI_OVLY_SAVE_PARMS struc
    mciosave_dwCallback       dd    ?
    mciosave_lpfilename       dd    ?
    mciosave_rc               db (SIZE RECT) dup (?)
MCI_OVLY_SAVE_PARMS ends

; parameter block for MCI_LOAD command message
MCI_OVLY_LOAD_PARMS struc
    mcioload_dwCallback       dd    ?
    mcioload_lpfilename       dd    ?
    mcioload_rc               db (SIZE RECT) dup (?)
MCI_OVLY_LOAD_PARMS ends

endif  ;ifndef MMNOMCI

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       DISPLAY Driver extensions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef C1_TRANSPARENT
    CAPS1           equ    94          ; other caps
    C1_TRANSPARENT  equ    0001h       ; new raster cap
    NEWTRANSPARENT  equ    3           ; use with SetBkMode()

    QUERYROPSUPPORT equ    40          ; use to determine ROP support
endif  ;ifndef C1_TRANSPARENT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       DIB Driver extensions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SELECTDIB       equ    41                      ; DIB.DRV select dib escape
DIBINDEX MACRO a
        mov     ax,a
        mov     dx,10ffh
        ENDM


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       ScreenSaver support
;
;   The current application will receive a syscommand of SC_SCREENSAVE just
;   before the screen saver is invoked.  If the app wishes to prevent a
;   screen save, return non-zero value, otherwise call DefWindowProc().
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef SC_SCREENSAVE

    SC_SCREENSAVE   equ    0F140h

endif  ;ifndef SC_SCREENSAVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\ole.h ===
/*****************************************************************************\
*                                                                             *
* ole.h -       Object Linking and Embedding functions, types, and definitions*
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1990-1992, Microsoft Corp.  All rights reserved.*
*                                                                             *
\*****************************************************************************/

#ifndef _INC_OLE
#define _INC_OLE

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

#ifdef STRICT
#define OLE_LPCSTR  LPCSTR
#define OLE_CONST   const
#else   /* STRICT */
#define OLE_LPCSTR  LPSTR
#define OLE_CONST
#endif /* !STRICT */


/* Object types */
#define OT_LINK             1L
#define OT_EMBEDDED         2L
#define OT_STATIC           3L

/* activate verbs */
#define OLEVERB_PRIMARY     0

/* target device info structure */
typedef struct _OLETARGETDEVICE
{
    UINT otdDeviceNameOffset;
    UINT otdDriverNameOffset;
    UINT otdPortNameOffset;
    UINT otdExtDevmodeOffset;
    UINT otdExtDevmodeSize;
    UINT otdEnvironmentOffset;
    UINT otdEnvironmentSize;
    BYTE otdData[1];
} OLETARGETDEVICE;
typedef OLETARGETDEVICE FAR* LPOLETARGETDEVICE;

/* flags used in some methods */
#define OF_SET              0x0001
#define OF_GET              0x0002
#define OF_HANDLER          0x0004

/* return codes for OLE functions */
typedef enum
{
    OLE_OK,                     /* 0   Function operated correctly             */

    OLE_WAIT_FOR_RELEASE,       /* 1   Command has been initiated, client      */
                                /*     must wait for release. keep dispatching */
                                /*     messages till OLE_RELESE in callback    */

    OLE_BUSY,                   /* 2   Tried to execute a method while another */
                                /*     method is in progress.                  */

    OLE_ERROR_PROTECT_ONLY,     /* 3   Ole APIs are called in real mode        */
    OLE_ERROR_MEMORY,           /* 4   Could not alloc or lock memory          */
    OLE_ERROR_STREAM,           /* 5  (OLESTREAM) stream error                 */
    OLE_ERROR_STATIC,           /* 6   Non static object expected              */
    OLE_ERROR_BLANK,            /* 7   Critical data missing                   */
    OLE_ERROR_DRAW,             /* 8   Error while drawing                     */
    OLE_ERROR_METAFILE,         /* 9   Invalid metafile                        */
    OLE_ERROR_ABORT,            /* 10  Client chose to abort metafile drawing  */
    OLE_ERROR_CLIPBOARD,        /* 11  Failed to get/set clipboard data        */
    OLE_ERROR_FORMAT,           /* 12  Requested format is not available       */
    OLE_ERROR_OBJECT,           /* 13  Not a valid object                      */
    OLE_ERROR_OPTION,           /* 14  Invalid option(link update / render)    */
    OLE_ERROR_PROTOCOL,         /* 15  Invalid protocol                        */
    OLE_ERROR_ADDRESS,          /* 16  One of the pointers is invalid          */
    OLE_ERROR_NOT_EQUAL,        /* 17  Objects are not equal                   */
    OLE_ERROR_HANDLE,           /* 18  Invalid handle encountered              */
    OLE_ERROR_GENERIC,          /* 19  Some general error                      */
    OLE_ERROR_CLASS,            /* 20  Invalid class                           */
    OLE_ERROR_SYNTAX,           /* 21  Command syntax is invalid               */
    OLE_ERROR_DATATYPE,         /* 22  Data format is not supported            */
    OLE_ERROR_PALETTE,          /* 23  Invalid color palette                   */
    OLE_ERROR_NOT_LINK,         /* 24  Not a linked object                     */
    OLE_ERROR_NOT_EMPTY,        /* 25  Client doc contains objects.            */
    OLE_ERROR_SIZE,             /* 26  Incorrect buffer size passed to the api */
                                /*     that places some string in caller's     */
                                /*     buffer                                  */

    OLE_ERROR_DRIVE,            /* 27  Drive letter in doc name is invalid     */
    OLE_ERROR_NETWORK,          /* 28  Failed to establish connection to a     */
                                /*     network share on which the document     */
                                /*     is located                              */

    OLE_ERROR_NAME,             /* 29  Invalid name(doc name, object name),    */
                                /*     etc.. passed to the APIs                */

    OLE_ERROR_TEMPLATE,         /* 30  Server failed to load template          */
    OLE_ERROR_NEW,              /* 31  Server failed to create new doc         */
    OLE_ERROR_EDIT,             /* 32  Server failed to create embedded        */
                                /*     instance                                */
    OLE_ERROR_OPEN,             /* 33  Server failed to open document,         */
                                /*     possible invalid link                   */

    OLE_ERROR_NOT_OPEN,         /* 34  Object is not open for editing          */
    OLE_ERROR_LAUNCH,           /* 35  Failed to launch server                 */
    OLE_ERROR_COMM,             /* 36  Failed to communicate with server       */
    OLE_ERROR_TERMINATE,        /* 37  Error in termination                    */
    OLE_ERROR_COMMAND,          /* 38  Error in execute                        */
    OLE_ERROR_SHOW,             /* 39  Error in show                           */
    OLE_ERROR_DOVERB,           /* 40  Error in sending do verb, or invalid    */
                                /*     verb                                    */
    OLE_ERROR_ADVISE_NATIVE,    /* 41  Item could be missing                   */
    OLE_ERROR_ADVISE_PICT,      /* 42  Item could be missing or server doesn't */
                                /*     this format.                            */

    OLE_ERROR_ADVISE_RENAME,    /* 43  Server doesn't support rename           */
    OLE_ERROR_POKE_NATIVE,      /* 44  Failure of poking native data to server */
    OLE_ERROR_REQUEST_NATIVE,   /* 45  Server failed to render native data     */
    OLE_ERROR_REQUEST_PICT,     /* 46  Server failed to render presentation    */
                                /*     data                                    */
    OLE_ERROR_SERVER_BLOCKED,   /* 47  Trying to block a blocked server or     */
                                /*     trying to revoke a blocked server       */
                                /*     or document                             */

    OLE_ERROR_REGISTRATION,     /* 48  Server is not registered in regestation */
                                /*     data base                               */
    OLE_ERROR_ALREADY_REGISTERED,/*49  Trying to register same doc multiple    */
                                 /*    times                                   */
    OLE_ERROR_TASK,             /* 50  Server or client task is invalid        */
    OLE_ERROR_OUTOFDATE,        /* 51  Object is out of date                   */
    OLE_ERROR_CANT_UPDATE_CLIENT,/* 52 Embed doc's client doesn't accept       */
                                /*     updates                                 */
    OLE_ERROR_UPDATE,           /* 53  erorr while trying to update            */
    OLE_ERROR_SETDATA_FORMAT,   /* 54  Server app doesn't understand the       */
                                /*     format given to its SetData method      */
    OLE_ERROR_STATIC_FROM_OTHER_OS,/* 55 trying to load a static object created */
                                   /*    on another Operating System           */

    /*  Following are warnings */
    OLE_WARN_DELETE_DATA = 1000 /*     Caller must delete the data when he is  */
                                /*     done with it.                           */
} OLESTATUS;



/* Codes for CallBack events */
typedef enum
{
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
    OLE_QUERY_PAINT,        /* 4  Interruptible paint support                */
    OLE_RELEASE,            /* 5  Object is released(asynchronous operation  */
                            /*    is completed)                              */
    OLE_QUERY_RETRY         /* 6  Query for retry when server sends busy ACK */
} OLE_NOTIFICATION;

typedef enum
{
    OLE_NONE,               /* 0  no method active                           */
    OLE_DELETE,             /* 1  object delete                              */
    OLE_LNKPASTE,           /* 2  PasteLink(auto reconnect)                  */
    OLE_EMBPASTE,           /* 3  paste(and update)                          */
    OLE_SHOW,               /* 4  Show                                       */
    OLE_RUN,                /* 5  Run                                        */
    OLE_ACTIVATE,           /* 6  Activate                                   */
    OLE_UPDATE,             /* 7  Update                                     */
    OLE_CLOSE,              /* 8  Close                                      */
    OLE_RECONNECT,          /* 9  Reconnect                                  */
    OLE_SETUPDATEOPTIONS,   /* 10 setting update options                     */
    OLE_SERVERUNLAUNCH,     /* 11 server is being unlaunched                 */
    OLE_LOADFROMSTREAM,     /* 12 LoadFromStream(auto reconnect)             */
    OLE_SETDATA,            /* 13 OleSetData                                 */
    OLE_REQUESTDATA,        /* 14 OleRequestData                             */
    OLE_OTHER,              /* 15 other misc async operations                */
    OLE_CREATE,             /* 16 create                                     */
    OLE_CREATEFROMTEMPLATE, /* 17 CreatefromTemplate                         */
    OLE_CREATELINKFROMFILE, /* 18 CreateLinkFromFile                         */
    OLE_COPYFROMLNK,        /* 19 CopyFromLink(auto reconnect)               */
    OLE_CREATEFROMFILE,     /* 20 CreateFromFile                             */
    OLE_CREATEINVISIBLE     /* 21 CreateInvisible                            */
} OLE_RELEASE_METHOD;

/* rendering options */
typedef enum
{
    olerender_none, 
    olerender_draw, 
    olerender_format 
} OLEOPT_RENDER;

/* standard clipboard format type */
typedef WORD OLECLIPFORMAT;

/* Link update options */
typedef enum
{
    oleupdate_always,
    oleupdate_onsave,
#ifndef OLE_INTERNAL
    oleupdate_oncall
#else
    oleupdate_oncall,
    oleupdate_onclose
#endif  /* OLE_INTERNAL */
} OLEOPT_UPDATE;

typedef HANDLE  HOBJECT;
typedef LONG    LHSERVER;
typedef LONG    LHCLIENTDOC;
typedef LONG    LHSERVERDOC;

typedef struct _OLEOBJECT FAR*  LPOLEOBJECT;
typedef struct _OLESTREAM FAR*  LPOLESTREAM;
typedef struct _OLECLIENT FAR*  LPOLECLIENT;


#ifndef OLE_INTERNAL
/* object method table definitions. */
typedef struct _OLEOBJECTVTBL
{
    void FAR*      (CALLBACK* QueryProtocol)        (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* Release)              (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Show)                 (LPOLEOBJECT, BOOL);
    OLESTATUS      (CALLBACK* DoVerb)               (LPOLEOBJECT, UINT, BOOL, BOOL);
    OLESTATUS      (CALLBACK* GetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
    OLESTATUS      (CALLBACK* SetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
    OLESTATUS      (CALLBACK* SetTargetDevice)      (LPOLEOBJECT, HGLOBAL);
    OLESTATUS      (CALLBACK* SetBounds)            (LPOLEOBJECT, OLE_CONST RECT FAR*);
    OLECLIPFORMAT  (CALLBACK* EnumFormats)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* SetColorScheme)       (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
    /* Server has to implement only the above methods. */

#ifndef SERVERONLY
    /* Extra methods required for client. */
    OLESTATUS      (CALLBACK* Delete)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* SetHostNames)         (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* SaveToStream)         (LPOLEOBJECT, LPOLESTREAM);
    OLESTATUS      (CALLBACK* Clone)                (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* CopyFromLink)         (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* Equal)                (LPOLEOBJECT, LPOLEOBJECT);
    OLESTATUS      (CALLBACK* CopyToClipboard)      (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Draw)                 (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
    OLESTATUS      (CALLBACK* Activate)             (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
    OLESTATUS      (CALLBACK* Execute)              (LPOLEOBJECT, HGLOBAL, UINT);
    OLESTATUS      (CALLBACK* Close)                (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Update)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Reconnect)            (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* ObjectConvert)        (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* GetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE FAR*);
    OLESTATUS      (CALLBACK* SetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE);
    
    OLESTATUS      (CALLBACK* Rename)               (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* QueryName)            (LPOLEOBJECT, LPSTR, UINT FAR*);

    OLESTATUS      (CALLBACK* QueryType)            (LPOLEOBJECT, LONG FAR*);
    OLESTATUS      (CALLBACK* QueryBounds)          (LPOLEOBJECT, RECT FAR*);
    OLESTATUS      (CALLBACK* QuerySize)            (LPOLEOBJECT, DWORD FAR*);
    OLESTATUS      (CALLBACK* QueryOpen)            (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryOutOfDate)       (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* QueryReleaseStatus)   (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryReleaseError)    (LPOLEOBJECT);
    OLE_RELEASE_METHOD (CALLBACK* QueryReleaseMethod)(LPOLEOBJECT);

    OLESTATUS      (CALLBACK* RequestData)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* ObjectLong)           (LPOLEOBJECT, UINT, LONG FAR*);
    
/* This method is internal only */
    OLESTATUS      (CALLBACK* ChangeData)           (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
#endif  /* !SERVERONLY */
} OLEOBJECTVTBL;
typedef  OLEOBJECTVTBL FAR* LPOLEOBJECTVTBL;

typedef struct _OLEOBJECT
{
    LPOLEOBJECTVTBL    lpvtbl;
} OLEOBJECT;
#endif  /* !OLE_NTERNAL */

/* ole client definitions */
typedef struct _OLECLIENTVTBL
{
    int (CALLBACK* CallBack)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);
} OLECLIENTVTBL;

typedef  OLECLIENTVTBL FAR*  LPOLECLIENTVTBL;

typedef struct _OLECLIENT
{
    LPOLECLIENTVTBL   lpvtbl;
} OLECLIENT;

/* Stream definitions */
typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, OLE_CONST void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL      lpstbl;
} OLESTREAM;

/* Public Function Prototypes */
OLESTATUS   WINAPI  OleDelete(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRelease(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSaveToStream(LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   WINAPI  OleEqual(LPOLEOBJECT, LPOLEOBJECT );
OLESTATUS   WINAPI  OleCopyToClipboard(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSetHostNames(LPOLEOBJECT, LPCSTR, LPCSTR);
OLESTATUS   WINAPI  OleSetTargetDevice(LPOLEOBJECT, HGLOBAL);
OLESTATUS   WINAPI  OleSetBounds(LPOLEOBJECT, const RECT FAR*);
OLESTATUS   WINAPI  OleSetColorScheme(LPOLEOBJECT, const LOGPALETTE FAR*);
OLESTATUS   WINAPI  OleQueryBounds(LPOLEOBJECT, RECT FAR*);
OLESTATUS   WINAPI  OleQuerySize(LPOLEOBJECT, DWORD FAR*);
OLESTATUS   WINAPI  OleDraw(LPOLEOBJECT, HDC, const RECT FAR*, const RECT FAR*, HDC);
OLESTATUS   WINAPI  OleQueryOpen(LPOLEOBJECT);
OLESTATUS   WINAPI  OleActivate(LPOLEOBJECT, UINT, BOOL, BOOL, HWND, const RECT FAR*);
OLESTATUS   WINAPI  OleExecute(LPOLEOBJECT, HGLOBAL, UINT);
OLESTATUS   WINAPI  OleClose(LPOLEOBJECT);
OLESTATUS   WINAPI  OleUpdate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleReconnect(LPOLEOBJECT);
OLESTATUS   WINAPI  OleGetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE FAR*);
OLESTATUS   WINAPI  OleSetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE);
void FAR*   WINAPI  OleQueryProtocol(LPOLEOBJECT, LPCSTR);

/* Routines related to asynchronous operations. */
OLESTATUS   WINAPI  OleQueryReleaseStatus(LPOLEOBJECT);
OLESTATUS   WINAPI  OleQueryReleaseError(LPOLEOBJECT);
OLE_RELEASE_METHOD WINAPI OleQueryReleaseMethod(LPOLEOBJECT);

OLESTATUS   WINAPI  OleQueryType(LPOLEOBJECT, LONG FAR*);

/* LOWORD is major version, HIWORD is minor version */
DWORD       WINAPI  OleQueryClientVersion(void);
DWORD       WINAPI  OleQueryServerVersion(void);

/* Converting to format (as in clipboard): */
OLECLIPFORMAT  WINAPI  OleEnumFormats(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleGetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
OLESTATUS   WINAPI  OleSetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS   WINAPI  OleQueryOutOfDate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRequestData(LPOLEOBJECT, OLECLIPFORMAT);

/* Query apis for creation from clipboard */
OLESTATUS   WINAPI  OleQueryLinkFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleQueryCreateFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);

/* Object creation functions */
OLESTATUS   WINAPI  OleCreateFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR,  LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleLoadFromStream(LPOLESTREAM, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCreate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateInvisible(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);
OLESTATUS   WINAPI  OleCreateFromTemplate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCopyFromLink(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleObjectConvert(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleRename(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  OleQueryName(LPOLEOBJECT, LPSTR, UINT FAR*);
OLESTATUS   WINAPI  OleRevokeObject(LPOLECLIENT);
BOOL        WINAPI  OleIsDcMeta(HDC);

/* client document API */
OLESTATUS   WINAPI  OleRegisterClientDoc(LPCSTR, LPCSTR, LONG, LHCLIENTDOC FAR*);
OLESTATUS   WINAPI  OleRevokeClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleRenameClientDoc(LHCLIENTDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleSavedClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleEnumObjects(LHCLIENTDOC, LPOLEOBJECT FAR*);

/* server usage definitions */
typedef enum {
    OLE_SERVER_MULTI,           /* multiple instances */
    OLE_SERVER_SINGLE           /* single instance(multiple document) */
} OLE_SERVER_USE;

/* Server API */
typedef struct _OLESERVER FAR*  LPOLESERVER;

OLESTATUS   WINAPI  OleRegisterServer(LPCSTR, LPOLESERVER, LHSERVER FAR*, HINSTANCE, OLE_SERVER_USE);
OLESTATUS   WINAPI  OleRevokeServer(LHSERVER);
OLESTATUS   WINAPI  OleBlockServer(LHSERVER);
OLESTATUS   WINAPI  OleUnblockServer(LHSERVER, BOOL FAR*);

/* APIs to keep server open */
OLESTATUS   WINAPI  OleLockServer(LPOLEOBJECT, LHSERVER FAR*);
OLESTATUS   WINAPI  OleUnlockServer(LHSERVER);

/* Server document API */

typedef struct _OLESERVERDOC FAR*  LPOLESERVERDOC;

OLESTATUS   WINAPI  OleRegisterServerDoc(LHSERVER, LPCSTR, LPOLESERVERDOC, LHSERVERDOC FAR*);
OLESTATUS   WINAPI  OleRevokeServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleRenameServerDoc(LHSERVERDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleSavedServerDoc(LHSERVERDOC);

typedef struct _OLESERVERVTBL
{
    OLESTATUS (CALLBACK* Open)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* document name                        */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Create)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* CreateFromTemplate)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* lp template name                     */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Edit)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Exit)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Release)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Execute)(LPOLESERVER, HGLOBAL);
                                    /* lp OLESERVER                         */
                                    /* handle to command strings            */
} OLESERVERVTBL;
typedef  OLESERVERVTBL FAR*  LPOLESERVERVTBL;

typedef struct _OLESERVER
{
    LPOLESERVERVTBL    lpvtbl;
} OLESERVER;

typedef struct _OLESERVERDOCVTBL
{
    OLESTATUS (CALLBACK* Save)      (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* Close)     (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetHostNames)(LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS (CALLBACK* SetDocDimensions)(LPOLESERVERDOC, OLE_CONST RECT FAR*);
    OLESTATUS (CALLBACK* GetObject) (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR*, LPOLECLIENT);
    OLESTATUS (CALLBACK* Release)   (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetColorScheme)(LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);
    OLESTATUS (CALLBACK* Execute)  (LPOLESERVERDOC, HGLOBAL);
} OLESERVERDOCVTBL;
typedef  OLESERVERDOCVTBL FAR*  LPOLESERVERDOCVTBL;

typedef struct _OLESERVERDOC
{
    LPOLESERVERDOCVTBL lpvtbl;
} OLESERVERDOC;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_OLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\penwin.h ===
/*****************************************************************************\
*                                                                             *
* penwin.h -    Pen Windows functions, types, and definitions                 *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_WINDOWS
#include <windows.h>    /* <windows.h> must be pre-included */
#endif /* _INC_WINDOWS */

#ifndef _INC_PENWIN     /* prevent multiple includes */
#define _INC_PENWIN

#ifndef RC_INVOKED
#pragma pack(1)
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {
#endif	/* __cplusplus */

/****** General Pen Windows Definitions *************************************/

typedef int                    REC;    
typedef LONG                   SYV;    
typedef SYV FAR                *LPSYV;
typedef HANDLE                 HREC;
typedef int                    CL;
typedef LONG                   ALC;
typedef UINT                   HKP;
typedef int (CALLBACK * LPDF)(int, LPVOID, LPVOID, int, DWORD, DWORD);

#define BITPENUP               0x8000
#define FPenUpX(x)             (((x) & BITPENUP)!=0)

/* Default pen cursor to indicate writing, points northwest */
#define IDC_PEN                MAKEINTRESOURCE(32631)

/* alternate select cursor: upsidedown standard arrow, points southeast */
#define IDC_ALTSELECT          MAKEINTRESOURCE(32501)

#define RC_WDEFAULT            (0xFFFF)
#define RC_LDEFAULT            (0xFFFFFFFFL)
#define RC_WDEFAULTFLAGS       (0x8000)
#define RC_LDEFAULTFLAGS       (0x80000000L)

/* HIWORD(SYV) defines and detection macros */

#define SYVHI_SPECIAL          0
#define FIsSpecial(syv)        (HIWORD((syv))==SYVHI_SPECIAL)
#define SYVHI_ANSI             1
#define FIsAnsi(syv)           (HIWORD((syv))==SYVHI_ANSI)
#define SYVHI_GESTURE          2
#define FIsGesture(syv)        (HIWORD((syv))==SYVHI_GESTURE)
#define SYVHI_KANJI            3
#define FIsKanji(syv)          (HIWORD((syv))==SYVHI_KANJI)
#define SYVHI_SHAPE            4
#define FIsShape(syv)          (HIWORD((syv))==SYVHI_SHAPE)
#define SYVHI_UNICODE          5
#define FIsUniCode(syv)        (HIWORD((syv))==SYVHI_UNICODE)
#define SYVHI_VKEY             6
#define FIsVKey(syv)           (HIWORD((syv))==SYVHI_VKEY)

/* Macros to convert between SYV and ANSI */

#define ChSyvToAnsi(syv)       ((BYTE) (LOBYTE(LOWORD((syv)))))
#define SyvCharacterToSymbol(c) ((LONG)(unsigned char)(c) | 0x00010000)
#define SyvKanjiToSymbol(c) ((LONG)(WORD)(c) | 0x00030000)

/* SYV values with special meanings to Pen Windows */

#define SYV_NULL               0x00000000L
#define SYV_UNKNOWN            0x00000001L
#define SYV_EMPTY              0x00000003L
#define SYV_BEGINOR            0x00000010L
#define SYV_ENDOR              0x00000011L
#define SYV_OR                 0x00000012L
#define SYV_SOFTNEWLINE        0x00000020L
#define SYV_SPACENULL          SyvCharacterToSymbol('\0')

/* SYV values for gestures (map into UNICODE space) */

#define SYV_KKCONVERT          0x0002FFD4L
#define SYV_CLEAR              0x0002FFD5L
#define SYV_EXTENDSELECT       0x0002FFD8L
#define SYV_UNDO               0x0002FFD9L
#define SYV_COPY               0x0002FFDAL
#define SYV_CUT                0x0002FFDBL
#define SYV_PASTE              0x0002FFDCL
#define SYV_CLEARWORD          0x0002FFDDL
#define SYV_USER               0x0002FFDEL	/* ;Reserved */
#define SYV_CORRECT            0x0002FFDFL

#define SYV_BACKSPACE          0x00020008L
#define SYV_TAB                0x00020009L
#define SYV_RETURN             0x0002000DL
#define SYV_SPACE              0x00020020L

#define FIsStdGesture(syv)     \
     ((syv) == SYV_CLEAR       \
   || (syv) == SYV_EXTENDSELECT\
   || (syv) == SYV_UNDO        \
   || (syv) == SYV_COPY        \
   || (syv) == SYV_CUT         \
   || (syv) == SYV_PASTE       \
   || (syv) == SYV_CLEARWORD   \
   || (syv) == SYV_KKCONVERT   \
   || (syv) == SYV_USER        \
   || (syv) == SYV_CORRECT)

#define FIsAnsiGesture(syv)    \
     ((syv) == SYV_BACKSPACE   \
   || (syv) == SYV_TAB         \
   || (syv) == SYV_RETURN      \
   || (syv) == SYV_SPACE)

/* Application specific gestures, Circle a-z and Circle A-Z */

#define SYV_APPGESTUREMASK     0x00020000L
#define SYV_CIRCLEUPA          0x000224B6L
#define SYV_CIRCLEUPZ          0x000224CFL
#define SYV_CIRCLELOA          0x000224D0L
#define SYV_CIRCLELOZ          0x000224E9L

/* Gesture Macros */

#define FIsLoAppGesture(syv)   (syv >= SYV_CIRCLELOA && syv <= SYV_CIRCLELOZ)
#define FIsUpAppGesture(syv)   (syv >= SYV_CIRCLEUPA && syv <= SYV_CIRCLEUPZ)
#define FIsAppGesture(syv)     (syv>=SYV_CIRCLEUPA && syv<=SYV_CIRCLELOZ)

#define SyvAppGestureFromLoAnsi(ansi) ((DWORD)(BYTE)ansi- 'a' + SYV_CIRCLELOA)
#define SyvAppGestureFromUpAnsi(ansi) ((DWORD)(BYTE)ansi- 'A' + SYV_CIRCLEUPA)
#define AnsiFromSyvAppGesture(syv) ChSyvToAnsi( \
    syv-(FIsUpAppGesture(syv)? SYV_CIRCLEUPA-(SYV)'A': SYV_CIRCLELOA-(SYV)'a'))

/* SYV definitions for shapes */

#define SYV_SHAPELINE          0x00040001L
#define SYV_SHAPEELLIPSE       0x00040002L
#define SYV_SHAPERECT          0x00040003L
#define SYV_SHAPEMIN           SYV_SHAPELINE
#define SYV_SHAPEMAX           SYV_SHAPERECT

/****** Recognition Error Codes *********************************************/

#define REC_OEM                (-1024)
#define REC_LANGUAGE           (-48)
#define REC_GUIDE              (-47)
#define REC_PARAMERROR         (-46)
#define REC_INVALIDREF         (-45)
#define REC_RECTEXCLUDE        (-44)
#define REC_RECTBOUND          (-43)
#define REC_PCM                (-42)
#define REC_RESULTMODE         (-41)
#define REC_HWND               (-40)
#define REC_ALC                (-39)
#define REC_ERRORLEVEL         (-38)
#define REC_CLVERIFY           (-37)
#define REC_DICT               (-36)
#define REC_HREC               (-35)
#define REC_BADEVENTREF        (-33)
#define REC_NOCOLLECTION       (-32)

#define REC_DEBUG              (-32)    

#define REC_POINTEREVENT       (-31)
#define REC_BADHPENDATA        (-9)    
#define REC_OOM                (-8)
#define REC_NOINPUT            (-7)
#define REC_NOTABLET           (-6)
#define REC_BUSY               (-5)
#define REC_BUFFERTOOSMALL     (-4)
#define REC_ABORT              (-3)

#define REC_OVERFLOW           (-1)

#define REC_OK                 0
#define REC_TERMBOUND          1
#define REC_TERMEX             2
#define REC_TERMPENUP          3
#define REC_TERMRANGE          4
#define REC_TERMTIMEOUT        5
#define REC_DONE               6
#define REC_TERMOEM            512

/****** Pen Driver Structures and Entry points ******************************/

typedef struct tagOEMPENINFO
   {
   UINT wPdt;
   UINT wValueMax;
   UINT wDistinct;
   }
   OEMPENINFO, FAR *LPOEMPENINFO;

#define PDT_NULL               0
#define PDT_PRESSURE           1
#define PDT_HEIGHT             2
#define PDT_ANGLEXY            3
#define PDT_ANGLEZ             4
#define PDT_BARRELROTATION     5
#define PDT_OEMSPECIFIC        16

#define MAXOEMDATAWORDS        6

typedef struct tagPENPACKET
   {
   UINT wTabletX;
   UINT wTabletY;
   UINT wPDK;
   UINT rgwOemData[MAXOEMDATAWORDS];
   }
   PENPACKET, FAR *LPPENPACKET;

typedef BOOL (CALLBACK * LPFNRAWHOOK)(LPPENPACKET);

typedef struct tagPENINFO
   {
   UINT cxRawWidth;       
   UINT cyRawHeight;       
   UINT wDistinctWidth;   
   UINT wDistinctHeight;  
   int nSamplingRate; 
   int nSamplingDist; 
   LONG lPdc;        
   int cPens;        
   int cbOemData;    
   OEMPENINFO rgoempeninfo[MAXOEMDATAWORDS];  
   UINT rgwReserved[8];     
   }
   PENINFO, FAR *LPPENINFO;

#define PDC_INTEGRATED         0x00000001L
#define PDC_PROXIMITY          0x00000002L
#define PDC_RANGE              0x00000004L
#define PDC_INVERT             0x00000008L
#define PDC_RELATIVE           0x00000010L
#define PDC_BARREL1            0x00000020L
#define PDC_BARREL2            0x00000040L
#define PDC_BARREL3            0x00000080L

typedef struct tagSTROKEINFO
   {
   UINT cPnt;        
   UINT cbPnts;    
   UINT wPdk;        
   DWORD dwTick;    
   }
   STROKEINFO, FAR *LPSTROKEINFO;

typedef struct tagCALBSTRUCT
   {
   int wOffsetX;
   int wOffsetY;
   int wDistinctWidth;
   int wDistinctHeight;
   }
   CALBSTRUCT, FAR *LPCALBSTRUCT;

/****** DRV_ values for pen driver specific messages ************************/

#define DRV_SetPenDriverEntryPoints    DRV_RESERVED+1
#define DRV_RemovePenDriverEntryPoints DRV_RESERVED+2
#define DRV_SetPenSamplingRate         DRV_RESERVED+3
#define DRV_SetPenSamplingDist         DRV_RESERVED+4
#define DRV_GetName                    DRV_RESERVED+5
#define DRV_GetVersion                 DRV_RESERVED+6
#define DRV_GetPenInfo                 DRV_RESERVED+7
#define DRV_GetCalibration             DRV_RESERVED+11
#define DRV_SetCalibration             DRV_RESERVED+12

VOID WINAPI UpdatePenInfo(LPPENINFO);
BOOL WINAPI EndPenCollection(REC);
REC  WINAPI GetPenHwData(LPPOINT, LPVOID, int, UINT, LPSTROKEINFO);
REC  WINAPI GetPenHwEventData(UINT, UINT, LPPOINT, LPVOID, int, LPSTROKEINFO);
VOID WINAPI PenPacket(VOID);
BOOL WINAPI SetPenHook(HKP, LPFNRAWHOOK);

/****** Pen Hardware Constants **********************************************/

#define PDK_UP                 0x0000    
#define PDK_DOWN               0x0001    
#define PDK_BARREL1            0x0002    
#define PDK_BARREL2            0x0004    
#define PDK_BARREL3            0x0008    
#define PDK_TRANSITION         0x0010    
#define PDK_INVERTED           0x0080    
#define PDK_OUTOFRANGE         0x4000    
#define PDK_DRIVER             0x8000    
#define PDK_TIPMASK            0x0001    
#define PDK_SWITCHES           (PDK_DOWN|PDK_BARREL1|PDK_BARREL2|PDK_BARREL3)

#define PCM_PENUP              0x00000001L
#define PCM_RANGE              0x00000002L
#define PCM_INVERT             0x00000020L
#define PCM_RECTEXCLUDE        0x00002000L
#define PCM_RECTBOUND          0x00004000L
#define PCM_TIMEOUT            0x00008000L
#define PCM_ADDDEFAULTS        RC_LDEFAULTFLAGS /* 0x80000000L */

/****** Virtual Event Layer *************************************************/

VOID WINAPI PostVirtualKeyEvent(UINT, BOOL);
VOID WINAPI PostVirtualMouseEvent(UINT, int, int);
VOID WINAPI AtomicVirtualEvent(BOOL);

#define VWM_MOUSEMOVE          0x0001
#define VWM_MOUSELEFTDOWN      0x0002
#define VWM_MOUSELEFTUP        0x0004
#define VWM_MOUSERIGHTDOWN     0x0008
#define VWM_MOUSERIGHTUP       0x0010

/****** RC Definition *************************************************************/

#define CL_NULL                0
#define CL_MINIMUM             1
#define CL_MAXIMUM             100
#define INKWIDTH_MINIMUM       0
#define INKWIDTH_MAXIMUM       15
#define ENUM_MINIMUM           1
#define ENUM_MAXIMUM           4096
#define MAXDICTIONARIES        16

typedef struct tagGUIDE
   {
   int xOrigin;    
   int yOrigin;
   int cxBox;
   int cyBox;
   int cxBase;
   int cyBase;
   int cHorzBox;
   int cVertBox;
   int cyMid;
   }
   GUIDE, FAR *LPGUIDE;

typedef BOOL (CALLBACK * RCYIELDPROC)(VOID);

#define cbRcLanguageMax        44
#define cbRcUserMax            32
#define cbRcrgbfAlcMax         32
#define cwRcReservedMax        8

typedef struct tagRC
   {
   HREC hrec;
   HWND hwnd;
   UINT wEventRef;        
   UINT wRcPreferences;
   LONG lRcOptions;
   RCYIELDPROC lpfnYield;
   BYTE lpUser[cbRcUserMax];
   UINT wCountry;
   UINT wIntlPreferences;
   char lpLanguage[cbRcLanguageMax];
   LPDF rglpdf[MAXDICTIONARIES];
   UINT wTryDictionary;
   CL clErrorLevel;
   ALC alc;
   ALC alcPriority;
   BYTE rgbfAlc[cbRcrgbfAlcMax];
   UINT wResultMode;
   UINT wTimeOut;
   LONG lPcm;
   RECT rectBound;
   RECT rectExclude;
   GUIDE guide;
   UINT wRcOrient;
   UINT wRcDirect;
   int nInkWidth;
   COLORREF rgbInk;
   DWORD dwAppParam;
   DWORD dwDictParam;
   DWORD dwRecognizer;
   UINT rgwReserved[cwRcReservedMax];
   }
   RC, FAR *LPRC;

typedef HANDLE HPENDATA;

typedef struct tagSYC
   {
   UINT wStrokeFirst;
   UINT wPntFirst;
   UINT wStrokeLast;
   UINT wPntLast;
   BOOL fLastSyc;
   }
   SYC, FAR *LPSYC;
    
#define wPntAll                (UINT)0xFFFF
#define iSycNull               (-1)

typedef struct tagSYE
   {
   SYV syv;
   LONG lRecogVal;
   CL cl;
   int iSyc;
   }
   SYE, FAR *LPSYE;

#define MAXHOTSPOT             8

typedef struct tagSYG
   {
   POINT rgpntHotSpots[MAXHOTSPOT];
   int cHotSpot;
   int nFirstBox;
   LONG lRecogVal;
   LPSYE lpsye;
   int cSye;
   LPSYC lpsyc;
   int cSyc;
   }
   SYG, FAR *LPSYG;

typedef int (CALLBACK *ENUMPROC)(LPSYV, int, VOID FAR *);

typedef struct tagRCRESULT
   {
   SYG syg;
   UINT wResultsType;
   int cSyv;
   LPSYV lpsyv;
   HANDLE hSyv;
   int nBaseLine;
   int nMidLine;
   HPENDATA hpendata;
   RECT rectBoundInk;
   POINT pntEnd;
   LPRC lprc;
   }
   RCRESULT, FAR *LPRCRESULT;

#define RCRT_DEFAULT           0x0000
#define RCRT_UNIDENTIFIED      0x0001 
#define RCRT_GESTURE           0x0002 
#define RCRT_NOSYMBOLMATCH     0x0004    
#define RCRT_PRIVATE           0x4000 
#define RCRT_NORECOG           0x8000 
#define RCRT_ALREADYPROCESSED  0x0008   
#define RCRT_GESTURETRANSLATED 0x0010 
#define RCRT_GESTURETOKEYS     0x0020 

#define HKP_SETHOOK            0
#define HKP_UNHOOK             0xFFFF
#define HWR_RESULTS            0
#define HWR_APPWIDE            1

#define PEN_NOINKWIDTH         0
#define LPDFNULL               ((LPDF)NULL)

#define RPA_DEFAULT            1

/* GetGlobalRC return codes */
#define GGRC_OK                0
#define GGRC_DICTBUFTOOSMALL   1
#define GGRC_PARAMERROR        2

/* SetGlobalRC return code flags */
#define SGRC_OK                0x0000
#define SGRC_USER              0x0001
#define SGRC_PARAMERROR        0x0002
#define SGRC_RC                0x0004
#define SGRC_RECOGNIZER        0x0008
#define SGRC_DICTIONARY        0x0010
#define SGRC_INIFILE           0x0020

#define GetWEventRef()         (LOWORD(GetMessageExtraInfo()))

HREC WINAPI InstallRecognizer(LPSTR);
VOID WINAPI UninstallRecognizer(HREC);
UINT WINAPI GetGlobalRC(LPRC, LPSTR, LPSTR, int);
UINT WINAPI SetGlobalRC(LPRC, LPSTR, LPSTR);
VOID WINAPI RegisterPenApp(UINT, BOOL);
UINT WINAPI IsPenAware(VOID);
BOOL WINAPI SetRecogHook(UINT, UINT, HWND);
VOID WINAPI InitRC(HWND, LPRC);
REC  WINAPI Recognize(LPRC);
REC  WINAPI RecognizeData(LPRC, HPENDATA);
BOOL WINAPI TrainInk(LPRC, HPENDATA, LPSYV);
BOOL WINAPI TrainContext(LPRCRESULT, LPSYE, int, LPSYC, int);
REC  WINAPI ProcessWriting(HWND, LPRC);    
BOOL WINAPI CorrectWriting(HWND, LPSTR, UINT, LPRC, DWORD, DWORD);
VOID WINAPI EmulatePen(BOOL);
int  WINAPI GetSymbolMaxLength(LPSYG);
int  WINAPI GetSymbolCount(LPSYG);
VOID WINAPI FirstSymbolFromGraph(LPSYG, LPSYV, int, int FAR *);
UINT WINAPI EnumSymbols(LPSYG, WORD, ENUMPROC, LPVOID);

/****** Miscellaneous Functions *********************************************/

BOOL WINAPI TPtoDP(LPPOINT, int);
BOOL WINAPI DPtoTP(LPPOINT, int);
VOID WINAPI BoundingRectFromPoints(LPPOINT, int, LPRECT);
BOOL WINAPI SymbolToCharacter(LPSYV, int, LPSTR, LPINT);
int  WINAPI CharacterToSymbol(LPSTR, int, LPSYV);
UINT WINAPI GetVersionPenWin(VOID);
BOOL WINAPI ExecuteGesture(HWND, SYV, LPRCRESULT);

/****** RC Options and Flags  ***********************************************/

#define ALC_ALL                0x000043FFL
#define ALC_DEFAULT            0x00000000L
#define ALC_LCALPHA            0x00000001L
#define ALC_UCALPHA            0x00000002L
#define ALC_ALPHA              0x00000003L
#define ALC_NUMERIC            0x00000004L
#define ALC_ALPHANUMERIC       0x00000007L
#define ALC_PUNC               0x00000008L
#define ALC_MATH               0x00000010L
#define ALC_MONETARY           0x00000020L
#define ALC_OTHER              0x00000040L
#define ALC_WHITE              0x00000100L
#define ALC_NONPRINT           0x00000200L
#define ALC_GESTURE            0x00004000L
#define ALC_USEBITMAP          0x00008000L
#define ALC_DBCS               0x00000400L
#define ALC_HIRAGANA           0x00010000L
#define ALC_KATAKANA           0x00020000L
#define ALC_KANJI              0x00040000L
#define ALC_OEM                0x0FF80000L
#define ALC_RESERVED           0xF0003800L
#define ALC_NOPRIORITY         0x00000000L
#define ALC_SYSMINIMUM (ALC_ALPHANUMERIC | ALC_PUNC | ALC_WHITE | ALC_GESTURE)

#define MpAlcB(lprc,i) ((lprc)->rgbfAlc[((i) & 0xff) >> 3])
#define MpIbf(i)       ((BYTE)(1 << ((i) & 7)))

#define SetAlcBitAnsi(lprc,i)      do {MpAlcB(lprc,i) |= MpIbf(i);} while (0)
#define ResetAlcBitAnsi(lprc,i)    do {MpAlcB(lprc,i) &= ~MpIbf(i);} while (0)
#define IsAlcBitAnsi(lprc, i)      ((MpAlcB(lprc,i) & MpIbf(i)) != 0)

#define RCD_DEFAULT            0
#define RCD_LR                 1
#define RCD_RL                 2
#define RCD_TB                 3
#define RCD_BT                 4

#define RCO_NOPOINTEREVENT     0x00000001L
#define RCO_SAVEALLDATA        0x00000002L
#define RCO_SAVEHPENDATA       0x00000004L
#define RCO_NOFLASHUNKNOWN     0x00000008L
#define RCO_TABLETCOORD        0x00000010L
#define RCO_NOSPACEBREAK       0x00000020L
#define RCO_NOHIDECURSOR       0x00000040L
#define RCO_NOHOOK             0x00000080L
#define RCO_BOXED              0x00000100L
#define RCO_SUGGEST            0x00000200L
#define RCO_DISABLEGESMAP      0x00000400L
#define RCO_NOFLASHCURSOR      0x00000800L
#define RCO_COLDRECOG          0x00008000L

#define RCP_LEFTHAND           0x0001
#define RCP_MAPCHAR            0x0004

#define RCOR_NORMAL            1
#define RCOR_RIGHT             2
#define RCOR_UPSIDEDOWN        3
#define RCOR_LEFT              4

#define RRM_STROKE             0
#define RRM_SYMBOL             1
#define RRM_WORD               2
#define RRM_NEWLINE            3
#define RRM_COMPLETE           16

#define RCIP_ALLANSICHAR       0x0001
#define RCIP_MASK              0x0001

#define CWR_STRIPCR            0x00000001L
#define CWR_STRIPLF            0x00000002L
#define CWR_STRIPTAB           0x00000004L
#define CWR_SINGLELINEEDIT     0x00000007L
#define CWR_TITLE              0x00000010L
#define CWR_KKCONVERT          0x00000020L

#define MAP_GESTOGES				(RCRT_GESTURE|RCRT_GESTURETRANSLATED)
#define MAP_GESTOVKEYS			(RCRT_GESTURETOKEYS|RCRT_ALREADYPROCESSED)

#define IsGestureToGesture(lprcresult)	(((lprcresult)->wResultstype & MAP_GESTOGES \
													 ) == MAP_GESTOGES)

#define IsGestureToVkeys(lprcresult)	(((lprcresult)->wResultstype & MAP_GESTOVKEYS \
													 ) == MAP_GESTOVKEYS)

#define SetAlreadyProcessed(lprcresult) ((lprcresult)->wResultsType = ((lprcresult)->wResultsType \
														& ~RCRT_GESTURETOKEYS) | RCRT_ALREADYPROCESSED)

/****** Pen Data Type *******************************************************/

typedef struct tagPENDATAHEADER
   {
   UINT wVersion;
   UINT cbSizeUsed;        
   UINT cStrokes;          
   UINT cPnt;              
   UINT cPntStrokeMax;
   RECT rectBound;
   UINT wPndts;            
   int  nInkWidth;
   DWORD rgbInk;
   }
   PENDATAHEADER, FAR *LPPENDATAHEADER, FAR *LPPENDATA;

#define PDTS_LOMETRIC          0x0000
#define PDTS_HIMETRIC          0x0001
#define PDTS_HIENGLISH         0x0002
#define PDTS_SCALEMAX          0x0003
#define PDTS_DISPLAY           0x0003
#define PDTS_ARBITRARY         0x0004
#define PDTS_SCALEMASK         0x000F
#define PDTS_STANDARDSCALE     PDTS_HIENGLISH 

#define PDTS_NOPENINFO         0x0100  
#define PDTS_NOUPPOINTS        0x0200  
#define PDTS_NOOEMDATA         0x0400
#define PDTS_NOCOLINEAR        0x0800  
#define PDTS_COMPRESSED        0x8000
#define PDTS_COMPRESSMETHOD    0x00F0  
#define PDTS_COMPRESS2NDDERIV  0x0010 

#define PDTT_DEFAULT           0x0000         
#define PDTT_PENINFO           PDTS_NOPENINFO 
#define PDTT_UPPOINTS          PDTS_NOUPPOINTS
#define PDTT_OEMDATA           PDTS_NOOEMDATA
#define PDTT_COLINEAR          PDTS_NOCOLINEAR 
#define PDTT_COMPRESS          PDTS_COMPRESSED
#define PDTT_DECOMPRESS        0x4000
#define PDTT_ALL (PDTT_PENINFO|PDTT_UPPOINTS|PDTT_OEMDATA|PDTT_COLINEAR)

#define DestroyPenData(hpendata) (GlobalFree(hpendata)==NULL)
#define EndEnumStrokes(hpendata) GlobalUnlock(hpendata)

BOOL WINAPI IsPenEvent(UINT, LONG);
BOOL WINAPI GetPenAsyncState(UINT);

BOOL WINAPI GetPenDataInfo(HPENDATA, LPPENDATAHEADER, LPPENINFO, DWORD);
BOOL WINAPI GetPenDataStroke(LPPENDATA, UINT, LPPOINT FAR *, LPVOID FAR *, LPSTROKEINFO );
BOOL WINAPI GetPointsFromPenData(HPENDATA, UINT, UINT, UINT, LPPOINT);
VOID WINAPI DrawPenData(HDC, LPRECT, HPENDATA);
BOOL WINAPI MetricScalePenData(HPENDATA, UINT);
BOOL WINAPI ResizePenData(HPENDATA, LPRECT);
BOOL WINAPI OffsetPenData(HPENDATA, int, int);
BOOL WINAPI RedisplayPenData(HDC, HPENDATA, LPPOINT, LPPOINT, int, DWORD);
HPENDATA  WINAPI CompactPenData(HPENDATA, UINT );
HPENDATA  WINAPI DuplicatePenData(HPENDATA, UINT);
HPENDATA  WINAPI CreatePenData(LPPENINFO, int, UINT, UINT); 
HPENDATA  WINAPI AddPointsPenData(HPENDATA, LPPOINT, LPVOID, LPSTROKEINFO);
LPPENDATA WINAPI BeginEnumStrokes(HPENDATA );

/****** New Windows Messages ************************************************/

#define WM_RCRESULT            (WM_PENWINFIRST+1)
#define WM_HOOKRCRESULT        (WM_PENWINFIRST+2)
#define WM_GLOBALRCCHANGE      (WM_PENWINFIRST+3)
#define WM_SKB                 (WM_PENWINFIRST+4)
#define WM_HEDITCTL            (WM_PENWINFIRST+5)

/****** Dictionary **********************************************************/

#define cbDictPathMax          255
#define DIRQ_QUERY             1
#define DIRQ_DESCRIPTION       2
#define DIRQ_CONFIGURE         3
#define DIRQ_OPEN              4
#define DIRQ_CLOSE             5
#define DIRQ_SETWORDLISTS      6
#define DIRQ_STRING            7
#define DIRQ_SUGGEST           8
#define DIRQ_ADD               9
#define DIRQ_DELETE            10
#define DIRQ_FLUSH             11
#define DIRQ_RCCHANGE          12
#define DIRQ_SYMBOLGRAPH       13
#define DIRQ_INIT					 14
#define DIRQ_CLEANUP				 15
#define DIRQ_COPYRIGHT			 16


#define DIRQ_USER              4096

BOOL WINAPI DictionarySearch(LPRC, LPSYE, int, LPSYV, int);

/****** Handwriting Edit Control ********************************************/

#define HE_GETRC               3
#define HE_SETRC               4
#define HE_GETINFLATE          5
#define HE_SETINFLATE          6
#define HE_GETUNDERLINE        7
#define HE_SETUNDERLINE        8
#define HE_GETINKHANDLE        9
#define HE_SETINKMODE          10
#define HE_STOPINKMODE         11
#define HE_GETRCRESULTCODE     12
#define HE_DEFAULTFONT         13
#define HE_CHARPOSITION        14
#define HE_CHAROFFSET          15

#define HE_GETRCRESULT         22

#define HE_KKCONVERT           30
#define HE_GETKKCONVERT        31
#define HE_CANCELKKCONVERT     32
#define HE_FIXKKCONVERT        33

#define HEKK_DEFAULT           0
#define HEKK_CONVERT           1
#define HEKK_CANDIDATE         2

#define HEP_NORECOG            0
#define HEP_RECOG              1
#define HEP_WAITFORTAP         2

#define HN_ENDREC              4
#define HN_DELAYEDRECOGFAIL    5

#define HN_RCRESULT            20

#define HN_ENDKKCONVERT        30

typedef struct tagRECTOFS
   {
   int dLeft;
   int dTop;
   int dRight;
   int dBottom;
   }
   RECTOFS, FAR *LPRECTOFS;

/****** Boxed Edit Control **************************************************/

typedef struct tagBOXLAYOUT
   {
   int cyCusp;      
   int cyEndCusp;
   UINT style;      
   DWORD rgbText;
   DWORD rgbBox; 
   DWORD rgbSelect;
   }
   BOXLAYOUT, FAR *LPBOXLAYOUT;

#define BXS_NONE               0U
#define BXS_RECT               1U
#define BXS_ENDTEXTMARK        2U
#define BXS_MASK               3U

#define HE_GETBOXLAYOUT        20
#define HE_SETBOXLAYOUT        21

#define BXD_CELLWIDTH          12
#define BXD_CELLHEIGHT         16
#define BXD_BASEHEIGHT         13
#define BXD_BASEHORZ           0
#define BXD_CUSPHEIGHT         2
#define BXD_ENDCUSPHEIGHT      4

/****** Screen Keyboard *****************************************************/

typedef struct tagSKBINFO
   {
   HWND hwnd;
   UINT nPad;
   BOOL fVisible;
   BOOL fMinimized;
   RECT rect;
   DWORD dwReserved;
   }
   SKBINFO, FAR *LPSKBINFO;

#define SKB_QUERY              0x0000
#define SKB_SHOW               0x0001
#define SKB_HIDE               0x0002
#define SKB_CENTER             0x0010
#define SKB_MOVE               0x0020
#define SKB_MINIMIZE           0x0040
#define SKB_FULL               0x0100
#define SKB_BASIC              0x0200
#define SKB_NUMPAD             0x0400

#define OBM_SKBBTNUP           32767
#define OBM_SKBBTNDOWN         32766
#define OBM_SKBBTNDISABLED     32765

#define SKN_CHANGED            1

#define SKN_POSCHANGED         1
#define SKN_PADCHANGED         2
#define SKN_MINCHANGED         4
#define SKN_VISCHANGED         8
#define SKN_TERMINATED         0xffff

BOOL WINAPI ShowKeyboard(HWND, UINT, LPPOINT, LPSKBINFO);

/****** New ComboBox Notifications  *****************************************/

#define CBN_ENDREC             16
#define CBN_DELAYEDRECOGFAIL   17
#define CBN_RCRESULT           18


#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif /* RC_INVOKED */

#endif /* #define _INC_PENWIN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\paswindw.inc ===
TYPE {Standard C types}
  int           = INTEGERC;
  short         = INTEGER;
  long          = INTEGER4;
  unsigned      = WORD;
  unsignedlong  = INTEGER4;
  LPshort       = ADS OF short;

CONST
  FALSE_             = 0;
  TRUE_              = 1;
  NULL_              = 0;

TYPE
  DWORD              = INTEGER4;
  BOOL               = int;
  PSTR               = ADR OF INTEGER1;
  NPSTR              = ADR OF INTEGER1;
  LPSTR              = ADS OF INTEGER1;
  LPINT              = ADS OF int;
  LPWORD             = ADS OF WORD;

CONST
  OBM_CLOSE          = 32767;
  OBM_SIZE           = 32766;
  OBM_UPARROW        = 32765;
  OBM_DNARROW        = 32764;
  OBM_RGARROW        = 32763;
  OBM_LfarROW        = 32762;
  OBM_BTSIZE         = 32761;
  OBM_CHECK          = 32760;
  OBM_CHECKBOXES     = 32759;
  OBM_BTNCORNERS     = 32758;
  OBM_REDUCE	     = 32757;
  OBM_ZOOM	     = 32756;
  OBM_RESTORE	     = 32755;
  OCR_NORMAL	     = 32512;
  OCR_IBEAM          = 32513;
  OCR_WAIT           = 32514;
  OCR_CROSS          = 32515;
  OCR_UP             = 32516;
  OCR_SIZE           = 32640;
  OCR_ICON	     = 32641;
  OCR_SIZENWSE	     = 32642;
  OCR_SIZENESW	     = 32643;
  OCR_SIZEWE	     = 32644;
  OCR_SIZENS	     = 32645;
  OCR_SIZEALL	     = 32646;

  OIC_SAMPLE         = 32512;
  OIC_HAND           = 32513;
  OIC_QUES           = 32514;
  OIC_BANG           = 32515;
  OIC_NOTE           = 32516;

(*  Scroll bar constants *)
  SB_HORZ            = 0;
  SB_VERT            = 1;
  SB_CTL	     = 2;
  SB_BOTH	     = 3;

(*  Scroll Commands *)
  SB_LINEUP          = 0;
  SB_LINEDOWN        = 1;
  SB_PAGEUP          = 2;
  SB_PAGEDOWN        = 3;
  SB_THUMBPOSITION   = 4;
  SB_THUMBTRACK      = 5;
  SB_TOP             = 6;
  SB_BOTTOM          = 7;
  SB_ENDSCROLL	     = 8;

(* ShowWindow commands *)

  SW_HIDE	     = 0;
  SW_SHOWNORMAL      = 1;
  SW_RESTORE	     = 1;
  SW_NORMAL	     = 1;
  SW_SHOWMINIMIZED   = 2;
  SW_SHOWMAXIMIZED   = 3;
  SW_MAXIMIZE	     = 3;
  SW_SHOWNOACTIVATE  = 4;
  SW_SHOW	     = 5;
  SW_MINIMIZE	     = 6;
  SW_SHOWMINNOACTIVE = 7;
  SW_SHOWNA	     = 8;


(* Old ShowWindow commands *)
  HIDE_WINDOW        = 0;
  SHOW_OPENWINDOW    = 1;
  SHOW_ICONWINDOW    = 2;
  SHOW_FULLSCREEN    = 3;
  SHOW_OPENNOACTIVATE = 4;

(* identifiers for the WM_SHOWWINDOW message *)
  SW_PARENTCLOSING    = 1;
  SW_OTHERZOOM        = 2;
  SW_PARENTOPENING    = 3;
  SW_OTHERUNZOOM      = 4;

(* flags for regions *)
  ERROR               = 0;
  NULLREGION          = 1;
  SIMPLEREGION        = 2;
  COMPLEXREGION       = 3;

(* styles for CombineRgn *)
  RGN_AND             = 1;
  RGN_OR              = 2;
  RGN_XOR             = 3;
  RGN_DIFF            = 4;
  RGN_COPY            = 5;

(* Virtual Keys, Standard Set *)

  VK_LBUTTON          = #01;
  VK_RBUTTON          = #02;
  VK_CANCEL           = #03;
  VK_MBUTTON          = #04    (* NOT contiguous with L & RBUTTON *);
  VK_BACK             = #08;
  VK_TAB              = #09;
  VK_CLEAR            = #0c;
  VK_RETURN           = #0d;
  VK_SHIFT            = #10;
  VK_CONTROL          = #11;
  VK_MENU             = #12;
  VK_PAUSE            = #13;
  VK_CAPITAL          = #14;
  VK_ESCAPE           = #1b;
  VK_SPACE            = #20;

  VK_PRIOR            = #21;
  VK_NEXT             = #22;
  VK_END              = #23;
  VK_HOME             = #24;
  VK_LEFT             = #25;
  VK_UP               = #26;
  VK_RIGHT            = #27;
  VK_DOWN             = #28;

(* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' *)
(* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' *)

  VK_SELECT           = #29;
  VK_PRINT            = #2a;
  VK_EXECUTE          = #2b;
  VK_INSERT           = #2d;
  VK_DELETE           = #2e;
  VK_HELP             = #2f;

  VK_NUMPAD0          = #60;
  VK_NUMPAD1          = #61;
  VK_NUMPAD2          = #62;
  VK_NUMPAD3          = #63;
  VK_NUMPAD4          = #64;
  VK_NUMPAD5          = #65;
  VK_NUMPAD6          = #66;
  VK_NUMPAD7          = #67;
  VK_NUMPAD8          = #68;
  VK_NUMPAD9          = #69;
  VK_MULTIPLY         = #6A;
  VK_ADD              = #6B;
  VK_SEPARATOR        = #6C;
  VK_SUBTRACT         = #6D;
  VK_DECIMAL          = #6E;
  VK_DIVIDE           = #6F;

  VK_F1               = #70;
  VK_F2               = #71;
  VK_F3               = #72;
  VK_F4               = #73;
  VK_F5               = #74;
  VK_F6               = #75;
  VK_F7               = #76;
  VK_F8               = #77;
  VK_F9               = #78;
  VK_F10              = #79;
  VK_F11              = #7a;
  VK_F12              = #7b;
  VK_F13              = #7c;
  VK_F14              = #7d;
  VK_F15              = #7e;
  VK_F16              = #7f;

  VK_NUMLOCK	      = #90;

(* SetWindowsHook codes *)
  WH_MSGFILTER        = -1;
  WH_JOURNALRECORD    = 0;
  WH_JOURNALPLAYBACK  = 1;
  WH_KEYBOARD         = 2;
  WH_GETMESSAGE       = 3;
  WH_CALLWNDPROC      = 4;
  WH_CBT	      = 5;
  WH_SYSMSGFILTER     = 6;
  WH_WINDOWMGR	      = 7;

(* HC_* Hook Codes *)
  HC_LPLPFNNEXT       = -2;
  HC_LPFNNEXT	      = -1;
  HC_ACTION	      =  0;
  HC_GETNEXT	      =  1;
  HC_SKIP	      =  2;
  HC_NOREM	      =  3;

(* CBT hook codes *)
  HCBT_MOVESIZE       =  0;
  HCBT_MINMAX	      =  1;
  HCBT_QS	      =  2;


(* WH_MSGFILTER filter proc codes *)
  MSGF_DIALOGBOX      = 0;
  MSGF_MESSAGEBOX     = 1;
  MSGF_MENU           = 2;
  MSGF_MOVE	      = 3;
  MSGF_SIZE	      = 4;
  MSGF_SCROLLBAR      = 5;
  MSGF_NEXTWINDOW     = 6;

(* Define window manager hook codes *)
  WC_INIT	      = 1;
  WC_SWP	      = 2;
  WC_DEFWINDOWPROC    = 3;
  WC_MINMAX	      = 4;
  WC_MOVE	      = 5;
  WC_SIZE	      = 6;
  WC_DRAWCAPTION      = 7;

(* message structure used in journaling  *)

TYPE

  EVENTMSG = RECORD
	message : unsigned;
	paramL	: WORD;
	paramH	: WORD;
	time	: DWORD;
  END;
  PEVENTMSGMSG	= ADR OF EVENTMSG;
  NPEVENTMSGMSG = ADR OF EVENTMSG;
  LPEVENTMSGMSG = ADS OF EVENTMSG;

CONST

(*  Binary raster ops *)
  R2_BLACK            = 1               (*  0       *);
  R2_NOTMERGEPEN      = 2               (* DPon     *);
  R2_MASKNOTPEN       = 3               (* DPna     *);
  R2_NOTCOPYPEN       = 4               (* PN       *);
  R2_MASKPENNOT       = 5               (* PDna     *);
  R2_NOT              = 6               (* Dn       *);
  R2_XORPEN           = 7               (* DPx      *);
  R2_NOTMASKPEN       = 8               (* DPan     *);
  R2_MASKPEN          = 9               (* DPa      *);
  R2_NOTXORPEN        = 10               (* DPxn     *);
  R2_NOP              = 11               (* D        *);
  R2_MERGENOTPEN      = 12               (* DPno     *);
  R2_COPYPEN          = 13               (* P        *);
  R2_MERGEPENNOT      = 14               (* PDno     *);
  R2_MERGEPEN         = 15               (* DPo      *);
  R2_WHITE            = 16               (*  1       *);

(*  Ternary raster operations *)
  SRCCOPY             = #00CC0020  (* dest=source                        *);
  SRCPAINT            = #00EE0086  (* dest=source OR dest                *);
  SRCAND              = #008800C6  (* dest = source AND dest             *);
  SRCINVERT           = #00660046  (* dest = source XOR      dest        *);
  SRCERASE            = #00440328  (* dest = source AND (not dest )      *);
  NOTSRCCOPY          = #00330008  (* dest = (not source)                *);
  NOTSRCERASE         = #001100A6  (* dest = (not source) AND (not dest) *);
  MERGECOPY           = #00C000CA  (* dest = (source AND pattern)        *);
  MERGEPAINT          = #00BB0226  (* dest = (NOT source) OR dest        *);
  PATCOPY             = #00F00021  (* dest = pattern                     *);
  PATPAINT            = #00FB0A09  (* dest = DPSnoo                      *);
  PATINVERT           = #005A0049  (* dest = pattern XOR     dest        *);
  DSTINVERT           = #00550009  (* dest = (not dest)                  *);
  BLACKNESS           = #00000042  (* dest = BLACK                       *);
  WHITENESS           = #00FF0062  (* dest = WHITE                       *);

(* StretchBlt() modes *)
  BLACKONWHITE        = 1;
  WHITEONBLACK        = 2;
  COLORONCOLOR        = 3;

(* PolyFill modes *)
  ALTERNATE           = 1;
  WINDING	      = 2;

(* text alignment options *)
  TA_UPDATECP	      = 1;
  TA_NOUPDATECP       = 0;

  TA_LEFT	      = 0;
  TA_RIGHT	      = 2;
  TA_CENTER	      = 6;

  TA_TOP	      = 0;
  TA_BOTTOM	      = 8;
  TA_BASELINE	      = 24;

  ETO_GRAYED	      = 1;
  ETO_OPAQUE	      = 2;
  ETO_CLIPPED	      = 4;



  ASPECT_FILTERING  = #0000001;

(* Meta file function numbers	*)
  META_SETBKCOLOR		= #201;
  META_SETBKMODE		= #102;
  META_SETMAPMODE		= #103;
  META_SETROP2			= #104;
  META_SETRELABS		= #105;
  META_SETPOLYFILLMODE		= #106;
  META_SETSTRETCHBLTMODE	= #107;
  META_SETTEXTCHAREXTRA 	= #108;
  META_SETTEXTCOLOR		= #209;
  META_SETTEXTJUSTIFICATION	= #20A;
  META_SETWINDOWORG		= #20B;
  META_SETWINDOWEXT		= #20C;
  META_SETVIEWPORTORG		= #20D;
  META_SETVIEWPORTEXT		= #20E;
  META_OFFSETWINDOWORG		= #20F;
  META_SCALEWINDOWEXT		= #400;
  META_OFFSETVIEWPORTORG	= #211;
  META_SCALEVIEWPORTEXT 	= #412;
  META_LINETO			= #213;
  META_MOVETO			= #214;
  META_EXCLUDECLIPRECT		= #415;
  META_INTERSECTCLIPRECT	= #416;
  META_ARC			= #817;
  META_ELLIPSE			= #418;
  META_FLOODFILL		= #419;
  META_PIE			= #81A;
  META_RECTANGLE		= #41B;
  META_ROUNDRECT		= #61C;
  META_PATBLT			= #61D;
  META_SAVEDC			= #01E;
  META_SETPIXEL 		= #41F;
  META_OFFSETCLIPRGN		= #220;
  META_TEXTOUT			= #521;
  META_BITBLT			= #922;
  META_STRETCHBLT		= #B23;
  META_POLYGON			= #324;
  META_POLYLINE 		= #325;
  META_ESCAPE			= #626;
  META_RESTOREDC		= #127;
  META_FILLREGION		= #228;
  META_FRAMEREGION		= #429;
  META_INVERTREGION		= #12A;
  META_PAINTREGION		= #12B;
  META_SELECTCLIPREGION 	= #12C;
  META_SELECTOBJECT		= #12D;
  META_SETTEXTALIGN		= #12E;
  META_DRAWTEXT 		= #62F;
  META_CHORD			= #630;
  META_CREATEBRUSH		= #0F8;
  META_CREATEPATTERNBRUSH	= #1F9;
  META_CREATEPENINDIRECT	= #2FA;
  META_CREATEFONTINDIRECT	= #2FB;
  META_CREATEBRUSHINDIRECT	= #2FC;
  META_CREATEBITMAPINDIRECT	= #2FD;
  META_CREATEBITMAP		= #6FE;
  META_CREATEREGION		= #6FF;

(* GDI escapes *)
  NEWFRAME            = 1;
  ABORTDOC            = 2;
  NEXTBAND            = 3;
  SETCOLORTABLE       = 4;
  GETCOLORTABLE       = 5;
  FLUSHOUTPUT         = 6;
  DRAFTMODE           = 7;
  QUERYESCSUPPORT     = 8;
  SETABORTPROC        = 9;
  STARTDOC            = 10;
  ENDDOC              = 11;
  GETPHYSPAGESIZE     = 12;
  GETPRINTINGOFFSET   = 13;
  GETSCALINGFACTOR    = 14;
  MFCOMMENT	      = 15;	   (* Metafile comment escape *)
  GETPENWIDTH	      = 16;
  SETCOPYCOUNT	      = 17;
  SELECTPAPERSOURCE   = 18;
  DEVICEDATA	      = 19;
  PASSTHROUGH	      = 19;
  GETTECHNOLGY	      = 20;
  SETENDCAP	      = 21;
  SETLINEJOIN	      = 22;
  SETMITERLIMIT       = 23;
  BANDINFO	      = 24;
  DRAWPATTERNRECT     = 25;
  GETVECTORPENSIZE    = 26;
  GETVECTORBRUSHSIZE  = 27;
  ENABLEDUPLEX	      = 28;
  ENABLEMANUALFEED    = 29;


(* spooler error code *)
  SP_NOTREPORTED      = #4000   (* set if GDI did not report error *);
  SP_ERROR            = -1      (* general errors who know what went wrong *);
  SP_APPABORT         = -2      (* app aborted the job - callback function returned false *);
  SP_USERABORT        = -3      (* user aborted the job through spooler's front end *);
  SP_OUTOFDISK        = -4      (* not enough disk space to spool *);
  SP_OUTOFMEMORY      = -5;

(* spooler WM_SPOOLERSTATUS wparm classes   *)

  PR_JOBSTATUS	      = #000;

(* Object definitions for GDI EnumObjects. *)
  OBJ_PEN             = 1;
  OBJ_BRUSH           = 2;


TYPE
  HANDLE             = WORD;
  PHANDLE            = ADR OF HANDLE;
  SPHANDLE           = ADR OF HANDLE;
  LPHANDLE           = ADS OF HANDLE;

  FARPROC            = ADSMEM;
  NEARPROC           = ADRMEM;
(*  GLOBALHANDLE       = HANDLE;  Conflict with function name *)
(*  LOCALHANDLE        = HANDLE;  Conflict with function name *)

  BITMAP = RECORD
    bmType           : short;
    bmWidth          : short;
    bmHeight         : short;
    bmWidthBytes     : short;
    bmPlanes         : BYTE;
    bmBitsPixel      : BYTE;
    bmBits           : LPSTR;
  END;
  PBITMAP            = ADR OF BITMAP;
  NPBITMAP           = ADR OF BITMAP;
  LPBITMAP           = ADS OF BITMAP;

  HSTR               = HANDLE;
  HICON              = HANDLE;
  HDC                = HANDLE;
  HMENU              = HANDLE;
  HPEN               = HANDLE;
  HFONT              = HANDLE;
  HBRUSH             = HANDLE;
  HBITMAP            = HANDLE;
  HCURSOR            = HANDLE;
  HRGN               = HANDLE;

  POINT = RECORD
    x                : int;
    y                : int;
  END;
  PPOINT             = ADR OF POINT;
  NPPOINT            = ADR OF POINT;
  LPPOINT            = ADS OF POINT;

  RECT = RECORD
    left             : int;
    top              : int;
    right            : int;
    bottom           : int;
  END;

  PRECT              = ADR OF RECT;
  NPRECT             = ADR OF RECT;
  LPRECT             = ADS OF RECT;

  WNDCLASS = RECORD
    style            : WORD;
    lpfnWndProc      : FARPROC;
    cbClsExtra       : int;
    cbWndExtra       : int;
    hInstance        : HANDLE;
    hIcon_           : HICON;
    hCursor_         : HCURSOR;
    hbrBackground    : HBRUSH;
    lpszMenuName     : LPSTR;
    lpszClassName    : LPSTR;
  END;
  PWNDCLASS          = ADR OF WNDCLASS;
  NPWNDCLASS         = ADR OF WNDCLASS;
  LPWNDCLASS         = ADS OF WNDCLASS;

  HWND               = HANDLE;

(* Message structure *)
  MSG = RECORD
    hwnd_            : HWND;
    message          : WORD;
    wParam           : WORD;
    lParam           : LONG;
    time             : DWORD;
    pt               : POINT;
  END;
  PMSG               = ADR OF MSG;
  NPMSG              = ADR OF MSG;
  LPMSG              = ADS OF MSG;

(* Window field offsets for GetWindowLong & GetWindowWord *)

CONST
  GWL_WNDPROC         = -4;
  GWW_HINSTANCE       = -6;
  GWW_HWNDPARENT      = -8;
  GWW_HWNDTEXT        = -10;
  GWW_ID              = -12;
  GWL_STYLE           = -16;

(* Class field offsets for GetClassLong & GetClassWord *)
  GCL_MENUNAME        = -8;
  GCW_HBRBACKGROUND   = -10;
  GCW_HCURSOR         = -12;
  GCW_HICON           = -14;
  GCW_HMODULE         = -16;
  GCW_CBWNDEXTRA      = -18;
  GCW_CBCLSEXTRA      = -20;
  GCL_WNDPROC         = -24;
  GCW_STYLE           = -26;

(* ** Window Procedure Messages *)

  WM_NULL             = #0000;
  WM_CREATE           = #0001;
  WM_DESTROY          = #0002;
  WM_MOVE             = #0003;
  WM_SIZEWAIT         = #0004;
  WM_SIZE             = #0005;
  WM_ACTIVATE         = #0006;
  WM_SETFOCUS_        = #0007;
  WM_KILLFOCUS_       = #0008;
  WM_SETVISIBLE       = #0009;
  WM_ENABLE           = #000a;
  WM_SETREDRAW        = #000b;
  WM_SETTEXT          = #000c;
  WM_GETTEXT          = #000d;
  WM_GETTEXTLENGTH    = #000e;
  WM_PAINT            = #000f;
  WM_CLOSE            = #0010;
  WM_QUERYENDSESSION  = #0011;
  WM_QUIT             = #0012;
  WM_QUERYOPEN        = #0013;
  WM_ERASEBKGND       = #0014;
  WM_SYSCOLORCHANGE   = #0015;
  WM_ENDSESSION       = #0016;
  WM_SYSTEMERROR      = #0017;
  WM_SHOWWINDOW       = #0018;
  WM_CTLCOLOR         = #0019;
  WM_WININICHANGE     = #001a;
  WM_DEVMODECHANGE    = #001b;
  WM_ACTIVATEAPP      = #001c;
  WM_FONTCHANGE       = #001d;
  WM_TIMECHANGE       = #001e;
  WM_CANCELMODE       = #001f;
  WM_SETCURSOR	      = #0020;
  WM_MOUSEACTIVATE    = #0021;
  WM_CHILDACTIVATE    = #0022;
  WM_QUEUESYNC	      = #0023;
  WM_GETMINMAXINFO    = #0024;
  WM_PAINTICON	      = #0026;
  WM_ICONERASEBKGND   = #0027;
  WM_NEXTDLGCTL       = #0028;
  WM_ALTTABACTIVE     = #0029;	      (* for win386 only *)
  WM_SPOOLERSTATUS    = #002A;


  WM_NCCREATE         = #0081;
  WM_NCDESTROY        = #0082;
  WM_NCCALCSIZE       = #0083;
  WM_NCHITTEST        = #0084;
  WM_NCPAINT          = #0085;
  WM_NCACTIVATE       = #0086;
  WM_GETDLGCODE       = #0087;
  WM_SYNCPAINT	      = #0088;
  WM_SYNCTASK	      = #0089;

  ST_BEGINSWP	      = 0;
  ST_ENDSWP	      = 1;


  WM_NCMOUSEMOVE      = #00a0;
  WM_NCLBUTTONDOWN    = #00a1;
  WM_NCLBUTTONUP      = #00a2;
  WM_NCLBUTTONDBLCLK  = #00a3;
  WM_NCRBUTTONDOWN    = #00a4;
  WM_NCRBUTTONUP      = #00a5;
  WM_NCRBUTTONDBLCLK  = #00a6;
  WM_NCMBUTTONDOWN    = #00a7;
  WM_NCMBUTTONUP      = #00a8;
  WM_NCMBUTTONDBLCLK  = #00a9;

(* WINWhere area codes *)
  HTERROR             = -2;
  HTTRANSPARENT       = -1;
  HTNOWHERE           = 0;
  HTCLIENT            = 1;
  HTCAPTION           = 2;
  HTSYSMENU           = 3;
  HTGROWBOX	      = 4;
  HTSIZE	      = HTGROWBOX;
  HTMENU              = 5;
  HTHSCROLL           = 6;
  HTVSCROLL           = 7;
  HTREDUCE	      = 8;
  HTZOOM	      = 9;
  HTLEFT	      = 10;
  HTRIGHT	      = 11;
  HTTOP 	      = 12;
  HTTOPLEFT	      = 13;
  HTTOPRIGHT	      = 14;
  HTBOTTOM	      = 15;
  HTBOTTOMLEFT	      = 16;
  HTBOTTOMRIGHT       = 17;
  HTSIZEFIRST	      = HTLEFT;
  HTSIZELAST	      = HTBOTTOMRIGHT;

(* WM_MOUSEACTIVATE return codes *)
  MA_ACTIVATE	      = 1;
  MA_ACTIVATEANDEAT   = 2;
  MA_NOACTIVATE       = 3;

  WM_KEYFIRST         = #0100;
  WM_KEYLAST          = #0107;

  WM_KEYDOWN          = #0100;
  WM_KEYUP            = #0101;
  WM_CHAR             = #0102;
  WM_DEADCHAR         = #0103;
  WM_SYSKEYDOWN       = #0104;
  WM_SYSKEYUP         = #0105;
  WM_SYSCHAR          = #0106;
  WM_SYSDEADCHAR      = #0107;
  WM_YOMICHAR         = #0108;
  WM_MOVECONVERTWINDOW = #0109;
  WM_CONVERTREQUEST    = #010A;
  WM_CONVERTRESULT     = #010B;

  WM_INITDIALOG        = #0110;
  WM_COMMAND           = #0111;
  WM_SYSCOMMAND        = #0112;
  WM_TIMER             = #0113;
  WM_HSCROLL           = #0114;
  WM_VSCROLL           = #0115;
  WM_INITMENU          = #0116;
  WM_INITMENUPOPUP     = #0117;
  WM_SYSTIMER          = #0118;
  WM_MENUSELECT        = #011f;
  WM_MENUCHAR	       = #0120;
  WM_ENTERIDLE	       = #0121;

  WM_MOUSEFIRST        = #0200;
  WM_MOUSELAST         = #0209;

  WM_MOUSEMOVE         = #0200      (* mouse related constants *);
  WM_LBUTTONDOWN       = #0201;
  WM_LBUTTONUP         = #0202;
  WM_LBUTTONDBLCLK     = #0203;
  WM_RBUTTONDOWN       = #0204;
  WM_RBUTTONUP         = #0205;
  WM_RBUTTONDBLCLK     = #0206;
  WM_MBUTTONDOWN       = #0207;
  WM_MBUTTONUP         = #0208;
  WM_MBUTTONDBLCLK     = #0209;

  WM_KANJIFIRST        = #0280;
  WM_KANJILAST	       = #029f;

(* clipboard messages *)
  WM_CUT               = #0300;
  WM_COPY              = #0301;
  WM_PASTE             = #0302;
  WM_CLEAR             = #0303;
  WM_UNDO              = #0304;
  WM_RENDERFORMAT      = #0305;
  WM_RENDERALLFORMATS  = #0306;
  WM_DESTROYCLIPBOARD  = #0307;
  WM_DRAWCLIPBOARD     = #0308;
  WM_PAINTCLIPBOARD    = #0309;
  WM_VSCROLLCLIPBOARD  = #030a;
  WM_SIZECLIPBOARD     = #030b;
  WM_ASKCBFORMATNAME   = #030c;
  WM_CHANGECBCHAIN     = #030d;
  WM_HSCROLLCLIPBOARD  = #030e;

(* 0x03f0 to 0x03ff are reserved *)
(* private window messages start here *)
  WM_USER              = #0400;



{ $IFDECL MAKELONG $THEN BEGIN }
  FUNCTION MAKELONG (
    w1_,w2_            : WORD
  )                    : LONG;
{ $END }

{ $IFDECL LOWORD $THEN BEGIN }
  FUNCTION LOWORD (
    l_                 : LONG
  )                    : WORD;
{ $END }

{ $IFDECL HIWORD $THEN BEGIN }
  FUNCTION HIWORD (
    l_                 : LONG
  )                    : WORD;
{ $END }

{ $IFDECL LOBYTE $THEN BEGIN }
  FUNCTION LOBYTE (
    w_                 : WORD
  )                    : BYTE;
{ $END }

{ $IFDECL HIBYTE $THEN BEGIN }
  FUNCTION HIBYTE (
    w_                 : WORD
  )                    : BYTE;
{ $END }

{ $IFDECL MAKEPOINT $THEN BEGIN }
  FUNCTION MAKEPOINT (
    l_                 : LONG
  )                    : POINT;
{ $END }

{ $IFDECL RegisterWindowMessage $THEN BEGIN }
  FUNCTION  RegisterWindowMessage (
    l_               : LPSTR
  )                  : WORD;
{ $END }

(* Size message commands *)

CONST
  SIZENORMAL           = 0;
  SIZEICONIC           = 1;
  SIZEFULLSCREEN       = 2;
  SIZEZOOMSHOW         = 3;
  SIZEZOOMHIDE         = 4;

(* Key state masks for mouse messages *)
  MK_LBUTTON           = #0001;
  MK_RBUTTON           = #0002;
  MK_SHIFT             = #0004;
  MK_CONTROL           = #0008;
  MK_MBUTTON           = #0010;

(* Window styles *)
  WS_TILED	       = #00000000;
  WS_OVERLAPPED        = WS_TILED;
  WS_ICONICPOPUP       = #c0000000;
  WS_POPUP	       = #80000000;
  WS_CHILD	       = #40000000;
  WS_MINIMIZE	       = #20000000;
  WS_VISIBLE	       = #10000000;
  WS_DISABLED	       = #08000000;
  WS_CLIPSIBLINGS      = #04000000;
  WS_CLIPCHILDREN      = #02000000;
  WS_MAXIMIZE	       = #01000000;

  WS_BORDER	       = #00800000;
  WS_CAPTION	       = #00c00000;
  WS_DLGFRAME	       = #00400000;
  WS_VSCROLL	       = #00200000;
  WS_HSCROLL	       = #00100000;
  WS_SYSMENU	       = #00080000;
  WS_SIZEBOX	       = #00040000;
  WS_THICKFRAME        = #00040000;
  WS_GROUP	       = #00020000;
  WS_TABSTOP	       = #00010000;

  WS_MINIMIZEBOX       = #00020000;
  WS_MAXIMIZEBOX       = #00010000;

  WS_ICONIC	  = WS_MINIMIZE;


(* Class styles *)
  CS_VREDRAW           = #0001;
  CS_HREDRAW           = #0002;
  CS_KEYCVTWINDOW      = #0004;
  CS_DBLCLKS           = #0008;
  CS_OEMCHARS          = #0010;
  CS_OWNDC             = #0020;
  CS_CLASSDC           = #0040;
  CS_PARENTDC	       = #0080;
  CS_NOKEYCVT          = #0100;
  CS_SAVEBITS	       = #0800;
  CS_NOCLOSE	       = #0200;
  CS_BYTEALIGNCLIENT   = #1000;
  CS_BYTEALIGNWINDOW   = #2000;

(* Shorthand for the common cases *)
  WS_TILEDWINDOW       = #00CF0000; (* WS_TILED | WS_CAPTION | WS_SYSMENU | WS_SIZEBOX *)
  WS_OVERLAPPEDWINDOW  = WS_TILEDWINDOW;
  WS_POPUPWINDOW       = #80880000; (* WS_POPUP | WS_BORDER | WS_SYSMENU *)
  WS_CHILDWINDOW       = (WS_CHILD);

(* clipboard metafile picture structure *)
TYPE
  HANDLETABLE = RECORD
    objectHandle[1] : HANDLE;
  END;
  PHANDLETABLE	= ADR OF HANDLETABLE;
  LPHANDLETABLE = ADS OF HANDLETABLE;

  METARECORD = RECORD
    rdSize     : DWORD;
    rdFunction : WORD;
    rdParm[1]  : WORD;
  END;
  PMETARECORD  = ADR OF METARECORD;
  LPMETARECORD = ADS OF METARECORD;

  METAFILEPICT = RECORD
    mm               : int;
    xExt             : int;
    yExt             : int;
    hMF              : HANDLE;
  END;
  LPMETAFILEPICT     = ADS OF METAFILEPICT;

(* predefined clipboard formats *)

CONST
  CF_TEXT              = 1;
  CF_BITMAP            = 2;
  CF_METAFILEPICT      = 3;
  CF_SYLK              = 4;
  CF_DIF               = 5;
  CF_TIFF	       = 6;
  CF_OEMTEXT	       = 7;

  CF_OWNERDISPLAY      = #80       (* owner display *);
  CF_DSPTEXT           = #81       (* display text *);
  CF_DSPBITMAP         = #82       (* display bitmap *);
  CF_DSPMETAFILEPICT   = #83       (* display metafile *);

(* Private clipboard format range *)
  CF_PRIVATEFIRST      = #200       (* Anything in this range doesn't *);
  CF_PRIVATELAST       = #2ff       (* get GlobalFree'd *);
  CF_GDIOBJFIRST       = #300       (* Anything in this range gets *);
  CF_GDIOBJLAST        = #3ff       (* DeleteObject'ed *);


TYPE
  PAINTSTRUCT = RECORD
    hdc_             : HDC;
    fErase           : BOOL;
    rcPaint          : RECT;
    fRestore         : BOOL;
    fIncUpdate       : BOOL;
    rgbReserved      : ARRAY [0..15] OF BYTE;
  END;
  PPAINTSTRUCT       = ADR OF PAINTSTRUCT;
  NPPAINTSTRUCT      = ADR OF PAINTSTRUCT;
  LPPAINTSTRUCT      = ADS OF PAINTSTRUCT;

  CREATESTRUCT = RECORD
    lpCreateParams   : LPSTR;
    hInstance        : HANDLE;
    hMenu            : HANDLE;
    hwndParent       : HWND;
    cy               : int;
    cx               : int;
    y                : int;
    x                : int;
    style            : long;
    lpszName         : LPSTR;
    lpszClass        : LPSTR;
  END;
  LPCREATESTRUCT     = ADS OF CREATESTRUCT;

(* TextMetric structure *)
  TEXTMETRIC = RECORD
    tmHeight         : INTEGER2;
    tmAscent         : INTEGER2;
    tmDescent        : INTEGER2;
    tmInternalLeading : INTEGER2;
    tmExternalLeading : INTEGER2;
    tmAveCharWidth    : INTEGER2;
    tmMaxCharWidth    : INTEGER2;
    tmWeight          : INTEGER2;
    tmItalic          : BYTE;
    tmUnderlined      : BYTE;
    tmStruckOut       : BYTE;
    tmFirstChar       : BYTE;
    tmLastChar        : BYTE;
    tmDefaultChar     : BYTE;
    tmBreakChar       : BYTE;
    tmPitchAndFamily  : BYTE;
    tmCharSet         : BYTE;
    tmOverhang        : INTEGER2;
    tmDigitizedAspectX : INTEGER2;
    tmDigitizedAspectY : INTEGER2;
  END;
  PTEXTMETRIC          = ADR OF TEXTMETRIC;
  NPTEXTMETRIC         = ADR OF TEXTMETRIC;
  LPTEXTMETRIC         = ADS OF TEXTMETRIC;

(* GDI logical objects *)
(* Pel Array *)
  PELARRAY = RECORD
    paXCount           : INTEGER2;
    paYCount           : INTEGER2;
    paXExt             : INTEGER2;
    paYExt             : INTEGER2;
    paRGBs             : BYTE;
  END;
  PPELARRAY            = ADR OF PELARRAY;
  NPPELARRAY           = ADR OF PELARRAY;
  LPPELARRAY           = ADS OF PELARRAY;

(* Logical Brush *)
  LOGBRUSH = RECORD
    lbStyle            : WORD;
    lbColor            : DWORD;
    lbHatch            : INTEGER2;
  END;
  PLOGBRUSH            = ADR OF LOGBRUSH;
  NPLOGBRUSH           = ADR OF LOGBRUSH;
  LPLOGBRUSH           = ADS OF LOGBRUSH;

(* A PATTERN and a LOGBRUSH are the same thing *)
  PATTERN              = LOGBRUSH;
  PPATTERN             = ADR OF PATTERN;
  NPPATTERN            = ADR OF PATTERN;
  LPPATTERN            = ADS OF PATTERN;

(* Logical Pen *)
  LOGPEN = RECORD
    lopnStyle          : WORD;
    lopnWidth          : POINT;
    lopnColor          : DWORD;
  END;
  PLOGPEN              = ADR OF LOGPEN;
  NPLOGPEN             = ADR OF LOGPEN;
  LPLOGPEN             = ADS OF LOGPEN;

(* Logical Font *)


CONST
  LF_FACESIZE          = 32;


TYPE
  LOGFONT = RECORD
    lfHeight           : INTEGER2;
    lfWidth            : INTEGER2;
    lfEscapement       : INTEGER2;
    lfOrientation      : INTEGER2;
    lfWeight           : INTEGER2;
    lfItalic           : BYTE;
    lfUnderline        : BYTE;
    lfStrikeOut        : BYTE;
    lfCharSet          : BYTE;
    lfOutPrecision     : BYTE;
    lfClipPrecision    : BYTE;
    lfQuality          : BYTE;
    lfPitchAndFamily   : BYTE;
    lfFaceName         : ARRAY [0..LF_FACESIZE-1] OF BYTE;
  END;
  PLOGFONT             = ADR OF LOGFONT;
  NPLOGFONT            = ADR OF LOGFONT;
  LPLOGFONT            = ADS OF LOGFONT;


(* Logical font constants *)

CONST
  OUT_DEFAULT_PRECIS   = 0;
  OUT_STRING_PRECIS    = 1;
  OUT_CHARACTER_PRECIS = 2;
  OUT_STROKE_PRECIS    = 3;

  CLIP_DEFAULT_PRECIS  = 0;
  CLIP_CHARACTER_PRECIS = 1;
  CLIP_STROKE_PRECIS    = 2;

  DEFAULT_QUALITY       = 0;
  DRAFT_QUALITY         = 1;
  PROOF_QUALITY         = 2;

  DEFAULT_PITCH         = 0;
  FIXED_PITCH           = 1;
  VARIABLE_PITCH        = 2;

  ANSI_CHARSET          = 0;
  SHIFTJIS_CHARSET	= 128;		 (* Kanji CharSet *)
  OEM_CHARSET           = 255;

(* GDI font families. *)
  FF_DONTCARE           = 0     (* Don't care or don't know. *);
  FF_ROMAN              = 16    (* Variable stroke width, serifed. *);
                                (* Times Roman, Century Schoolbook, etc. *)
  FF_SWISS              = 32    (* Variable stroke width, sans-serifed. *);
                                (* Helvetica, Swiss, etc. *)
  FF_MODERN             = 48    (* Constant stroke width, serifed or sans-serifed. *);
                                (* Pica, Elite, Courier, etc. *)
  FF_SCRIPT             = 64    (* Cursive, etc. *);
  FF_DECORATIVE         = 80    (* Old English, etc. *);

(* Font weights lightest to darkest. *)
  FW_DONTCARE           = 0;
  FW_THIN               = 100;
  FW_EXTRALIGHT         = 200;
  FW_LIGHT              = 300;
  FW_NORMAL             = 400;
  FW_MEDIUM             = 500;
  FW_SEMIBOLD           = 600;
  FW_BOLD               = 700;
  FW_EXTRABOLD          = 800;
  FW_HEAVY              = 900;

  FW_ULTRALIGHT         = (FW_EXTRALIGHT);
  FW_REGULAR            = (FW_NORMAL);
  FW_DEMIBOLD           = (FW_SEMIBOLD);
  FW_ULTRABOLD          = (FW_EXTRABOLD);
  FW_BLACK              = (FW_HEAVY);


(* EnumFonts masks. *)
  RASTER_FONTTYPE       = #0001;
  DEVICE_FONTTYPE       = #0002;


(* GDI rgb values packed into a dword *)

{ $IFDECL RGB $THEN BEGIN }
  FUNCTION RGB (
    r,g,b              : BYTE
  )                    : DWORD;
{ $END }

{ $IFDECL GetRValue $THEN BEGIN }
  FUNCTION GetRValue (
    d_                 : DWORD
  )                    : BYTE;
{ $END }

{ $IFDECL GetGValue $THEN BEGIN }
  FUNCTION GetGValue (
    d_                 : DWORD
  )                    : BYTE;
{ $END }

{ $IFDECL GetBValue $THEN BEGIN }
  FUNCTION GetBValue (
    d_                 : DWORD
  )                    : BYTE;
{ $END }

(* GDI Background Modes *)

CONST
  TRANSPARENT           = 1;
  OPAQUE                = 2;

(* GDI map modes *)
  MM_TEXT               = 1;
  MM_LOMETRIC           = 2;
  MM_HIMETRIC           = 3;
  MM_LOENGLISH          = 4;
  MM_HIENGLISH          = 5;
  MM_TWIPS              = 6;
  MM_ISOTROPIC          = 7;
  MM_ANISOTROPIC        = 8;

(* GDI coordinate modes *)

  ABSOLUTE              = 1;
  RELATIVE              = 2;

(* Stock Logical Objects *)
  WHITE_BRUSH           = 0;
  LTGRAY_BRUSH          = 1;
  GRAY_BRUSH            = 2;
  DKGRAY_BRUSH          = 3;
  BLACK_BRUSH           = 4;
  NULL_BRUSH            = 5;
  HOLLOW_BRUSH          = (NULL_BRUSH);
  WHITE_PEN             = 6;
  BLACK_PEN             = 7;
  NULL_PEN              = 8;
  OEM_FIXED_FONT        = 10;
  ANSI_FIXED_FONT       = 11;
  ANSI_VAR_FONT         = 12;
  SYSTEM_FONT           = 13;
  DEVICEDEFAULT_FONT    = 14;

(* GDI Brush Style definitions. *)

  BS_SOLID              = 0;
  BS_NULL               = 1;
  BS_HOLLOW             = (BS_NULL);
  BS_HATCHED            = 2;
  BS_PATTERN            = 3;
  BS_INDEXED		= 4;


(* GDI Hatch Style definitions. *)

  HS_HORIZONTAL         = 0       (* ----- *);
  HS_VERTICAL           = 1       (* ||||| *);
  HS_FDIAGONAL          = 2       (* ///// *);
  HS_BDIAGONAL          = 3       (* \\\\\ *);
  HS_CROSS              = 4       (* +++++ *);
  HS_DIAGCROSS          = 5       (* xxxxx *);


(* GDI Pen Style definitions *)
  PS_SOLID              = 0       (* solid pen *);
  PS_DASH               = 1       (* -------  *);
  PS_DOT                = 2       (* .......  *);
  PS_DASHDOT            = 3       (* _._._._  *);
  PS_DASHDOTDOT         = 4       (* _.._.._  *);
  PS_NULL               = 5       (*          *);

(* Device Parameters for GetDeviceCaps() *)

  DRIVERVERSION         = 0     (*  Device driver version                 *);
  TECHNOLOGY            = 2     (*  Device classification                 *);
  HORZSIZE              = 4     (*  Horizontal size in millimeters        *);
  VERTSIZE              = 6     (*  Vertical   size in millimeters        *);
  HORZRES               = 8     (*  Horizontal width in pixels            *);
  VERTRES               = 10    (*  Vertical   width in pixels            *);
  BITSPIXEL             = 12    (*  Number of bits per pixel              *);
  PLANES                = 14    (*  Number of planes                      *);
  NUMBRUSHES            = 16    (*  Number of brushes the device has      *);
  NUMPENS               = 18    (*  Number of pens the device has         *);
  NUMMARKERS            = 20    (*  Number of markers the device has      *);
  NUMFONTS              = 22    (*  Number of fonts the device has        *);
  NUMCOLORS             = 24;
  PDEVICESIZE           = 26    (*  Size required for device descriptor   *);
  CURVECAPS             = 28    (*  Curves    capabilities                *);
  LINECAPS              = 30    (*  Line      capabilities                *);
  POLYGONALCAPS         = 32    (*  Polygonal capabilities                *);
  TEXTCAPS              = 34    (*  Text      capabilities                *);
  CLIPCAPS              = 36    (*  Clipping  capabilities                *);
  RASTERCAPS            = 38    (*  Bitblt    capabilities                *);
  ASPECTX               = 40    (*  Length of the X leg                   *);
  ASPECTY               = 42    (*  Length of the Y leg                   *);
  ASPECTXY              = 44    (*  Length of the hypotenuse              *);

  LOGPIXELSX            = 88    (*  Logical pixels/inch in X              *);
  LOGPIXELSY            = 90    (*  Logical pixels/inch in Y              *);


(* Device capability masks *)
(*              Device Technologies                                *)

  DT_PLOTTER            = 0       (* Vector plotter          *);
  DT_RASDISPLAY         = 1       (* Raster display          *);
  DT_RASPRINTER         = 2       (* Raster printer          *);
  DT_RASCAMERA          = 3       (* Raster camera           *);
  DT_CHARSTREAM         = 4       (* Character-stream, PLP   *);
  DT_METAFILE           = 5       (* Metafile, VDM           *);
  DT_DISPFILE           = 6       (* Display-file            *);

(*              Curve Capabilities                                 *)

  CC_NONE               = 0   (* Curves not supported    *);
  CC_CIRCLES            = 1   (* Can do circles          *);
  CC_PIE                = 2   (* Can do pie wedges       *);
  CC_CHORD              = 4   (* Can do chord arcs       *);
  CC_ELLIPSES           = 8   (* Can do ellipese         *);
  CC_WIDE               = 16  (* Can do wide lines       *);
  CC_STYLED             = 32  (* Can do styled lines     *);
  CC_WIDESTYLED         = 64  (* Can do wide styled lines*);
  CC_INTERIORS          = 128 (* Can do interiors        *);

(*           Line Capabilities                                 *)

  LC_NONE               = 0   (* Lines not supported     *);
  LC_POLYLINE           = 2   (* Can do polylines        *);
  LC_MARKER             = 4   (* Can do markers          *);
  LC_POLYMARKER         = 8   (* Can do polymarkers      *);
  LC_WIDE               = 16  (* Can do wide lines       *);
  LC_STYLED             = 32   (* Can do styled lines     *);
  LC_WIDESTYLED         = 64   (* Can do wide styled lines*);
  LC_INTERIORS          = 128  (* Can do interiors        *);

(*           Polygonal Capabilities                            *)

  PC_NONE               = 0   (* Polygonals not supported*);
  PC_POLYGON            = 1   (* Can do polygons         *);
  PC_RECTANGLE          = 2   (* Can do rectangles       *);
  PC_TRAPEZOID          = 4   (* Can do trapezoids       *);
  PC_SCANLINE           = 8   (* Can do scanlines        *);
  PC_WIDE               = 16  (* Can do wide borders     *);
  PC_STYLED             = 32   (* Can do styled borders   *);
  PC_WIDESTYLED         = 64   (* Can do wide styled borders*);
  PC_INTERIORS          = 128  (* Can do interiors        *);

(*           Polygonal Capabilities                            *)

  CP_NONE               = 0   (* no clipping of Output   *);
  CP_RECTANGLE          = 1   (* Output clipped to Rects *);

(*           Text Capabilities                                          *)

  TC_OP_CHARACTER       = #0001      (* Can do OutputPrecision   CHARACTER      *);
  TC_OP_STROKE          = #0002      (* Can do OutputPrecision   STROKE         *);
  TC_CP_STROKE          = #0004      (* Can do ClipPrecision     STROKE         *);
  TC_CR_90              = #0008      (* Can do CharRotAbility    90             *);
  TC_CR_ANY             = #0010      (* Can do CharRotAbility    ANY            *);
  TC_SF_X_YINDEP        = #0020      (* Can do ScaleFreedom      X_YINDEPENDENT *);
  TC_SA_DOUBLE          = #0040      (* Can do ScaleAbility      DOUBLE         *);
  TC_SA_INTEGER         = #0080      (* Can do ScaleAbility      INTEGER        *);
  TC_SA_CONTIN          = #0100      (* Can do ScaleAbility      CONTINUOUS     *);
  TC_EA_DOUBLE          = #0200      (* Can do EmboldenAbility   DOUBLE         *);
  TC_IA_ABLE            = #0400      (* Can do ItalisizeAbility  ABLE           *);
  TC_UA_ABLE            = #0800      (* Can do UnderlineAbility  ABLE           *);
  TC_SO_ABLE            = #1000      (* Can do StrikeOutAbility  ABLE           *);
  TC_RA_ABLE            = #2000      (* Can do RasterFontAble    ABLE           *);
  TC_VA_ABLE            = #4000      (* Can do VectorFontAble    ABLE           *);
  TC_RESERVED           = #8000      (* Reserved.                               *);
(*           Raster Capabilities                                        *)

  RC_BITBLT             = 1     (* Can do standard non-stretching, non-inverting BLT. *);
  RC_BANDING            = 2     (* Device requires banding support                    *);
  RC_SCALING            = 4     (* Device requires scaling support *);
  RC_BITMAP64		= 8	(* Device can support >64K bitmap  *);

(* PeekMessage options *)

  PM_REMOVE	       = TRUE_;
  PM_NOREMOVE	       = FALSE_;
  PM_NOYIELD	       = #02;


{ $IFDECL GetMessage $THEN BEGIN }
  FUNCTION  GetMessage (
    l_                 : LPMSG;
    h_                 : HWND;
    w_,x_              : WORD
  )                    : BOOL;
{ $END }

{ $IFDECL PeekMessage $THEN BEGIN }
  FUNCTION  PeekMessage (
    l_                 : LPMSG;
    h_                 : HWND;
    w_,x_              : WORD;
    b_                 : BOOL
  )                    : BOOL;
{ $END }

{ $IFDECL TranslateMessage $THEN BEGIN }
  FUNCTION  TranslateMessage (
    l_                 : LPMSG
  )                    : BOOL;
{ $END }

{ $IFDECL DispatchMessage $THEN BEGIN }
  FUNCTION  DispatchMessage (
    l_                 : LPMSG
  )                    : LONG;
{ $END }


{ $IFDECL SwapMouseButton $THEN BEGIN }
  FUNCTION  SwapMouseButton (
    b_                 : BOOL
  )                    : BOOL;
{ $END }

{ $IFDECL GetMessagePos $THEN BEGIN }
  FUNCTION  GetMessagePos                    : DWORD;
{ $END }

{ $IFDECL GetMessageTime $THEN BEGIN }
  FUNCTION  GetMessageTime                    : long;
{ $END }


{ $IFDECL GetSysModalWindow $THEN BEGIN }
  FUNCTION  GetSysModalWindow                    : HWND;
{ $END }

{ $IFDECL SetSysModalWindow $THEN BEGIN }
  FUNCTION  SetSysModalWindow (
    h_                 : HWND
  )                    : HWND;
{ $END }


{ $IFDECL SendMessage $THEN BEGIN }
  FUNCTION  SendMessage (
    h_                 : HWND;
    w_,x_              : WORD;
    l_                 : LONG
  )                    : long;
{ $END }

{ $IFDECL PostMessage $THEN BEGIN }
  FUNCTION  PostMessage (
    h_                 : HWND;
    w_,x_              : WORD;
    l_                 : LONG
  )                    : BOOL;
{ $END }

{ $IFDECL PostAppMessage $THEN BEGIN }
  FUNCTION  PostAppMessage (
    h_                 : HANDLE;
    w_,x_              : WORD;
    l_                 : LONG
  )                    : BOOL;
{ $END }

{ $IFDECL ReplyMessage $THEN BEGIN }
  PROCEDURE ReplyMessage (
    l_                 : long
  );
{ $END }

{ $IFDECL WaitMessage $THEN BEGIN }
  PROCEDURE WaitMessage;
{ $END }

{ $IFDECL DefWindowProc $THEN BEGIN }
  FUNCTION  DefWindowProc (
    h_                 : HWND;
    w_,x_              : WORD;
    l_                 : LONG
  )                    : long;
{ $END }

{ $IFDECL PostQuitMessage $THEN BEGIN }
  PROCEDURE PostQuitMessage (
    i_                 : int
  );
{ $END }

{ $IFDECL CallWindowProc $THEN BEGIN }
  FUNCTION  CallWindowProc (
    f_                 : FARPROC;
    h_                 : HWND;
    w_,x_              : WORD;
    l_                 : LONG
  )                    : long;
{ $END }

{ $IFDECL InSendMessage $THEN BEGIN }
  FUNCTION  InSendMessage                    : BOOL;
{ $END }


{ $IFDECL GetDoubleClickTime $THEN BEGIN }
  FUNCTION  GetDoubleClickTime                    : WORD;
{ $END }

{ $IFDECL SetDoubleClickTime $THEN BEGIN }
  FUNCTION  SetDoubleClickTime (
     w_ 	       : WORD
  );
{ $END }

{ $IFDECL RegisterClass $THEN BEGIN }
  FUNCTION  RegisterClass (
    l_                 : LPWNDCLASS
  )                    : BOOL;
{ $END }

{ $IFDECL SetMessageQueue $THEN BEGIN }
  FUNCTION  SetMessageQueue (
    i_		       : int
  )                    : BOOL;
{ $END }

{ $IFDECL CreateWindow $THEN BEGIN }
  FUNCTION  CreateWindow (
    l_,m_              : LPSTR;
    d_                 : DWORD;
    i_,j_,k_,n_        : int;
    h_                 : HWND;
    o_                 : HMENU;
    p_                 : HANDLE;
    q_                 : LPSTR
  )                    : HWND;
{ $END }

CONST
  CW_USEDEFAULT        = RETYPE( int, #8000);	{ used on both x and cx }

{ $IFDECL IsWindow $THEN BEGIN }
  FUNCTION  IsWindow (
    h_                 : HWND
  )                    : BOOL;
{ $END }

{ $IFDECL DestroyWindow $THEN BEGIN }
  FUNCTION  DestroyWindow (
    h_                 : HWND
  )                    : BOOL;
{ $END }


{ $IFDECL ShowWindow $THEN BEGIN }
  FUNCTION  ShowWindow (
    h_                 : HWND;
    i_                 : int
  )                    : BOOL;
{ $END }

{ $IFDECL FlashWindow $THEN BEGIN }
  FUNCTION  FlashWindow (
    h_                 : HWND;
    b_                 : BOOL
  )                    : BOOL;
{ $END }


{ $IFDECL OpenIcon $THEN BEGIN }
  FUNCTION  OpenIcon (
    h_                 : HWND
  )                    : BOOL;
{ $END }

{ $IFDECL CloseWindow $THEN BEGIN }
  FUNCTION  CloseWindow (
    h_                 : HWND
  )                    : int;
{ $END }

{ $IFDECL MoveWindow $THEN BEGIN }
  PROCEDURE MoveWindow (
    h_                 : HWND;
    i_,j_,k_,l_        : int;
    b_                 : BOOL
  );
{ $END }

{ $IFDECL IsWindowVisible $THEN BEGIN }
  FUNCTION  IsWindowVisible (
    h_                 : HWND
  )                    : BOOL;
{ $END }

{ $IFDECL IsIconic $THEN BEGIN }
  FUNCTION  IsIconic (
    h_                 : HWND
  )                    : BOOL;
{ $END }

{ $IFDECL AnyPopup $THEN BEGIN }
  FUNCTION  AnyPopup                    : BOOL;
{ $END }

{ $IFDECL BringWindowToTop $THEN BEGIN }
  PROCEDURE BringWindowToTop (
    h_                 : HWND
  );
{ $END }

{ $IFDECL IsZoomed $THEN BEGIN }
  FUNCTION  IsZoomed (
    h_                 : HWND
  )                    : BOOL;
{ $END }

(* SetWindowPos flags *)

CONST
  SWP_NOSIZE	   = #01;
  SWP_NOMOVE	   = #02;
  SWP_NOZORDER	   = #04;
  SWP_NOREDRAW	   = #08;
  SWP_NOACTIVATE   = #10;
  SWP_DRAWFRAME    = #20;
  SWP_SHOWWINDOW   = #40;
  SWP_HIDEWINDOW   = #80;
  SWP_NOCOPYBITS   = #0100;
  SWP_NOREPOSITION = #200;


(* DrawFrame and associated defines *)
  DF_SHIFT0	      = #0000;
  DF_SHIFT1	      = #0001;
  DF_SHIFT2	      = #0002;
  DF_SHIFT3	      = #0003;
  DF_PATCOPY	      = #0000;
  DF_PATINVERT	      = #0004;

  DF_SCROLLBAR	      = 0;
  DF_BACKGROUND       = 8;
  DF_ACTIVECAPTION    = 16;
  DF_INACTIVECAPTION  = 24;
  DF_MENU	      = 32;
  DF_WINDOW	      = 40;
  DF_WINDOWFRAME      = 48;
  DF_MENUTEXT	      = 56;
  DF_WINDOWTEXT       = 64;
  DF_CAPTIONTEXT      = 72;
  DF_ACTIVEBORDER     = 80;
  DF_INACTIVEBORDER   = 88;
  DF_APPWORKSPACE     = 96;
  DF_GRAY	      = 104;

(* DrawText format flags *)


  DT_LEFT               = #00;
  DT_CENTER             = #01;
  DT_RIGHT              = #02;
  DT_TOP                = #00;
  DT_VCENTER            = #04;
  DT_BOTTOM             = #08;
  DT_WORDBREAK          = #10;
  DT_SINGLELINE         = #20;
  DT_EXPANDTABS         = #40;
  DT_TABSTOP            = #80;
  DT_NOCLIP             = #100;
  DT_EXTERNALLEADING    = #200;
  DT_CALCRECT		= #400;
  DT_NOPREFIX		= #800;
  DT_INTERNAL		= #1000;


{ $IFDECL DrawText $THEN BEGIN }
  PROCEDURE DrawText (
    h_                 : HDC;
    l_                 : LPSTR;
    i_                 : int;
    m_                 : LPRECT;
    w_                 : WORD
  );
{ $END }

{ $IFDECL DrawIcon $THEN BEGIN }
  FUNCTION  DrawIcon (
    h_                 : HDC;
    i_,j_              : int;
    k_                 : HICON
  )                    : BOOL;
{ $END }


{ $IFDECL CreateDialog $THEN BEGIN }
  FUNCTION  CreateDialog (
    h_                 : HANDLE;
    l_                 : LPSTR;
    i_                 : HWND;
    f_                 : FARPROC
  )                    : HWND;
{ $END }

{ $IFDECL CreateDialogIndirect $THEN BEGIN }
  FUNCTION  CreateDialogIndirect (
    h_                 : HANDLE;
    l_                 : LPSTR;
    i_                 : HWND;
    f_                 : FARPROC
  )                    : HWND;
{ $END }

{ $IFDECL DialogBox $THEN BEGIN }
  FUNCTION  DialogBox (
    h_                 : HANDLE;
    l_                 : LPSTR;
    i_                 : HWND;
    f_                 : FARPROC
  )                    : int;
{ $END }

{ $IFDECL DialogBoxIndirect $THEN BEGIN }
  FUNCTION  DialogBoxIndirect (
    h_                 : HANDLE;
    h_		       : HANDLE;
    i_                 : HWND;
    f_                 : FARPROC
  )                    : int;
{ $END }

{ $IFDECL EndDialog $THEN BEGIN }
  PROCEDURE EndDialog (
    h_                 : HWND;
    i_                 : int
  );
{ $END }

{ $IFDECL GetDlgItem $THEN BEGIN }
  FUNCTION  GetDlgItem (
    h_                 : HWND;
    i_                 : int
  )                    : HWND;
{ $END }

{ $IFDECL SetDlgItemInt $THEN BEGIN }
  PROCEDURE SetDlgItemInt (
    h_                 : HWND;
    i_                 : int;
    w_                 : WORD;
    b_                 : BOOL
  );
{ $END }

{ $IFDECL GetDlgItemInt $THEN BEGIN }
  FUNCTION  GetDlgItemInt (
    h_                 : HWND;
    i_                 : int;
    b_                 : LPBOOL;
    c_                 : BOOL
  )                    : WORD;
{ $END }

{ $IFDECL SetDlgItemText $THEN BEGIN }
  PROCEDURE SetDlgItemText (
    h_                 : HWND;
    i_                 : int;
    l_                 : LPSTR
  );
{ $END }

{ $IFDECL GetDlgItemText $THEN BEGIN }
  FUNCTION  GetDlgItemText (
    h_                 : HWND;
    i_                 : int;
    l_                 : LPSTR;
    j_                 : int
  )                    : int;
{ $END }

{ $IFDECL CheckDlgButton $THEN BEGIN }
  PROCEDURE CheckDlgButton (
    h_                 : HWND;
    i_                 : int;
    w_                 : WORD
  );
{ $END }

{ $IFDECL CheckRadioButton $THEN BEGIN }
  PROCEDURE CheckRadioButton (
    h_                 : HWND;
    i_,j_,k_           : int
  );
{ $END }

{ $IFDECL IsDlgButtonChecked $THEN BEGIN }
  FUNCTION  IsDlgButtonChecked (
    h_                 : HWND;
    i_                 : int
  )                    : WORD;
{ $END }

{ $IFDECL SendDlgItemMessage $THEN BEGIN }
  FUNCTION  SendDlgItemMessage (
    h_                 : HWND;
    i_                 : int;
    w_,x_              : WORD;
    l_                 : LONG
  )                    : long;
{ $END }


{ $IFDECL CallMsgFilter $THEN BEGIN }
  FUNCTION  CallMsgFilter (
    l_                 : LPMSG;
    i_                 : int
  )                    : BOOL;
{ $END }

(* Clipboard manager routines *)

{ $IFDECL OpenClipboard $THEN BEGIN }
  FUNCTION  OpenClipboard (
    h_                 : HWND
  )                    : BOOL;
{ $END }

{ $IFDECL CloseClipboard $THEN BEGIN }
  FUNCTION  CloseClipboard                    : BOOL;
{ $END }

{ $IFDECL GetClipboardOwner $THEN BEGIN }
  FUNCTION  GetClipboardOwner                    : HWND;
{ $END }

{ $IFDECL SetClipboardViewer $THEN BEGIN }
  FUNCTION  SetClipboardViewer (
    h_                 : HWND
  )                    : HWND;
{ $END }

{ $IFDECL GetClipboardViewer $THEN BEGIN }
  FUNCTION  GetClipboardViewer                    : HWND;
{ $END }

{ $IFDECL ChangeClipboardChain $THEN BEGIN }
  FUNCTION  ChangeClipboardChain (
    h_,i_              : HWND
  )                    : BOOL;
{ $END }

{ $IFDECL SetClipboardData $THEN BEGIN }
  FUNCTION  SetClipboardData (
    w_                 : WORD;
    h_                 : HANDLE
  )                    : HANDLE;
{ $END }

{ $IFDECL GetClipboardData $THEN BEGIN }
  FUNCTION  GetClipboardData (
    w_                 : WORD
  )                    : HANDLE;
{ $END }

{ $IFDECL RegisterClipboardFormat $THEN BEGIN }
  FUNCTION  RegisterClipboardFormat (
    l_                 : LPSTR
  )                    : WORD;
{ $END }

{ $IFDECL CountClipboardFormats $THEN BEGIN }
  FUNCTION  CountClipboardFormats                    : int;
{ $END }

{ $IFDECL EnumClipboardFormats $THEN BEGIN }
  FUNCTION  EnumClipboardFormats (
    w_                 : WORD
  )                    : WORD;
{ $END }

{ $IFDECL GetClipboardFormatName $THEN BEGIN }
  FUNCTION  GetClipboardFormatName (
    w_                 : WORD;
    l_                 : LPSTR;
    i_                 : int
  )                    : int;
{ $END }

{ $IFDECL EmptyClipboard $THEN BEGIN }
  FUNCTION  EmptyClipboard                    : BOOL;
{ $END }

{ $IFDECL IsClipboardFormatAvailable $THEN BEGIN }
  FUNCTION  IsClipboardFormatAvailable (
    w_                 : WORD
  )                    : BOOL;
{ $END }


{ $IFDECL SetFocus $THEN BEGIN }
  FUNCTION  SetFocus (
    h_                 : HWND
  )                    : HWND;
{ $END }

{ $IFDECL GetFocus $THEN BEGIN }
  FUNCTION  GetFocus                    : HWND;
{ $END }

{ $IFDECL GetActiveWindow $THEN BEGIN }
  FUNCTION  GetActiveWindow                    : HWND;
{ $END }


{ $IFDECL GetKeyState $THEN BEGIN }
  FUNCTION  GetKeyState (
    i_                 : int
  )                    : int;
{ $END }

{ $IFDECL GetAsyncKeyState $THEN BEGIN }
  FUNCTION  GetAsyncKeyState (
    i_                 : int
  )                    : int;
{ $END }

{ $IFDECL GetKeyboardState $THEN BEGIN }
  PROCEDURE GetKeyboardState (
    b_		       : ADS OF BYTE
  );
{ $END }

{ $IFDECL SetKeyboardState $THEN BEGIN }
  PROCEDURE SetKeyboardState (
    b_		       : ADS OF BYTE
  );
{ $END }

{ $IFDECL EnableHardwareInput $THEN BEGIN }
  FUNCTION  EnableHardwareInput (
    b_		       : BOOL
  )                    : BOOL;
{ $END }

{ $IFDECL GetInputState $THEN BEGIN }
  FUNCTION  GetInputState (
  )                    : BOOL;
{ $END }

{ $IFDECL GetCapture $THEN BEGIN }
  FUNCTION  GetCapture;
{ $END }

{ $IFDECL SetCapture $THEN BEGIN }
  FUNCTION  SetCapture (
    h_                 : HWND
  )                    : HWND;
{ $END }

{ $IFDECL ReleaseCapture $THEN BEGIN }
  PROCEDURE ReleaseCapture;
{ $END }

(* Windows Functions *)

{ $IFDECL SetTimer $THEN BEGIN }
  FUNCTION  SetTimer (
    h_                 : HWND;
    s_                 : short;
    w_                 : WORD;
    f_                 : FARPROC
  )		       : WORD;
{ $END }

{ $IFDECL KillTimer $THEN BEGIN }
  FUNCTION  KillTimer (
    h_                 : HWND;
    s_                 : short
  )                    : BOOL;
{ $END }


{ $IFDECL EnableWindow $THEN BEGIN }
  FUNCTION  EnableWindow (
    h_                 : HWND;
    b_                 : BOOL
  )                    : BOOL;
{ $END }

{ $IFDECL IsWindowEnabled $THEN BEGIN }
  FUNCTION  IsWindowEnabled (
    h_                 : HWND
  )                    : BOOL;
{ $END }


{ $IFDECL LoadAccelerators $THEN BEGIN }
  FUNCTION  LoadAccelerators (
    h_                 : HANDLE;
    l_                 : LPSTR
  )                    : HANDLE;
{ $END }


{ $IFDECL TranslateAccelerator $THEN BEGIN }
  FUNCTION  TranslateAccelerator (
    h_                 : HWND;
    i_                 : HANDLE;
    l_                 : LPMSG
  )                    : int;
{ $END }


(* GetSystemMetrics codes *)

CONST
  SM_CXSCREEN           = 0;
  SM_CYSCREEN           = 1;
  SM_CXVSCROLL          = 2;
  SM_CYHSCROLL          = 3;
  SM_CYCAPTION          = 4;
  SM_CXBORDER           = 5;
  SM_CYBORDER           = 6;
  SM_CXDLGFRAME         = 7;
  SM_CYDLGFRAME         = 8;
  SM_CYVTHUMB           = 9;
  SM_CXHTHUMB           = 10;
  SM_CXICON             = 11;
  SM_CYICON             = 12;
  SM_CXCURSOR           = 13;
  SM_CYCURSOR           = 14;
  SM_CYMENU             = 15;
  SM_CXFULLSCREEN       = 16;
  SM_CYFULLSCREEN       = 17;
  SM_CYKANJIWINDOW      = 18;
  SM_MOUSEPRESENT       = 19;
  SM_CYVSCROLL          = 20;
  SM_CXHSCROLL          = 21;
  SM_DEBUG              = 22;
  SM_SWAPBUTTON         = 23;
  SM_RESERVED1		= 24;
  SM_RESERVED2		= 25;
  SM_RESERVED3		= 26;
  SM_RESERVED4		= 27;
  SM_CXMIN		= 28;
  SM_CYMIN		= 29;
  SM_CXSIZE		= 30;
  SM_CYSIZE		= 31;
  SM_CXFRAME		= 32;
  SM_CYFRAME		= 33;
  SM_CXMINTRACK 	= 34;
  SM_CYMINTRACK 	= 35;
  SM_CMETRICS		= 36;


{ $IFDECL GetSystemMetrics $THEN BEGIN }
  FUNCTION  GetSystemMetrics (
    i_                 : int
  )                    : int;
{ $END }


{ $IFDECL HiliteMenuItem $THEN BEGIN }
  FUNCTION  HiliteMenuItem (
    h_                 : HWND;
    i_                 : HMENU;
    w_,x_              : WORD
  )                    : BOOL;
{ $END }

{ $IFDECL GetMenuString $THEN BEGIN }
  FUNCTION  GetMenuString (
    h_                 : HMENU;
    w_                 : WORD;
    l_                 : LPSTR;
    i_                 : int;
    x_                 : WORD
  )                    : int;
{ $END }

{ $IFDECL GetMenuState $THEN BEGIN }
  FUNCTION  GetMenuState (
    h_                 : HMENU;
    w_                 : WORD;
    w_		       : WORD
  )		       : WORD;
{ $END }

{ $IFDECL GetMenuItemID $THEN BEGIN }
  FUNCTION  GetMenuItemID (
    h_                 : HMENU;
    i_		       : int
  )		       : WORD;
{ $END }

{ $IFDECL GetMenuItemCount $THEN BEGIN }
  FUNCTION  GetMenuItemCount (
    h_		       : HMENU
  )		       : WORD;
{ $END }

{ $IFDECL DrawMenuBar $THEN BEGIN }
  PROCEDURE DrawMenuBar (
    h_                 : HWND
  );
{ $END }

{ $IFDECL GetSystemMenu $THEN BEGIN }
  FUNCTION  GetSystemMenu (
    h_                 : HWND;
    b_                 : BOOL
  )                    : HMENU;
{ $END }

{ $IFDECL CreateMenu $THEN BEGIN }
  FUNCTION  CreateMenu                    : HMENU;
{ $END }

{ $IFDECL DestroyMenu $THEN BEGIN }
  FUNCTION  DestroyMenu (
    h_                 : HMENU
  )                    : BOOL;
{ $END }

{ $IFDECL ChangeMenu $THEN BEGIN }
  FUNCTION  ChangeMenu (
    h_                 : HMENU;
    w_                 : WORD;
    l_                 : LPSTR;
    x_,y_              : WORD
  )                    : BOOL;
{ $END }

{ $IFDECL CheckMenuItem $THEN BEGIN }
  FUNCTION  CheckMenuItem (
    h_                 : HMENU;
    w_,x_              : WORD
  )                    : BOOL;
{ $END }

{ $IFDECL EnableMenuItem $THEN BEGIN }
  FUNCTION  EnableMenuItem (
    h_                 : HMENU;
    w_,x_              : WORD
  )                    : BOOL;
{ $END }

{ $IFDECL GetSubMenu $THEN BEGIN }
  FUNCTION  GetSubMenu (
    h_                 : HMENU;
    i_                 : int
  )                    : HMENU;
{ $END }

{ $IFDECL EndMenu $THEN BEGIN }
  PROCEDURE EndMenu;
{ $END }


{ $IFDECL GrayString $THEN BEGIN }
  FUNCTION  GrayString (
    h_                 : HDC;
    i_                 : HBRUSH;
    f_                 : FARPROC;
    d_                 : DWORD;
    j_,k_,l_,m_,n_     : int
  )                    : BOOL;
{ $END }

{ $IFDECL UpdateWindow $THEN BEGIN }
  PROCEDURE UpdateWindow (
    h_                 : HWND
  );
{ $END }

{ $IFDECL SetActiveWindow $THEN BEGIN }
  FUNCTION  SetActiveWindow (
    h_                 : HWND
  )                    : HWND;
{ $END }


{ $IFDECL GetWindowDC $THEN BEGIN }
  FUNCTION  GetWindowDC (
    h_                 : HWND
  )                    : HDC;
{ $END }

{ $IFDECL GetDC $THEN BEGIN }
  FUNCTION  GetDC (
    h_                 : HWND
  )                    : HDC;
{ $END }

{ $IFDECL ReleaseDC $THEN BEGIN }
  FUNCTION  ReleaseDC (
    h_                 : HWND;
    i_                 : HDC
  )                    : int;
{ $END }


{ $IFDECL BeginPaint $THEN BEGIN }
  FUNCTION  BeginPaint (
    h_                 : HWND;
    l_                 : LPPAINTSTRUCT
  )                    : HDC;
{ $END }


{ $IFDECL EndPaint $THEN BEGIN }
  PROCEDURE EndPaint (
    h_                 : HWND;
    l_                 : LPPAINTSTRUCT
  );
{ $END }

{ $IFDECL GetUpdateRect $THEN BEGIN }
  FUNCTION  GetUpdateRect (
    h_                 : HWND;
    l_                 : LPRECT;
    b_                 : BOOL
  )                    : BOOL;
{ $END }

{ $IFDECL GetUpdateRgn $THEN BEGIN }
  FUNCTION  GetUpdateRgn (
    h_                 : HWND;
    r_		       : HRGN;
    b_                 : BOOL
  )		       : int;
{ $END }

{ $IFDECL GetUpdateRgn $THEN BEGIN }
  FUNCTION  GetUpdateRgn (
    d_		       : HDC;
    h_		       : HWND
  )		       : short;
{ $END }

{ $IFDECL InvalidateRect $THEN BEGIN }
  PROCEDURE InvalidateRect (
    h_                 : HWND;
    l_                 : LPRECT;
    b_                 : BOOL
  );
{ $END }

{ $IFDECL ValidateRect $THEN BEGIN }
  PROCEDURE ValidateRect (
    h_                 : HWND;
    l_                 : LPRECT
  );
{ $END }


{ $IFDECL InvalidateRgn $THEN BEGIN }
  PROCEDURE InvalidateRgn (
    h_                 : HWND;
    i_                 : HRGN;
    b_                 : BOOL
  );
{ $END }

{ $IFDECL ValidateRgn $THEN BEGIN }
  PROCEDURE ValidateRgn (
    h_                 : HWND;
    i_                 : HRGN
  );
{ $END }


{ $IFDECL ScrollWindow $THEN BEGIN }
  PROCEDURE ScrollWindow (
    h_                 : HWND;
    i_,j_              : int;
    l_,m_              : LPRECT
  );
{ $END }

{ $IFDECL ScrollDC $THEN BEGIN }
  FUNCTION ScrollDC (
    h_		       : HDC;
    i_,j_              : int;
    l_,m_	       : LPRECT;
    r_		       : HRGN;
    p_		       : LPRECT
  )		       : BOOL;
{ $END }

{ $IFDECL SetScrollPos $THEN BEGIN }
  FUNCTION  SetScrollPos (
    h_                 : HWND;
    i_,j_              : int;
    b_                 : BOOL
  )                    : int;
{ $END }

{ $IFDECL GetScrollPos $THEN BEGIN }
  FUNCTION  GetScrollPos (
    h_                 : HWND;
    i_                 : int
  )                    : int;
{ $END }

{ $IFDECL SetScrollRange $THEN BEGIN }
  PROCEDURE SetScrollRange (
    h_                 : HWND;
    i_,j_,k_           : int;
    b_                 : BOOL
  );
{ $END }

{ $IFDECL GetScrollRange $THEN BEGIN }
  PROCEDURE GetScrollRange (
    h_                 : HWND;
    i_                 : int;
    l_,m_              : LPINT
  );
{ $END }

{ $IFDECL ShowScrollBar $THEN BEGIN }
  PROCEDURE ShowScrollBar (
    h_                 : HWND;
    w_		       : WORD;
    b_		       : BOOL
  );
{ $END }

{ $IFDECL SetProp $THEN BEGIN }
  FUNCTION  SetProp (
    h_                 : HWND;
    l_                 : LPSTR;
    i_                 : HANDLE
  )                    : BOOL;
{ $END }

{ $IFDECL GetProp $THEN BEGIN }
  FUNCTION  GetProp (
    h_                 : HWND;
    l_                 : LPSTR
  )                    : HANDLE;
{ $END }

{ $IFDECL RemoveProp $THEN BEGIN }
  FUNCTION  RemoveProp (
    h_                 : HWND;
    l_                 : LPSTR
  )                    : HANDLE;
{ $END }

{ $IFDECL EnumProps $THEN BEGIN }
  FUNCTION  EnumProps (
    h_                 : HWND;
    f_                 : FARPROC
  )                    : int;
{ $END }

{ $IFDECL SetWindowText $THEN BEGIN }
  PROCEDURE SetWindowText (
    h_                 : HWND;
    l_                 : LPSTR
  );
{ $END }

{ $IFDECL GetWindowText $THEN BEGIN }
  FUNCTION  GetWindowText (
    h_                 : HWND;
    l_                 : LPSTR;
    i_                 : int
  )                    : int;
{ $END }

{ $IFDECL GetWindowTextLength $THEN BEGIN }
  FUNCTION  GetWindowTextLength (
    h_                 : HWND
  )                    : int;
{ $END }

{ $IFDECL SetMenu $THEN BEGIN }
  FUNCTION  SetMenu (
    h_                 : HWND;
    i_                 : HMENU
  )                    : BOOL;
{ $END }

{ $IFDECL GetMenu $THEN BEGIN }
  FUNCTION  GetMenu (
    h_                 : HWND
  )                    : HMENU;
{ $END }


{ $IFDECL GetClientRect $THEN BEGIN }
  PROCEDURE GetClientRect (
    h_                 : HWND;
    l_                 : LPRECT
  );
{ $END }

{ $IFDECL GetWindowRect $THEN BEGIN }
  PROCEDURE GetWindowRect (
    h_                 : HWND;
    l_                 : LPRECT
  );
{ $END }

{ $IFDECL AdjustWindowRect $THEN BEGIN }
  PROCEDURE AdjustWindowRect (
    l_		       : LPRECT
    l2_ 	       : long;
    b_		       : BOOL
  );
{ $END }

(* MessageBox type_flags *)

CONST
  MB_OK                 = #0000;
  MB_OKCANCEL           = #0001;
  MB_ABORTRETRYIGNORE   = #0002;
  MB_YESNOCANCEL        = #0003;
  MB_YESNO              = #0004;
  MB_RETRYCANCEL        = #0005;

  MB_ICONHAND           = #0010;
  MB_ICONQUESTION       = #0020;
  MB_ICONEXCLAMATION    = #0030;
  MB_ICONASTERISK       = #0040;

  MB_DEFBUTTON1         = #0000;
  MB_DEFBUTTON2         = #0100;
  MB_DEFBUTTON3         = #0200;

  MB_APPLMODAL          = #0000;
  MB_SYSTEMMODAL        = #1000;
  MB_NOFOCUS            = #8000;
  MB_MISCMASK           = #c000;
  MB_TYPEMASK           = #000f;
  MB_ICONMASK           = #00f0;
  MB_DEFMASK            = #0f00;
  MB_MODEMASK           = #3000;


{ $IFDECL MessageBox $THEN BEGIN }
  FUNCTION  MessageBox (
    h_                 : HWND;
    l_,m_              : LPSTR;
    w_                 : WORD
  )                    : int;
{ $END }

{ $IFDECL MessageBeep $THEN BEGIN }
  FUNCTION  MessageBeep (
    w_                 : WORD
  )                    : BOOL;
{ $END }


{ $IFDECL ShowCursor $THEN BEGIN }
  FUNCTION  ShowCursor (
    b_                 : BOOL
  )                    : int;
{ $END }


{ $IFDECL SetCursor $THEN BEGIN }
  FUNCTION  SetCursor (
    h_                 : HCURSOR
  )                    : HCURSOR;
{ $END }


{ $IFDECL SetCursorPos $THEN BEGIN }
  PROCEDURE SetCursorPos (
    i_,j_              : int
  );
{ $END }


{ $IFDECL GetCursorPos $THEN BEGIN }
  PROCEDURE GetCursorPos (
    l_                 : LPPOINT
  );
{ $END }


{ $IFDECL ClipCursor $THEN BEGIN }
  PROCEDURE ClipCursor (
    l_                 : LPRECT
  );
{ $END }


{ $IFDECL CreateCaret $THEN BEGIN }
  PROCEDURE CreateCaret (
    h_                 : HWND;
    i_                 : HBITMAP;
    j_,k_              : int
  );
{ $END }



{ $IFDECL GetCaretBlinkTime $THEN BEGIN }
  FUNCTION  GetCaretBlinkTime                    : WORD;
{ $END }

{ $IFDECL SetCaretBlinkTime $THEN BEGIN }
  PROCEDURE SetCaretBlinkTime (
    w_                 : WORD
  );
{ $END }

{ $IFDECL DestroyCaret $THEN BEGIN }
  PROCEDURE DestroyCaret;
{ $END }

{ $IFDECL HideCaret $THEN BEGIN }
  PROCEDURE HideCaret (
    h_                 : HWND
  );
{ $END }

{ $IFDECL ShowCaret $THEN BEGIN }
  PROCEDURE ShowCaret (
    h_                 : HWND
  );
{ $END }

{ $IFDECL SetCaretPos $THEN BEGIN }
  PROCEDURE SetCaretPos (
    i_,j_              : int
  );
{ $END }

{ $IFDECL GetCaretPos $THEN BEGIN }
  PROCEDURE GetCaretPos (
    l_			 : LPPOINT
  );
{ $END }

{ $IFDECL ClientToScreen $THEN BEGIN }
  PROCEDURE ClientToScreen (
    h_                 : HWND;
    l_                 : LPPOINT
  );
{ $END }

{ $IFDECL ScreenToClient $THEN BEGIN }
  PROCEDURE ScreenToClient (
    h_                 : HWND;
    l_                 : LPPOINT
  );
{ $END }

{ $IFDECL WindowFromPoint $THEN BEGIN }
  FUNCTION  WindowFromPoint (
    p_                 : POINT
  )                    : HWND;
{ $END }

{ $IFDECL ChildWindowFromPoint $THEN BEGIN }
  FUNCTION  ChildWindowFromPoint (
    h_                 : HWND;
    p_                 : POINT
  )                    : HWND;
{ $END }

(* color type_indices           *)
(* for the WM_CTLCOLOR message *)

CONST
  CTLCOLOR_MSGBOX       = 0;
  CTLCOLOR_EDIT         = 1;
  CTLCOLOR_LISTBOX      = 2;
  CTLCOLOR_BTN          = 3;
  CTLCOLOR_DLG          = 4;
  CTLCOLOR_SCROLLBAR    = 5;
  CTLCOLOR_STATIC       = 6;
  CTLCOLOR_MAX          = 8     (* three bits max *);

  COLOR_SCROLLBAR       = 0;
  COLOR_BACKGROUND      = 1;
  COLOR_ACTIVECAPTION   = 2;
  COLOR_INACTIVECAPTION = 3;
  COLOR_MENU            = 4;
  COLOR_WINDOW          = 5;
  COLOR_WINDOWFRAME     = 6;
  COLOR_MENUTEXT        = 7;
  COLOR_WINDOWTEXT      = 8;
  COLOR_CAPTIONTEXT     = 9;
  COLOR_ACTIVEBORDER	= 10;
  COLOR_INACTIVEBORDER	= 11;
  COLOR_APPWORKSPACE	= 12;


{ $IFDECL GetSysColor $THEN BEGIN }
  FUNCTION  GetSysColor (
    i_                 : int
  )                    : DWORD;
{ $END }

{ $IFDECL SetSysColors $THEN BEGIN }
  PROCEDURE SetSysColors (
    i_                 : int;
    l_                 : LPINT;
    m_                 : LPlong
  );
{ $END }

  CP_GETBEEP	    = 1;
  CP_SETBEEP	    = 2;
  CP_GETMOUSE	    = 3;
  CP_SETMOUSE	    = 4;
  CP_GETBORDER	    = 5;
  CP_SETBORDER	    = 6;
  CP_TIMEOUTS	    = 7;
  CP_KANJIMENU	    = 8;

{ $IFDECL ControlPanelInfo $THEN BEGIN }
  PROCEDURE ControlPanelInfo (
    w_,x_	       : WORD;
    l_		       : LONG
  );
{ $END }

{ $IFDECL CreateDC $THEN BEGIN }
  FUNCTION  CreateDC (
    l_,m_,n_,o_        : LPSTR
  )                    : HDC;
{ $END }

{ $IFDECL CreateIC $THEN BEGIN }
  FUNCTION  CreateIC (
    l_,m_,n_,o_        : LPSTR
  )                    : HDC;
{ $END }

{ $IFDECL CreateCompatibleDC $THEN BEGIN }
  FUNCTION  CreateCompatibleDC (
    h_                 : HDC
  )                    : HDC;
{ $END }

{ $IFDECL DeleteDC $THEN BEGIN }
  FUNCTION  DeleteDC (
    h_                 : HDC
  )                    : BOOL;
{ $END }

{ $IFDECL SaveDC $THEN BEGIN }
  FUNCTION  SaveDC (
    h_                 : HDC
  )                    : short;
{ $END }

{ $IFDECL RestoreDC $THEN BEGIN }
  FUNCTION  RestoreDC (
    h_                 : HDC;
    s_                 : short
  )                    : BOOL;
{ $END }

{ $IFDECL MoveTo $THEN BEGIN }
  FUNCTION  MoveTo (
    h_                 : HDC;
    s_,t_              : short
  )                    : DWORD;
{ $END }

{ $IFDECL GetCurrentPosition $THEN BEGIN }
  FUNCTION  GetCurrentPosition (
    h_                 : HDC
  )                    : DWORD;
{ $END }

{ $IFDECL LineTo $THEN BEGIN }
  FUNCTION  LineTo (
    h_                 : HDC;
    s_,t_              : short
  )                    : BOOL;
{ $END }

{ $IFDECL GetDCOrg $THEN BEGIN }
  FUNCTION  GetDCOrg (
    h_		       : HDC
  )		       : DWORD;
{ $END }

{ $IFDECL ExtTextOut $THEN BEGIN }
  FUNCTION  ExtTextOut (
    h_                 : HDC;
    s_,t_	       : short;
    w_		       : WORD;
    l_		       : LPRECT;
    p_		       : LPSTR;
    i_		       : WORD;
    n_		       : LPINT
  )                    : BOOL;
{ $END }

{ $IFDECL FastWindowFrame $THEN BEGIN }
  FUNCTION  FastWindowFrame (
    h_                 : HDC;
    l_		       : LPRECT;
    w_,x_	       : WORD;
    i_		       : DWORD
  )                    : BOOL;
{ $END }

{ $IFDECL Polyline $THEN BEGIN }
  FUNCTION  Polyline (
    h_                 : HDC;
    l_                 : LPPOINT;
    s_                 : short
  )                    : BOOL;
{ $END }

{ $IFDECL Polygon $THEN BEGIN }
  FUNCTION  Polygon (
    h_                 : HDC;
    l_                 : LPPOINT;
    s_                 : short
  )                    : BOOL;
{ $END }


{ $IFDECL Rectangle $THEN BEGIN }
  FUNCTION  Rectangle (
    h_                 : HDC;
    s_,t_,u_,v_        : short
  )                    : BOOL;
{ $END }

{ $IFDECL RoundRect $THEN BEGIN }
  FUNCTION  RoundRect (
    h_                 : HDC;
    s_,t_,u_,v_,w_,x_  : short
  )                    : BOOL;
{ $END }

{ $IFDECL Ellipse $THEN BEGIN }
  FUNCTION  Ellipse (
    h_                 : HDC;
    s_,t_,u_,v_        : short
  )                    : BOOL;
{ $END }

{ $IFDECL Arc $THEN BEGIN }
  FUNCTION  Arc (
    h_                 : HDC;
    s_,t_,u_,v_,w_,x_,y_,z_ : short
  )                         : BOOL;
{ $END }

{ $IFDECL Chord $THEN BEGIN }
  FUNCTION  Chord (
    h_                 : HDC;
    s_,t_,u_,v_,w_,x_,y_,z_ : short
  )                         : BOOL;
{ $END }

{ $IFDECL Pie $THEN BEGIN }
  FUNCTION  Pie (
    h_                      : HDC;
    s_,t_,u_,v_,w_,x_,y_,z_ : short
  )                         : BOOL;
{ $END }

{ $IFDECL PatBlt $THEN BEGIN }
  FUNCTION  PatBlt (
    h_                      : HDC;
    s_,t_,u_,v_             : short;
    d_                      : DWORD
  )                         : BOOL;
{ $END }

{ $IFDECL BitBlt $THEN BEGIN }
  FUNCTION  BitBlt (
    h_                      : HDC;
    s_,t_,u_,v_             : short;
    i_                      : HDC;
    w_,x_                   : short;
    d_                      : DWORD
  )                         : BOOL;
{ $END }

{ $IFDECL StretchBlt $THEN BEGIN }
  FUNCTION  StretchBlt (
    h_                      : HDC;
    s_,t_,u_,v_             : short;
    i_                      : HDC;
    w_,x_,y_,z_             : short;
    d_                      : DWORD
  )                         : BOOL;
{ $END }

{ $IFDECL TextOut $THEN BEGIN }
  FUNCTION  TextOut (
    h_                      : HDC;
    s_,t_                   : short;
    l_                      : LPSTR;
    u_                      : short
  )                         : BOOL;
{ $END }

{ $IFDECL GetCharWidth $THEN BEGIN }
  FUNCTION  GetCharWidth (
    h_                      : HDC;
    w_,x_		    : WORD;
    l_			    : LPINT
  )			    : BOOL;
{ $END }

{ $IFDECL SetPixel $THEN BEGIN }
  FUNCTION  SetPixel (
    h_                      : HDC;
    s_,t_                   : short;
    d_                      : DWORD
  )                         : DWORD;
{ $END }

{ $IFDECL GetPixel $THEN BEGIN }
  FUNCTION  GetPixel (
    h_                      : HDC;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL FloodFill $THEN BEGIN }
  FUNCTION  FloodFill (
    h_                      : HDC;
    s_,t_                   : short;
    d_                      : DWORD
  )                         : BOOL;
{ $END }


{ $IFDECL LineDDA $THEN BEGIN }
  PROCEDURE LineDDA (
    s_,t_,u_,v_             : short;
    f_                      : FARPROC;
    l_                      : LPSTR
  );
{ $END }


{ $IFDECL FillRect $THEN BEGIN }
  FUNCTION  FillRect (
    h_                      : HDC;
    l_                      : LPRECT;
    i_                      : HBRUSH
  )                         : int;
{ $END }

{ $IFDECL FrameRect $THEN BEGIN }
  FUNCTION  FrameRect (
    h_                      : HDC;
    l_                      : LPRECT;
    i_                      : HBRUSH
  )                         : int;
{ $END }

{ $IFDECL InvertRect $THEN BEGIN }
  FUNCTION  InvertRect (
    h_                      : HDC;
    l_                      : LPRECT
  )                         : int;
{ $END }



{ $IFDECL FillRgn $THEN BEGIN }
  FUNCTION  FillRgn (
    h_                      : HDC;
    i_                      : HRGN;
    j_                      : HBRUSH
  )                         : BOOL;
{ $END }

{ $IFDECL FrameRgn $THEN BEGIN }
  FUNCTION  FrameRgn (
    h_                      : HDC;
    i_                      : HRGN;
    j_                      : HBRUSH;
    s_,t_                   : short
  )                         : BOOL;
{ $END }

{ $IFDECL InvertRgn $THEN BEGIN }
  FUNCTION  InvertRgn (
    h_                      : HDC;
    i_                      : HRGN
  )                         : BOOL;
{ $END }

{ $IFDECL PaintRgn $THEN BEGIN }
  FUNCTION  PaintRgn (
    h_                      : HDC;
    i_                      : HRGN
  )                         : BOOL;
{ $END }

{ $IFDECL PtInRegion $THEN BEGIN }
  FUNCTION  PtInRegion (
    h_                      : HRGN;
    s_,t_                   : short
  )                         : BOOL;
{ $END }


{ $IFDECL GetStockObject $THEN BEGIN }
  FUNCTION  GetStockObject (
    s_                      : short
  )                         : HANDLE;
{ $END }


{ $IFDECL CreatePen $THEN BEGIN }
  FUNCTION  CreatePen (
    s_,t_                   : short;
    d_                      : DWORD
  )                         : HPEN;
{ $END }

{ $IFDECL CreatePenIndirect $THEN BEGIN }
  FUNCTION  CreatePenIndirect (
    l_                      : LPLOGPEN
  )                         : HPEN;
{ $END }


{ $IFDECL CreateSolidBrush $THEN BEGIN }
  FUNCTION  CreateSolidBrush (
    d_                      : DWORD
  )                         : HBRUSH;
{ $END }

{ $IFDECL CreateHatchBrush $THEN BEGIN }
  FUNCTION  CreateHatchBrush (
    s_                      : short;
    d_                      : DWORD
  )                         : HBRUSH;
{ $END }

{ $IFDECL SetBrushOrg $THEN BEGIN }
  FUNCTION  SetBrushOrg (
    h_                      : HDC;
    i_,j_                   : int
  )                         : DWORD;
{ $END }

{ $IFDECL GetBrushOrg $THEN BEGIN }
  FUNCTION  GetBrushOrg (
    h_                      : HDC
  )                         : DWORD;
{ $END }

{ $IFDECL UnrealizeObject $THEN BEGIN }
  FUNCTION  UnrealizeObject (
    h_                      : HBRUSH
  )                         : BOOL;
{ $END }


{ $IFDECL CreatePatternBrush $THEN BEGIN }
  FUNCTION  CreatePatternBrush (
    h_                      : HBITMAP
  )                         : HBRUSH;
{ $END }

{ $IFDECL CreateBrushIndirect $THEN BEGIN }
  FUNCTION  CreateBrushIndirect (
    l_                      : LPLOGBRUSH
  )                         : HBRUSH;
{ $END }



{ $IFDECL CreateBitmap $THEN BEGIN }
  FUNCTION  CreateBitmap (
    s_,t_                   : short;
    b_,c_                   : BYTE;
    l_                      : LPSTR
  )                         : HBITMAP;
{ $END }

{ $IFDECL CreateBitmapIndirect $THEN BEGIN }
  FUNCTION  CreateBitmapIndirect (
    b_                      : LPBITMAP
  )                         : HBITMAP;
{ $END }

{ $IFDECL CreateCompatibleBitmap $THEN BEGIN }
  FUNCTION  CreateCompatibleBitmap (
    h_                      : HDC;
    s_,t_                   : short
  )                         : HBITMAP;
{ $END }

{ $IFDECL CreateDiscardableBitmap $THEN BEGIN }
  FUNCTION  CreateDiscardableBitmap (
    h_                      : HDC;
    s_,t_                   : short
  )                         : HBITMAP;
{ $END }

{ $IFDECL SetBitmapBits $THEN BEGIN }
  FUNCTION  SetBitmapBits (
    h_                      : HBITMAP;
    d_                      : DWORD;
    l_                      : LPSTR
  )			    : long;
{ $END }

{ $IFDECL GetBitmapBits $THEN BEGIN }
  FUNCTION  GetBitmapBits (
    h_                      : HBITMAP;
    l_                      : long;
    m_                      : LPSTR
  )                         : long;
{ $END }

{ $IFDECL SetBitmapDimension $THEN BEGIN }
  FUNCTION  SetBitmapDimension (
    h_                      : HBITMAP;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL GetBitmapDimension $THEN BEGIN }
  FUNCTION  GetBitmapDimension (
    h_                      : HBITMAP
  )                         : DWORD;
{ $END }


{ $IFDECL CreateFont $THEN BEGIN }
  FUNCTION  CreateFont (
    s_,t_,u_,v_,w_          : short;
    b_,c_,d_,e_,f_,g_,h_,i_ : BYTE;
    l_                      : LPSTR
  )                         : HFONT;
{ $END }

{ $IFDECL CreateFontIndirect $THEN BEGIN }
  FUNCTION  CreateFontIndirect (
    l_                      : LPLOGFONT
  )                         : HFONT;
{ $END }


{ $IFDECL CreateRectRgn $THEN BEGIN }
  FUNCTION  CreateRectRgn (
    s_,t_,u_,v_             : short
  )                         : HRGN;
{ $END }

{ $IFDECL SetRectRgn $THEN BEGIN }
  PROCEDURE  SetRectRgn     (
    h_			    : HRGN;
    s_,t_,u_,v_ 	    : short;
  );
{ $END }


{ $IFDECL CreateRectRgnIndirect $THEN BEGIN }
  FUNCTION  CreateRectRgnIndirect (
    l_                      : LPRECT
  )                         : HRGN;
{ $END }

{ $IFDECL CreateEllipticRgnIndirect $THEN BEGIN }
  FUNCTION  CreateEllipticRgnIndirect (
    l_                      : LPRECT
  )                         : HRGN;
{ $END }


{ $IFDECL CreateEllipticRgn $THEN BEGIN }
  FUNCTION  CreateEllipticRgn (
    s_,t_,u_,v_             : short
  )                         : HRGN;
{ $END }

{ $IFDECL CreatePolygonRgn $THEN BEGIN }
  FUNCTION  CreatePolygonRgn (
    l_                      : LPPOINT;
    s_,t_                   : short
  )                         : HRGN;
{ $END }


{ $IFDECL DeleteObject $THEN BEGIN }
  FUNCTION  DeleteObject (
    h_                      : HANDLE
  )                         : BOOL;
{ $END }

{ $IFDECL SelectObject $THEN BEGIN }
  FUNCTION  SelectObject (
    h_                      : HDC;
    i_                      : HANDLE
  )                         : HANDLE;
{ $END }


{ $IFDECL SelectClipRgn $THEN BEGIN }
  FUNCTION  SelectClipRgn (
    h_                      : HDC;
    i_                      : HRGN
  )                         : short;
{ $END }


{ $IFDECL GetObject $THEN BEGIN }
  FUNCTION  GetObject (
    h_                      : HANDLE;
    s_                      : short;
    l_                      : LPSTR
  )                         : short;
{ $END }


{ $IFDECL SetRelAbs $THEN BEGIN }
  FUNCTION  SetRelAbs (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL GetRelAbs $THEN BEGIN }
  FUNCTION  GetRelAbs (
    h_                      : HDC
  )                         : short;
{ $END }

{ $IFDECL SetBkColor $THEN BEGIN }
  FUNCTION  SetBkColor (
    h_                      : HDC;
    d_                      : DWORD
  )                         : DWORD;
{ $END }

{ $IFDECL GetBkColor $THEN BEGIN }
  FUNCTION  GetBkColor (
    h_                      : HDC
  )                         : DWORD;
{ $END }

{ $IFDECL SetBkMode $THEN BEGIN }
  FUNCTION  SetBkMode (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL GetBkMode $THEN BEGIN }
  FUNCTION  GetBkMode (
    h_                      : HDC
  )                         : short;
{ $END }

{ $IFDECL SetTextColor $THEN BEGIN }
  FUNCTION  SetTextColor (
    h_                      : HDC;
    d_                      : DWORD
  )                         : DWORD;
{ $END }

{ $IFDECL GetTextColor $THEN BEGIN }
  FUNCTION  GetTextColor (
    h_                      : HDC
  )                         : DWORD;
{ $END }

{ $IFDECL SetTextAlign $THEN BEGIN }
  FUNCTION  SetTextAlign (
    h_			    : HDC;
    w_			    : WORD
  )			    : WORD;
{ $END }

{ $IFDECL GetTextAlign $THEN BEGIN }
  FUNCTION  GetTextAlign (
    h_                      : HDC
  )			    : WORD;
{ $END }

{ $IFDECL SetMapperFlags $THEN BEGIN }
  FUNCTION  SetMapperFlags (
    h_			    : HDC;
    w_			    : WORD
  )			    : DWORD;
{ $END }

{ $IFDECL GetAspectRatioFilter $THEN BEGIN }
  FUNCTION  GetAspectRatioFilter (
    h_			    : HDC
  )			    : DWORD;
{ $END }

{ $IFDECL GetNearestColor $THEN BEGIN }
  FUNCTION  GetNearestColor (
    h_                      : HDC;
    d_                      : DWORD
  )                         : DWORD;
{ $END }

{ $IFDECL SetROP2 $THEN BEGIN }
  FUNCTION  SetROP2 (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL GetROP2 $THEN BEGIN }
  FUNCTION  GetROP2 (
    h_                      : HDC
  )                         : short;
{ $END }

{ $IFDECL SetStretchBltMode $THEN BEGIN }
  FUNCTION  SetStretchBltMode (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL GetStretchBltMode $THEN BEGIN }
  FUNCTION  GetStretchBltMode (
    h_                      : HDC
  )                         : short;
{ $END }

{ $IFDECL SetPolyFillMode $THEN BEGIN }
  FUNCTION  SetPolyFillMode (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL GetPolyFillMode $THEN BEGIN }
  FUNCTION  GetPolyFillMode (
    h_                      : HDC
  )                         : short;
{ $END }

{ $IFDECL SetMapMode $THEN BEGIN }
  FUNCTION  SetMapMode (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL GetMapMode $THEN BEGIN }
  FUNCTION  GetMapMode (
    h_                      : HDC
  )                         : short;
{ $END }

{ $IFDECL SetWindowOrg $THEN BEGIN }
  FUNCTION  SetWindowOrg (
    h_                      : HDC;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL GetWindowOrg $THEN BEGIN }
  FUNCTION  GetWindowOrg (
    h_                      : HDC
  )                         : DWORD;
{ $END }

{ $IFDECL SetWindowExt $THEN BEGIN }
  FUNCTION  SetWindowExt (
    h_                      : HDC;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL GetWindowExt $THEN BEGIN }
  FUNCTION  GetWindowExt (
    h_                      : HDC
  )                         : DWORD;
{ $END }

{ $IFDECL SetViewportOrg $THEN BEGIN }
  FUNCTION  SetViewportOrg (
    h_                      : HDC;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL GetViewportOrg $THEN BEGIN }
  FUNCTION  GetViewportOrg (
    h_                      : HDC
  )                         : DWORD;
{ $END }

{ $IFDECL SetViewportExt $THEN BEGIN }
  FUNCTION  SetViewportExt (
    h_                      : HDC;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL GetViewportExt $THEN BEGIN }
  FUNCTION  GetViewportExt (
    h_                      : HDC
  )                         : DWORD;
{ $END }

{ $IFDECL OffsetViewportOrg $THEN BEGIN }
  FUNCTION  OffsetViewportOrg (
    h_                      : HDC;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL ScaleViewportExt $THEN BEGIN }
  FUNCTION  ScaleViewportExt (
    h_                      : HDC;
    s_,t_,r_,q_ 	    : short
  )                         : DWORD;
{ $END }

{ $IFDECL OffsetWindowOrg $THEN BEGIN }
  FUNCTION  OffsetWindowOrg (
    h_                      : HDC;
    s_,t_                   : short
  )                         : DWORD;
{ $END }

{ $IFDECL ScaleWindowExt $THEN BEGIN }
  FUNCTION  ScaleWindowExt (
    h_                      : HDC;
    s_,t_,r_,q_ 	    : short
  )                         : DWORD;
{ $END }


{ $IFDECL GetClipBox $THEN BEGIN }
  FUNCTION  GetClipBox (
    h_                      : HDC;
    l_                      : LPRECT
  )                         : short;
{ $END }


{ $IFDECL IntersectClipRect $THEN BEGIN }
  FUNCTION  IntersectClipRect (
    h_                      : HDC;
    s_,t_,u_,v_             : short
  )                         : short;
{ $END }

{ $IFDECL OffsetClipRgn $THEN BEGIN }
  FUNCTION  OffsetClipRgn (
    h_                      : HDC;
    s_,t_                   : short
  )                         : short;
{ $END }

{ $IFDECL ExcludeClipRect $THEN BEGIN }
  FUNCTION  ExcludeClipRect (
    h_                      : HDC;
    s_,t_,u_,v_             : short
  )                         : short;
{ $END }

{ $IFDECL PtVisible $THEN BEGIN }
  FUNCTION  PtVisible (
    h_                      : HDC;
    s_,t_                   : short
  )                         : BOOL;
{ $END }


{ $IFDECL SetRect $THEN BEGIN }
  FUNCTION  SetRect (
    l_                      : LPRECT;
    i_,j_,k_,m_             : int
  )                         : int;
{ $END }

{ $IFDECL SetRectEmpty $THEN BEGIN }
  FUNCTION  SetRectEmpty (
    l_                      : LPRECT
  )                         : int;
{ $END }

{ $IFDECL CopyRect $THEN BEGIN }
  FUNCTION  CopyRect (
    l_,m_                   : LPRECT
  )                         : int;
{ $END }

{ $IFDECL InflateRect $THEN BEGIN }
  FUNCTION  InflateRect (
    l_                      : LPRECT;
    i_,j_                   : int
  )                         : int;
{ $END }

{ $IFDECL IntersectRect $THEN BEGIN }
  FUNCTION  IntersectRect (
    l_,m_,n_                : LPRECT
  )                         : int;
{ $END }

{ $IFDECL UnionRect $THEN BEGIN }
  FUNCTION  UnionRect (
    l_,m_,n_                : LPRECT
  )                         : int;
{ $END }

{ $IFDECL OffsetRect $THEN BEGIN }
  FUNCTION  OffsetRect (
    l_                      : LPRECT;
    i_,j_                   : int
  )                         : int;
{ $END }

{ $IFDECL IsRectEmpty $THEN BEGIN }
  FUNCTION  IsRectEmpty (
    l_                      : LPRECT
  )                         : BOOL;
{ $END }

{ $IFDECL EqualRect $THEN BEGIN }
  FUNCTION  EqualRect (
    l_,k_		    : LPRECT
  )                         : BOOL;
{ $END }

{ $IFDECL PtInRect $THEN BEGIN }
  FUNCTION  PtInRect (
    l_                      : LPRECT;
    p_                      : POINT
  )                         : BOOL;
{ $END }


{ $IFDECL RectVisible $THEN BEGIN }
  FUNCTION  RectVisible (
    h_                      : HDC;
    l_                      : LPRECT
  )                         : BOOL;
{ $END }


{ $IFDECL CombineRgn $THEN BEGIN }
  FUNCTION  CombineRgn (
    h_,i_,j_                : HRGN;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL EqualRgn $THEN BEGIN }
  FUNCTION  EqualRgn (
    h_,i_                   : HRGN
  )                         : BOOL;
{ $END }

{ $IFDECL OffsetRgn $THEN BEGIN }
  FUNCTION  OffsetRgn (
    h_                      : HRGN;
    s_,t_                   : short
  )                         : short;
{ $END }


{ $IFDECL SetTextJustification $THEN BEGIN }
  FUNCTION  SetTextJustification (
    h_                      : HDC;
    s_,t_                   : short
  )                         : short;
{ $END }

{ $IFDECL GetTextExtent $THEN BEGIN }
  FUNCTION  GetTextExtent (
    h_                      : HDC;
    l_                      : LPSTR;
    s_                      : short
  )                         : DWORD;
{ $END }

{ $IFDECL SetTextCharacterExtra $THEN BEGIN }
  FUNCTION  SetTextCharacterExtra (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }

{ $IFDECL GetTextCharacterExtra $THEN BEGIN }
  FUNCTION  GetTextCharacterExtra (
    h_                      : HDC
  )                         : short;
{ $END }


{ $IFDECL GetMetaFile $THEN BEGIN }
  FUNCTION  GetMetaFile (
    l_                      : LPSTR
  )                         : HANDLE;
{ $END }

{ $IFDECL DeleteMetaFile $THEN BEGIN }
  FUNCTION  DeleteMetaFile (
    h_                      : HANDLE
  )                         : BOOL;
{ $END }

{ $IFDECL CopyMetaFile $THEN BEGIN }
  FUNCTION  CopyMetaFile (
    h_                      : HANDLE;
    l_                      : LPSTR
  )                         : HANDLE;
{ $END }

{ $IFDECL PlayMetaFileRecord $THEN BEGIN }
  PROCEDURE  PlayMetaFileRecord (
    h_                      : HDC;
    i_			    : LPHANDLETABLE;
    j_			    : LPMETARECORD;
    w_			    : WORD;
  );
{ $END }

{ $IFDECL EnumMetaFile $THEN BEGIN }
  FUNCTION  EnumMetaFile (
    h_                      : HDC;
    i_			    : LOCALHANDLE;
    f_			    : FARPROC;
    a_			    ; ADS OF BYTE
  )                         : BOOL;
{ $END }


{ $IFDECL PlayMetaFile $THEN BEGIN }
  FUNCTION  PlayMetaFile (
    h_                      : HDC;
    i_                      : HANDLE
  )                         : BOOL;
{ $END }

{ $IFDECL Escape $THEN BEGIN }
  FUNCTION  Escape (
    h_                      : HDC;
    s_,t_                   : short;
    l_,m_                   : LPSTR
  )                         : short;
{ $END }

{ $IFDECL EnumFonts $THEN BEGIN }
  FUNCTION  EnumFonts (
    h_                      : HDC;
    l_                      : LPSTR;
    f_                      : FARPROC;
    m_                      : LPSTR
  )                         : short;
{ $END }

{ $IFDECL EnumObjects $THEN BEGIN }
  FUNCTION  EnumObjects (
    h_                      : HDC;
    s_                      : short;
    f_                      : FARPROC;
    l_                      : LPSTR
  )                         : short;
{ $END }

{ $IFDECL GetTextFace $THEN BEGIN }
  FUNCTION  GetTextFace (
    h_                      : HDC;
    s_                      : short;
    l_                      : LPSTR
  )                         : short;
{ $END }

{ $IFDECL GetTextMetrics $THEN BEGIN }
  FUNCTION  GetTextMetrics (
    h_                      : HDC;
    l_                      : LPTEXTMETRIC
  )                         : BOOL;
{ $END }

{ $IFDECL GetDeviceCaps $THEN BEGIN }
  FUNCTION  GetDeviceCaps (
    h_                      : HDC;
    s_                      : short
  )                         : short;
{ $END }


{ $IFDECL DeviceModes $THEN BEGIN }
  FUNCTION  DeviceModes (
    h_                      : HWND;
    i_                      : HANDLE;
    l_,m_                   : LPSTR
  )                         : LPSTR;
{ $END }

{ $IFDECL SetEnvironment $THEN BEGIN }
  FUNCTION  SetEnvironment (
    l_,m_                   : LPSTR;
    w_                      : WORD
  )                         : short;
{ $END }

{ $IFDECL GetEnvironment $THEN BEGIN }
  FUNCTION  GetEnvironment (
    l_,m_                   : LPSTR;
    w_                      : WORD
  )                         : short;
{ $END }


{ $IFDECL DPtoLP $THEN BEGIN }
  FUNCTION  DPtoLP (
    h_                      : HDC;
    l_                      : LPPOINT;
    s_                      : short
  )                         : BOOL;
{ $END }

{ $IFDECL LPtoDP $THEN BEGIN }
  FUNCTION  LPtoDP (
    h_                      : HDC;
    l_                      : LPPOINT;
    s_                      : short
  )                         : BOOL;
{ $END }

(* Interface to the dynamic loader/linker *)


{ $IFDECL GetVersion $THEN BEGIN }
  FUNCTION  GetVersion                         : WORD;
{ $END }

{ $IFDECL GetNumTasks $THEN BEGIN }
  FUNCTION  GetNumTasks 		       : WORD;
{ $END }

{ $IFDECL GetCodeHandle $THEN BEGIN }
  FUNCTION  GetCodeHandle (
    f_                      : FARPROC
  )                         : HANDLE;
{ $END }

{ $IFDECL GetModuleHandle $THEN BEGIN }
  FUNCTION  GetModuleHandle (
    l_                      : LPSTR
  )                         : HANDLE;
{ $END }

{ $IFDECL GetModuleUsage $THEN BEGIN }
  FUNCTION  GetModuleUsage (
    h_                      : HANDLE
  )                         : int;
{ $END }

{ $IFDECL GetModuleFileName $THEN BEGIN }
  FUNCTION  GetModuleFileName (
    h_                      : HANDLE;
    l_                      : LPSTR;
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL GetInstanceData $THEN BEGIN }
  FUNCTION  GetInstanceData (
    h_                      : HANDLE;
    n_                      : NPSTR;
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL GetProcAddress $THEN BEGIN }
  FUNCTION  GetProcAddress (
    h_                      : HANDLE;
    l_                      : LPSTR
  )                         : FARPROC;
{ $END }

{ $IFDECL MakeProcInstance $THEN BEGIN }
  FUNCTION  MakeProcInstance (
    f_                      : FARPROC;
    h_                      : HANDLE
  )                         : FARPROC;
{ $END }

{ $IFDECL FreeProcInstance $THEN BEGIN }
  PROCEDURE FreeProcInstance (
    f_                      : FARPROC
  );
{ $END }

{ $IFDECL LoadLibrary $THEN BEGIN }
  FUNCTION  LoadLibrary (
    l_                      : LPSTR
  )                         : HANDLE;
{ $END }

{ $IFDECL FreeLibrary $THEN BEGIN }
  FUNCTION  FreeLibrary (
    h_                      : HANDLE
  )                         : HANDLE;
{ $END }


{ $IFDECL AnsiToOem $THEN BEGIN }
  FUNCTION  AnsiToOem (
    l_,m_                   : LPSTR
  )                         : BOOL;
{ $END }

{ $IFDECL OemToAnsi $THEN BEGIN }
  FUNCTION  OemToAnsi (
    l_,m_                   : LPSTR
  )                         : BOOL;
{ $END }

{ $IFDECL AnsiUpper $THEN BEGIN }
  FUNCTION  AnsiUpper (
    l_                      : LPSTR
  )                         : BYTE;
{ $END }

{ $IFDECL AnsiLower $THEN BEGIN }
  FUNCTION  AnsiLower (
    l_                      : LPSTR
  )                         : BYTE;
{ $END }

{ $IFDECL AnsiNext $THEN BEGIN }
  FUNCTION  AnsiNext (
    l_                      : LPSTR
  )                         : LPSTR;
{ $END }

{ $IFDECL AnsiPrev $THEN BEGIN }
  FUNCTION  AnsiPrev (
    l_,m_                   : LPSTR
  )                         : LPSTR;
{ $END }



TYPE
  OFSTRUCT = RECORD
    cBytes                  : BYTE; (* length of structure *)
    fFixedDisk              : BYTE; (* non-zero if file located on non- *)
                                    (* removeable media *)
    nErrCode                : WORD; (* DOS error code if OpenFile fails *)
    reserved                : ARRAY [0..3] OF BYTE;
    szPathName		    : ARRAY [0..127] OF BYTE;
  END;
  POFSTRUCT                 = ADR OF OFSTRUCT;
  NPOFSTRUCT                = ADR OF OFSTRUCT;
  LPOFSTRUCT                = ADS OF OFSTRUCT;


{ $IFDECL GetTempDrive $THEN BEGIN }
  FUNCTION  GetTempDrive (
    b_                      : BYTE
  )                         : BYTE;
{ $END }


{ $IFDECL GetTempFileName $THEN BEGIN }
  FUNCTION  GetTempFileName (
    b_                      : BYTE;
    l_                      : LPSTR;
    w_                      : WORD;
    m_                      : LPSTR
  )                         : int;
{ $END }

{ $IFDECL OpenFile $THEN BEGIN }
  FUNCTION  OpenFile (
    l_                      : LPSTR;
    m_                      : LPOFSTRUCT;
    w_                      : WORD
  )                         : int;
{ $END }

(* Flags for GetTempFileName *)

CONST
  TF_FORCEDRIVE         = #80;   (* Forces use of current dir of passed *)
                                 (* drive *)

(* Flags for OpenFile *)

CONST
  OF_REOPEN             = #8000;
  OF_EXIST              = #4000;
  OF_PROMPT             = #2000;
  OF_CREATE             = #1000;
  OF_CANCEL             = #0800;
  OF_VERIFY             = #0400;
  OF_DELETE             = #0200;
  OF_PARSE              = #0100;

  OF_READ               = 0;
  OF_WRITE              = 1;
  OF_READWRITE          = 2;

(* Interface to global memory manager *)
  GMEM_FIXED            = #0000;
  GMEM_MOVEABLE         = #0002;
  GMEM_NOCOMPACT        = #0010;
  GMEM_NODISCARD        = #0020;
  GMEM_ZEROINIT         = #0040;
  GMEM_MODIFY           = #0080;
  GMEM_DISCARDABLE      = #0F00;
  GHND                  = (GMEM_MOVEABLE OR GMEM_ZEROINIT);
  GPTR                  = (GMEM_FIXED    OR GMEM_ZEROINIT);
  GMEM_SHARE		= #2000;
  GMEM_DDESHARE 	= #2000;
  GMEM_LOWER		= #1000;
  GMEM_NOTIFY		= #4000;
  GMEM_NOT_BANKED	= #1000;


{ $IFDECL GlobalAlloc $THEN BEGIN }
  FUNCTION  GlobalAlloc (
    w_                      : WORD;
    d_                      : DWORD
  )                         : HANDLE;
{ $END }

{ $IFDECL GlobalCompact $THEN BEGIN }
  FUNCTION  GlobalCompact (
    d_                      : DWORD
  )                         : DWORD;
{ $END }

{ $IFDECL GlobalDiscard $THEN BEGIN }
  FUNCTION  GlobalDiscard (
    h_                      : HANDLE;
  )                         : HANDLE;
{ $END }

{ $IFDECL GlobalFree $THEN BEGIN }
  FUNCTION  GlobalFree (
    h_                      : HANDLE
  )                         : HANDLE;
{ $END }

{ $IFDECL GlobalHandle $THEN BEGIN }
  FUNCTION  GlobalHandle (
    w_                      : WORD
  )                         : DWORD;
{ $END }

{ $IFDECL GlobalLock $THEN BEGIN }
  FUNCTION  GlobalLock (
    h_                      : HANDLE
  )                         : LPSTR;
{ $END }

{ $IFDECL GlobalReAlloc $THEN BEGIN }
  FUNCTION  GlobalReAlloc (
    h_                      : HANDLE;
    d_                      : DWORD;
    w_                      : WORD
  )                         : HANDLE;
{ $END }

{ $IFDECL GlobalSize $THEN BEGIN }
  FUNCTION  GlobalSize (
    h_                      : HANDLE
  )                         : DWORD;
{ $END }

{ $IFDECL GlobalFlags $THEN BEGIN }
  FUNCTION  GlobalFlags (
    h_                      : HANDLE
  )                         : WORD;
{ $END }

{ $IFDECL GlobalWire $THEN BEGIN }
  FUNCTION  GlobalWire (
    h_                      : HANDLE
  )			    : LPSTR;
{ $END }

{ $IFDECL GlobalUnWire $THEN BEGIN }
  FUNCTION  GlobalUnWire (
    h_                      : HANDLE
  )			    : BOOL;
{ $END }

{ $IFDECL GlobalUnlock $THEN BEGIN }
  FUNCTION  GlobalUnlock (
    h_                      : HANDLE
  )			    : BOOL;
{ $END }

{ $IFDECL UnlockResource $THEN BEGIN }
  FUNCTION  UnlockResource ( h_ : HANDLE)  : BOOL;
    BEGIN
      UnlockResource := GlobalUnlock(h_)
    END;
{ $END }

{ $IFDECL GlobalLRUNewest $THEN BEGIN }
  FUNCTION  GlobalLRUNewest (
    h_                      : HANDLE
  )			    : HANDLE;
{ $END }

{ $IFDECL GlobalLRUOldest $THEN BEGIN }
  FUNCTION  GlobalLRUOldest (
    h_                      : HANDLE
  )			    : HANDLE;
{ $END }

{ $IFDECL GlobalNotify $THEN BEGIN }
  PROCEDURE  GlobalNotify (
    l_			    : LPSTR
  );
{ $END }

(* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) *)

CONST
  GMEM_DISCARDED        = #4000;
  GMEM_SWAPPED          = #8000;
  GMEM_LOCKCOUNT        = #00FF;

{ $IFDECL LockData $THEN BEGIN }
  FUNCTION  LockData (
    i_                      : int
  )                         : HANDLE;
{ $END }

{ $IFDECL UnlockData $THEN BEGIN }
  FUNCTION  UnlockData (
    i_                      : int
  )                         : HANDLE;
{ $END }


{ $IFDECL LockSegment $THEN BEGIN }
  FUNCTION  LockSegment (
    w_                      : WORD
  )                         : HANDLE;
{ $END }

{ $IFDECL UnlockSegment $THEN BEGIN }
  FUNCTION  UnlockSegment (
    w_                      : WORD
  )                         : HANDLE;
{ $END }

(* Interface to local memory manager *)


CONST
  LMEM_FIXED            = #0000;
  LMEM_MOVEABLE         = #0002;
  LMEM_NOCOMPACT        = #0010;
  LMEM_NODISCARD        = #0020;
  LMEM_ZEROINIT         = #0040;
  LMEM_MODIFY           = #0080;
  LMEM_DISCARDABLE      = #0F00;
  LHND                  = (LMEM_MOVEABLE OR LMEM_ZEROINIT);
  LPTR                  = (LMEM_FIXED    OR LMEM_ZEROINIT);
  NONZEROLHND           = (LMEM_MOVEABLE);
  NONZEROLPTR           = (LMEM_FIXED);

  LNOTIFY_OUTOFMEM      = 0;
  LNOTIFY_MOVE          = 1;
  LNOTIFY_DISCARD       = 2;


{ $IFDECL LocalAlloc $THEN BEGIN }
  FUNCTION  LocalAlloc (
    w_,x_                   : WORD
  )                         : HANDLE;
{ $END }

{ $IFDECL LocalCompact $THEN BEGIN }
  FUNCTION  LocalCompact (
    w_                      : WORD
  )                         : WORD;
{ $END }

{ $IFDECL LocalDiscard $THEN BEGIN }
  FUNCTION  LocalDiscard (
    h_                      : HANDLE
  )                         : HANDLE;
{ $END }

{ $IFDECL LocalFree $THEN BEGIN }
  FUNCTION  LocalFree (
    h_                      : HANDLE
  )                         : HANDLE;
{ $END }

{ $IFDECL LocalHandle $THEN BEGIN }
  FUNCTION  LocalHandle (
    w_                      : WORD
  )                         : HANDLE;
{ $END }

{ $IFDECL LocalFreeze $THEN BEGIN }
  PROCEDURE LocalFreeze (
    i_                      : int
  );
{ $END }

{ $IFDECL LocalHandleDelta $THEN BEGIN }
  FUNCTION  LocalHandleDelta (
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL LocalInit $THEN BEGIN }
  FUNCTION  LocalInit (
    w_			    : WORD;
    p_,q_		    : PSTR
  )                         : BOOL;
{ $END }

{ $IFDECL LocalLock $THEN BEGIN }
  FUNCTION  LocalLock (
    h_                      : HANDLE
  )                         : PSTR;
{ $END }

{ $IFDECL LocalMelt $THEN BEGIN }
  PROCEDURE LocalMelt (
    i_                      : int
  );
{ $END }

{ $IFDECL LocalNotify $THEN BEGIN }
  FUNCTION  LocalNotify (
    f_                      : FARPROC
  )                         : FARPROC;
{ $END }

{ $IFDECL LocalReAlloc $THEN BEGIN }
  FUNCTION  LocalReAlloc (
    h_                      : HANDLE;
    w_,x_                   : WORD
  )                         : HANDLE;
{ $END }

{ $IFDECL LocalSize $THEN BEGIN }
  FUNCTION  LocalSize (
    h_                      : HANDLE
  )                         : WORD;
{ $END }

{ $IFDECL LocalUnlock $THEN BEGIN }
  FUNCTION  LocalUnlock (
    h_                      : HANDLE
  )                         : BOOL;
{ $END }

{ $IFDECL LocalFlags $THEN BEGIN }
  FUNCTION  LocalFlags (
    h_                      : HANDLE
  )                         : WORD;
{ $END }

{ $IFDECL LocalShrink $THEN BEGIN }
  FUNCTION  LocalShrink (
    h_			    : HANDLE;
    w_			    : WORD
  )                         : WORD;
{ $END }

(* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) *)

CONST
  LMEM_DISCARDED        = #4000;
  LMEM_LOCKCOUNT        = #00FF;

(* SetSwapAreaSize really returns 2 words -
    lo word is Size actually set (or current size if you passed in 0)
    hi word is Max size you can get
*)

{ $IFDECL SetSwapAreaSize $THEN BEGIN }
  FUNCTION  SetSwapAreaSize (
    w_			    : WORD
  )			    : LONG;
{ $END }

{ $IFDECL ValidateFreeSpaces $THEN BEGIN }
  FUNCTION  ValidateFreeSpaces	 : LPSTR;
{ $END }

{ $IFDECL LimitEmsPages $THEN BEGIN }
  PROCEDURE  LimitEmsPages (
    w_			    : DWORD
  );
{ $END }

{ $IFDECL SetErrorMode $THEN BEGIN }
  FUNCTION  SetErrorMode (
    w_			    : WORD
  )			    : BOOL;
{ $END }


(* Interface to the resource manager *)


{ $IFDECL FindResource $THEN BEGIN }
  FUNCTION  FindResource (
    h_                      : HANDLE;
    l_,m_                   : LPSTR
  )                         : HANDLE;
{ $END }

{ $IFDECL LoadResource $THEN BEGIN }
  FUNCTION  LoadResource (
    h_,i_                   : HANDLE
  )                         : HANDLE;
{ $END }

{ $IFDECL FreeResource $THEN BEGIN }
  FUNCTION  FreeResource (
    h_                      : HANDLE
  )                         : BOOL;
{ $END }


{ $IFDECL LockResource $THEN BEGIN }
  FUNCTION  LockResource (
    h_                      : HANDLE
  )                         : LPSTR;
{ $END }


{ $IFDECL SetResourceHandler $THEN BEGIN }
  FUNCTION  SetResourceHandler (
    h_                      : HANDLE;
    l_                      : LPSTR;
    f_                      : FARPROC
  )                         : FARPROC;
{ $END }

{ $IFDECL AllocResource $THEN BEGIN }
  FUNCTION  AllocResource (
    h_,i_                   : HANDLE;
    d_                      : DWORD
  )                         : HANDLE;
{ $END }

{ $IFDECL SizeofResource $THEN BEGIN }
  FUNCTION  SizeofResource (
    h_,i_                   : HANDLE
  )                         : WORD;
{ $END }

{ $IFDECL AccessResource $THEN BEGIN }
  FUNCTION  AccessResource (
    h_,i_                   : HANDLE
  )                         : int;
{ $END }

{ $IFDECL MAKEINTRESOURCE $THEN BEGIN }
  FUNCTION  MAKEINTRESOURCE (
    i_                      : int
  )                         : LPSTR;
{ $END }

(* Predefined resource types *)
CONST
  RT_CURSOR             = RETYPE( LPSTR, BYLONG(0, 1) );
  RT_BITMAP             = RETYPE( LPSTR, BYLONG(0, 2) );
  RT_ICON               = RETYPE( LPSTR, BYLONG(0, 3) );
  RT_MENU               = RETYPE( LPSTR, BYLONG(0, 4) );
  RT_DIALOG             = RETYPE( LPSTR, BYLONG(0, 5) );
  RT_STRING             = RETYPE( LPSTR, BYLONG(0, 6) );
  RT_FONTDIR            = RETYPE( LPSTR, BYLONG(0, 7) );
  RT_FONT               = RETYPE( LPSTR, BYLONG(0, 8) );
  RT_ACCELERATOR        = RETYPE( LPSTR, BYLONG(0, 9) );
  RT_RCDATA		= RETYPE( LPSTR, BYLONG(0, 10) );

(* Interface to the task scheduler *)


{ $IFDECL Yield $THEN BEGIN }
  FUNCTION  Yield                         : BOOL;
{ $END }

{ $IFDECL GetCurrentTask $THEN BEGIN }
  FUNCTION  GetCurrentTask                         : HANDLE;
{ $END }

{ $IFDECL SetPriority $THEN BEGIN }
  FUNCTION  SetPriority (
    h_                      : HANDLE;
    i_                      : int
  )                         : int;
{ $END }

(* Interface to the atom manager *)


TYPE
  ATOM                      = WORD;


{ $IFDECL InitAtomTable $THEN BEGIN }
  FUNCTION  InitAtomTable (
    i_                      : int
  )                         : BOOL;
{ $END }


{ $IFDECL AddAtom $THEN BEGIN }
  FUNCTION  AddAtom (
    l_                      : LPSTR
  )                         : ATOM;
{ $END }

{ $IFDECL DeleteAtom $THEN BEGIN }
  FUNCTION  DeleteAtom (
    a_                      : ATOM
  )                         : ATOM;
{ $END }

{ $IFDECL FindAtom $THEN BEGIN }
  FUNCTION  FindAtom (
    l_                      : LPSTR
  )                         : ATOM;
{ $END }

{ $IFDECL GetAtomName $THEN BEGIN }
  FUNCTION  GetAtomName (
    a_                      : ATOM;
    l_                      : LPSTR;
    i_                      : int
  )                         : WORD;
{ $END }

{ $IFDECL GlobalAddAtom $THEN BEGIN }
  FUNCTION  GlobalAddAtom (
    l_			    : LPSTR
  )			    : ATOM;
{ $END }

{ $IFDECL GlobalDeleteAtom $THEN BEGIN }
  FUNCTION  GlobalDeleteAtom (
    a_                      : ATOM
  )			    : ATOM;
{ $END }

{ $IFDECL GlobalFindAtom $THEN BEGIN }
  FUNCTION  GlobalFindAtom (
    l_			    : LPSTR
  )			    : ATOM;
{ $END }

{ $IFDECL GlobalGetAtomName $THEN BEGIN }
  FUNCTION  GlobalGetAtomName (
    a_                      : ATOM;
    l_                      : LPSTR;
    i_                      : int
  )                         : WORD;
{ $END }

{ $IFDECL GetAtomHandle $THEN BEGIN }
  FUNCTION  GetAtomHandle (
    a_                      : ATOM
  )                         : HANDLE;
{ $END }

{ $IFDECL MAKEINTATOM $THEN BEGIN }
  FUNCTION  MAKEINTATOM (
    i_                      : int
  )                         : LPSTR;
{ $END }

(* Interface to the user profile *)

{ $IFDECL GetProfileInt $THEN BEGIN }
  FUNCTION  GetProfileInt (
    l_,m_                   : LPSTR;
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL GetProfileString $THEN BEGIN }
  FUNCTION  GetProfileString (
    l_,m_,n_,o_             : LPSTR;
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL WriteProfileString $THEN BEGIN }
  FUNCTION  WriteProfileString (
    l_,m_,n_                : LPSTR
  )                         : BOOL;
{ $END }

(* Interface to FatalExit procedure *)


{ $IFDECL FatalExit $THEN BEGIN }
  PROCEDURE FatalExit (
    i_                      : int
  );
{ $END }

(* Interface to Catch and Throw procedures *)


TYPE
  CATCHBUF                  = ARRAY [0..8] OF int;
  LPCATCHBUF                = ADS OF int;

{ $IFDECL Catch $THEN BEGIN }
  FUNCTION  Catch (
    l_                      : LPCATCHBUF
  )                         : int;
{ $END }

{ $IFDECL Throw $THEN BEGIN }
  PROCEDURE Throw (
    l_                      : LPCATCHBUF;
    i_                      : int
  );
{ $END }


{ $IFDECL CreateMetaFile $THEN BEGIN }
  FUNCTION  CreateMetaFile (
    l_                      : LPSTR
  )                         : HANDLE;
{ $END }

{ $IFDECL CloseMetaFile $THEN BEGIN }
  FUNCTION  CloseMetaFile (
    h_                      : HANDLE
  )                         : HANDLE;
{ $END }

{ $IFDECL GetMetaFileBits $THEN BEGIN }
  FUNCTION  GetMetaFileBits (
    h_                      : HANDLE
  )                         : HANDLE;
{ $END }

{ $IFDECL SetMetaFileBits $THEN BEGIN }
  FUNCTION  SetMetaFileBits (
    h_                      : HANDLE
  )                         : HANDLE;
{ $END }


{ $IFDECL GetCurrentTime $THEN BEGIN }
  FUNCTION  GetCurrentTime  : DWORD;
{ $END }

{ $IFDECL GetTickCount $THEN BEGIN }
  FUNCTION  GetTickCount    : DWORD;
{ $END }

{ $IFDECL GetTimerResolution $THEN BEGIN }
  FUNCTION  GetTimerResolution	  : DWORD;
{ $END }

{ $IFDECL IsChild $THEN BEGIN }
  FUNCTION  IsChild (
    h_,i_                   : HWND
  )                         : BOOL;
{ $END }


{ $IFDECL GetWindowWord $THEN BEGIN }
  FUNCTION  GetWindowWord (
    h_                      : HWND;
    i_                      : int
  )                         : WORD;
{ $END }

{ $IFDECL SetWindowWord $THEN BEGIN }
  FUNCTION  SetWindowWord (
    h_                      : HWND;
    i_                      : int;
    w_                      : WORD
  )                         : WORD;
{ $END }

{ $IFDECL GetWindowLong $THEN BEGIN }
  FUNCTION  GetWindowLong (
    h_                      : HWND;
    i_                      : int
  )                         : LONG;
{ $END }

{ $IFDECL SetWindowLong $THEN BEGIN }
  FUNCTION  SetWindowLong (
    h_                      : HWND;
    i_                      : int;
    l_                      : LONG
  )                         : LONG;
{ $END }

{ $IFDECL GetClassWord $THEN BEGIN }
  FUNCTION  GetClassWord (
    h_                      : HWND;
    i_                      : int
  )                         : WORD;
{ $END }

{ $IFDECL SetClassWord $THEN BEGIN }
  FUNCTION  SetClassWord (
    h_                      : HWND;
    i_                      : int;
    w_                      : WORD
  )                         : WORD;
{ $END }

{ $IFDECL GetClassLong $THEN BEGIN }
  FUNCTION  GetClassLong (
    h_                      : HWND;
    i_                      : int
  )                         : LONG;
{ $END }

{ $IFDECL SetClassLong $THEN BEGIN }
  FUNCTION  SetClassLong (
    h_                      : HWND;
    i_                      : int;
    l_                      : LONG
  )                         : LONG;
{ $END }


{ $IFDECL GetParent $THEN BEGIN }
  FUNCTION  GetParent (
    h_                      : HWND
  )                         : HWND;
{ $END }

{ $IFDECL SetParent $THEN BEGIN }
  FUNCTION  SetParent (
    h_,w_		    : HWND
  )                         : HWND;
{ $END }

{ $IFDECL EnumChildWindows $THEN BEGIN }
  FUNCTION  EnumChildWindows (
    h_                      : HWND;
    f_                      : FARPROC;
    l_                      : LONG
  )                         : BOOL;
{ $END }

{ $IFDECL FindWindow $THEN BEGIN }
  FUNCTION  FindWindow (
    l_,m_                   : LPSTR
  )                         : HWND;
{ $END }

{ $IFDECL EnumWindows $THEN BEGIN }
  FUNCTION  EnumWindows (
    f_                      : FARPROC;
    l_                      : LONG
  )                         : BOOL;
{ $END }

{ $IFDECL EnumTaskWindows $THEN BEGIN }
  FUNCTION  EnumTaskWindows (
    h_			    : HANDLE;
    f_                      : FARPROC;
    l_                      : LONG
  )                         : BOOL;
{ $END }

{ $IFDECL GetClassName $THEN BEGIN }
  FUNCTION  GetClassName (
    h_                      : HWND;
    l_                      : LPSTR;
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL GetTopWindow $THEN BEGIN }
  FUNCTION  GetTopWindow (
    h_			    : HWND
  )			    : HWND;
{ $END }

{ $IFDECL GetNextWindow $THEN BEGIN }
  FUNCTION  GetNextWindow (
    h_			    : HWND;
    W_			    : WORD
  )			    : HWND;
{ $END }

{ $IFDECL GetWindowTask $THEN BEGIN }
  FUNCTION  GetWindowTask (
    h_			    : HWND
  )			    : HANDLE;
{ $END }

(* GetWindow() and constants *)
{ $IFDECL GetWindow $THEN BEGIN }
  FUNCTION  GetWindow (
    h_			    : HWND;
    w_			    : WORD
  )			    : HWND;
{ $END }


{ $IFDECL SetWindowsHook $THEN BEGIN }
  FUNCTION  SetWindowsHook (
    i_                      : int;
    f_                      : FARPROC
  )                         : FARPROC;
{ $END }

{ $IFDECL UnhookWindowsHook $THEN BEGIN }
  FUNCTION  UnhookWindowsHook (
    i_                      : int;
    f_                      : FARPROC
  )			    : BOOL;
{ $END }

{ $IFDECL DefHookProc $THEN BEGIN }
  FUNCTION  DefHookProc (
    i_			    : int;
    w_			    : WORD;
    d_			    : DWORD;
    f_			    : ADS OF FARPROC
  )			    : DWORD;
{ $END }

(* Key conversion window *)

{ $IFDECL CreateConvertWindow $THEN BEGIN }
  FUNCTION  CreateConvertWindow (
    l_                      : LPSTR;
    h_                      : HANDLE;
    m_                      : LPSTR
  )                         : HWND;
{ $END }

{ $IFDECL ShowConvertWindow $THEN BEGIN }
  PROCEDURE ShowConvertWindow (
    h_                      : HWND;
    b_                      : BOOL
  );
{ $END }

{ $IFDECL SetConvertWindowHeight $THEN BEGIN }
  PROCEDURE SetConvertWindowHeight (
    i_                      : int
  );
{ $END }

{ $IFDECL IsTwoByteCharPrefix $THEN BEGIN }
  FUNCTION  IsTwoByteCharPrefix (
    i_                      : INTEGER1
  )                         : BOOL;
{ $END }

CONST
  GW_HWNDFIRST		    = 0;
  GW_HWNDLAST		    = 1;
  GW_HWNDNEXT		    = 2;
  GW_HWNDPREV		    = 3;
  GW_OWNER		    = 4;
  GW_CHILD		    = 5;

(* Menu flags for Add/Check/EnableMenuItem *)

  MF_CHANGE             = #0080;
  MF_INSERT             = #0000;
  MF_APPEND             = #0100;
  MF_DELETE             = #0200;
  MF_BYPOSITION         = #0400;
  MF_SEPARATOR          = #0800;
  MF_REMOVE		= #1000;
  MF_BYCOMMAND          = #0000;
  MF_GRAYED             = #0001;
  MF_DISABLED           = #0002;
  MF_ENABLED            = #0000;
  MF_CHECKED            = #0008;
  MF_UNCHECKED          = #0000;
  MF_BITMAP             = #0004;
  MF_STRING             = #0000;
  MF_POPUP              = #0010;
  MF_MENUBARBREAK       = #0020;
  MF_MENUBREAK          = #0040;
  MF_HILITE             = #0080;
  MF_UNHILITE           = #0000;
  MF_HELP		= #4000;
  MF_SYSMENU		= #2000;
  MF_MOUSESELECT	= #8000;


(* System Menu Command Values *)
  SC_SIZE               = #f000;
  SC_MOVE               = #f010;
  SC_MINIMIZE		= #f020;
  SC_MAXIMIZE		= #f030;
  SC_NEXTWINDOW         = #f040;
  SC_PREVWINDOW         = #f050;
  SC_CLOSE              = #f060;
  SC_VSCROLL            = #f070;
  SC_HSCROLL            = #f080;
  SC_MOUSEMENU          = #f090;
  SC_KEYMENU            = #f100;
  SC_ARRANGE		= #F110;
  SC_RESTORE		= #F120;
  SC_ICON		= SC_MINIMIZE;
  SC_ZOOM		= SC_MAXIMIZE;

(* Resource loading routines *)


{ $IFDECL LoadBitmap $THEN BEGIN }
  FUNCTION  LoadBitmap (
    h_                      : HANDLE;
    l_                      : LPSTR
  )                         : HBITMAP;
{ $END }


{ $IFDECL LoadCursor $THEN BEGIN }
  FUNCTION  LoadCursor (
    h_                      : HANDLE;
    l_                      : LPSTR
  )                         : HCURSOR;
{ $END }

(* Standard cursor IDs *)
CONST
  IDC_ARROW             = RETYPE( LPSTR, BYLONG(0,32512) );
  IDC_IBEAM             = RETYPE( LPSTR, BYLONG(0,32513) );
  IDC_WAIT              = RETYPE( LPSTR, BYLONG(0,32514) );
  IDC_CROSS             = RETYPE( LPSTR, BYLONG(0,32515) );
  IDC_UPARROW           = RETYPE( LPSTR, BYLONG(0,32516) );
  IDC_SIZE              = RETYPE( LPSTR, BYLONG(0,32640) );
  IDC_ICON              = RETYPE( LPSTR, BYLONG(0,32641) );
  IDC_SIZENWSE		= RETYPE( LPSTR, BYLONG(0,32642) );
  IDC_SIZENESW		= RETYPE( LPSTR, BYLONG(0,32643) );
  IDC_SIZEWE		= RETYPE( LPSTR, BYLONG(0,32644) );
  IDC_SIZENS		= RETYPE( LPSTR, BYLONG(0,32645) );



{ $IFDECL LoadIcon $THEN BEGIN }
  FUNCTION  LoadIcon (
    h_                      : HANDLE;
    l_                      : LPSTR
  )                         : HICON;
{ $END }

(* Standard icon IDs *)
CONST
  IDI_APPLICATION       = RETYPE( LPSTR, BYLONG(0,32512) );
  IDI_HAND              = RETYPE( LPSTR, BYLONG(0,32513) );
  IDI_QUESTION          = RETYPE( LPSTR, BYLONG(0,32514) );
  IDI_EXCLAMATION       = RETYPE( LPSTR, BYLONG(0,32515) );
  IDI_ASTERISK          = RETYPE( LPSTR, BYLONG(0,32516) );



{ $IFDECL LoadMenu $THEN BEGIN }
  FUNCTION  LoadMenu (
    h_                      : HANDLE;
    l_                      : LPSTR
  )                         : HMENU;
{ $END }

{ $IFDECL LoadMenuIndirect $THEN BEGIN }
  FUNCTION  LoadMenuIndirect (
    l_                      : LPSTR
  )                         : HMENU;
{ $END }

{ $IFDECL LoadString $THEN BEGIN }
  FUNCTION  LoadString (
    h_                      : HANDLE;
    w_                      : WORD;
    l_                      : LPSTR;
    i_                      : int
  )                         : int;
{ $END }


{ $IFDECL AddFontResource $THEN BEGIN }
  FUNCTION  AddFontResource (
    l_                      : LPSTR
  )                         : short;
{ $END }

{ $IFDECL RemoveFontResource $THEN BEGIN }
  FUNCTION  RemoveFontResource (
    l_                      : LPSTR
  )                         : BOOL;
{ $END }


CONST
  CP_HWND               = 0;
  CP_OPEN               = 1;
  CP_DIRECT		= 2;

(* VK from the keyboard driver *)
  VK_KANA		= #15;
  VK_ROMAJI		= #16;
  VK_ZENKAKU		= #17;
  VK_HIRAGANA		= #18;
  VK_KANJI		= #19;

(* VK to send to Applications *)
  VK_CONVERT		 = #1C;
  VK_NONCONVERT 	 = #1D;
  VK_ACCEPT		 = #1E;
  VK_MODECHANGE 	 = #1F;


(* Conversion function numbers *)
  KNJ_START		 = #01;
  KNJ_END		 = #02;
  KNJ_QUERY		 = #03;

  KNJ_LEARN_MODE	 = #10;
  KNJ_GETMODE		 = #11;
  KNJ_SETMODE		 = #12;

  KNJ_CODECONVERT	 = #20;
  KNJ_CONVERT		 = #21;
  KNJ_NEXT		 = #22;
  KNJ_PREVIOUS		 = #23;
  KNJ_ACCEPT		 = #24;

  KNJ_LEARN		 = #30;
  KNJ_REGISTER		 = #31;
  KNJ_REMOVE		 = #32;
  KNJ_CHANGE_UDIC	 = #33;

(* note: DEFAULT	= 0
	 JIS1		= 1
	 JIS2		= 2
	 SJIS2		= 3
	 JIS1KATAKANA	= 4
	 SJIS2HIRAGANA	= 5
	 SJIS2KATAKANA	= 6
	 OEM		= F
*)

  KNJ_JIS1toJIS1KATAKANA	 = #14;
  KNJ_JIS1toSJIS2		 = #13;
  KNJ_JIS1toSJIS2HIRAGANA	 = #15;
  KNJ_JIS1toSJIS2KATAKANA	 = #16;
  KNJ_JIS1toDEFAULT		 = #10;
  KNJ_JIS1toSJIS2OEM		 = #1F;
  KNJ_JIS2toSJIS2		 = #23;
  KNJ_SJIS2toJIS2		 = #32;

(* see KNJ_GETMODE for definition *)
  KNJ_MD_ALPHA			 = #01;
  KNJ_MD_HIRAGANA		 = #02;
  KNJ_MD_HALF			 = #04;
  KNJ_MD_JIS			 = #08;
  KNJ_MD_SPECIAL		 = #10;

(* conversion modes, low word of lParam when VK_CONVERT is sent to the app *)
  KNJ_CVT_NEXT			 = #01;
  KNJ_CVT_PREV			 = #02;
  KNJ_CVT_KATAKANA		 = #03;
  KNJ_CVT_HIRAGANA		 = #04;
  KNJ_CVT_JIS1			 = #05;
  KNJ_CVT_SJIS2 		 = #06;
  KNJ_CVT_DEFAULT		 = #07;
  KNJ_CVT_TYPED 		 = #08;

(* WM_YOMICHAR			  = #0108;
   WM_CONVERTREQUEST		  = #010A;
   WM_CONVERTRESULT		  = #010B;   Previously defined constants.
*)


TYPE
  KANJISTRUCT = RECORD
    fnc 		    : short;
    wParam		    : short;
    lpSource		    : LPSTR;
    lpdest		    : LPSTR;
    wCount		    : short;
    lpReserved1 	    : LPSTR;
    lpReserved2 	    : LPSTR;
  END;

  LPKANJISTRUCT             = ADS OF KANJISTRUCT;


{ $IFDECL MoveConvertWindow $THEN BEGIN }
  PROCEDURE MoveConvertWindow (
    s_,t_                   : short
  );
{ $END }

{ $IFDECL ConvertRequest $THEN BEGIN }
  FUNCTION ConvertRequest (
    h_                      : HWND;
    l_                      : LPKANJISTRUCT
  )			    : short;
{ $END }

{ $IFDECL SetConvertParams $THEN BEGIN }
  FUNCTION  SetConvertParams (
    s_,t_                   : short
  )                         : BOOL;
{ $END }

{ $IFDECL SetConvertHook $THEN BEGIN }
  PROCEDURE SetConvertHook (
    b_                      : BOOL
  );
{ $END }

(* Conventional dialog box and message box command IDs *)

CONST
  IDOK                  = 1;
  IDCANCEL              = 2;
  IDABORT               = 3;
  IDRETRY               = 4;
  IDIGNORE              = 5;
  IDYES                 = 6;
  IDNO                  = 7;


(* Control manager structures & definitions *)
(* Edit control class stuff *)

(* styles *)
  ES_LEFT               = BYLONG(0,0);
  ES_CENTER             = BYLONG(0,1);
  ES_RIGHT              = BYLONG(0,2);
  ES_MULTILINE          = BYLONG(0,4);
  ES_AUTOVSCROLL        = BYLONG(0,64);
  ES_AUTOHSCROLL        = BYLONG(0,128);
  ES_NOHIDESEL          = BYLONG(0,256);

(* notification codes *)
  EN_SETFOCUS_          = #0100;
  EN_KILLFOCUS_         = #0200;
  EN_CHANGE             = #0300;
  EN_UPDATE		= #0400;
  EN_ERRSPACE           = #0500;
  EN_HSCROLL            = #0601;
  EN_VSCROLL            = #0602;

(* control messages: *)
  EM_GETSEL             = WM_USER+0;
  EM_SETSEL             = WM_USER+1;
  EM_GETRECT            = WM_USER+2;
  EM_SETRECT            = WM_USER+3;
  EM_SETRECTNP          = WM_USER+4;
  EM_SCROLL             = WM_USER+5;
  EM_LINESCROLL         = WM_USER+6;
  EM_GETMODIFY          = WM_USER+8;
  EM_SETMODIFY          = WM_USER+9;
  EM_GETLINECOUNT       = WM_USER+10;
  EM_LINEINDEX          = WM_USER+11;
  EM_SETHANDLE          = WM_USER+12;
  EM_GETHANDLE          = WM_USER+13;
  EM_GETTHUMB           = WM_USER+14;
  EM_LINELENGTH         = WM_USER+17;
  EM_REPLACESEL         = WM_USER+18;
  EM_SETFONT            = WM_USER+19;
  EM_GETLINE            = WM_USER+20;
  EM_LIMITTEXT          = WM_USER+21;
  EM_CANUNDO            = WM_USER+22;
  EM_UNDO               = WM_USER+23;
  EM_FMTLINES           = WM_USER+24;
  EM_LINEFROMCHAR	= WM_USER+25;
  EM_SETWORDBREAK	= WM_USER+26;

(* button control styles *)
  BS_PUSHBUTTON         = BYLONG(0,0);
  BS_DEFPUSHBUTTON      = BYLONG(0,1);
  BS_CHECKBOX           = BYLONG(0,2);
  BS_AUTOCHECKBOX       = BYLONG(0,3);
  BS_RADIOBUTTON        = BYLONG(0,4);
  BS_3STATE             = BYLONG(0,5);
  BS_AUTO3STATE         = BYLONG(0,6);
  BS_GROUPBOX           = BYLONG(0,7);
  BS_USERBUTTON         = BYLONG(0,8);
  BS_AUTORADIOBUTTON	= BYLONG(0,9);
  BS_PUSHBOX		= BYLONG(0,10);
  BS_LEFTTEXT		= BYLONG(0,20);

(* user button notification codes *)
  BN_CLICKED            = 0;
  BN_PAINT              = 1;
  BN_HILITE             = 2;
  BN_UNHILITE           = 3;
  BN_DISABLE            = 4;
  BN_DOUBLECLICKED	= 5;

(* control messages *)
  BM_GETCHECK           = WM_USER+0;
  BM_SETCHECK           = WM_USER+1;
  BM_GETSTATE           = WM_USER+2;
  BM_SETSTATE           = WM_USER+3;
  BM_SETSTYLE		= WM_USER+4;

(* Static control constants *)

  SS_LEFT               = BYLONG(0,0);
  SS_CENTER             = BYLONG(0,1);
  SS_RIGHT              = BYLONG(0,2);
  SS_ICON               = BYLONG(0,3);
  SS_BLACKRECT          = BYLONG(0,4);
  SS_GRAYRECT           = BYLONG(0,5);
  SS_WHITERECT          = BYLONG(0,6);
  SS_BLACKFRAME         = BYLONG(0,7);
  SS_GRAYFRAME          = BYLONG(0,8);
  SS_WHITEFRAME         = BYLONG(0,9);
  SS_USERITEM           = BYLONG(0,10);
  SS_SIMPLE		= BYLONG(0,11);
  SS_NOPREFIX		= BYLONG(0,128);
		      (* 0x80 - don't do "&" character translation *)

(* Dialog manager routines *)


{ $IFDECL IsDialogMessage $THEN BEGIN }
  FUNCTION  IsDialogMessage (
    h_                      : HWND;
    l_                      : LPMSG
  )                         : BOOL;
{ $END }


{ $IFDECL MapDialogRect $THEN BEGIN }
  PROCEDURE MapDialogRect (
    h_                      : HWND;
    l_                      : LPRECT
  );
{ $END }


{ $IFDECL DlgDirList $THEN BEGIN }
  FUNCTION  DlgDirList (
    h_                      : HWND;
    l_                      : LPSTR;
    i_,j_                   : int;
    w_                      : WORD
  )                         : int;
{ $END }

{ $IFDECL DlgDirSelect $THEN BEGIN }
  FUNCTION  DlgDirSelect (
    h_                      : HWND;
    l_                      : LPSTR;
    i_                      : int
  )                         : BOOL;
{ $END }

(* Dialog style bits *)

CONST
  DS_ABSALIGN           = #000000001;
  DS_SYSMODAL           = #000000002;
  DS_LOCALEDIT		= #000000020; (* Edit items get Local storage. *)

  DM_GETDEFID		= WM_USER+0;
  DM_SETDEFID		= WM_USER+1;
  DC_HASDEFID		= #534B;

(*  Dialog codes (returned by WM_GETDLGCODE message) *)

  DLGC_WANTARROWS	= #0001; (* control wants arrow keys *)
  DLGC_WANTTAB		= #0002; (* control wants tab keys *)
  DLGC_WANTALLKEYS	= #0004; (* control wants all keys *)
  DLGC_HASSETSEL	= #0008; (* understands EM_SETSEL message *)
  DLGC_WANTMESSAGE	= #0004;    (* pass message to control *)
  DLGC_DEFPUSHBUTTON	= #0010;    (* Default pushbutton     *)
  DLGC_UNDEFPUSHBUTTON	= #0020;    (* Non-default pushbutton *)
  DLGC_RADIOBUTTON	= #0040;    (* radio button	      *)
  DLGC_WANTCHARS	= #0080;    (* Want WM_CHAR messages  *)
  DLGC_STATIC		= #0100;   (* Static item: don't include *)
  DLGC_BUTTON		= #2000;  (* Button item: can be checked *)

  LB_CTLCODE            = BYLONG(0,0);

(* Listbox control return values *)
  LB_OKAY               = 0;
  LB_ERR                = -1;
  LB_ERRSPACE           = -2;

(* listbox notification codes *)
  LBN_ERRSPACE          = -2;
  LBN_SELCHANGE         = 1;
  LBN_DBLCLK            = 2;

(* listbox messages *)
  LB_ADDSTRING          = 1+WM_USER;
  LB_INSERTSTRING       = 2+WM_USER;
  LB_DELETESTRING       = 3+WM_USER;
  LB_REPLACESTRING      = 4+WM_USER;
  LB_RESETCONTENT       = 5+WM_USER;
  LB_SETSEL             = 6+WM_USER;
  LB_SETCURSEL          = 7+WM_USER;
  LB_GETSEL             = 8+WM_USER;
  LB_GETCURSEL          = 9+WM_USER;
  LB_GETTEXT            = 10+WM_USER;
  LB_GETTEXTLEN         = 11+WM_USER;
  LB_GETCOUNT           = 12+WM_USER;
  LB_SELECTSTRING       = 13+WM_USER;
  LB_DIR                = 14+WM_USER;
  LB_GETTOPINDEX	= 15+WM_USER;
  LB_MSGMAX		= 16+WM_USER;

(* listbox style bits *)
  LBS_NOTIFY            = #00000001;
  LBS_SORT              = #00000002;
  LBS_NOREDRAW          = #00000004;
  LBS_MULTIPLESEL       = #00000008;
  LBS_STANDARD          = #00A00003; (*LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER *)


(* scroll bar styles *)
  SBS_HORZ              = #00000000;
  SBS_VERT              = #00000001;
  SBS_TOPALIGN          = #00000002;
  SBS_LEFTALIGN         = #00000002;
  SBS_BOTTOMALIGN       = #00000004;
  SBS_RIGHTALIGN        = #00000004;
  SBS_SIZEBOXTOPLEFTALIGN = #00000002;
  SBS_SIZEBOXBOTTOMRIGHTALIGN = #00000004;
  SBS_SIZEBOX                 = #00000008;


{ $IFDECL OpenSound $THEN BEGIN }
  FUNCTION  OpenSound                         : int;
{ $END }

{ $IFDECL CloseSound $THEN BEGIN }
  FUNCTION  CloseSound                         : int;
{ $END }

{ $IFDECL SetVoiceQueueSize $THEN BEGIN }
  FUNCTION  SetVoiceQueueSize (
    i_,j_                   : int
  )                         : int;
{ $END }

{ $IFDECL SetVoiceNote $THEN BEGIN }
  FUNCTION  SetVoiceNote (
    i_,j_,k_,l_             : int
  )                         : int;
{ $END }

{ $IFDECL SetVoiceAccent $THEN BEGIN }
  FUNCTION  SetVoiceAccent (
    i_,j_,k_,l_,m_          : int
  )                         : int;
{ $END }

{ $IFDECL SetVoiceEnvelope $THEN BEGIN }
  FUNCTION  SetVoiceEnvelope (
    i_,j_,k_                : int
  )                         : int;
{ $END }

{ $IFDECL SetSoundNoise $THEN BEGIN }
  FUNCTION  SetSoundNoise (
    i_,j_                   : int
  )                         : int;
{ $END }

{ $IFDECL SetVoiceSound $THEN BEGIN }
  FUNCTION  SetVoiceSound (
    i_,j_,k_                : int
  )                         : int;
{ $END }

{ $IFDECL StartSound $THEN BEGIN }
  FUNCTION  StartSound                         : int;
{ $END }

{ $IFDECL StopSound $THEN BEGIN }
  FUNCTION  StopSound                         : int;
{ $END }

{ $IFDECL WaitSoundState $THEN BEGIN }
  FUNCTION  WaitSoundState (
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL SyncAllVoices $THEN BEGIN }
  FUNCTION  SyncAllVoices                         : int;
{ $END }

{ $IFDECL CountVoiceNotes $THEN BEGIN }
  FUNCTION  CountVoiceNotes (
    i_                      : int
  )                         : int;
{ $END }

{ $IFDECL GetThresholdEvent $THEN BEGIN }
  FUNCTION  GetThresholdEvent                         : LPINT;
{ $END }

{ $IFDECL GetThresholdStatus $THEN BEGIN }
  FUNCTION  GetThresholdStatus                         : int;
{ $END }

{ $IFDECL SetVoiceThreshold $THEN BEGIN }
  FUNCTION  SetVoiceThreshold (
    i_,j_                   : int
  )                         : int;
{ $END }

(* constants used to specify return condition for WaitSoundState *)


CONST
  QUEUEEMPTY                  = 0;
  THRESHOLD                   = 1;
  ALLTHRESHOLD                = 2;

(* constants used to specify accent mode *)

  S_NORMAL                    = 0;
  S_LEGATO                    = 1;
  S_STACCATO                  = 2;

(* constants used to specify source in SetSoundNoise *)
  S_PERIOD512                 = 0   (* freq = N/512 high pitch, less coarse hiss *);
  S_PERIOD1024                = 1   (* freq = N/1024 *);
  S_PERIOD2048                = 2   (* freq = N/2048 low pitch, more coarse hiss *);
  S_PERIODVOICE               = 3   (* source is frequency from voice channel (3) *);

  S_WHITE512                  = 4   (* freq = N/512 high pitch, less coarse hiss *);
  S_WHITE1024                 = 5   (* freq = N/1024 *);
  S_WHITE2048                 = 6   (* freq = N/2048 low pitch, more coarse hiss *);
  S_WHITEVOICE                = 7   (* source is frequency from voice channel (3) *);

  S_SERDVNA                   = -1      (* device not available *);
  S_SEROFM                    = -2      (* out of memory *);
  S_SERMACT                   = -3      (* music active *);
  S_SERQFUL                   = -4      (* queue full *);
  S_SERBDNT                   = -5      (* invalid note *);
  S_SERDLN                    = -6      (* invalid note length *);
  S_SERDCC                    = -7      (* invalid note count *);
  S_SERDTP                    = -8      (* invalid tempo *);
  S_SERDVL                    = -9      (* invalid volume *);
  S_SERDMD                    = -10     (* invalid mode *);
  S_SERDSH                    = -11     (* invalid shape *);
  S_SERDPT                    = -12     (* invalid pitch *);
  S_SERDFQ                    = -13     (* invalid frequency *);
  S_SERDDR                    = -14     (* invalid duration *);
  S_SERDSR                    = -15     (* invalid source *);
  S_SERDST                    = -16     (* invalid state *);



(*************************************************************************
**
** dcb field definitions.
**
*************************************************************************)

  NOPARITY                    = 0;
  ODDPARITY                   = 1;
  EVENPARITY                  = 2;
  MARKPARITY                  = 3;
  SPACEPARITY                 = 4;

  ONESTOPBIT                  = 0;
  ONE5STOPBITS                = 1;
  TWOSTOPBITS                 = 2;

  IGNORE                      = 0               (* Ignore signal                *);
  INFINITE                    = #ffff          (* Infinite timeout             *);



(*************************************************************************
**
** Comm Device Driver Error Bits.
**
*************************************************************************)

  CE_RXOVER                   = #0001          (* Receive Queue overflow       *);
  CE_OVERRUN                  = #0002          (* Receive Overrun Error        *);
  CE_RXPARITY                 = #0004          (* Receive Parity Error         *);
  CE_FRAME                    = #0008          (* Receive Framing error        *);
  CE_BREAK                    = #0010          (* Break Detected               *);
  CE_CTSTO                    = #0020          (* CTS Timeout                  *);
  CE_DSRTO                    = #0040          (* DSR Timeout                  *);
  CE_RLSDTO                   = #0080          (* RLSD Timeout                 *);
  CE_TXFULL                   = #0100          (* TX QUEUE IS FULL             *);
  CE_PTO                      = #0200          (* LPTx Timeout                 *);
  CE_IOE                      = #0400          (* LPTx I/O Error               *);
  CE_DNS                      = #0800          (* LPTx Device not selected     *);
  CE_OOP                      = #1000          (* LPTx Out-Of-Paper            *);
  CE_MODE                     = #8000          (* Requested mode unsupported   *);


(*************************************************************************
**
** Initialization Error Codes
**
*************************************************************************)

  IE_BADID                    = -1              (* Invalid or unsupported id    *);
  IE_OPEN                     = -2              (* Device Already Open          *);
  IE_NOPEN                    = -3              (* Device Not Open              *);
  IE_MEMORY                   = -4              (* Unable to allocate queues    *);
  IE_DEFAULT                  = -5              (* Error in default parameters  *);
  IE_HARDWARE                 = -10             (* Hardware Not Present         *);
  IE_BYTESIZE                 = -11             (* Illegal Byte Size            *);
  IE_BAUDRATE                 = -12             (* Unsupported BaudRate         *);


(*************************************************************************
**
** Event Definitions
**
*************************************************************************)

  EV_RXCHAR                   = #0001          (* Any Character received       *);
  EV_RXFLAG                   = #0002          (* Received certain INTEGER1acter   *);
  EV_TXEMPTY                  = #0004          (* Transmitt Queue Empty        *);
  EV_CTS                      = #0008          (* CTS changed state            *);
  EV_DSR                      = #0010          (* DSR changed state            *);
  EV_RLSD                     = #0020          (* RLSD changed state           *);
  EV_BREAK                    = #0040          (* BREAK received               *);
  EV_ERR                      = #0080          (* Line status error occurred   *);
  EV_RING                     = #0100          (* Ring signal detected         *);
  EV_PERR                     = #0200          (* Printer error occured        *);


(*************************************************************************
**
** Escape Functions
**
*************************************************************************)

  SETXOFF                     = 1               (* Simulate XOFF received       *);
  SETXON                      = 2               (* Simulate XON received        *);
  SETRTS                      = 3               (* Set RTS high                 *);
  CLRRTS                      = 4               (* Set RTS low                  *);
  SETDTR                      = 5               (* Set DTR high                 *);
  CLRDTR                      = 6               (* Set DTR low                  *);
  RESETDEV                    = 7               (* Reset device if possible     *);


(*************************************************************************
**
** Device Descriptor Block Definition
**
*************************************************************************)

  LPTx                        = #80             (* Set if ID is for LPT device  *);

  (* Bitfield locators for 'bitField1' in DCB record type *)
  fBinary                     = 1;
  fRtsDisable                 = 2;
  fParity                     = 4;
  fOutxCtsFlow                = 8;
  fOutxDsrFlow                = 16;
  fDtrDisable                 = 128;

  (* Bitfield locators for 'bitField2' in DCB record type *)
  fOutX                       = 1;
  fInX                        = 2;
  fPeChar                     = 4;
  fNull                       = 8;
  fChEvt                      = 16;
  fDtrflow                    = 32;
  fRtsflow                    = 64;

TYPE
  DCB = RECORD
    Id                      : BYTE; (* Internal Device ID           *)
    BaudRate                : WORD; (* Baudrate at which runing     *)
    ByteSize                : BYTE; (* Number of bits/byte, 4-8     *)
    Parity                  : BYTE; (* 0-4=None,Odd,Even,Mark,Space *)
    StopBits                : BYTE; (* 0,1,2 = 1, 1.5, 2            *)
    RlsTimeout              : WORD; (* Timeout for RLSD to be set   *)
    CtsTimeout              : WORD; (* Timeout for CTS to be set    *)
    DsrTimeout              : WORD; (* Timeout for DSR to be set    *)

    bitField1               : BYTE;
        (* Packed bits.  Access with constants defined above.
         * BYTE fBinary: 1;         - Binary Mode (skip EOF check)
         * BYTE fRtsDisable:1;      - Don't assert RTS at init time
         * BYTE fParity: 1;         - Enable parity checking
         * BYTE fOutxCtsFlow:1;     - CTS handshaking on output
         * BYTE fOutxDsrFlow:1;     - DSR handshaking on output
         * BYTE fDummy: 2;          - Reserved
         * BYTE fDtrDisable:1;      - Don't assert DTR at init time
         *)
    bitField2               : BYTE;
        (* Packed bits.  Access with constants defined above.
         * BYTE fOutX: 1;           - Enable output X-ON/X-OFF
         * BYTE fInX: 1;            - Enable input X-ON/X-OFF
         * BYTE fPeChar: 1;         - Enable Parity Err Replacement
         * BYTE fNull: 1;           - Enable Null stripping
         * BYTE fChEvt: 1;          - Enable Rx INTEGER1acter event.
         * BYTE fDtrflow: 1;        - DTR handshake on input
         * BYTE fRtsflow: 1;        - RTS handshake on input
         * BYTE fDummy2: 1; }
         *)
    XonChar                 : INTEGER1; (* Tx and Rx X-ON INTEGER1acter     *)
    XoffChar                : INTEGER1; (* Tx and Rx X-OFF INTEGER1acter    *)
    XonLim                  : WORD; (* Transmit X-ON threshold      *)
    XoffLim                 : WORD; (* Transmit X-OFF threshold     *)
    PeChar                  : INTEGER1; (* Parity error replacement INTEGER1*)
    EofChar                 : INTEGER1; (* End of Input INTEGER1acter       *)
    EvtChar                 : INTEGER1; (* Recieved Event INTEGER1acter     *)
    TxDelay                 : WORD; (* Amount of time between INTEGER1s *)
  END;
  LPDCB = ADS OF DCB;


(*************************************************************************
**
** Status record returned by GetCommError
**
*************************************************************************)

CONST
  fCtsHold      = 1;
  fDsrHold      = 2;
  fRlsdHold     = 4;
  fXoffHold     = 8;
  fXoffSent     = 16;
  fEof          = 32;
  fTxim         = 64;

TYPE
  COMSTAT = RECORD
    bitField                : BYTE;
        (* Packed bits.  Access with constants defined above.
         * BYTE fCtsHold: 1;        - Transmit is on CTS hold
         * BYTE fDsrHold: 1;        - Transmit is on DSR hold
         * BYTE fRlsdHold: 1;       - Transmit is on RLSD hold
         * BYTE fXoffHold: 1;       - Received handshake
         * BYTE fXoffSent: 1;       - Issued handshake
         * BYTE fEof: 1;            - End of file INTEGER1acter found
         * BYTE fTxim: 1;           - Character being transmitted
         *)
    cbInQue                 : WORD; (* count of characters in Rx Que*)
    cbOutQue                : WORD; (* count of characters in Tx Que*)
  END;
  LPCOMSTAT = ADS OF COMSTAT;

{ $IFDECL OpenComm $THEN BEGIN }
  FUNCTION  OpenComm (
    l_               : LPSTR;
    w_,x_            : WORD
  )                  : short;
{ $END }

{ $IFDECL SetCommState $THEN BEGIN }
  FUNCTION  SetCommState (
    d_               : LPDCB
  )                  : short;
{ $END }

{ $IFDECL GetCommState $THEN BEGIN }
  FUNCTION  GetCommState (
    s_               : short;
    d_               : LPDCB
  )                  : short;
{ $END }

{ $IFDECL ReadComm $THEN BEGIN }
  FUNCTION  ReadComm (
    s_               : short;
    l_               : LPSTR;
    i_               : int
  )                  : short;
{ $END }

{ $IFDECL UngetCommChar $THEN BEGIN }
  FUNCTION  UngetCommChar (
    s_               : short;
    i_               : INTEGER1
  )                  : short;
{ $END }

{ $IFDECL WriteComm $THEN BEGIN }
  FUNCTION  WriteComm (
    s_               : short;
    l_               : LPSTR;
    i_               : int
  )                  : short;
{ $END }

{ $IFDECL CloseComm $THEN BEGIN }
  FUNCTION  CloseComm (
    s_               : short
  )                  : short;
{ $END }

{ $IFDECL GetCommError $THEN BEGIN }
  FUNCTION  GetCommError (
    s_               : short;
    c_               : LPCOMSTAT
  )                  : short;
{ $END }

{ $IFDECL BuildCommDCB $THEN BEGIN }
  FUNCTION  BuildCommDCB (
    l_               : LPSTR;
    d_               : LPDCB
  )                  : short;
{ $END }

{ $IFDECL TransmitCommChar $THEN BEGIN }
  FUNCTION  TransmitCommChar (
    s_               : short;
    i_               : INTEGER1
  )                  : short;
{ $END }

{ $IFDECL SetCommEventMask $THEN BEGIN }
  FUNCTION  SetCommEventMask (
    s_               : short;
    w_               : WORD
  )                  : LPWORD;
{ $END }

{ $IFDECL GetCommEventMask $THEN BEGIN }
  FUNCTION  GetCommEventMask (
    s_               : short;
    i_               : int
  )                  : WORD;
{ $END }

{ $IFDECL SetCommBreak $THEN BEGIN }
  FUNCTION  SetCommBreak (
    s_               : short
  )                  : short;
{ $END }

{ $IFDECL ClearCommBreak $THEN BEGIN }
  FUNCTION  ClearCommBreak (
    s_               : short
  )                  : short;
{ $END }

{ $IFDECL FlushComm $THEN BEGIN }
  FUNCTION  FlushComm (
    s_               : short;
    i_               : int
  )                  : short;
{ $END }

{ $IFDECL EscapeCommFunction $THEN BEGIN }
  FUNCTION  EscapeCommFunction (
    s_               : short;
    i_               : int
  )                  : short;
{ $END }
END;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\prd.inc ===
NAME_LEN    equ 32
BLOCK_SIZE  equ 512
DEV_PRD     equ 8888h
DEV_PORT    equ 8888h
DEV_LAND    equ 8889h

HSIZE       equ 8d              ;HorzSize
VSIZE       equ 11d             ;VertSize
VSIZE_LEGAL equ 14d             ;VertSize

MM_HSIZE    equ 203             ;Horizontal size in millimeter
MM_HSIZE0   equ 2032
MM_HSIZE00  equ 20320
MM_VSIZE    equ 279             ;Vertical size in millimeter
MM_VSIZE0   equ 2794
MM_VSIZE00  equ 27940
MM_VSIZE_LEGAL      equ 356             ;Vertical size in millimeter
MM_VSIZE0_LEGAL     equ 3556
MM_VSIZE00_LEGAL    equ 35560

EnglishLo1  equ 800             ;HorzSize * 1000 scaled (/254)
EnglishLo2  equ 1100            ;VertSize * 1000 scaled (/254)

EnglishHi1  equ  8000           ;HorzSize * 10000 scaled (/254)
EnglishHi2  equ  11000          ;VertSize * 10000 scaled (/254)
EnglishHi3  equ  EnglishLo3
EnglishHi4  equ  EnglishLo4

Twips1      equ  11520          ;HorzSize * 14400 scaled (/254)
Twips2      equ  15840          ;VertSize * 14400 scaled (/254)
Twips3      equ  EnglishLo3
Twips4      equ  EnglishLo4

EnglishLo2_LEGAL equ 1400
EnglishHi2_LEGAL  equ  14000          ;VertSize * 10000 scaled (/254)
EnglishHi4_LEGAL  equ  EnglishLo4_LEGAL

Twips2_LEGAL equ  20160
Twips4_LEGAL equ  EnglishLo4_LEGAL

yMinorDist   =  Hypotenuse-xMajorDist
xMinorDist   =  Hypotenuse-yMajorDist

MaxStyleErr  =  Hypotenuse*2    ;Max error before updating
                                ;rotating bit mask

DEVICE  struc
    deType      dw      0       ;
    deMode      dw      0       ;
    deJob       dw      0       ;job number
    deWheel     dw      0       ;font wheel number
    dePtr       dw      0       ;spooler buffer pointer
    deYPQ       dw      0
    deXPQ       dw      0
    deCurx      dw      0
    deCury      dw      0
    deXcurwidth dw      0
    deYcurwidth dw      0
    deDoc       dw      0       ;job spooled as a document or by the page
    deHeap      dw      0
    deHPsize    dw      0
    deHPptr     dw      0
    dePhySize   dd      0
DEVICE  ends

BUFFER      struc
  dePort        db      NAME_LEN     dup (?); port name
  deSpool       db      BLOCK_SIZE   dup (?)
BUFFER      ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\rom.inc ===
; ROM Windows specific include file

;
;   INT 2F subfunction
;	if ROM installed, returns 0 in AX and RM segment of ROMTOC in
;	BX.  Hooked by WIN.COM to pass ROMTOC to other components
;
ROMINSTALLCHECK     equ 160Ch

; ROM Table of Contents structure

ROMTOC	STRUC
ROMSignature	db	55h, 0AAh	; IBM standard ROM signature
ROMLength	db	?		; IBM length (/512)
ROMEntryPoint	db	5 dup (?)	; jmp near + retf + pad
szID		db	10 dup (?)	; ID string "ROMWINTOC\0"
DOSX_CSIP	dd	?		; DOSX initial CS:IP   (seg:off)
KRNL_CSIP	dd	?		; Kernel initial CS:IP (sel:off)
lmaROMLDT	dd	?		; lma of ROM prototype LDT
cROMsels	dw	?		; # descriptors used in ROM proto LDT
FirstROMsel	dw	?		; first LDT selector in ROM proto LDT
offSysDir	dw	?		; offset to system directory string
lmaHigh		dd	?		; lma of high ROM
lenHigh		dd	?		; length in bytes of High ROM
cModules	dw	?		; # modules defined in ROM TOC
cFiles		dw	?		; # files defined in ROM TOC
ModEntries	db	?		; start of module entries

; module entries follow at this point...
; file entries start at ModEntries + cModules*(SIZE MODENT)

ROMTOC	ENDS


; Module entry format in ROM TOC

File_Name_Len	=	13
Module_Name_Len =	9

MODENT	STRUC
ModNameStr	db	Module_Name_Len dup (?) ; Module name (null padded)
FileNameStr	db	File_Name_Len	dup (?) ; File name (null padded)
lmaExeHdr	dd	?			; lma of module EXE header
MODENT	ENDS

FILENT STRUC
fname		db	File_Name_Len dup(?)	; file name
lma		dd	?			; lma of start of file
fsize		dd	?
FILENT ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\prsht.h ===
/*****************************************************************************\
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1996, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _PRSHT_H_
#define _PRSHT_H_

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#endif
#endif // DUMMYUNIONNAME

#ifdef __cplusplus
extern "C" {
#endif


#ifndef SNDMSG
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif
#endif // ifndef SNDMSG

#define MAXPROPPAGES            100

struct _PSP;
typedef struct _PSP FAR* HPROPSHEETPAGE;

#ifndef MIDL_PASS
struct _PROPSHEETPAGEA;
struct _PROPSHEETPAGEW;
#endif

typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEA FAR *ppsp);
typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKW)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEW FAR *ppsp);

#ifdef UNICODE
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKW
#else
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKA
#endif

#define PSP_DEFAULT             0x0000
#define PSP_DLGINDIRECT         0x0001
#define PSP_USEHICON            0x0002
#define PSP_USEICONID           0x0004
#define PSP_USETITLE            0x0008
#define PSP_RTLREADING          0x0010

#define PSP_HASHELP             0x0020
#define PSP_USEREFPARENT        0x0040
#define PSP_USECALLBACK         0x0080


#define PSPCB_RELEASE           1
#define PSPCB_CREATE            2


typedef struct _PROPSHEETPAGEA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        } DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        } DUMMYUNIONNAME2;
        LPCSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKA pfnCallback;
        UINT FAR * pcRefParent;
} PROPSHEETPAGEA, FAR *LPPROPSHEETPAGEA;
typedef const PROPSHEETPAGEA FAR *LPCPROPSHEETPAGEA;

typedef struct _PROPSHEETPAGEW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCWSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        }DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCWSTR      pszIcon;
        }DUMMYUNIONNAME2;
        LPCWSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT FAR * pcRefParent;
} PROPSHEETPAGEW, FAR *LPPROPSHEETPAGEW;
typedef const PROPSHEETPAGEW FAR *LPCPROPSHEETPAGEW;

#ifdef UNICODE
#define PROPSHEETPAGE           PROPSHEETPAGEW
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEW
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEW
#else
#define PROPSHEETPAGE           PROPSHEETPAGEA
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEA
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEA
#endif


#define PSH_DEFAULT             0x0000
#define PSH_PROPTITLE           0x0001
#define PSH_USEHICON            0x0002
#define PSH_USEICONID           0x0004
#define PSH_PROPSHEETPAGE       0x0008
#define PSH_WIZARD              0x0020
#define PSH_USEPSTARTPAGE       0x0040
#define PSH_NOAPPLYNOW          0x0080
#define PSH_USECALLBACK         0x0100
#define PSH_HASHELP             0x0200
#define PSH_MODELESS            0x0400
#define PSH_RTLREADING          0x0800

typedef int (CALLBACK *PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM);

typedef struct _PROPSHEETHEADERA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        }DUMMYUNIONNAME;
        LPCSTR          pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCSTR      pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEA ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERA, FAR *LPPROPSHEETHEADERA;
typedef const PROPSHEETHEADERA FAR *LPCPROPSHEETHEADERA;

typedef struct _PROPSHEETHEADERW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCWSTR     pszIcon;
        }DUMMYUNIONNAME;
        LPCWSTR         pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCWSTR     pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEW ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERW, FAR *LPPROPSHEETHEADERW;
typedef const PROPSHEETHEADERW FAR *LPCPROPSHEETHEADERW;

#ifdef UNICODE
#define PROPSHEETHEADER         PROPSHEETHEADERW
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERW
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERW
#else
#define PROPSHEETHEADER         PROPSHEETHEADERA
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERA
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERA
#endif


#define PSCB_INITIALIZED  1
#define PSCB_PRECREATE    2

WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageA(LPCPROPSHEETPAGEA);
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW);
WINCOMMCTRLAPI BOOL           WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE);
WINCOMMCTRLAPI int            WINAPI PropertySheetA(LPCPROPSHEETHEADERA);
WINCOMMCTRLAPI int            WINAPI PropertySheetW(LPCPROPSHEETHEADERW);

#ifdef UNICODE
#define CreatePropertySheetPage  CreatePropertySheetPageW
#define PropertySheet            PropertySheetW
#else
#define CreatePropertySheetPage  CreatePropertySheetPageA
#define PropertySheet            PropertySheetA
#endif



typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);
typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);


typedef struct _PSHNOTIFY
{
    NMHDR hdr;
    LPARAM lParam;
} PSHNOTIFY, FAR *LPPSHNOTIFY;


#define PSN_FIRST               (0U-200U)
#define PSN_LAST                (0U-299U)


#define PSN_SETACTIVE           (PSN_FIRST-0)
#define PSN_KILLACTIVE          (PSN_FIRST-1)
// #define PSN_VALIDATE            (PSN_FIRST-1)
#define PSN_APPLY               (PSN_FIRST-2)
#define PSN_RESET               (PSN_FIRST-3)
// #define PSN_CANCEL              (PSN_FIRST-3)
#define PSN_HELP                (PSN_FIRST-5)
#define PSN_WIZBACK             (PSN_FIRST-6)
#define PSN_WIZNEXT             (PSN_FIRST-7)
#define PSN_WIZFINISH           (PSN_FIRST-8)
#define PSN_QUERYCANCEL         (PSN_FIRST-9)


#define PSNRET_NOERROR              0
#define PSNRET_INVALID              1
#define PSNRET_INVALID_NOCHANGEPAGE 2


#define PSM_SETCURSEL           (WM_USER + 101)
#define PropSheet_SetCurSel(hDlg, hpage, index) \
        SNDMSG(hDlg, PSM_SETCURSEL, (WPARAM)index, (LPARAM)hpage)


#define PSM_REMOVEPAGE          (WM_USER + 102)
#define PropSheet_RemovePage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_REMOVEPAGE, index, (LPARAM)hpage)


#define PSM_ADDPAGE             (WM_USER + 103)
#define PropSheet_AddPage(hDlg, hpage) \
        SNDMSG(hDlg, PSM_ADDPAGE, 0, (LPARAM)hpage)


#define PSM_CHANGED             (WM_USER + 104)
#define PropSheet_Changed(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_CHANGED, (WPARAM)hwnd, 0L)


#define PSM_RESTARTWINDOWS      (WM_USER + 105)
#define PropSheet_RestartWindows(hDlg) \
        SNDMSG(hDlg, PSM_RESTARTWINDOWS, 0, 0L)


#define PSM_REBOOTSYSTEM        (WM_USER + 106)
#define PropSheet_RebootSystem(hDlg) \
        SNDMSG(hDlg, PSM_REBOOTSYSTEM, 0, 0L)


#define PSM_CANCELTOCLOSE       (WM_USER + 107)
#define PropSheet_CancelToClose(hDlg) \
        PostMessage(hDlg, PSM_CANCELTOCLOSE, 0, 0L)


#define PSM_QUERYSIBLINGS       (WM_USER + 108)
#define PropSheet_QuerySiblings(hDlg, wParam, lParam) \
        SNDMSG(hDlg, PSM_QUERYSIBLINGS, wParam, lParam)


#define PSM_UNCHANGED           (WM_USER + 109)
#define PropSheet_UnChanged(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_UNCHANGED, (WPARAM)hwnd, 0L)


#define PSM_APPLY               (WM_USER + 110)
#define PropSheet_Apply(hDlg) \
        SNDMSG(hDlg, PSM_APPLY, 0, 0L)


#define PSM_SETTITLEA           (WM_USER + 111)
#define PSM_SETTITLEW           (WM_USER + 120)

#ifdef UNICODE
#define PSM_SETTITLE            PSM_SETTITLEW
#else
#define PSM_SETTITLE            PSM_SETTITLEA
#endif

#define PropSheet_SetTitle(hDlg, wStyle, lpszText)\
        SNDMSG(hDlg, PSM_SETTITLE, wStyle, (LPARAM)(LPCTSTR)lpszText)


#define PSM_SETWIZBUTTONS       (WM_USER + 112)
#define PropSheet_SetWizButtons(hDlg, dwFlags) \
        PostMessage(hDlg, PSM_SETWIZBUTTONS, 0, (LPARAM)dwFlags)



#define PSWIZB_BACK             0x00000001
#define PSWIZB_NEXT             0x00000002
#define PSWIZB_FINISH           0x00000004
#define PSWIZB_DISABLEDFINISH   0x00000008


#define PSM_PRESSBUTTON         (WM_USER + 113)
#define PropSheet_PressButton(hDlg, iButton) \
        PostMessage(hDlg, PSM_PRESSBUTTON, (WPARAM)iButton, 0)


#define PSBTN_BACK              0
#define PSBTN_NEXT              1
#define PSBTN_FINISH            2
#define PSBTN_OK                3
#define PSBTN_APPLYNOW          4
#define PSBTN_CANCEL            5
#define PSBTN_HELP              6
#define PSBTN_MAX               6



#define PSM_SETCURSELID         (WM_USER + 114)
#define PropSheet_SetCurSelByID(hDlg, id) \
        SNDMSG(hDlg, PSM_SETCURSELID, 0, (LPARAM)id)


#define PSM_SETFINISHTEXTA      (WM_USER + 115)
#define PSM_SETFINISHTEXTW      (WM_USER + 121)

#ifdef UNICODE
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTW
#else
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTA
#endif

#define PropSheet_SetFinishText(hDlg, lpszText) \
        SNDMSG(hDlg, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText)


#define PSM_GETTABCONTROL       (WM_USER + 116)
#define PropSheet_GetTabControl(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETTABCONTROL, 0, 0)

#define PSM_ISDIALOGMESSAGE     (WM_USER + 117)
#define PropSheet_IsDialogMessage(hDlg, pMsg) \
        (BOOL)SNDMSG(hDlg, PSM_ISDIALOGMESSAGE, 0, (LPARAM)pMsg)

#define PSM_GETCURRENTPAGEHWND  (WM_USER + 118)
#define PropSheet_GetCurrentPageHwnd(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETCURRENTPAGEHWND, 0, 0L)

#define ID_PSRESTARTWINDOWS     0x2
#define ID_PSREBOOTSYSTEM       (ID_PSRESTARTWINDOWS | 0x1)


#define WIZ_CXDLG               276
#define WIZ_CYDLG               140

#define WIZ_CXBMP               80

#define WIZ_BODYX               92
#define WIZ_BODYCX              184

#define PROP_SM_CXDLG           212
#define PROP_SM_CYDLG           188

#define PROP_MED_CXDLG          227
#define PROP_MED_CYDLG          215

#define PROP_LG_CXDLG           252
#define PROP_LG_CYDLG           218



#ifdef __cplusplus
}
#endif


#endif  // _PRSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\setupx.h ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

//**********************************************************************
//
// SETUPX.H                         
//
// Public include file for Chicago Setup services.
//
//**********************************************************************

#ifndef SETUPX_INC
#define SETUPX_INC   1                   // SETUPX.H signature

/***************************************************************************/
// setup PropertySheet support
// NOTE:  Always include PRST.H because it is needed later for Class Installer
// stuff, and optionally define the SU prop sheet stuff.
/***************************************************************************/
//#include <prsht.h>
#ifndef NOPRSHT
HPROPSHEETPAGE  WINAPI SUCreatePropertySheetPage(LPCPROPSHEETPAGE lppsp);
BOOL            WINAPI SUDestroyPropertySheetPage(HPROPSHEETPAGE hPage);
int             WINAPI SUPropertySheet(LPCPROPSHEETHEADER lppsh);
#endif // NOPRSHT

typedef UINT RETERR;             // Return Error code type.

#define OK 0                     // success error code

#define IP_ERROR       (100)    // Inf parsing
#define TP_ERROR       (200)    // Text processing module
#define VCP_ERROR      (300)    // Virtual copy module
#define GEN_ERROR      (400)    // Generic Installer
#define DI_ERROR       (500)    // Device Installer

// err2ids mappings
enum ERR_MAPPINGS {
    E2I_VCPM,           // Maps VCPM to strings
    E2I_SETUPX,         // Maps setupx returns to strings
    E2I_SETUPX_MODULE,  // Maps setupx returns to appropriate module
    E2I_DOS_SOLUTION,   // Maps DOS Extended errors to solutions
    E2I_DOS_REASON,     // Maps DOS extended errors to strings.
    E2I_DOS_MEDIA,      // Maps DOS extended errors to media icon.
};

#ifndef NOVCP

/***************************************************************************/
//
// Logical Disk ID definitions
//
/***************************************************************************/

// DECLARE_HANDLE(VHSTR);           /* VHSTR = VirtCopy Handle to STRing */
typedef UINT VHSTR;         /* VirtCopy Handle to String */

VHSTR   WINAPI vsmStringAdd(LPCSTR lpszName);
int WINAPI vsmStringDelete(VHSTR vhstr);
VHSTR   WINAPI vsmStringFind(LPCSTR lpszName);
int WINAPI vsmGetStringName(VHSTR vhstr, LPSTR lpszBuffer, int cbBuffer);
int WINAPI vsmStringCompare(VHSTR vhstrA, VHSTR vhstrB);
LPCSTR  WINAPI vsmGetStringRawName(VHSTR vhstr);
void    WINAPI vsmStringCompact(void);

typedef UINT LOGDISKID;          /* ldid */

// Logical Disk Descriptor: Structure which describes the physical attributes
// of a logical disk. Every logical disk is assigned a logical disk
// identifier (LDID), and is described by a logical disk descriptor (LDD).
//
// The cbSize structure member must always be set to sizeof(LOGDISKDESC_S),
// but all other unused structure members should be NULL or 0. No validation
// is performed on the size of string arrays; all string pointers, if
// non-NULL and they are to receive a string, must point at string arrays
// whose sizes are as follows:
//      sizeof( szPath )    = MAX_PATH_LEN
//      sizeof( szVolLabel) = MAX_FILENAME_LEN
//      sizeof( szName )    = MAX_STRING_LEN
#define MAX_PATH_LEN        260     // Max. path length.
#define MAX_FILENAME_LEN    20      // Max. filename length. ( > sizeof( "x:\\12345678.123" )

typedef struct _LOGDISKDESC_S { /* ldd */
    WORD        cbSize;                 // Size of this structure (bytes)
    LOGDISKID   ldid;                   // Logical Disk ID.
    LPSTR       pszPath;                // Ptr. to associated Path string.
    LPSTR       pszVolLabel;            // Ptr. to Volume Label string.
    LPSTR       pszDiskName;            // Ptr. to Disk Name string.
    WORD        wVolTime;               // Volume label modification time.
    WORD        wVolDate;               // Volume label modification date.
    DWORD       dwSerNum;               // Disk serial number.
    WORD        wFlags;                 // Flags.
} LOGDISKDESC_S, FAR *LPLOGDISKDESC;

// Range for pre-defined LDIDs.
#define LDID_PREDEF_START   0x0001  // Start of range
#define LDID_PREDEF_END     0x7FFF  // End of range

// Range for dynamically assigned LDIDs.
#define LDID_ASSIGN_START   0x8000  // Start of range
#define LDID_ASSIGN_END     0xBFFF  // End of range

// Pre-defined Logical Disk Identifiers (LDID).
//
#define LDID_NULL       0               // Null (undefined) LDID.
#define LDID_ABSOLUTE   ((UINT)-1)      // Absolute path

// source path of windows install, this is typically A:\ or a net drive
#define LDID_SRCPATH    1   // source of instilation
// temporary setup directory used by setup, this is only valid durring
// regular install and contains the INF and other binary files.  May be
// read-only location.
#define LDID_SETUPTEMP  2   // temporary setup dir for install
// path to uninstall location, this is where we backup files that will
// be overwritten
#define LDID_UNINSTALL  3   // uninstall (backup) dir.
// backup path for the copy engine, this should not be used
#define LDID_BACKUP     4   // NOTE: backup dir for the copy engine, not used
// temporary setup directory used by setup, this is only valid durring
// regular install and is guarenteed to be a read/write location for 
// scratch space.
#define LDID_SETUPSCRATCH  5   // temporary setup dir for scratch space.

// windows directory, this is the destinatio of the insallation
#define LDID_WIN        10  // destination Windows dir (just user files).
#define LDID_SYS        11  // destination Windows System dir.
#define LDID_IOS        12  // destination Windows Iosubsys dir.
#define LDID_CMD        13  // destination Windows Command (DOS) dir.
#define LDID_CPL        14  // destination Windows Control Panel dir.
#define LDID_PRINT      15  // destination Windows Printer dir.
#define LDID_MAIL       16  // destination Mail dir.
#define LDID_INF        17  // destination Windows *.INF dir.
#define LDID_HELP       18  // destination Windows Help dir.
#define LDID_WINADMIN   19  // admin stuff.

#define LDID_FONTS      20  // destination Windows Font dir.
#define LDID_VIEWERS    21  // destination Windows Viewers dir.
#define LDID_VMM32      22  // destination Windows VMM32 dir.
#define LDID_COLOR      23  // destination Windows Color dir.

#define LDID_APPS       24  // Applications folder location.

// Shared dirs for net install.
#define LDID_SHARED     25  // Bulk of windows files.
#define LDID_WINBOOT    26  // guarenteed boot device for windows.
#define LDID_MACHINE    27  // machine specific files.
#define LDID_HOST_WINBOOT   28

// boot and old win and dos dirs.
#define LDID_BOOT       30  // Root dir of boot drive
#define LDID_BOOT_HOST  31  // Root dir of boot drive host
#define LDID_OLD_WINBOOT    32  // Subdir off of Root (optional)
#define LDID_OLD_WIN    33  // old windows directory (if it exists)
#define LDID_OLD_DOS    34  // old dos directory (if it exists)

#define LDID_OLD_NET    35  // old network root directory, only valid during
                            // network GenUpgrade

#define LDID_MOUSE      36  // path to MOUSE env. variable if set or same as LDID_WIN
                            // only valid after mouse class installer.

// Convert Ascii drive letter to Integer drive number ('A'=1, 'B'=2, ...).
#define DriveAtoI( chDrv )      ((int)(chDrv & 31))

// Convert Integer drive number to Ascii drive letter (1='A', 2='B', ...).
#define DriveItoA( iDrv )       ((char) (iDrv - 1 + 'A'))

// NOTE: change the names of these

RETERR WINAPI CtlSetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlGetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlFindLdd    ( LPLOGDISKDESC );
RETERR WINAPI CtlAddLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlDelLdd     ( LOGDISKID  );
RETERR WINAPI CtlGetLddPath ( LOGDISKID, LPSTR );
RETERR WINAPI CtlSetLddPath ( LOGDISKID, LPSTR );

/***************************************************************************/
//
// Virtual File Copy definitions
//
/***************************************************************************/

typedef DWORD LPEXPANDVTBL;         /* Should clean this up */

enum _ERR_VCP
{
    ERR_VCP_IOFAIL = (VCP_ERROR + 1),       // File I/O failure
    ERR_VCP_STRINGTOOLONG,                  // String length limit exceeded
    ERR_VCP_NOMEM,                          // Insufficient memory to comply
    ERR_VCP_NOVHSTR,                        // No string handles available
    ERR_VCP_OVERFLOW,                       // Reference count would overflow
    ERR_VCP_BADARG,                         // Invalid argument to function
    ERR_VCP_UNINIT,                         // String library not initialized
    ERR_VCP_NOTFOUND ,                      // String not found in string table
    ERR_VCP_BUSY,                           // Can't do that now
    ERR_VCP_INTERRUPTED,                    // User interrupted operation
    ERR_VCP_BADDEST,                        // Invalid destination directory
    ERR_VCP_SKIPPED,                        // User skipped operation
    ERR_VCP_IO,                             // Hardware error encountered
    ERR_VCP_LOCKED,                         // List is locked
    ERR_VCP_WRONGDISK,                      // The wrong disk is in the drive
    ERR_VCP_CHANGEMODE,                     //
    ERR_VCP_LDDINVALID,                // Logical Disk ID Invalid.
    ERR_VCP_LDDFIND,                   // Logical Disk ID not found.
    ERR_VCP_LDDUNINIT,                 // Logical Disk Descriptor Uninitialized.
    ERR_VCP_LDDPATH_INVALID,
    ERR_VCP_NOEXPANSION,                // Failed to load expansion dll
    ERR_VCP_NOTOPEN,                    // Copy session not open
};

/*****************************************************************************
 *              Structures
 *****************************************************************************/

/*---------------------------------------------------------------------------*
 *                  VCPPROGRESS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPPROGRESS { /* prg */
    DWORD   dwSoFar;            /* Number of units copied so far */
    DWORD   dwTotal;            /* Number of units to copy */
} VCPPROGRESS, FAR *LPVCPPROGRESS;

/*---------------------------------------------------------------------------*
 *                  VCPDISKINFO
 *---------------------------------------------------------------------------*/

typedef struct tagVCPDISKINFO {
    WORD        cbSize;         /* Size of this structure in bytes */
    LOGDISKID   ldid;           /* Logical disk ID */
    VHSTR       vhstrRoot;      /* Location of root directory */
    VHSTR       vhstrVolumeLabel;/* Volume label */
    VHSTR       vhstrDiskName;  // Printed name on the disk.
    WORD        wVolumeTime;    /* Volume label modification time */
    WORD        wVolumeDate;    /* Volume label modification date */
    DWORD       dwSerialNumber; /* Disk serial number */
    WORD        fl;             /* Flags */
    LPARAM      lparamRef;      /* Reference data for client */

    VCPPROGRESS prgFileRead;    /* Progress info */
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

} VCPDISKINFO, FAR *LPVCPDISKINFO;

#define VDIFL_VALID     0x0001  /* Fields are valid from a prev. call */
#define VDIFL_EXISTS    0x0002  /* Disk exists; do not format */

RETERR WINAPI DiskInfoFromLdid(LOGDISKID ldid, LPVCPDISKINFO lpdi);

/*---------------------------------------------------------------------------*
 *                  VCPFILESPEC
 *---------------------------------------------------------------------------*/

typedef struct tagVCPFILESPEC { /* vfs */
    LOGDISKID   ldid;           /* Logical disk */
    VHSTR       vhstrDir;       /* Directory withing logical disk */
    VHSTR       vhstrFileName;  /* Filename within directory */
} VCPFILESPEC, FAR *LPVCPFILESPEC;

/*---------------------------------------------------------------------------*
 *              VCPFATTR
 *---------------------------------------------------------------------------*/

/*
 * Explain diffce between llenIn and llenOut wrt compression.
 */
typedef struct tagVCPFATTR {
    UINT    uiMDate;            /* Modification date */
    UINT    uiMTime;            /* Modification time */
    UINT    uiADate;            /* Access date */
    UINT    uiATime;            /* Access time */
    UINT    uiAttr;             /* File attribute bits */
    DWORD   llenIn;             /* Original file length */
    DWORD   llenOut;            /* Final file length */
                                /* (after decompression) */
} VCPFATTR, FAR *LPVCPFATTR;

/*---------------------------------------------------------------------------*
 *                  VIRTNODEEX
 *---------------------------------------------------------------------------*/
typedef struct tagVIRTNODEEX
{    /* vnex */
    HFILE           hFileSrc;
    HFILE           hFileDst;
    VCPFATTR        fAttr;
    WORD            dosError;   // The first/last error encountered
    VHSTR           vhstrFileName;  // The original destination name.
    WPARAM          vcpm;   // The message that was being processed.
} VIRTNODEEX, FAR *LPCVIRTNODEEX, FAR *LPVIRTNODEEX ;

/*---------------------------------------------------------------------------*
 *                  VIRTNODE
 *---------------------------------------------------------------------------*/

typedef struct tagVIRTNODE {    /* vn */
    WORD            cbSize;
    VCPFILESPEC     vfsSrc;
    VCPFILESPEC     vfsDst;
    WORD            fl;
    LPARAM          lParam;
    LPEXPANDVTBL    lpExpandVtbl;
    LPVIRTNODEEX    lpvnex;
} VIRTNODE, FAR *LPCVIRTNODE, FAR *LPVIRTNODE ;

/*---------------------------------------------------------------------------*
 *              VCPDESTINFO
 *---------------------------------------------------------------------------*/

typedef struct tagVCPDESTINFO { /* destinfo */
    WORD    flDevAttr;          /* Device attributes */
    LONG    cbCapacity;         /* Disk capacity */
    WORD    cbCluster;          /* Bytes per cluster */
    WORD    cRootDir;           /* Size of root directory */
} VCPDESTINFO, FAR *LPVCPDESTINFO;

#define DIFL_FIXED      0x0001  /* Nonremoveable media */
#define DIFL_CHANGELINE 0x0002  /* Change line support */

// Now also used by the virtnode as we dont have copy nodes any more.
// #define CNFL_BACKUP             0x0001  /* This is a backup node */
#define CNFL_DELETEONFAILURE    0x0002  /* Dest should be deleted on failure */
#define CNFL_RENAMEONSUCCESS    0x0004  /* Dest needs to be renamed */
#define CNFL_CONTINUATION       0x0008  /* Dest is continued onto difft disk */
#define CNFL_SKIPPED            0x0010  /* User asked to skip file */
#define CNFL_IGNOREERRORS       0x0020  // An error has occured on this file already
#define CNFL_RETRYFILE          0x0040  // Retry the file (error ocurred)
#define CNFL_COPIED				0x0080  // Node has already been copied.

// Verify the use and usefullness of these flags
// #define VNFL_UNIQUE          0x0000  /* Default */
#define VNFL_MULTIPLEOK         0x0100  /* Do not search PATH for duplicates */
#define VNFL_DESTROYOLD         0x0200  /* Do not back up files */
// #define VNFL_NOW             0x0400  /* Use by vcp Flush */
// To deternime what kind of node it is.
#define VNFL_COPY			    0x0000  // A simple copy node.
#define VNFL_DELETE             0x0800  // A delete node
#define VNFL_RENAME             0x1000  // A rename node
#define VNFL_NODE_TYPE		    ( VNFL_RENAME|VNFL_DELETE|VNFL_COPY )
    /* Read-only flag bits */
#define VNFL_CREATED            0x2000  /* VCPM_NODECREATE has been sent */
#define VNFL_REJECTED           0x4000  /* Node has been rejected */

#define VNFL_DEVICEINSTALLER    0x8000     /* Node was added by the Device Installer */

/*---------------------------------------------------------------------------*
 *                  VCPSTATUS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPSTATUS {   /* vstat */
    WORD    cbSize;             /* Size of this structure */

    VCPPROGRESS prgDiskRead;
    VCPPROGRESS prgFileRead;
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgDiskWrite;
    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

    LPVCPDISKINFO lpvdiIn;      /* Current input disk */
    LPVCPDISKINFO lpvdiOut;     /* Current output disk */
    LPVIRTNODE    lpvn;            /* Current file */

} VCPSTATUS, FAR *LPVCPSTATUS;

/*---------------------------------------------------------------------------*
 *                  VCPVERCONFLICT
 *---------------------------------------------------------------------------*/

typedef struct tagVCPVERCONFLICT {

    LPCSTR  lpszOldFileName;
    LPCSTR  lpszNewFileName;
    DWORD   dwConflictType;     /* Same values as VerInstallFiles */
    LPVOID  lpvinfoOld;         /* Version information resources */
    LPVOID  lpvinfoNew;
    WORD    wAttribOld;         /* File attributes for original */
    LPARAM  lparamRef;          /* Reference data for callback */

} VCPVERCONFLICT, FAR *LPVCPVERCONFLICT;

/*****************************************************************************
 *              Callback functions
 *****************************************************************************/

typedef LRESULT (CALLBACK *VIFPROC)(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

LRESULT CALLBACK vcpDefCallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

// callback for default UI.
// lparamRef --> a VCPUIINFO structure
LRESULT CALLBACK vcpUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

/*---------------------------------------------------------------------------*
 *                  VCPUIINFO
 *
 * This structure is passed in as the lparamRef of vcpUICallbackProc.
 *
 * on using vcpUICallbackProc:
 * - to use, have vcpUICallbackProc as the callback for vcpOpen with
 *   an appropriately filled in VCPUIINFO structure as the lparamRef.
 *
 * - based on flags, hwndProgress is created and maintained
 * - lpfnStatCallback is called with only status messages
 *     returning VCPM_ABORT indicates that the copy should be aborted
 * - if hwndProgress is non-NULL, the control with idProgress will
 *     receive progress gauge messages as appropriate
 *
 *---------------------------------------------------------------------------*/
#define VCPUI_CREATEPROGRESS 0x0001 // callback should create and manage progress gauge dialog
#define VCPUI_NOBROWSE       0x0002 // no browse button in InsertDisk
#define VCPUI_RENAMEREQUIRED 0x0004 // as a result of a file being in use at copy, reboot required

typedef struct {
    UINT flags;
    HWND hwndParent;            // window of parent
    HWND hwndProgress;          // window to get progress updates (nonzero ids)
    UINT idPGauge;              // id for progress gauge
    VIFPROC lpfnStatCallback;   // callback for status info (or NULL)
    LPARAM lUserData;           // caller definable data
    LOGDISKID ldidCurrent;      // reserved.  do not touch.
} VCPUIINFO, FAR *LPVCPUIINFO;

/******************************************************************************
 *          Callback notification codes
 *****************************************************************************/

    /* VCPN_ABORT should match VCPERROR_INTERRUPTED */

#define VCPN_OK         0       /* All is hunky-dory */
#define VCPN_PROCEED        0   /* The same as VCPN_OK */

#define VCPN_ABORT      (-1)    /* Cancel current operation */
#define VCPN_RETRY      (-2)    /* Retry current operation */
#define VCPN_IGNORE     (-3)    /* Ignore error and continue */
#define VCPN_SKIP       (-4)    /* Skip this file and continue */
#define VCPN_FORCE      (-5)    /* Force an action */
#define VCPN_DEFER      (-6)    /* Save the action for later */
#define VCPN_FAIL       (-7)    /* Return failure back to caller */
#define VCPN_RETRYFILE  (-8)    // An error ocurred during file copy, do it again.

/*****************************************************************************
 *          Callback message numbers
 *****************************************************************************/

#define VCPM_CLASSOF(uMsg)  HIBYTE(uMsg)
#define VCPM_TYPEOF(uMsg)   (0x00FF & (uMsg))   // LOBYTE(uMsg)

/*---------------------------------------------------------------------------*
 *          ERRORs
 *---------------------------------------------------------------------------*/

#define VCPM_ERRORCLASSDELTA    0x80
#define VCPM_ERRORDELTA         0x8000      /* Where the errors go */

/*---------------------------------------------------------------------------*
 *          Disk information callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_DISKCLASS      0x01
#define VCPM_DISKFIRST      0x0100
#define VCPM_DISKLAST       0x01FF

enum tagVCPM_DISK {

    VCPM_DISKCREATEINFO = VCPM_DISKFIRST,
    VCPM_DISKGETINFO,
    VCPM_DISKDESTROYINFO,
    VCPM_DISKPREPINFO,

    VCPM_DISKENSURE,
    VCPM_DISKPROMPT,

    VCPM_DISKFORMATBEGIN,
    VCPM_DISKFORMATTING,
    VCPM_DISKFORMATEND,

    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          File copy callbacks
 *---------------------------------------------------------------------------*/

// NOTE: This needs to be merged back with other internal errors
#define VCPERROR_IO         (VCP_ERROR - ERR_VCP_IO)            /* Hardware error encountered */

#define VCPM_FILEINCLASS    0x02
#define VCPM_FILEOUTCLASS   0x03
#define VCPM_FILEFIRSTIN    0x0200
#define VCPM_FILEFIRSTOUT   0x0300
#define VCPM_FILELAST       0x03FF

enum tagVCPM_FILE {
    VCPM_FILEOPENIN = VCPM_FILEFIRSTIN,
    VCPM_FILEGETFATTR,
    VCPM_FILECLOSEIN,
    VCPM_FILECOPY,
    VCPM_FILENEEDED,

    VCPM_FILEOPENOUT = VCPM_FILEFIRSTOUT,
    VCPM_FILESETFATTR,
    VCPM_FILECLOSEOUT,
    VCPM_FILEFINALIZE,
    VCPM_FILEDELETE,
    VCPM_FILERENAME,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VIRTNODE callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_NODECLASS  0x04
#define VCPM_NODEFIRST  0x0400
#define VCPM_NODELAST   0x04FF

enum tagVCPM_NODE {
    VCPM_NODECREATE = VCPM_NODEFIRST,
    VCPM_NODEACCEPT,
    VCPM_NODEREJECT,
    VCPM_NODEDESTROY,
    VCPM_NODECHANGEDESTDIR,
    VCPM_NODECOMPARE,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          TALLY callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_TALLYCLASS     0x05
#define VCPM_TALLYFIRST     0x0500
#define VCPM_TALLYLAST      0x05FF

enum tagVCPM_TALLY {
    VCPM_TALLYSTART = VCPM_TALLYFIRST,
    VCPM_TALLYEND,
    VCPM_TALLYFILE,
    VCPM_TALLYDISK,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VER callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VERCLASS       0x06
#define VCPM_VERFIRST       0x0600
#define VCPM_VERLAST        0x06FF

enum tagVCPM_VER {
    VCPM_VERCHECK = VCPM_VERFIRST,
    VCPM_VERCHECKDONE,
    VCPM_VERRESOLVECONFLICT,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VSTAT callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VSTATCLASS     0x07
#define VCPM_VSTATFIRST     0x0700
#define VCPM_VSTATLAST      0x07FF

enum tagVCPM_VSTAT {
    VCPM_VSTATSTART = VCPM_VSTATFIRST,
    VCPM_VSTATEND,
    VCPM_VSTATREAD,
    VCPM_VSTATWRITE,
    VCPM_VSTATNEWDISK,

    VCPM_VSTATCLOSESTART,       // Start of VCP close
    VCPM_VSTATCLOSEEND,         // upon leaving VCP close
    VCPM_VSTATBACKUPSTART,      // Backup is beginning
    VCPM_VSTATBACKUPEND,        // Backup is finished
    VCPM_VSTATRENAMESTART,      // Rename phase start/end
    VCPM_VSTATRENAMEEND,
    VCPM_VSTATCOPYSTART,        // Acutal copy phase
    VCPM_VSTATCOPYEND,
    VCPM_VSTATDELETESTART,      // Delete phase
    VCPM_VSTATDELETEEND,
    VCPM_VSTATPATHCHECKSTART,   // Check for valid paths
    VCPM_VSTATPATHCHECKEND,
    VCPM_VSTATUSERABORT,        // User wants to quit.
    VCPM_VSTATYIELD,            // Do a yield.
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          Destination info callbacks
 *---------------------------------------------------------------------------*/

/* NOTE -- find a reasonable message range for this */
#define VCPM_PATHCLASS      0x08
#define VCPM_PATHFIRST      0x0800
#define VCPM_PATHLAST       0x08FF

enum tagVCPM_PATH{
    VCPM_BUILDPATH = VCPM_PATHFIRST,
    VCPM_UNIQUEPATH,
    VCPM_CHECKPATH,
};

// #define VCPM_BUILDPATH      0x83

/*****************************************************************************/
void WINAPI VcpAddMRUPath( LPCSTR lpszPath );
#define SZ_INSTALL_LOCATIONS "InstallLocationsMRU"

RETERR WINAPI VcpOpen(VIFPROC vifproc, LPARAM lparamMsgRef);

RETERR WINAPI VcpClose(WORD fl, LPCSTR lpszBackupDest);

RETERR WINAPI VcpFlush(WORD fl, LPCSTR lpszBackupDest);

#define VCPFL_ABANDON           0x0000  /* Abandon all pending file copies */
#define VCPFL_BACKUP            0x0001  /* Perform backup */
#define VCPFL_COPY              0x0002  /* Copy files */
#define VCPFL_BACKUPANDCOPY     (VCPFL_BACKUP | VCPFL_COPY)
#define VCPFL_INSPECIFIEDORDER  0x0004  /* Do not sort before copying */
#define VCPFL_DELETE            0x0008
#define VCPFL_RENAME            0x0010
#define VCPFL_ALL	        (VCPFL_COPY | VCPFL_DELETE | VCPFL_RENAME)

typedef int (CALLBACK *VCPENUMPROC)(LPVIRTNODE lpvn, LPARAM lparamRef);

int WINAPI vcpEnumFiles(VCPENUMPROC vep, LPARAM lparamRef);

enum tag_VCPM_EXPLAIN{
    VCPEX_SRC_DISK,
    VCPEX_SRC_CABINET,
    VCPEX_SRC_LOCN,
    VCPEX_DST_LOCN,
    VCPEX_SRC_FILE,
    VCPEX_DST_FILE,
    VCPEX_DOS_ERROR,
    VCPEX_MESSAGE,
    VCPEX_DOS_SOLUTION,
    VCPEX_SRC_FULL,
    VCPEX_DST_FULL,
};

LPCSTR WINAPI VcpExplain( LPVIRTNODE lpVn, DWORD dwWhat );

/* Flag bits that can be set via VcpQueueCopy */

// Various Lparams for files
#define VNLP_SYSCRITICAL    0x0001  // This file should not be skipped
#define VNLP_SETUPCRITICAL  0x0002  // This file cannot be skipped
#define VNLP_NOVERCHECK     0x0004  // This file must not be VerResolved.
#define VNLP_FORCETEMP      0x0008  // This file must left as a temp name
#define VNLP_IFEXISTS       0x0010  // File skipped if already on machine
#define VNLP_KEEPNEWER      0x0020  // If the dest file is newer - keep it (frosting)

// VcpEnumFiles Flags.

#define VEN_OP      0x00ff      /* Operation field */

#define VEN_NOP     0x0000      /* Do nothing */
#define VEN_DELETE  0x0001      /* Delete current item */
#define VEN_SET     0x0002      /* Change value of current item */

#define VEN_FL      0xff00      /* Flags field */

#define VEN_STOP    0x0100      /* Stop enumeration after this item */
#define VEN_ERROR   0x8000      /* Stop enumeration after this item
                                 * and ignore the OP field */

// NOTE: add the other VCP stuff necessary to use this

// NOTE: remove the lpsz*Dir fields, make overload the LDID with them

RETERR WINAPI VcpQueueCopy(LPCSTR lpszSrcFileName, LPCSTR lpszDstFileName,
                LPCSTR lpszSrcDir, LPCSTR lpszDstDir,
                LOGDISKID ldidSrc, LOGDISKID ldidDst,
                LPEXPANDVTBL lpExpandVtbl, WORD fl,
                LPARAM lParam);

RETERR WINAPI VcpQueueDelete( LPCSTR lpszDstFileName,
                              LPCSTR lpszDstDir,
                              LOGDISKID ldidDst,
                              LPARAM lParamRef );

RETERR WINAPI VcpQueueRename( LPCSTR      lpszSrcFileName,
                            LPCSTR      lpszDstFileName,
                            LPCSTR      lpszSrcDir,
                            LPCSTR      lpszDstDir,
                            LOGDISKID   ldidSrc,
                            LOGDISKID   ldidDst,
                            LPARAM      lParam );

#endif // NOVCP

#ifndef NOINF
/***************************************************************************/
//
// Inf Parser API declaration and definitions
//
/***************************************************************************/

enum _ERR_IP
{
    ERR_IP_INVALID_FILENAME = (IP_ERROR + 1),
    ERR_IP_ALLOC_ERR,
    ERR_IP_INVALID_SECT_NAME,
    ERR_IP_OUT_OF_HANDLES,
    ERR_IP_INF_NOT_FOUND,
    ERR_IP_INVALID_INFFILE,
    ERR_IP_INVALID_HINF,
    ERR_IP_INVALID_FIELD,
    ERR_IP_SECT_NOT_FOUND,
    ERR_IP_END_OF_SECTION,
    ERR_IP_PROFILE_NOT_FOUND,
    ERR_IP_LINE_NOT_FOUND,
    ERR_IP_FILEREAD,
    ERR_IP_TOOMANYINFFILES,
    ERR_IP_INVALID_SAVERESTORE,
    ERR_IP_INVALID_INFTYPE
};

#define INFTYPE_TEXT                0
#define INFTYPE_EXECUTABLE          1

#define MAX_SECT_NAME_LEN    32

typedef struct _INF NEAR * HINF;
typedef struct _INFLINE FAR * HINFLINE;            // tolken to inf line

RETERR  WINAPI IpOpen(LPCSTR pszFileSpec, HINF FAR * lphInf);
RETERR  WINAPI IpOpenEx(LPCSTR pszFileSpec, HINF FAR * lphInf, UINT InfType);
RETERR  WINAPI IpOpenAppend(LPCSTR pszFileSpec, HINF hInf);
RETERR  WINAPI IpOpenAppendEx(LPCSTR pszFileSpec, HINF hInf, UINT InfType);
RETERR  WINAPI IpSaveRestorePosition(HINF hInf, BOOL bSave);
RETERR  WINAPI IpClose(HINF hInf);
RETERR  WINAPI IpGetLineCount(HINF hInf, LPCSTR lpszSection, int FAR * lpCount);
RETERR  WINAPI IpFindFirstLine(HINF hInf, LPCSTR lpszSect, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextLine(HINF hInf, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextMatchLine(HINF hInf, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpGetProfileString(HINF hInf, LPCSTR lpszSec, LPCSTR lpszKey, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetFieldCount(HINF hInf, HINFLINE hInfLine, int FAR * lpCount);
RETERR  WINAPI IpGetFileName(HINF hInf, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetIntField(HINF hInf, HINFLINE hInfLine, int iField, int FAR * lpVal);
RETERR  WINAPI IpGetLongField(HINF hInf, HINFLINE hInfLine, int iField, long FAR * lpVal);
RETERR  WINAPI IpGetStringField(HINF hInf, HINFLINE hInfLine, int iField, LPSTR lpBuf, int iBufSize, int FAR * lpuCount);
RETERR  WINAPI IpGetVersionString(LPSTR lpszInfFile, LPSTR lpszValue, LPSTR lpszBuf, int cbBuf, LPSTR lpszDefaultValue);

#endif // NOINF

#ifndef NOTEXTPROC
/***************************************************************************/
//
// Text processing API declaration and definitions
//
/***************************************************************************/

/* Relative/absolute positioning */
#define SEC_SET 1       // Absolute positioning (relative to the start)
#define SEC_END 2       // Realtive to the end
#define SEC_CUR 3       // Relative to the current line.

#define SEC_OPENALWAYS          1   // Always open a section, no error if it does not exist
#define SEC_OPENEXISTING        2   // Open an existing section, an error given if it does not exist.
#define SEC_OPENNEWALWAYS       3   // Open a section (present or not) and discard its contents.
#define SEC_OPENNEWEXISTING     4   // Open an existing section (discarding its contents). Error if not existing

// Flags for TP_OpenFile().
//
  // Use autoexec/config.sys key delimiters
  //
#define TP_WS_KEEP      1

  // If TP code running under SETUP, the foll. flag specifies whether
  // to cache this file or not! Use this, if you want to read a whole
  // file in when doing the TpOpenSection()!
  //
#define TP_WS_DONTCACHE 2

// The following are simple errors
enum {
    ERR_TP_NOT_FOUND = (TP_ERROR + 1),  // line, section, file etc.
                    // not necessarily terminal
    ERR_TP_NO_MEM,      // couldn't perform request - generally terminal
    ERR_TP_READ,        // could not read the disc - terminal
    ERR_TP_WRITE,       // could not write the data - terminal.
    ERR_TP_INVALID_REQUEST, // Multitude of sins - not necessarily terminal.
    ERR_TP_INVALID_LINE         // Invalid line from DELETE_LINE etc.
};

/* Data handles */
DECLARE_HANDLE(HTP);
typedef HTP FAR * LPHTP;

/* File handles */
DECLARE_HANDLE(HFN);
typedef HFN FAR * LPHFN;

typedef UINT TFLAG;
typedef UINT LINENUM, FAR * LPLINENUM;

#define MAX_REGPATH     256     // Max Registry Path Length
#define LINE_LEN        256     // Max line length?
#define SECTION_LEN     32      // Max length of a section name?
#define MAX_STRING_LEN  512     // Review this

/* Function prototypes */
RETERR  WINAPI TpOpenFile(LPCSTR Filename, LPHFN phFile, TFLAG Flag);
RETERR  WINAPI TpCloseFile(HFN hFile);
RETERR  WINAPI TpOpenSection(HFN hfile, LPHTP phSection, LPCSTR Section, TFLAG flag);
RETERR  WINAPI TpCloseSection(HTP Section);
RETERR  WINAPI TpCommitSection(HFN hFile, HTP hSection, LPCSTR Section, TFLAG flag);
LINENUM WINAPI TpGetLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, LPLINENUM lpLineNum );
LINENUM WINAPI TpGetNextLine(HTP hSection, LPCSTR key, LPCSTR value, LPLINENUM lpLineNum );
RETERR  WINAPI TpInsertLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpReplaceLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpDeleteLine(HTP hSection, int rel, int orig,TFLAG flag);
RETERR  WINAPI TpMoveLine(HTP hSection, int src_rel, int src_orig, int dest_rel, int dest_orig, TFLAG flag);
RETERR  WINAPI TpGetLineContents(HTP hSection, LPSTR buffer, UINT bufsize, UINT FAR * lpActualSize,int rel, int orig, TFLAG flag);

// UINT    WINAPI TpGetWindowsDirectory(LPSTR lpDest, UINT size);
// UINT    WINAPI TpGetSystemDirectory(LPSTR lpDest, UINT size);

int  WINAPI TpGetPrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize, LPCSTR lpszFile);
int  WINAPI TpWritePrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszString, LPCSTR lpszFile);
int  WINAPI TpGetProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize);
BOOL WINAPI TpWriteProfileString(LPCSTR lpszSect , LPCSTR lpszKey , LPCSTR lpszString);

#endif // NOTEXTPROC

#ifndef NOGENINSTALL
/***************************************************************************/
//
// Generic Installer prototypes and definitions
//
/***************************************************************************/

enum _ERR_GENERIC
{
    ERR_GEN_LOW_MEM = GEN_ERROR+1,  // Insufficient memory.
    ERR_GEN_INVALID_FILE,           // Invalid INF file.
    ERR_GEN_LOGCONFIG,              // Can't process LogConfig=.
    ERR_GEN_CFGAUTO,                // Can't process CONFIG.SYS/AUTOEXEC.BAT
    ERR_GEN_UPDINI,                 // Can't process UpdateInis=.
    ERR_GEN_UPDINIFIELDS,           // Can't process UpdateIniFields=.
    ERR_GEN_ADDREG,                 // Can't process AddReg=.
    ERR_GEN_DELREG,                 // Can't process DelReg=.
    ERR_GEN_INI2REG,                // Can't process Ini2Reg=.
    ERR_GEN_FILE_COPY,              // Can't process CopyFiles=.
    ERR_GEN_FILE_DEL,               // Can't process DelFiles=.
    ERR_GEN_FILE_REN,               // Can't process RenFiles=.
    ERR_GEN_REG_API,                // Error returned by Reg API.
    ERR_GEN_DO_FILES,               // can't do Copy, Del or RenFiles.
};

// The cbSize field will always be set to sizeof(GENCALLBACKINFO_S).
// All unused fields (for the operation) will be not be initialized.
// For example, when the operation is GENO_DELFILE, the Src fields will
// not have any sensible values (Dst fields will be set correctly) as
// VcpQueueDelete only accepts Dst parameters.
//
/***************************************************************************
 * GenCallbackINFO structure passed to GenInstall CallBack functions.
 ***************************************************************************/
typedef struct _GENCALLBACKINFO_S { /* gen-callback struc */
    WORD         cbSize;                 // Size of this structure (bytes).
    WORD         wOperation;             // Operation being performed.
    LOGDISKID    ldidSrc;                // Logical Disk ID for Source.
    LPCSTR       pszSrcSubDir;           // Source sub-dir off of the LDID.
    LPCSTR       pszSrcFileName;         // Source file name (base name).
    LOGDISKID    ldidDst;                // Logical Disk ID for Dest.
    LPCSTR       pszDstSubDir;           // Dest. sub-dir off of the LDID.
    LPCSTR       pszDstFileName;         // Dest. file name (base name).
    LPEXPANDVTBL lpExpandVtbl;           // Needed? NULL right now!
    WORD         wflags;                 // flags for VcpQueueCopy.
    LPARAM       lParam;                 // LPARAM to the Vcp API.
} GENCALLBACKINFO_S, FAR *LPGENCALLBACKINFO;

/***************************************************************************
 * GenCallback notification codes -- callback proc returns 1 of foll. values.
 ***************************************************************************/
#define GENN_OK         0       /* All is hunky-dory. Do the VCP operation */
#define GENN_PROCEED    0       /* The same as GENN_OK */

#define GENN_ABORT      (-1)    /* Cancel current GenInstall altogether */
#define GENN_SKIP       (-2)    /* Skip this file and continue */

/***************************************************************************
 * VCP Operation being performed by GenInstall() -- wOperation values in
 * GENCALLBACKINFO structure above.
 ***************************************************************************/
#define GENO_COPYFILE   1       /* VCP copyfile being done */
#define GENO_DELFILE    2       /* VCP delfile being done */
#define GENO_RENFILE    3       /* VCP renfile being done */
#define GENO_WININITRENAME 4    /* VCP wininit rename being added */

typedef LRESULT (CALLBACK *GENCALLBACKPROC)(LPGENCALLBACKINFO lpGenInfo,
                                                            LPARAM lparamRef);

RETERR WINAPI GenInstall( HINF hinfFile, LPCSTR szInstallSection, WORD wFlags );
RETERR WINAPI GenInstallEx( HINF hInf, LPCSTR szInstallSection, WORD wFlags,
                                HKEY hRegKey, GENCALLBACKPROC CallbackProc,
                                LPARAM lparam);
RETERR WINAPI GenWinInitRename(LPCSTR szNew, LPSTR szOld, LOGDISKID ldid);
RETERR WINAPI GenCopyLogConfig2Reg(HINF hInf, HKEY hRegKey,
                                                LPCSTR szLogConfigSection);
void   WINAPI GenFormStrWithoutPlaceHolders( LPSTR szDst, LPCSTR szSrc,
                                                                HINF hInf ) ;
// Flags for GenAddReg() from INf /GenSURegSetValueEx()
//
#define FLG_ADDREG_BINVALUETYPE  1
#define FLG_ADDREG_NOCLOBBER     2
#define FLG_ADDREG_DELVAL        4

RETERR WINAPI GenSURegSetValueEx(HKEY hkeyRoot, LPCSTR szSubKey,
                         LPCSTR lpszValueName, DWORD dwValType,
                         LPBYTE lpszValue, DWORD dwValSize, UINT uFlags );

// A devnode is just a DWORD and this is easier than
// having to include configmg.h for everybody
RETERR WINAPI GenInfLCToDevNode(ATOM atInfFileName, LPSTR lpszSectionName,
                                BOOL bInstallSec, UINT InfType, 
                                DWORD dnDevNode);

// Bit fields for GenInstall() (for wFlags parameter) -- these can be OR-ed!
#define GENINSTALL_DO_FILES     1
#define GENINSTALL_DO_INI       2
#define GENINSTALL_DO_REG       4
#define GENINSTALL_DO_INI2REG   8
#define GENINSTALL_DO_CFGAUTO   16
#define GENINSTALL_DO_LOGCONFIG 32
#define GENINSTALL_DO_INIREG    (GENINSTALL_DO_INI | \
                                 GENINSTALL_DO_REG | \
                                 GENINSTALL_DO_INI2REG)
#define GENINSTALL_DO_ALL       (GENINSTALL_DO_FILES | \
                                    GENINSTALL_DO_INIREG | \
                                    GENINSTALL_DO_CFGAUTO | \
                                    GENINSTALL_DO_LOGCONFIG)

#endif // NOGENINSTALL

#ifndef NODEVICENSTALL
/***************************************************************************/
//
// Device Installer prototypes and definitions
//
/***************************************************************************/

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @typee    _ERR_DEVICE_INSTALL | Error return codes for Device Installation
*   APIs.
*
*   @emem ERR_DI_INVALID_DEVICE_ID | Incorrectly formed device ID.
*
*   @emem ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST | Invalid compatible device list.
*
*   @emem ERR_DI_REG_API | Error returned by one of the registry API.
*
*   @emem ERR_DI_LOW_MEM | Insufficient memory to complete.
*
*   @emem ERR_DI_BAD_DEV_INFO | A passed in DEVICE_INFO struct is invalid.
*
*   @emem ERR_DI_INVALID_CLASS_INSTALLER | The class installer is listed incorrecrly
*   in the registry, or points to an invalid class installer.
*
*   @emem ERR_DI_DO_DEFAULT | Do the default action for the requested operation.
*
*   @emem ERR_DI_USER_CANCEL | The user cancelled the operation.
*
*   @emem ERR_DI_NOFILECOPY | No need to copy files (in install).
*
*   @emem ERR_DI_BAD_CLASS_INFO | A passed in CLASS_INFO struct is invalid.
*
*   @emem ERR_DI_BAD_INF | An invalid INF file was encountered.
*
*   @emem ERR_DI_BAD_MOVEDEV_PARAMS | A passed in MOVEDEVICE_PARAMS struct was
*   invalid.
*
*   @emem ERR_DI_NO_INF | No INF found on supplied OEM path.
*
*   @emem ERR_DI_BAD_PROPCHANGE_PARAMS | A passed in PROPCHANGE_PARMS struct was
*   invalid.
*
*   @emem ERR_DI_BAD_SELECTDEVICE_PARAMS | A passed in SELECTEDEVICE_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_BAD_REMOVEDEVICE_PARAMS | A passed in REMOVEDEVICE_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_BAD_ENABLECLASS_PARAMS | A passed in ENABLECLASS_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_FAIL_QUERY | The queried action should not take place.
*
*   @emem ERR_DI_API_ERROR | One of the Device installation APIs was called
*   incorrectly or with invalid parameters.
*
*   @emem ERR_DI_BAD_PATH | An OEM path was specified incorrectly.
*
*******************************************************************************/
enum _ERR_DEVICE_INSTALL
{
    ERR_DI_INVALID_DEVICE_ID = DI_ERROR,    // Incorrectly formed device IDF
#if 0 // generates warnings during compile.
    ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST,  // Invalid compatible device list
#else
    ERR_DI_INVALID_COMP_DEVICE_LIST,        // Invalid compatible device list
#endif
    ERR_DI_REG_API,                         // Error returned by Reg API.
    ERR_DI_LOW_MEM,                         // Insufficient memory to complete
    ERR_DI_BAD_DEV_INFO,                    // Device Info struct invalid
    ERR_DI_INVALID_CLASS_INSTALLER,         // Registry entry / DLL invalid
    ERR_DI_DO_DEFAULT,                      // Take default action
    ERR_DI_USER_CANCEL,                     // the user cancelled the operation
    ERR_DI_NOFILECOPY,                      // No need to copy files (in install)
    ERR_DI_BAD_CLASS_INFO,                  // Class Info Struct invalid
    ERR_DI_BAD_INF,                         // Bad INF file encountered
    ERR_DI_BAD_MOVEDEV_PARAMS,	            // Bad Move Device Params struct
    ERR_DI_NO_INF,                          // No INF found on OEM disk
    ERR_DI_BAD_PROPCHANGE_PARAMS,           // Bad property change param struct
    ERR_DI_BAD_SELECTDEVICE_PARAMS,         // Bad Select Device Parameters
    ERR_DI_BAD_REMOVEDEVICE_PARAMS,         // Bad Remove Device Parameters
    ERR_DI_BAD_ENABLECLASS_PARAMS,          // Bad Enable Class Parameters
    ERR_DI_FAIL_QUERY,                      // Fail the Enable Class query
    ERR_DI_API_ERROR,                       // DI API called incorrectly
    ERR_DI_BAD_PATH,                        // An OEM path was specified incorrectly
};

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DRIVER_INFO | This structure contains the information necessary
*   to present the user with a select device dialog.
*
*   @field WORD | cbSize | Size of this structure in bytes.
*
*   @field struct _DRIVER_INFO FAR | *lpNextInfo | Pointer to the next DRIVER_INFO
*   struct in a linked list.
*                 
*   @field LPSTR | lpszDescription | Pointer to the description of the device being
*   supported by this driver.
*
*   @field LPSTR | lpszMfgName | Pointer to the name of the manufacture of this
*   driver.
*
*   @field LPSTR | lpszProviderName | Pointer to provider of this driver if the
*   lpdi->Flags has the DI_MULTMFGS flag set.
*
*   @field WORD | Rank | The Rank match of this driver.  Ranks go from 0 to n, where 0 
*   is the most compatible.
*
*   @field DWORD | dwFlags | Flags that control the use of this driver node.  These
*   are the same as the flags defined for a DRIVER_NODE.
*       @flag DNF_DUPDESC           | This driver has the same device description 
*       from by more than one provider.
*       @flag DNF_OLDDRIVER         | Driver node specifies old/current driver
*       @flag DNF_EXCLUDEFROMLIST   | If set, this driver node will not be displayed
*       in any driver select dialogs.
*       @flag DNF_NODRIVER          | Set if we want to install no driver e.g no mouse drv
*
*   @field LPARAM | lpReserved | Reserved for use by the Device Installer.
*
*   @field DWORD | dwPrivateData | Reserved for use by the Device Installer.
*
*******************************************************************************/
typedef struct _DRIVER_INFO
{
    WORD                        cbSize;                     // Size of this structure in bytes
    struct _DRIVER_INFO FAR*    lpNextInfo;
    LPSTR                       lpszDescription;
    LPSTR                       lpszMfgName;
    LPSTR                       lpszProviderName;           // ONLY valid if DI_MULTMFGS is set in the LPDI
    WORD                        Rank;
    DWORD                       dwFlags;          
    LPARAM                      lpReserved;
    DWORD                       dwPrivateData;
} DRIVER_INFO, *PDRIVER_INFO, FAR *LPDRIVER_INFO;

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DRIVER_NODE | This strucure represents a driver which can be 
*   installed for a specific device.
*
*   @field struct _DRIVER_NODE FAR* | lpNextDN | Pointer to the next driver node
*   in a list.
*
*   @field UINT | Rank | The Rank match of this driver.  Ranks go from 0 to n, where 0 
*   is the most compatible.
*
*   @field UINT | InfType | Type of INF this driver cam from.  This will
*   be either INFTYPE_TEXT or INFTYPE_EXECUTABLE
*
*   @field unsigned | InfDate | DOS date stamp of the INF file.
*
*   @field LPSTR | lpszDescription | Pointer to a the descriptrion of the device being
*   supported by this driver.
*
*   @field LPSTR | lpszSectionName | Pointer to the name of INF install section for
*   this driver.
*
*   @field ATOM  | atInfFileName | Global ATOM containing the name of the INF file.
*
*   @field ATOM  | atMfgName | Global ATOM containing the name of this driver's 
*   manufacture.
*
*   @field ATOM  | atProviderName | Global ATOM containing the name of this driver's
*   provider.
*
*   @field DWORD | Flags | Flags that control functions using this DRIVER_NODE
*       @flag DNF_DUPDESC           | This driver has the same device description 
*       from by more than one provider.
*       @flag DNF_OLDDRIVER         | Driver node specifies old/current driver
*       @flag DNF_EXCLUDEFROMLIST   | If set, this driver node will not be displayed
*       in any driver select dialogs.
*       @flag DNF_NODRIVER          | Set if we want to install no driver e.g no mouse drv
*       @flag DNF_CONVERTEDLPINFO   | Set if this Driver Node was converted from an Info Node.
*       Setting this flag will cause the cleanup functions to explicitly delete it.
*
*   @field DWORD | dwPrivateData | Reserved
*
*   @field LPSTR | lpszDrvDescription | Pointer to a driver description.
*
*   @field LPSTR | lpszHardwareID | Pointer to a list of Plug-and-Play hardware IDs for 
*   this driver.
*   
*   @field LPSTR | lpszCompatIDs | Pointer to a list of Plug-and-Play compatible IDs for
*   this driver.
*
*******************************************************************************/
typedef struct _DRIVER_NODE {
    struct _DRIVER_NODE FAR* lpNextDN;
    UINT    Rank;
    UINT    InfType;
    unsigned    InfDate;
    LPSTR   lpszDescription;        // Compatibility: Contains the Device Desc.
    LPSTR   lpszSectionName;
    ATOM    atInfFileName;
    ATOM    atMfgName;
    ATOM    atProviderName;
    DWORD   Flags;
    DWORD   dwPrivateData;
    LPSTR   lpszDrvDescription;     // New contains an driver description
    LPSTR   lpszHardwareID;
    LPSTR   lpszCompatIDs;
}   DRIVER_NODE, NEAR* PDRIVER_NODE, FAR* LPDRIVER_NODE, FAR* FAR* LPLPDRIVER_NODE;

#define DNF_DUPDESC         0x00000001   // Multiple providers have same desc
#define DNF_OLDDRIVER       0x00000002   // Driver node specifies old/current driver
#define DNF_EXCLUDEFROMLIST 0x00000004  
#define DNF_NODRIVER	    0x00000008	 // if we want to install no driver e.g no mouse drv

#define DNF_CONVERTEDLPINFO 0x00000010  // Set if the Driver Node is a Converted Info Node

// possible types of "INF" files
#define INFTYPE_WIN4        1
#define INFTYPE_WIN3        2
#define INFTYPE_COMBIDRV    3
#define INFTYPE_PPD         4
#define INFTYPE_WPD     5
#define INFTYPE_CLASS_SPEC1 6
#define INFTYPE_CLASS_SPEC2 7
#define INFTYPE_CLASS_SPEC3 8
#define INFTYPE_CLASS_SPEC4 9

#define MAX_CLASS_NAME_LEN   32
#define MAX_DRIVER_INST_LEN  10

// NOTE:  Keep this in sync with confimg.h in \DDK\INC
#define MAX_DEVNODE_ID_LEN  256

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DEVICE_INFO | This is the basic data structure for most Device
*   installation APIs.  A DEVICE_INFO represents a device that is being installed
*   on the system, or an installed device that is being modified in some way.
*
*   @field UINT | cbSize | Size of the DEVICE_INFO struct.
*
*   @field struct _DEVICE_INFO FAR | *lpNextDi | Pointer to the next DEVICE_INFO struct
*   in a linked list.
*
*   @field char | szDescription[LINE_LEN] | Buffer containing the description of the 
*   device.
*
*   @field DWORD | dnDevnode | If set, this contains the address of the DevNode associated
*   with the device.
*
*   @field HKEY | hRegKey | An opened registry key that contains the device's registry
*   subkey.  This is usually HKEY_LOCAL_MACHINE.
*
*   @field char | szRegSubkey[MAX_DEVNODE_ID_LEN] | Buffer containing the device's 
*   hardware registry subkey.  This is key is rooted in hRegKey, and is ususally some 
*   place in the \\ENUM branch.
*
*   @field char | szClassName[MAX_CLASS_NAME_LEN] | Buffer containing the device's
*   class name.
*
*   @field DWORD | Flags | Flags for controlling installation and U/I functions. Some
*   flags can be set prior to calling device installer APIs, and other are set
*   automatically during the processing of some APIs.
*       @flag DI_SHOWOEM                  | Set if OEM disk support should be allowed
*       @flag DI_SHOWCOMPAT               | Will be set if only a compatible driver list
*       is being displayed by DiSelectDevice.
*       @flag DI_SHOWCLASS                | Will be set if only a Class driver list is
*       is being displayed by DiSelectDevice.
*       @flag DI_SHOWALL                  | Will be set if both a compatible driver list
*       and a class driver list are being shown by DiSelectDevice.
*       @flag DI_NOVCP                    | Set if no VCP (Virtual Copy Procedure) is 
*       desired during DiInstallDevice.
*       @flag DI_DIDCOMPAT                | Will be set if DiBuildCompatDrvList has been
*       done, and lpCompatDrvList points to this device's compatible driver list.
*       @flag DI_DIDCLASS                 | Will be set if DiBuildClassDrvList has been
*       done, and lpClassDrvList points to this device's class driver list.
*       @flag DI_AUTOASSIGNRES            | Unused.
*       @flag DI_NEEDRESTART              | Will be set if the device requires a restart
*       of Windows after installation or a state change.
*       @flag DI_NEEDREBOOT               | Will be set if the device requires a reboot
*       of the machine after installation or a state change.
*       @flag DI_NOBROWSE                 | Set to diable browsing when selecting an OEM
*       disk path.
*       @flag DI_MULTMFGS                 | Will be set if a class driver list, or class
*       info list contains multiple manufactures.
*       @flag DI_DISABLED                 | Unused.
*       @flag DI_GENERALPAGE_ADDED        | Set by a property page provider if a general
*       properties page has been added to the device's property sheet.
*       @flag DI_RESOURCEPAGE_ADDED       | Set by a property page provider if a resource
*       properties page has been added to the device's property sheet.
*       @flag DI_PROPERTIES_CHANGE        | Set if a device's properties have been changed
*       and require an update of the Device Manager's U/I.
*       @flag DI_INF_IS_SORTED            | Set if the INF containing drivers for this 
*       device is in sorted order.
*       @flag DI_ENUMSINGLEINF            | Set if DiBuildCompatDrvList and 
*       DiBuildlassDrvList should only search the INF file specificed by atDriverPath.
*       @flag DI_DONOTCALLCONFIGMG        | Set if the configuration manager should not
*       be called during DiInstallDevice.
*       @flag DI_INSTALLDISABLED          | Set if the device should be installed in a 
*       disabled state by default.
*       @flag DI_CLASSONLY                | Set if this DEVICE_INFO struct contains only
*       a class name.
*       @flag DI_CLASSINSTALLPARAMS       | Set if the lpClassIntallParams field points to
*       a class install parameter block.
*       @flag DI_NODI_DEFAULTACTION       | Set if DiCallClassInstaller should not 
*       perform any default action if the class installer return ERR_DI_DO_DEFAULT, or
*       there is not class installer.
*       @flag DI_QUIETINSTALL             | Set if device install API should be as 
*       silent as possible using default choices whereever possible.
*       @flag DI_NOFILECOPY               | Set if DiInstallDevice should skip file
*       copying.
*       @flag DI_FORCECOPY                | Set if DiInstallDevice should always
*       copy file, even if they are present on the system.
*       @flag DI_DRIVERPAGE_ADDED         | Set by a property page provider if a driver
*       properties page has been added to the device's property sheet.
*       @flag DI_USECI_SELECTSTRINGS      | Set if class installer provided strings 
*       should be used during DiSelectDevice.
*       @flag DI_OVERRIDE_INFFLAGS        | Unused.
*       @flag DI_PROPS_NOCHANGEUSAGE      | Set if there should be no Enable/Disable 
*       capability on the device's general property page.
*       @flag DI_NOSELECTICONS            | Set if no small icons should be used during
*       DiSelectDevice.
*       @flag DI_NOWRITE_IDS              | Set if DiInstallDevice should not write
*       the device's hardware and compatible IDs to the registry.
*   
*   @field HWND | hwndParent | Window handle that will own U/I dialogs related to this
*   device.
*
*   @field LPDRIVER_NODE | lpCompatDrvList | Pointer to a linked list of DRIVER_NODES 
*   representing the compatible drivers for this device.
*
*   @field LPDRIVER_NODE | lpClassDrvList | Pointer to a linked list of DRIVER_NODES
*   representing all drivers of this device's class.
*
*   @field LPDRIVER_NODE | lpSelectedDriver | Pointer to a single DRIVER_NODE that
*   has been selected as the driver for this device.
*
*   @field ATOM | atDriverPath | Global ATOM containing the path to this device's INF
*   file.  This is set only of the driver came from an OEM INF file.  This will be
*   0 if the INF is a standard Windows INF file.
*
*   @field ATOM | atTempInfFile | Global ATOM containing the name of a temporary INF
*   file for this device's drivers.  This is set if the drivers came from an old style
*   INF file and have been converted.
*
*   @field HINSTANCE | hinstClassInstaller | Class installer module instance.
*
*   @field HINSTANCE | hinstClassPropProvidor | Class Property Providor module instance.
*
*   @field HINSTANCE | hinstDevicePropProvidor | Device Property Providor module instance.
*
*   @field HINSTANCE | hinstBasicPropProvidor | Basic Property Providor module instance.
*
*   @field FARPROC | fpClassInstaller | Procedure address of class install function.
*
*   @field FARPROC | fpClassEnumPropPages | Procedure address of the Class property 
*   provider page enumeration function.
*
*   @field FARPROC | fpDeviceEnumPropPages | Procedure address of the Device property
*   provider page enumeration function.
*
*   @field FARPROC | fpEnumBasicProperties | Procedure address of the Basic device
*   property provider page enumeration function.
*
*   @field DWORD | dwSetupReserved | Reserved for use by Setup.
*
*   @field DWORD | dwClassInstallReserved | Reserved for use by Class Installers.
*
*   @field GENCALLBACKPROC | gicpGenInstallCallBack | Procedure address of a GenInstall
*   call back function.  This would be set if the class installer wanted to handle
*   GenInstall callbacks during DiInstallDevice.
*
*   @field LPARAM | gicplParam | lParam for the GenInstall Callback.                                                
*
*   @field UINT | InfType | The type of INF file being used.  This will be INFTYPE_TEXT
*   or INFTYPE_EXECUTABLE.
*
*   @field HINSTANCE | hinstPrivateProblemHandler | Module handle for the device's 
*   private problem procedure.
*
*   @field FARPROC | fpPrivateProblemHandler | Procedure address of the device's
*   private problem handler.
*
*   @field LPARAM | lpClassInstallParams | Pointer to a class install parameter block.
*   Class installer parameters are specific to the class install functions.
*
*   @field struct _DEVICE_INFO FAR | *lpdiChildList | Pointer to a linked list of
*   DRIVER_INFO structs representing children of this device.
*
*   @field DWORD | dwFlagsEx | Additional control flags.
*       @flag DI_FLAGSEX_USEOLDINFSEARCH  | Set if INF Search functions should not use 
*       indexed searching.
*       @flag DI_FLAGSEX_AUTOSELECTRANK0  | Set if DiSelectDevice should automatically
*       select rank 0 match drivers.
*       @flag DI_FLAGSEX_CI_FAILED        | Will be set internally if there was a 
*       failure to load or call a class installer.
*       @flag DI_FLAGSEX_DIDINFOLIST      | Will be set if DiBuildCompatDrvInfoList has
*       been called, and this device's compatible driver Info list has been built.
*       @flag DI_FLAGSEX_DIDCOMPATINFO    | Will be set if DiBuildClassDrvInfoList has
*       been called, and this device's class driver Info list has been built.
*       @flag DI_FLAGSEX_FILTERCLASSES    | If set, DiBuildClassDrvList, and 
*       DiBuildClassDrvInfoList will check for Class inclusion filters.  This means
*       devices will not be included in the list, if their class is marked as a
*       NoInstallClass class.
*       @flag DI_FLAGSEX_SETFAILEDINSTALL | If set, then if DiInstallDevice installs
*       a NULL driver, it will also set the FAILEDINSTALL config flag
*       @flag DI_FLAGSEX_DEVICECHANGE | If set, the device manager will rebuild it
*       tree of devices after the device property sheet is closed.
*       @flag DI_FLAGSEX_ALWAYSWRITEIDS | If set, and the flag, DI_NOWRITE_ID is clear
*       (ie that flag takes higher precedance) then always write Hardare and Compat
*       ids, even if they allready exist
*       @flag DI_FLAGSEX_ALLOWEXCLUDEDDRVS | If set, DiSelectDevice will display drivers
*       that have the Exlude From Select state
*       @flag DI_FLAGSEX_NOUIONQUERYREMOVE | If setup, DiInstallDevice will prevent 
*       U/I warnings during a query removal.  Any U/I wanings that would have been
*       displayed will be silently failed.
*   @field LPDRIVER_INFO | lpCompatDrvInfoList | Pointer to a linked list of
*   DRIVER_INFO structs that are compatible with this device.
*
*   @field LPDRIVER_INFO | lpClassDrvInfoList | Pointer to a linked list of 
*   DRIVER_INFO structs representing all drivers for this device's class.
*
*******************************************************************************/
typedef struct _DEVICE_INFO
{
    UINT                        cbSize;
    struct _DEVICE_INFO FAR     *lpNextDi;
    char                        szDescription[LINE_LEN];
    DWORD                       dnDevnode;
    HKEY                        hRegKey;
    char                        szRegSubkey[MAX_DEVNODE_ID_LEN]; 
    char                        szClassName[MAX_CLASS_NAME_LEN];
    DWORD                       Flags;
    HWND                        hwndParent;
    LPDRIVER_NODE               lpCompatDrvList;
    LPDRIVER_NODE               lpClassDrvList;
    LPDRIVER_NODE               lpSelectedDriver;
    ATOM                        atDriverPath;
    ATOM                        atTempInfFile;
    HINSTANCE                   hinstClassInstaller;            
    HINSTANCE                   hinstClassPropProvidor;         
    HINSTANCE                   hinstDevicePropProvidor;        
    HINSTANCE                   hinstBasicPropProvidor;         
    FARPROC                     fpClassInstaller;               
    FARPROC                     fpClassEnumPropPages;           
    FARPROC                     fpDeviceEnumPropPages;          
    FARPROC                     fpEnumBasicProperties;          
    DWORD                       dwSetupReserved;                
    DWORD                       dwClassInstallReserved;         
    GENCALLBACKPROC             gicpGenInstallCallBack;     
                                                
    LPARAM                      gicplParam;     
    UINT                        InfType;        
                                                
    HINSTANCE                   hinstPrivateProblemHandler;
    FARPROC                     fpPrivateProblemHandler;   
    LPARAM                      lpClassInstallParams;      
    struct _DEVICE_INFO FAR     *lpdiChildList;     
    DWORD                       dwFlagsEx;          
    LPDRIVER_INFO               lpCompatDrvInfoList;
    LPDRIVER_INFO               lpClassDrvInfoList;
} DEVICE_INFO, FAR * LPDEVICE_INFO, FAR * FAR * LPLPDEVICE_INFO;

#define ASSERT_DI_STRUC(lpdi) if (lpdi->cbSize != sizeof(DEVICE_INFO)) return (ERR_DI_BAD_DEV_INFO)

typedef struct _CLASS_INFO
{
    UINT        cbSize;
    struct _CLASS_INFO FAR* lpNextCi;
    LPDEVICE_INFO   lpdi;
    char                szDescription[LINE_LEN];
    char        szClassName[MAX_CLASS_NAME_LEN];
} CLASS_INFO, FAR * LPCLASS_INFO, FAR * FAR * LPLPCLASS_INFO;
#define ASSERT_CI_STRUC(lpci) if (lpci->cbSize != sizeof(CLASS_INFO)) return (ERR_DI_BAD_CLASS_INFO)

// flags for device choosing (InFlags)
#define DI_SHOWOEM                  0x00000001L     // support Other... button
#define DI_SHOWCOMPAT               0x00000002L     // show compatibility list
#define DI_SHOWCLASS                0x00000004L     // show class list
#define DI_SHOWALL                  0x00000007L
#define DI_NOVCP                    0x00000008L     // Don't do vcpOpen/vcpClose.
#define DI_DIDCOMPAT                0x00000010L     // Searched for compatible devices
#define DI_DIDCLASS                 0x00000020L     // Searched for class devices
#define DI_AUTOASSIGNRES            0x00000040L    // No UI for resources if possible

// flags returned by DiInstallDevice to indicate need to reboot/restart
#define DI_NEEDRESTART              0x00000080L     // Restart required to take effect
#define DI_NEEDREBOOT               0x00000100L     // Reboot required to take effect

// flags for device installation
#define DI_NOBROWSE                 0x00000200L     // no Browse... in InsertDisk

// Flags set by DiBuildClassDrvList
#define DI_MULTMFGS                 0x00000400L     // Set if multiple manufacturers in
                                                    // class driver list
// Flag indicates that device is disabled
#define DI_DISABLED                 0x00000800L     // Set if device disabled

// Flags for Device/Class Properties
#define DI_GENERALPAGE_ADDED        0x00001000L
#define DI_RESOURCEPAGE_ADDED       0x00002000L

// Flag to indicate the setting properties for this Device (or class) caused a change
// so the Dev Mgr UI probably needs to be updatd.
#define DI_PROPERTIES_CHANGE        0x00004000L

// Flag to indicate that the sorting from the INF file should be used.
#define DI_INF_IS_SORTED            0x00008000L

#define DI_ENUMSINGLEINF            0x00010000L

// The following flags can be used to install a device disabled
// and to prevent CONFIGMG being called when a device is installed
#define DI_DONOTCALLCONFIGMG        0x00020000L
#define DI_INSTALLDISABLED          0x00040000L

// This flag is set of this LPDI is really just an LPCI, ie
// it only contains class info, NO DRIVER/DEVICE INFO
#define DI_CLASSONLY                0x00080000L

// This flag is set if the Class Install params are valid
#define DI_CLASSINSTALLPARAMS       0x00100000L

// This flag is set if the caller of DiCallClassInstaller does NOT
// want the internal default action performed if the Class installer
// return ERR_DI_DO_DEFAULT
#define DI_NODI_DEFAULTACTION       0x00200000L

// This is a hack for M6 Net setup.  Net Setup does not work correctly
// if we process devnode syncronously.  This WILL be removed for M7 when
// Net setup is fixed to work with DiInstallDevice
#define DI_NOSYNCPROCESSING         0x00400000L

// flags for device installation
#define DI_QUIETINSTALL             0x00800000L     // don't confuse the user with
                                                    // questions or excess info
#define DI_NOFILECOPY               0x01000000L     // No file Copy necessary
#define DI_FORCECOPY                0x02000000L     // Force files to be copied from install path
#define DI_DRIVERPAGE_ADDED         0x04000000L     // Prop providor added Driver page.
#define DI_USECI_SELECTSTRINGS      0x08000000L     // Use Class Installer Provided strings in the Select Device Dlg
#define DI_OVERRIDE_INFFLAGS        0x10000000L     // Override INF flags
#define DI_PROPS_NOCHANGEUSAGE      0x20000000L     // No Enable/Disable in General Props

#define DI_NOSELECTICONS	    0x40000000L     // No small icons in select device dialogs

#define DI_NOWRITE_IDS		    0x80000000L     // Don't write HW & Compat IDs on install

#define DI_FLAGSEX_USEOLDINFSEARCH  0x00000001L  // Inf Search functions should not use Index Search
#define DI_FLAGSEX_AUTOSELECTRANK0  0x00000002L  // DiSelectDevice doesn't propmt user if rank 0 match
#define DI_FLAGSEX_CI_FAILED        0x00000004L  // Failed to Load/Call class installer

#define DI_FLAGSEX_DIDINFOLIST      0x00000010L  // Did the Class Info List
#define DI_FLAGSEX_DIDCOMPATINFO    0x00000020L  // Did the Compat Info List

#define DI_FLAGSEX_FILTERCLASSES        0x00000040L
#define DI_FLAGSEX_SETFAILEDINSTALL     0x00000080L
#define DI_FLAGSEX_DEVICECHANGE         0x00000100L
#define DI_FLAGSEX_ALWAYSWRITEIDS       0x00000200L
#define DI_FLAGSEX_ALLOWEXCLUDEDDRVS    0x00000800L
#define DI_FLAGSEX_NOUIONQUERYREMOVE    0x00001000L

// Defines for class installer functions
#define DIF_SELECTDEVICE            0x0001
#define DIF_INSTALLDEVICE           0x0002
#define DIF_ASSIGNRESOURCES         0x0003
#define DIF_PROPERTIES              0x0004
#define DIF_REMOVE                  0x0005
#define DIF_FIRSTTIMESETUP          0x0006
#define DIF_FOUNDDEVICE             0x0007
#define DIF_SELECTCLASSDRIVERS      0x0008
#define DIF_VALIDATECLASSDRIVERS    0x0009
#define DIF_INSTALLCLASSDRIVERS     0x000A
#define DIF_CALCDISKSPACE           0x000B
#define DIF_DESTROYPRIVATEDATA      0x000C
#define DIF_VALIDATEDRIVER          0x000D
#define DIF_MOVEDEVICE              0x000E
#define DIF_DETECT                  0x000F
#define DIF_INSTALLWIZARD           0x0010
#define DIF_DESTROYWIZARDDATA       0x0011
#define DIF_PROPERTYCHANGE          0x0012
#define DIF_ENABLECLASS             0x0013
#define DIF_DETECTVERIFY            0x0014
#define DIF_INSTALLDEVICEFILES      0x0015

typedef UINT        DI_FUNCTION;    // Function type for device installer

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    ENABLECLASS_PARAMS | DIF_ENABLECLASS class install parameters
*
*   @field UINT | cbSize | Size of the ENABLECLASS_PARAMS struct.
*
*   @field LPSTR | szClass | The class that is being enabled.
*
*   @field WORD | wEnableMsg | Specifies the stage of enabling.
*   Can be one of:
*
*   @const ENABLECLASS_QUERY | The class is about to be enabled.  Return
*   ERR_DI_DO_DEFAULT to allow the class to be enabled, or ERR_DI_FAIL_QUERY
*   to prevent the class from being enabled.
*
*   @const ENABLECLASS_SUCCESS | The enabling of the class has succeeded,
*   return ERR_DI_DO_DEFAULT.
*
*   @const ENABLECLASS_FAILURE | The enabling of the class has failed,
*   return ERR_DI_DO_DEFAULT.
*
*******************************************************************************/
// DIF_ENABLECLASS parameter struct.
typedef struct _ENABLECLASS_PARAMS
{
    UINT            cbSize;
    LPSTR           szClass;
    WORD            wEnableMsg;
} ENABLECLASS_PARAMS, FAR * LPENABLECLASS_PARAMS;
#define ASSERT_ENABLECLASSPARAMS_STRUC(lpecp) if (lpecp->cbSize != sizeof(ENABLECLASS_PARAMS)) return (ERR_DI_BAD_ENABLECLASS_PARAMS)

#define ENABLECLASS_QUERY   0
#define ENABLECLASS_SUCCESS 1
#define ENABLECLASS_FAILURE 2

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    MOVEDEV_PARAMS | DIF_MOVEDEVICE class install parameters
*
*   @field UINT | cbSize | Size of the MOVDEV_PARAMS struct.
*
*   @field LPDEVICE_INFO | lpdiOldDev  | Pointer to the device that is being 
*   moved.
*
*******************************************************************************/
typedef struct _MOVEDEV_PARAMS
{
    UINT            cbSize;
    LPDEVICE_INFO   lpdiOldDev;     // References the Device Begin Moved
} MOVEDEV_PARAMS, FAR * LPMOVEDEV_PARAMS;
#define ASSERT_MOVEDEVPARAMS_STRUC(lpmdp) if (lpmdp->cbSize != sizeof(MOVEDEV_PARAMS)) return (ERR_DI_BAD_MOVEDEV_PARAMS)

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    PROPCHANGE_PARAMS | DIF_PROPCHANGE class install parameters
*
*   @field UINT | cbSize | Size of the PROPCHANGE_PARAMS struct.
*
*   @field DWORD | dwStateChange | State change action. See DiChangeState for details.
*
*   @field DWORD | dwFlags | Flags specific to the type of state change.
*
*   @field DWORD | dwConfigID | Configuration ID for config specific changes.
*
*   @xref DiChangeState.
*
*******************************************************************************/
typedef struct _PROPCHANGE_PARAMS
{
    UINT            cbSize;
    DWORD           dwStateChange;
    DWORD           dwFlags;
    DWORD           dwConfigID;
} PROPCHANGE_PARAMS, FAR * LPPROPCHANGE_PARAMS;
#define ASSERT_PROPCHANGEPARAMS_STRUC(lpmdp) if (lpmdp->cbSize != sizeof(PROPCHANGE_PARAMS)) return (ERR_DI_BAD_PROPCHANGE_PARAMS)

#define MAX_TITLE_LEN           60
#define MAX_INSTRUCTION_LEN     256
#define MAX_LABEL_LEN           30
/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    SELECTDEVICE_PARAMS | DIF_SELECTDEVICE class install parameters
*
*   @field UINT | cbSize | Size of the SELECTDEVICE_PARAMS struct.
*
*   @field char | szTitle[MAX_TITLE_LEN] | Buffer containing a class installer
*   provided title for the Select Device dialogs.
*
*   @field char | szInstructions[MAX_INSTRUCTION_LEN] |  Buffer containing 
*   class installer provided Select Device instructions.
*
*   @field char | szListLabel[MAX_LABEL_LEN] | Buffer containing a lable
*   of the Select Device list of drivers.
*
*******************************************************************************/
typedef struct _SELECTDEVICE_PARAMS
{
    UINT            cbSize;
    char            szTitle[MAX_TITLE_LEN];
    char            szInstructions[MAX_INSTRUCTION_LEN];
    char            szListLabel[MAX_LABEL_LEN];
} SELECTDEVICE_PARAMS, FAR * LPSELECTDEVICE_PARAMS;
#define ASSERT_SELECTDEVICEPARAMS_STRUC(p) if (p->cbSize != sizeof(SELECTDEVICE_PARAMS)) return (ERR_DI_BAD_SELECTDEVICE_PARAMS)

#define DI_REMOVEDEVICE_GLOBAL                  0x00000001
#define DI_REMOVEDEVICE_CONFIGSPECIFIC          0x00000002
/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    REMOVEDEVICE_PARAMS | DIF_REMOVE class install parameters
*
*   @field UINT | cbSize | Size of the REMOVEDEVICE_PARAMS struct.
*
*   @field DWORD | dwFlags | Flags indicating the type of removal to perform.
*       @flag DI_REMOVEDEVICE_GLOBAL         | The device will be removed globally.
*       @flag DI_REMOVEDEVICE_CONFIGSPECIFIC | The device will be removed from only
*       the specified configuration.
*
*   @field DWORD | dwConfigID |  If DI_REMOVEDEVICE_CONFIGSPECIFIC is set, then
*   this is the configuration the device will be removed from. 0 means the current
*   config.
*
*******************************************************************************/
typedef struct _REMOVEDEVICE_PARAMS
{
    UINT            cbSize;
    DWORD           dwFlags;
    DWORD           dwConfigID;
} REMOVEDEVICE_PARAMS, FAR * LPREMOVEDEVICE_PARAMS;
#define ASSERT_REMOVEDPARAMS_STRUC(p) if (p->cbSize != sizeof(REMOVEDEVICE_PARAMS)) return (ERR_DI_BAD_REMOVEDEVICE_PARAMS)

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @type NONE | Dynamic Hardware Install Wizard Constants | Constants that are
*   used when adding custom pages to the hardware install wizard.
*
*   @const MAX_INSTALLWIZARD_DYNAPAGES | The maximum number of dynamic hardware 
*   installation wizard pages that can be added by a class installer.
*
*   @const IDD_DYNAWIZ_FIRSTPAGE | Resource ID for the first page that the install 
*   wizard will go to after adding the class installer pages.
*
*   @const IDD_DYNAWIZ_SELECT_PREVPAGE | Resource ID for the page that the Select 
*   Device page will go back to.
*
*   @const IDD_DYNAWIZ_SELECT_NEXTPAGE | Resource ID for the page that the Select 
*   Device page will go forward to.
*
*   @const IDD_DYNAWIZ_ANALYZE_PREVPAGE | Resource ID for the page that the Analyze 
*   page will go back to. This will only be used in the event that there is a 
*   problem (i.e a conflict), and the user selects Back from the analyze page.
*
*   @const IDD_DYNAWIZ_ANALYZE_NEXTPAGE | Resource ID for the page that the Analyze 
*   page will go to if it continues forward.  The wAnalyzeResult in the 
*   INSTALLWIZARDDATA struct will contain the anaysis results.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE | Resource ID for that page that the
*   Install detected devices page will go back to.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE | Resource ID for the page that the
*   Install detected devices page will go forward to.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_NODEVS | Resource ID for the page that the
*   Install detected devices page will go to in the event that no devices are 
*   detected.
*
*   @const IDD_DYNAWIZ_SELECTDEV_PAGE | Resource ID of the hardware install wizard's
*   select device page.  This ID can be used to go directly to the hardware install
*   wizard's select device page.
*
*   @const IDD_DYNAWIZ_ANALYZEDEV_PAGE | Resource ID of the hardware install wizard's
*   device analysis page.  This ID can be use to go directly to the hardware install
*   wizard's analysis page.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE | Resource ID of the hardware install
*   wizard's install detected devices page.  This ID can be use to go directly to
*   the hardware install wizard's install detected devices page.
*
*   @const IDD_DYNAWIZ_SELECTCLASS_PAGE | Resource ID of the hardware install wizard's
*   select class page.  This ID can be use to go directly to the hardware install 
*   wizard's select class page.
*
*******************************************************************************/
// DIF_INSTALLWIZARD  Wizard Data
#define MAX_INSTALLWIZARD_DYNAPAGES             20

// Use this ID for the first page that the install wizard should dynamically jump to.
#define IDD_DYNAWIZ_FIRSTPAGE                   10000

// Use this ID for the page that the Select Device dialog should go back to
#define IDD_DYNAWIZ_SELECT_PREVPAGE             10001

// Use this ID for the page that the Select Device dialog should go to next
#define IDD_DYNAWIZ_SELECT_NEXTPAGE             10002
               
// Use this ID for the page that the Analyze dialog should go back to
// This will only be used in the event that there is a problem, and the user
// selects Back from the analyze proc.
#define IDD_DYNAWIZ_ANALYZE_PREVPAGE            10003

// Use this ID for the page that the Analyze dialog should go to if it continue from
// the analyze proc.  the wAnalyzeResult in the INSTALLDATA struct will
// contain the anaysis results.
#define IDD_DYNAWIZ_ANALYZE_NEXTPAGE            10004

// This dialog will be selected if the user chooses back from the
// Install Detected Devices dialog.
#if 0 // generates warnings during compile
#define IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE    10006
#else
#define IDD_DYNAWIZ_INSDETECT_PREVPAGE    10006
#endif

// This dialog will be selected if the user chooses Next from the
// Install Detected Devices dialog.
#if 0 // generates warnings during compile
#define IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE    10007
#else
#define IDD_DYNAWIZ_INSDETECT_NEXTPAGE    10007
#endif

// This is the ID of the dialog to select if detection does not
// find any new devices
#if 0 // generates warnings during compile
#define IDD_DYNAWIZ_INSTALLDETECTED_NODEVS      10008
#else
#define IDD_DYNAWIZ_INSDETECT_NODEVS      10008
#endif

// This is the ID of the Select Device Wizard page.
#define IDD_DYNAWIZ_SELECTDEV_PAGE              10009

// This is the ID of the Analyze Device Wizard page.
#define IDD_DYNAWIZ_ANALYZEDEV_PAGE             10010

// This is the ID of the Install Detected Devs Wizard page.
#if 0 // generates warnings during compile
#define IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE    10011
#else
#define IDD_DYNAWIZ_INSDETECTDEVS_PAGE    10011
#endif

// This is the ID of the Select Class Wizard page.
#define IDD_DYNAWIZ_SELECTCLASS_PAGE            10012

// This flag is set if a Class installer has added pages to the
// install wizard.
#define DYNAWIZ_FLAG_PAGESADDED             0x00000001

// The following flags will control the button states when displaying
// the InstallDetectedDevs dialog.  
#define DYNAWIZ_FLAG_INSTALLDET_NEXT        0x00000002
#define DYNAWIZ_FLAG_INSTALLDET_PREV        0x00000004

// Set this flag if you jump to the analyze page, and want it to
// handle conflicts for you.  NOTE.  You will not get control back 
// in the event of a conflict if you set this flag.
#if 0 // generates warnings during compile
#define DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT 0x00000008
#else
#define DYNAWIZ_FLAG_ANALYZE_HCONFLICT 0x00000008
#endif

#define ANALYZE_FACTDEF_OK      1
#define ANALYZE_STDCFG_OK       2
#define ANALYZE_CONFLICT        3
#define ANALYZE_NORESOURCES     4
#define ANALYZE_ERROR           5
#define ANALYZE_PNP_DEV         6
#define ANALYZE_PCMCIA_DEV      7

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    INSTALLWIZARDDATA | DIF_INSTALLWIZARD class install parameters. This
*   struct is used by class installers to extend the operation of the hardware
*   installation wizard by adding custom pages.
*
*   @field UINT | cbSize | Size of the INSTALLWIZARDDATA struct.
*
*   @field LPDEVICE_INFO | lpdiOriginal | Pointer to the Original DEVICE_INFO
*   struct at the start of the manual installation.
*
*   @field LPDEVICE_INFO | lpdiSelected | Pointer to the current DEVICE_INFO struct
*   that is being manually selected.
*
*   @field DWORD | dwFlags | Flags that control the operation of the hardware
*   installation wizard.  There are currently none defined.
*
*   @field LPVOID | lpConfigData | Pointer to configuration data for analysis to
*   determine if the selected device can be installed with no conflicts.
*
*   @field WORD | wAnalyzeResult | Results of analysis to determine if the device
*   can be installed with no problems.  The following values are defined:
*       @flag ANALYZE_FACTDEF_OK    | The device can be installed using its factory
*       default settings.
*       @flag ANALYZE_STDCFG_OK     | The device can be installed using a configuration
*       specified in one if its basic logical configurations.  The user will probably
*       have to set jumpers or switches on the hardware to match the settings determined
*       by the install wizard.
*       @flag ANALYZE_CONFLICT      | The device cannot be installed without causing a
*       conflict with another device.
*       @flag ANALYZE_NORESOURCES   | The device does not require any resources, so it
*       can be installed witth no conflicts.
*       @flag ANALYZE_ERROR         | There was an error during analysis.
*       @flag ANALYZE_PNP_DEV       | The device has a least one softsettable logical
*       configurations, allowing it to be automatically configured.  Additionally the
*       device will be enumerated by one of the standard bus enumerators, so it does
*       not require manual installation, except to pre-copy driver files.
*
*   @field HPROPSHEETPAGE | hpsDynamicPages[MAX_INSTALLWIZARD_DYNAPAGES] | An
*   array of property sheet page handles.  The class installer would use this array
*   to create custom wizard pages, and insert their handles into this array.
*
*   @field WORD | wNumDynaPages | The number of pages inserted into the hpsDynamicPages
*   array.
*
*   @field DWORD | dwDynaWizFlags | Flags that control the behavior of the
*   installation wizard whtn dynamic pages have been added.
*       @flag DYNAWIZ_FLAG_PAGESADDED | Will be set by the install wizard if the
*       class installer adds custom pages.
*       @flag DYNAWIZ_FLAG_INSTALLDET_NEXT | If set, the install wizard will allow
*       going forward from the detected devices page, otherwise finish will
*       be the default option for the detected devices page.
*       @flag DYNAWIZ_FLAG_INSTALLDET_PREV | If set, the install wizard will allow
*       going back from the detected devices page.
*       @flag DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT | If set, the class installer will 
*       handle the case where the selected device cannot be installed because of
*       a conflict.
*
*   @field DWORD | dwPrivateFlags | Flags that may be defined and used by the class
*   installer.
*
*   @field LPARAM | lpPrivateData | Pointer to private reference data defined and
*   set by the class installer.
*
*   @field LPSTR | lpExtraRunDllParams | Pointer to a string containing extra 
*   parameters passed to the hardware install rundll function.
*
*   @field HWND | hwndWizardDlg | Window handle of the install wizard top level 
*   window.
*
*******************************************************************************/
typedef struct InstallWizardData_tag        
{
    UINT                    cbSize;
    
    LPDEVICE_INFO           lpdiOriginal;
    LPDEVICE_INFO           lpdiSelected;
    DWORD                   dwFlags;
    LPVOID                  lpConfigData;
    WORD                    wAnalyzeResult;
        
    // The following fields are used when a Class Installer Extends the Install Wizard
    HPROPSHEETPAGE          hpsDynamicPages[MAX_INSTALLWIZARD_DYNAPAGES];
    WORD                    wNumDynaPages;
    DWORD                   dwDynaWizFlags;
    DWORD                   dwPrivateFlags;
    LPARAM                  lpPrivateData;
    LPSTR                   lpExtraRunDllParams;    
    HWND                    hwndWizardDlg;
} INSTALLWIZDATA, * PINSTALLWIZDATA , FAR *LPINSTALLWIZDATA;

RETERR WINAPI DiCreateDeviceInfo(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszDescription,    // If non-null then description string
    DWORD       hDevnode,       // MAKE A DEVNODE
    HKEY        hkey,       // Registry hkey for dev info
    LPCSTR      lpszRegsubkey,  // If non-null then reg subkey string
    LPCSTR      lpszClassName,  // If non-null then class name string
    HWND        hwndParent);    // If non-null then hwnd of parent

RETERR WINAPI DiGetClassDevs(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszClassName,  // Must be name of class
    HWND        hwndParent,     // If non-null then hwnd of parent
    int         iFlags);        // Options

RETERR WINAPI DiGetClassDevsEx(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszClassName,  // Must be name of class
    LPCSTR      lpszEnumerator, // Must be name of enumerator, or NULL
    HWND        hwndParent,     // If non-null then hwnd of parent
    int         iFlags);        // Options
    
#define DIGCF_DEFAULT           0x0001  // NOT IMPLEMENTED!
#define DIGCF_PRESENT           0x0002
#define DIGCF_ALLCLASSES        0x0004
#define DIGCF_PROFILE           0x0008

// API to return the Class name of an INF File
RETERR WINAPI DiGetINFClass(LPSTR lpszMWDPath, UINT InfType, LPSTR lpszClassName, DWORD dwcbClassName);

RETERR WINAPI PASCAL DiCreateDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    HINF        hinf,
    LPCSTR      lpszInfSection,
    int         iFlags);
    
RETERR WINAPI PASCAL DiDeleteDevRegKey(LPDEVICE_INFO lpdi, int  iFlags);

RETERR WINAPI PASCAL DiOpenDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    int         iFlags);

#define DIREG_DEV	0x0001		// Open/Create/Delete device key
#define DIREG_DRV	0x0002		// Open/Create/Delete driver key
#define DIREG_BOTH	0x0004		// Delete both driver and Device key

RETERR WINAPI DiReadRegLogConf
(
    LPDEVICE_INFO       lpdi,
    LPSTR               lpszConfigName,
    LPBYTE FAR          *lplpbLogConf,
    LPDWORD             lpdwSize
);

RETERR WINAPI DiReadRegConf
(
    LPDEVICE_INFO       lpdi,
    LPBYTE FAR          *lplpbLogConf,
    LPDWORD             lpdwSize,
    DWORD               dwFlags
);

#define DIREGLC_FORCEDCONFIG        0x00000001
#define DIREGLC_BOOTCONFIG          0x00000002

RETERR WINAPI DiCopyRegSubKeyValue
(
    HKEY    hkKey,
    LPSTR   lpszFromSubKey,
    LPSTR   lpszToSubKey,
    LPSTR   lpszValueToCopy
);

RETERR WINAPI DiDestroyClassInfoList(LPCLASS_INFO lpci);
RETERR WINAPI DiBuildClassInfoList(LPLPCLASS_INFO lplpci);

#define DIBCI_NOINSTALLCLASS        0x000000001
#define DIBCI_NODISPLAYCLASS        0x000000002

RETERR WINAPI DiBuildClassInfoListEx(LPLPCLASS_INFO lplpci, DWORD dwFlags);
RETERR WINAPI DiGetDeviceClassInfo(LPLPCLASS_INFO lplpci, LPDEVICE_INFO lpdi);

RETERR WINAPI DiDestroyDeviceInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiSelectDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiSelectOEMDrv(HWND hDlg, LPDEVICE_INFO lpdi);

// Callback for diInstallDevice vcpOpen.  Basically calls vcpUICallback for everthing
// except when DI_FORCECOPY is active, in which case copies get defaulted to
// VCPN_FORCE
LRESULT CALLBACK diInstallDeviceUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);
RETERR WINAPI DiInstallDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiInstallDriverFiles(LPDEVICE_INFO lpdi);

RETERR WINAPI DiRemoveDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiAskForOEMDisk(LPDEVICE_INFO lpdi);

RETERR WINAPI DiCallClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);

BOOL WINAPI DiBuildDriverIndex(BOOL bUI);
BOOL WINAPI DiAddSingleInfToDrvIdx(LPSTR lpszInfName, WORD InfType, BOOL bCreate);

RETERR WINAPI DiBuildCompatDrvList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildClassDrvList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildCompatDrvInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildClassDrvInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiDestroyDrvInfoList(LPDRIVER_INFO lpInfo);
LPDRIVER_NODE WINAPI DiConvertDriverInfoToDriverNode(LPDEVICE_INFO lpdi, LPDRIVER_INFO lpInfo);    

typedef RETERR (CALLBACK *OLDINFPROC)(HINF hinf, LPCSTR lpszNewInf, LPARAM lParam);
RETERR WINAPI DiBuildClassDrvListFromOldInf(LPDEVICE_INFO lpdi, LPCSTR lpszSection, OLDINFPROC lpfnOldInfProc, LPARAM lParam);

RETERR WINAPI DiDestroyDriverNodeList(LPDRIVER_NODE lpdn);

RETERR  WINAPI  DiMoveDuplicateDevNode(LPDEVICE_INFO lpdiNewDev);

// The following export will load a dll and find the specified proc name
typedef RETERR (FAR PASCAL *DIINSTALLERPROPERTIES)(LPDEVICE_INFO);

RETERR WINAPI GetFctn(HKEY hk, LPSTR lpszRegVal, LPSTR lpszDefProcName,
                      HINSTANCE FAR * lphinst, FARPROC FAR *lplpfn);
                        
RETERR
WINAPI
DiCreateDriverNode(
    LPLPDRIVER_NODE lplpdn,
    UINT    Rank,
    UINT    InfType,
    unsigned    InfDate,
    LPCSTR  lpszDevDescription,
    LPCSTR  lpszDrvDescription,
    LPCSTR  lpszProviderName,
    LPCSTR  lpszMfgName,
    LPCSTR  lpszInfFileName,
    LPCSTR  lpszSectionName,
    DWORD   dwPrivateData);

RETERR WINAPI DiLoadClassIcon(
    LPCSTR  szClassName,
    HICON FAR *lphiLargeIcon,
    int FAR *lpiMiniIconIndex);

RETERR WINAPI DiInstallDrvSection(
    LPCSTR  lpszInfFileName,
    LPCSTR  lpszSection,
    LPCSTR  lpszClassName,
    LPCSTR  lpszDescription,
    DWORD   dwFlags);

RETERR WINAPI DiChangeState(LPDEVICE_INFO lpdi, DWORD dwStateChange, DWORD dwFlags, LPARAM lParam);

#define DICS_ENABLE                 0x00000001
#define DICS_DISABLE                0x00000002
#define DICS_PROPCHANGE 	    0x00000003
#define DICS_START		    0x00000004
#define DICS_STOP		    0x00000005

#define DICS_FLAG_GLOBAL            0x00000001
#define DICS_FLAG_CONFIGSPECIFIC    0x00000002
#define DICS_FLAG_CONFIGGENERAL     0x00000004

RETERR WINAPI DiInstallClass(LPCSTR lpszInfFileName, DWORD dwFlags);

RETERR WINAPI DiOpenClassRegKey(LPHKEY lphk, LPCSTR lpszClassName);

// support routine for dealing with class mini icons
#define DMI_MASK            0x0001
#define DMI_BKCOLOR         0x0002
#define DMI_USERECT         0x0004
int WINAPI PASCAL DiDrawMiniIcon(HDC hdc, RECT rcLine, int iMiniIcon, DWORD flags);
BOOL WINAPI DiGetClassBitmapIndex(LPCSTR lpszClass, int FAR *lpiMiniIconIndex);

// internal calls for display class
#define DISPLAY_SETMODE_SUCCESS     0x0001
#define DISPLAY_SETMODE_DRVCHANGE   0x0002
#define DISPLAY_SETMODE_FONTCHANGE  0x0004

UINT WINAPI Display_SetMode(LPDEVICE_INFO lpdi, UINT uColorRes, int iXRes, int iYRes);
RETERR WINAPI Display_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
RETERR WINAPI Display_OpenFontSizeKey(LPHKEY lphkFontSize);
BOOL WINAPI Display_SetFontSize(LPCSTR lpszFontSize);

RETERR WINAPI DiIsThereNeedToCopy(HWND hwnd, DWORD dwFlags);

#define DINTC_NOCOPYDEFAULT	    0x00000001

// API for the mouse class installer
RETERR WINAPI Mouse_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
#endif // NODEVICEINSTALL

// API for determining if a Driver file is currently part of VMM32.VxD
BOOL WINAPI bIsFileInVMM32
(
    LPSTR   lpszFileName
);

#ifndef NOUSERINTERFACE
/***************************************************************************/
//
// User Interface prototypes and definitions
//
/***************************************************************************/

BOOL WINAPI UiMakeDlgNonBold(HWND hDlg);
VOID WINAPI UiDeleteNonBoldFont(HWND hDlg);

#endif

/***************************************************************************/
//
// setup reg DB calls, use just like those in kernel
//
/***************************************************************************/

DWORD WINAPI SURegOpenKey(HKEY hKey, LPCSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegCloseKey(HKEY hKey);
DWORD WINAPI SURegCreateKey(HKEY hKey, LPCSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegDeleteKey(HKEY hKey, LPCSTR lpszSubKey);
DWORD WINAPI SURegEnumKey(HKEY hKey, DWORD dwIdx, LPSTR lpszBuffer, DWORD dwBufSize);
DWORD WINAPI SURegQueryValue16(HKEY hKey, LPCSTR lpszSubKey, LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValue16(HKEY hKey, LPCSTR lpszSubKey, DWORD dwType, LPCBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegDeleteValue(HKEY hKey,LPCSTR lpszValue);
DWORD WINAPI SURegEnumValue(HKEY hKey,DWORD dwIdx, LPCSTR lpszValue, DWORD FAR *lpcbValue, DWORD FAR *lpdwReserved, DWORD FAR *lpdwType, LPBYTE lpbData, DWORD FAR *lpcbData);
DWORD WINAPI SURegQueryValueEx(HKEY hKey,LPCSTR lpszValueName, DWORD FAR *lpdwReserved,DWORD FAR *lpdwType,LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValueEx(HKEY hKey,LPCSTR lpszValueName, DWORD dwReserved, DWORD dwType, LPBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegSaveKey(HKEY hKey, LPCSTR lpszFileName, LPVOID lpsa);
DWORD WINAPI SURegLoadKey(HKEY hKey, LPCSTR lpszSubKey, LPCSTR lpszFileName);
DWORD WINAPI SURegUnLoadKey(HKEY hKey, LPCSTR lpszSubKey);

DWORD WINAPI SURegFlush(VOID);
DWORD WINAPI SURegInit(VOID);    // should be called before any other Reg APIs

/***************************************************************************/
// setup FormatMessage support
/***************************************************************************/
#define MB_LOG  (UINT)-1
#define MB_DBG  (UINT)-2

UINT FAR CDECL suFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
    ...);
UINT WINAPI suvFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
    LPVOID FAR * lpArgs);
int WINCAPI _loadds suFormatMessageBox(HINSTANCE hAppInst, HWND hwndParent, LPCSTR lpcText, LPCSTR lpcTitle,
    UINT uStyle, ...);

WORD WINAPI suErrorToIds( WORD Value, WORD Class );

/***************************************************************************/
// setup Version Conflict support
/***************************************************************************/

LPVOID WINAPI suVerConflictInit(BOOL fYesToLangMismatch);
void WINAPI suVerConflictTerm(LPVOID lpvData);
LRESULT WINAPI suVerConflict(HWND hwnd, LPVCPVERCONFLICT lpvc, LPVOID lpvData);
int WINAPI sxCompareDosAppVer( LPCSTR lpszOldFileSpec, LPCSTR lpszNewFileSpec);

/***************************************************************************/
// setup Help support
/***************************************************************************/

BOOL WINAPI suHelp( HWND hwndApp, HWND hwndDlg );

//***************************************************************************/
// setup Emergency Boot Disk (EBD) creation fn.
//***************************************************************************/

RETERR WINAPI suCreateEBD( HWND hWnd, VIFPROC CopyCallbackProc, LPARAM lpuii );

//***************************************************************************
// Misc SETUPX.DLL support functions.
//***************************************************************************
#ifdef  NEC_98                         // for support AT Boot
#endif  //NEC_98

RETERR WINAPI SUGetSetSetupFlags(LPDWORD lpdwFlags, BOOL bSet);

RETERR WINAPI CfgSetupMerge( int uFlags );
BOOL WINAPI sxIsMSDOS7Running();

#ifndef LPLPSTR
    typedef LPSTR (FAR *LPLPSTR);
#endif

//***************************************************************************
//
// ENUMS for accessing config.sys/autoexec.bat line objects using the
// array returned by ParseConfigLine()..
//
//***************************************************************************

enum    CFGLINE_STRINGS                     // Config.sys/autoexec.bat objects
{
    CFG_KEYLEAD,                            // Keyword leading whitespaces
    CFG_KEYWORD,                            // Keyword
    CFG_KEYTRAIL,                           // Keyword trailing delimiters
    CFG_UMBINFO,                            // Load high info
    CFG_DRVLETTER,                          // Drive letter for cmd path
    CFG_PATH,                               // Command path
    CFG_COMMAND,                            // Command base name
    CFG_EXT,                                // Command extension including '.'
    CFG_ARGS,                               // Command arguments
    CFG_FREE,                               // Free area at end of buffer
    CFG_END
};

/*---------------------------------------------------------------------------*
 *                  SUB String Data 
 *---------------------------------------------------------------------------*/

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    SUBSTR_DATA | Data structure used to manage substrings.
*   struct is used by class installers to extend the operation of the hardware
*   installation wizard by adding custom pages.
*
*   @field LPSTR | lpFirstSubstr | Pointer to the first substring in the list.
*
*   @field LPSTR | lpCurSubstr | Pointer to the current substring in the list.
*
*   @field LPSTR | lpLastSubstr | Pointer to the last substring in the list.
*
*   @xref InitSubstrData
*   @xref GetFirstSubstr
*   @xref GetNextSubstr
*
*******************************************************************************/
typedef struct _SUBSTR_DATA {
    LPSTR lpFirstSubstr;
    LPSTR lpCurSubstr;
    LPSTR lpLastSubstr;
}   SUBSTR_DATA;

typedef SUBSTR_DATA*		PSUBSTR_DATA;
typedef SUBSTR_DATA NEAR*	NPSUBSTR_DATA;
typedef SUBSTR_DATA FAR*	LPSUBSTR_DATA;

BOOL WINAPI InitSubstrData(LPSUBSTR_DATA lpSubstrData, LPSTR lpStr);
BOOL WINAPI GetFirstSubstr(LPSUBSTR_DATA lpSubstrData);
BOOL WINAPI GetNextSubstr(LPSUBSTR_DATA lpSubStrData);

BOOL WINAPI FirstBootMoveToDOSSTART(LPSTR lpszCmd, BOOL fRemark);
BOOL WINAPI DOSOptEnableCurCfg(LPCSTR lpszOptKey);

/*---------------------------------------------------------------------------*
 *                  Misc. Di functions
 *---------------------------------------------------------------------------*/
BOOL WINAPI DiBuildPotentialDuplicatesList
(
    LPDEVICE_INFO   lpdi, 
    LPSTR           lpDuplicateList, 
    DWORD           cbSize,
    LPDWORD         lpcbData,
    LPSTR           lpstrDupType
);

// PID
BOOL _loadds WINAPI PidConstruct( LPSTR lpszProductType, LPSTR lpszPID, LPSTR lpszUPI, int iAction);
BOOL _loadds WINAPI PidValidate( LPSTR lpszProductType, LPSTR lpszPID);
int _loadds WINAPI WriteDMFBootData(int iDrive, LPSTR pData, int cb);

//***************************************************************************
#endif      // SETUPX_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\printer.h ===
/*  printer.h
    contains the definitions of the functions in _SORT,
       _BRUTE, _SPOOL.
*/

#ifdef OLDWAY

#define PASCAL
#define LONG        long
#define NULL        0
#define TRUE        1
#define FALSE       0
#define ERROR       (-1)
#define FAR  far
#define NEAR near
#define VOID void
#define REGISTER    register


/* file IO flags */

#define O_RDONLY        0x0000
#define O_WRONLY        0x0001
#define O_RDWR          0x0002
#define O_APPEND        0x0008  /* writes done at eof */

#define         OF_REOPEN       0x8000
#define         OF_EXIST        0x4000
#define         OF_PROMPT       0x2000
#define         OF_CREATE       0x1000
#define         OF_CANCEL       0x0800
#define         OF_VERIFY       0x0400
#define         OF_DELETE       0x0200

#define O_TEXT          0x4000  /* file mode is text (translated) */
#define O_BINARY        0x8000  /* file mode is binary (untranslated) */

#define SP_CREATE       O_WRONLY | OF_CREATE
#define SP_OPEN         O_RDONLY | OF_EXIST
#define SP_REOPEN       O_RDWR | OF_REOPEN | OF_PROMPT | OF_CANCEL

typedef int (FAR * FARPROC)();
typedef int (NEAR * NEARPROC)();
typedef unsigned LONG     DWORD;
typedef DWORD (FAR * DWORDFARPROC)();
typedef unsigned short int WORD;
typedef unsigned char      BYTE;
typedef WORD HANDLE;
typedef HANDLE HWND;
typedef HANDLE HDC;
typedef WORD ATOM;
typedef int  BOOLEAN;
typedef char *NEARP;
typedef char FAR *FARP;
typedef HANDLE GLOBALHANDLE;
typedef HANDLE LOCALHANDLE;
typedef unsigned char     *PSTR;
typedef unsigned char far *LPSTR;
typedef short     BOOL;
typedef long FAR *LPLONG;

#define MAX(a,b)        ((a)>(b)?(a):(b))
#define MIN(a,b)        ((a)<=(b)?(a):(b))
#define ABS(x)          (((x) >= 0) ? (x) : (-(x)))
#define LWORD(x)        ((short)((x)&0xFFFF))
#define HWORD(y)        ((short)(((y)>>16)&0xFFFF))
#define MAKELONG(h,l)  ((long)(((WORD)l)|(((long)h)<<16)))
#define LOBYTE(w)       ((BYTE)w)
#define HIBYTE(w)       (((WORD)w >> 8) & 0xff)
#define MAKEPOINT(l)    (*((POINT *)&l))

/* Interface to global memory manager */

#define GMEM_SHAREALL       0x2000
#define GMEM_FIXED          0x00
#define GMEM_MOVEABLE       0x02
#define GMEM_ZEROINIT       0x40
#define GMEM_DISCARDABLE    0x0F00
#define GHND    (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR    (GMEM_FIXED    | GMEM_ZEROINIT)

/* Interface to local memory manager */

#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00

/* Exported procedures for KERNEL module */

/* Spooler escapes      */
#define SE_JOBTIME          0x0001  /* time out for printer     */
#define SE_SETCALLBACK      0x0002  /* set callback function    */
#define SE_MARKCALLBACK     0x0003  /* write mark for call back */


/* Exported procedures for KERNEL module */
VOID          far PASCAL FatalExit( int );

HANDLE        far PASCAL LoadModule(LPSTR, LPSTR);
VOID          far PASCAL FreeModule(HANDLE);
HANDLE        far PASCAL GetModuleHandle(FARP);
FARPROC       far PASCAL GetProcAddress(HANDLE, FARP);

HANDLE far PASCAL GlobalAlloc( WORD, DWORD );
HANDLE far PASCAL GlobalReAlloc( HANDLE, DWORD, WORD );
HANDLE far PASCAL GlobalFree( HANDLE );
FARP   far PASCAL GlobalLock( HANDLE );
BOOL   far PASCAL GlobalUnlock( HANDLE );
LONG   far PASCAL GlobalSize( HANDLE );
LONG   far PASCAL GlobalFlags( HANDLE );

/* task scheduler routines */

extern void          far PASCAL Yield(void);
extern BOOL          far PASCAL WaitEvent(HANDLE);
extern BOOL          far PASCAL PostEvent(HANDLE);
extern HANDLE        far PASCAL GetCurrentTask(void);

short       FAR PASCAL GetProfileString(LPSTR,  LPSTR,  LPSTR,  LPSTR,  short);
BOOL FAR PASCAL WriteProfileString( LPSTR, LPSTR, LPSTR );

/* Interface to the resource manager */

HANDLE      FAR PASCAL FindResource( HANDLE, LPSTR, LPSTR );
HANDLE      FAR PASCAL LoadResource( HANDLE, HANDLE );
BOOL        FAR PASCAL FreeResource( HANDLE );

char FAR *  FAR PASCAL LockResource( HANDLE );

FARPROC     FAR PASCAL SetResourceHandler( HANDLE, LPSTR, FARPROC );
HANDLE      FAR PASCAL AllocResource( HANDLE, HANDLE, DWORD );
WORD        FAR PASCAL SizeofResource( HANDLE, HANDLE );
int         FAR PASCAL AccessResource( HANDLE, HANDLE );


#define WM_INITDIALOG       0x0110
#define WM_COMMAND          0x0111
#define WM_ENDDIALOG        0x0088
#define WM_SPOOLERSTATUS    0x002a	/* ;Internal */
#define PR_JOBSTATUS        0x0000

typedef struct
{
        BYTE    cBytes;                 /* length of structure */
        BYTE    fFixedDisk;             /* non-zero if file located on non- */
                                        /* removeable media */
        WORD    nErrCode;               /* DOS error code if OpenFile fails */
        BYTE    reserved[ 4 ];
        BYTE    szPathName[ 128 ];
} OFSTRUCT;

typedef OFSTRUCT FAR * LPOFSTRUCT;

int         FAR PASCAL OpenFile( LPSTR, LPOFSTRUCT, WORD );
BYTE        FAR PASCAL GetTempDrive( BYTE );
int         far PASCAL OpenPathname( LPSTR, int );
int         far PASCAL DeletePathname( LPSTR );
int         far PASCAL _lopen( LPSTR, int );
void        far PASCAL _lclose( int );
int         far PASCAL _lcreat( LPSTR, int );
BOOL        far PASCAL _ldelete( LPSTR );
WORD        far PASCAL _ldup( int );
LONG        far PASCAL _llseek( int, long, int );
WORD        far PASCAL _lread( int, LPSTR, int );
WORD        far PASCAL _lwrite( int, LPSTR, int );

int         far PASCAL lstrcmp( LPSTR, LPSTR );
LPSTR       far PASCAL lstrcpy( LPSTR, LPSTR );
LPSTR       far PASCAL lstrcat( LPSTR, LPSTR );
int         far PASCAL lstrlen( LPSTR );
LPSTR       far PASCAL lstrbscan( LPSTR, LPSTR );
LPSTR	    far PASCAL lstrbskip( LPSTR, LPSTR );

/* new Escape support */
#define  GETEXTENDEDTEXTMETRICS  256
#define  GETEXTENTTABLE  257
#define  EXTTEXTOUT	 512

#else

#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMSG
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NOCOMM
#define NOKANJI

#include "Windows.h"
#include "winexp.h"

#undef NOATOM
#undef NOGDI
#undef NOGDICAPMASKS
#undef NOMETAFILE
#undef NOMSG
#undef NORASTEROPS
#undef NOSCROLL
#undef NOSOUND
#undef NOSYSMETRICS
#undef NOTEXTMETRIC
#undef NOWH
#undef NOCOMM
#undef NOKANJI

#define NOPTRC	/* don't allow gdidefs.inc to redef these */
#define PTTYPE POINT

#endif /* OLDWAY */

/*  GDI internal routines */

short FAR PASCAL SetEnvironment(LPSTR, LPSTR, WORD);
short FAR PASCAL GetEnvironment(LPSTR, LPSTR, WORD);

/*  _SORT export routines */

HANDLE FAR  PASCAL CreatePQ(short);
short  FAR  PASCAL MinPQ(HANDLE);
short  FAR  PASCAL ExtractPQ(HANDLE);
short  FAR  PASCAL InsertPQ(HANDLE, short, short);
short  FAR  PASCAL SizePQ(HANDLE, short);
void   FAR  PASCAL DeletePQ(HANDLE);

/*  _SPOOL export routines */

HANDLE FAR  PASCAL OpenJob(LPSTR, LPSTR, HANDLE);
short FAR  PASCAL StartSpoolPage(HANDLE);
short FAR  PASCAL EndSpoolPage(HANDLE);
short FAR  PASCAL WriteSpool(HANDLE, LPSTR, short);
short FAR  PASCAL CloseJob(HANDLE);
short FAR  PASCAL DeleteJob(HANDLE, short);
short FAR  PASCAL WriteDialog(HANDLE, LPSTR, short);
short FAR  PASCAL WriteMark(HANDLE, LPSTR, short);
BOOL  FAR  PASCAL AddFileSpoolJob(LPSTR, LPSTR, BOOL, LPSTR);
BOOL  FAR  PASCAL SpoolEscape(HANDLE, short, short, LPSTR, LPSTR);


long  FAR  PASCAL QueryJob(HANDLE, short);
short FAR  PASCAL QueryAbort(HANDLE, short);

/* _SPOOL constants for queryjob */
#define SP_QUERYVALIDJOB    30
#define SP_QUERYDISKAVAIL   0x1004

#define USA_COUNTRYCODE 1

#define PQERROR (-1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\spl_wnt.h ===
/*****************************************************************/ 
/**		  Microsoft Windows for Workgroups		**/
/**	      Copyright (C) Microsoft Corp., 1991-1992		**/
/*****************************************************************/ 

#ifndef _spl_wnt_h_
#define _spl_wnt_h_

/*
 *	Print Manager Administration APIs
 *	for later inclusion into WINNET.H once they settle down
 *
 *	JONN 4/19/91	Trimmed out unnecessary stuff
 *	JONN 5/3/91	Added type WNETERR
 */


/*
    Codes for WNetPrintMgrSelNotify's "type" variable, indicating
    what's selected:  a queue, a job, or nothing.
*/

#define WNPMSEL_NOTHING	0
#define WNPMSEL_QUEUE	1
#define WNPMSEL_JOB	2

#define PRIORITY        10		/* menu uses 10, 11, 12, 13 */
#define ABOUT	       24
#define EXIT            25
#define PRINT_LOG       28
#define NETWORK         29
#define HELP_NDEX       30
#define HELP_MOUSE      31
#define HELP_KEYBOARD   32
#define HELP_HELP       33
#define HELP_COMMANDS   34
#define HELP_PROCEDURES 35

#define SHOW_TIME   51
#define SHOW_SIZE   52
#define SHOW_DETAIL 53
#define UPDATE      54
#define SHOW_LOCAL  55
#define SHOW_NET    56
#define SHOW_QUEUE  57
#define SHOW_OTHER  58

#define ALERT_ALWAYS	100
#define ALERT_FLASH	101
#define ALERT_IGNORE	102

#define PRT_SETUP       8001   // These have to match the stuff in control
#define NETWK_CONNECTIONS 8021  // panel

#define PM_REFRESH	WM_USER + 100  // NOTE: Need to define proper manifest
#define PM_SELQUEUE	WM_USER + 101
#define PM_QUERYSEL	WM_USER + 102

typedef struct _wnpmsel {	/* structure returned by PM_QUERYSEL */
    WORD wJobID;
    char szQueueName [260];	/* in the form "LPT1\0HP LaserJet III\0" */
} WNPMSEL, far *LPWNPMSEL;

#define IDM_PROPERTIES		202
#define IDM_CHANGE_MENUS    	212

/*
 *	added JONN 2/26/91
 *	Print Manager Extensions
 */

typedef struct _queuestruct2
{
    WORD pq2Name;		/* offset to queue name */
				/* in the form "LPT1\0HP LaserJet III\0" */
    WORD pq2Comment;		/* offset to queue comment */
    WORD pq2Driver;		/* offset to driver name */
    WORD pq2Status;		/* status flags */
    WORD pq2Jobcount;		/* number of jobs in this queue */    
    WORD pq2Flags;		/* miscellaneous flags */

} QUEUESTRUCT2, FAR *LPQS2;

#define QNAME(buf,qs)	((LPSTR)(buf) + (qs).pq2Name)
#define QCOMMENT(buf,qs) ((LPSTR)(buf) + (qs).pq2Comment)
#define QDRIVER(buf,qs)	((LPSTR)(buf) + (qs).pq2Driver)

#define QF_REDIRECTED	0x0001
#define QF_SHARED	0x0002

typedef struct _jobstruct2 {
	WORD	pj2Id;		// job ID
	WORD	pj2Username;	// name of owner (offset to string)
//	WORD	pj2Parms;
	WORD	pj2Position;	// 0-based position in queue
	WORD	pj2Status;	// status flags (WNPRJ_XXXXX)
	DWORD	pj2Submitted;
	DWORD	pj2Size;	// size of job in bytes
        DWORD	pj2SubmitSize;	// bytes submitted so far
//	WORD	pj2Copies;
	WORD	pj2Comment;	// comment/app name (offset to string)
	WORD	pj2Document;	// document name (offset to string)
	WORD	pj2StatusText;	// verbose status (offset to string)
	WORD	pj2PrinterName;	// name of port job is printing on (offs to str)
} JOBSTRUCT2;

typedef JOBSTRUCT2 far * LPJOBSTRUCT2;

#define JOBNAME(buf,job)	((LPSTR)(buf) + (job).pj2Username)
#define JOBCOMMENT(buf,job)	((LPSTR)(buf) + (job).pj2Comment)
#define JOBDOCUMENT(buf,job)	((LPSTR)(buf) + (job).pj2Document)
#define JOBSTATUS(buf,job)	((LPSTR)(buf) + (job).pj2StatusText)
#define JOBPRINTER(buf,job)	((LPSTR)(buf) + (job).pj2PrinterName)

/*
 * Type WNETERR distinguishes WN_ error codes from other WORD
 * values.  Added JONN 5/3/91
 */
typedef WORD WNETERR;

// new Print Manager Extensions APIs
/* All queue names are in the form "LPT1\0HP LaserJet III\0" */
#ifdef C700
extern void far pascal __loadds WNetPrintMgrSelNotify (BYTE, LPQS2, LPQS2,
	LPJOBSTRUCT2, LPJOBSTRUCT2, LPWORD, LPSTR, WORD);
extern WNETERR far pascal __loadds WNetPrintMgrPrinterEnum (LPSTR lpszQueueName,
	LPSTR lpBuffer, LPWORD pcbBuffer, LPWORD cAvail, WORD usLevel);
extern WNETERR far pascal __loadds WNetPrintMgrChangeMenus(HWND, HANDLE FAR *, BOOL FAR *);
extern WNETERR far pascal __loadds WNetPrintMgrCommand (HWND, WORD);
extern void far pascal __loadds WNetPrintMgrExiting (void);
extern BOOL far pascal __loadds WNetPrintMgrExtHelp (DWORD);
extern WORD far pascal __loadds WNetPrintMgrMoveJob (HWND, LPSTR, WORD, int);
#else
extern void API WNetPrintMgrSelNotify (BYTE, LPQS2, LPQS2,
	                               LPJOBSTRUCT2, LPJOBSTRUCT2, 
                                       LPWORD, LPSTR, WORD);
extern WNETERR API WNetPrintMgrPrinterEnum (LPSTR lpszQueueName,
	                                    LPSTR lpBuffer, LPWORD pcbBuffer, 
                                            LPWORD cAvail, WORD usLevel);
extern WNETERR API WNetPrintMgrChangeMenus(HWND, HANDLE FAR *, BOOL FAR *);
extern WNETERR API WNetPrintMgrCommand (HWND, WORD);
extern void API WNetPrintMgrExiting (void);
extern BOOL API WNetPrintMgrExtHelp (DWORD);
extern WORD API WNetPrintMgrMoveJob (HWND, LPSTR, WORD, int);
#endif


#define WINBALL
#ifdef WINBALL
#define WNNC_PRINTMGRNOTIFY	0x000C
#ifdef C700
extern void far pascal __loadds WNetPrintMgrStatusChange (LPSTR lpszQueueName,
	LPSTR lpszPortName, WORD wQueueStatus, WORD cJobsLeft, HANDLE hJCB,
	BOOL fDeleted);
#else
extern void API WNetPrintMgrStatusChange (LPSTR lpszQueueName,
	                                  LPSTR lpszPortName, 
                                          WORD wQueueStatus, 
                                          WORD cJobsLeft, 
                                          HANDLE hJCB,
	                                  BOOL fDeleted);
#endif

#define PM_QUERYQDATA		WM_USER + 104

typedef struct _PMQUEUE {
    WORD dchPortName;		/* offset to port name string */
    WORD dchPrinterName;	/* offset to printer name string */
    WORD dchRemoteName;		/* offset to remote name string */
    WORD cJobs;			/* count of jobs */
    WORD fwStatus;		/* queue status */
} PMQUEUE, FAR *LPPMQUEUE;

#define PMQPORTNAME(buf,queue)		((LPSTR)(buf) + (queue).dchPortName)
#define PMQPRINTERNAME(buf,queue)	((LPSTR)(buf) + (queue).dchPrinterName)
#define PMQREMOTENAME(buf,queue)	((LPSTR)(buf) + (queue).dchRemoteName)

typedef struct _PMJOB {
    DWORD dwTime;		/* date/time job was spooled */
    DWORD cbJob;		/* job size in bytes */
    DWORD cbSubmitted;		/* bytes submitted so far */
    WORD dchJobName;		/* offset to job name (doc name) string */
    HANDLE hJCB;		/* hJCB to refer to the job */
} PMJOB, FAR *LPPMJOB;

#define PMJOBNAME(buf,job)	((LPSTR)(buf) + (job).dchJobName)


#endif

// new values for WNetGetCaps()
#define WNNC_PRINTMGREXT		0x000B
// returns extensions version number, re: GetVersion(),
//   or 0 if not supported

// QUEUESTRUCT2.pq2Status and .pq2Jobcount for WNetPrintMgrPrinterEnum[2]
#define WNQ_UNKNOWN -1

#define WNPRS_CANPAUSE	0x0001
#define WNPRS_CANRESUME	0x0002
#define WNPRS_CANDELETE	0x0004
#define WNPRS_CANMOVE	0x0008
#define WNPRS_CANDISCONNECT	0x0010
#define WNPRS_CANSTOPSHARE	0x0020
#define WNPRS_ISPAUSED		0x0040
#define WNPRS_ISRESUMED		0x0080

// help contexts, were previously in sphelp.h
#define IDH_HELPFIRST		5000
#define IDH_SYSMENU	(IDH_HELPFIRST + 2000)
#define IDH_MBFIRST	(IDH_HELPFIRST + 2001)
#define IDH_MBLAST	(IDH_HELPFIRST + 2099)
#define IDH_DLGFIRST	(IDH_HELPFIRST + 3000)


#define IDH_PRIORITY	(IDH_HELPFIRST + PRIORITY )
#define IDH_PRIORITY1 	(IDH_HELPFIRST + PRIORITY + 1)
#define IDH_PRIORITY2 	(IDH_HELPFIRST + PRIORITY + 2)
#define IDH_ABOUT	(IDH_HELPFIRST + ABOUT	)
#define IDH_EXIT 	(IDH_HELPFIRST + EXIT)
#define IDH_NETWORK 	(IDH_HELPFIRST + NETWORK)
#define IDH_HELP_NDEX 	(IDH_HELPFIRST + HELP_NDEX)
#define IDH_HELP_MOUSE 	(IDH_HELPFIRST + HELP_MOUSE)
#define IDH_HELP_KEYBOARD 	(IDH_HELPFIRST + HELP_KEYBOARD)
#define IDH_HELP_HELP 	(IDH_HELPFIRST + HELP_HELP)
#define IDH_HELP_COMMANDS 	(IDH_HELPFIRST + HELP_COMMANDS)
#define IDH_HELP_PROCEDURES 	(IDH_HELPFIRST + HELP_PROCEDURES)
#define IDH_SHOW_TIME 	(IDH_HELPFIRST + SHOW_TIME)
#define IDH_SHOW_SIZE 	(IDH_HELPFIRST + SHOW_SIZE)
#define IDH_UPDATE 	(IDH_HELPFIRST + UPDATE)
#define IDH_SHOW_QUEUE 	(IDH_HELPFIRST + SHOW_QUEUE)
#define IDH_SHOW_OTHER 	(IDH_HELPFIRST + SHOW_OTHER)
#define IDH_ALERT_ALWAYS 	(IDH_HELPFIRST + ALERT_ALWAYS)
#define IDH_ALERT_FLASH 	(IDH_HELPFIRST + ALERT_FLASH)
#define IDH_ALERT_IGNORE 	(IDH_HELPFIRST + ALERT_IGNORE)


// was in spoolids.h

#define IDS_A_BASE	4096

/* also used as button IDs */
#define ID_ABORT	4
#define ID_PAUSE	2
#define ID_RESUME	3
#define ID_EXPLAIN	5

#endif /* _spl_wnt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\spool.h ===
#ifndef WINAPI
#ifdef BUILDDLL                                 /* ;Internal */
#define WINAPI              _loadds far pascal  /* ;Internal */
#define CALLBACK	    _loadds far pascal	/* ;Internal */
#else						/* ;Internal */
#define WINAPI              far pascal
#define CALLBACK	    far pascal
#endif                                          /* ;Internal */
#endif

#define LWORD(x)        ((int)((x)&0xFFFF))


/* spooler error code */
#define SP_ERROR            (-1)    /* general error - mostly used when spooler isn't loaded */
#define SP_APPABORT         (-2)    /* app aborted the job through the driver */
#define SP_USERABORT        (-3)    /* user aborted the job through spooler's front end */
#define SP_OUTOFDISK        (-4)    /* simply no disk to spool */
#define SP_OUTOFMEMORY      (-5)
#define SP_RETRY            (-6)    /* retry sending to the port again  */
#define SP_NOTREPORTED      0x4000  /* set if GDI did not report error */

/* subfunctions of the Spooler support function, GetSpoolJob()
 *  CP_* are used by the control panel for modifying the printer setup/
 */
#define SP_PRINTERNAME      20
#define SP_REGISTER         21
#define SP_CONNECTEDPORTCNT 25
#define SP_QUERYDISKUSAGE   26
#define SP_DISKFREED        27
#define SP_INIT             28
#define SP_LISTEDPORTCNT    29
#define CP_ISPORTFREE	    30
#define CP_REINIT	    31
#define SP_TXTIMEOUT	    32
#define SP_DNSTIMEOUT	    33
#define CP_CHECKSPOOLER     34
#define CP_SET_TT_ONLY      35
#define CP_SETSPOOLER       36
#define CP_SETDOSPRINT      37


#define SP_DISK_BUFFER      (20000) /* wait for about 20 K of disk space to free
                                       free up before attempting to write to disk */

/* messages posted or sent to the spooler window
 */
#define SP_NEWJOB           0x1001
#define SP_DELETEJOB        0x1002
#define SP_DISKNEEDED       0x1003
#define SP_QUERYDISKAVAIL   0x1004
#define SP_ISPORTFREE       0x1005
#define SP_CHANGEPORT       0x1006

/* in /windows/oem/printer.h */


/* job status flag bits in the type field of the JCB structure
 */
#define JB_ENDDOC           0x0001
#define JB_INVALIDDOC       0x0002
#define JB_DIRECT_SPOOL     0x8000  /* go directly to the printer without the spooler */
#define JB_FILE_PORT        0x4000  /* were given a file for a port name */
#define JB_VALID_SPOOL      0x2000  /* everything is cool, continue to spool normally */
#define JB_NOTIFIED_SPOOLER 0x1000  /* already notified the spooler of this job */
#define JB_WAITFORDISK      0x0800  /* out of disk condition has been detected previously */
#define JB_DEL_FILE         0x0400  /* no deletion of file after spool          */
#define JB_FILE_SPOOL	    0x0200  /* spooling a file		*/
#define JB_NET_SPOOL	    0x0100  /* sending directly to network */

/* allow 2 dialog box messages initially and increment 8 at a time */
#define SP_DLGINC       8
#define SP_DLGINIT      8

#define NAME_LEN        32
#define BUF_SIZE        128
#define MAX_PROFILE     80
#define JCBBUF_LEN      256

#define lower(c)        ((c > 'A' && c < 'Z') ? (c - 'A' + 'a') : c)

#define IDS_LENGTH	    60

/* comm driver stuff */
#define COMM_INQUE          0x010                       /* wm091385 */
#define COMM_OUTQUE         0x030                       /* wm091385 */
#define COMM_OUTQUEPMODE    0x400                       /* New size for pmode */

#define COMM_ERR_BIT        0x8000
#define TXTIMEOUT           45000               /* milliseconds */
#define DNSTIMEOUT          15000               /* milliseconds */

#define BAUDRATE            0
#define PARITY              1
#define BYTESIZE            2
#define STOPBITS            3
#define REPEAT              4


typedef struct {
    int     type;           /* type of dialog. This will tell whether it is */
                            /* call back function or pure dialog etc        */
    int     size;           /* size of special function data                */
    int     adr;
}DIALOGMARK;

#define SP_TEXT         0   /* text type                                */
#define SP_NOTTEXT      1   /* not text type                            */
#define SP_DIALOG       2   /* dialog type data                         */
#define SP_CALLBACK     3   /* call back type function                  */

#define MAXPORTLIST 20  	/* max # ports listed in win.ini [ports] */
#define MAXPORT     MAXPORTLIST
#define MAXSPOOL    100		/* max # jobs spooled per port */
#define MAXMAP      18
#define PORTINDENT   2
#define JOBINDENT    3
#define MAXPAGE     7     /* allow 7 pages at first */
#define INC_PAGE    8     /* increase by 8 pages at a time */

typedef struct {
    int   pnum;
    int   printeratom;
    long txtimeout;
    long dnstimeout;
}JCBQ;

typedef struct jcb {
    unsigned        type;
    int             pagecnt;
    int             maxpage;
    int             portnum;
    HDC             hDC;
    int             chBuf;
    long	    timeSpooled;
    char            buffer[JCBBUF_LEN];
    unsigned long   size;
    unsigned long   iLastPage;
    WORD	    psp;		// the PSP of the app that started printing
    char            jobName[NAME_LEN];
    int             page[MAXPAGE];
}JCB;

typedef struct page {
    int      filenum;
    unsigned maxdlg;                    /* max number of dialog */
    unsigned dlgptr;                    /* number of dialogs */
    long     spoolsize;
    OFSTRUCT fileBuf;
    DIALOGMARK  dialog[SP_DLGINIT];
}PAGE;

#define SP_COMM_PORT    0
#define SP_FILE_PORT	1
#define SP_REMOTE_QUEUE 2
#define SP_QUERYVALIDJOB    30


typedef struct
{
        int   type;
        int   fn;
        long  retry;            /* system timer on first error  */
}   PORT;


/* exported routines */
BOOL  WINAPI QueryJob(HANDLE, int);
BOOL  WINAPI QueryAbort(HANDLE, int);

int   WINAPI WriteDialog(HANDLE hJCB, LPSTR str, int n);
int   WINAPI WriteSpool(HANDLE hJCB, LPSTR str, int n);

LONG  WINAPI GetSpoolJob(int, long);
char  WINAPI GetSpoolTempDrive(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\stat.h ===
/***
*sys\stat.h - defines structure used by stat() and fstat()
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines the structure used by the stat() and fstat()
*   routines.
*   [System V]
*
****/

#ifndef _INC_STAT

#ifndef _INC_TYPES
#include <sys/types.h>
#endif 

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _TIME_T_DEFINED
typedef long    time_t;
#define _TIME_T_DEFINED
#endif 

/* define structure for returning status information */

#ifndef _STAT_DEFINED
#pragma pack(2)

struct _stat {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
struct stat {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
    };
#endif 

#pragma pack()
#define _STAT_DEFINED
#endif 

#define _S_IFMT     0170000     /* file type mask */
#define _S_IFDIR    0040000     /* directory */
#define _S_IFCHR    0020000     /* character special */
#define _S_IFREG    0100000     /* regular */
#define _S_IREAD    0000400     /* read permission, owner */
#define _S_IWRITE   0000200     /* write permission, owner */
#define _S_IEXEC    0000100     /* execute/search permission, owner */


/* function prototypes */

int __cdecl _fstat(int, struct _stat *);
int __cdecl _stat(const char *, struct _stat *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define S_IFMT   _S_IFMT
#define S_IFDIR  _S_IFDIR
#define S_IFCHR  _S_IFCHR
#define S_IFREG  _S_IFREG
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IEXEC  _S_IEXEC

int __cdecl fstat(int, struct stat *);
int __cdecl stat(const char *, struct stat *);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STAT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\print.h ===
/*****************************************************************************\
*                                                                             *
* print.h -     Printing helper functions, types, and definitions             *
*                                                                             *
*               Copyright (c) 1985-1992. Microsoft Corp.  All rights reserved.*
*                                                                             *
*******************************************************************************
*
*  PRINTDRIVER       - For inclusion with a printer driver
*  NOPQ              - Prevent inclusion of priority queue APIs
*
\*****************************************************************************/

#ifndef _INC_PRINT
#define _INC_PRINT

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifdef PRINTDRIVER

#define NORASTEROPS
#define NOTEXTMETRICS
#define NOGDICAPMASKS
#define NOGDIOBJ
#define NOBITMAP
#define NOSOUND
#define NOTEXTMETRIC
#define NOCOMM
#define NOKANJI

#include <windows.h>

#undef NORASTEROPS
#undef NOTEXTMETRICS
#undef NOGDICAPMASKS
#undef NOGDICAPMASKS
#undef NOGDIOBJ
#undef NOBITMAP
#undef NOSOUND
#undef NOTEXTMETRIC
#undef NOCOMM
#undef NOKANJI

#define NOPTRC	/* don't allow gdidefs.inc to redef these */
#define PTTYPE POINT

#define PQERROR (-1)

#ifndef NOPQ

DECLARE_HANDLE(HPQ);

HPQ     WINAPI CreatePQ(int);
int     WINAPI MinPQ(HPQ);
int     WINAPI ExtractPQ(HPQ);
int     WINAPI InsertPQ(HPQ, int, int);
int     WINAPI SizePQ(HPQ, int);
void    WINAPI DeletePQ(HPQ);
#endif  /* !NOPQ */

/* Spool routines for use by printer drivers */

DECLARE_HANDLE(HPJOB);

HPJOB   WINAPI OpenJob(LPSTR, LPSTR, HPJOB);
int     WINAPI StartSpoolPage(HPJOB);
int     WINAPI EndSpoolPage(HPJOB);
int     WINAPI WriteSpool(HPJOB, LPSTR, int);
int     WINAPI CloseJob(HPJOB);
int     WINAPI DeleteJob(HPJOB, int);
int     WINAPI WriteDialog(HPJOB, LPSTR, int);
int     WINAPI DeleteSpoolPage(HPJOB);

#endif /* !PRINTDRIVER */

typedef struct tagBANDINFOSTRUCT
{
    BOOL    fGraphics;
    BOOL    fText;
    RECT    rcGraphics;
} BANDINFOSTRUCT, FAR* LPBI;

#define USA_COUNTRYCODE 1

/*
 *  Printer driver initialization using ExtDeviceMode()
 *  and DeviceCapabilities().
 *  This replaces Drivinit.h
 */

/* size of a device name string */
#define CCHDEVICENAME 32
#define CCHPAPERNAME  64

/* current version of specification */
#define DM_SPECVERSION 0x30A

/* field selection bits */
#define DM_ORIENTATION	    0x0000001L
#define DM_PAPERSIZE	    0x0000002L
#define DM_PAPERLENGTH	    0x0000004L
#define DM_PAPERWIDTH	    0x0000008L
#define DM_SCALE	    0x0000010L
#define DM_COPIES	    0x0000100L
#define DM_DEFAULTSOURCE    0x0000200L
#define DM_PRINTQUALITY     0x0000400L
#define DM_COLOR	    0x0000800L
#define DM_DUPLEX	    0x0001000L
#define DM_YRESOLUTION	    0x0002000L
#define DM_TTOPTION	    0x0004000L

/* orientation selections */
#define DMORIENT_PORTRAIT   1
#define DMORIENT_LANDSCAPE  2

/* paper selections */
/*  Warning: The PostScript driver mistakingly uses DMPAPER_ values between
 *  50 and 56.  Don't use this range when defining new paper sizes.
 */
#define DMPAPER_FIRST	    DMPAPER_LETTER
#define DMPAPER_LETTER      1           /* Letter 8 1/2 x 11 in               */
#define DMPAPER_LETTERSMALL 2           /* Letter Small 8 1/2 x 11 in         */
#define DMPAPER_TABLOID     3           /* Tabloid 11 x 17 in                 */
#define DMPAPER_LEDGER      4           /* Ledger 17 x 11 in                  */
#define DMPAPER_LEGAL       5           /* Legal 8 1/2 x 14 in                */
#define DMPAPER_STATEMENT   6           /* Statement 5 1/2 x 8 1/2 in         */
#define DMPAPER_EXECUTIVE   7		/* Executive 7 1/4 x 10 1/2 in	      */
#define DMPAPER_A3          8           /* A3 297 x 420 mm                    */
#define DMPAPER_A4          9           /* A4 210 x 297 mm                    */
#define DMPAPER_A4SMALL     10          /* A4 Small 210 x 297 mm              */
#define DMPAPER_A5          11          /* A5 148 x 210 mm                    */
#define DMPAPER_B4          12          /* B4 250 x 354                       */
#define DMPAPER_B5          13          /* B5 182 x 257 mm                    */
#define DMPAPER_FOLIO       14          /* Folio 8 1/2 x 13 in                */
#define DMPAPER_QUARTO      15          /* Quarto 215 x 275 mm                */
#define DMPAPER_10X14       16          /* 10x14 in                           */
#define DMPAPER_11X17       17          /* 11x17 in                           */
#define DMPAPER_NOTE        18          /* Note 8 1/2 x 11 in                 */
#define DMPAPER_ENV_9       19          /* Envelope #9 3 7/8 x 8 7/8          */
#define DMPAPER_ENV_10      20          /* Envelope #10 4 1/8 x 9 1/2         */
#define DMPAPER_ENV_11      21          /* Envelope #11 4 1/2 x 10 3/8        */
#define DMPAPER_ENV_12      22          /* Envelope #12 4 \276 x 11           */
#define DMPAPER_ENV_14      23          /* Envelope #14 5 x 11 1/2            */
#define DMPAPER_CSHEET      24          /* C size sheet                       */
#define DMPAPER_DSHEET      25          /* D size sheet                       */
#define DMPAPER_ESHEET      26          /* E size sheet                       */
#define DMPAPER_ENV_DL      27          /* Envelope DL 110 x 220mm            */
#define DMPAPER_ENV_C5      28          /* Envelope C5 162 x 229 mm           */
#define DMPAPER_ENV_C3      29          /* Envelope C3  324 x 458 mm          */
#define DMPAPER_ENV_C4      30          /* Envelope C4  229 x 324 mm          */
#define DMPAPER_ENV_C6      31          /* Envelope C6  114 x 162 mm          */
#define DMPAPER_ENV_C65     32          /* Envelope C65 114 x 229 mm          */
#define DMPAPER_ENV_B4      33          /* Envelope B4  250 x 353 mm          */
#define DMPAPER_ENV_B5      34          /* Envelope B5  176 x 250 mm          */
#define DMPAPER_ENV_B6      35          /* Envelope B6  176 x 125 mm          */
#define DMPAPER_ENV_ITALY   36          /* Envelope 110 x 230 mm              */
#define DMPAPER_ENV_MONARCH 37          /* Envelope Monarch 3.875 x 7.5 in    */
#define DMPAPER_ENV_PERSONAL 38         /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
#define DMPAPER_FANFOLD_US  39          /* US Std Fanfold 14 7/8 x 11 in      */
#define DMPAPER_FANFOLD_STD_GERMAN  40  /* German Std Fanfold 8 1/2 x 12 in   */
#define DMPAPER_FANFOLD_LGL_GERMAN  41  /* German Legal Fanfold 8 1/2 x 13 in */

#define DMPAPER_LAST	    DMPAPER_FANFOLD_LGL_GERMAN

#define DMPAPER_USER	    256

/* bin selections */
#define DMBIN_FIRST	    DMBIN_UPPER
#define DMBIN_UPPER	    1
#define DMBIN_ONLYONE	    1
#define DMBIN_LOWER	    2
#define DMBIN_MIDDLE	    3
#define DMBIN_MANUAL	    4
#define DMBIN_ENVELOPE	    5
#define DMBIN_ENVMANUAL     6
#define DMBIN_AUTO	    7
#define DMBIN_TRACTOR	    8
#define DMBIN_SMALLFMT	    9
#define DMBIN_LARGEFMT	    10
#define DMBIN_LARGECAPACITY 11
#define DMBIN_CASSETTE      14
#define DMBIN_LAST	    DMBIN_CASSETTE

#define DMBIN_USER	    256     /* device specific bins start here */

/* print qualities */
#define DMRES_DRAFT	    (-1)
#define DMRES_LOW	    (-2)
#define DMRES_MEDIUM	    (-3)
#define DMRES_HIGH	    (-4)

/* color enable/disable for color printers */
#define DMCOLOR_MONOCHROME  1
#define DMCOLOR_COLOR	    2

/* duplex enable */
#define DMDUP_SIMPLEX	 1
#define DMDUP_VERTICAL	 2
#define DMDUP_HORIZONTAL 3

/* TrueType options */
#define DMTT_BITMAP     1       /* print TT fonts as graphics */
#define DMTT_DOWNLOAD   2       /* download TT fonts as soft fonts */
#define DMTT_SUBDEV     3       /* substitute device fonts for TT fonts */

typedef struct tagDEVMODE
{
    char  dmDeviceName[CCHDEVICENAME];
    UINT  dmSpecVersion;
    UINT  dmDriverVersion;
    UINT  dmSize;
    UINT  dmDriverExtra;
    DWORD dmFields;
    int   dmOrientation;
    int   dmPaperSize;
    int   dmPaperLength;
    int   dmPaperWidth;
    int   dmScale;
    int   dmCopies;
    int   dmDefaultSource;
    int   dmPrintQuality;
    int   dmColor;
    int   dmDuplex;
    int   dmYResolution;
    int   dmTTOption;
} DEVMODE;

typedef DEVMODE* PDEVMODE, NEAR* NPDEVMODE, FAR* LPDEVMODE;

/* mode selections for the device mode function */
#define DM_UPDATE	    1
#define DM_COPY 	    2
#define DM_PROMPT	    4
#define DM_MODIFY	    8

#define DM_IN_BUFFER	    DM_MODIFY
#define DM_IN_PROMPT	    DM_PROMPT
#define DM_OUT_BUFFER	    DM_COPY
#define DM_OUT_DEFAULT	    DM_UPDATE

/* device capabilities indices */
#define DC_FIELDS	    1
#define DC_PAPERS	    2
#define DC_PAPERSIZE	    3
#define DC_MINEXTENT	    4
#define DC_MAXEXTENT	    5
#define DC_BINS 	    6
#define DC_DUPLEX	    7
#define DC_SIZE 	    8
#define DC_EXTRA	    9
#define DC_VERSION	    10
#define DC_DRIVER	    11
#define DC_BINNAMES	    12
#define DC_ENUMRESOLUTIONS  13
#define DC_FILEDEPENDENCIES 14
#define DC_TRUETYPE	    15
#define DC_PAPERNAMES	    16
#define DC_ORIENTATION	    17
#define DC_COPIES	    18

/* bit fields of the return value (DWORD) for DC_TRUETYPE */
#define DCTT_BITMAP	    0x0000001L
#define DCTT_DOWNLOAD	    0x0000002L
#define DCTT_SUBDEV	    0x0000004L

/* export ordinal definitions */
#define PROC_EXTDEVICEMODE	MAKEINTRESOURCE(90)
#define PROC_DEVICECAPABILITIES MAKEINTRESOURCE(91)
#define PROC_OLDDEVICEMODE	MAKEINTRESOURCE(13)

/* define types of pointers to ExtDeviceMode() and DeviceCapabilities()
 * functions
 */
typedef UINT   (CALLBACK* LPFNDEVMODE)(HWND, HMODULE, DEVMODE FAR*,
                          LPSTR, LPSTR, DEVMODE FAR*, LPSTR, UINT);

typedef DWORD  (CALLBACK* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, DEVMODE FAR*);

HDC     WINAPI ResetDC(HDC, const DEVMODE FAR*);

/* this structure is used by the GETSETSCREENPARAMS escape */
typedef struct tagSCREENPARAMS
{
   int angle;
   int frequency;
} SCREENPARAMS;

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_PRINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\shellapi.h ===
/*****************************************************************************\
*                                                                             *
* shellapi.h -  SHELL.DLL functions, types, and definitions                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SHELLAPI
#define _INC_SHELLAPI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If included with Windows 3.0 windows.h: define 3.1-compatible types */

#ifndef _INC_WINDOWS

#define HDROP   HANDLE
#define WINAPI  FAR PASCAL
#define LPCSTR  LPSTR
#define UINT    WORD

#else

DECLARE_HANDLE(HDROP);

#endif

/* return codes from Registration functions */
#define ERROR_SUCCESS           0L
#define ERROR_BADDB             1L
#define ERROR_BADKEY            2L
#define ERROR_CANTOPEN          3L
#define ERROR_CANTREAD          4L
#define ERROR_CANTWRITE         5L
#define ERROR_OUTOFMEMORY       6L
#define ERROR_INVALID_PARAMETER 7L
#define ERROR_ACCESS_DENIED     8L

#define REG_SZ			1	    /* string type */

#define HKEY_CLASSES_ROOT	0x80000000

typedef DWORD HKEY;
typedef HKEY FAR* PHKEY;
                                                                /* ;Internal */
typedef struct _dropfilestruct {				/* ;Internal */
    WORD pFiles;                        /* offset of file list*//* ;Internal */
    POINT pt;                           /* drop point         *//* ;Internal */
    BOOL fNC;                           /* is it on NC area   *//* ;Internal */
} DROPFILESTRUCT, FAR* LPDROPFILESTRUCT;                        /* ;Internal */

LONG WINAPI RegOpenKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCreateKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCloseKey(HKEY);
LONG WINAPI RegDeleteKey(HKEY, LPCSTR);
LONG WINAPI RegSetValue(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
LONG WINAPI RegQueryValue(HKEY, LPCSTR, LPSTR, LONG FAR*);
LONG WINAPI RegEnumKey(HKEY, DWORD, LPSTR, DWORD);

UINT WINAPI DragQueryFile(HDROP, UINT, LPSTR, UINT);
BOOL WINAPI DragQueryPoint(HDROP, POINT FAR*);
void WINAPI DragFinish(HDROP);
void WINAPI DragAcceptFiles(HWND, BOOL);

HICON WINAPI ExtractIcon(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex);

/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE            26
#define SE_ERR_ASSOCINCOMPLETE  27
#define SE_ERR_DDETIMEOUT       28
#define SE_ERR_DDEFAIL          29
#define SE_ERR_DDEBUSY          30
#define SE_ERR_NOASSOC          31

HINSTANCE WINAPI ShellExecute(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, int iShowCmd);
HINSTANCE WINAPI FindExecutable(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);
				 
int   WINAPI ShellAbout(HWND hWnd, LPCSTR szApp, LPCSTR szOtherStuff, HICON hIcon);                   /* ;Internal */
HICON WINAPI ExtractAssociatedIcon(HANDLE hInst, LPSTR lpIconPath, WORD FAR* lpiIcon);                /* ;Internal */
HICON WINAPI InternalExtractIcon(HANDLE hInst, LPCSTR lpszExeFileName, WORD nIconIndex, WORD nIcons); /* ;Internal */
DWORD WINAPI DoEnvironmentSubst(LPSTR szString, WORD cbString);                                       /* ;Internal */
BOOL  WINAPI RegisterShellHook(HWND, BOOL);                                                           /* ;Internal */

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_SHELLAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\style.h ===
/* Window styles */
#define WS_TILED        0x00000000L
#define WS_ICONICPOPUP  0xc0000000L
#define WS_POPUP        0x80000000L
#define WS_CHILD        0x40000000L
#define WS_MINIMIZE     0x20000000L
#define WS_VISIBLE      0x10000000L
#define WS_DISABLED     0x08000000L
#define WS_CLIPSIBLINGS 0x04000000L
#define WS_CLIPCHILDREN 0x02000000L
#define WS_MAXIMIZE     0x01000000L

#define WS_BORDER       0x00800000L
#define WS_CAPTION      0x00c00000L
#define WS_DLGFRAME     0x00400000L
#define WS_VSCROLL      0x00200000L
#define WS_HSCROLL      0x00100000L
#define WS_SYSMENU      0x00080000L
#define WS_SIZEBOX      0x00040000L
#define WS_GROUP        0x00020000L
#define WS_TABSTOP      0x00010000L

#define WS_ICONIC       WS_MINIMIZE

/* Class styles */
#define CS_VREDRAW      0x0001
#define CS_HREDRAW      0x0002
#define CS_KEYCVTWINDOW 0x0004
#define CS_DBLCLKS      0x0008
			/* 0x0010 reserved */
#define CS_OWNDC        0x0020
#define CS_CLASSDC      0x0040
#define CS_MENUPOPUP    0x0080
#define CS_NOKEYCVT     0x0100
#define CS_SAVEBITS     0x0800

/* Shorthand for the common cases */
#define WS_TILEDWINDOW   (WS_TILED | WS_CAPTION | WS_SYSMENU | WS_SIZEBOX)
#define WS_POPUPWINDOW   (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW   (WS_CHILD)

/* Edit control styles */
#define ES_LEFT             0x0000L
#define ES_CENTER           0x0001L
#define ES_RIGHT            0x0002L
#define ES_MULTILINE        0x0004L
#define ES_UPPERCASE        0x0008L
#define ES_LOWERCASE        0x0010L
#define ES_PASSWORD         0x0020L
#define ES_AUTOVSCROLL      0x0040L
#define ES_AUTOHSCROLL      0x0080L
#define ES_NOHIDESEL        0x0100L
#define ES_OEMCONVERT       0x0400L

/* button control styles */
#define BS_PUSHBUTTON    0L
#define BS_DEFPUSHBUTTON 1L
#define BS_CHECKBOX      2L
#define BS_AUTOCHECKBOX  3L
#define BS_RADIOBUTTON   4L
#define BS_3STATE        5L
#define BS_AUTO3STATE    6L
#define BS_GROUPBOX      7L
#define BS_USERBUTTON    8L
#define BS_AUTORADIOBUTTON 9L
#define BS_PUSHBOX       10L
#define BS_OWNERDRAW	   0x0BL
#define BS_LEFTTEXT      0x20L

/* Dialog Styles */
#define DS_ABSALIGN	    0x01L
#define DS_SYSMODAL	    0x02L
#define DS_LOCALEDIT	    0x20L   /* Edit items get Local storage. */
#define DS_SETFONT	    0x40L   /* User specified font for Dlg controls */
#define DS_MODALFRAME	    0x80L   /* Can be combined with WS_CAPTION  */
#define DS_NOIDLEMSG	    0x100L  /* WM_ENTERIDLE message will not be sent */

/* listbox style bits */
#define LBS_NOTIFY        0x0001L
#define LBS_SORT          0x0002L
#define LBS_NOREDRAW      0x0004L
#define LBS_MULTIPLESEL   0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL	      0x0800L
#define LBS_STANDARD      (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)

/* Combo Box styles */
#define CBS_SIMPLE	      0x0001L
#define CBS_DROPDOWN	      0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L

/* scroll bar styles */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L

/* Conventional dialog box and message box command IDs */
#define IDOK         1
#define IDCANCEL     2
#define IDABORT      3
#define IDRETRY      4
#define IDIGNORE     5
#define IDYES        6
#define IDNO         7

/* Static control constants */
#define SS_LEFT       0L
#define SS_CENTER     1L
#define SS_RIGHT      2L
#define SS_ICON       3L
#define SS_BLACKRECT  4L
#define SS_GRAYRECT   5L
#define SS_WHITERECT  6L
#define SS_BLACKFRAME 7L
#define SS_GRAYFRAME  8L
#define SS_WHITEFRAME 9L
#define SS_USERITEM   10L

/* Virtual Keys, Standard Set */

#define VK_LBUTTON  0x01
#define VK_RBUTTON  0x02
#define VK_CANCEL   0x03
#define VK_MBUTTON  0x04    /* NOT contiguous with L & RBUTTON */
#define VK_BACK     0x08
#define VK_TAB      0x09
#define VK_CLEAR    0x0c
#define VK_RETURN   0x0d
#define VK_SHIFT    0x10
#define VK_CONTROL  0x11
#define VK_MENU     0x12
#define VK_PAUSE    0x13
#define VK_CAPITAL  0x14
#define VK_ESCAPE   0x1b
#define VK_SPACE    0x20

#define VK_PRIOR    0x21
#define VK_NEXT     0x22
#define VK_END      0x23
#define VK_HOME     0x24
#define VK_LEFT     0x25
#define VK_UP       0x26
#define VK_RIGHT    0x27
#define VK_DOWN     0x28

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#define VK_SELECT   0x29
#define VK_PRINT    0x2a
#define VK_EXECUTE  0x2b
#define VK_SNAPSHOT 0x2c
#define VK_INSERT   0x2d
#define VK_DELETE   0x2e
#define VK_HELP     0x2f

#define VK_NUMPAD0  0x60
#define VK_NUMPAD1  0x61
#define VK_NUMPAD2  0x62
#define VK_NUMPAD3  0x63
#define VK_NUMPAD4  0x64
#define VK_NUMPAD5  0x65
#define VK_NUMPAD6  0x66
#define VK_NUMPAD7  0x67
#define VK_NUMPAD8  0x68
#define VK_NUMPAD9  0x69
#define VK_MULTIPLY 0x6A
#define VK_ADD      0x6B
#define VK_SEPARATOR 0x6C
#define VK_SUBTRACT 0x6D
#define VK_DECIMAL  0x6E
#define VK_DIVIDE   0x6F

#define VK_F1       0x70
#define VK_F2       0x71
#define VK_F3       0x72
#define VK_F4       0x73
#define VK_F5       0x74
#define VK_F6       0x75
#define VK_F7       0x76
#define VK_F8       0x77
#define VK_F9       0x78
#define VK_F10      0x79
#define VK_F11      0x7a
#define VK_F12      0x7b
#define VK_F13      0x7c
#define VK_F14      0x7d
#define VK_F15      0x7e
#define VK_F16      0x7f
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\testing.h ===
/*---------------------------------------------------------*\
|							    |
|  TESTING.H						    |
|							    |
|  Testing's very own include file!                         |
\*---------------------------------------------------------*/



/* This has all of the defines for the wParam and lParam that go along with
 * the WM_TESTING message 
 */
/* wParam defines - Area
 */
#define   TEST_PRINTMAN 	 0x0001
#define   TEST_GDI		 0x0002


/* lParam defines - Details (in LOWORD) 
 */
#define   TEST_PRINTJOB_START	 0x0001 /* when bits start going to the port */
#define   TEST_PRINTJOB_END	 0x0002 /* when bits stop going to the port  */
#define   TEST_QUEUE_READY	 0x0003 /* when the queue is ready to accept a job */
#define   TEST_QUEUE_EMPTY	 0x0004 /* when the last job is done being sent    */

#define   TEST_START_DOC	 0x0001 /* print job is started 	     */
#define   TEST_END_DOC		 0x0002 /* print job is ended		     */


/* Defines for UserSeeUserDo and GDISeeGDIDo functions 
 */
LONG API UserSeeUserDo(WORD wMsg, WORD wParam, LONG lParam);
LONG API GDISeeGDIDo(WORD wMsg, WORD wParam, LONG lParam);

/* Defines for the various messages one can pass for the SeeDo functions. 
 */
#define SD_LOCALALLOC	0x0001	/* Alloc using flags wParam and lParam bytes.
				 * Returns handle to data.  
				 */
#define SD_LOCALFREE	0x0002  /* Free the memory allocated by handle wParam
				 */
#define SD_LOCALCOMPACT	0x0003  /* Return the number of free bytes available 
				 */
#define SD_GETUSERMENUHEAP 0x0004 /* Return the handle to the far menu heap
                                   * maintained by user. 
				   */
#define SD_GETCLASSHEADPTR 0x0005 /* Return the near pointer to the head of 
				   * the linked list of CLS structures.
				   * Interface: wParam = NULL; lParam = NULL;
				   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines ANSI-style macros for accessing arguments
*	of functions which take a variable number of arguments.
*	[ANSI]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif

#ifndef _VA_LIST_DEFINED
typedef char _FAR_ *va_list;
#define _VA_LIST_DEFINED
#endif

#define va_start(ap,v) ap = (va_list)&v + sizeof(v)
#define va_arg(ap,t) ((t _FAR_ *)(ap += sizeof(t)))[-1]
#define va_end(ap) ap = NULL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the structures, values, macros, and functions
*	used by the level 2 I/O ("standard I/O") routines.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
typedef char _FAR_ *va_list;
#define _VA_LIST_DEFINED
#endif

/* buffered I/O macros */

#define BUFSIZ	512
#ifdef _MT
#define _NFILE	40
#else
#define _NFILE	20
#endif
#define EOF	(-1)

#ifndef _FILE_DEFINED
struct _iobuf {
	char _FAR_ *_ptr;
	int   _cnt;
	char _FAR_ *_base;
	char  _flag;
	char  _file;
	};
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif


/* P_tmpnam: Directory where temporary files may be created.
 * L_tmpnam size =  size of P_tmpdir
 *	+ 1 (in case P_tmpdir does not end in "\\")
 *	+ 6 (for the temp number string)
 *	+ 1 (for the null terminator)
 */

#define  P_tmpdir "\\"
#define  L_tmpnam sizeof(P_tmpdir)+8


/* fseek constants */

#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_SET 0


/* minimum guaranteed filename length, open file count, and unique
 * tmpnam filenames.
 */

#define FILENAME_MAX 63
#define FOPEN_MAX 20
#define SYS_OPEN 20
#define TMP_MAX 32767


/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif


/* declare _iob[] array */

#ifndef _STDIO_DEFINED
#ifdef _DLL
extern FILE _FAR_ _cdecl _iob[];
#else
extern FILE _near _cdecl _iob[];
#endif
#endif


/* define file position type */

#ifndef _FPOS_T_DEFINED
typedef long fpos_t;
#define _FPOS_T_DEFINED
#endif


/* standard file pointers */

#ifndef _WINDOWS
#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])
#define stdaux (&_iob[3])
#define stdprn (&_iob[4])
#endif


#define _IOREAD 	0x01
#define _IOWRT		0x02

#define _IOFBF		0x0
#define _IOLBF		0x40
#define _IONBF		0x04

#define _IOMYBUF	0x08
#define _IOEOF		0x10
#define _IOERR		0x20
#define _IOSTRG 	0x40
#define _IORW		0x80


/* function prototypes */

#ifndef _STDIO_DEFINED
int _FAR_ _cdecl _filbuf(FILE _FAR_ *);
int _FAR_ _cdecl _flsbuf(int, FILE _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl _fsopen(const char _FAR_ *,
	const char _FAR_ *, int);
void _FAR_ _cdecl clearerr(FILE _FAR_ *);
int _FAR_ _cdecl fclose(FILE _FAR_ *);
int _FAR_ _cdecl fcloseall(void);
FILE _FAR_ * _FAR_ _cdecl fdopen(int, const char _FAR_ *);
int _FAR_ _cdecl feof(FILE _FAR_ *);
int _FAR_ _cdecl ferror(FILE _FAR_ *);
int _FAR_ _cdecl fflush(FILE _FAR_ *);
int _FAR_ _cdecl fgetc(FILE _FAR_ *);
#ifndef _WINDOWS
int _FAR_ _cdecl fgetchar(void);
#endif
int _FAR_ _cdecl fgetpos(FILE _FAR_ *, fpos_t _FAR_ *);
char _FAR_ * _FAR_ _cdecl fgets(char _FAR_ *, int, FILE _FAR_ *);
int _FAR_ _cdecl fileno(FILE _FAR_ *);
int _FAR_ _cdecl flushall(void);
FILE _FAR_ * _FAR_ _cdecl fopen(const char _FAR_ *,
	const char _FAR_ *);
#ifndef _WINDLL
int _FAR_ _cdecl fprintf(FILE _FAR_ *, const char _FAR_ *, ...);
#endif
int _FAR_ _cdecl fputc(int, FILE _FAR_ *);
#ifndef _WINDOWS
int _FAR_ _cdecl fputchar(int);
#endif
int _FAR_ _cdecl fputs(const char _FAR_ *, FILE _FAR_ *);
size_t _FAR_ _cdecl fread(void _FAR_ *, size_t, size_t, FILE _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl freopen(const char _FAR_ *,
	const char _FAR_ *, FILE _FAR_ *);
#ifndef _WINDLL
int _FAR_ _cdecl fscanf(FILE _FAR_ *, const char _FAR_ *, ...);
#endif
int _FAR_ _cdecl fsetpos(FILE _FAR_ *, const fpos_t _FAR_ *);
int _FAR_ _cdecl fseek(FILE _FAR_ *, long, int);
long _FAR_ _cdecl ftell(FILE _FAR_ *);
size_t _FAR_ _cdecl fwrite(const void _FAR_ *, size_t, size_t,
	FILE _FAR_ *);
int _FAR_ _cdecl getc(FILE _FAR_ *);
#ifndef _WINDOWS
int _FAR_ _cdecl getchar(void);
char _FAR_ * _FAR_ _cdecl gets(char _FAR_ *);
#endif
int _FAR_ _cdecl getw(FILE _FAR_ *);
#ifndef _WINDOWS
void _FAR_ _cdecl perror(const char _FAR_ *);
#endif
int _FAR_ _cdecl _pclose(FILE _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl _popen(const char _FAR_ *,
	const char _FAR_ *);
#ifndef _WINDOWS
int _FAR_ _cdecl printf(const char _FAR_ *, ...);
#endif
int _FAR_ _cdecl putc(int, FILE _FAR_ *);
#ifndef _WINDOWS
int _FAR_ _cdecl putchar(int);
int _FAR_ _cdecl puts(const char _FAR_ *);
#endif
int _FAR_ _cdecl putw(int, FILE _FAR_ *);
int _FAR_ _cdecl remove(const char _FAR_ *);
int _FAR_ _cdecl rename(const char _FAR_ *, const char _FAR_ *);
void _FAR_ _cdecl rewind(FILE _FAR_ *);
int _FAR_ _cdecl rmtmp(void);
#ifndef _WINDOWS
int _FAR_ _cdecl scanf(const char _FAR_ *, ...);
#endif
void _FAR_ _cdecl setbuf(FILE _FAR_ *, char _FAR_ *);
int _FAR_ _cdecl setvbuf(FILE _FAR_ *, char _FAR_ *, int, size_t);
#ifndef _WINDLL
int _FAR_ _cdecl sprintf(char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl sscanf(const char _FAR_ *, const char _FAR_ *, ...);
#endif
char _FAR_ * _FAR_ _cdecl tempnam(char _FAR_ *, char _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl tmpfile(void);
char _FAR_ * _FAR_ _cdecl tmpnam(char _FAR_ *);
int _FAR_ _cdecl ungetc(int, FILE _FAR_ *);
int _FAR_ _cdecl unlink(const char _FAR_ *);
#ifndef _WINDLL
int _FAR_ _cdecl vfprintf(FILE _FAR_ *, const char _FAR_ *, va_list);
#endif
#ifndef _WINDOWS
int _FAR_ _cdecl vprintf(const char _FAR_ *, va_list);
#endif
#ifndef _WINDLL
int _FAR_ _cdecl vsprintf(char _FAR_ *, const char _FAR_ *, va_list);
#endif
#define _STDIO_DEFINED
#endif

/* macro definitions */

#define feof(_stream)	  ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define fileno(_stream)   ((int)(unsigned char)(_stream)->_file)
#define getc(_stream)	  (--(_stream)->_cnt >= 0 ? 0xff & *(_stream)->_ptr++ \
	: _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
	? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#ifndef _WINDOWS
#define getchar()	  getc(stdin)
#define putchar(_c)	  putc((_c),stdout)
#endif

#ifdef _MT
#undef	getc
#undef	putc
#undef	getchar
#undef	putchar
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for
*	commonly used library functions which either don't fit somewhere
*	else, or, like toupper/tolower, can't be declared in the normal
*	place for other reasons.
*	[ANSI]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifdef	_DLL
#define _LOADDS_ _loadds
#else
#define _LOADDS_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif

/* definition of the return type for the onexit() function */

#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1

#ifndef _ONEXIT_T_DEFINED
typedef int (_FAR_ _cdecl _LOADDS_ * _cdecl onexit_t)();
#define _ONEXIT_T_DEFINED
#endif


/* data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
	int quot;
	int rem;
} div_t;

typedef struct _ldiv_t {
	long quot;
	long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif

/* maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff


/* min and max macros */

#define max(a,b)	(((a) > (b)) ? (a) : (b))
#define min(a,b)	(((a) < (b)) ? (a) : (b))


/* sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */

#define _MAX_PATH	260	/* max. length of full pathname */
#define _MAX_DRIVE	3	/* max. length of drive component */
#define _MAX_DIR	256	/* max. length of path component */
#define _MAX_FNAME	256	/* max. length of file name component */
#define _MAX_EXT	256	/* max. length of extension component */

/* external variable declarations */

#ifdef	_MT
extern int _far * _cdecl _far volatile _errno(void);
extern unsigned _far * _cdecl _far __doserrno(void);
#define errno	    (*_errno())
#define _doserrno   (*__doserrno())
#else
extern int _near _cdecl volatile errno; 	/* XENIX style error number */
extern int _near _cdecl _doserrno;		/* MS-DOS system error value */
#endif
extern char * _near _cdecl sys_errlist[];	/* perror error message table */
extern int _near _cdecl sys_nerr;		/* # of entries in sys_errlist table */

#ifdef _DLL
extern char ** _FAR_ _cdecl environ;		/* pointer to environment table */
extern int _FAR_ _cdecl _fmode; 		/* default file translation mode */
extern int _FAR_ _cdecl _fileinfo;		/* open file info mode (for spawn) */
#else
extern char ** _near _cdecl environ;		/* pointer to environment table */
extern int _near _cdecl _fmode; 		/* default file translation mode */
extern int _near _cdecl _fileinfo;		/* open file info mode (for spawn) */
#endif

extern unsigned int _near _cdecl _psp;		/* Program Segment Prefix */

/* OS major/minor version numbers */

#ifndef _WINDLL
extern unsigned char _near _cdecl _osmajor;
extern unsigned char _near _cdecl _osminor;
#endif

#define DOS_MODE	0	/* Real Address Mode */
#define OS2_MODE	1	/* Protected Address Mode */

extern unsigned char _near _cdecl _osmode;


/* function prototypes */

#ifdef	_MT
double _FAR_ _pascal atof(const char _FAR_ *);
double _FAR_ _pascal strtod(const char _FAR_ *, char _FAR_ * _FAR_ *);
ldiv_t _FAR_ _pascal ldiv(long, long);
#else	/* not _MT */
double _FAR_ _cdecl atof(const char _FAR_ *);
double _FAR_ _cdecl strtod(const char _FAR_ *, char _FAR_ * _FAR_ *);
ldiv_t _FAR_ _cdecl ldiv(long, long);
#endif

void _FAR_ _cdecl abort(void);
int _FAR_ _cdecl abs(int);
int _FAR_ _cdecl atexit(void (_cdecl _FAR_ _LOADDS_ *)(void));
int _FAR_ _cdecl atoi(const char _FAR_ *);
long _FAR_ _cdecl atol(const char _FAR_ *);
long double _FAR_ _cdecl _atold(const char _FAR_ *);
void _FAR_ * _FAR_ _cdecl bsearch(const void _FAR_ *, const void _FAR_ *,
	size_t, size_t, int (_FAR_ _cdecl *)(const void _FAR_ *,
	const void _FAR_ *));
void _FAR_ * _FAR_ _cdecl calloc(size_t, size_t);
div_t _FAR_ _cdecl div(int, int);
char _FAR_ * _FAR_ _cdecl ecvt(double, int, int _FAR_ *, int _FAR_ *);
void _FAR_ _cdecl exit(int);
void _FAR_ _cdecl _exit(int);
char _FAR_ * _FAR_ _cdecl fcvt(double, int, int _FAR_ *, int _FAR_ *);
void _FAR_ _cdecl free(void _FAR_ *);
char _FAR_ * _FAR_ _cdecl _fullpath(char _FAR_ *, const char _FAR_ *,
	size_t);
#ifndef _WINDLL
char _FAR_ * _FAR_ _cdecl gcvt(double, int, char _FAR_ *);
#endif
char _FAR_ * _FAR_ _cdecl getenv(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl itoa(int, char _FAR_ *, int);
long _FAR_ _cdecl labs(long);
unsigned long _FAR_ _cdecl _lrotl(unsigned long, int);
unsigned long _FAR_ _cdecl _lrotr(unsigned long, int);
char _FAR_ * _FAR_ _cdecl ltoa(long, char _FAR_ *, int);
void _FAR_ _cdecl _makepath(char _FAR_ *, const char _FAR_ *,
	const char _FAR_ *, const char _FAR_ *, const char _FAR_ *);
void _FAR_ * _FAR_ _cdecl malloc(size_t);
onexit_t _FAR_ _cdecl onexit(onexit_t);
#ifndef _WINDOWS
void _FAR_ _cdecl perror(const char _FAR_ *);
#endif
int _FAR_ _cdecl putenv(const char _FAR_ *);
void _FAR_ _cdecl qsort(void _FAR_ *, size_t, size_t, int (_FAR_ _cdecl *)
	(const void _FAR_ *, const void _FAR_ *));
unsigned int _FAR_ _cdecl _rotl(unsigned int, int);
unsigned int _FAR_ _cdecl _rotr(unsigned int, int);
int _FAR_ _cdecl rand(void);
void _FAR_ * _FAR_ _cdecl realloc(void _FAR_ *, size_t);
void _FAR_ _cdecl _searchenv(const char _FAR_ *, const char _FAR_ *,
	char _FAR_ *);
void _FAR_ _cdecl _splitpath(const char _FAR_ *, char _FAR_ *,
	char _FAR_ *, char _FAR_ *, char _FAR_ *);
void _FAR_ _cdecl srand(unsigned int);
long _FAR_ _cdecl strtol(const char _FAR_ *, char _FAR_ * _FAR_ *,
	int);
long double _FAR_ _cdecl _strtold(const char _FAR_ *,
	char _FAR_ * _FAR_ *);
unsigned long _FAR_ _cdecl strtoul(const char _FAR_ *,
	char _FAR_ * _FAR_ *, int);
void _FAR_ _cdecl swab(char _FAR_ *, char _FAR_ *, int);
#ifndef _WINDOWS
int _FAR_ _cdecl system(const char _FAR_ *);
#endif
char _FAR_ * _FAR_ _cdecl ultoa(unsigned long, char _FAR_ *, int);

#ifndef tolower 	/* tolower has been undefined - use function */
int _FAR_ _cdecl tolower(int);
#endif	/* tolower */

#ifndef toupper 	/* toupper has been undefined - use function */
int _FAR_ _cdecl toupper(int);
#endif	/* toupper */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\timeb.h ===
/***
*sys\timeb.h - definition/declarations for ftime()
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file define the ftime() function and the types it uses.
*   [System V]
*
****/

#ifndef _INC_TIMEB

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _TIME_T_DEFINED
typedef long    time_t;
#define _TIME_T_DEFINED
#endif 

/* structure returned by ftime system call */

#ifndef _TIMEB_DEFINED
#pragma pack(2)

struct _timeb {
    time_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
struct timeb {
    time_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
    };
#endif 

#pragma pack()
#define _TIMEB_DEFINED
#endif 


/* function prototypes */

void __cdecl _ftime(struct _timeb *);

#ifndef __STDC__
/* Non-ANSI name for compatibility */
void __cdecl ftime(struct timeb *);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_TIMEB
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the string
*	manipulation functions.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* function prototypes */

void _FAR_ * _FAR_ _cdecl memccpy(void _FAR_ *, const void _FAR_ *,
	int, unsigned int);
void _FAR_ * _FAR_ _cdecl memchr(const void _FAR_ *, int, size_t);
int _FAR_ _cdecl memcmp(const void _FAR_ *, const void _FAR_ *,
	size_t);
int _FAR_ _cdecl memicmp(const void _FAR_ *, const void _FAR_ *,
	unsigned int);
void _FAR_ * _FAR_ _cdecl memcpy(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memmove(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memset(void _FAR_ *, int, size_t);
void _FAR_ _cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);
char _FAR_ * _FAR_ _cdecl strcat(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strchr(const char _FAR_ *, int);
int _FAR_ _cdecl strcmp(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcmpi(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcoll(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl stricmp(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strcpy(char _FAR_ *, const char _FAR_ *);
size_t _FAR_ _cdecl strcspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strdup(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strerror(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strerror(int);
size_t _FAR_ _cdecl strlen(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strlwr(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strncat(char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strncmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strnicmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strncpy(char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strnset(char _FAR_ *, int, size_t);
char _FAR_ * _FAR_ _cdecl strpbrk(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strrchr(const char _FAR_ *, int);
char _FAR_ * _FAR_ _cdecl strrev(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strset(char _FAR_ *, int);
size_t _FAR_ _cdecl strspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strstr(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strtok(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strupr(char _FAR_ *);
size_t _FAR_ _cdecl strxfrm (char _FAR_ *, const char _FAR_ *,
	size_t);

/* model independent function prototypes */

void _far * _far _cdecl _fmemccpy(void _far *, const void _far *,
	int, unsigned int);
void _far * _far _cdecl _fmemchr(const void _far *, int, size_t);
int _far _cdecl _fmemcmp(const void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemcpy(void _far *, const void _far *,
	size_t);
int _far _cdecl _fmemicmp(const void _far *, const void _far *,
	unsigned int);
void _far * _far _cdecl _fmemmove(void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemset(void _far *, int, size_t);
char _far * _far _cdecl _fstrcat(char _far *, const char _far *);
char _far * _far _cdecl _fstrchr(const char _far *, int);
int _far _cdecl _fstrcmp(const char _far *, const char _far *);
int _far _cdecl _fstricmp(const char _far *, const char _far *);
char _far * _far _cdecl _fstrcpy(char _far *, const char _far *);
size_t _far _cdecl _fstrcspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrdup(const char _far *);
char _near * _far _cdecl _nstrdup(const char _far *);
size_t _far _cdecl _fstrlen(const char _far *);
char _far * _far _cdecl _fstrlwr(char _far *);
char _far * _far _cdecl _fstrncat(char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrncmp(const char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrnicmp(const char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrncpy(char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrnset(char _far *, int, size_t);
char _far * _far _cdecl _fstrpbrk(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrrchr(const char _far *, int);
char _far * _far _cdecl _fstrrev(char _far *);
char _far * _far _cdecl _fstrset(char _far *, int);
size_t _far _cdecl _fstrspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrstr(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrtok(char _far *, const char _far *);
char _far * _far _cdecl _fstrupr(char _far *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\strtable.h ===
/****************************************************************************/
/*                                      */
/*  STRTABLE.H -                                */
/*                                      */
/*  StringTable Defines                         */
/*                                      */
/****************************************************************************/

/* STRINGTABLE Defines */
#define STR_WINDOWS     0
#define STR_COLORS      1
#define STR_DESKPATTERN     2
#define STR_FONTS       3
#define STR_BLINK       4
#define STR_SWAPBUTTONS     5
#define STR_DBLCLKSPEED     6
#define STR_TYPEAHEAD       7
#define STR_GRID        8
#define STR_BEEP        9
#define STR_MOUSETHRESH1        10
#define STR_MOUSETHRESH2        11
#define STR_MOUSESPEED      12
#define STR_KEYSPEED        13
#define STR_BORDER      14
#define STR_QSIZE       15

#define STR_CLASSSTART      16
#define STR_BUTTONCLASS     16
#define STR_EDITCLASS       17
#define STR_STATICCLASS     18
#define STR_LISTBOXCLASS    19
#define STR_SCROLLBARCLASS  20
#define STR_COMBOBOXCLASS   21
#define STR_MDICLASS        22
#define STR_COMBOLISTBOXCLASS   23

#define STR_COLORSTART      32
#define STR_SCROLLBAR       32
#define STR_BACKGROUND      33
#define STR_ACTIVETITLE     34
#define STR_INACTIVETITLE   35
#define STR_MENU        36
#define STR_WINDOW      37
#define STR_WINDOWFRAME     38
#define STR_MENUTEXT        39
#define STR_WINDOWTEXT      40
#define STR_TITLETEXT       41
#define STR_ACTIVEBORDER    42
#define STR_INACTIVEBORDER  43
#define STR_APPWORKSPACE    44
#define STR_HIGHLIGHT       45
#define STR_HIGHLIGHTTEXT   46
#define STR_BTNFACE             47
#define STR_BTNSHADOW           48
#define STR_GRAYTEXT            49
#define STR_BTNTEXT             50
#define STR_INACTIVECAPTIONTEXT 51

#define STR_FILEPORT            60
#define STR_CANTOPEN            61
#define STR_OVERWRITE           62
#define STR_MOREWINDOWS     63

#define STR_ICONHORZSPACING     64
#define STR_ICONVERTSPACING     65
#define STR_ICONTITLEWRAP       66

#define STR_DTBITMAP        67
#define STR_DTSTYLE     68
#define STR_DTORIGINX       69
#define STR_DTORIGINY       70

#define STR_NETDRIVER       71
#define STR_BOOT        72
#define STR_LANGDRIVER      73
#define STR_SYSTEMINI       74
#define STR_SYSERR              75
#define STR_DIVBYZERO           76
#define STR_UNTITLED            77
#define STR_ERROR               78
#define STR_TASKMAN             79

#define STR_DESKTOP     80
#define STR_PATTERNS        81
#define STR_NONE        82
#define STR_TILEWALL        83

#define STR_OK                  84
#define STR_CANCEL              85
#define STR_ABORT               86
#define STR_RETRY               87
#define STR_IGNORE              88
#define STR_YES                 89
#define STR_NO                  90
#define STR_ACCELERATORS    91
#define STR_AM                  92
#define STR_PM                  93
#define STR_MENUSHOWDELAY       94
#define STR_MENUHIDEDELAY       95
#define STR_MENUDROPALIGNMENT   96
#define STR_DOUBLECLICKWIDTH    97
#define STR_DOUBLECLICKHEIGHT   98
#define STR_SCREENSAVETIMEOUT   99
#define STR_SCREENSAVEACTIVE    100
#define STR_SCREENSAVEEXE       101
#define STR_DRIVERS             102
#define STR_NOMEMBITMAP         103
#define STR_BEEPYES     104
#define STR_BEEPNO      105
#define STR_KEYDELAY        106
#define STR_DRAGFULLWINDOWS     107
#define STR_ICONTITLEFACENAME   108
#define STR_ICONTITLESIZE       109
#define STR_ICONTITLESTYLE      110
#define STR_FASTALTTAB          111
#define STR_INRESTORENETCONNECT 112

#define STR_COMMMODULENAME      200
#define STR_COMMWRITESTRING     201
#define STR_COMMREADSTRING      202
#define STR_COMMENABLENOTIFICATION 203
#define STR_MOUSEMODULENAME     204


    /* 256 - 512 are strings for network errors
     */

#define STR_NETCONNMSG      256
#define STR_NETCONNTTL      257
#define STR_NETCRASHEDTITLE     258
#define STR_NETCRASHEDMSG       259
#define STR_NETERRORS       275

#define STR_SEARCH_TAG      513 // don't change, these are hard
#define STR_USER_NAME       514 // coded in SHELL.DLL
#define STR_ORG_NAME        515 // ugh!
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\userproc.h ===
/*
 *
 *  UserProc.H
 *
 *  Addition exports from USER.EXE
 */

/*  lParam of WM_DROPOBJECT and WM_QUERYDROPOBJECT points to one of these.
 */
typedef struct _dropstruct
  {
    HWND  hwndSource;
    HWND  hwndSink;
    WORD  wFmt;
    LPARAM dwData;
    POINT ptDrop;
    LPARAM dwControlData;
  } DROPSTRUCT;

#define DOF_EXECUTABLE	0x8001
#define DOF_DOCUMENT	0x8002
#define DOF_DIRECTORY	0x8003
#define DOF_MULTIPLE	0x8004

typedef DROPSTRUCT FAR * LPDROPSTRUCT;

WORD FAR PASCAL GetInternalWindowPos(HWND,LPRECT,LPPOINT);
BOOL FAR PASCAL SetInternalWindowPos(HWND,WORD,LPRECT,LPPOINT);

void FAR PASCAL CalcChildScroll(HWND,WORD);
void FAR PASCAL ScrollChildren(HWND,WORD,WORD,LONG);

LRESULT FAR PASCAL DragObject(HWND hwndParent, HWND hwndFrom, WORD wFmt,
    LPARAM dwData, HANDLE hCursor);
BOOL FAR PASCAL DragDetect(HWND hwnd, POINT pt);

void FAR PASCAL FillWindow(HWND hwndBrush, HWND hwndPaint, HDC hdc,
    HBRUSH hBrush);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the various declarations and definitions
*	for the time routines.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* implementation defined time types */

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* structure for use with localtime(), gmtime(), etc. */

#ifndef _TM_DEFINED
struct tm {
	int tm_sec;	/* seconds after the minute - [0,59] */
	int tm_min;	/* minutes after the hour - [0,59] */
	int tm_hour;	/* hours since midnight - [0,23] */
	int tm_mday;	/* day of the month - [1,31] */
	int tm_mon;	/* months since January - [0,11] */
	int tm_year;	/* years since 1900 */
	int tm_wday;	/* days since Sunday - [0,6] */
	int tm_yday;	/* days since January 1 - [0,365] */
	int tm_isdst;	/* daylight savings time flag */
	};
#define _TM_DEFINED
#endif


/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif


/* clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC	1000

/* clock ticks macro - archaic version */

#define CLK_TCK 	1000


/* extern declarations for the global variables used by the ctime family of
 * routines.
 */

#ifdef _DLL
extern int _FAR_ _cdecl daylight;     /* non-zero if daylight savings time is used */
extern long _FAR_ _cdecl timezone;    /* difference in seconds between GMT and local time */
extern char _FAR_ * _FAR_ _cdecl tzname[2]; /* standard/daylight savings time zone names */
#else
extern int _near _cdecl daylight;     /* non-zero if daylight savings time is used */
extern long _near _cdecl timezone;    /* difference in seconds between GMT and local time */
extern char * _near _cdecl tzname[2]; /* standard/daylight savings time zone names */
#endif


/* function prototypes */

#ifdef _MT
double _FAR_ _pascal difftime(time_t, time_t);
#else
double _FAR_ _cdecl difftime(time_t, time_t);
#endif

char _FAR_ * _FAR_ _cdecl asctime(const struct tm _FAR_ *);
char _FAR_ * _FAR_ _cdecl ctime(const time_t _FAR_ *);
#ifndef _WINDLL
clock_t _FAR_ _cdecl clock(void);
#endif
struct tm _FAR_ * _FAR_ _cdecl gmtime(const time_t _FAR_ *);
struct tm _FAR_ * _FAR_ _cdecl localtime(const time_t _FAR_ *);
time_t _FAR_ _cdecl mktime(struct tm _FAR_ *);
#ifndef _WINDLL
size_t _FAR_ _cdecl strftime(char _FAR_ *, size_t, const char _FAR_ *,
	const struct tm _FAR_ *);
#endif
char _FAR_ * _FAR_ _cdecl _strdate(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strtime(char _FAR_ *);
time_t _FAR_ _cdecl time(time_t _FAR_ *);
void _FAR_ _cdecl tzset(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\types.h ===
/***
*sys\types.h - types returned by system level calls for file and time info
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines types used in defining values returned by system
*   level calls for file status and time information.
*   [System V]
*
****/

#ifndef _INC_TYPES

#ifndef _TIME_T_DEFINED
typedef unsigned long time_t;
#define _TIME_T_DEFINED
#endif 

#ifndef _INO_T_DEFINED
typedef unsigned short _ino_t;      /* i-node number (not used on DOS) */
#ifndef __STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif 
#define _INO_T_DEFINED
#endif 

#ifndef _DEV_T_DEFINED
typedef short _dev_t;           /* device code */
#ifndef __STDC__
/* Non-ANSI name for compatibility */
typedef short dev_t;
#endif 
#define _DEV_T_DEFINED
#endif 

#ifndef _OFF_T_DEFINED
typedef long _off_t;            /* file offset value */
#ifndef __STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif 
#define _OFF_T_DEFINED
#endif 

#define _INC_TYPES
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *									    *
 *	This file is only modified by the official builder to update the    *
 *	VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG 
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <ver.h> 
#endif 

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION 		    "3.1"
#define VER_PRODUCTVERSION_STR      "3.10\0"
#define VER_PRODUCTVERSION          3,10,0,103

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\utime.h ===
/***
*sys\utime.h - definitions/declarations for utime()
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines the structure used by the utime routine to set
*   new file access and modification times.  NOTE - MS-DOS
*   does not recognize access time, so this field will
*   always be ignored and the modification time field will be
*   used to set the new time.
*
****/

#ifndef _INC_UTIME

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _TIME_T_DEFINED
typedef long    time_t;
#define _TIME_T_DEFINED
#endif 

/* define struct used by utime() function */

#ifndef _UTIMBUF_DEFINED

struct _utimbuf {
    time_t actime;      /* access time */
    time_t modtime;     /* modification time */
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
struct utimbuf {
    time_t actime;      /* access time */
    time_t modtime;     /* modification time */
    };
#endif 

#define _UTIMBUF_DEFINED
#endif 


/* function prototypes */

int __cdecl _utime(const char *, struct _utimbuf *);

#ifndef __STDC__
/* Non-ANSI name for compatibility */
int __cdecl utime(const char *, struct utimbuf *);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_UTIME
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\w32sys.h ===
/*************************************************************************\
* w32sys.h
*
* Win32S i/f
*
* 11-18-91    AviN   Created
\*************************************************************************/

#ifndef APIENTRY
#define APIENTRY _far _pascal _loadds
#endif

HANDLE APIENTRY GetPEResourceTable(WORD hFile);
HANDLE APIENTRY LoadPEResource(HANDLE hFile, LPSTR lpResTable, LPSTR lpId, LPSTR lpType);
WORD   APIENTRY GetW32SysVersion(VOID);
BOOL   APIENTRY GetPEExeInfo(LPSTR lpFileName, LPSTR lpBuff, WORD cbBuff, WORD iInfo);
WORD   APIENTRY ExecPE(LPSTR  lpPath, LPSTR lpCmd, WORD nCmdShow);
BOOL   APIENTRY IsPEFormat(LPSTR lpFileName, WORD hFile);

/*
 * Constants for GetPEExeInfo iInfo parameter
 */
#define GPEI_MODNAME     1
#define GPEI_DESCRIPTION 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\wfwnet.h ===
/*
 *      Windows/Network Interface
 *      Copyright (C) Microsoft 1989-1992
 *
 *      Standard WINNET Driver Header File, spec version 3.10
 *                                               rev. 3.10.05 ;Internal
 */


#ifndef _INC_WFWNET
#define _INC_WFWNET	/* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */


#define CHAR	char		
#define SHORT	short		
#define LONG	long		

typedef WORD far * 	LPWORD;

typedef unsigned char UCHAR;	
typedef unsigned short USHORT;	
typedef unsigned long ULONG;

typedef unsigned short SHANDLE;
typedef void far      *LHANDLE;

typedef unsigned char far  *PSZ;
typedef unsigned char near *NPSZ;

typedef unsigned char far  *PCH;
typedef unsigned char near *NPCH;

typedef UCHAR  FAR *PUCHAR;
typedef USHORT FAR *PUSHORT;
typedef ULONG  FAR *PULONG;


#ifndef DRIVDATA
/* structure for Device Driver data */

typedef struct _DRIVDATA {	/* driv */
	LONG	cb;
	LONG	lVersion;
	CHAR	szDeviceName[32];
	CHAR	abGeneralData[1];
} DRIVDATA;
typedef DRIVDATA far *PDRIVDATA;
#endif

#ifndef API
#define API WINAPI
#endif

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_WFWNET */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\ver.h ===
/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef _INC_VER
#define _INC_VER

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)			id
#else
#define ID(id)			MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO		ID(16)		/* Version stamp res type */
#define VS_VERSION_INFO		ID(1)  		/* Version stamp res ID */
#define VS_USER_DEFINED		ID(100)		/* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FFI_SIGNATURE	0xFEEF04BDL
#define	VS_FFI_STRUCVERSION	0x00010000L
#define	VS_FFI_FILEFLAGSMASK	0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FF_DEBUG		0x00000001L
#define	VS_FF_PRERELEASE	0x00000002L
#define	VS_FF_PATCHED		0x00000004L
#define	VS_FF_PRIVATEBUILD	0x00000008L
#define	VS_FF_INFOINFERRED	0x00000010L
#define	VS_FF_SPECIALBUILD	0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define	VOS_UNKNOWN		0x00000000L
#define	VOS_DOS			0x00010000L
#define	VOS_OS216		0x00020000L
#define	VOS_OS232		0x00030000L
#define	VOS_NT			0x00040000L

#define	VOS__BASE		0x00000000L
#define	VOS__WINDOWS16		0x00000001L
#define	VOS__PM16		0x00000002L
#define	VOS__PM32		0x00000003L
#define	VOS__WINDOWS32		0x00000004L

#define	VOS_DOS_WINDOWS16	0x00010001L
#define	VOS_DOS_WINDOWS32	0x00010004L
#define	VOS_OS216_PM16		0x00020002L
#define	VOS_OS232_PM32		0x00030003L
#define	VOS_NT_WINDOWS32	0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define	VFT_UNKNOWN		0x00000000L
#define	VFT_APP			0x00000001L
#define	VFT_DLL			0x00000002L
#define	VFT_DRV			0x00000003L
#define	VFT_FONT		0x00000004L
#define	VFT_VXD			0x00000005L
#define	VFT_STATIC_LIB		0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define	VFT2_UNKNOWN		0x00000000L
#define VFT2_DRV_PRINTER	0x00000001L
#define	VFT2_DRV_KEYBOARD	0x00000002L
#define	VFT2_DRV_LANGUAGE	0x00000003L
#define	VFT2_DRV_DISPLAY	0x00000004L
#define	VFT2_DRV_MOUSE		0x00000005L
#define	VFT2_DRV_NETWORK	0x00000006L
#define	VFT2_DRV_SYSTEM		0x00000007L
#define	VFT2_DRV_INSTALLABLE	0x00000008L
#define	VFT2_DRV_SOUND		0x00000009L
#define	VFT2_DRV_COMM		0x0000000AL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER	0x00000001L
#define	VFT2_FONT_VECTOR	0x00000002L
#define	VFT2_FONT_TRUETYPE	0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE	0x0001

#define VFF_CURNEDEST		0x0001
#define VFF_FILEINUSE		0x0002
#define VFF_BUFFTOOSMALL	0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL	0x0001
#define VIFF_DONTDELETEOLD	0x0002

#define VIF_TEMPFILE		0x00000001L
#define VIF_MISMATCH		0x00000002L
#define VIF_SRCOLD		0x00000004L

#define VIF_DIFFLANG		0x00000008L
#define VIF_DIFFCODEPG		0x00000010L
#define VIF_DIFFTYPE		0x00000020L

#define VIF_WRITEPROT		0x00000040L
#define VIF_FILEINUSE		0x00000080L
#define VIF_OUTOFSPACE		0x00000100L
#define VIF_ACCESSVIOLATION	0x00000200L
#define VIF_SHARINGVIOLATION	0x00000400L
#define VIF_CANNOTCREATE	0x00000800L
#define VIF_CANNOTDELETE	0x00001000L
#define VIF_CANNOTRENAME	0x00002000L
#define VIF_CANNOTDELETECUR	0x00004000L
#define VIF_OUTOFMEMORY		0x00008000L

#define VIF_CANNOTREADSRC	0x00010000L
#define VIF_CANNOTREADDST	0x00020000L

#define VIF_BUFFTOOSMALL	0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#pragma pack()

#endif  /* !RC_INVOKED */
#endif  /* !_INC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\win3deb.inc ===
; declare a simple interface to control debugging messages

BegData	macro
  _DATA	SEGMENT PARA PUBLIC 'DATA'
endm

EndData	macro
  _DATA ENDS
endm

DEB_ERROR	=  1
DEB_WARN	=  2
DEB_TRACE	=  4
DEB_FERROR	=  8	;; fatal error - terminate app
DEB_IERROR	= 10h
DEB_IWARN	= 20h
DEB_ITRACE	= 40h
DEB_IFERROR	= 80h ;; fatal error - terminate app
DEB_FERRORS	= DEB_FERROR or DEB_IFERROR
DEB_ERRORS	= DEB_ERROR OR DEB_IERROR OR DEB_FERRORS
DEB_WARNS	= DEB_WARN OR DEB_IWARN
DEB_TRACES	= DEB_TRACE OR DEB_ITRACE
DEB_NOCRLF	= 8000h	;; No CR/LF in string
DEB_BREAKLEVEL	= DEB_ERRORS or 0ff00h
DEB_INFOLEVEL	= DEB_BREAKLEVEL or DEB_WARNS

DECLARE_DEBUG	macro	comp

  ifdef Win3DebData
  else
    extrn _Win3InfoLevel:word, _Win3BreakLevel:word

;    BegData
      extrn	_&comp&InfoLevel:word, _&comp&BreakLevel:word
;    EndData

  endif
  ifdef Win3Deb
  else
    extrn	_&comp&DebugTest:far
  endif

  &comp&DebugOut	macro	flag, string, vals
    local sloc, cnt
    BegData
      sloc label byte
       db  string
       ife (flag) and DEB_NOCRLF
	 db 13, 10
       endif
       db  0
    EndData
    cnt = 0
    irp foo, <vals>
      push	foo
      cnt = cnt + 1
    endm
    push	offset sloc
    push	flag AND NOT DEB_NOCRLF
    call	_&comp&DebugTest
    add	sp, 4+(2*cnt)
  endm
endm

declare_areas macro name, comp, list
  deb_loc = 100h
  deb_areas equ <list>

  irp val, <list>
    DEB_&comp&&val = deb_loc
    deb_loc = deb_loc + deb_loc
    ifdef Win3Deb
      BegData
      STR_&comp&&val label byte
	 db  "&name &val: ", 0
      EndData
    endif
  endm
  ifdef Win3Deb
    BegData
      STR_&comp&Trace db "Trace: ", 0
      STR_&comp&Warn db "Warning: ", 0
      STR_&comp&Error db "Error: ", 0
      STR_&comp	db	"&name: ", 0
      STR_&comp&table	dw	dataoffset STR_&comp
      irp val, <list>
	dw dataoffset STR_&comp&&val
      endm
    EndData
  endif
endm

declare_infolevel macro comp
  local skip
  BegData
;    public _&comp&InfoLevel, _&comp&BreakLevel
;    _&comp&InfoLevel  dw  DEB_INFOLEVEL		;; component can override
;    _&comp&BreakLevel dw  DEB_BREAKLEVEL
  EndData

  _&comp&DebugTest proc far		;; Per-component - check right flags
  public _&comp&DebugTest
	push	bp
	mov	bp, sp
	push	ds
	push	ax
	mov	ax, _DATA
	cmp	ax, 1000h		;; DATA should be selector, not addr
	jnc	skip
	mov	ds, ax
	assume	ds:_DATA

	mov	ax, [bp+6]		;; See if component enabled
	and	ax, [_&comp&InfoLevel]
	cmp	ax, [bp+6]
	jnz	skip

	push	es			;; See if system enabled
	push	seg _Win3InfoLevel
	pop	es
	and	al, byte ptr es:[_Win3InfoLevel] ;; test low 8 bits for system-wide
	pop	es
	cmp	ax, [bp+6]
	jnz	skip

					;; Print it, so format message
	push	bx
	test	al, DEB_ERRORS
	mov	bx, dataoffset STR_&comp&Error
	jnz	@F
	test	al, DEB_WARNS
	mov	bx, dataoffset STR_&comp&Warn
	jnz	@F
	test	al, DEB_TRACES
	mov	bx, dataoffset STR_&comp&Trace
	jnz	@F
	jmp	short deb_no_msg_type

@@:
	push	bx
	call	KOutDSStr
deb_no_msg_type:
	mov	bx, dataoffset STR_&comp&Table
	or	ah, ah
	jz	deb_show_it
@@:
	add	bx, 2
	shr	ah, 1
	jnz	@B
deb_show_it:
	push	[bx]			;; push parameter
	call	KOutDSStr
	pop	bx			;; restore reg

	pop	ax
	push	[bp+8]
	call	KOutDSStr
	push	ax
	mov	ax, [bp+6]
	and	ax, [_&comp&BreakLevel]
	jz	skip

	push	es
	push	seg _Win3BreakLevel
	pop	es
	and	ax, es:_Win3BreakLevel
	pop	es
	jz	skip

	int	3
  skip:
	test    byte ptr [bp+6], DEB_FERRORS
	jz	@F
	push	0
	push	DGROUP
	push	word ptr [bp+8]
	cCall	FatalAppExit	;,<0,DGROUP,[bp+8]>
@@:
	pop	ax
	pop	ds
	pop	bp
	retf
  _&comp&DebugTest endp
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\windefs.inc ===
;***************************************************************************
;                                                                          *
;   Copyright (C) 1983,1984 by Microsoft Inc.                              *
;                                                                          *
;***************************************************************************

;       Macros for disabling and restoring hardware interrupt enable flag
;
;       The LeaveCrit macro has been updated for the mask problem on
;       the 80286 processor.

include vint.inc


EnterCrit   MACRO
        pushf
        FCLI
ENDM

LeaveCrit   macro   reg 		;;this macro will restore the state of
ifnb	<reg>				;;the interrupt flag to what is was
	pop	reg&x			;;before EnterCrit.  All other flags
	test	reg&h, 2		;;are discarded.
	jz	@f
        FSTI
@@:
else
	push	bp
	mov	bp, sp
	test	byte ptr [bp+3], 2
	jz	@f
        FSTI
@@:
	pop	bp
	popf
endif
	endm


if 0
POPFF	equ	<LeaveCrit>

LeaveCrit   MACRO
        POPFF
ENDM
endif

POPFF	MACRO				;;this macro will restore ALL flags,
	local	a			;;EXCEPT the interrupt flag, to
	jmp	$+3			;;their previous state
a       label   near
        iret
        push    cs
        call    a
ENDM




;***************************************************************************
;                                                                          *
;   Inquire data structures for Timer, Keyboard, Mouse and Cursor modules  *
;                                                                          *
;***************************************************************************

TIMERINFO       STRUC
tiResolution    DD      0       ; #microseconds each timer tick
TIMERINFO       ENDS

KBINFO          STRUC
kbRanges        DB      4 dup (0)  ; Far East ranges for KANJI
kbStateSize     DW      0       ; #bytes of state info maintained by TOASCII
KBINFO          ENDS


MOUSEINFO       STRUC
msExists        DB      0       ; true => mouse exists
msRelative      DB      0       ; true => relative coordinate
msNumButtons    DW      0       ; number of buttons on the mouse
msRate          DW      0       ; maximum rate of mouse input events
msXThresh       DW      0       ; threshold before acceleration
msYThresh       DW      0       ;
msXRes          DW      0       ; x resolution
msYRes          DW      0       ; y resolution
MOUSEINFO       ENDS


CURSORINFO      STRUC
dpXRate         DW      0       ; horizontal mickey/pixel ratio
dpYRate         DW      0       ; vertical mickey/pixel ratio
CURSORINFO      ENDS


;***************************************************************************
;                                                                          *
; Cursor data structure passed to OEM routines.  Defines a graphics display*
; cursor in terms of a hotspot, an AND mask and an XOR mask.  The hot      *
; spot defines the pixel within the cursor that is the cursor is "pointing"*
; to.  So when displaying a cursor at location X,Y the pixel that          *
; is the hot spot should be painted at that X,Y coordinate.  The "shape"   *
; of the cursor is defined by two pixel masks.  The first mask is ANDed    *
; with the bits in the display bitmap and the second mask is XORed with    *
; the result to determine the bits that will be placed in the display      *
; bitmap.  The bits for the masks are in the byte array that begins        *
; at the csBits field, with the AND mask bits first, followed by the       *
; XOR mask bits.  The csWidthBytes field is the width of ONE mask, in      *
; bytes.  Currently, MS-WIN will only generate cursors whose width and     *
; height are both 16.                                                      *
;                                                                          *
;***************************************************************************

cursorShape     STRUC
csHotX          DW      0
csHotY          DW      0
csWidth         DW      0
csHeight        DW      0
csWidthBytes    DW      0
csColor         DW      0
    ; Beginning of an array of bytes that contain the bits for the AND and
    ; XOR masks.  The first csHeight * csWidthBytes bytes contain the bits
    ; for the AND mask and the next csHeight * csWidthBytes bytes contain
    ; the bits for the XOR mask.
;csBits          DB  2*2*16 DUP (?)
cursorShape     ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\wife.h ===
/****************************************************************************\
*
* WIFE.H : East Asia Windows Intelligent Font Environment definitions
*
******************************************************************************
*
*
* Copyright (c) 1990  Microsoft Corporation
*
* Brief instruction
* -----------------
*
*   This header file is a common single header for WIFE drivers.										    *
*   If you are a developer of FontDriver, please write coding as follow 									    *
*
*   #define WIFE_CREATE_FONTDRIVER														      *
*   #include <wife.h>																      *
*
*   If you are a developer of DeviceDriver which are display or printer
*   drivers, please write coding as follow.														      *
*
*   #define WIFE_CREATE_DEVICEDRIVER														      *
*   #include <wife.h>																      *
*
*   If you don't define both of symbols, only common defenitions are
*   available.
*
*   Aug.17,1990 Akira Kawamata [AkiraK] 									     *
*
\****************************************************************************/

/****** OS/2-like common data type definitions ******************************/

#ifndef WIFEH_NODATATYPES
typedef unsigned short int USHORT;
typedef short int          SHORT;
typedef unsigned long      ULONG;
typedef LONG FAR *         LPLONG;
typedef LONG NEAR *        NPLONG;
typedef ULONG FAR *        LPULONG;
typedef ULONG NEAR *       NPULONG;
typedef SHORT FAR *        LPSHORT;
typedef SHORT NEAR *       NPSHORT;
typedef USHORT FAR *       LPUSHORT;
typedef USHORT NEAR *      NPUSHORT;
typedef char               CHAR;
typedef unsigned char      UCHAR;

typedef VOID NEAR *        NPVOID;

/* FIXED Number */
typedef struct {
	USHORT Fraction;
	SHORT Integer;
} FIXED;
#endif //WIFEH_NODATATYPES

/****** Graphics handling support definitions *******************************/

#ifndef WIFEH_NOGRAPHSUPPORT
/* rotation angle by 90degree */
typedef enum {
	ANGLE000 = 0,
	ANGLE090 = 1,
	ANGLE180 = 2,
	ANGLE270 = 3
} QUOTER_ANGLE;
#define FixedToQuoterAngle(f) ((f.Integer/90)%4)
#define RotationToQuoterAngle(r) ((r/900)%4)

typedef DWORD PACKEDPOINT;
typedef DWORD PACKEDLOGICALPOINT;
typedef DWORD PACKEDPHYSICALPOINT;
typedef struct {
	short x,y;
} XYPOINT;
typedef union {
	PACKEDPOINT packed;
	XYPOINT point;
} UNIONPOINT, NEAR * NPUNIONPOINT, FAR * LPUNIONPOINT;

#define PartOfX(xy)	((SHORT)(xy))
#define PartOfY(xy)	((SHORT)(((DWORD)(xy) >> 16) & 0xFFFF))
#define MAKELONG_LO_HI MAKELONG
#define PackXY(x,y)	((DWORD)MAKELONG_LO_HI((WORD)x,(WORD)y))
#endif //WIFEH_NOGRAPHSUPPORT

/****** UBCS : Unified Byte Character Set, data types defenition  **********/

#ifndef WIFEH_NOUBCS
typedef	USHORT UBCHAR;
typedef	UBCHAR NEAR * NPUBCHAR;
typedef	UBCHAR FAR * LPUBCHAR;

#define UBEOS (0)		/* End Of String */
#define UBNEWLINE (0x0a0d)	/* New Line (CR/LF) */

#define IsSbcsUBChar(uc) ((uc & 0xff00) == 0x2000)
#define IsDbcsUBChar(uc) ((uc & 0xff00) != 0x2000)
#endif //WIFEH_NOUBCS

/****** Utility macros *****************************************************/

#ifndef WIFEH_NOUTILITYMACROS
/* return type of GlobalLock is LPSTR, but it's to be LPVOID */
#define AnyGlobalLock(h) ((LPVOID)GlobalLock(h))
#define AnyLocalLock(h) ((NPVOID)LocalLock(h))
#define TypedLocalLock(h,t) ((t NEAR *)LocalLock(h))
#define TypedGlobalLock(h,t) ((t FAR *)GlobalLock(h))

/* utility macro which is not included windows.h */
#define MAKEWORD(l,h) ((WORD)((BYTE)l+(((BYTE)h) << 8)))
#endif //WIFEH_NOUTILITYMACROS

/****** GDIDEFS.H support definitions **************************************/

#ifdef WIFE_ENABLE_GDIDEFS_SUPPORT
typedef FONTINFO FAR * LPFONTINFO;
typedef DRAWMODE FAR * LPDRAWMODE;
typedef TEXTXFORM FAR * LPTEXTXFORM;
#endif //WIFE_ENABLE_GDIDEFS_SUPPORT

/****** Character set definitions ******************************************/

#ifndef WIFEH_NOCHARSET
typedef enum {
	CHARSET_ANSI = 0,
	CHARSET_SYMBOL = 2,
	CHARSET_SHIFTJIS = 128,
	CHARSET_KOREA = 129,
	CHARSET_CHINESEBIG5 = 136,
	CHARSET_OEM = 255
} CHAR_SET;
#endif //WIFEH_NOCHARSET


/***************************************************************************/
/****** Control function support definitions  ******************************/

#ifndef WIFEH_NOCONTROL

/******************************************/
/*      FONT DRIVER MEDIA DESCRIPTER      */
/******************************************/
#ifndef WIFEWH_NOMEDIA
/* FDMEDIA enumration type */
typedef enum {
	FDMEDIA_ON_FILE = 1,
	FDMEDIA_ON_DRIVER = 2,
	FDMEDIA_ON_REMOVEABLE_HARDWARE = 4,
	FDMEDIA_ON_FIXED_HARDWARE = 8,
	FDMEDIA_UNDEFINED = 0x4000,
	FDMEDIA_ANY_MEDIA = 0x7fff
} FDMEDIA;
#endif


/******************************************/
/*    MINOR CHARACTER SETS DEFENITION     */
/******************************************/
#ifndef WIFEH_NOMINORCHARSET_IN_JAPAN

/* general default minor character set */
#define FD_MINOR_CHARSET_DEFAULT 1

/* Minor Character Set in Japan */
#define	FD_MINOR_CHARSET_NEW_JIS 1	/* new JIS */
#define	FD_MINOR_CHARSET_OLD_JIS 2	/* old JIS */
#define	FD_MINOR_CHARSET_IBM_JIS 4	/* IBM JIS */
#define	FD_MINOR_CHARSET_NEC_JIS 8	/* NEC JIS */

#endif

/******************************************/
/*        CODE AREA STRUCTURE             */
/******************************************/
#ifndef WIFEH_NOCODEAREA

typedef struct {
	UBCHAR CodeFrom;
	UBCHAR CodeTo;
} CODEAREA, NEAR * NPCODEAREA, FAR * LPCODEAREA;

#endif

/******************************************/
/*    SPECIAL ESCAPE FUNCTION ORDERS      */
/******************************************/

/* subfunction orders in WIFE */
#define FD_CONTROL_RESERVED		(0xa20)
#define FD_CONTROL_RESERVED_LIMIT	(FD_CONTROL_RESERVED+0x3f)

/* standard subfunctions */
#define FD_CONTROL_QUERY_ESC_SUPPORT	(FD_CONTROL_RESERVED+0)
#define FD_CONTROL_SUPPORT_CODES	(FD_CONTROL_RESERVED+1)
#define FD_CONTROL_NUMBER_OF_ATTRIBUTE	(FD_CONTROL_RESERVED+2)
#define FD_CONTROL_NAME_OF_ATTRIBUTE	(FD_CONTROL_RESERVED+3)
#define FD_CONTROL_SET_ATTRIBUTE	(FD_CONTROL_RESERVED+4)
#define FD_CONTROL_GET_ATTRIBUTE	(FD_CONTROL_RESERVED+5)
#define FD_CONTROL_SET_MINOR_CHARSET	(FD_CONTROL_RESERVED+6)
#define FD_CONTROL_GET_MINOR_CHARSET	(FD_CONTROL_RESERVED+7)
#define FD_CONTROL_GET_FONT_DRIVER_NAME	(FD_CONTROL_RESERVED+8)
#define FD_CONTROL_GET_FONT_PACK_NAME	(FD_CONTROL_RESERVED+9)
#define FD_CONTROL_GET_MEDIA		(FD_CONTROL_RESERVED+10)
#define FD_CONTROL_GET_DBCS_STRING_KERN	(FD_CONTROL_RESERVED+11)

/* EUDC related subfunctions */
#define FD_CONTROL_LEVEL2_EUDC_INFO	(FD_CONTROL_RESERVED+12)

/* private interface subfunctions */
#define FD_CONTROL_USER			(FD_CONTROL_RESERVED+0x10)
#define FD_CONTROL_USER_LIMIT		(FD_CONTROL_RESERVED+0x1f)

/* Chinese related functions */
#define FD_CONTROL_GET_USERFONT_TECH	(FD_CONTROL_RESERVED+0x20)
#define FD_CONTROL_SET_USERFONT 	(FD_CONTROL_RESERVED+0x21)
#define FD_CONTROL_SETUP_DIALOG 	(FD_CONTROL_RESERVED+0x22)
#define FD_CONTROL_SET_DEFAULT_CHAR	(FD_CONTROL_RESERVED+0x23)

#ifdef WIFE_ENABLE_EUDC_SUPPORT

typedef struct {
	ULONG	cb;		/* length of this structure */
	BOOL	bForceFixedPitch;	/* force fixed pitch */
	BOOL	bVerticalFont;	/* vertical font flag */
	FIXED	fxCharRot;	/* character rotation */
	FIXED	fxInlineDir;	/* inline rotation */
	USHORT	usLimitWidth;	/* maximum width of cachable */
	SHORT	sFixedASpace;	/* font width when bForceFixedPitch is TRUE */
	USHORT	usFixedBSpace;	/* font width when bForceFixedPitch is TRUE */
	SHORT	sFixedCSpace;	/* font width when bForceFixedPitch is TRUE */
} EUDC_CONTEXT, NEAR * NPEUDC_CONTEXT, FAR * LPEUDC_CONTEXT;

#endif

#endif


#ifndef WIFEH_NOFDCOMMONDEFENITION
typedef LONG HFF;
typedef LONG HFC;
typedef HANDLE HFD;
typedef HANDLE HFB;

#define FACESIZE 32
#define GLYPHNAMESIZE 16

#define WIFEERR_FACENAME_NOT_FOUND        23004L
#define WIFEERR_FD_ALREADY_INSTALLED      23005L
#define WIFEERR_INVALID_CONTEXTINFO       23006L
#define WIFEERR_NOT_A_FONT_FILE           23007L
#define WIFEERR_INVALID_FONT_SELECTION    23008L
#define WIFEERR_INVALID_FORMAT            23009L
#define WIFEERR_BUSY_HFC                  230010L
#define WIFEERR_INVALID_HFC               230011L
#define WIFEERR_INVALID_INDEX             230012L
#define WIFEERR_INVALID_QUERY_TYPE        230013L
#define WIFEERR_CONTEXT_NOT_SET           230014L

#define FD_QUERY_ABC_WIDTHS     2L
#define FD_QUERY_KERNINGPAIRS   3L

#define FD_QUERY_CHARIMAGE      1L
#define FD_QUERY_OUTLINE        2L
#define FD_QUERY_BITMAPMETRICS  4L

typedef UBCHAR GLYPH; /* gi */
typedef LPUBCHAR LPGLYPH; /* lpgi */

typedef struct _POINTFX { /* ptfx, npptfx, lpptfx */
	FIXED x;
	FIXED y;
} POINTFX, NEAR * NPPOINTFX, FAR * LPPOINTFX;

typedef struct _ABC_TRIPLETS { /* abc, npabc, lpabc */
	SHORT  sA;
	USHORT usB;
	SHORT  sC;
} ABC_TRIPLETS, NEAR * NPABC_TRIPLETS, FAR * LPABC_TRIPLETS;

typedef struct _SIZEL { /* sizl */
	ULONG cx; // Width.
	ULONG cy; // Height.
} SIZEL;

typedef struct _BITMAPMETRICS { /* bmm, npbmm, lpbmm */
	SIZEL     sizlExtent;
	POINTFX   pfxOrigin;    /* Return character origin. */
	POINTFX   pfxCharInc;   /* Return the device advance width */
} BITMAPMETRICS, NEAR * NPBITMAPMETRICS, FAR * LPBITMAPMETRICS;

typedef struct _MAT2 { /* mat */
	FIXED eM11;
	FIXED eM12;
	FIXED eM21;
	FIXED eM22;
} MAT2;

typedef struct _FD_KERNINGPAIRS  { /* krnpr, npkrnpr, lpkrnpr */
	GLYPH     giFirst;
	GLYPH     giSecond;
	LONG      eKerningAmount;
} FD_KERNINGPAIRS, NEAR * NPFD_KERNINGPAIRS, FAR * LPFD_KERNINGPAIRS;


typedef struct _CONTEXTINFO  { /* ci */
	ULONG     cb;        /* Length in bytes of this structure. */
	ULONG     fl;        /* Flags. */
	SIZEL     sizlPPM;    /* Device resolution in pels/meter. */
	POINTFX   pfxSpot;   /* Spot size in pels. */
	MAT2      matXform;  /* Notional to Device transform. */
} CONTEXTINFO, NEAR * NPCONTEXTINFO, FAR * LPCONTEXTINFO;


typedef struct _CHARATTR  { /* chattr */
	ULONG     cb;
	ULONG     iQuery;   /* Query type. */
	GLYPH     gi;       /* Glyph index in font. */
	LPBYTE    lpBuffer;  /* Bitmap buffer. */
	ULONG     cbLen;    /* Size of buffer in bytes. */
} CHARATTR, NEAR * NPCHARATTR, FAR * LPCHARATTR;


/* bit-constants for fsType in IFIMETRICS  */

#define IFIMETRICS_FIXED       0x0001   /* Fixed pitch */
#define IFIMETRICS_LICENSED    0x0002   /* dummy defenition */
#define IFIMETRICS_SPARSE      0x0004   /* Incomplete font */
#define IFIMETRICS_SCALEABLE   0x8000   /* scalable font */

/* bit-constant for fsDefn in IFIMETRICS   */

#define IFIMETRICS_OUTLINE     0x0001   /* dummy definition */
					/* 1 - Outline. 0 - Raster */

/* bit-constant for fsSelection in IFIMETRICS */

#define IFIMETRICS_ITALIC      0x8000  /*Italic */
#define IFIMETRICS_UNDERSCORE  0x4000  /*Underscored */
#define IFIMETRICS_OVERSTRUCK  0x2000  /*Overstruck */

/* bit-constant for fsSelection in IFIMETRICS valid for bitmap fonts */

#define IFIMETRICS_NEGATIVE    0x1000   /*Negative image */
#define IFIMETRICS_HOLLOW      0x0800   /*Outline (hollow) */


typedef struct _IFIMETRICS {   /* ifim */
                                                                    /* UNITS */
  UCHAR   szFamilyname[FACESIZE];   /*Font Family Name, e.g. Roman */
  UCHAR   szFacename[FACESIZE];     /*Face name, e.g. Tms Rmn Bold Italic */
  UCHAR   szGlyphlistName[GLYPHNAMESIZE]; /*e.g. PM316, Latin-2, Greek */
  USHORT  idRegistry;          /*Dummy                                     I */
  SHORT   sCapEmHeight;        /*Height of uppercase M                     N */
  SHORT   sXHeight;            /*Nominal height of lowercase               N */
  SHORT   sMaxAscender;        /*Maximum height above baseline of any char N */
  SHORT   sMaxDescender;       /*Maximum depth below baseline of any char  N */
  SHORT   sLowerCaseAscent;    /*Maximum height above baseline of any a-z  N */
  SHORT   sLowerCaseDescent;   /*Maximum depth below basiline of any a-z   N */
  SHORT   sInternalLeading;    /*White space within character              N */
  SHORT   sExternalLeading;    /*White space between lines                 N */
  SHORT   sAveCharWidth;       /*Weighted average character width          N */
  SHORT   sMaxCharInc;         /*Maximum character increment               N */
  SHORT   sEmInc;              /*Increment for Capitals (typically 'M')    N */
  SHORT   sMaxBaselineExt;     /*Height of character cell                  N */
  FIXED   fxCharSlope;         /*Slope angle, degrees, clockwise           D */
  FIXED   fxInlineDir;         /*Drawing direction, degrees clockwise      D */
  FIXED   fxCharRot;           /*Glyph rotation in cell, degrees clockwise D */
  USHORT  usWeightClass;       /*Character weight, 1-9 (1=ultra-light)     I */
  USHORT  usWidthClass;        /*Character width, 1-9 (1=ultra condensed)  I */
  SHORT   sEmSquareSize;       /*Em Square size, x-direction               N */
  GLYPH   giFirstChar;         /*Number of first glyph in font             I */
  GLYPH   giLastChar;          /*Number of last glyph in font              I */
  GLYPH   giDefaultChar;       /*Glyph used if requested glyph invalid     I */
  GLYPH   giBreakChar;         /*Space glyph                               I */
  ULONG   aulPanose [1];       /*Panose Number */
  USHORT  usNominalPointSize;  /*Point size for which font was designed    N */
  USHORT  usMinimumPointSize;  /*Minimum point size scaling for font	   N */
  USHORT  usMaximumPointSize;  /*Maximum point size scaling for font	   N */
  USHORT  fsType;              /*Type indicators  (see #defines)           B */
  USHORT  fsDefn;              /*Font definition data (see #defines)       B */
  USHORT  fsSelection;         /*Font selection flags (see #defines)       B */
  USHORT  fsCapabilities;      /*Font capabilities must be 0               B */
  SHORT   sSubscriptXSize;     /*Size in x-direction of subscript          N */
  SHORT   sSubscriptYSize;     /*Size in y-direction of subscript          N */
  SHORT   sSubscriptXOffset;   /*Offset in x-direction of subscript        N */
  SHORT   sSubscriptYOffset;   /*Offset in y-direction of subscript        N */
  SHORT   sSuperscriptXSize;   /*Size in x-direction of superscript        N */
  SHORT   sSuperscriptYSize;   /*Size in y-direction of superscript        N */
  SHORT   sSuperscriptXOffset; /*Offset in x-direction of superscript      N */
  SHORT   sSuperscriptYOffset; /*Offset in y-direction of superscript      N */
  SHORT   sUnderscoreSize;     /*Underscore size                           N */
  SHORT   sUnderscorePosition; /*Underscore position                       N */
  SHORT   sStrikeoutSize;      /*Strikeout size                            N */
  SHORT   sStrikeoutPosition;  /*Strikeout position                        N */
  SHORT   cKerningPairs;       /*Number of kerning pairs in pair table     I */
  ULONG   ulFontClass;         /*IBM font classification                   B */
} IFIMETRICS, NEAR * NPIFIMETRICS, FAR * LPIFIMETRICS;

#ifdef ENABLE_CONTROL_TAG

/* Tag structure for Fd(i)Control */
typedef struct {
	USHORT SubFunction;
	LPDEVICE lpDevice;
	LPFONTINFO lpFontStructure;
	LPTEXTXFORM lpXform;
	LPVOID lpInData;
} CONTROLTAG, FAR * LPCONTROLTAG;
#else
typedef struct {
	USHORT SubFunction;
	LPVOID lpDevice;
	LPVOID lpFontStructure;
	LPVOID lpXform;
	LPVOID lpInData;
} CONTROLTAG, FAR * LPCONTROLTAG;
#endif

#endif


/****************************************/
/* Attribute bits for FdOpenFontContext */
/****************************************/
#ifndef WIFEH_NOWIFEMAN_EUDCFONTCONTEXT
#define OFC_EUDC_CONTEXT (0x80000000L)
#endif


#ifdef WIFE_CREATE_FONTDRIVER

/***********************************************/
/* PROTO-TYPE FOR EACH FUNCTION in FONT DRIVER */
/***********************************************/

LONG FAR PASCAL FdClaimFontFile( LPSTR lpszFileName );

LONG FAR PASCAL FdConvertFontFile( 
	LPSTR lpszSrcFileName, 
	LPSTR lpszDestDirName, 
	LPSTR lpszResultPackName 
);
HFF FAR PASCAL FdLoadFontFile( LPSTR lpszPackName );

LONG FAR PASCAL FdUnloadFontFile( HFF hFF );

LONG FAR PASCAL FdQueryFaces( 
	HFF hFF,
	LPIFIMETRICS lpIfiMetrics,
	ULONG cMetricLen,
	ULONG cFontCount,
	ULONG cStart
);

HFC FAR PASCAL FdOpenFontContext( HFF hFF, ULONG ulFont ); 

LONG FAR PASCAL FdSetFontContext(
	HFC hFC,
	LPCONTEXTINFO lpContextInfo
);

LONG FAR PASCAL FdCloseFontContext( HFC hFC ); 

LONG FAR PASCAL FdQueryFaceAttr(
	HFC       hFC,
	ULONG     iQuery,
	LPVOID    lpBuffer,
	ULONG     cb,
	LPVOID    lpIndex,
	SHORT     Start
);

LONG FAR PASCAL FdQueryCharAttr(
	HFC        hFC,
	LPCHARATTR lpCharAttr,
	LPBITMAPMETRICS lpbmm
);

SHORT FAR PASCAL FdControl(
	HFC hFC,
	LPCONTROLTAG lpControlTag,
	LPVOID lpOutData
);


/******************************************/
/*       FAR PTR TO EACH FUNCTION         */
/******************************************/
typedef LONG (FAR PASCAL * LPFDCLF)( LPSTR lpszFileName );

typedef LONG (FAR PASCAL * LPFDCFF)(
	LPSTR lpszSrcFileName, 
	LPSTR lpszDestDirName, 
	LPSTR lpszResultPackName 
);

typedef HFF (FAR PASCAL * LPFDLFF)( LPSTR lpszPackName );

typedef LONG (FAR PASCAL * LPFDQF)(
	HFF hFF,
	LPIFIMETRICS lpIfiMetrics,
	ULONG cMetricLen,
	ULONG cFontCount,
	ULONG cStart
);

typedef LONG (FAR PASCAL * LPFDUFF)( HFF hFF );

typedef HFC (FAR PASCAL * LPFDOFC)( HFF hFF, ULONG ulFont ); 

typedef LONG (FAR PASCAL * LPFDSFC)(
	HFC hFC,
	LPCONTEXTINFO lpContextInfo
);

typedef LONG (FAR PASCAL * LPFDCFC)( HFC hFC ); 

typedef LONG (FAR PASCAL * LPFDQFA)(
	HFC       hFC,
	ULONG     iQuery,
	LPVOID    lpBuffer,
	ULONG     cb,
	LPVOID    lpIndex,
	SHORT     Start
);

typedef LONG (FAR PASCAL * LPFDQCA)(
	HFC        hFC,
	LPCHARATTR lpCharAttr,
	LPBITMAPMETRICS lpbmm
);

typedef SHORT (FAR PASCAL * LPFDCTL)(
	HFC hFC,
	LPCONTROLTAG lpControlTag,
	LPVOID lpOutData
);

typedef struct _FDHEADER { /* fdhdr */
        ULONG   cbLength;            /* Length of FDHEADER */
        UCHAR   strId[16];           /* String 'WIFE FONT DRIVER' */
        UCHAR   szTechnology[40];    /* Identifier of Font Driver technology */
        ULONG   ulVersion;           /* IFI version number (0x0100) */
        ULONG   ufDeviceCaps;        /* Capabilities of device */
        NPVOID	npfddisp;
        SHORT	dummy1;
} FDHEADER, NEAR * NPFDHEADER, FAR * LPFDHEADER;

#endif

#ifdef WIFE_CREATE_DEVICEDRIVER

/***********************************************/
/* PROTO-TYPE FOR EACH FUNCTION in WIFEMAN.DLL */
/***********************************************/

/***********************************************/
/*         Module Install Manager              */
/***********************************************/
#ifndef WIFEH_NOWIFEMAN_MIM

typedef BOOL (FAR PASCAL * LPCBMEAD)
		( LPSTR lpszFoundFileName, LPSTR lpszDescriptionName );
BOOL FAR PASCAL MimEnumAvailableDrivers
			( LPSTR lpszSeachFilePath, LPCBMEAD lpfCallBack );

typedef BOOL (FAR PASCAL * LPCBMEAP)
		( HFD hFD, LPSTR lpszPackName );
BOOL FAR PASCAL MimEnumAvailablePacks
	( HFD hFD, LPSTR lpszPackName, LPCBMEAP lpfCallBack );

HFD FAR PASCAL MimAddFontDriver( LPSTR lpszFileName );

HFF FAR PASCAL MimAddFontPack( HFD hFD, LPSTR lpszPackName );

BOOL FAR PASCAL MimRemoveFontDriver( HFD hFD );

BOOL FAR PASCAL MimRemoveFontPack( HFD hFD, HFF hFontPack );

HFD FAR PASCAL MimEnumFontDrivers( HFD hLastDriver );

HFF FAR PASCAL MimEnumFontPacks( HFD hFD, HFF hLastPack );

HFC FAR PASCAL MimOpenFontContext( HFD hFD, HFF hFF, ULONG ulFont );

LONG FAR PASCAL MimCloseFontContext( HFD hFD, HFF hFF, HFC hFC );

typedef enum {
	MIMGETINFO_FD_DESCRIPTION = 0,
	MIMGETINFO_FF_DESCRIPTION = 1,
	MIMGETINFO_FD_FILENAME = 2,
	MIMGETINFO_FF_FILENAME = 3,
	MIMGETINFO_FD_USAGE = 4,
	MIMGETINFO_FF_USAGE = 5,
	MIMGETINFO_FD_INSTALL_COUNT = 6,
	MIMGETINFO_FF_INSTALL_COUNT = 7
} MIMGETINFO_ORDER;

SHORT FAR PASCAL MimGetInformations( 
	MIMGETINFO_ORDER order,
	HFD hFD,
	HFF hFF,
	LPVOID AnswerBuffer,
	USHORT SizeOfBuffer
);

#endif

/***********************************************/
/*         Font Driver Interface               */
/***********************************************/
#ifndef WIFEH_NOWIFEMAN_FDI

LONG FAR PASCAL  FdiClaimFontFile( HFD hFD, LPSTR lpszFileName );

LONG FAR PASCAL FdiConvertFontFile( 
	HFD hFD,
	LPSTR lpszSrcFileName, 
	LPSTR lpszDestDirName, 
	LPSTR lpszResultPackName 
);

HFF FAR PASCAL FdiLoadFontFile( HFD hFD, LPSTR lpszPackName );

LONG FAR PASCAL FdiUnloadFontFile( HFD hFD, HFF hFF );

LONG FAR PASCAL FdiQueryFaces( 
	HFD hFD, 
	HFF hFF,            // Font File handle 
	LPIFIMETRICS lpIfiMetrics,   // Buffer for the metrics 
	ULONG cMetricLen,    // Length of the metrics structure 
	ULONG cFontCount,    // # of fonts wanted. 
	ULONG cStart         // index of the font to start with 
);

HFC FAR PASCAL FdiOpenFontContext( HFD hFD, HFF hFF, ULONG ulFont ); 

LONG FAR PASCAL FdiSetFontContext(
	HFD hFD, 
	HFC hFC,
	LPCONTEXTINFO lpContextInfo
);

LONG FAR PASCAL FdiCloseFontContext( HFD hFD, HFC hFC ); 

LONG FAR PASCAL FdiQueryFaceAttr(
	HFD hFD, 
	HFC       hFC,
	ULONG     iQuery,
	LPVOID    lpBuffer,
	ULONG     cb,
	LPVOID    lpIndex,
	SHORT     Start
);

LONG FAR PASCAL FdiQueryCharAttr(
	HFD hFD, 
	HFC        hFC,
	LPCHARATTR lpCharAttr,
	LPBITMAPMETRICS lpbmm
);

SHORT FAR PASCAL FdiControl(
	HFD hFD, 
	HFC hFC,
	LPCONTROLTAG lpControlTag,
	LPVOID lpOutData
);

#endif

/***********************************************/
/*         Font Cacheing Manager               */
/***********************************************/
#ifdef WIFE_ENABLE_FCM

#define FCM_WIFE_CHARACTER 1
#define FCM_CLIP_OUT 2
#define FCM_LEFT_CLIP 0x0100
#define FCM_RIGHT_CLIP 0x0200
#define FCM_TOP_CLIP 0x0400
#define FCM_BOTTOM_CLIP 0x0800

typedef struct {
	USHORT	SizeOfStruct;	/* size of structire */
	WORD	WifeFlag;	/* FCM processing flags */
	UBCHAR	ubCode;		/* character code */
	LPSTR	lpCacheBuffer; /* long ptr to cache bitmap */
	SHORT	nBitWidth;	/* x size of character image */
	SHORT	nBitHeight;	/* y size of character image */
	SHORT	nByteWidth;	/* byte width size in alloctaed buffer */
	USHORT	InternalIndex;	/* RESERVED FOR SYSTEM USE */
} FCM_CHARACTERISTIC, NEAR *NP_FCM_CHARACTERISTIC, FAR *LP_FCM_CHARACTERISTIC;

typedef struct {
	USHORT	SizeOfStruct;	/* size of structire */
	WORD	WifeFlag;	/* FCM processing flags */
	UBCHAR	ubCode;		/* character code */
	LPSTR	lpCacheBuffer; /* long ptr to cache bitmap */
	SHORT	nBitWidth;	/* x size of character image */
	SHORT	nBitHeight;	/* y size of character image */
	SHORT	nByteWidth;	/* byte width size in alloctaed buffer */
	USHORT	InternalIndex;	/* RESERVED FOR SYSTEM USE */

	SHORT	xPosOnDst;	/* x position on dst device */
	SHORT	yPosOnDst;	/* y position on dst device */

} FCM_EXTCHARACTERISTIC, 
	NEAR * NP_FCM_EXTCHARACTERISTIC, FAR * LP_FCM_EXTCHARACTERISTIC;


HFB FAR PASCAL FcmCreateCacheBuffer(
	HFD hFD,
	HFF hFF,
	ULONG ulFont,
	LPTEXTXFORM lpXform,
	USHORT usMinorCharSet,
	USHORT usAttribute
);

BOOL FAR PASCAL FcmDeleteCacheBuffer( HFB hFontBuffer );

SHORT FAR PASCAL FcmRequestImages( 
	HFB hFontBuffer,
	LP_FCM_CHARACTERISTIC AnswerBuffer,
	short length
);

BOOL FAR PASCAL FcmReleaseImages( 
	HFB hFontBuffer,
	LP_FCM_CHARACTERISTIC AnswerBuffer,
	short length
);

HFB FAR PASCAL FcmRequestDefaultFB( 
	LPFONTINFO lpFont, 
	LPTEXTXFORM lpTextXform 
);

BOOL FAR PASCAL FcmReleaseDefaultFB( HFB hFB );

#define FCMCALC_BIGFONT 1
#define FCMCALC_ROUGHCLIPINFO 2
#define FCMCALC_DETAILCLIPINFO 4

DWORD FAR PASCAL FcmCalculateTextExtent(
	HFB         hFB,
	LPSTR       lpString,
	short       count,
	LPFONTINFO  lpFont,
	LPDRAWMODE  lpDrawMode,
	LPTEXTXFORM lpXform,
	LPSHORT     lpCharWidths,
	USHORT      usMode
);

SHORT FAR PASCAL FcmCalculateOutputPositions(
	HFB             hFB,
	LP_FCM_EXTCHARACTERISTIC lpFcmCharacteristics,
	SHORT		nArrayLength,
	LPSHORT		lpx,
	LPSHORT		lpy,
	LPRECT		lpClipRect,
	LPSTR		FAR * lplpString,
	LPSHORT		lpcount,
	LPFONTINFO	lpFont,
	LPDRAWMODE	lpDrawMode,
	LPTEXTXFORM     lpXform,
	LPSHORT         FAR * lplpCharWidths,
	USHORT          usMode
);


SHORT FAR PASCAL FcmCleanUp( VOID );

HFB FAR PASCAL FcmEnumFontBuffers( HFB hLastBuffer );

HFC FAR PASCAL FcmGetFontContext( HFB hFB );

SHORT FAR PASCAL FcmCalcByteWidth( SHORT nBitWidth );

SHORT FAR PASCAL FcmForceCacheIn( HFB hFB, LPUBCHAR lpubStr );

BOOL FAR PASCAL FcmValidateFC( HFB hFB );

BOOL FAR PASCAL FcmUnvalidateFC( HFB hFB );

LONG FAR PASCAL FcmQueryFaceAttr(
	HFB         hFB,
	ULONG       iQuery,
	LPABC_TRIPLETS  lpBuffer,
	ULONG       cb,
	LPUBCHAR    lpIndex,
	UBCHAR      Start
);

#ifdef WIFE_ENABLE_FCM_CONTROL

SHORT FAR PASCAL FcmIsProcessableDeviceControl( 
	HFB hFB,
	SHORT nFunction,
	GAIJIINFO FAR * lpGI
);

SHORT FAR PASCAL FcmProcessDeviceControl( 
	HFB hFB,
	SHORT nFunction,
	GAIJIINFO FAR * lpGI,
	LPVOID lpOutData
);

#endif

USHORT FAR PASCAL FcmGetEUDCLeadByteRange( HFB hFB );

HFB FAR PASCAL FcmGetEUDCFB( HFB hFB );

USHORT FAR PASCAL FcmGetCharWidth(
	HFB         hFB,
	LPUSHORT    lpBuffer,
	USHORT      wFirstChar,
	USHORT      wLastChar,
	LPFONTINFO  lpFont,
	LPDRAWMODE  lpDrawMode,
	LPTEXTXFORM lpFontTrans,
	USHORT      usExpandPixels,
	USHORT      usMode
);

#endif

#endif

/***********************************************/
/*  WIFEMAN's Miscellaneous Service Functions  */
/***********************************************/
#ifndef WIFEH_NOWIFEMAN_MISC

BOOL FAR PASCAL MiscIsDBCSLeadByte( CHAR_SET CharSet, USHORT ch );

#define MiscIsMBCSCharSet(c) (MiscIsDBCSLeadByte(c,0xffff))

VOID FAR PASCAL MiscSetErroInfo( ULONG ErrorCode );

ULONG FAR PASCAL MiscGetErroInfo( VOID );

SHORT FAR PASCAL MiscWarningMessage( 
	HANDLE hInst, 
	USHORT idsMsg, 
	USHORT idsTitle, 
	USHORT mode 
);

SHORT FAR PASCAL MiscWarningMessageWithArgument( 
	HANDLE hInst, 
	USHORT idsMsg, 
	USHORT idsTitle, 
	LPSTR lpszArgument,
	USHORT mode
);

#ifdef ENABLE_MESSAGEBOX

/* MessageBox() Flags */
#define MB_OK		    0x0000
#define MB_OKCANCEL	    0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL	    0x0003
#define MB_YESNO	    0x0004
#define MB_RETRYCANCEL	    0x0005

#define MB_ICONHAND	    0x0010
#define MB_ICONQUESTION	    0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP	    MB_ICONHAND

#define MB_DEFBUTTON1	    0x0000
#define MB_DEFBUTTON2	    0x0100
#define MB_DEFBUTTON3	    0x0200

#define MB_APPLMODAL	    0x0000
#define MB_SYSTEMMODAL	    0x1000
#define MB_TASKMODAL	    0x2000

#define MB_NOFOCUS	    0x8000

#define MB_TYPEMASK	    0x000F
#define MB_ICONMASK	    0x00F0
#define MB_DEFMASK	    0x0F00
#define MB_MODEMASK	    0x3000
#define MB_MISCMASK	    0xC000

#endif /* ENABLE_MESSAGEBOX */

USHORT FAR PASCAL ubstrlen( LPUBCHAR cp );

LPUBCHAR FAR PASCAL ubstrcpy( LPUBCHAR dst, LPUBCHAR src );

LPUBCHAR FAR PASCAL ubstrncpy( LPUBCHAR dst, LPUBCHAR src, USHORT limit );

LPUBCHAR FAR PASCAL ubstrcat( LPUBCHAR dst, LPUBCHAR src );

LPUBCHAR FAR PASCAL ubstrncat( LPUBCHAR dst, LPUBCHAR src, USHORT limit );

SHORT FAR PASCAL ubstrcmp( LPUBCHAR str1, LPUBCHAR str2 );

USHORT FAR PASCAL AscizToUz( 
	LPUBCHAR dst, 
	LPSTR src, 
	USHORT limit,
	CHAR_SET CharSet
);

USHORT FAR PASCAL UzToAsciz(
	LPSTR dst, 
	LPUBCHAR src, 
	USHORT limit 
);

VOID FAR PASCAL MiscTrancateString( 
	LPSTR lpszStr, 
	SHORT length, 
	SHORT CharSet 
);

#define MiscTrancateByDefaultCharSet(s,l) MiscTrancateString(s,l,-1)

ULONG FAR PASCAL MiscGetVersion( VOID );

USHORT FAR PASCAL MiscGetEUDCLeadByteRange( CHAR_SET csCharSet );

BYTE FAR PASCAL MiscConvertFontFamily( LPSTR szFamilyName );

BYTE FAR PASCAL MiscConvertCharSet( LPSTR CharSetString );

#ifdef WIFE_ENABLE_FONT_STRUCT_CONVERT

/* follow two values are only for usLogicalMapFlag parameter */
/* in MiscIfiMetricsToLogFont function.  */
#define LOGMAP_IGNORE_DESCENT 1
#define LOGMAP_IGNORE_INTERNAL_LEADING 2
#define LOGMAP_NEGATIVE (0x8000)

VOID FAR PASCAL MiscIfiMetricsToLogFont( 
	LPLOGFONT lpLogFont, 
	LPIFIMETRICS lpIFIMetrics,
	USHORT usLogicalMapFlag
);

VOID FAR PASCAL MiscIfiMetricsToTextMetrics( 
	LPTEXTMETRIC lpTextMetrics, 
	LPIFIMETRICS lpIFIMetrics 
);

#endif

#ifdef WIFE_ENABLE_FONT_STRUCT_MAKE

VOID FAR PASCAL MiscMakeTextXform(
	LPTEXTXFORM lpTXF,
	LPIFIMETRICS lpIM,
	LPLOGFONT lpLF
);

#endif

#ifndef WIFEH_NO_HUGE_SUPPORT
LPVOID FAR PASCAL MiscAddHugePtr( LPVOID src, ULONG offset );
USHORT FAR PASCAL MiscGetSegmentIncrement( VOID );
#endif

#ifndef WIFEH_NO_CONTROL_RANGES
BOOL FAR PASCAL MiscIsWifeControl( SHORT function );
BOOL FAR PASCAL MiscIsGaijiControl( SHORT function );
#endif

#ifndef WIFEH_NO_STRETCHER
BOOL FAR PASCAL MiscStretchMonoFontImage(
	LPVOID	lpDestImage,
	USHORT	usSizeOfDestX,
	USHORT	usSizeOfDestY,
	LPVOID	lpSrcImage,
	USHORT	usSizeOfSrcX,
	USHORT	usSizeOfSrcY
);
#endif

#ifdef WIFE_ENABLE_QUICK_SEARCH_TABLE

typedef struct {
	HFD hFD;
	HFF hFF;
	ULONG ulFont;
	BOOL bScalable;
	LOGFONT LogFont;
}QUICK_SEARCH_TABLE, NEAR * NP_QUICK_SEARCH_TABLE, FAR * LP_QUICK_SEARCH_TABLE;

LP_QUICK_SEARCH_TABLE FAR PASCAL MiscValidateQuickSearchTable( 
	USHORT usLogicalMapFlag 
);

BOOL FAR PASCAL MiscUnvalidateQuickSearchTable( 
	USHORT usLogicalMapFlag 
);

typedef LP_QUICK_SEARCH_TABLE (FAR PASCAL * LPMISCVALIDATEQST)(
	USHORT usLogicalMapFlag 
);

typedef BOOL (FAR PASCAL * LPMISCUNVALIDATEQST)(
	USHORT usLogicalMapFlag 
);

#define NMISCVALIDATEQST (67)
#define NMISCUNVALIDATEQST (68)

#endif

#ifdef WIFE_ENABLE_NOTIFY_FUNCTIONS

typedef enum {
	WN_ADD_FONTDRIVER = 0,
	WN_ADD_FONTPACKAGE = 1,
	WN_REMOVE_FONTDRIVER = 2,
	WN_REMOVE_FONTPACKAGE = 3,
	WN_REGISTER_SYSTEM_EUDC_CHAR = 4,
	WN_CHANGE_SYSTEM_EUDC_FILE = 5
} WIFENOTIFY_ORDER;

typedef struct {
	HFD hTargetFontDriver;
} WNS_FONTDRIVER;

typedef struct {
	HFD hTargetFontDriver;
	HFF hTargetFontPackage;
} WNS_FONTPACKAGE;

typedef struct {
	HFD hTargetFontDriver;
	HFF hTargetFontPackage;
	UBCHAR ubRegistedCharCode;
} WNS_REGISTER_SYSTEM_EUDC_CHAR;

typedef struct {
	HFD hTargetFontDriver;
	HFF hTargetFontPackage;
	LPSTR lpszNewFileName;
} WNS_WN_CHANGE_SYSTEM_EUDC_FILE;

typedef BOOL (FAR PASCAL * LPNOTIFYCALLBACKFUNC)(
	WIFENOTIFY_ORDER NotifyOrder,
	LPVOID lpParamBlock
);

BOOL FAR PASCAL MiscRegisterNotifyFunction(
	LPNOTIFYCALLBACKFUNC lpfnCallBack
);

BOOL FAR PASCAL MiscUnregisterNotifyFunction(
	LPNOTIFYCALLBACKFUNC lpfnCallBack
);

#endif

#endif


/***********************************************/
/*    DIAGNOSTIC TEST&CHECKING FUNCTIONS       */
/***********************************************/
#ifdef ENABLE_DIAGNOSTIC_FUNCTION

/* test and return error code  */
SHORT FAR PASCAL DiagSelfCheck( VOID );

/* invoke self test and make error record file, display warning dialog */
SHORT FAR PASCAL DiagSelfCheckAndWarning( VOID );

#endif


/************************************************/
/* THESE ARE PRIVATE INTERFACE FOR TEST PROGRAM */
/************************************************/
#ifdef ENABLE_TEST_PROGRAM_INTERFACE

LPVOID FAR PASCAL DiagLocalLockAnything( LOCALHANDLE hAny );
LPVOID FAR PASCAL DiagLocalUnlockAnything( LOCALHANDLE hAny );
SHORT FAR PASCAL DiagGetConfirmString( LPSTR buffer, SHORT length );

#endif

/* end of wife.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\winexp.h ===
#ifndef NOATOM
/* atom manager internals */
#define ATOMSTRUC struct atomstruct
typedef ATOMSTRUC *PATOM;
typedef ATOMSTRUC {
    PATOM chain;
    WORD  usage;             /* Atoms are usage counted. */
    BYTE  len;               /* length of ASCIZ name string */
    BYTE  name;              /* beginning of ASCIZ name string */
} ATOMENTRY;

typedef struct {
    int     numEntries;
    PATOM   pAtom[ 1 ];
} ATOMTABLE;
ATOMTABLE * PASCAL pAtomTable;
#endif

LPSTR	API lstrbscan(LPSTR, LPSTR);
LPSTR	API lstrbskip(LPSTR, LPSTR);

int	API OpenPathName(LPSTR, int);
int	API DeletePathName(LPSTR);
WORD	API _ldup(int);


/* scheduler things that the world knows not */
BOOL	API WaitEvent( HANDLE );
BOOL	API PostEvent( HANDLE );
BOOL	API KillTask( HANDLE );

/* print screen hooks */
BOOL	API SetPrtScHook(FARPROC);
FARPROC API GetPrtScHook(void);


/* scroll bar messages */
#define SBM_SETPOS      WM_USER+0
#define SBM_GETPOS      WM_USER+1
#define SBM_SETRANGE    WM_USER+2
#define SBM_GETRANGE    WM_USER+3
#define SBM_ENABLE_ARROWS WM_USER+4

/* module stuff */
HANDLE	API GetDSModule( WORD );
HANDLE	API GetDSInstance( WORD );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\windows.h ===
/*****************************************************************************\
*                                                                             *
* windows.h -   Windows functions, types, and definitions                     *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1985-1992, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file:
*
* WINVER            Windows version number (0x030a).  To exclude
*                   definitions introduced in version 3.1 (or above)
*                   #define WINVER 0x0300 before #including <windows.h>
*
* #define:          To prevent inclusion of:
*
* NOKERNEL          KERNEL APIs and definitions
* NOGDI             GDI APIs and definitions
* NOUSER            USER APIs and definitions
* NOSOUND           Sound APIs and definitions
* NOCOMM            Comm driver APIs and definitions
* NODRIVERS         Installable driver APIs and definitions
*
* NOMINMAX          min() and max() macros
* NOLOGERROR        LogError() and related definitions
* NOPROFILER        Profiler APIs
* NOMEMMGR          Local and global memory management
* NOLFILEIO         _l* file I/O routines
* NOOPENFILE        OpenFile and related definitions
* NORESOURCE        Resource management
* NOATOM            Atom management
* NOLANGUAGE        Character test routines
* NOLSTRING         lstr* string management routines
* NODBCS            Double-byte character set routines
* NOKEYBOARDINFO    Keyboard driver routines
* NOGDICAPMASKS     GDI device capability constants
* NOCOLOR           COLOR_* color values
* NOGDIOBJ          GDI pens, brushes, fonts
* NODRAWTEXT        DrawText() and related definitions
* NOTEXTMETRIC      TEXTMETRIC and related APIs
* NOSCALABLEFONT    Truetype scalable font support
* NOBITMAP          Bitmap support
* NORASTEROPS       GDI Raster operation definitions
* NOMETAFILE        Metafile support
* NOSYSMETRICS      GetSystemMetrics() and related SM_* definitions
* NOSYSTEMPARAMSINFO SystemParametersInfo() and SPI_* definitions
* NOMSG             APIs and definitions that use MSG structure
* NOWINSTYLES       Window style definitions
* NOWINOFFSETS      Get/SetWindowWord/Long offset definitions
* NOSHOWWINDOW      ShowWindow and related definitions
* NODEFERWINDOWPOS  DeferWindowPos and related definitions
* NOVIRTUALKEYCODES VK_* virtual key codes
* NOKEYSTATES       MK_* message key state flags
* NOWH              SetWindowsHook and related WH_* definitions
* NOMENUS           Menu APIs
* NOSCROLL          Scrolling APIs and scroll bar control
* NOCLIPBOARD       Clipboard APIs and definitions
* NOICONS           IDI_* icon IDs
* NOMB              MessageBox and related definitions
* NOSYSCOMMANDS     WM_SYSCOMMAND SC_* definitions
* NOMDI             MDI support
* NOCTLMGR          Control management and controls
* NOWINMESSAGES     WM_* window messages
* NOHELP            Help support
*
\****************************************************************************/

#ifndef _INC_WINDOWS
#define _INC_WINDOWS    /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifdef NOWIN31                      /* ;Internal */
#define WINVER  0x0300              /* ;Internal */
#endif                              /* ;Internal */
                                    /* ;Internal */
/* If WINVER is not defined, assume version 3.1 */
#ifndef WINVER
#define WINVER  0x030a
#endif

#ifdef RC_INVOKED
/* Don't include definitions that RC.EXE can't parse */
#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NODBCS
#define NOSYSTEMPARAMSINFO
#define NOCOMM
#define NOOEMRESOURCE
#endif  /* RC_INVOKED */

/* Temp internal compatibility hacks */ /* ;Internal */
#define NOOEMRESOURCE               /* ;Internal */
#ifdef OEMRESOURCE                  /* ;Internal */
#undef NOOEMRESOURCE                /* ;Internal */
#endif                              /* ;Internal */
#define NOCOMM                      /* ;Internal */
#ifdef USECOMM                      /* ;Internal */
#undef NOCOMM                       /* ;Internal */
#endif                              /* ;Internal */
                                    /* ;Internal */
/* Handle OEMRESOURCE for 3.0 compatibility */
#if (WINVER < 0x030a)
#define NOOEMRESOURCE
#ifdef OEMRESOURCE
#undef NOOEMRESOURCE
#endif
#endif

/******* Common definitions and typedefs ***********************************/

#define VOID                void

#define FAR                 _far
#define NEAR                _near
#define PASCAL              _pascal
#define CDECL               _cdecl
#define CONST               const                   /* ;Internal */

#ifdef BUILDDLL                                     /* ;Internal */
#define WINAPI              _loadds _far _pascal    /* ;Internal */
#define CALLBACK            _loadds _far _pascal    /* ;Internal */
#else                                               /* ;Internal */
#define WINAPI              _far _pascal
#define CALLBACK            _far _pascal
#endif                                              /* ;Internal */
                                                    /* ;Internal */
#define API                 WINAPI                  /* ;Internal */

/****** Simple types & common helper macros *********************************/

typedef int                 BOOL;
#define FALSE               0
#define TRUE                1

typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef unsigned long       DWORD;

typedef unsigned int        UINT;

#ifdef STRICT
typedef signed long         LONG;
#else
#define LONG long
#endif

#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((UINT)(w) >> 8) & 0xFF))

#define LOWORD(l)           ((WORD)(DWORD)(l))
#define HIWORD(l)           ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))

#ifndef NOMINMAX
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
#endif  /* NOMINMAX */

/* Types use for passing & returning polymorphic values */
typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

#define MAKELPARAM(low, high)   ((LPARAM)MAKELONG(low, high))
#define MAKELRESULT(low, high)  ((LRESULT)MAKELONG(low, high))

/****** Common pointer types ************************************************/

#ifndef NULL
#define NULL                0
#endif

typedef char NEAR*          PSTR;
typedef char NEAR*          NPSTR;

#define SZ char                         /* ;Internal */

typedef char FAR*           LPSTR;
typedef const char FAR*     LPCSTR;

typedef BYTE NEAR*          PBYTE;
typedef BYTE FAR*           LPBYTE;

typedef int NEAR*           PINT;
typedef int FAR*            LPINT;

typedef WORD NEAR*          PWORD;
typedef WORD FAR*           LPWORD;

typedef long NEAR*          PLONG;
typedef long FAR*           LPLONG;

typedef DWORD NEAR*         PDWORD;
typedef DWORD FAR*          LPDWORD;

typedef void FAR*           LPVOID;

#define MAKELP(sel, off)    ((void FAR*)MAKELONG((off), (sel)))
#define SELECTOROF(lp)      HIWORD(lp)
#define OFFSETOF(lp)        LOWORD(lp)

#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)

/****** Common handle types *************************************************/

#ifdef STRICT
typedef const void NEAR*        HANDLE;
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ NEAR* name
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ FAR* name
#else   /* STRICT */
typedef UINT                    HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */

typedef HANDLE*             PHANDLE;
typedef HANDLE NEAR*        SPHANDLE;
typedef HANDLE FAR*         LPHANDLE;

typedef HANDLE              HGLOBAL;
typedef HANDLE              HLOCAL;

typedef HANDLE              GLOBALHANDLE;
typedef HANDLE              LOCALHANDLE;

typedef UINT                ATOM;

#ifdef STRICT
typedef void (CALLBACK*     FARPROC)(void);
typedef void (NEAR PASCAL*  NEARPROC)(void);
#else
typedef int (CALLBACK*      FARPROC)();
typedef int (NEAR PASCAL*   NEARPROC)();
#endif

DECLARE_HANDLE(HSTR);

/****** KERNEL typedefs, structures, and functions **************************/

DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;  /* HMODULEs can be used in place of HINSTANCEs */

#ifndef NOKERNEL

/****** Application entry point function ************************************/

#ifdef STRICT
int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
#endif

/****** System Information **************************************************/

DWORD   WINAPI GetVersion(void);

DWORD   WINAPI GetFreeSpace(UINT);
UINT    WINAPI GetCurrentPDB(void);

UINT    WINAPI GetWindowsDirectory(LPSTR, UINT);
UINT    WINAPI GetSystemDirectory(LPSTR, UINT);

#if (WINVER >= 0x030a)
UINT    WINAPI GetFreeSystemResources(UINT);
#define GFSR_SYSTEMRESOURCES   0x0000
#define GFSR_GDIRESOURCES      0x0001
#define GFSR_USERRESOURCES     0x0002
#define GFSR_VALID             0x0002  /* ;Internal */
#endif  /* WINVER >= 0x030a */

DWORD   WINAPI GetWinFlags(void);

#define WF_PMODE        0x0001
#define WF_CPU286       0x0002
#define WF_CPU386       0x0004
#define WF_CPU486       0x0008
#define WF_STANDARD     0x0010
#define WF_WIN286       0x0010
#define WF_ENHANCED     0x0020
#define WF_WIN386       0x0020
#define WF_CPU086       0x0040
#define WF_CPU186       0x0080
#define WF_LARGEFRAME   0x0100
#define WF_CPUEM        0x0100
#define WF_SMALLFRAME   0x0200
#define WF_80x87        0x0400
#define WF_PAGING       0x0800
#define WF_WINNT        0x4000
#define WF_WLO          0x8000

LPSTR   WINAPI GetDOSEnvironment(void);

DWORD   WINAPI GetCurrentTime(void);
DWORD   WINAPI GetTickCount(void);
DWORD   WINAPI GetTimerResolution(void);

/****** Error handling ******************************************************/

#if (WINVER >= 0x030a)
#ifndef NOLOGERROR

void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING             0x8000
#define ERR_PARAM               0x4000

/* Internal error value masks */            /* ;Internal */
#define ERR_TYPE_MASK           0x0fff      /* ;Internal */
#define ERR_FLAGS_MASK          0xc000      /* ;Internal */
                                            /* ;Internal */
#define ERR_SIZE_MASK           0x3000
#define ERR_SIZE_SHIFT          12          /* ;Internal */
#define ERR_BYTE                0x1000
#define ERR_WORD                0x2000
#define ERR_DWORD               0x3000
                                            /* ;Internal */
/* Error option flags (set by [kernel] ErrorOptions win.ini variable) *//* ;Internal */
                                            /* ;Internal */
#define ERO_PARAM_ERROR_BREAK   0x0001      /* ;Internal */
#define ERO_BUFFER_FILL         0x0002      /* ;Internal */

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE           0x6001
#define ERR_BAD_FLAGS           0x6002
#define ERR_BAD_INDEX           0x6003
#define ERR_BAD_DVALUE          0x7004
#define ERR_BAD_DFLAGS          0x7005
#define ERR_BAD_DINDEX          0x7006
#define ERR_BAD_PTR             0x7007
#define ERR_BAD_FUNC_PTR        0x7008
#define ERR_BAD_SELECTOR        0x6009
#define ERR_BAD_STRING_PTR      0x700a
#define ERR_BAD_HANDLE          0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS          0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069

/* Debug fill constants */              /* ;Internal */
                                        /* ;Internal */
#define DBGFILL_ALLOC           0xfd    /* ;Internal */
#define DBGFILL_FREE            0xfb    /* ;Internal */
#define DBGFILL_BUFFER          0xf9    /* ;Internal */
#define DBGFILL_STACK           0xf7    /* ;Internal */

/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

/* Debugging support (DEBUG SYSTEM ONLY) */
typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
} WINDEBUGINFO;

BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void    FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);
void    WINAPI DebugFillBuffer(void FAR* lpb, UINT cb);                 /* ;Internal */

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS         0x0001
#define WDI_FILTER          0x0002
#define WDI_ALLOCBREAK      0x0004
#define WDI_VALID           0x0007  /* ;Internal */

/* dwOptions values */
#define DBO_CHECKHEAP       0x0001
#define DBO_BUFFERFILL      0x0004
#define DBO_DISABLEGPTRAPPING 0x0010
#define DBO_CHECKFREE       0x0020

#define DBO_SILENT          0x8000

#define DBO_TRACEBREAK      0x2000
#define DBO_WARNINGBREAK    0x1000
#define DBO_NOERRORBREAK    0x0800
#define DBO_NOFATALBREAK    0x0400
#define DBO_INT3BREAK       0x0100

/* DebugOutput flags values */
#define DBF_TRACE           0x0000
#define DBF_WARNING         0x4000
#define DBF_ERROR           0x8000
#define DBF_FATAL           0xc000
#define DBF_SEVMASK         0xc000  /* ;Internal */
#define DBF_FILTERMASK      0x3fff  /* ;Internal */

/* dwFilter values */
#define DBF_KERNEL          0x1000
#define DBF_KRN_MEMMAN      0x0001
#define DBF_KRN_LOADMODULE  0x0002
#define DBF_KRN_SEGMENTLOAD 0x0004
#define DBF_USER            0x0800
#define DBF_GDI             0x0400
#define DBF_MMSYSTEM        0x0040
#define DBF_PENWIN          0x0020
#define DBF_APPLICATION     0x0008
#define DBF_DRIVER          0x0010

#endif  /* NOLOGERROR */
#endif  /* WINVER >= 0x030a */

void    WINAPI FatalExit(int);
void    WINAPI FatalAppExit(UINT, LPCSTR);

BOOL    WINAPI ExitWindows(DWORD dwReturnCode, UINT wReserved);

#define EW_RESTARTWINDOWS 0x42
#if (WINVER >= 0x030a)
#define EW_REBOOTSYSTEM   0x43
#define EW_EXITANDEXECAPP 0x44   /* ;Internal */

BOOL    WINAPI ExitWindowsExec(LPCSTR, LPCSTR);
#endif  /* WINVER >= 0x030a */

void    WINAPI DebugBreak(void);
void    WINAPI OutputDebugString(LPCSTR);

/* SetErrorMode() constants */
#define SEM_FAILCRITICALERRORS  0x0001
#define SEM_NOGPFAULTERRORBOX   0x0002
#define SEM_NOOPENFILEERRORBOX  0x8000

UINT    WINAPI SetErrorMode(UINT);

/****** Pointer validation **************************************************/

#if (WINVER >= 0x030a)

BOOL    WINAPI IsBadReadPtr(const void FAR* lp, UINT cb);
BOOL    WINAPI IsBadWritePtr(void FAR* lp, UINT cb);
BOOL    WINAPI IsBadHugeReadPtr(const void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadHugeWritePtr(void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadCodePtr(FARPROC lpfn);
BOOL    WINAPI IsBadStringPtr(const void FAR* lpsz, UINT cchMax);
#endif  /* WINVER >= 0x030a */

/****** Profiling support ***************************************************/

#ifndef NOPROFILER

int     WINAPI ProfInsChk(void);
void    WINAPI ProfSetup(int,int);
void    WINAPI ProfSampRate(int,int);
void    WINAPI ProfStart(void);
void    WINAPI ProfStop(void);
void    WINAPI ProfClear(void);
void    WINAPI ProfFlush(void);
void    WINAPI ProfFinish(void);
#endif  /* NOPROFILER */

/****** Catch/Throw and stack management ************************************/

typedef int CATCHBUF[9];
typedef int FAR* LPCATCHBUF;

int     WINAPI Catch(int FAR*);
void    WINAPI Throw(const int FAR*, int);

void    WINAPI SwitchStackBack(void);
void    WINAPI SwitchStackTo(UINT, UINT, UINT);

/****** Module Management ***************************************************/

#define HINSTANCE_ERROR ((HINSTANCE)32)

LONG    WINAPI GetExpWinVer(HINSTANCE);                 /* ;Internal */

HINSTANCE   WINAPI LoadModule(LPCSTR, LPVOID);
BOOL        WINAPI FreeModule(HINSTANCE);

HINSTANCE   WINAPI LoadLibrary(LPCSTR);
void        WINAPI FreeLibrary(HINSTANCE);

UINT    WINAPI WinExec(LPCSTR, UINT);

HMODULE WINAPI GetModuleHandle(LPCSTR);

int     WINAPI GetModuleUsage(HINSTANCE);
int     WINAPI GetModuleFileName(HINSTANCE, LPSTR, int);

FARPROC WINAPI GetProcAddress(HINSTANCE, LPCSTR);

int     WINAPI GetInstanceData(HINSTANCE, BYTE*, int);

HGLOBAL WINAPI GetCodeHandle(FARPROC);

typedef struct tagSEGINFO
{
    UINT offSegment;
    UINT cbSegment;
    UINT flags;
    UINT cbAlloc;
    HGLOBAL h;
    UINT alignShift;
    UINT reserved[2];
} SEGINFO;
typedef SEGINFO FAR* LPSEGINFO;

void    WINAPI GetCodeInfo(FARPROC lpProc, SEGINFO FAR* lpSegInfo);

FARPROC WINAPI MakeProcInstance(FARPROC, HINSTANCE);
void    WINAPI FreeProcInstance(FARPROC);

LONG    WINAPI SetSwapAreaSize(UINT);
void    WINAPI SwapRecording(UINT);
void    WINAPI ValidateCodeSegments(void);

/* Windows Exit Procedure flag values */
#define WEP_SYSTEM_EXIT 1
#define WEP_FREE_DLL    0

/****** Task Management *****************************************************/

#endif  /* NOKERNEL */

DECLARE_HANDLE(HTASK);

#ifndef NOKERNEL

UINT    WINAPI GetNumTasks(void);

#if (WINVER >= 0x030a)
BOOL    WINAPI IsTask(HTASK);
#endif  /* WINVER >= 0x030a */

HTASK   WINAPI GetCurrentTask(void);
int     WINAPI SetPriority(HTASK, int);     /* ;Internal */

void    WINAPI Yield(void);
void    WINAPI DirectedYield(HTASK);

DWORD   WINAPI GetAppCompatFlags(HTASK);                /* ;Internal */
                                                        /* ;Internal */
/* GetAppCompatFlags flag values */                     /* ;Internal */
#define GACF_IGNORENODISCARD    0x0001                  /* ;Internal */
#define GACF_FORCETEXTBAND      0x0002                  /* ;Internal */
#define GACF_ONELANDGRXBAND     0x0004                  /* ;Internal */
#define GACF_IGNORETOPMOST      0x0008                  /* ;Internal */
#define GACF_CALLTTDEVICE       0x0010                  /* ;Internal */
#define GACF_MULTIPLEBANDS      0x0020                  /* ;Internal */
#define GACF_ALWAYSSENDNCPAINT  0x0040                  /* ;Internal */
#define GACF_EDITSETTEXTMUNGE   0x0080                  /* ;Internal */
#define GACF_MOREEXTRAWNDWORDS  0x0100                  /* ;Internal */
#define GACF_TTIGNORERASTERDUPE 0x0200                  /* ;Internal */
#define GACF_HACKWINFLAGS       0x0400                  /* ;Internal */
#define GACF_DELAYHWHNDSHAKECHK 0x0800                  /* ;Internal */
#define GACF_ENUMHELVNTMSRMN    0x1000                  /* ;Internal */
#define GACF_ENUMTTNOTDEVICE    0x2000                  /* ;Internal */
#define GACF_SUBTRACTCLIPSIBS   0x4000                  /* ;Internal */
#define GACF_FORCETTGRAPHICS    0x8000                  /* ;Internal */
#define GACF_NOHRGN1            0x00010000              /* ;Internal */
#define GACF_NCCALCSIZEONMOVE   0x00020000              /* ;Internal */
#define GACF_SENDMENUDBLCLK     0x00040000              /* ;Internal */
#define GACF_30AVGWIDTH         0x00080000              /* ;Internal */

/****** Global memory management ********************************************/

#ifndef NOMEMMGR

/* Global Memory Flags */

#define GMEM_FIXED          0x0000
#define GMEM_MOVEABLE       0x0002
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE          0x2000
#define GMEM_DDESHARE       0x2000
#define GMEM_NOTIFY         0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND                (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR                (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h)    GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HGLOBAL WINAPI GlobalAlloc(UINT, DWORD);
HGLOBAL WINAPI GlobalReAlloc(HGLOBAL, DWORD, UINT);
HGLOBAL WINAPI GlobalFree(HGLOBAL);

DWORD   WINAPI GlobalDosAlloc(DWORD);
UINT    WINAPI GlobalDosFree(UINT);

#ifdef STRICT
void FAR* WINAPI GlobalLock(HGLOBAL);
#else
char FAR* WINAPI GlobalLock(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnlock(HGLOBAL);

DWORD   WINAPI GlobalSize(HGLOBAL);
DWORD   WINAPI GlobalHandle(UINT);

/* GlobalFlags return flags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED      0x4000
#define GMEM_LOCKCOUNT      0x00FF
UINT    WINAPI GlobalFlags(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI GlobalWire(HGLOBAL);
#else
char FAR* WINAPI GlobalWire(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnWire(HGLOBAL);

UINT    WINAPI GlobalPageLock(HGLOBAL);
UINT    WINAPI GlobalPageUnlock(HGLOBAL);

void    WINAPI GlobalFix(HGLOBAL);
void    WINAPI GlobalUnfix(HGLOBAL);

HGLOBAL WINAPI GlobalLRUNewest(HGLOBAL);
HGLOBAL WINAPI GlobalLRUOldest(HGLOBAL);

DWORD   WINAPI GlobalCompact(DWORD);

#ifdef STRICT
typedef BOOL (CALLBACK* GNOTIFYPROC)(HGLOBAL);
#else
typedef FARPROC GNOTIFYPROC;
#endif

void    WINAPI GlobalNotify(GNOTIFYPROC);

HGLOBAL WINAPI LockSegment(UINT);
void    WINAPI UnlockSegment(UINT);

#define LockData(dummy)     LockSegment((UINT)-1)
#define UnlockData(dummy)   UnlockSegment((UINT)-1)

UINT    WINAPI AllocSelector(UINT);
UINT    WINAPI FreeSelector(UINT);
UINT    WINAPI AllocDStoCSAlias(UINT);
UINT    WINAPI PrestoChangoSelector(UINT sourceSel, UINT destSel);
DWORD   WINAPI GetSelectorBase(UINT);
UINT    WINAPI SetSelectorBase(UINT, DWORD);
DWORD   WINAPI GetSelectorLimit(UINT);
UINT    WINAPI SetSelectorLimit(UINT, DWORD);

void    WINAPI LimitEmsPages(DWORD);

void    WINAPI ValidateFreeSpaces(void);

/* Low system memory notification message */
#define WM_COMPACTING       0x0041

/***** Local Memory Management */

/* Local Memory Flags */
#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND                (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR                (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND         (LMEM_MOVEABLE)
#define NONZEROLPTR         (LMEM_FIXED)

extern UINT NEAR* PASCAL pLocalHeap;                    /* ;Internal */
#define LocalFreeze(dummy)  (*(pLocalHeap+1) += 1)      /* ;Internal */
#define LocalMelt(dummy)    (*(pLocalHeap+1) -= 1)      /* ;Internal */

#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)


HLOCAL  WINAPI LocalAlloc(UINT, UINT);
HLOCAL  WINAPI LocalReAlloc(HLOCAL, UINT, UINT);
HLOCAL  WINAPI LocalFree(HLOCAL);

#ifdef STRICT
void NEAR* WINAPI LocalLock(HLOCAL);
#else
char NEAR* WINAPI LocalLock(HLOCAL);
#endif

BOOL    WINAPI LocalUnlock(HLOCAL);

UINT    WINAPI LocalSize(HLOCAL);
#ifdef STRICT
HLOCAL  WINAPI LocalHandle(void NEAR*);
#else
HLOCAL  WINAPI LocalHandle(UINT);
#endif
UINT    WINAPI LocalHandleDelta(UINT);              /* ;Internal */

/* LocalFlags return flags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED      0x4000
#define LMEM_LOCKCOUNT      0x00FF

UINT    WINAPI LocalFlags(HLOCAL);

BOOL    WINAPI LocalInit(UINT, UINT, UINT);
UINT    WINAPI LocalCompact(UINT);
UINT    WINAPI LocalShrink(HLOCAL, UINT);

/* LocalNotify callback */                                          /* ;Internal */
#ifdef STRICT                                                       /* ;Internal */
typedef BOOL (CALLBACK* LNOTIFYPROC)(UINT, HLOCAL, void NEAR*);   /* ;Internal */
#else                                                               /* ;Internal */
typedef FARPROC LNOTIFYPROC;                                        /* ;Internal */
#endif                                                              /* ;Internal */
                                                                    /* ;Internal */
#define LNOTIFY_OUTOFMEM    0                                       /* ;Internal */
#define LNOTIFY_MOVE        1                                       /* ;Internal */
#define LNOTIFY_DISCARD     2                                       /* ;Internal */
                                                                    /* ;Internal */
LNOTIFYPROC WINAPI LocalNotify(LNOTIFYPROC);                        /* ;Internal */
                                                                    /* ;Internal */
#endif  /* NOMEMMGR */

/****** File I/O ************************************************************/

#ifndef NOLFILEIO

typedef int HFILE;      /* Polymorphic with C runtime file handle type */

#define HFILE_ERROR ((HFILE)-1)

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
{
    BYTE cBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT*       POFSTRUCT;
typedef OFSTRUCT NEAR* NPOFSTRUCT;
typedef OFSTRUCT FAR*  LPOFSTRUCT;

/* OpenFile() Flags */
#define OF_READ             0x0000
#define OF_WRITE            0x0001
#define OF_READWRITE        0x0002
#define OF_SHARE_COMPAT     0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE            0x0100
#define OF_DELETE           0x0200
#define OF_VERIFY           0x0400      /* Used with OF_REOPEN */
#define OF_SEARCH           0x0400      /* Used without OF_REOPEN */
#define OF_CANCEL           0x0800
#define OF_CREATE           0x1000
#define OF_PROMPT           0x2000
#define OF_EXIST            0x4000
#define OF_REOPEN           0x8000

HFILE   WINAPI OpenFile(LPCSTR, OFSTRUCT FAR*, UINT);

#endif  /* NOOPENFILE */

/* _lopen() flags */
#define READ        0
#define WRITE       1
#define READ_WRITE  2

HFILE   WINAPI _lopen(LPCSTR, int);
HFILE   WINAPI _lcreat(LPCSTR, int);

HFILE   WINAPI _lclose(HFILE);

LONG    WINAPI _llseek(HFILE, LONG, int);

/* _llseek origin values */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

UINT    WINAPI _lread(HFILE, void _huge*, UINT);
UINT    WINAPI _lwrite(HFILE, const void _huge*, UINT);

#if (WINVER >= 0x030a)
long    WINAPI _hread(HFILE, void _huge*, long);
long    WINAPI _hwrite(HFILE, const void _huge*, long);
#endif  /* WINVER >= 0x030a */

UINT    WINAPI DeletePathname(LPCSTR);   /* ;Internal */

#endif  /* NOLFILEIO */

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE       (BYTE)0x80

int     WINAPI GetTempFileName(BYTE, LPCSTR, UINT, LPSTR);
BYTE    WINAPI GetTempDrive(char);

/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4
UINT    WINAPI GetDriveType(int);

UINT    WINAPI SetHandleCount(UINT);

/****** Network support *****************************************************/
UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
UINT WINAPI WNetCancelConnection(LPSTR, BOOL);
/* Errors */
#define WN_SUCCESS                      0x0000
#define WN_NOT_SUPPORTED                0x0001
#define WN_NET_ERROR                    0x0002
#define WN_MORE_DATA                    0x0003
#define WN_BAD_POINTER                  0x0004
#define WN_BAD_VALUE                    0x0005
#define WN_BAD_PASSWORD                 0x0006
#define WN_ACCESS_DENIED                0x0007
#define WN_FUNCTION_BUSY                0x0008
#define WN_WINDOWS_ERROR                0x0009
#define WN_BAD_USER                     0x000A
#define WN_OUT_OF_MEMORY                0x000B
#define WN_CANCEL                       0x000C
#define WN_CONTINUE                     0x000D

/* Connection errors */
#define WN_NOT_CONNECTED                0x0030
#define WN_OPEN_FILES                   0x0031
#define WN_BAD_NETNAME                  0x0032
#define WN_BAD_LOCALNAME                0x0033
#define WN_ALREADY_CONNECTED            0x0034
#define WN_DEVICE_ERROR                 0x0035
#define WN_CONNECTION_CLOSED            0x0036

/****** Resource Management *************************************************/

DECLARE_HANDLE(HRSRC);

HRSRC   WINAPI FindResource(HINSTANCE, LPCSTR, LPCSTR);
HGLOBAL WINAPI LoadResource(HINSTANCE, HRSRC);
BOOL    WINAPI FreeResource(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI LockResource(HGLOBAL);
#else
char FAR* WINAPI LockResource(HGLOBAL);
#endif

#define     UnlockResource(h)       GlobalUnlock(h)

DWORD   WINAPI SizeofResource(HINSTANCE, HRSRC);

int     WINAPI AccessResource(HINSTANCE, HRSRC);

HGLOBAL WINAPI AllocResource(HINSTANCE, HRSRC, DWORD);

#ifdef STRICT
typedef HGLOBAL (CALLBACK* RSRCHDLRPROC)(HGLOBAL, HINSTANCE, HRSRC);
#else
typedef FARPROC RSRCHDLRPROC;
#endif

RSRCHDLRPROC WINAPI SetResourceHandler(HINSTANCE, LPCSTR, RSRCHDLRPROC);

#define MAKEINTRESOURCE(i)  ((LPCSTR)MAKELP(0, (i)))

#ifndef NORESOURCE

/* Predefined Resource Types */
#define RT_CURSOR           MAKEINTRESOURCE(1)
#define RT_BITMAP           MAKEINTRESOURCE(2)
#define RT_ICON             MAKEINTRESOURCE(3)
#define RT_MENU             MAKEINTRESOURCE(4)
#define RT_DIALOG           MAKEINTRESOURCE(5)
#define RT_STRING           MAKEINTRESOURCE(6)
#define RT_FONTDIR          MAKEINTRESOURCE(7)
#define RT_FONT             MAKEINTRESOURCE(8)
#define RT_ACCELERATOR      MAKEINTRESOURCE(9)
#define RT_RCDATA           MAKEINTRESOURCE(10)

/* If any new types are added above this point, */  /* ;Internal */
/* DIFFERENCE must be changed.  The GROUP_*     */  /* ;Internal */
/* values minus the non-GROUP values must be    */  /* ;Internal */
/* equal to DIFFERENCE                          */  /* ;Internal */
#define DIFFERENCE          11                      /* ;Internal */
#define RT_GROUP_CURSOR     MAKEINTRESOURCE(12)
#define RT_GROUP_ICON       MAKEINTRESOURCE(14)

#endif  /* NORESOURCE */

#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#if (WINVER >= 0x030a)
#define OBM_UPARROWI        32737
#define OBM_DNARROWI        32736
#define OBM_RGARROWI        32735
#define OBM_LFARROWI        32734
#endif  /* WINVER >= 0x030a */

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZE            32640
#define OCR_ICON            32641
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647

#define OIC_SAMPLE          32512
#define OIC_HAND            32513
#define OIC_QUES            32514
#define OIC_BANG            32515
#define OIC_NOTE            32516

#endif  /* OEMRESOURCE */

/****** Atom Management *****************************************************/

#define MAKEINTATOM(i)      ((LPCSTR)MAKELP(0, (i)))

#ifndef NOATOM

BOOL    WINAPI InitAtomTable(int);
ATOM    WINAPI AddAtom(LPCSTR);
ATOM    WINAPI DeleteAtom(ATOM);
ATOM    WINAPI FindAtom(LPCSTR);
UINT    WINAPI GetAtomName(ATOM, LPSTR, int);
ATOM    WINAPI GlobalAddAtom(LPCSTR);
ATOM    WINAPI GlobalDeleteAtom(ATOM);
ATOM    WINAPI GlobalFindAtom(LPCSTR);
UINT    WINAPI GlobalGetAtomName(ATOM, LPSTR, int);
HLOCAL  WINAPI GetAtomHandle(ATOM);

#endif  /* NOATOM */

/****** WIN.INI Support *****************************************************/

/* User Profile Routines */
UINT    WINAPI GetProfileInt(LPCSTR, LPCSTR, int);
int     WINAPI GetProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
BOOL    WINAPI WriteProfileString(LPCSTR, LPCSTR, LPCSTR);

UINT    WINAPI GetPrivateProfileInt(LPCSTR, LPCSTR, int, LPCSTR);
int     WINAPI GetPrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
BOOL    WINAPI WritePrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPCSTR);

#define WM_WININICHANGE     0x001A

/****** International & Char Translation Support ****************************/

void    WINAPI AnsiToOem(const char _huge*, char _huge*);
void    WINAPI OemToAnsi(const char _huge*, char _huge*);

void    WINAPI AnsiToOemBuff(LPCSTR, LPSTR, UINT);
void    WINAPI OemToAnsiBuff(LPCSTR, LPSTR, UINT);

LPSTR   WINAPI AnsiNext(LPCSTR);
LPSTR   WINAPI AnsiPrev(LPCSTR, LPCSTR);

LPSTR   WINAPI AnsiUpper(LPSTR);
LPSTR   WINAPI AnsiLower(LPSTR);

UINT    WINAPI AnsiUpperBuff(LPSTR, UINT);
UINT    WINAPI AnsiLowerBuff(LPSTR, UINT);

/* Language driver entry point ordinal */    /* ;Internal */
#define ORD_LANGDRIVER    1                  /* ;Internal */

#ifndef  NOLANGUAGE
BOOL    WINAPI IsCharAlpha(char);
BOOL    WINAPI IsCharAlphaNumeric(char);
BOOL    WINAPI IsCharUpper(char);
BOOL    WINAPI IsCharLower(char);
#endif

#ifndef NOLSTRING
int     WINAPI lstrcmp(LPCSTR, LPCSTR);
int     WINAPI lstrcmpi(LPCSTR, LPCSTR);
LPSTR   WINAPI lstrcpy(LPSTR, LPCSTR);
LPSTR   WINAPI lstrcat(LPSTR, LPCSTR);
int     WINAPI lstrlen(LPCSTR);
#if (WINVER >= 0x030a)
LPSTR   WINAPI lstrcpyn(LPSTR, LPCSTR, int);
void    WINAPI hmemcpy(void _huge*, const void _huge*, long);
#endif  /* WINVER >= 0x030a */
#endif  /* NOLSTRING */

#if (WINVER >= 0x030a)
#ifndef NODBCS
BOOL    WINAPI IsDBCSLeadByte(BYTE);
#endif  /* NODBCS */
#endif  /* WINVER >= 0x030a */

int     WINAPI LoadString(HINSTANCE, UINT, LPSTR, int);

/****** Keyboard Driver Functions *******************************************/

#ifndef NOKEYBOARDINFO

DWORD   WINAPI OemKeyScan(UINT);
UINT    WINAPI VkKeyScan(UINT);
int     WINAPI GetKeyboardType(int);
UINT    WINAPI MapVirtualKey(UINT, UINT);
int     WINAPI GetKBCodePage(void);
int     WINAPI GetKeyNameText(LONG, LPSTR, int);
int     WINAPI ToAscii(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags);

#endif

#endif  /* NOKERNEL */

/****** GDI typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HDC);

#ifndef NOGDI

#ifdef STRICT
typedef const void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

#endif  /* NOGDI */

DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HBRUSH);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HFONT);

typedef struct tagRECT
{
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT*      PRECT;
typedef RECT NEAR* NPRECT;
typedef RECT FAR*  LPRECT;

typedef struct tagPOINT
{
    int x;
    int y;
} POINT;
typedef POINT*       PPOINT;
typedef POINT NEAR* NPPOINT;
typedef POINT FAR*  LPPOINT;

#if (WINVER >= 0x030a)
typedef struct tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;
typedef SIZE NEAR* NPSIZE;
typedef SIZE FAR*  LPSIZE;
#endif  /* WINVER >= 0x030a */

#define MAKEPOINT(l)        (*((POINT FAR*)&(l)))

#ifndef NOGDI

/****** DC Management *******************************************************/

HDC     WINAPI CreateDC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateIC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateCompatibleDC(HDC);

BOOL    WINAPI DeleteDC(HDC);

DWORD   WINAPI GetDCOrg(HDC);
DWORD   WINAPI SetDCOrg(HDC, int, int);    /* ;Internal */

int     WINAPI SaveDC(HDC);
BOOL    WINAPI RestoreDC(HDC, int);

int     WINAPI SetEnvironment(LPCSTR, const void FAR*, UINT);
int     WINAPI GetEnvironment(LPCSTR, void FAR*, UINT);

int     WINAPI MulDiv(int, int, int);

#if (WINVER >= 0x030a)
/* Drawing bounds accumulation APIs */
UINT    WINAPI SetBoundsRect(HDC hDC, const RECT FAR* lprcBounds, UINT flags);
UINT    WINAPI GetBoundsRect(HDC hDC, RECT FAR* lprcBounds, UINT flags);

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY       DCB_ACCUMULATE
#define DCB_SET         (DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008
#define DCB_WINDOWMGR   0x8000                          /* ;Internal */
                                                        /* ;Internal */
/* Internal SelectBitmap stuff */                       /* ;Internal */
/*HBITMAP WINAPI SelectBitmap(HDC hDC, HBITMAP hbm);*/     /* ;Internal */
#endif  /* WINVER >= 0x030a */

/****** Device Capabilities *************************************************/

int WINAPI GetDeviceCaps(HDC, int);

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY    2
#define HORZSIZE      4
#define VERTSIZE      6
#define HORZRES       8
#define VERTRES       10
#define BITSPIXEL     12
#define PLANES        14
#define NUMBRUSHES    16
#define NUMPENS       18
#define NUMMARKERS    20
#define NUMFONTS      22
#define NUMCOLORS     24
#define PDEVICESIZE   26
#define CURVECAPS     28
#define LINECAPS      30
#define POLYGONALCAPS 32
#define TEXTCAPS      34
#define CLIPCAPS      36
#define RASTERCAPS    38
#define ASPECTX       40
#define ASPECTY       42
#define ASPECTXY      44

#define LOGPIXELSX    88
#define LOGPIXELSY    90

#define SIZEPALETTE  104
#define NUMRESERVED  106
#define COLORRES     108

#ifndef NOGDICAPMASKS

/* GetDeviceCaps() return value masks */

/* TECHNOLOGY */
#define DT_PLOTTER          0
#define DT_RASDISPLAY       1
#define DT_RASPRINTER       2
#define DT_RASCAMERA        3
#define DT_CHARSTREAM       4
#define DT_METAFILE         5
#define DT_DISPFILE         6

/* CURVECAPS */
#define CC_NONE             0x0000
#define CC_CIRCLES          0x0001
#define CC_PIE              0x0002
#define CC_CHORD            0x0004
#define CC_ELLIPSES         0x0008
#define CC_WIDE             0x0010
#define CC_STYLED           0x0020
#define CC_WIDESTYLED       0x0040
#define CC_INTERIORS        0x0080
#define CC_ROUNDRECT        0x0100

/* LINECAPS */
#define LC_NONE             0x0000
#define LC_POLYLINE         0x0002
#define LC_MARKER           0x0004
#define LC_POLYMARKER       0x0008
#define LC_WIDE             0x0010
#define LC_STYLED           0x0020
#define LC_WIDESTYLED       0x0040
#define LC_INTERIORS        0x0080

/* POLYGONALCAPS */
#define PC_NONE             0x0000
#define PC_POLYGON          0x0001
#define PC_RECTANGLE        0x0002
#define PC_WINDPOLYGON      0x0004
#define PC_SCANLINE         0x0008
#define PC_WIDE             0x0010
#define PC_STYLED           0x0020
#define PC_WIDESTYLED       0x0040
#define PC_INTERIORS        0x0080

/* TEXTCAPS */
#define TC_OP_CHARACTER     0x0001
#define TC_OP_STROKE        0x0002
#define TC_CP_STROKE        0x0004
#define TC_CR_90            0x0008
#define TC_CR_ANY           0x0010
#define TC_SF_X_YINDEP      0x0020
#define TC_SA_DOUBLE        0x0040
#define TC_SA_INTEGER       0x0080
#define TC_SA_CONTIN        0x0100
#define TC_EA_DOUBLE        0x0200
#define TC_IA_ABLE          0x0400
#define TC_UA_ABLE          0x0800
#define TC_SO_ABLE          0x1000
#define TC_RA_ABLE          0x2000
#define TC_VA_ABLE          0x4000
#define TC_RESERVED         0x8000

/* CLIPCAPS */
#define CP_NONE             0x0000
#define CP_RECTANGLE        0x0001
#define CP_REGION           0x0002

/* RASTERCAPS */
#define RC_NONE
#define RC_BITBLT           0x0001
#define RC_BANDING          0x0002
#define RC_SCALING          0x0004
#define RC_BITMAP64         0x0008
#define RC_GDI20_OUTPUT     0x0010
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080
#define RC_PALETTE          0x0100
#define RC_DIBTODEV         0x0200
#define RC_BIGFONT          0x0400
#define RC_STRETCHBLT       0x0800
#define RC_FLOODFILL        0x1000
#define RC_STRETCHDIB       0x2000
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

#endif  /* NOGDICAPMASKS */

/****** Coordinate transformation support ***********************************/

int     WINAPI SetMapMode(HDC, int);
int     WINAPI GetMapMode(HDC);

/* Map modes */
#define MM_TEXT             1
#define MM_LOMETRIC         2
#define MM_HIMETRIC         3
#define MM_LOENGLISH        4
#define MM_HIENGLISH        5
#define MM_TWIPS            6
#define MM_ISOTROPIC        7
#define MM_ANISOTROPIC      8

DWORD   WINAPI SetWindowOrg(HDC, int, int);
DWORD   WINAPI GetWindowOrg(HDC);

DWORD   WINAPI SetWindowExt(HDC, int, int);
DWORD   WINAPI GetWindowExt(HDC);

DWORD   WINAPI OffsetWindowOrg(HDC, int, int);
DWORD   WINAPI ScaleWindowExt(HDC, int, int, int, int);

DWORD   WINAPI SetViewportOrg(HDC, int, int);
DWORD   WINAPI GetViewportOrg(HDC);

DWORD   WINAPI SetViewportExt(HDC, int, int);
DWORD   WINAPI GetViewportExt(HDC);

DWORD   WINAPI OffsetViewportOrg(HDC, int, int);
DWORD   WINAPI ScaleViewportExt(HDC, int, int, int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI SetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetWindowOrgEx(HDC, POINT FAR*);

BOOL    WINAPI SetWindowExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetWindowExtEx(HDC, SIZE FAR*);

BOOL    WINAPI OffsetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleWindowExtEx(HDC, int, int, int, int, SIZE FAR*);

BOOL    WINAPI SetViewportExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetViewportExtEx(HDC, SIZE FAR*);

BOOL    WINAPI SetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetViewportOrgEx(HDC, POINT FAR*);

BOOL    WINAPI OffsetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleViewportExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DPtoLP(HDC, POINT FAR*, int);
BOOL    WINAPI LPtoDP(HDC, POINT FAR*, int);

int     WINAPI SetRelAbs(HDC, int);   /* ;Internal */
int     WINAPI GetRelAbs(HDC);        /* ;Internal */

/* Coordinate Modes */
#define ABSOLUTE    1
#define RELATIVE    2

/****** Color support *******************************************************/

typedef DWORD COLORREF;

#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#define GetRValue(rgb)      ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)      ((BYTE)((rgb)>>16))

COLORREF WINAPI GetNearestColor(HDC, COLORREF);

#ifndef NOCOLOR

COLORREF WINAPI GetSysColor(int);
void    WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*);

#define COLOR_SCROLLBAR            0
#define COLOR_BACKGROUND           1
#define COLOR_ACTIVECAPTION        2
#define COLOR_INACTIVECAPTION      3
#define COLOR_MENU                 4
#define COLOR_WINDOW               5
#define COLOR_WINDOWFRAME          6
#define COLOR_MENUTEXT             7
#define COLOR_WINDOWTEXT           8
#define COLOR_CAPTIONTEXT          9
#define COLOR_ACTIVEBORDER        10
#define COLOR_INACTIVEBORDER      11
#define COLOR_APPWORKSPACE        12
#define COLOR_HIGHLIGHT           13
#define COLOR_HIGHLIGHTTEXT       14
#define COLOR_BTNFACE             15
#define COLOR_BTNSHADOW           16
#define COLOR_GRAYTEXT            17
#define COLOR_BTNTEXT             18
#if (WINVER >= 0x030a)
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_BTNHIGHLIGHT        20
#define COLOR_MAX                 20            /* ;Internal */
#else  /* WINVER >= 0x030a */                   /* ;Internal */
#define COLOR_MAX                 18            /* ;Internal */
#endif  /* WINVER >= 0x030a */
#define COLOR_ENDCOLORS           COLOR_MAX     /* ;Internal */

#endif  /* NOCOLOR */

#define WM_SYSCOLORCHANGE   0x0015

/****** GDI Object Support **************************************************/

#ifndef NOGDIOBJ

HGDIOBJ WINAPI GetStockObject(int);

BOOL    WINAPI IsGDIObject(HGDIOBJ);
#define GDIOBJ_PEN        1    /* ;Internal */
#define GDIOBJ_BRUSH      2    /* ;Internal */
#define GDIOBJ_FONT       3    /* ;Internal */
#define GDIOBJ_PALETTE    4    /* ;Internal */
#define GDIOBJ_BITMAP     5    /* ;Internal */
#define GDIOBJ_RGN        6    /* ;Internal */
#define GDIOBJ_DC         7    /* ;Internal */
#define GDIOBJ_IC         8    /* ;Internal */
#define GDIOBJ_DISABLEDDC 9    /* ;Internal */
#define GDIOBJ_METADC    10    /* ;Internal */
#define GDIOBJ_METAFILE  11    /* ;Internal */

BOOL    WINAPI DeleteObject(HGDIOBJ);
HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
int     WINAPI GetObject(HGDIOBJ, int, void FAR*);
BOOL    WINAPI UnrealizeObject(HGDIOBJ);

#ifdef STRICT
typedef (CALLBACK* GOBJENUMPROC)(void FAR*, LPARAM);
#else
typedef FARPROC GOBJENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPSTR);
#endif

/* Object types for EnumObjects() */
#define OBJ_PEN             1
#define OBJ_BRUSH           2

/****** Pen support *********************************************************/

/* Logical Pen */
typedef struct tagLOGPEN
{
    UINT    lopnStyle;
    POINT   lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
typedef LOGPEN*       PLOGPEN;
typedef LOGPEN NEAR* NPLOGPEN;
typedef LOGPEN FAR*  LPLOGPEN;

/* Pen Styles */
#define PS_SOLID            0
#define PS_DASH             1
#define PS_DOT              2
#define PS_DASHDOT          3
#define PS_DASHDOTDOT       4
#define PS_NULL             5
#define PS_INSIDEFRAME      6

HPEN    WINAPI CreatePen(int, int, COLORREF);
HPEN    WINAPI CreatePenIndirect(LOGPEN FAR*);

/* Stock pens for use with GetStockObject(); */
#define WHITE_PEN           6
#define BLACK_PEN           7
#define NULL_PEN            8

/****** Brush support *******************************************************/

/* Brush Styles */
#define BS_SOLID            0
#define BS_NULL             1
#define BS_HOLLOW           BS_NULL
#define BS_HATCHED          2
#define BS_PATTERN          3
#define BS_INDEXED          4
#define BS_DIBPATTERN       5

/* Hatch Styles */
#define HS_HORIZONTAL       0
#define HS_VERTICAL         1
#define HS_FDIAGONAL        2
#define HS_BDIAGONAL        3
#define HS_CROSS            4
#define HS_DIAGCROSS        5

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
{
    UINT     lbStyle;
    COLORREF lbColor;
    int      lbHatch;
} LOGBRUSH;
typedef LOGBRUSH*       PLOGBRUSH;
typedef LOGBRUSH NEAR* NPLOGBRUSH;
typedef LOGBRUSH FAR*  LPLOGBRUSH;

typedef LOGBRUSH            PATTERN;
typedef PATTERN*       PPATTERN;
typedef PATTERN NEAR* NPPATTERN;
typedef PATTERN FAR*  LPPATTERN;

HBRUSH  WINAPI CreateSolidBrush(COLORREF);
HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  WINAPI CreateBrushIndirect(LOGBRUSH FAR*);

/* Stock brushes for use with GetStockObject() */
#define WHITE_BRUSH         0
#define LTGRAY_BRUSH        1
#define GRAY_BRUSH          2
#define DKGRAY_BRUSH        3
#define BLACK_BRUSH         4
#define NULL_BRUSH          5
#define HOLLOW_BRUSH        NULL_BRUSH

DWORD   WINAPI SetBrushOrg(HDC, int, int);
DWORD   WINAPI GetBrushOrg(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetBrushOrgEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

/****** Region support ******************************************************/

HRGN    WINAPI CreateRectRgn(int, int, int, int);
HRGN    WINAPI CreateRectRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
HRGN    WINAPI CreatePolygonRgn(const POINT FAR*, int, int);
HRGN    WINAPI CreatePolyPolygonRgn(const POINT FAR*, const int FAR*, int, int);
HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);

/* Region type flags */
#define ERROR               0
#define NULLREGION          1
#define SIMPLEREGION        2
#define COMPLEXREGION       3

void    WINAPI SetRectRgn(HRGN, int, int, int, int);

int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);

/* CombineRgn() command values */
#define RGN_AND             1
#define RGN_OR              2
#define RGN_XOR             3
#define RGN_DIFF            4
#define RGN_COPY            5

BOOL    WINAPI EqualRgn(HRGN, HRGN);
int     WINAPI OffsetRgn(HRGN, int, int);

int     WINAPI GetRgnBox(HRGN, RECT FAR*);

BOOL    WINAPI RectInRegion(HRGN, const RECT FAR*);
BOOL    WINAPI PtInRegion(HRGN, int, int);

/****** Color palette Support ************************************************/

#define PALETTERGB(r,g,b)   (0x02000000L | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000L | (DWORD)(WORD)(i)))

typedef struct tagPALETTEENTRY
{
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR* LPPALETTEENTRY;

/* Palette entry flags */
#define PC_RESERVED     0x01    /* palette index used for animation */
#define PC_EXPLICIT     0x02    /* palette index is explicit to device */
#define PC_NOCOLLAPSE   0x04    /* do not match color to system palette */

/* Logical Palette */
typedef struct tagLOGPALETTE
{
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE*       PLOGPALETTE;
typedef LOGPALETTE NEAR* NPLOGPALETTE;
typedef LOGPALETTE FAR*  LPLOGPALETTE;

HPALETTE WINAPI CreatePalette(const LOGPALETTE FAR*);

HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);

UINT    WINAPI RealizePalette(HDC);

int     WINAPI UpdateColors(HDC);
void    WINAPI AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);

UINT    WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);
UINT    WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);

BOOL    WINAPI ResizePalette(HPALETTE, UINT);

UINT    WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetSystemPaletteUse(HDC);
UINT    WINAPI SetSystemPaletteUse(HDC, UINT);

/* Get/SetSystemPaletteUse() values */
#define SYSPAL_STATIC   1
#define SYSPAL_NOSTATIC 2

/* Palette window messages */
#define WM_QUERYNEWPALETTE  0x030F
#define WM_PALETTEISCHANGING 0x0310
#define WM_PALETTECHANGED   0x0311
#define WM_PALETTEGONNACHANGE   WM_PALETTEISCHANGING    /* ;Internal */
#define WM_CHANGEPALETTE        WM_PALETTECHANGED       /* ;Internal */

/****** Clipping support *****************************************************/

int     WINAPI SelectClipRgn(HDC, HRGN);
int     WINAPI GetClipBox(HDC, RECT FAR*);

int     WINAPI IntersectClipRect(HDC, int, int, int, int);
int     WINAPI OffsetClipRgn(HDC, int, int);
int     WINAPI ExcludeClipRect(HDC, int, int, int, int);

BOOL    WINAPI PtVisible(HDC, int, int);
BOOL    WINAPI RectVisible(HDC, const RECT FAR*);

#if (WINVER >= 0x030a)                                  /* ;Internal */
/* DC hook callback function */                         /* ;Internal */
                                                        /* ;Internal */
typedef UINT (CALLBACK* DCHOOKPROC)(HDC hDC, UINT code, DWORD data, DWORD lParam); /* ;Internal */
                                                        /* ;Internal */
BOOL    WINAPI SetDCHook(HDC hDC, DCHOOKPROC lpNewProc, DWORD data);   /* ;Internal */
DWORD   WINAPI GetDCHook(HDC hDC, DCHOOKPROC FAR* lplpproc);          /* ;Internal */
                                                        /* ;Internal */
/* Callback reason code values */                       /* ;Internal */
                                                        /* ;Internal */
#define DCHC_INVALIDVISRGN 0x0001                       /* ;Internal */
#define DCHC_DELETEDC      0x0002                       /* ;Internal */
                                                        /* ;Internal */
UINT WINAPI SetHookFlags(HDC hDC, UINT flags);          /* ;Internal */
                                                        /* ;Internal */
#define DCHF_INVALIDATEVISRGN 0x0001                    /* ;Internal */
#define DCHF_VALIDATEVISRGN   0x0002                    /* ;Internal */
#endif  /* WINVER >= 0x030a */                          /* ;Internal */

/****** General drawing support ********************************************/

DWORD   WINAPI MoveTo(HDC, int, int);
DWORD   WINAPI GetCurrentPosition(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI MoveToEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetCurrentPositionEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI LineTo(HDC, int, int);
BOOL    WINAPI Polyline(HDC, const POINT FAR*, int);

#ifdef STRICT
typedef void (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC LINEDDAPROC;
#endif

void    WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);

BOOL    WINAPI Rectangle(HDC, int, int, int, int);
BOOL    WINAPI RoundRect(HDC, int, int, int, int, int, int);

BOOL    WINAPI Ellipse(HDC, int, int, int, int);
BOOL    WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Pie(HDC, int, int, int, int, int, int, int, int);

BOOL    WINAPI Polygon(HDC, const POINT FAR*, int);
BOOL    WINAPI PolyPolygon(HDC, const POINT FAR*, int FAR*, int);

/* PolyFill Modes */
#define ALTERNATE   1
#define WINDING     2

int     WINAPI SetPolyFillMode(HDC, int);
int     WINAPI GetPolyFillMode(HDC);

BOOL    WINAPI FloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

BOOL    WINAPI FillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI InvertRgn(HDC, HRGN);
BOOL    WINAPI PaintRgn(HDC, HRGN);

/* Rectangle output routines */
int     WINAPI FillRect(HDC, const RECT FAR*, HBRUSH);
int     WINAPI FrameRect(HDC, const RECT FAR*, HBRUSH);
void    WINAPI InvertRect(HDC, const RECT FAR*);

void    WINAPI DrawFocusRect(HDC, const RECT FAR*);

BOOL    WINAPI FastWindowFrame(HDC, const RECT FAR*, UINT, UINT, DWORD); /* ;Internal */

/****** Text support ********************************************************/

BOOL    WINAPI TextOut(HDC, int, int, LPCSTR, int);
LONG    WINAPI TabbedTextOut(HDC, int, int, LPCSTR, int, int, int FAR*, int);
BOOL    WINAPI ExtTextOut(HDC, int, int, UINT, const RECT FAR*, LPCSTR, UINT, int FAR*);

#define ETO_GRAYED      0x0001
#define ETO_OPAQUE      0x0002
#define ETO_CLIPPED     0x0004

DWORD   WINAPI GetTextExtent(HDC, LPCSTR, int);
DWORD   WINAPI GetTabbedTextExtent(HDC, LPCSTR, int, int, int FAR*);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetTextExtentPoint(HDC, LPCSTR, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

/* DrawText() Format Flags */
#ifndef NODRAWTEXT
#define DT_TOP              0x0000
#define DT_LEFT             0x0000
#define DT_CENTER           0x0001
#define DT_RIGHT            0x0002
#define DT_VCENTER          0x0004
#define DT_BOTTOM           0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE       0x0020
#define DT_EXPANDTABS       0x0040
#define DT_TABSTOP          0x0080
#define DT_NOCLIP           0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT         0x0400
#define DT_NOPREFIX         0x0800
#define DT_INTERNAL         0x1000
#define DT_VALID            0x1fff  /* ;Internal: Union of all those above */

int     WINAPI DrawText(HDC, LPCSTR, int, RECT FAR*, UINT);
#endif  /* NODRAWTEXT */

#ifdef STRICT
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
#else
typedef FARPROC GRAYSTRINGPROC;
#endif

BOOL    WINAPI GrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);

BOOL    WINAPI GetCharWidth(HDC, UINT, UINT, int FAR*);

COLORREF WINAPI SetTextColor(HDC, COLORREF);
COLORREF WINAPI GetTextColor(HDC);

COLORREF WINAPI SetBkColor(HDC, COLORREF);
COLORREF WINAPI GetBkColor(HDC);

int     WINAPI SetBkMode(HDC, int);
int     WINAPI GetBkMode(HDC);

/* Background Modes */
#define TRANSPARENT     1
#define OPAQUE          2
#define TRANSPARENT1    3           /* ;Internal */

UINT    WINAPI SetTextAlign(HDC, UINT);
UINT    WINAPI GetTextAlign(HDC);

/* Text Alignment Options */
#define TA_NOUPDATECP                0x0000
#define TA_UPDATECP                  0x0001
#define TA_LEFT                      0x0000
#define TA_RIGHT                     0x0002
#define TA_CENTER                    0x0006
#define TA_TOP                       0x0000
#define TA_BOTTOM                    0x0008
#define TA_BASELINE                  0x0018

int     WINAPI SetTextCharacterExtra(HDC, int);
int     WINAPI GetTextCharacterExtra(HDC);

int     WINAPI SetTextJustification(HDC, int, int);

/****** Font support ********************************************************/

#ifndef NOGDIOBJ
/* Logical Font */
#define LF_FACESIZE         32
typedef struct tagLOGFONT
{
    int     lfHeight;
    int     lfWidth;
    int     lfEscapement;
    int     lfOrientation;
    int     lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT*       PLOGFONT;
typedef LOGFONT NEAR* NPLOGFONT;
typedef LOGFONT FAR*  LPLOGFONT;

/* weight values */
#define FW_DONTCARE         0
#define FW_THIN             100
#define FW_EXTRALIGHT       200
#define FW_LIGHT            300
#define FW_NORMAL           400
#define FW_MEDIUM           500
#define FW_SEMIBOLD         600
#define FW_BOLD             700
#define FW_EXTRABOLD        800
#define FW_HEAVY            900

#define FW_ULTRALIGHT       FW_EXTRALIGHT
#define FW_REGULAR          FW_NORMAL
#define FW_DEMIBOLD         FW_SEMIBOLD
#define FW_ULTRABOLD        FW_EXTRABOLD
#define FW_BLACK            FW_HEAVY

/* CharSet values */
#define ANSI_CHARSET        0
#define DEFAULT_CHARSET     1
#define SYMBOL_CHARSET      2
#define SHIFTJIS_CHARSET    128
#define HANGEUL_CHARSET     129
#define CHINESEBIG5_CHARSET 136
#define OEM_CHARSET         255

/* OutPrecision values */
#define OUT_DEFAULT_PRECIS      0
#define OUT_STRING_PRECIS       1
#define OUT_CHARACTER_PRECIS    2
#define OUT_STROKE_PRECIS       3
#if (WINVER >= 0x030a)
#define OUT_TT_PRECIS           4
#define OUT_DEVICE_PRECIS       5
#define OUT_RASTER_PRECIS       6
#define OUT_TT_ONLY_PRECIS      7
#endif  /* WINVER >= 0x030a */

/* ClipPrecision values */
#define CLIP_DEFAULT_PRECIS     0x00
#define CLIP_CHARACTER_PRECIS   0x01
#define CLIP_STROKE_PRECIS      0x02
#define CLIP_MASK               0x0F
#if (WINVER >= 0x030a)
#define CLIP_LH_ANGLES          0x10
#define CLIP_TT_ALWAYS          0x20
#define CLIP_EMBEDDED           0x80
#endif  /* WINVER >= 0x030a */

/* Quality values */
#define DEFAULT_QUALITY     0
#define DRAFT_QUALITY       1
#define PROOF_QUALITY       2

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

HFONT   WINAPI CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPCSTR);
HFONT   WINAPI CreateFontIndirect(const LOGFONT FAR*);

/* Stock fonts for use with GetStockObject() */
#define OEM_FIXED_FONT      10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT       12
#define SYSTEM_FONT         13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16


DWORD   WINAPI SetMapperFlags(HDC, DWORD);
#define ASPECT_FILTERING             0x00000001L

int     WINAPI AddFontResource(LPCSTR);
BOOL    WINAPI RemoveFontResource(LPCSTR);

#define WM_FONTCHANGE       0x001D

int     WINAPI GetTextFace(HDC, int, LPSTR);

DWORD   WINAPI GetAspectRatioFilter(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI GetAspectRatioFilterEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

#endif  /* NOGDIOBJ */

#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC*       PTEXTMETRIC;
typedef TEXTMETRIC NEAR* NPTEXTMETRIC;
typedef TEXTMETRIC FAR*  LPTEXTMETRIC;

/* tmPitchAndFamily values */
#define TMPF_FIXED_PITCH    0x01
#define TMPF_VECTOR         0x02
#define TMPF_DEVICE         0x08
#if (WINVER >= 0x030a)
#define TMPF_TRUETYPE       0x04
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetTextMetrics(HDC, TEXTMETRIC FAR*);

#if (WINVER >= 0x030a)
#ifndef NOSCALABLEFONT

typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, FAR* LPPANOSE;

typedef struct tagOUTLINETEXTMETRIC
{
    UINT    otmSize;
    TEXTMETRIC otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
    int     otmsCharSlopeRise;
    int     otmsCharSlopeRun;
    int     otmItalicAngle;
    UINT    otmEMSquare;
    int     otmAscent;
    int     otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
    int     otmMacAscent;
    int     otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
    int     otmsStrikeoutPosition;
    int     otmsUnderscorePosition;
    int     otmsUnderscoreSize;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRIC, FAR* LPOUTLINETEXTMETRIC;

WORD    WINAPI GetOutlineTextMetrics(HDC, UINT, OUTLINETEXTMETRIC FAR*);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

#ifndef NOGDIOBJ
#if (WINVER >= 0x030a)

/* Structure passed to FONTENUMPROC */
/* NOTE: NEWTEXTMETRIC is the same as TEXTMETRIC plus 4 new fields */
typedef struct tagNEWTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRIC;
typedef NEWTEXTMETRIC*       PNEWTEXTMETRIC;
typedef NEWTEXTMETRIC NEAR* NPNEWTEXTMETRIC;
typedef NEWTEXTMETRIC FAR*  LPNEWTEXTMETRIC;

/* ntmFlags field flags */
#define NTM_REGULAR     0x00000040L
#define NTM_BOLD        0x00000020L
#define NTM_ITALIC      0x00000001L

#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONT
{
    LOGFONT elfLogFont;
    char    elfFullName[LF_FULLFACESIZE];
    char    elfStyle[LF_FACESIZE];
} ENUMLOGFONT, FAR* LPENUMLOGFONT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

#ifdef STRICT
#ifndef NOGDIOBJ

typedef int (CALLBACK* OLDFONTENUMPROC)(const LOGFONT FAR*, const TEXTMETRIC FAR*, int, LPARAM);

#if (WINVER >= 0x030a)
typedef int (CALLBACK* FONTENUMPROC)(const ENUMLOGFONT FAR*, const NEWTEXTMETRIC FAR*, int, LPARAM);

int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPARAM);

#else   /* WINVER >= 0x030a */
typedef OLDFONTENUMPROC FONTENUMPROC;
#endif  /* WINVER >= 0x030a) */

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPARAM);
#endif  /* NOGDIOBJ */

#else   /* STRICT */

typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROC;

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPSTR);

#if (WINVER >= 0x030a)
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPSTR);
#endif  /* WINVER >= 0x030a */

#endif  /* !STRICT */

/* EnumFonts font type values */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002
#if (WINVER >= 0x030a)
#define TRUETYPE_FONTTYPE   0x0004
#endif  /* WINVER >= 0x030a */

#endif  /* NOTEXTMETRIC */

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x030a)

DWORD   WINAPI ConvertOutlineFontFile(LPCSTR, LPCSTR, LPCSTR);   /* ;Internal */
DWORD   WINAPI GetFontData(HDC, DWORD, DWORD, void FAR*, DWORD);
BOOL    WINAPI CreateScalableFontResource(UINT, LPCSTR, LPCSTR, LPCSTR);

typedef struct tagGLYPHMETRICS
{
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    int     gmCellIncX;
    int     gmCellIncY;
} GLYPHMETRICS, FAR* LPGLYPHMETRICS;

typedef struct tagFIXED
{
    UINT    fract;
    int     value;
} FIXED, FAR* LPFIXED;

typedef struct tagMAT2
{
    FIXED  eM11;
    FIXED  eM12;
    FIXED  eM21;
    FIXED  eM22;
} MAT2, FAR* LPMAT2;

DWORD   WINAPI GetGlyphOutline(HDC, UINT, UINT, GLYPHMETRICS FAR*, DWORD, void FAR*, const MAT2 FAR*);

/* GetGlyphOutline constants */
#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2

#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    UINT    wType;
    UINT    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;

typedef UINT FAR* LPFONTDIR;                               /* ;Internal */
                                                           /* ;Internal */
DWORD   WINAPI EngineMakeFontDir(HDC, LPFONTDIR, LPCSTR);  /* ;Internal */
                                                           /* ;Internal */
typedef struct tagABC
{
    int   abcA;
    UINT  abcB;
    int   abcC;
} ABC;
typedef ABC FAR* LPABC;

BOOL    WINAPI GetCharABCWidths(HDC, UINT, UINT, ABC FAR*);

typedef struct tagKERNINGPAIR
{
    WORD wFirst;
    WORD wSecond;
    int  iKernAmount;
} KERNINGPAIR, FAR* LPKERNINGPAIR;

int     WINAPI GetKerningPairs(HDC, int, KERNINGPAIR FAR*);

typedef struct tagRASTERIZER_STATUS
{
    int   nSize;
    int   wFlags;
    int   nLanguageID;
} RASTERIZER_STATUS;
typedef RASTERIZER_STATUS FAR* LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE    0x0001
#define TT_ENABLED      0x0002

BOOL    WINAPI GetRasterizerCaps(RASTERIZER_STATUS FAR*, int);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

/****** Bitmap support ******************************************************/

#ifndef NOBITMAP
typedef struct tagBITMAP
{
    int     bmType;
    int     bmWidth;
    int     bmHeight;
    int     bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} BITMAP;
typedef BITMAP*       PBITMAP;
typedef BITMAP NEAR* NPBITMAP;
typedef BITMAP FAR*  LPBITMAP;

/* Bitmap Header structures */
typedef struct tagRGBTRIPLE
{
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE;
typedef RGBTRIPLE FAR* LPRGBTRIPLE;

typedef struct tagRGBQUAD
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER
{
    DWORD   bcSize;
    short   bcWidth;
    short   bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER*      PBITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR* LPBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER
{
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;
typedef BITMAPINFOHEADER*      PBITMAPINFOHEADER;
typedef BITMAPINFOHEADER FAR* LPBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB      0L
#define BI_RLE8     1L
#define BI_RLE4     2L

typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD          bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO*     PBITMAPINFO;
typedef BITMAPINFO FAR* LPBITMAPINFO;

typedef struct tagBITMAPCOREINFO
{
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE        bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO*      PBITMAPCOREINFO;
typedef BITMAPCOREINFO FAR* LPBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER
{
    UINT    bfType;
    DWORD   bfSize;
    UINT    bfReserved1;
    UINT    bfReserved2;
    DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER*      PBITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR* LPBITMAPFILEHEADER;

/* Pel Array */                             /* ;Internal */
typedef struct tagPELARRAY                  /* ;Internal */
{                                           /* ;Internal */
    int     paXCount;                       /* ;Internal */
    int     paYCount;                       /* ;Internal */
    int     paXExt;                         /* ;Internal */
    int     paYExt;                         /* ;Internal */
    BYTE    paRGBs;                         /* ;Internal */
} PELARRAY;                                 /* ;Internal */
typedef PELARRAY*       PPELARRAY;          /* ;Internal */
typedef PELARRAY NEAR* NPPELARRAY;          /* ;Internal */
typedef PELARRAY FAR*  LPPELARRAY;          /* ;Internal */

HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, const void FAR*);
HBITMAP WINAPI CreateBitmapIndirect(BITMAP FAR* );
HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
HBITMAP WINAPI CreateDIBitmap(HDC, BITMAPINFOHEADER FAR*, DWORD, const void FAR*, BITMAPINFO FAR*, UINT);

HBITMAP WINAPI LoadBitmap(HINSTANCE, LPCSTR);

/* DIB color table identifiers */
#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

/* constants for CreateDIBitmap */
#define CBM_INIT        0x00000004L
#endif  /* NOBITMAP */

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1
#define R2_NOTMERGEPEN      2
#define R2_MASKNOTPEN       3
#define R2_NOTCOPYPEN       4
#define R2_MASKPENNOT       5
#define R2_NOT              6
#define R2_XORPEN           7
#define R2_NOTMASKPEN       8
#define R2_MASKPEN          9
#define R2_NOTXORPEN        10
#define R2_NOP              11
#define R2_MERGENOTPEN      12
#define R2_COPYPEN          13
#define R2_MERGEPENNOT      14
#define R2_MERGEPEN         15
#define R2_WHITE            16

/* Ternary raster operations */
#define SRCCOPY             0x00CC0020L
#define SRCPAINT            0x00EE0086L
#define SRCAND              0x008800C6L
#define SRCINVERT           0x00660046L
#define SRCERASE            0x00440328L
#define NOTSRCCOPY          0x00330008L
#define NOTSRCERASE         0x001100A6L
#define MERGECOPY           0x00C000CAL
#define MERGEPAINT          0x00BB0226L
#define PATCOPY             0x00F00021L
#define PATPAINT            0x00FB0A09L
#define PATINVERT           0x005A0049L
#define DSTINVERT           0x00550009L
#define BLACKNESS           0x00000042L
#define WHITENESS           0x00FF0062L

#endif  /* NORASTEROPS */

#ifndef NOBITMAP
BOOL    WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);

BOOL    WINAPI PatBlt(HDC, int, int, int, int, DWORD);

BOOL    WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI StretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);

COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
COLORREF WINAPI GetPixel(HDC, int, int);

/* StretchBlt() Modes */
#define BLACKONWHITE    1
#define WHITEONBLACK    2
#define COLORONCOLOR    3

/* new StretchBlt() Modes (simpler names) */
#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3

int     WINAPI SetStretchBltMode(HDC, int);
int     WINAPI GetStretchBltMode(HDC);

DWORD   WINAPI SetBitmapDimension(HBITMAP, int, int);
DWORD   WINAPI GetBitmapDimension(HBITMAP);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetBitmapDimensionEx(HBITMAP, int, int, SIZE FAR*);
BOOL    WINAPI GetBitmapDimensionEx(HBITMAP, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI SetROP2(HDC, int);
int     WINAPI GetROP2(HDC);

LONG    WINAPI SetBitmapBits(HBITMAP, DWORD, const void FAR*);
LONG    WINAPI GetBitmapBits(HBITMAP, LONG, void FAR*);

int     WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
int     WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, void FAR*, BITMAPINFO FAR*, UINT);

int     WINAPI SetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    void FAR*, BITMAPINFO FAR*, UINT);
#endif  /* NOBITMAP */

/****** Metafile support ****************************************************/

#ifndef NOMETAFILE

DECLARE_HANDLE(HMETAFILE);

HDC     WINAPI CreateMetaFile(LPCSTR);
HMETAFILE WINAPI CloseMetaFile(HDC);

HMETAFILE WINAPI GetMetaFile(LPCSTR);
BOOL      WINAPI DeleteMetaFile(HMETAFILE);
HMETAFILE WINAPI CopyMetaFile(HMETAFILE, LPCSTR);

BOOL    WINAPI PlayMetaFile(HDC, HMETAFILE);

HGLOBAL WINAPI GetMetaFileBits(HMETAFILE);
HMETAFILE WINAPI SetMetaFileBits(HGLOBAL);
#if (WINVER >= 0x030a)
HMETAFILE WINAPI SetMetaFileBitsBetter(HGLOBAL);
#endif  /* WINVER >= 0x030a */

/* Clipboard Metafile Picture Structure */
typedef struct tagMETAFILEPICT
{
    int     mm;
    int     xExt;
    int     yExt;
    HMETAFILE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR* LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    UINT    mtType;
    UINT    mtHeaderSize;
    UINT    mtVersion;
    DWORD   mtSize;
    UINT    mtNoObjects;
    DWORD   mtMaxRecord;
    UINT    mtNoParameters;
} METAHEADER;

typedef struct tagHANDLETABLE
{
    HGDIOBJ objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE*      PHANDLETABLE;
typedef HANDLETABLE FAR* LPHANDLETABLE;

typedef struct tagMETARECORD
{
    DWORD   rdSize;
    UINT    rdFunction;
    UINT    rdParm[1];
} METARECORD;
typedef METARECORD*      PMETARECORD;
typedef METARECORD FAR* LPMETARECORD;

/* Metafile Functions */
#define META_SETBKCOLOR              0x0201
#define META_SETBKMODE               0x0102
#define META_SETMAPMODE              0x0103
#define META_SETROP2                 0x0104
#define META_SETRELABS               0x0105
#define META_SETPOLYFILLMODE         0x0106
#define META_SETSTRETCHBLTMODE       0x0107
#define META_SETTEXTCHAREXTRA        0x0108
#define META_SETTEXTCOLOR            0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG            0x020B
#define META_SETWINDOWEXT            0x020C
#define META_SETVIEWPORTORG          0x020D
#define META_SETVIEWPORTEXT          0x020E
#define META_OFFSETWINDOWORG         0x020F
#define META_SCALEWINDOWEXT          0x0410
#define META_OFFSETVIEWPORTORG       0x0211
#define META_SCALEVIEWPORTEXT        0x0412
#define META_LINETO                  0x0213
#define META_MOVETO                  0x0214
#define META_EXCLUDECLIPRECT         0x0415
#define META_INTERSECTCLIPRECT       0x0416
#define META_ARC                     0x0817
#define META_ELLIPSE                 0x0418
#define META_FLOODFILL               0x0419
#define META_PIE                     0x081A
#define META_RECTANGLE               0x041B
#define META_ROUNDRECT               0x061C
#define META_PATBLT                  0x061D
#define META_SAVEDC                  0x001E
#define META_SETPIXEL                0x041F
#define META_OFFSETCLIPRGN           0x0220
#define META_TEXTOUT                 0x0521
#define META_BITBLT                  0x0922
#define META_STRETCHBLT              0x0B23
#define META_POLYGON                 0x0324
#define META_POLYLINE                0x0325
#define META_ESCAPE                  0x0626
#define META_RESTOREDC               0x0127
#define META_FILLREGION              0x0228
#define META_FRAMEREGION             0x0429
#define META_INVERTREGION            0x012A
#define META_PAINTREGION             0x012B
#define META_SELECTCLIPREGION        0x012C
#define META_SELECTOBJECT            0x012D
#define META_SETTEXTALIGN            0x012E
#define META_DRAWTEXT                0x062F

#define META_CHORD                   0x0830
#define META_SETMAPPERFLAGS          0x0231
#define META_EXTTEXTOUT              0x0a32
#define META_SETDIBTODEV             0x0d33
#define META_SELECTPALETTE           0x0234
#define META_REALIZEPALETTE          0x0035
#define META_ANIMATEPALETTE          0x0436
#define META_SETPALENTRIES           0x0037
#define META_POLYPOLYGON             0x0538
#define META_RESIZEPALETTE           0x0139

#define META_DIBBITBLT               0x0940
#define META_DIBSTRETCHBLT           0x0b41
#define META_DIBCREATEPATTERNBRUSH   0x0142
#define META_STRETCHDIB              0x0f43

#define META_EXTFLOODFILL            0x0548

#define META_RESETDC                 0x014C
#define META_STARTDOC                0x014D
#define META_STARTPAGE               0x004F
#define META_ENDPAGE                 0x0050
#define META_ABORTDOC                0x0052
#define META_ENDDOC                  0x005E

#define META_DELETEOBJECT            0x01f0

#define META_CREATEPALETTE           0x00f7
#define META_CREATEBRUSH             0x00F8
#define META_CREATEPATTERNBRUSH      0x01F9
#define META_CREATEPENINDIRECT       0x02FA
#define META_CREATEFONTINDIRECT      0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEBITMAPINDIRECT    0x02FD
#define META_CREATEBITMAP            0x06FE
#define META_CREATEREGION            0x06FF

void    WINAPI PlayMetaFileRecord(HDC, HANDLETABLE FAR*, METARECORD FAR*, UINT);

#ifdef STRICT
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
#else
typedef FARPROC MFENUMPROC;
#endif

BOOL    WINAPI EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

#endif  /* NOMETAFILE */

/****** Printing support ****************************************************/

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

#if (WINVER >= 0x030a)

typedef struct
{
    int     cbSize;
    LPCSTR  lpszDocName;
    LPCSTR  lpszOutput;
}   DOCINFO;
typedef DOCINFO FAR* LPDOCINFO;

int     WINAPI StartDoc(HDC, DOCINFO FAR*);
int     WINAPI StartPage(HDC);
int     WINAPI EndPage(HDC);
int     WINAPI EndDoc(HDC);
int     WINAPI AbortDoc(HDC);

int     WINAPI SetAbortProc(HDC, ABORTPROC);
HANDLE  WINAPI SpoolFile(LPSTR, LPSTR, LPSTR, LPSTR);
BOOL    WINAPI QueryJob(HANDLE, int);           /* ;Internal */
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI QueryAbort(HDC, int);

/* Spooler Error Codes */
#define SP_NOTREPORTED               0x4000
#define SP_ERROR                     (-1)
#define SP_APPABORT                  (-2)
#define SP_USERABORT                 (-3)
#define SP_OUTOFDISK                 (-4)
#define SP_OUTOFMEMORY               (-5)

#define PR_JOBSTATUS                 0x0000

#endif  /* NOGDI  */

/* Spooler status notification message */
#define WM_SPOOLERSTATUS            0x002A

#ifndef NOGDI

/******* GDI Escape support *************************************************/

int     WINAPI Escape(HDC, int, int, LPCSTR, void FAR*);

/* GDI Escapes */
#define NEWFRAME                     1
#define ABORTDOC                     2
#define NEXTBAND                     3
#define SETCOLORTABLE                4
#define GETCOLORTABLE                5
#define FLUSHOUTPUT                  6
#define DRAFTMODE                    7
#define QUERYESCSUPPORT              8
#define SETABORTPROC                 9
#define STARTDOC                     10
#define ENDDOC                       11
#define GETPHYSPAGESIZE              12
#define GETPRINTINGOFFSET            13
#define GETSCALINGFACTOR             14
#define MFCOMMENT                    15
#define GETPENWIDTH                  16
#define SETCOPYCOUNT                 17
#define SELECTPAPERSOURCE            18
#define DEVICEDATA                   19
#define PASSTHROUGH                  19
#define GETTECHNOLGY                 20
#define GETTECHNOLOGY                20
#define SETLINECAP                   21
#define SETLINEJOIN                  22
#define SETMITERLIMIT                23
#define BANDINFO                     24
#define DRAWPATTERNRECT              25
#define GETVECTORPENSIZE             26
#define GETVECTORBRUSHSIZE           27
#define ENABLEDUPLEX                 28
#define GETSETPAPERBINS              29
#define GETSETPRINTORIENT            30
#define ENUMPAPERBINS                31
#define SETDIBSCALING                32
#define EPSPRINTING                  33
#define ENUMPAPERMETRICS             34
#define GETSETPAPERMETRICS           35
#define POSTSCRIPT_DATA              37
#define POSTSCRIPT_IGNORE            38
#define MOUSETRAILS                  39

#define GETEXTENDEDTEXTMETRICS       256
#define GETEXTENTTABLE               257
#define GETPAIRKERNTABLE             258
#define GETTRACKKERNTABLE            259
#define EXTTEXTOUT                   512
#define GETFACENAME                  513
#define ENABLERELATIVEWIDTHS         768
#define ENABLEPAIRKERNING            769
#define SETKERNTRACK                 770
#define SETALLJUSTVALUES             771
#define SETCHARSET                   772

#define STRETCHBLT                   2048

#define GETSETSCREENPARAMS           3072

#define BEGIN_PATH                   4096
#define CLIP_TO_PATH                 4097
#define END_PATH                     4098
#define EXT_DEVICE_CAPS              4099
#define RESTORE_CTM                  4100
#define SAVE_CTM                     4101
#define SET_ARC_DIRECTION            4102
#define SET_BACKGROUND_COLOR         4103
#define SET_POLY_MODE                4104
#define SET_SCREEN_ANGLE             4105
#define SET_SPREAD                   4106
#define TRANSFORM_CTM                4107
#define SET_CLIP_BOX                 4108
#define SET_BOUNDS                   4109

#endif  /* NOGDI */

/****** USER typedefs, structures, and functions *****************************/

#ifdef tagWND                       /* ;Internal */
typedef struct tagWND NEAR* HWND;   /* ;Internal */
#else                               /* ;Internal */
DECLARE_HANDLE(HWND);
#endif                              /* ;Internal */

#ifndef NOUSER

DECLARE_HANDLE(HMENU);

DECLARE_HANDLE(HICON);
typedef HICON HCURSOR;      /* HICONs & HCURSORs are polymorphic */

/****** System Metrics *******************************************************/

#ifndef NOSYSMETRICS

int WINAPI GetSystemMetrics(int);

/* GetSystemMetrics() codes */
#define SM_CXSCREEN          0
#define SM_CYSCREEN          1
#define SM_CXVSCROLL         2
#define SM_CYHSCROLL         3
#define SM_CYCAPTION         4
#define SM_CXBORDER          5
#define SM_CYBORDER          6
#define SM_CXDLGFRAME        7
#define SM_CYDLGFRAME        8
#define SM_CYVTHUMB          9
#define SM_CXHTHUMB          10
#define SM_CXICON            11
#define SM_CYICON            12
#define SM_CXCURSOR          13
#define SM_CYCURSOR          14
#define SM_CYMENU            15
#define SM_CXFULLSCREEN      16
#define SM_CYFULLSCREEN      17
#define SM_CYKANJIWINDOW     18
#define SM_MOUSEPRESENT      19
#define SM_CYVSCROLL         20
#define SM_CXHSCROLL         21
#define SM_DEBUG             22
#define SM_SWAPBUTTON        23
#define SM_RESERVED1         24
#define SM_RESERVED2         25
#define SM_RESERVED3         26
#define SM_RESERVED4         27
#define SM_CXMIN             28
#define SM_CYMIN             29
#define SM_CXSIZE            30
#define SM_CYSIZE            31
#define SM_CXFRAME           32
#define SM_CYFRAME           33
#define SM_CXMINTRACK        34
#define SM_CYMINTRACK        35

#if (WINVER >= 0x030a)
#define SM_CXDOUBLECLK       36
#define SM_CYDOUBLECLK       37
#define SM_CXICONSPACING     38
#define SM_CYICONSPACING     39
#define SM_MENUDROPALIGNMENT 40
#define SM_PENWINDOWS        41
#define SM_DBCSENABLED       42
#endif  /* WINVER >= 0x030a */

#define SM_MAX               42         /* ;Internal */
#define SM_CMETRICS          43

#endif  /* NOSYSMETRICS */

UINT    WINAPI GetDoubleClickTime(void);
void    WINAPI SetDoubleClickTime(UINT);

#define WM_DEVMODECHANGE    0x001B
#define WM_TIMECHANGE       0x001E
#define WM_FILESYSCHANGE    0x0034              /* ;Internal */

/****** System Parameters support ********************************************/

#if (WINVER >= 0x030a)
#ifndef NOSYSTEMPARAMSINFO

BOOL    WINAPI SystemParametersInfo(UINT, UINT, VOID FAR*, UINT);

#define SPI_GETBEEP                 1
#define SPI_SETBEEP                 2
#define SPI_GETMOUSE                3
#define SPI_SETMOUSE                4
#define SPI_GETBORDER               5
#define SPI_SETBORDER               6
#define SPI_TIMEOUTS                7   /* ;Internal */
#define SPI_KANJIMENU               8   /* ;Internal */
#define SPI_GETKEYBOARDSPEED        10
#define SPI_SETKEYBOARDSPEED        11
#define SPI_LANGDRIVER              12
#define SPI_ICONHORIZONTALSPACING   13
#define SPI_GETSCREENSAVETIMEOUT    14
#define SPI_SETSCREENSAVETIMEOUT    15
#define SPI_GETSCREENSAVEACTIVE     16
#define SPI_SETSCREENSAVEACTIVE     17
#define SPI_GETGRIDGRANULARITY      18
#define SPI_SETGRIDGRANULARITY      19
#define SPI_SETDESKWALLPAPER        20
#define SPI_SETDESKPATTERN          21
#define SPI_GETKEYBOARDDELAY        22
#define SPI_SETKEYBOARDDELAY        23
#define SPI_ICONVERTICALSPACING     24
#define SPI_GETICONTITLEWRAP        25
#define SPI_SETICONTITLEWRAP        26
#define SPI_GETMENUDROPALIGNMENT    27
#define SPI_SETMENUDROPALIGNMENT    28
#define SPI_SETDOUBLECLKWIDTH       29
#define SPI_SETDOUBLECLKHEIGHT      30
#define SPI_GETICONTITLELOGFONT     31
#define SPI_SETDOUBLECLICKTIME      32
#define SPI_SETMOUSEBUTTONSWAP      33
#define SPI_SETICONTITLELOGFONT     34
#define SPI_GETFASTTASKSWITCH       35
#define SPI_SETFASTTASKSWITCH       36
#define SPI_MAX                     36   /* ;Internal */

/* SystemParametersInfo flags */
#define SPIF_UPDATEINIFILE          0x0001
#define SPIF_SENDWININICHANGE       0x0002
#define SPIF_VALID                  0x0003  /* ;Internal */

#endif  /* NOSYSTEMPARAMSINFO  */
#endif  /* WINVER >= 0x030a */

/****** Rectangle support ****************************************************/

void    WINAPI SetRect(RECT FAR*, int, int, int, int);
void    WINAPI SetRectEmpty(RECT FAR*);

void    WINAPI CopyRect(RECT FAR*, const RECT FAR*);

BOOL    WINAPI IsRectEmpty(const RECT FAR*);

BOOL    WINAPI EqualRect(const RECT FAR*, const RECT FAR*);

BOOL    WINAPI IntersectRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI UnionRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI SubtractRect(RECT FAR*, const RECT FAR*, const RECT FAR*);

void    WINAPI OffsetRect(RECT FAR*, int, int);
void    WINAPI InflateRect(RECT FAR*, int, int);

BOOL    WINAPI PtInRect(const RECT FAR*, POINT);

/****** Window message support ***********************************************/

UINT WINAPI RegisterWindowMessage(LPCSTR);

#define WM_NULL             0x0000

/* NOTE: All messages below 0x0400 are RESERVED by Windows */
#define WM_USER             0x0400

#ifndef NOMSG

/* Queued message structure */
typedef struct tagMSG
{
    HWND        hwnd;
    UINT        message;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       time;
    POINT       pt;
} MSG;
typedef MSG* PMSG;
typedef MSG NEAR* NPMSG;
typedef MSG FAR* LPMSG;

BOOL    WINAPI GetMessage(MSG FAR*, HWND, UINT, UINT);
BOOL    WINAPI PeekMessage(MSG FAR*, HWND, UINT, UINT, UINT);

/* PeekMessage() options */
#define PM_NOREMOVE     0x0000
#define PM_REMOVE       0x0001
#define PM_NOYIELD      0x0002
#define PM_VALID        0x0003       /* ;Internal */

void    WINAPI WaitMessage(void);

DWORD   WINAPI GetMessagePos(void);
LONG    WINAPI GetMessageTime(void);
#if (WINVER >= 0x030a)
LPARAM  WINAPI GetMessageExtraInfo(void);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI TranslateMessage(const MSG FAR*);
LONG    WINAPI DispatchMessage(const MSG FAR*);

BOOL    WINAPI SetMessageQueue(int);

BOOL    WINAPI GetInputState(void);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetQueueStatus(UINT flags);

/* GetQueueStatus flags */
#define QS_KEY          0x0001
#define QS_MOUSEMOVE    0x0002
#define QS_MOUSEBUTTON  0x0004
#define QS_MOUSE        (QS_MOUSEMOVE | QS_MOUSEBUTTON)
#define QS_POSTMESSAGE  0x0008
#define QS_TIMER        0x0010
#define QS_PAINT        0x0020
#define QS_SENDMESSAGE  0x0040

#define QS_ALLINPUT     0x007f
#define QS_VALID        0x007f      /* ;Internal */
#endif  /* WINVER >= 0x030a */

#endif  /* NOMSG */

BOOL    WINAPI PostMessage(HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI SendMessage(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG

BOOL    WINAPI PostAppMessage(HTASK, UINT, WPARAM, LPARAM);

void    WINAPI ReplyMessage(LRESULT);
BOOL    WINAPI InSendMessage(void);

/* Special HWND value for use with PostMessage() and SendMessage() */
#define HWND_BROADCAST  ((HWND)0xffff)

BOOL WINAPI CallMsgFilter(MSG FAR*, int);

#define WH_GETMESSAGE       3

#define WH_CALLWNDPROC      4

#define WH_MSGFILTER        (-1)
#define WH_SYSMSGFILTER     6

/* CallMsgFilter() and WH_SYS/MSGFILTER context codes */
#define MSGF_DIALOGBOX           0
#define MSGF_MESSAGEBOX          1          /* ;Internal */
#define MSGF_MENU                2
#define MSGF_MOVE                3
#define MSGF_SIZE                4
#define MSGF_SCROLLBAR           5
#define MSGF_NEXTWINDOW          6
#define MSGF_CBTHOSEBAGSUSEDTHIS 7          /* ;Internal */
#define MSGF_MAINLOOP            8
#define MSGF_USER                4096
#endif  /* NOMSG */

/* Standard window messages */
/* PenWindows specific messages */
#define WM_PENWINFIRST      0x0380
#define WM_PENWINLAST       0x038F

/* Coalescing messages */
#define WM_COALESCE_FIRST   0x0390
#define WM_COALESCE_LAST    0x039F

/* Reserved message ranges */                   /* ;Internal */
#define WM_KANJIFIRST       0x0280  /* JAPAN */ /* ;Internal */
#define WM_KANJILAST        0x029F  /* JAPAN */ /* ;Internal */
#define WM_HANGEULFIRST     0x0280  /* KOREA */ /* ;Internal */
#define WM_HANGEULLAST      0x029F  /* KOREA */ /* ;Internal */
                                                /* ;Internal */
                                                /* ;Internal */
#define WM_INTERNAL_COALESCE_FIRST  0x0390      /* ;Internal */
                                                /* ;Internal */
                                                /* ;Internal */
/* The following message range reserved  */     /* ;Internal */
/* for multi-media                       */     /* ;Internal */
#define WM_MM_RESERVED_FIRST 0x03A0             /* ;Internal */
#define WM_MM_RESERVED_LAST  0x03DF             /* ;Internal */
#define WM_INTERNAL_COALESCE_LAST  0x03b0       /* ;Internal */
                                                /* ;Internal */
#define WM_INTERNAL_DDE_FIRST 0x03E0            /* ;Internal */
#define WM_INTERNAL_DDE_LAST  0x03EF            /* ;Internal */
                                                /* ;Internal */
/* The following message range reserved  */     /* ;Internal */
/* for CBT                               */     /* ;Internal */
#define WM_CBT_RESERVED_FIRST 0x03F0            /* ;Internal */
#define WM_CBT_RESERVED_LAST  0x03FF            /* ;Internal */

#if (WINVER >= 0x030a)
/****** Power management ****************************************************/
#define WM_POWER            0x0048

/* wParam for WM_POWER window message and DRV_POWER driver notification */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3
#endif  /* WINVER >= 0x030a */

/****** Application termination *********************************************/

#define WM_QUERYENDSESSION  0x0011
#define WM_ENDSESSION       0x0016

#define WM_QUIT             0x0012

void    WINAPI PostQuitMessage(int);

#define WM_SYSTEMERROR      0x0017

/****** Window class management *********************************************/

typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct tagWNDCLASS
{
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASS;
typedef WNDCLASS* PWNDCLASS;
typedef WNDCLASS NEAR* NPWNDCLASS;
typedef WNDCLASS FAR* LPWNDCLASS;

ATOM    WINAPI RegisterClass(const WNDCLASS FAR*);
BOOL    WINAPI UnregisterClass(LPCSTR, HINSTANCE);

BOOL    WINAPI GetClassInfo(HINSTANCE, LPCSTR, WNDCLASS FAR*);
int     WINAPI GetClassName(HWND, LPSTR, int);

#ifndef NOWINSTYLES

/* Class styles */
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002

#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080

#define CS_SAVEBITS         0x0800

#define CS_DBLCLKS          0x0008

#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000

#define CS_NOCLOSE          0x0200

#define CS_KEYCVTWINDOW     0x0004
#define CS_NOKEYCVT         0x0100

#define CS_GLOBALCLASS      0x4000
#define CS_VALID            0x7fef  /* ;Internal */
#endif  /* NOWINSTYLES */

#ifndef NOWINOFFSETS

WORD    WINAPI GetClassWord(HWND, int);
WORD    WINAPI SetClassWord(HWND, int, WORD);
LONG    WINAPI GetClassLong(HWND, int);
LONG    WINAPI SetClassLong(HWND, int, LONG);

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME        (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR         (-12)
#define GCW_HICON           (-14)
#define GCW_HMODULE         (-16)
#define GCW_CBWNDEXTRA      (-18)
#define GCW_CBCLSEXTRA      (-20)
#define GCL_WNDPROC         (-24)
#define GCW_STYLE           (-26)

#if (WINVER >= 0x030a)
#define GCW_ATOM            (-32)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINOFFSETS */

/****** Window creation/destroy *********************************************/

/* Window Styles */
#ifndef NOWINSTYLES

/* Basic window types */
#define WS_OVERLAPPED       0x00000000L
#define WS_POPUP            0x80000000L
#define WS_CHILD            0x40000000L

/* Clipping styles */
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L

/* Generic window states */
#define WS_VISIBLE          0x10000000L
#define WS_DISABLED         0x08000000L

/* Main window states */
#define WS_MINIMIZE         0x20000000L
#define WS_MAXIMIZE         0x01000000L

/* Main window styles */
#define WS_CAPTION          0x00C00000L     /* WS_BORDER | WS_DLGFRAME  */
#define WS_BORDER           0x00800000L
#define WS_DLGFRAME         0x00400000L
#define WS_VSCROLL          0x00200000L
#define WS_HSCROLL          0x00100000L
#define WS_SYSMENU          0x00080000L
#define WS_THICKFRAME       0x00040000L
#define WS_MINIMIZEBOX      0x00020000L
#define WS_MAXIMIZEBOX      0x00010000L

/* Control window styles */
#define WS_GROUP            0x00020000L
#define WS_TABSTOP          0x00010000L

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW      (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW      (WS_CHILD)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME  0x00000001L
#define WS_EX_DRAGOBJECT     0x00000002L                /* ;Internal */
#define WS_EX_NOPARENTNOTIFY 0x00000004L

#if (WINVER >= 0x030a)
#define WS_EX_TOPMOST        0x00000008L
#define WS_EX_ACCEPTFILES    0x00000010L
#define WS_EX_TRANSPARENT    0x00000020L
#define WS_EX_VALID          0x0000003fL    /* ;Internal */
#endif  /* WINVER >= 0x030a */

/* Obsolete style names */
#define WS_TILED            WS_OVERLAPPED
#define WS_ICONIC           WS_MINIMIZE
#define WS_SIZEBOX          WS_THICKFRAME
#define WS_TILEDWINDOW      WS_OVERLAPPEDWINDOW

#define WS_VALID            0xffff0000L     /* ;Internal */

#endif  /* NOWINSTYLES */

/* Special value for CreateWindow, et al. */
#define HWND_DESKTOP        ((HWND)0)

BOOL    WINAPI IsWindow(HWND);

HWND    WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
HWND    WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);

#define WM_CREATE           0x0001
#define WM_NCCREATE         0x0081

/* WM_CREATE/WM_NCCREATE lParam struct */
typedef struct tagCREATESTRUCT
{
    void FAR* lpCreateParams;
    HINSTANCE hInstance;
    HMENU     hMenu;
    HWND      hwndParent;
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
} CREATESTRUCT;
typedef CREATESTRUCT FAR* LPCREATESTRUCT;

BOOL    WINAPI DestroyWindow(HWND);

#define WM_DESTROY          0x0002
#define WM_NCDESTROY        0x0082

/* Basic window attributes */

HTASK   WINAPI GetWindowTask(HWND);

BOOL    WINAPI IsChild(HWND, HWND);

HWND    WINAPI GetParent(HWND);
HWND    WINAPI SetParent(HWND, HWND);

BOOL    WINAPI IsWindowVisible(HWND);

BOOL    WINAPI ShowWindow(HWND, int);

#define WM_SETVISIBLE       0x0009              /* ;Internal */

#ifndef NOSHOWWINDOW

#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9
#define SW_MAX              9   /* ;Internal */

/* Obsolete ShowWindow() command names */
#define HIDE_WINDOW         0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

#define WM_SHOWWINDOW       0x0018

/* WM_SHOWWINDOW wParam codes */
#define SW_PARENTCLOSING    1
#define SW_OTHERMAXIMIZED   2
#define SW_PARENTOPENING    3
#define SW_OTHERRESTORED    4

/* Obsolete constant names */
#define SW_OTHERZOOM        SW_OTHERMAXIMIZED
#define SW_OTHERUNZOOM      SW_OTHERRESTORED
#endif  /* NOSHOWWINDOW */

#define WM_SETREDRAW        0x000B

/* Enabled state */
BOOL    WINAPI EnableWindow(HWND,BOOL);
BOOL    WINAPI IsWindowEnabled(HWND);

#define WM_ENABLE           0x000A

/* Window text */
void    WINAPI SetWindowText(HWND, LPCSTR);
int     WINAPI GetWindowText(HWND, LPSTR, int);
int     WINAPI GetWindowTextLength(HWND);

#define WM_SETTEXT          0x000C
#define WM_GETTEXT          0x000D
#define WM_GETTEXTLENGTH    0x000E

/* Window words */
WORD    WINAPI GetWindowWord(HWND, int);
WORD    WINAPI SetWindowWord(HWND, int, WORD);
LONG    WINAPI GetWindowLong(HWND, int);
LONG    WINAPI SetWindowLong(HWND, int, LONG);

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC         (-4)
#define GWW_HINSTANCE       (-6)
#define GWW_HWNDPARENT      (-8)
#define GWW_ID              (-12)
#define GWL_STYLE           (-16)
#define GWL_EXSTYLE         (-20)
#endif  /* NOWINOFFSETS */

/****** Window size, position, Z-order, and visibility **********************/

#define CW_USEDEFAULT       ((int)0x8000)

void    WINAPI GetClientRect(HWND, RECT FAR*);
void    WINAPI GetWindowRect(HWND, RECT FAR*);


#if (WINVER >= 0x030a)
typedef struct tagWINDOWPLACEMENT
{
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT     *PWINDOWPLACEMENT;
typedef WINDOWPLACEMENT FAR* LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION      0x0001
#define WPF_RESTORETOMAXIMIZED  0x0002
#define WPF_VALID               0x0003  /* ;Internal */

BOOL    WINAPI GetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
BOOL    WINAPI SetWindowPlacement(HWND, const WINDOWPLACEMENT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI SetWindowPos(HWND, HWND, int, int, int, int, UINT);

/* SetWindowPos() and WINDOWPOS flags */
#define SWP_NOSIZE          0x0001
#define SWP_NOMOVE          0x0002
#define SWP_NOZORDER        0x0004
#define SWP_NOREDRAW        0x0008
#define SWP_NOACTIVATE      0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW      0x0040
#define SWP_HIDEWINDOW      0x0080
#define SWP_NOCOPYBITS      0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */

#define SWP_DRAWFRAME       SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#define SWP_NOCLIENTSIZE    0x0800  /* Client didn't resize */  /* ;Internal */
#define SWP_NOCLIENTMOVE    0x1000  /* Client didn't move   */  /* ;Internal */
#define SWP_NOSENDCHANGING  0x0400
#define SWP_DEFERERASE      0x2000
#define SWP_DEFERDRAWING    SWP_DEFERERASE /* Don't do any drawing or erasing */ /* ;Internal */
                                                                      /* ;Internal */
#define SWP_CHANGEMASK      (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | /* ;Internal */ \
                            SWP_FRAMECHANGED |                        /* ;Internal */ \
                            SWP_SHOWWINDOW | SWP_HIDEWINDOW |         /* ;Internal */ \
                            SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)      /* ;Internal */
                                                                      /* ;Internal */
#define SWP_NOCHANGE        (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | /* ;Internal */ \
                            SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)      /* ;Internal */
#define SWP_VALID           0x27ff  /* ;Internal */

/* SetWindowPos() hwndInsertAfter field values */
#define HWND_TOP            ((HWND)0)
#define HWND_BOTTOM         ((HWND)1)
#define HWND_TOPMOST        ((HWND)-1)
#define HWND_NOTOPMOST      ((HWND)-2)
#define HWND_GROUPTOTOP     HWND_TOPMOST        /* ;Internal */

#ifndef NODEFERWINDOWPOS

DECLARE_HANDLE(HDWP);

HDWP    WINAPI BeginDeferWindowPos(int);
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
BOOL    WINAPI EndDeferWindowPos(HDWP);

#endif  /* NODEFERWINDOWPOS */

BOOL    WINAPI MoveWindow(HWND, int, int, int, int, BOOL);
BOOL    WINAPI BringWindowToTop(HWND);

#if (WINVER >= 0x030a)

#define WM_WINDOWPOSCHANGING 0x0046
#define WM_WINDOWPOSCHANGED 0x0047

/* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam */
typedef struct tagWINDOWPOS
{
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS;
typedef WINDOWPOS FAR* LPWINDOWPOS;
#endif  /* WINVER >= 0x030a */

#define WM_MOVE             0x0003
#define WM_SIZEWAIT         0x0004      /* ;Internal */
#define WM_SIZE             0x0005

/* WM_SIZE message wParam values */
#define SIZE_RESTORED       0
#define SIZE_MINIMIZED      1
#define SIZE_MAXIMIZED      2
#define SIZE_MAXSHOW        3
#define SIZE_MAXHIDE        4

/* Obsolete constant names */
#define SIZENORMAL          SIZE_RESTORED
#define SIZEICONIC          SIZE_MINIMIZED
#define SIZEFULLSCREEN      SIZE_MAXIMIZED
#define SIZEZOOMSHOW        SIZE_MAXSHOW
#define SIZEZOOMHIDE        SIZE_MAXHIDE

/****** Window proc implementation & subclassing support *********************/

LRESULT WINAPI DefWindowProc(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT
LRESULT WINAPI CallWindowProc(WNDPROC, HWND, UINT, WPARAM, LPARAM);
#else
LRESULT WINAPI CallWindowProc(FARPROC, HWND, UINT, WPARAM, LPARAM);
#endif

/****** Main window support **************************************************/

void    WINAPI AdjustWindowRect(RECT FAR*, DWORD, BOOL);
void    WINAPI AdjustWindowRectEx(RECT FAR*, DWORD, BOOL, DWORD);

#define WM_QUERYOPEN        0x0013
#define WM_CLOSE            0x0010

/* Struct pointed to by WM_GETMINMAXINFO lParam */
typedef struct tagMINMAXINFO
{
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO;
#define WM_GETMINMAXINFO    0x0024

#define WM_ENTERSIZEMOVE    0x0231              /* ;Internal */
#define WM_EXITSIZEMOVE     0x0232              /* ;Internal */
#define WM_ISACTIVEICON     0x0035              /* ;Internal */
#define WM_UNUSED0036       0x0036              /* ;Internal */
#define WM_TESTING          0x0040              /* ;Internal */

BOOL    WINAPI FlashWindow(HWND, BOOL);

void    WINAPI ShowOwnedPopups(HWND, BOOL);

/* Obsolete functions */
BOOL    WINAPI OpenIcon(HWND);
void    WINAPI CloseWindow(HWND);
BOOL    WINAPI AnyPopup(void);
BOOL    WINAPI IsIconic(HWND);
BOOL    WINAPI IsZoomed(HWND);

/****** Window coordinate mapping and hit-testing ***************************/

void    WINAPI ClientToScreen(HWND, POINT FAR*);
void    WINAPI ScreenToClient(HWND, POINT FAR*);

#if (WINVER >= 0x030a)
void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINT FAR* lppt, UINT cpt);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI WindowFromPoint(POINT);
HWND    WINAPI ChildWindowFromPoint(HWND, POINT);

/****** Window query and enumeration ****************************************/

HWND    WINAPI GetDesktopWindow(void);

HWND    WINAPI FindWindow(LPCSTR, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
#else
typedef FARPROC WNDENUMPROC;
#endif

BOOL    WINAPI EnumWindows(WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumChildWindows(HWND, WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumTaskWindows(HTASK, WNDENUMPROC, LPARAM);

HWND    WINAPI GetTopWindow(HWND);

HWND    WINAPI GetWindow(HWND, UINT);
HWND    WINAPI GetNextWindow(HWND, UINT);

/* GetWindow() constants */
#define GW_HWNDFIRST    0
#define GW_HWNDLAST     1
#define GW_HWNDNEXT     2
#define GW_HWNDPREV     3
#define GW_OWNER        4
#define GW_CHILD        5
#define GW_MAX          5       /* ;Internal */

HWND    WINAPI GetNextQueueWindow(HWND, int); /* ;Internal */

/****** Window property support *********************************************/

BOOL    WINAPI SetProp(HWND, LPCSTR, HANDLE);
HANDLE  WINAPI GetProp(HWND, LPCSTR);
HANDLE  WINAPI RemoveProp(HWND, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND, LPCSTR, HANDLE);
#else
typedef FARPROC PROPENUMPROC;
#endif

int     WINAPI EnumProps(HWND, PROPENUMPROC);

/****** Window drawing support **********************************************/

HDC     WINAPI GetDC(HWND);
int     WINAPI ReleaseDC(HWND, HDC);

HDC     WINAPI GetWindowDC(HWND);

#if (WINVER >= 0x030a)
HDC     WINAPI GetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);

#define DCX_WINDOW          0x00000001L
#define DCX_CACHE           0x00000002L
#define DCX_NORESETATTRS    0x00000004L /* ;Internal */
#define DCX_CLIPCHILDREN    0x00000008L
#define DCX_CLIPSIBLINGS    0x00000010L
#define DCX_PARENTCLIP      0x00000020L

#define DCX_EXCLUDERGN      0x00000040L
#define DCX_INTERSECTRGN    0x00000080L

#define DCX_EXCLUDEUPDATE   0x00000100L /* ;Internal */
#define DCX_INTERSECTUPDATE 0x00000200L /* ;Internal */

#define DCX_LOCKWINDOWUPDATE 0x00000400L

#define DCX_INVALID         0x00000800L /* ;Internal */
#define DCX_INUSE           0x00001000L /* ;Internal */
#define DCX_SAVEDRGNINVALID 0x00002000L /* ;Internal */

#define DCX_USESTYLE        0x00010000L
#define DCX_NEEDFONT        0x00020000L /* ;Internal */
#define DCX_NODELETERGN     0x00040000L /* ;Internal */
#define DCX_NOCLIPCHILDREN  0x00080000L /* ;Internal */
#define DCX_NORECOMPUTE     0x00100000L /* ;Internal */
#define DCX_VALIDATE        0x00200000L /* ;Internal */

#define DCX_MATCHMASK           (DCX_WINDOW | DCX_CACHE |                 /* ;Internal */ \
                                 DCX_CLIPCHILDREN | DCX_CLIPSIBLINGS |    /* ;Internal */ \
                                 DCX_LOCKWINDOWUPDATE                     /* ;Internal */ \
                                )                                         /* ;Internal */
#define DCX_VALID           0x000104fbL /* ;Internal */
#endif  /* WINVER >= 0x030a */

/****** Window repainting ***************************************************/

#define WM_PAINT            0x000F
#define WM_ERASEBKGND       0x0014
#define WM_PAINTICON        0x0026              /* ;Internal */
#define WM_ICONERASEBKGND   0x0027
#define WM_SYNCPAINT        0x0088              /* ;Internal */
#define WM_SYNCTASK         0x0089              /* ;Internal */

/* BeginPaint() return structure */
typedef struct tagPAINTSTRUCT
{
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[16];
} PAINTSTRUCT;
typedef PAINTSTRUCT* PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR* NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR* LPPAINTSTRUCT;

HDC     WINAPI BeginPaint(HWND, PAINTSTRUCT FAR*);
void    WINAPI EndPaint(HWND, const PAINTSTRUCT FAR*);

void    WINAPI UpdateWindow(HWND);

int     WINAPI ExcludeUpdateRgn(HDC, HWND);

#if (WINVER >= 0x030a)
BOOL    WINAPI LockWindowUpdate(HWND hwndLock);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetUpdateRect(HWND, RECT FAR*, BOOL);
int     WINAPI GetUpdateRgn(HWND, HRGN, BOOL);

void    WINAPI InvalidateRect(HWND, const RECT FAR*, BOOL);
void    WINAPI ValidateRect(HWND, const RECT FAR*);

void    WINAPI InvalidateRgn(HWND, HRGN, BOOL);
void    WINAPI ValidateRgn(HWND, HRGN);

#if (WINVER >= 0x030a)
BOOL    WINAPI RedrawWindow(HWND hwnd, const RECT FAR* lprcUpdate, HRGN hrgnUpdate, UINT flags);

#define RDW_INVALIDATE          0x0001
#define RDW_INTERNALPAINT       0x0002
#define RDW_ERASE               0x0004

#define RDW_VALIDATE            0x0008
#define RDW_NOINTERNALPAINT     0x0010
#define RDW_NOERASE             0x0020

#define RDW_NOCHILDREN          0x0040
#define RDW_ALLCHILDREN         0x0080

#define RDW_UPDATENOW           0x0100
#define RDW_ERASENOW            0x0200

#define RDW_FRAME               0x0400
#define RDW_NOFRAME             0x0800
                                                                        /* ;Internal */
#define RDW_REDRAWWINDOW        0x1000  /* Called from RedrawWindow()*/ /* ;Internal */
#define RDW_SUBTRACTSELF        0x2000  /* Subtract self from hrgn   */ /* ;Internal */
                                                                        /* ;Internal */
#define RDW_COPYRGN             0x4000  /* Copy the passed-in region */ /* ;Internal */
#define RDW_VALID               0x0fff                                  /* ;Internal */

#endif  /* WINVER >= 0x030a */

/****** Window scrolling ****************************************************/

void    WINAPI ScrollWindow(HWND, int, int, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI ScrollDC(HDC, int, int, const RECT FAR*, const RECT FAR*, HRGN, RECT FAR*);

#if (WINVER >= 0x030a)

int     WINAPI ScrollWindowEx(HWND hwnd, int dx, int dy,
                const RECT FAR* prcScroll, const RECT FAR* prcClip,
                HRGN hrgnUpdate, RECT FAR* prcUpdate, UINT flags);

#define SW_SCROLLCHILDREN   0x0001
#define SW_INVALIDATE       0x0002
#define SW_ERASE            0x0004

#define SW_SCROLLWINDOW     0x8000  /* ;Internal */
#define SW_VALID            0x8007  /* ;Internal */

#endif  /* WINVER >= 0x030a */

/****** Non-client window area management ************************************/

#define WM_NCPAINT          0x0085

#define WM_NCCALCSIZE       0x0083

#if (WINVER >= 0x030a)
/* WM_NCCALCSIZE return flags */
#define WVR_ALIGNTOP        0x0010
#define WVR_ALIGNLEFT       0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT      0x0080
#define WVR_HREDRAW         0x0100
#define WVR_VREDRAW         0x0200
#define WVR_REDRAW          (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS      0x0400

#define WVR_MINVALID        WVR_ALIGNTOP        /* ;Internal */
#define WVR_MAXVALID        WVR_VALIDRECTS      /* ;Internal */

/* WM_NCCALCSIZE parameter structure */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT           rgrc[3];
    WINDOWPOS FAR* lppos;
} NCCALCSIZE_PARAMS;
#else   /* WINVER >= 0x030a */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[2];
} NCCALCSIZE_PARAMS;
#endif  /* WINVER >= 0x030a */
typedef NCCALCSIZE_PARAMS FAR* LPNCCALCSIZE_PARAMS;

#define WM_NCHITTEST        0x0084

/* WM_NCHITTEST return codes */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTSIZE              4
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTMINBUTTON         8
#define HTMAXBUTTON         9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTBORDER            18
#define HTGROWBOX           HTSIZE
#define HTREDUCE            HTMINBUTTON
#define HTZOOM              HTMAXBUTTON
#define HTSIZEFIRST         HTLEFT              /* ;Internal */
#define HTSIZELAST          HTBOTTOMRIGHT       /* ;Internal */

/****** Drag-and-drop support ***********************************************/

#define WM_DROPOBJECT       0x022A              /* ;Internal */
#define WM_QUERYDROPOBJECT  0x022B              /* ;Internal */
#define WM_BEGINDRAG        0x022C              /* ;Internal */
#define WM_DRAGLOOP         0x022D              /* ;Internal */
#define WM_DRAGSELECT       0x022E              /* ;Internal */
#define WM_DRAGMOVE         0x022F              /* ;Internal */
#define WM_QUERYDRAGICON    0x0037
#define WM_DROPFILES        0x0233

/****** Window activation ***************************************************/

HWND    WINAPI SetActiveWindow(HWND);
HWND    WINAPI GetActiveWindow(void);

HWND    WINAPI GetLastActivePopup(HWND);

/* WM_ACTIVATE state values */
#define WA_INACTIVE         0
#define WA_ACTIVE           1
#define WA_CLICKACTIVE      2

#define WM_ACTIVATE         0x0006
#define WM_ACTIVATEAPP      0x001C
#define WM_NCACTIVATE       0x0086

/****** Keyboard input support **********************************************/

HWND    WINAPI SetFocus(HWND);
HWND    WINAPI GetFocus(void);

int     WINAPI GetKeyState(int);
int     WINAPI GetAsyncKeyState(int);

void    WINAPI GetKeyboardState(BYTE FAR* );
void    WINAPI SetKeyboardState(BYTE FAR* );

#define WM_SETFOCUS         0x0007
#define WM_KILLFOCUS        0x0008

#define WM_KEYDOWN          0x0100
#define WM_KEYUP            0x0101

#define WM_CHAR             0x0102
#define WM_DEADCHAR         0x0103

#define WM_SYSKEYDOWN       0x0104
#define WM_SYSKEYUP         0x0105

#define WM_SYSCHAR          0x0106
#define WM_SYSDEADCHAR      0x0107

#define WM_YOMICHAR         0x0108  /* JAPAN */ /* ;Internal */
#define WM_CONVERTREQUEST   0x010A  /* JAPAN */ /* ;Internal */
#define WM_CONVERTRESULT    0x010B  /* JAPAN */ /* ;Internal */
#define WM_INTERIM          0x010C  /* KOREA */ /* ;Internal */

/* Keyboard message range */
#define WM_KEYFIRST         0x0100
#define WM_KEYLAST          0x0108

/* WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags */
#define KF_EXTENDED         0x0100
#define KF_DLGMODE          0x0800
#define KF_MENUMODE         0x1000
#define KF_ALTDOWN          0x2000
#define KF_REPEAT           0x4000
#define KF_UP               0x8000

/* Virtual key codes */
#ifndef NOVIRTUALKEYCODES
#define VK_LBUTTON          0x01
#define VK_RBUTTON          0x02
#define VK_CANCEL           0x03
#define VK_MBUTTON          0x04
#define VK_BACK             0x08
#define VK_TAB              0x09
#define VK_CLEAR            0x0C
#define VK_RETURN           0x0D
#define VK_SHIFT            0x10
#define VK_CONTROL          0x11
#define VK_MENU             0x12
#define VK_PAUSE            0x13
#define VK_CAPITAL          0x14
#define VK_KANA             0x15    /* JAPAN */ /* ;Internal */
#define VK_KANJI            0x19    /* JAPAN */ /* ;Internal */
#define VK_HANGEUL          0x15    /* KOREA */ /* ;Internal */
#define VK_JUNJA            0x17    /* KOREA */ /* ;Internal */
#define VK_HANJA            0x19    /* KOREA */ /* ;Internal */
#define VK_ESCAPE           0x1B
#define VK_SPACE            0x20
#define VK_PRIOR            0x21
#define VK_NEXT             0x22
#define VK_END              0x23
#define VK_HOME             0x24
#define VK_LEFT             0x25
#define VK_UP               0x26
#define VK_RIGHT            0x27
#define VK_DOWN             0x28
#define VK_SELECT           0x29
#define VK_PRINT            0x2A
#define VK_EXECUTE          0x2B
#define VK_SNAPSHOT         0x2C
#define VK_INSERT           0x2D
#define VK_DELETE           0x2E
#define VK_HELP             0x2F
#define VK_NUMPAD0          0x60
#define VK_NUMPAD1          0x61
#define VK_NUMPAD2          0x62
#define VK_NUMPAD3          0x63
#define VK_NUMPAD4          0x64
#define VK_NUMPAD5          0x65
#define VK_NUMPAD6          0x66
#define VK_NUMPAD7          0x67
#define VK_NUMPAD8          0x68
#define VK_NUMPAD9          0x69
#define VK_MULTIPLY         0x6A
#define VK_ADD              0x6B
#define VK_SEPARATOR        0x6C
#define VK_SUBTRACT         0x6D
#define VK_DECIMAL          0x6E
#define VK_DIVIDE           0x6F
#define VK_F1               0x70
#define VK_F2               0x71
#define VK_F3               0x72
#define VK_F4               0x73
#define VK_F5               0x74
#define VK_F6               0x75
#define VK_F7               0x76
#define VK_F8               0x77
#define VK_F9               0x78
#define VK_F10              0x79
#define VK_F11              0x7A
#define VK_F12              0x7B
#define VK_F13              0x7C
#define VK_F14              0x7D
#define VK_F15              0x7E
#define VK_F16              0x7F
#define VK_F17              0x80
#define VK_F18              0x81
#define VK_F19              0x82
#define VK_F20              0x83
#define VK_F21              0x84
#define VK_F22              0x85
#define VK_F23              0x86
#define VK_F24              0x87
#define VK_NUMLOCK          0x90
#define VK_SCROLL           0x91

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#endif  /* NOVIRTUALKEYCODES */

BOOL WINAPI IsTwoByteCharPrefix(char);      /* ;Internal */

/* SetWindowsHook() keyboard hook */
#define WH_KEYBOARD         2

/****** Mouse input support *************************************************/

HWND    WINAPI SetCapture(HWND);
void    WINAPI ReleaseCapture(void);
HWND    WINAPI GetCapture(void);

BOOL    WINAPI SwapMouseButton(BOOL);

/* Mouse input messages */
#define WM_MOUSEMOVE        0x0200
#define WM_LBUTTONDOWN      0x0201
#define WM_LBUTTONUP        0x0202
#define WM_LBUTTONDBLCLK    0x0203
#define WM_RBUTTONDOWN      0x0204
#define WM_RBUTTONUP        0x0205
#define WM_RBUTTONDBLCLK    0x0206
#define WM_MBUTTONDOWN      0x0207
#define WM_MBUTTONUP        0x0208
#define WM_MBUTTONDBLCLK    0x0209

/* Mouse input message range */
#define WM_MOUSEFIRST       0x0200
#define WM_MOUSELAST        0x0209

/* Mouse message wParam key states */
#ifndef NOKEYSTATES
#define MK_LBUTTON          0x0001
#define MK_RBUTTON          0x0002
#define MK_SHIFT            0x0004
#define MK_CONTROL          0x0008
#define MK_MBUTTON          0x0010
#endif  /* NOKEYSTATES */

/* Non-client mouse messages */
#define WM_NCMOUSEMOVE      0x00A0
#define WM_NCLBUTTONDOWN    0x00A1
#define WM_NCLBUTTONUP      0x00A2
#define WM_NCLBUTTONDBLCLK  0x00A3
#define WM_NCRBUTTONDOWN    0x00A4
#define WM_NCRBUTTONUP      0x00A5
#define WM_NCRBUTTONDBLCLK  0x00A6
#define WM_NCMBUTTONDOWN    0x00A7
#define WM_NCMBUTTONUP      0x00A8
#define WM_NCMBUTTONDBLCLK  0x00A9

/* Mouse click activation support */
#define WM_MOUSEACTIVATE    0x0021

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE         1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE       3
#if (WINVER >= 0x030a)
#define MA_NOACTIVATEANDEAT 4
#endif  /* WINVER >= 0x030a */

/* SetWindowsHook() mouse hook */
#ifndef NOWH
#define WH_MOUSE            7

typedef struct tagMOUSEHOOKSTRUCT
{
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT;
typedef MOUSEHOOKSTRUCT  FAR* LPMOUSEHOOKSTRUCT;
#endif  /* NOWH */

/****** Mode control ********************************************************/

#define WM_CANCELMODE       0x001F

/****** System modal window support *****************************************/

HWND    WINAPI GetSysModalWindow(void);
HWND    WINAPI SetSysModalWindow(HWND);

/****** Timer support *******************************************************/

#ifdef STRICT
typedef void (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
#else
typedef FARPROC TIMERPROC;
#endif

UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC);

BOOL    WINAPI KillTimer(HWND, UINT);

#define WM_TIMER            0x0113
#define WM_SYSTIMER         0x0118              /* ;Internal */

/****** Accelerator support *************************************************/

DECLARE_HANDLE(HACCEL);

HACCEL  WINAPI LoadAccelerators(HINSTANCE, LPCSTR);

#ifndef NOMSG
int     WINAPI TranslateAccelerator(HWND, HACCEL, MSG FAR*);
#endif

/****** Menu support ********************************************************/

#ifndef NOMENUS

/* Menu template header */
typedef struct
{
    UINT    versionNumber;
    UINT    offset;
} MENUITEMTEMPLATEHEADER;

/* Menu template item struct */
typedef struct
{
    UINT    mtOption;
    UINT    mtID;
    char    mtString[1];
} MENUITEMTEMPLATE;

#if (WINVER >= 0x030a)
BOOL    WINAPI IsMenu(HMENU);
#endif  /* WINVER >= 0x030a */

HMENU   WINAPI CreateMenu(void);
HMENU   WINAPI CreatePopupMenu(void);
HMENU   WINAPI LoadMenu(HINSTANCE, LPCSTR);
HMENU   WINAPI LoadMenuIndirect(const void FAR*);

BOOL    WINAPI DestroyMenu(HMENU);

HMENU   WINAPI GetMenu(HWND);
BOOL    WINAPI SetMenu(HWND, HMENU);

HMENU   WINAPI GetSystemMenu(HWND, BOOL);
BOOL    WINAPI SetSystemMenu(HWND, HMENU);    /* ;Internal */

void    WINAPI DrawMenuBar(HWND);

BOOL    WINAPI HiliteMenuItem(HWND, HMENU, UINT, UINT);

BOOL    WINAPI InsertMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI AppendMenu(HMENU, UINT, UINT, LPCSTR);
BOOL    WINAPI ModifyMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI RemoveMenu(HMENU, UINT, UINT);
BOOL    WINAPI DeleteMenu(HMENU, UINT, UINT);

BOOL    WINAPI ChangeMenu(HMENU, UINT, LPCSTR, UINT, UINT);

#define MF_INSERT           0x0000
#define MF_CHANGE           0x0080
#define MF_APPEND           0x0100
#define MF_DELETE           0x0200
#define MF_REMOVE           0x1000

/* Menu flags for Add/Check/EnableMenuItem() */
#define MF_BYCOMMAND        0x0000
#define MF_BYPOSITION       0x0400

#define MF_SEPARATOR        0x0800

#define MF_ENABLED          0x0000
#define MF_GRAYED           0x0001
#define MF_DISABLED         0x0002

#define MF_UNCHECKED        0x0000
#define MF_CHECKED          0x0008
#define MF_USECHECKBITMAPS  0x0200

#define MF_STRING           0x0000
#define MF_BITMAP           0x0004
#define MF_OWNERDRAW        0x0100

#define MF_POPUP            0x0010
#define MF_MENUBARBREAK     0x0020
#define MF_MENUBREAK        0x0040

#define MF_UNHILITE         0x0000
#define MF_HILITE           0x0080

#define MF_SYSMENU          0x2000
#define MF_HELP             0x4000
#define MF_MOUSESELECT      0x8000

#define MF_VALID            0x4fff  /* ;Internal */
#define MF_CHANGE_VALID     0x5fff  /* ;Internal */

#define MF_END              0x0080  /* Only valid in menu resource templates */

BOOL    WINAPI EnableMenuItem(HMENU, UINT, UINT);
BOOL    WINAPI CheckMenuItem(HMENU, UINT, UINT);

HMENU   WINAPI GetSubMenu(HMENU, int);

int     WINAPI GetMenuItemCount(HMENU);
UINT    WINAPI GetMenuItemID(HMENU, int);

int     WINAPI GetMenuString(HMENU, UINT, LPSTR, int, UINT);
UINT    WINAPI GetMenuState(HMENU, UINT, UINT);

BOOL    WINAPI SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
DWORD   WINAPI GetMenuCheckMarkDimensions(void);

BOOL    WINAPI TrackPopupMenu(HMENU, UINT, int, int, int, HWND, const RECT FAR*);

/* Flags for TrackPopupMenu */
#define TPM_LEFTBUTTON  0x0000
#if (WINVER >= 0x030a)
#define TPM_RIGHTBUTTON 0x0002
#define TPM_LEFTALIGN   0x0000
#define TPM_CENTERALIGN 0x0004
#define TPM_RIGHTALIGN  0x0008
#define TPM_VALID       0x000f  /* ;Internal */
#endif  /* WINVER >= 0x030a */

#endif  /* NOMENUS */

/* Menu messages */
#define WM_INITMENU         0x0116
#define WM_INITMENUPOPUP    0x0117

#ifndef NOMENUS

#define WM_MENUSELECT       0x011F
#define WM_MENUCHAR         0x0120
#define WM_ENTERMENULOOP    0x0211              /* ;Internal */
#define WM_EXITMENULOOP     0x0212              /* ;Internal */
#define WM_NEXTMENU         0x0213              /* ;Internal */

#endif  /* NOMENUS */

/* Menu and control command messages */
#define WM_COMMAND          0x0111

/****** Scroll bar support **************************************************/

#ifndef NOSCROLL

#define WM_HSCROLL          0x0114
#define WM_VSCROLL          0x0115

/* WM_H/VSCROLL commands */
#define SB_LINEUP           0
#define SB_LINELEFT         0
#define SB_LINEDOWN         1
#define SB_LINERIGHT        1
#define SB_PAGEUP           2
#define SB_PAGELEFT         2
#define SB_PAGEDOWN         3
#define SB_PAGERIGHT        3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK       5
#define SB_TOP              6
#define SB_LEFT             6
#define SB_BOTTOM           7
#define SB_RIGHT            7
#define SB_ENDSCROLL        8
#define SB_MSGCMD_MAX       8       /* ;Internal */

/* Scroll bar selection constants */
#define SB_HORZ             0
#define SB_VERT             1
#define SB_CTL              2
#define SB_BOTH             3
#define SB_MAX              3       /* ;Internal */

int     WINAPI SetScrollPos(HWND, int, int, BOOL);
int     WINAPI GetScrollPos(HWND, int);
void    WINAPI SetScrollRange(HWND, int, int, int, BOOL);
void    WINAPI GetScrollRange(HWND, int, int FAR*, int FAR*);
void    WINAPI ShowScrollBar(HWND, int, BOOL);
BOOL    WINAPI EnableScrollBar(HWND, int, UINT);

/* EnableScrollBar() flags */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT

#define ESB_MAX             0x0003              /* ;Internal */
#define SB_DISABLE_MASK     ESB_DISABLE_BOTH    /* ;Internal */
#endif  /* NOSCROLL */

/******* Clipboard manager **************************************************/

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_TEXT              1
#define CF_BITMAP            2
#define CF_METAFILEPICT      3
#define CF_SYLK              4
#define CF_DIF               5
#define CF_TIFF              6
#define CF_OEMTEXT           7
#define CF_DIB               8
#define CF_PALETTE           9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF

/* Clipboard Manager Functions */
BOOL    WINAPI OpenClipboard(HWND);
BOOL    WINAPI CloseClipboard(void);
BOOL    WINAPI EmptyClipboard(void);

#if (WINVER >= 0x030a)
HWND    WINAPI GetOpenClipboardWindow(void);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI GetClipboardOwner(void);

HWND    WINAPI SetClipboardViewer(HWND);
HWND    WINAPI GetClipboardViewer(void);

HANDLE  WINAPI SetClipboardData(UINT, HANDLE);
HANDLE  WINAPI GetClipboardData(UINT);

BOOL    WINAPI IsClipboardFormatAvailable(UINT);
int     WINAPI GetPriorityClipboardFormat(UINT FAR*, int);

UINT    WINAPI RegisterClipboardFormat(LPCSTR);
int     WINAPI CountClipboardFormats(void);
UINT    WINAPI EnumClipboardFormats(UINT);
int     WINAPI GetClipboardFormatName(UINT, LPSTR, int);

BOOL    WINAPI ChangeClipboardChain(HWND, HWND);

/* Clipboard command messages */
#define WM_CUT              0x0300
#define WM_COPY             0x0301
#define WM_PASTE            0x0302
#define WM_CLEAR            0x0303
#define WM_UNDO             0x0304

/* Clipboard owner messages */
#define WM_RENDERFORMAT     0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307

/* Clipboard viewer messages */
#define WM_DRAWCLIPBOARD    0x0308
#define WM_PAINTCLIPBOARD   0x0309
#define WM_SIZECLIPBOARD    0x030B
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_HSCROLLCLIPBOARD 0x030E
#define WM_ASKCBFORMATNAME  0x030C
#define WM_CHANGECBCHAIN    0x030D

#endif  /* NOCLIPBOARD */

/****** Mouse cursor support *************************************************/

HCURSOR WINAPI LoadCursor(HINSTANCE, LPCSTR);
HCURSOR WINAPI CreateCursor(HINSTANCE, int, int, int, int, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI CopyCursor(HINSTANCE, HCURSOR);
#endif  /* WINVER >= 0x030a */

int     WINAPI ShowCursor(BOOL);

void    WINAPI SetCursorPos(int, int);
void    WINAPI GetCursorPos(POINT FAR*);

HCURSOR WINAPI SetCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI GetCursor(void);
#endif  /* WINVER >= 0x030a */

void    WINAPI ClipCursor(const RECT FAR*);
#if (WINVER >= 0x030a)
void    WINAPI GetClipCursor(RECT FAR*);
#endif  /* WINVER >= 0x030a */

/* Standard cursor resource IDs */
#define IDC_ARROW           MAKEINTRESOURCE(32512)
#define IDC_IBEAM           MAKEINTRESOURCE(32513)
#define IDC_WAIT            MAKEINTRESOURCE(32514)
#define IDC_CROSS           MAKEINTRESOURCE(32515)
#define IDC_UPARROW         MAKEINTRESOURCE(32516)
#define IDC_SIZE            MAKEINTRESOURCE(32640)
#define IDC_ICON            MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE        MAKEINTRESOURCE(32642)
#define IDC_SIZENESW        MAKEINTRESOURCE(32643)
#define IDC_SIZEWE          MAKEINTRESOURCE(32644)
#define IDC_SIZENS          MAKEINTRESOURCE(32645)

#define WM_SETCURSOR        0x0020

/****** Icon support *********************************************************/

HICON   WINAPI LoadIcon(HINSTANCE, LPCSTR);
HICON   WINAPI CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyIcon(HICON);

#if (WINVER >= 0x030a)
HICON   WINAPI CopyIcon(HINSTANCE, HICON);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DrawIcon(HDC, int, int, HICON);

#ifndef NOICONS

/* Standard icon resource IDs */
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND            MAKEINTRESOURCE(32513)
#define IDI_QUESTION        MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK        MAKEINTRESOURCE(32516)

#endif  /* NOICONS */

/****** Message Box support *************************************************/

#ifndef NOMB

int     WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT);
void    WINAPI MessageBeep(UINT);

#define MB_OK               0x0000
#define MB_OKCANCEL         0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL      0x0003
#define MB_YESNO            0x0004
#define MB_RETRYCANCEL      0x0005
#define MB_TYPEMASK         0x000F

#define MB_ICONHAND         0x0010
#define MB_ICONQUESTION     0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040
#define MB_ICONMASK         0x00F0

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1       0x0000
#define MB_DEFBUTTON2       0x0100
#define MB_DEFBUTTON3       0x0200
#define MB_DEFMASK          0x0F00

#define MB_APPLMODAL        0x0000
#define MB_SYSTEMMODAL      0x1000
#define MB_TASKMODAL        0x2000

#define MB_NOFOCUS          0x8000

#define MB_TYPEMASK         0x000F      /* ;Internal */
#define MB_ICONMASK         0x00F0      /* ;Internal */
#define MB_DEFMASK          0x0F00      /* ;Internal */
#define MB_MODEMASK         0x3000      /* ;Internal */
#define MB_MISCMASK         0xC000      /* ;Internal */
#define MB_VALID            0xb377      /* ;Internal */


#endif  /* NOMB */

/****** Caret support ********************************************************/

void    WINAPI CreateCaret(HWND, HBITMAP, int, int);
void    WINAPI DestroyCaret(void);

void    WINAPI SetCaretPos(int, int);
void    WINAPI GetCaretPos(POINT FAR*);

void    WINAPI HideCaret(HWND);
void    WINAPI ShowCaret(HWND);

UINT    WINAPI GetCaretBlinkTime(void);
void    WINAPI SetCaretBlinkTime(UINT);

/****** WM_SYSCOMMAND support ***********************************************/

#define WM_SYSCOMMAND   0x0112

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

/* Obsolete names */
#define SC_ICON         SC_MINIMIZE
#define SC_ZOOM         SC_MAXIMIZE

/* SC_HOTKEY support messages */ /* ;Internal */
#define WM_SETHOTKEY    0x0032   /* ;Internal */
#define WM_GETHOTKEY    0x0033   /* ;Internal */

#endif  /* NOSYSCOMMANDS */

/****** MDI Support *********************************************************/

#ifndef NOMDI

/* CreateWindow lpParams structure for creating MDI client */
typedef struct tagCLIENTCREATESTRUCT
{
    HMENU  hWindowMenu;
    UINT   idFirstChild;
} CLIENTCREATESTRUCT;
typedef CLIENTCREATESTRUCT FAR* LPCLIENTCREATESTRUCT;

/* MDI client style bits */
#if (WINVER >= 0x030a)
#define MDIS_ALLCHILDSTYLES 0x0001
#endif  /* WINVER >= 0x030a */

/* MDI messages */
#define WM_MDICREATE        0x0220
#define WM_MDIDESTROY       0x0221
#define WM_MDIACTIVATE      0x0222
#define WM_MDIRESTORE       0x0223
#define WM_MDINEXT          0x0224
#define WM_MDIMAXIMIZE      0x0225
#define WM_MDITILE          0x0226
#define WM_MDICASCADE       0x0227
#define WM_MDIICONARRANGE   0x0228
#define WM_MDIGETACTIVE     0x0229
#define WM_MDISETMENU       0x0230

/* WM_MDICREATE message structure */
typedef struct tagMDICREATESTRUCT
{
    LPCSTR  szClass;
    LPCSTR  szTitle;
    HINSTANCE hOwner;
    int     x;
    int     y;
    int     cx;
    int     cy;
    DWORD   style;
    LPARAM  lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT FAR*  LPMDICREATESTRUCT;

#if (WINVER >= 0x030a)
/* wParam values for WM_MDITILE and WM_MDICASCADE messages. */
#define MDITILE_VERTICAL        0x0000
#define MDITILE_HORIZONTAL      0x0001
#define MDITILE_SKIPDISABLED    0x0002
#endif  /* WINVER >= 0x030a */

#define WM_CHILDACTIVATE    0x0022

LRESULT WINAPI DefFrameProc(HWND, HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI DefMDIChildProc(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG
BOOL    WINAPI TranslateMDISysAccel(HWND, MSG FAR*);
#endif

UINT    WINAPI ArrangeIconicWindows(HWND);

#endif  /* NOMDI */

/****** Dialog and Control Management ***************************************/

#ifndef NOCTLMGR

/* Dialog window class */
#define WC_DIALOG       (MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA  30

/* Dialog styles */
#define DS_ABSALIGN         0x01L
#define DS_SYSMODAL         0x02L
#define DS_LOCALEDIT        0x20L
#define DS_SETFONT          0x40L
#define DS_MODALFRAME       0x80L
#define DS_NOIDLEMSG        0x100L

/* Dialog messages */
#define DM_GETDEFID         (WM_USER+0)
#define DM_SETDEFID         (WM_USER+1)

/* Returned in HIWORD() of DM_GETDEFID result if msg is supported */
#define DC_HASDEFID         0x534B

#endif  /* NOCTLMGR */

/* Dialog notification messages */
#define WM_INITDIALOG       0x0110
#define WM_NEXTDLGCTL       0x0028
#define WM_ALTTABACTIVE     0x0029              /* ;Internal */

#define WM_PARENTNOTIFY     0x0210

#define WM_ENTERIDLE        0x0121


#ifndef NOCTLMGR

#ifdef STRICT
typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#else
typedef FARPROC DLGPROC;
#endif

/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT   0
#define DWL_DLGPROC     4
#define DWL_USER        8

#ifndef NOMSG
BOOL    WINAPI IsDialogMessage(HWND, MSG FAR*);
#endif

LRESULT WINAPI DefDlgProc(HWND, UINT, WPARAM, LPARAM);

HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);

int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);

void    WINAPI EndDialog(HWND, int);

int     WINAPI GetDlgCtrlID(HWND);
HWND    WINAPI GetDlgItem(HWND, int);
LRESULT WINAPI SendDlgItemMessage(HWND, int, UINT, WPARAM, LPARAM);

void    WINAPI SetDlgItemInt(HWND, int, UINT, BOOL);
UINT    WINAPI GetDlgItemInt(HWND, int, BOOL FAR* , BOOL);

void    WINAPI SetDlgItemText(HWND, int, LPCSTR);
int     WINAPI GetDlgItemText(HWND, int, LPSTR, int);

void    WINAPI CheckDlgButton(HWND, int, UINT);
void    WINAPI CheckRadioButton(HWND, int, int, int);
UINT    WINAPI IsDlgButtonChecked(HWND, int);

HWND    WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND    WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);

void    WINAPI MapDialogRect(HWND, RECT FAR*);
DWORD   WINAPI GetDialogBaseUnits(void);

#define WM_GETDLGCODE       0x0087

/* dialog codes */
#define DLGC_WANTARROWS     0x0001
#define DLGC_WANTTAB        0x0002
#define DLGC_WANTALLKEYS    0x0004
#define DLGC_WANTMESSAGE    0x0004
#define DLGC_HASSETSEL      0x0008
#define DLGC_DEFPUSHBUTTON  0x0010
#define DLGC_UNDEFPUSHBUTTON 0x0020
#define DLGC_RADIOBUTTON    0x0040
#define DLGC_WANTCHARS      0x0080
#define DLGC_STATIC         0x0100
#define DLGC_BUTTON         0x2000

#define WM_CTLCOLOR         0x0019

/* WM_CTLCOLOR control IDs */
#define CTLCOLOR_MSGBOX     0
#define CTLCOLOR_EDIT       1
#define CTLCOLOR_LISTBOX    2
#define CTLCOLOR_BTN        3
#define CTLCOLOR_DLG        4
#define CTLCOLOR_SCROLLBAR  5
#define CTLCOLOR_STATIC     6
#define CTLCOLOR_MAX        8       /* ;Internal */

#define WM_SETFONT          0x0030
#define WM_GETFONT          0x0031

#endif  /* NOCTLMGR */

/* Standard dialog button IDs */
#define IDOK                1
#define IDCANCEL            2
#define IDABORT             3
#define IDRETRY             4
#define IDIGNORE            5
#define IDYES               6
#define IDNO                7

/****** Owner draw control support ******************************************/

/* Owner draw control types */
#define ODT_MENU        1
#define ODT_LISTBOX     2
#define ODT_COMBOBOX    3
#define ODT_BUTTON      4

/* Owner draw actions */
#define ODA_DRAWENTIRE  0x0001
#define ODA_SELECT      0x0002
#define ODA_FOCUS       0x0004

/* Owner draw state */
#define ODS_SELECTED    0x0001
#define ODS_GRAYED      0x0002
#define ODS_DISABLED    0x0004
#define ODS_CHECKED     0x0008
#define ODS_FOCUS       0x0010

#define WM_DRAWITEM         0x002B

typedef struct tagDRAWITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR* PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR* LPDRAWITEMSTRUCT;

#define WM_MEASUREITEM      0x002C

typedef struct tagMEASUREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemWidth;
    UINT        itemHeight;
    DWORD       itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR* PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR* LPMEASUREITEMSTRUCT;

#define WM_DELETEITEM       0x002D

typedef struct tagDELETEITEMSTRUCT
{
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    DWORD      itemData;
} DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR* PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR* LPDELETEITEMSTRUCT;

#define WM_COMPAREITEM      0x0039

typedef struct tagCOMPAREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    HWND        hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
} COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR* PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR* LPCOMPAREITEMSTRUCT;

/****** Static control ******************************************************/

#ifndef NOCTLMGR

/* Static Control Styles */
#define SS_LEFT             0x00000000L
#define SS_CENTER           0x00000001L
#define SS_RIGHT            0x00000002L
#define SS_ICON             0x00000003L
#define SS_BLACKRECT        0x00000004L
#define SS_GRAYRECT         0x00000005L
#define SS_WHITERECT        0x00000006L
#define SS_BLACKFRAME       0x00000007L
#define SS_GRAYFRAME        0x00000008L
#define SS_WHITEFRAME       0x00000009L
#define SS_USERITEM         0x0000000AL    /* ;Internal */
#define SS_SIMPLE           0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#define SS_NOPREFIX         0x00000080L

#if (WINVER >= 0x030a)
#ifndef NOWINMESSAGES
/* Static Control Mesages */
#define STM_SETICON         (WM_USER+0)
#define STM_GETICON         (WM_USER+1)
#define STM_MSGMAX          (WM_USER+2)    /* ;Internal */
#endif  /* NOWINMESSAGES */
#endif  /* WINVER >= 0x030a */

#endif  /* NOCTLMGR */

/****** Button control *****************************************************/

#ifndef NOCTLMGR

/* Button Control Styles */
#define BS_PUSHBUTTON       0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX         0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON      0x00000004L
#define BS_3STATE           0x00000005L
#define BS_AUTO3STATE       0x00000006L
#define BS_GROUPBOX         0x00000007L
#define BS_USERBUTTON       0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_PUSHBOX          0x0000000AL  /* ;Internal */
#define BS_OWNERDRAW        0x0000000BL
#define BS_LEFTTEXT         0x00000020L

/* Button Control Messages  */
#define BM_GETCHECK         (WM_USER+0)
#define BM_SETCHECK         (WM_USER+1)
#define BM_GETSTATE         (WM_USER+2)
#define BM_SETSTATE         (WM_USER+3)
#define BM_SETSTYLE         (WM_USER+4)

/* User Button Notification Codes */
#define BN_CLICKED          0
#define BN_PAINT            1
#define BN_HILITE           2
#define BN_UNHILITE         3
#define BN_DISABLE          4
#define BN_DOUBLECLICKED    5

#endif  /* NOCTLMGR */

/****** Edit control *******************************************************/

#ifndef NOCTLMGR

/* Edit control styles */
#ifndef NOWINSTYLES
#define ES_LEFT             0x00000000L
#define ES_CENTER           0x00000001L
#define ES_RIGHT            0x00000002L
#define ES_MULTILINE        0x00000004L
#define ES_UPPERCASE        0x00000008L
#define ES_LOWERCASE        0x00000010L
#define ES_PASSWORD         0x00000020L
#define ES_AUTOVSCROLL      0x00000040L
#define ES_AUTOHSCROLL      0x00000080L
#define ES_NOHIDESEL        0x00000100L
#define ES_OEMCONVERT       0x00000400L
#if (WINVER >= 0x030a)
#define ES_READONLY         0x00000800L
#define ES_WANTRETURN       0x00001000L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Edit control messages */
#ifndef NOWINMESSAGES
#define EM_GETSEL               (WM_USER+0)
#define EM_SETSEL               (WM_USER+1)
#define EM_GETRECT              (WM_USER+2)
#define EM_SETRECT              (WM_USER+3)
#define EM_SETRECTNP            (WM_USER+4)
#define EM_SCROLL               (WM_USER+5)     /* ;Internal */
#define EM_LINESCROLL           (WM_USER+6)
#define EM_GETMODIFY            (WM_USER+8)
#define EM_SETMODIFY            (WM_USER+9)
#define EM_GETLINECOUNT         (WM_USER+10)
#define EM_LINEINDEX            (WM_USER+11)
#define EM_SETHANDLE            (WM_USER+12)
#define EM_GETHANDLE            (WM_USER+13)
#define EM_GETTHUMB             (WM_USER+14)    /* ;Internal */
#define EM_LINELENGTH           (WM_USER+17)
#define EM_REPLACESEL           (WM_USER+18)
#define EM_SETFONT              (WM_USER+19)    /* NOT IMPLEMENTED: use WM_SETFONT */
#define EM_GETLINE              (WM_USER+20)
#define EM_LIMITTEXT            (WM_USER+21)
#define EM_CANUNDO              (WM_USER+22)
#define EM_UNDO                 (WM_USER+23)
#define EM_FMTLINES             (WM_USER+24)
#define EM_LINEFROMCHAR         (WM_USER+25)
#define EM_SETWORDBREAK         (WM_USER+26)    /* NOT IMPLEMENTED: use EM_SETWORDBREAK */
#define EM_SETTABSTOPS          (WM_USER+27)
#define EM_SETPASSWORDCHAR      (WM_USER+28)
#define EM_EMPTYUNDOBUFFER      (WM_USER+29)
#if (WINVER >= 0x030a)
#define EM_GETFIRSTVISIBLELINE  (WM_USER+30)
#define EM_SETREADONLY          (WM_USER+31)
#define EM_SETWORDBREAKPROC     (WM_USER+32)
#define EM_GETWORDBREAKPROC     (WM_USER+33)
#define EM_GETPASSWORDCHAR      (WM_USER+34)
#endif  /* WINVER >= 0x030a */
#define EM_MSGMAX               (WM_USER+35)    /* ;Internal */
#endif  /* NOWINMESSAGES */

#if (WINVER >= 0x030a)
typedef int   (CALLBACK* EDITWORDBREAKPROC)(LPSTR lpch, int ichCurrent, int cch, int code);

/* EDITWORDBREAKPROC code values */
#define WB_LEFT            0
#define WB_RIGHT           1
#define WB_ISDELIMITER     2
#endif  /* WINVER >= 0x030a */

/* Edit control notification codes */
#define EN_SETFOCUS         0x0100
#define EN_KILLFOCUS        0x0200
#define EN_CHANGE           0x0300
#define EN_UPDATE           0x0400
#define EN_ERRSPACE         0x0500
#define EN_MAXTEXT          0x0501
#define EN_HSCROLL          0x0601
#define EN_VSCROLL          0x0602

#endif  /* NOCTLMGR */

/****** Scroll bar control *************************************************/
/* Also see scrolling support */

#ifndef NOCTLMGR

#ifndef NOWINSTYLES

/* Scroll bar styles */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L

#endif  /* NOWINSTYLES */

#endif  /* NOCTLMGR */

/****** Listbox control ****************************************************/

#ifndef NOCTLMGR

/* Listbox styles */
#ifndef NOWINSTYLES
#define LBS_NOTIFY            0x0001L
#define LBS_SORT              0x0002L
#define LBS_NOREDRAW          0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL       0x0800L
#if (WINVER >= 0x030a)
#define LBS_DISABLENOSCROLL   0x1000L
#endif  /* WINVER >= 0x030a */
#define LBS_STANDARD          (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif  /* NOWINSTYLES */

/* Listbox messages */
#ifndef NOWINMESSAGES
#define LB_ADDSTRING           (WM_USER+1)
#define LB_INSERTSTRING        (WM_USER+2)
#define LB_DELETESTRING        (WM_USER+3)
#define LB_RESETCONTENT        (WM_USER+5)
#define LB_SETSEL              (WM_USER+6)
#define LB_SETCURSEL           (WM_USER+7)
#define LB_GETSEL              (WM_USER+8)
#define LB_GETCURSEL           (WM_USER+9)
#define LB_GETTEXT             (WM_USER+10)
#define LB_GETTEXTLEN          (WM_USER+11)
#define LB_GETCOUNT            (WM_USER+12)
#define LB_SELECTSTRING        (WM_USER+13)
#define LB_DIR                 (WM_USER+14)
#define LB_GETTOPINDEX         (WM_USER+15)
#define LB_FINDSTRING          (WM_USER+16)
#define LB_GETSELCOUNT         (WM_USER+17)
#define LB_GETSELITEMS         (WM_USER+18)
#define LB_SETTABSTOPS         (WM_USER+19)
#define LB_GETHORIZONTALEXTENT (WM_USER+20)
#define LB_SETHORIZONTALEXTENT (WM_USER+21)
#define LB_SETCOLUMNWIDTH      (WM_USER+22)
#define LB_ADDFILE             (WM_USER+23)     /* ;Internal */
#define LB_SETTOPINDEX         (WM_USER+24)
#define LB_GETITEMRECT         (WM_USER+25)
#define LB_GETITEMDATA         (WM_USER+26)
#define LB_SETITEMDATA         (WM_USER+27)
#define LB_SELITEMRANGE        (WM_USER+28)
#define LB_SETANCHORINDEX      (WM_USER+29)     /* ;Internal */
#define LB_GETANCHORINDEX      (WM_USER+30)     /* ;Internal */
#define LB_SETCARETINDEX       (WM_USER+31)
#define LB_GETCARETINDEX       (WM_USER+32)

#if (WINVER >= 0x030a)
#define LB_SETITEMHEIGHT       (WM_USER+33)
#define LB_GETITEMHEIGHT       (WM_USER+34)
#define LB_FINDSTRINGEXACT     (WM_USER+35)
#endif  /* WINVER >= 0x030a */
#define LBCB_CARETON           (WM_USER+36)     /* ;Internal */
#define LBCB_CARETOFF          (WM_USER+37)     /* ;Internal */
#define LB_MSGMAX              (WM_USER+38)     /* ;Internal */

#endif  /* NOWINMESSAGES */

/* Listbox notification codes */
#define LBN_ERRSPACE        (-2)
#define LBN_SELCHANGE       1
#define LBN_DBLCLK          2
#define LBN_SELCANCEL       3
#define LBN_SETFOCUS        4
#define LBN_KILLFOCUS       5

/* Listbox notification messages */
#define WM_VKEYTOITEM       0x002E
#define WM_CHARTOITEM       0x002F
#define WM_LBTRACKPOINT     0x0131              /* ;Internal */

/* Listbox message return values */
#define LB_OKAY             0
#define LB_ERR              (-1)
#define LB_ERRSPACE         (-2)

#define LB_CTLCODE          0L

/****** Dialog directory support ********************************************/

int     WINAPI DlgDirList(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelect(HWND, LPSTR, int);

int     WINAPI DlgDirListComboBox(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelectComboBox(HWND, LPSTR, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI DlgDirSelectEx(HWND, LPSTR, int, int);
BOOL    WINAPI DlgDirSelectComboBoxEx(HWND, LPSTR, int, int);
#endif  /* WINVER >= 0x030a */

#define LBD_UPPERCASE   0x8001     /* ;Internal */
#define LBD_SIZE        0x8002     /* ;Internal */
#define LBD_DATE        0x8004     /* ;Internal */
#define LBD_TIME        0x8008     /* ;Internal */
#define LBD_ATTRIBUTE   0x8010     /* ;Internal */
#define LBD_FULLDETAILS 0x801E     /* ;Internal */
#define LBD_SENDDETAILS 0x8020     /* ;Internal */

/* DlgDirList, DlgDirListComboBox flags values */
#define DDL_READWRITE       0x0000
#define DDL_READONLY        0x0001
#define DDL_HIDDEN          0x0002
#define DDL_SYSTEM          0x0004
#define DDL_DIRECTORY       0x0010
#define DDL_ARCHIVE         0x0020

#define DDL_POSTMSGS        0x2000
#define DDL_DRIVES          0x4000
#define DDL_EXCLUSIVE       0x8000
#define DDL_VALID           0xe03f      /* ;Internal */

#endif  /* NOCTLMGR */

/****** Combo box control **************************************************/

#ifndef NOCTLMGR

/* Combo box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE            0x0001L
#define CBS_DROPDOWN          0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#if (WINVER >= 0x030a)
#define CBS_DISABLENOSCROLL   0x0800L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Combo box messages */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL            (WM_USER+0)
#define CB_LIMITTEXT             (WM_USER+1)
#define CB_SETEDITSEL            (WM_USER+2)
#define CB_ADDSTRING             (WM_USER+3)
#define CB_DELETESTRING          (WM_USER+4)
#define CB_DIR                   (WM_USER+5)
#define CB_GETCOUNT              (WM_USER+6)
#define CB_GETCURSEL             (WM_USER+7)
#define CB_GETLBTEXT             (WM_USER+8)
#define CB_GETLBTEXTLEN          (WM_USER+9)
#define CB_INSERTSTRING          (WM_USER+10)
#define CB_RESETCONTENT          (WM_USER+11)
#define CB_FINDSTRING            (WM_USER+12)
#define CB_SELECTSTRING          (WM_USER+13)
#define CB_SETCURSEL             (WM_USER+14)
#define CB_SHOWDROPDOWN          (WM_USER+15)
#define CB_GETITEMDATA           (WM_USER+16)
#define CB_SETITEMDATA           (WM_USER+17)
#if (WINVER >= 0x030a)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_SETITEMHEIGHT         (WM_USER+19)
#define CB_GETITEMHEIGHT         (WM_USER+20)
#define CB_SETEXTENDEDUI         (WM_USER+21)
#define CB_GETEXTENDEDUI         (WM_USER+22)
#define CB_GETDROPPEDSTATE       (WM_USER+23)
#define CB_FINDSTRINGEXACT       (WM_USER+24)
#endif  /* WINVER >= 0x030a */
#define CB_MSGMAX                (WM_USER+25)       /* ;Internal */

#endif  /* NOWINMESSAGES */

/* Combo box notification codes */
#define CBN_ERRSPACE        (-1)
#define CBN_SELCHANGE       1
#define CBN_DBLCLK          2
#define CBN_SETFOCUS        3
#define CBN_KILLFOCUS       4
#define CBN_EDITCHANGE      5
#define CBN_EDITUPDATE      6
#define CBN_DROPDOWN        7
#if (WINVER >= 0x030a)
#define CBN_CLOSEUP         8
#define CBN_SELENDOK        9
#define CBN_SELENDCANCEL    10
#endif  /* WINVER >= 0x030a */

/* Combo box message return values */
#define CB_OKAY             0
#define CB_ERR              (-1)
#define CB_ERRSPACE         (-2)

#endif  /* NOCTLMGR */

/******* Windows hook support **********************************************/

#ifndef NOWH

DECLARE_HANDLE32(HHOOK);

#ifdef STRICT
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
#else
typedef FARPROC HOOKPROC;
#endif

#ifdef STRICT
HHOOK   WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HHOOK FAR*);
#else
HOOKPROC WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HOOKPROC FAR*);
#endif
BOOL    WINAPI UnhookWindowsHook(int, HOOKPROC);

#if (WINVER >= 0x030a)

HHOOK   WINAPI SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
BOOL    WINAPI UnhookWindowsHookEx(HHOOK hHook);
LRESULT WINAPI CallNextHookEx(HHOOK hHook, int code, WPARAM wParam, LPARAM lParam);

#endif  /* WINVER >= 0x030a */

#define WH_MIN              (-1)                            /* ;Internal */
#define WH_MAX              10                              /* ;Internal */
#define WH_MINHOOK          WH_MIN                          /* ;Internal */
#define WH_MAXHOOK          WH_MAX                          /* ;Internal */
#define WH_CHOOKS           (WH_MAXHOOK - WH_MINHOOK + 1)   /* ;Internal */

/* Standard hook code */
#define HC_ACTION           0

/* Obsolete hook codes (NO LONGER SUPPORTED) */
#define HC_GETLPLPFN        (-3)
#define HC_LPLPFNNEXT       (-2)
#define HC_LPFNNEXT         (-1)

#endif  /* NOWH */

/****** Computer-based-training (CBT) support *******************************/

#define WM_QUEUESYNC        0x0023

#ifndef NOWH

/* SetWindowsHook() code */
#define WH_CBT              5

#define HCBT_MOVESIZE       0
#define HCBT_MINMAX         1
#define HCBT_QS             2
#define HCBT_CREATEWND      3
#define HCBT_DESTROYWND     4
#define HCBT_ACTIVATE       5
#define HCBT_CLICKSKIPPED   6
#define HCBT_KEYSKIPPED     7
#define HCBT_SYSCOMMAND     8
#define HCBT_SETFOCUS       9

#if (WINVER >= 0x030a)
/* HCBT_CREATEWND parameters pointed to by lParam */
typedef struct tagCBT_CREATEWND
{
    CREATESTRUCT FAR* lpcs;
    HWND    hwndInsertAfter;
} CBT_CREATEWND;
typedef CBT_CREATEWND FAR* LPCBT_CREATEWND;

/* HCBT_ACTIVATE structure pointed to by lParam */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Hardware hook support ***********************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
#define WH_HARDWARE         8

typedef struct tagHARDWAREHOOKSTRUCT
{
    HWND    hWnd;
    UINT    wMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT;
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Shell support *******************************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
/* SetWindowsHook() Shell hook code */
#define WH_SHELL           10

#define HSHELL_WINDOWCREATED       1
#define HSHELL_WINDOWDESTROYED     2
#define HSHELL_ACTIVATESHELLWINDOW 3

#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Journalling support *************************************************/

#ifndef NOWH
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1

/* Journalling hook codes */
#define HC_GETNEXT          1
#define HC_SKIP             2
#define HC_NOREMOVE         3
#define HC_NOREM            HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF      5

/* Journalling message structure */
typedef struct tagEVENTMSG
{
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD   time;
} EVENTMSG;
typedef EVENTMSG *PEVENTMSG;
typedef EVENTMSG *PEVENTMSGMSG;                 /* ;Internal */
typedef EVENTMSG NEAR* NPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSGMSG;            /* ;Internal */

BOOL    WINAPI EnableHardwareInput(BOOL);

#endif  /* NOWH */


/****** Debugger support ****************************************************/

#if (WINVER >= 0x030a)
/* SetWindowsHook debug hook support */
#define WH_DEBUG            9

typedef struct tagDEBUGHOOKINFO
{
    HMODULE     hModuleHook;
    LPARAM      reserved;
    LPARAM      lParam;
    WPARAM      wParam;
    int         code;
} DEBUGHOOKINFO;
typedef DEBUGHOOKINFO FAR* LPDEBUGHOOKINFO;

#ifndef NOMSG
BOOL WINAPI QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
#endif  /* NOMSG */

BOOL WINAPI LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG WINAPI GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState.
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004
#define SDS_DIALOG      0x0008
#define SDS_TASKLOCKED  0x0010
#endif  /* WINVER >= 0x030a */

/****** Help support ********************************************************/

#ifndef NOHELP

BOOL WINAPI WinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

/* WinHelp() commands */
#define HELP_CONTEXT      0x0001
#define HELP_QUIT         0x0002
#define HELP_INDEX        0x0003
#define HELP_CONTENTS     0x0003
#define HELP_HELPONHELP   0x0004
#define HELP_SETINDEX     0x0005
#define HELP_SETCONTENTS  0x0005
#define HELP_CONTEXTPOPUP 0x0008
#define HELP_FORCEFILE    0x0009
#define HELP_KEY          0x0101
#define HELP_COMMAND      0x0102
#define HELP_PARTIALKEY   0x0105
#define HELP_MULTIKEY     0x0201
#define HELP_SETWINPOS    0x0203

typedef struct tagMULTIKEYHELP
{
    UINT    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP;


typedef struct
{
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    char rgchMember[2];
} HELPWININFO;
typedef HELPWININFO NEAR* PHELPWININFO;
typedef HELPWININFO FAR* LPHELPWININFO;

#endif  /* NOHELP */

/****** Sound support ******************************************************/

#ifndef NOSOUND

int     WINAPI OpenSound(void);
void    WINAPI CloseSound(void);

int     WINAPI StartSound(void);
int     WINAPI StopSound(void);

int     WINAPI SetVoiceQueueSize(int, int);
int     WINAPI SetVoiceNote(int, int, int, int);
int     WINAPI SetVoiceAccent(int, int, int, int, int);
int     WINAPI SetVoiceEnvelope(int, int, int);
int     WINAPI SetVoiceSound(int, DWORD, int);

int     WINAPI SetVoiceThreshold(int, int);
int FAR* WINAPI GetThresholdEvent(void);
int     WINAPI GetThresholdStatus(void);

int     WINAPI SetSoundNoise(int, int);

/* SetSoundNoise() Sources */
#define S_PERIOD512   0
#define S_PERIOD1024  1
#define S_PERIOD2048  2
#define S_PERIODVOICE 3
#define S_WHITE512    4
#define S_WHITE1024   5
#define S_WHITE2048   6
#define S_WHITEVOICE  7

int     WINAPI WaitSoundState(int);

/* WaitSoundState() constants */
#define S_QUEUEEMPTY        0
#define S_THRESHOLD         1
#define S_ALLTHRESHOLD      2

int     WINAPI SyncAllVoices(void);
int     WINAPI CountVoiceNotes(int);

/* Accent Modes */
#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

/* Error return values */
#define S_SERDVNA     (-1)
#define S_SEROFM      (-2)
#define S_SERMACT     (-3)
#define S_SERQFUL     (-4)
#define S_SERBDNT     (-5)
#define S_SERDLN      (-6)
#define S_SERDCC      (-7)
#define S_SERDTP      (-8)
#define S_SERDVL      (-9)
#define S_SERDMD      (-10)
#define S_SERDSH      (-11)
#define S_SERDPT      (-12)
#define S_SERDFQ      (-13)
#define S_SERDDR      (-14)
#define S_SERDSR      (-15)
#define S_SERDST      (-16)

#endif  /* NOSOUND */

/****** Comm support ******************************************************/

#ifndef NOCOMM

#define NOPARITY            0
#define ODDPARITY           1
#define EVENPARITY          2
#define MARKPARITY          3
#define SPACEPARITY         4

#define ONESTOPBIT          0
#define ONE5STOPBITS        1
#define TWOSTOPBITS         2

#define IGNORE              0
#define INFINITE            0xFFFF

/* Error Flags */
#define CE_RXOVER           0x0001
#define CE_OVERRUN          0x0002
#define CE_RXPARITY         0x0004
#define CE_FRAME            0x0008
#define CE_BREAK            0x0010
#define CE_CTSTO            0x0020
#define CE_DSRTO            0x0040
#define CE_RLSDTO           0x0080
#define CE_TXFULL           0x0100
#define CE_PTO              0x0200
#define CE_IOE              0x0400
#define CE_DNS              0x0800
#define CE_OOP              0x1000
#define CE_MODE             0x8000

#define IE_BADID            (-1)
#define IE_OPEN             (-2)
#define IE_NOPEN            (-3)
#define IE_MEMORY           (-4)
#define IE_DEFAULT          (-5)
#define IE_HARDWARE         (-10)
#define IE_BYTESIZE         (-11)
#define IE_BAUDRATE         (-12)

/* Events */
#define EV_RXCHAR           0x0001
#define EV_RXFLAG           0x0002
#define EV_TXEMPTY          0x0004
#define EV_CTS              0x0008
#define EV_DSR              0x0010
#define EV_RLSD             0x0020
#define EV_BREAK            0x0040
#define EV_ERR              0x0080
#define EV_RING             0x0100
#define EV_PERR             0x0200
#define EV_CTSS             0x0400
#define EV_DSRS             0x0800
#define EV_RLSDS            0x1000
#define EV_RingTe           0x2000
#define EV_RINGTE           EV_RingTe
#define EV_VALID            0x3fff  /* ;Internal */

/* Escape Functions */
#define SETXOFF             1
#define SETXON              2
#define SETRTS              3
#define CLRRTS              4
#define SETDTR              5
#define CLRDTR              6
#define RESETDEV            7

#define LPTx                0x80

#if (WINVER >= 0x030a)

/* new escape functions */
#define GETMAXLPT           8
#define GETMAXCOM           9
#define GETBASEIRQ          10

/* Comm Baud Rate indices */
#define CBR_110      0xFF10
#define CBR_300      0xFF11
#define CBR_600      0xFF12
#define CBR_1200     0xFF13
#define CBR_2400     0xFF14
#define CBR_4800     0xFF15
#define CBR_9600     0xFF16
#define CBR_14400    0xFF17
#define CBR_19200    0xFF18
#define CBR_38400    0xFF1B
#define CBR_56000    0xFF1F
#define CBR_128000   0xFF23
#define CBR_256000   0xFF27

/* notifications passed in low word of lParam on WM_COMMNOTIFY messages */
#define CN_RECEIVE  0x0001
#define CN_TRANSMIT 0x0002
#define CN_EVENT    0x0004

#endif  /* WINVER >= 0x030a */

typedef struct tagDCB
{
    BYTE Id;
    UINT BaudRate;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    UINT RlsTimeout;
    UINT CtsTimeout;
    UINT DsrTimeout;

    UINT fBinary        :1;
    UINT fRtsDisable    :1;
    UINT fParity        :1;
    UINT fOutxCtsFlow   :1;
    UINT fOutxDsrFlow   :1;
    UINT fDummy         :2;
    UINT fDtrDisable    :1;

    UINT fOutX          :1;
    UINT fInX           :1;
    UINT fPeChar        :1;
    UINT fNull          :1;
    UINT fChEvt         :1;
    UINT fDtrflow       :1;
    UINT fRtsflow       :1;
    UINT fDummy2        :1;

    char XonChar;
    char XoffChar;
    UINT XonLim;
    UINT XoffLim;
    char PeChar;
    char EofChar;
    char EvtChar;
    UINT TxDelay;
} DCB;
typedef DCB FAR* LPDCB;

#if (defined(STRICT) | (WINVER >= 0x030a))

typedef struct tagCOMSTAT
{
    BYTE status;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#define CSTF_CTSHOLD    0x01
#define CSTF_DSRHOLD    0x02
#define CSTF_RLSDHOLD   0x04
#define CSTF_XOFFHOLD   0x08
#define CSTF_XOFFSENT   0x10
#define CSTF_EOF        0x20
#define CSTF_TXIM       0x40

#else   /* (STRICT | WINVER >= 0x030a) */

/* NOTE: This structure declaration is not ANSI compatible! */
typedef struct tagCOMSTAT
{
    BYTE fCtsHold  :1;
    BYTE fDsrHold  :1;
    BYTE fRlsdHold :1;
    BYTE fXoffHold :1;
    BYTE fXoffSent :1;
    BYTE fEof      :1;
    BYTE fTxim     :1;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#endif  /* !(STRICT | WINVER >= 0x030a */

int     WINAPI BuildCommDCB(LPCSTR, DCB FAR*);

int     WINAPI OpenComm(LPCSTR, UINT, UINT);
int     WINAPI CloseComm(int);

int     WINAPI ReadComm(int, void FAR*, int);
int     WINAPI WriteComm(int, const void FAR*, int);
int     WINAPI UngetCommChar(int, char);
int     WINAPI FlushComm(int, int);
int     WINAPI TransmitCommChar(int, char);

int     WINAPI SetCommState(const DCB FAR*);
int     WINAPI GetCommState(int, DCB FAR*);
int     WINAPI GetCommError(int, COMSTAT FAR* );

int     WINAPI SetCommBreak(int);
int     WINAPI ClearCommBreak(int);

UINT FAR* WINAPI SetCommEventMask(int, UINT);
UINT    WINAPI GetCommEventMask(int, int);

LONG    WINAPI EscapeCommFunction(int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI EnableCommNotification(int, HWND, int, int);

#define WM_COMMNOTIFY           0x0044
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOMM */

/****** String formatting support *******************************************/

int     WINAPI wvsprintf(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);

int     FAR CDECL wsprintf(LPSTR lpszOut, LPCSTR lpszFmt, ...);


/****** Driver support ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NODRIVERS

DECLARE_HANDLE(HDRVR);

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

/* Driver messages */
#define DRV_LOAD                0x0001
#define DRV_ENABLE              0x0002
#define DRV_OPEN                0x0003
#define DRV_CLOSE               0x0004
#define DRV_DISABLE             0x0005
#define DRV_FREE                0x0006
#define DRV_CONFIGURE           0x0007
#define DRV_QUERYCONFIGURE      0x0008
#define DRV_INSTALL             0x0009
#define DRV_REMOVE              0x000A
#define DRV_EXITSESSION         0x000B
#define DRV_EXITAPPLICATION     0x000C
#define DRV_POWER               0x000F

#define DRV_RESERVED            0x0800
#define DRV_USER                0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO
{
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO NEAR* PDRVCONFIGINFO;
typedef DRVCONFIGINFO FAR* LPDRVCONFIGINFO;

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL           0x0000
#define DRVCNF_OK               0x0001
#define DRVCNF_RESTART          0x0002

/* Supported lParam1 of DRV_EXITAPPLICATION notification */
#define DRVEA_NORMALEXIT            0x0001
#define DRVEA_ABNORMALEXIT          0x0002

LRESULT WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, UINT message, LPARAM lParam1, LPARAM lParam2);

HDRVR   WINAPI OpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT WINAPI CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

LRESULT WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

HINSTANCE WINAPI GetDriverModuleHandle(HDRVR hDriver);

HDRVR   WINAPI GetNextDriver(HDRVR, DWORD);

/* GetNextDriver flags */
#define GND_FIRSTINSTANCEONLY   0x00000001

#define GND_FORWARD             0x00000000
#define GND_REVERSE             0x00000002
#define GND_VALID               0x00000003  /* ;Internal */

typedef struct tagDRIVERINFOSTRUCT
{
    UINT    length;
    HDRVR   hDriver;
    HINSTANCE hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT;
typedef DRIVERINFOSTRUCT FAR* LPDRIVERINFOSTRUCT;

BOOL    WINAPI GetDriverInfo(HDRVR, DRIVERINFOSTRUCT FAR*);

#endif  /* !NODRIVERS */
#endif  /* WINVER >= 0x030a */
#endif  /* NOUSER */

#ifndef NOWINDOWSX          /* ;Internal */
#ifndef RC_INVOKED          /* ;Internal */
#include "windowsx.h"       /* ;Internal */
#ifndef STRICT              /* ;Internal */
#undef  SelectFont          /* ;Internal */
#endif  /* STRICT */        /* ;Internal */
#endif  /* RC_INVOKED */    /* ;Internal */
#endif  /* NOWINDOWSX */    /* ;Internal */
#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_WINDOWS */

// WOW Section //

int  FAR PASCAL WowGetNextVdmCommand(LPVOID);
int  FAR PASCAL WOWRegisterShellWindowHandle(HWND,LPVOID, HWND);
int  FAR PASCAL WowFailedExec(void);
void FAR PASCAL ExitKernelThunk(WORD wExitCode);
WORD FAR PASCAL WowSetExitOnLastApp(WORD fExitOnLastApp);

// Pickup WOW Generic Thunk Interfaces from wownt16,h //

#include "wownt16.h"

// this is a poor prototype.  CallProc32W is is a bad vararg function
// however rasapi16.c uses it.

#ifndef NO_CALLPROC32_DECL
DWORD FAR PASCAL CallProc32W(LPVOID, DWORD, DWORD);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\winnet.h ===
/*
 *      Windows/Network Interface
 *      Copyright (C) Microsoft 1989-1993
 *
 *      Standard WINNET Driver Header File, spec version 3.10
 */


#ifndef _INC_WINNET
#define _INC_WINNET  /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif   /* __cplusplus */

typedef WORD far * LPWORD;

#ifndef API
#define API WINAPI
#endif


/*
 *      SPOOLING - CONTROLLING JOBS
 */

#define WNJ_NULL_JOBID  0


WORD API WNetOpenJob(LPSTR,LPSTR,WORD,LPINT);
WORD API WNetCloseJob(WORD,LPINT,LPSTR);
WORD API WNetWriteJob(HANDLE,LPSTR,LPINT);
WORD API WNetAbortJob(WORD,LPSTR);
WORD API WNetHoldJob(LPSTR,WORD);
WORD API WNetReleaseJob(LPSTR,WORD);
WORD API WNetCancelJob(LPSTR,WORD);
WORD API WNetSetJobCopies(LPSTR,WORD,WORD);

/*
 *      SPOOLING - QUEUE AND JOB INFO
 */

typedef struct _queuestruct     {
	WORD    pqName;
	WORD    pqComment;
	WORD    pqStatus;
	WORD    pqJobcount;
	WORD    pqPrinters;
} QUEUESTRUCT;

typedef QUEUESTRUCT far * LPQUEUESTRUCT;

#define WNPRQ_ACTIVE    0x0
#define WNPRQ_PAUSE     0x1
#define WNPRQ_ERROR     0x2
#define WNPRQ_PENDING   0x3
#define WNPRQ_PROBLEM   0x4


typedef struct _jobstruct       {
	WORD    pjId;
	WORD    pjUsername;
	WORD    pjParms;
	WORD    pjPosition;
	WORD    pjStatus;
	DWORD   pjSubmitted;
	DWORD   pjSize;
	WORD    pjCopies;
	WORD    pjComment;
} JOBSTRUCT;

typedef JOBSTRUCT far * LPJOBSTRUCT;

#define WNPRJ_QSTATUS           0x0007
#define WNPRJ_QS_QUEUED                0x0000
#define WNPRJ_QS_PAUSED                0x0001
#define WNPRJ_QS_SPOOLING              0x0002
#define WNPRJ_QS_PRINTING              0x0003
#define WNPRJ_DEVSTATUS         0x0FF8
#define WNPRJ_DS_COMPLETE              0x0008
#define WNPRJ_DS_INTERV                0x0010
#define WNPRJ_DS_ERROR                 0x0020
#define WNPRJ_DS_DESTOFFLINE           0x0040
#define WNPRJ_DS_DESTPAUSED            0x0080
#define WNPRJ_DS_NOTIFY                0x0100
#define WNPRJ_DS_DESTNOPAPER           0x0200
#define WNPRJ_DS_DESTFORMCHG           0x0400
#define WNPRJ_DS_DESTCRTCHG            0x0800
#define WNPRJ_DS_DESTPENCHG            0x1000

#define SP_QUEUECHANGED         0x0500


WORD API WNetWatchQueue(HWND,LPSTR,LPSTR,WORD);
WORD API WNetUnwatchQueue(LPSTR);
WORD API WNetLockQueueData(LPSTR,LPSTR,LPQUEUESTRUCT FAR *);
WORD API WNetUnlockQueueData(LPSTR);


/*
 *      CONNECTIONS
 */

UINT API WNetAddConnection(LPSTR,LPSTR,LPSTR);
UINT API WNetCancelConnection(LPSTR,BOOL);
UINT API WNetGetConnection(LPSTR,LPSTR, UINT FAR *);
UINT API WNetRestoreConnection(HWND,LPSTR);

/*
 *      CAPABILITIES
 */

#define WNNC_SPEC_VERSION               0x0001

#define WNNC_NET_TYPE                   0x0002
#define  WNNC_NET_NONE                          0x0000
#define  WNNC_NET_MSNet                         0x0100
#define  WNNC_NET_LanMan                        0x0200
#define  WNNC_NET_NetWare                       0x0300
#define  WNNC_NET_Vines                         0x0400
#define  WNNC_NET_10NET                         0x0500
#define  WNNC_NET_Locus                         0x0600
#define  WNNC_NET_Sun_PC_NFS                    0x0700
#define  WNNC_NET_LANstep                       0x0800
#define  WNNC_NET_9TILES                        0x0900
#define  WNNC_NET_LANtastic                     0x0A00
#define  WNNC_NET_AS400                         0x0B00
#define  WNNC_NET_FTP_NFS                       0x0C00
#define  WNNC_NET_PATHWORKS                     0x0D00
#define  WNNC_NET_MultiNet       0x8000
#define   WNNC_SUBNET_NONE          0x0000
#define   WNNC_SUBNET_MSNet            0x0001
#define   WNNC_SUBNET_LanMan           0x0002
#define   WNNC_SUBNET_WinWorkgroups       0x0004
#define   WNNC_SUBNET_NetWare          0x0008
#define   WNNC_SUBNET_Vines            0x0010
#define   WNNC_SUBNET_Other            0x0080

#define WNNC_DRIVER_VERSION             0x0003

#define WNNC_USER                       0x0004
#define  WNNC_USR_GetUser                       0x0001

#define WNNC_CONNECTION                 0x0006
#define  WNNC_CON_AddConnection                 0x0001
#define  WNNC_CON_CancelConnection              0x0002
#define  WNNC_CON_GetConnections                0x0004
#define  WNNC_CON_AutoConnect                   0x0008
#define  WNNC_CON_BrowseDialog                  0x0010
#define  WNNC_CON_RestoreConnection             0x0020

#define WNNC_PRINTING                   0x0007
#define  WNNC_PRT_OpenJob                       0x0002
#define  WNNC_PRT_CloseJob                      0x0004
#define  WNNC_PRT_HoldJob                       0x0010
#define  WNNC_PRT_ReleaseJob                    0x0020
#define  WNNC_PRT_CancelJob                     0x0040
#define  WNNC_PRT_SetJobCopies                  0x0080
#define  WNNC_PRT_WatchQueue                    0x0100
#define  WNNC_PRT_UnwatchQueue                  0x0200
#define  WNNC_PRT_LockQueueData                 0x0400
#define  WNNC_PRT_UnlockQueueData               0x0800
#define  WNNC_PRT_ChangeMsg                     0x1000
#define  WNNC_PRT_AbortJob                      0x2000
#define  WNNC_PRT_NoArbitraryLock               0x4000
#define  WNNC_PRT_WriteJob                      0x8000

#define WNNC_DIALOG                     0x0008
#define  WNNC_DLG_DeviceMode                    0x0001
#define  WNNC_DLG_BrowseDialog                  0x0002
#define  WNNC_DLG_ConnectDialog                 0x0004
#define  WNNC_DLG_DisconnectDialog              0x0008
#define  WNNC_DLG_ViewQueueDialog               0x0010
#define  WNNC_DLG_PropertyDialog                0x0020
#define  WNNC_DLG_ConnectionDialog              0x0040
#define  WNNC_DLG_PrinterConnectDialog    0x0080
#define  WNNC_DLG_SharesDialog         0x0100
#define  WNNC_DLG_ShareAsDialog        0x0200


#define WNNC_ADMIN                      0x0009
#define  WNNC_ADM_GetDirectoryType              0x0001
#define  WNNC_ADM_DirectoryNotify               0x0002
#define  WNNC_ADM_LongNames                     0x0004
#define  WNNC_ADM_SetDefaultDrive      0x0008

#define WNNC_ERROR                      0x000A
#define  WNNC_ERR_GetError                      0x0001
#define  WNNC_ERR_GetErrorText                  0x0002


WORD API WNetGetCaps(WORD);

/*
 *      OTHER
 */

WORD API WNetGetUser(LPSTR,LPINT);

/*
 *      BROWSE DIALOG
 */

#define WNBD_CONN_UNKNOWN       0x0
#define WNBD_CONN_DISKTREE      0x1
#define WNBD_CONN_PRINTQ        0x3
#define WNBD_MAX_LENGTH         0x80    // path length, includes the NULL

#define WNTYPE_DRIVE            1
#define WNTYPE_FILE             2
#define WNTYPE_PRINTER          3
#define WNTYPE_COMM             4

#define WNPS_FILE               0
#define WNPS_DIR                1
#define WNPS_MULT               2

WORD API WNetDeviceMode(HWND);
WORD API WNetBrowseDialog(HWND,WORD,LPSTR);
WORD API WNetConnectDialog(HWND,WORD);
WORD API WNetDisconnectDialog(HWND,WORD);
WORD API WNetConnectionDialog(HWND,WORD);
WORD API WNetViewQueueDialog(HWND,LPSTR);
WORD API WNetPropertyDialog(HWND hwndParent, WORD iButton, WORD nPropSel,
				 LPSTR lpszName, WORD nType);
WORD API WNetGetPropertyText(WORD iButton, WORD nPropSel, LPSTR lpszName,
				  LPSTR lpszButtonName, WORD cbButtonName, WORD nType);

/*
	 The following APIs are not exported from USER.EXE.  They must be
	 loaded from the active network driver like this:

	 HINSTANCE hinstNetDriver;
	 LPWNETSERVERBROWSEDIALOG lpDialogAPI;

	 hinstNetDriver = (HINSTANCE)WNetGetCaps(0xFFFF);
	 if (hinstNetDriver == NULL) {
	// no network driver loaded
	 }
	 else {
	lpDialogAPI = (LPWNETSERVERBROWSEDIALOG)GetProcAddress(hinstNetDriver,
					(LPSTR)ORD_WNETSERVERBROWSEDIALOG);

	if (lpDialogAPI == NULL) {
		 // currently installed network doesn't support this API
	}
	else {
		 (*lpDialogAPI)(hwndParent, lpszSectionName, lpszBuffer, cbBuffer, 0L);
	}
	 }
*/

typedef WORD (API *LPWNETSHAREASDIALOG)(HWND hwndParent, WORD iType,
						 LPSTR lpszPath);
typedef WORD (API *LPWNETSTOPSHAREDIALOG)(HWND hwndParent, WORD iType,
							LPSTR lpszPath);
typedef WORD (API *LPWNETSETDEFAULTDRIVE)(WORD idriveDefault);
typedef WORD (API *LPWNETGETSHARECOUNT)(WORD iType);
typedef WORD (API *LPWNETGETSHARENAME)(LPSTR lpszPath, LPSTR lpszBuf,
						WORD cbBuf);
typedef WORD (API *LPWNETSERVERBROWSEDIALOG)(HWND hwndParent,
						 LPSTR lpszSectionName,
						 LPSTR lpszBuffer,
						 WORD cbBuffer,
						 DWORD flFlags);
typedef WORD (API *LPWNETGETSHAREPATH)(LPSTR lpszName, LPSTR lpszBuf,
						WORD cbBuf);
typedef WORD (API *LPWNETGETLASTCONNECTION)(WORD iType, LPWORD lpwConnIndex);
typedef WORD (API *LPWNETEXITCONFIRM)(HWND hwndOwner, WORD iExitType);

typedef BOOL (API *LPI_AUTOLOGON)(HWND hwndOwner, LPSTR lpszReserved,
						BOOL fPrompt, BOOL FAR *lpfLoggedOn);
typedef BOOL (API *LPI_LOGOFF)(HWND hwndOwner, LPSTR lpszReserved);
typedef VOID (API *LPI_CHANGEPASSWORD)(HWND hwndOwner);
typedef VOID (API *LPI_CHANGECACHEPASSWORD)(HWND hwndOwner);
typedef WORD (API *LPI_CONNECTDIALOG)(HWND hwndParent, WORD iType);
typedef WORD (API *LPI_CONNECTIONDIALOG)(HWND hwndParent, WORD iType);


typedef struct tagPASSWORD_CACHE_ENTRY {
	 WORD cbEntry;
	 WORD cbResource;
	 WORD cbPassword;
	 BYTE iEntry;
	 BYTE nType;
	 BYTE abResource[1];    /* resource name, cbResource bytes long */
				/* password follows immediately after */
} PASSWORD_CACHE_ENTRY;

typedef PASSWORD_CACHE_ENTRY FAR *LPPASSWORD_CACHE_ENTRY;

typedef WORD (API *LPWNETCACHEPASSWORD)(LPSTR pbResource, WORD cbResource,
					LPSTR pbPassword, WORD cbPassword,
					BYTE nType);

typedef WORD (API *LPWNETGETCACHEDPASSWORD)(LPSTR pbResource, WORD cbResource,
						 LPSTR pbPassword, LPWORD pcbPassword,
						 BYTE nType);

typedef WORD (API *LPWNETREMOVECACHEDPASSWORD)(LPSTR pbResource,
							 WORD cbResource,
							 BYTE nType);

/*
	 Typedef for the callback routine passed to WNetEnumCachedPasswords.
	 It will be called once for each entry that matches the criteria
	 requested.  It should return TRUE if it wants the enumeration to
	 continue, FALSE to stop.
*/
typedef BOOL (API *CACHECALLBACK)( LPPASSWORD_CACHE_ENTRY pce );


typedef WORD (API *LPWNETENUMCACHEDPASSWORDS)(LPSTR pbPrefix, WORD cbPrefix,
							BYTE nType,
							CACHECALLBACK pfnCallback);

/*
 * Ordinals in the network driver for APIs not exported by USER.
 */
#define ORD_I_AUTOLOGON       530
#define ORD_I_CHANGEPASSWORD     531
#define ORD_I_LOGOFF       532
#define ORD_I_CONNECTIONDIALOG      533
#define ORD_I_CHANGECACHEPASSWORD   534
#define ORD_I_CONNECTDIALOG      535
#define ORD_WNETSHARESDIALOG     140
#define ORD_WNETSHAREASDIALOG    141
#define ORD_WNETSTOPSHAREDIALOG     142
#define ORD_WNETSETDEFAULTDRIVE     143
#define ORD_WNETGETSHARECOUNT    144
#define ORD_WNETGETSHARENAME     145

#define ORD_WNETSERVERBROWSEDIALOG  146

#define ORD_WNETGETSHAREPATH     147

#define ORD_WNETGETLASTCONNECTION   148

#define ORD_WNETEXITCONFIRM      149

#define ORD_WNETCACHEPASSWORD    150
#define ORD_WNETGETCACHEDPASSWORD   151
#define ORD_WNETREMOVECACHEDPASSWORD   152
#define ORD_WNETENUMCACHEDPASSWORDS 153

/*
 *   the following nType values are only for the purposes of enumerating
 *   entries from the cache.  note that PCE_ALL is reserved and should not
 *   be the nType value for any entry.
*/

#define PCE_DOMAIN   0x01  /* entry is for a domain */
#define PCE_SERVER   0x02  /* entry is for a server */
#define PCE_UNC      0x03  /* entry is for a server/share combo */

#define PCE_NOTMRU   0x80  /* bit set if entry is exempt from MRU aging */
#define PCE_ALL      0xff  /* retrieve all entries */


/*
 * Defines for iExitType on WNetExitConfirm
 */
#define EXIT_CONFIRM 0
#define EXIT_EXITING 1
#define EXIT_CANCELED   2

/*
 *      ADMIN
 */

#define WNDT_NORMAL   0
#define WNDT_NETWORK  1

#define WNDN_MKDIR  1
#define WNDN_RMDIR  2
#define WNDN_MVDIR  3

WORD API WNetGetDirectoryType(LPSTR,LPINT);
WORD API WNetDirectoryNotify(HWND,LPSTR,WORD);

/*
 *      ERRORS
 */

WORD API WNetGetError(LPINT);
WORD API WNetGetErrorText(WORD,LPSTR,LPINT);


/*
 *      STATUS CODES
 */

/* General */

#define WN_SUCCESS                      0x0000
#define WN_NOT_SUPPORTED                0x0001
#define WN_NET_ERROR                    0x0002
#define WN_MORE_DATA                    0x0003
#define WN_BAD_POINTER                  0x0004
#define WN_BAD_VALUE                    0x0005
#define WN_BAD_PASSWORD                 0x0006
#define WN_ACCESS_DENIED                0x0007
#define WN_FUNCTION_BUSY                0x0008
#define WN_WINDOWS_ERROR                0x0009
#define WN_BAD_USER                     0x000A
#define WN_OUT_OF_MEMORY                0x000B
#define WN_CANCEL                       0x000C
#define WN_CONTINUE                     0x000D

/* Connection */

#define WN_NOT_CONNECTED                0x0030
#define WN_OPEN_FILES                   0x0031
#define WN_BAD_NETNAME                  0x0032
#define WN_BAD_LOCALNAME                0x0033
#define WN_ALREADY_CONNECTED            0x0034
#define WN_DEVICE_ERROR                 0x0035
#define WN_CONNECTION_CLOSED            0x0036

/* Printing */

#define WN_BAD_JOBID                    0x0040
#define WN_JOB_NOT_FOUND                0x0041
#define WN_JOB_NOT_HELD                 0x0042
#define WN_BAD_QUEUE                    0x0043
#define WN_BAD_FILE_HANDLE              0x0044
#define WN_CANT_SET_COPIES              0x0045
#define WN_ALREADY_LOCKED               0x0046

#define WN_NO_ERROR                     0x0050

/* stuff in user, not driver, for shell apps ;Internal */
WORD API WNetErrorText(WORD,LPSTR,WORD); /* ;Internal */

#ifdef LFN

/* this is the data structure returned from LFNFindFirst and
 * LFNFindNext.  The last field, achName, is variable length.  The size
 * of the name in that field is given by cchName, plus 1 for the zero
 * terminator.
 */
typedef struct _filefindbuf2
  {
	 WORD fdateCreation;
	 WORD ftimeCreation;
	 WORD fdateLastAccess;
	 WORD ftimeLastAccess;
	 WORD fdateLastWrite;
	 WORD ftimeLastWrite;
	 DWORD cbFile;
	 DWORD cbFileAlloc;
	 WORD attr;
	 DWORD cbList;
	 BYTE cchName;
	 BYTE achName[1];
  } FILEFINDBUF2, FAR * PFILEFINDBUF2;

typedef BOOL (API *PQUERYPROC)( void );

WORD API LFNFindFirst(LPSTR,WORD,LPINT,LPINT,WORD,PFILEFINDBUF2);
WORD API LFNFindNext(HANDLE,LPINT,WORD,PFILEFINDBUF2);
WORD API LFNFindClose(HANDLE);
WORD API LFNGetAttribute(LPSTR,LPINT);
WORD API LFNSetAttribute(LPSTR,WORD);
WORD API LFNCopy(LPSTR,LPSTR,PQUERYPROC);
WORD API LFNMove(LPSTR,LPSTR);
WORD API LFNDelete(LPSTR);
WORD API LFNMKDir(LPSTR);
WORD API LFNRMDir(LPSTR);
WORD API LFNGetVolumeLabel(WORD,LPSTR);
WORD API LFNSetVolumeLabel(WORD,LPSTR);
WORD API LFNParse(LPSTR,LPSTR,LPSTR);
WORD API LFNVolumeType(WORD,LPINT);

/* return values from LFNParse
 */
#define FILE_83_CI              0
#define FILE_83_CS              1
#define FILE_LONG               2

/* volumes types from LFNVolumeType
 */
#define VOLUME_STANDARD         0
#define VOLUME_LONGNAMES        1

// will add others later, == DOS int 21h error codes.

// this error code causes a call to WNetGetError, WNetGetErrorText
// to get the error text.
#define ERROR_NETWORKSPECIFIC   0xFFFF

#endif

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif   /* __cplusplus */

#endif  /* _INC_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\windowsx.h ===
/*****************************************************************************\
*                                                                             *
* windowsx.h -  Macro APIs, window message crackers, and control APIs         *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_WINDOWSX
#define _INC_WINDOWSX

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****** KERNEL Macro APIs ****************************************************/

#define     GetInstanceModule(hInstance) \
                GetModuleHandle((LPCSTR)MAKELP(0, hInstance))

#define     GlobalPtrHandle(lp)         \
                ((HGLOBAL)LOWORD(GlobalHandle(SELECTOROF(lp))))

#define     GlobalLockPtr(lp)		\
                ((BOOL)SELECTOROF(GlobalLock(GlobalPtrHandle(lp))))
#define     GlobalUnlockPtr(lp) 	\
                GlobalUnlock(GlobalPtrHandle(lp))

#define     GlobalAllocPtr(flags, cb)	\
                (GlobalLock(GlobalAlloc((flags), (cb))))
#define     GlobalReAllocPtr(lp, cbNew, flags)	\
                (GlobalUnlockPtr(lp), GlobalLock(GlobalReAlloc(GlobalPtrHandle(lp) , (cbNew), (flags))))
#define     GlobalFreePtr(lp)		\
                (GlobalUnlockPtr(lp), (BOOL)GlobalFree(GlobalPtrHandle(lp)))

/****** GDI Macro APIs *******************************************************/

#define     DeletePen(hpen)	    DeleteObject((HGDIOBJ)(HPEN)(hpen))
#define     SelectPen(hdc, hpen)    ((HPEN)SelectObject((hdc), (HGDIOBJ)(HPEN)(hpen)))
#define     GetStockPen(i)	    ((HPEN)GetStockObject(i))

#define     DeleteBrush(hbr)	    DeleteObject((HGDIOBJ)(HBRUSH)(hbr))
#define     SelectBrush(hdc, hbr)   ((HBRUSH)SelectObject((hdc), (HGDIOBJ)(HBRUSH)(hbr)))
#define     GetStockBrush(i)	    ((HBRUSH)GetStockObject(i))

#define     DeleteRgn(hrgn)	    DeleteObject((HGDIOBJ)(HRGN)(hrgn))

#define     CopyRgn(hrgnDst, hrgnSrc)               CombineRgn(hrgnDst, hrgnSrc, 0, RGN_COPY)
#define     IntersectRgn(hrgnResult, hrgnA, hrgnB)  CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_AND)
#define     SubtractRgn(hrgnResult, hrgnA, hrgnB)   CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_DIFF)
#define     UnionRgn(hrgnResult, hrgnA, hrgnB)      CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_OR)
#define     XorRgn(hrgnResult, hrgnA, hrgnB)        CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_XOR)

#define     DeletePalette(hpal)     DeleteObject((HGDIOBJ)(HPALETTE)(hpal))

#define     DeleteFont(hfont)	    DeleteObject((HGDIOBJ)(HFONT)(hfont))
#define     SelectFont(hdc, hfont)  ((HFONT)SelectObject((hdc), (HGDIOBJ)(HFONT)(hfont)))
#define     GetStockFont(i)	    ((HFONT)GetStockObject(i))

#define     DeleteBitmap(hbm)       DeleteObject((HGDIOBJ)(HBITMAP)(hbm))
#define     SelectBitmap(hdc, hbm)  ((HBITMAP)SelectObject((hdc), (HGDIOBJ)(HBITMAP)(hbm)))

#define     InsetRect(lprc, dx, dy) InflateRect((lprc), -(dx), -(dy))

/****** USER Macro APIs ******************************************************/

#define     GetWindowInstance(hwnd) ((HINSTANCE)GetWindowWord(hwnd, GWW_HINSTANCE))

#define     GetWindowStyle(hwnd)    ((DWORD)GetWindowLong(hwnd, GWL_STYLE))
#define     GetWindowExStyle(hwnd)  ((DWORD)GetWindowLong(hwnd, GWL_EXSTYLE))

#define     GetWindowOwner(hwnd)    GetWindow(hwnd, GW_OWNER)

#define     GetFirstChild(hwnd)     GetTopWindow(hwnd)
#define     GetFirstSibling(hwnd)   GetWindow(hwnd, GW_HWNDFIRST)
#define     GetLastSibling(hwnd)    GetWindow(hwnd, GW_HWNDLAST)
#define     GetNextSibling(hwnd)    GetWindow(hwnd, GW_HWNDNEXT)
#define     GetPrevSibling(hwnd)    GetWindow(hwnd, GW_HWNDPREV)

#define     GetWindowID(hwnd)	    GetDlgCtrlID(hwnd)

#define     SetWindowRedraw(hwnd, fRedraw)  \
                    ((void)SendMessage(hwnd, WM_SETREDRAW, (WPARAM)(BOOL)(fRedraw), 0L))

#define     SubclassWindow(hwnd, lpfn)	\
		((WNDPROC)SetWindowLong((hwnd), GWL_WNDPROC, (LPARAM)(WNDPROC)(lpfn)))

#define     IsMinimized(hwnd)	IsIconic(hwnd)
#define     IsMaximized(hwnd)	IsZoomed(hwnd)
#define     IsRestored(hwnd)    ((GetWindowStyle(hwnd) & (WS_MINIMIZE | WS_MAXIMIZE)) == 0L)

#define     SetWindowFont(hwnd, hfont, fRedraw) FORWARD_WM_SETFONT((hwnd), (hfont), (fRedraw), SendMessage)

#define     GetWindowFont(hwnd)                 FORWARD_WM_GETFONT((hwnd), SendMessage)

#if (WINVER >= 0x030a)
#define     MapWindowRect(hwndFrom, hwndTo, lprc) \
                    MapWindowPoints((hwndFrom), (hwndTo), (POINT FAR*)(lprc), 2)
#endif  /* WINVER >= 0x030a */

#define     IsLButtonDown()	(GetKeyState(VK_LBUTTON) < 0)
#define     IsRButtonDown()	(GetKeyState(VK_RBUTTON) < 0)
#define     IsMButtonDown()	(GetKeyState(VK_MBUTTON) < 0)

#define     SubclassDialog(hwndDlg, lpfn) \
		((DLGPROC)SetWindowLong(hwndDlg, DWL_DLGPROC, (LPARAM)(DLGPROC)(lpfn)))

#define     SetDlgMsgResult(hwnd, msg, result)	 \
    (((msg) == WM_CTLCOLOR || (msg) == WM_COMPAREITEM || (msg) == WM_VKEYTOITEM ||  \
    (msg) == WM_CHARTOITEM || (msg) == WM_QUERYDRAGICON || (msg) == WM_INITDIALOG)  \
    ? (BOOL)LOWORD(result) : (SetWindowLong((hwnd), DWL_MSGRESULT, (LPARAM)(LRESULT)(result)), TRUE))

#define     DefDlgProcEx(hwnd, msg, wParam, lParam, pfRecursion) \
    (*(pfRecursion) = TRUE, DefDlgProc(hwnd, msg, wParam, lParam))

#define     CheckDefDlgRecursion(pfRecursion) \
    if (*(pfRecursion)) { *(pfRecursion) = FALSE; return FALSE; }

/****** Message crackers ****************************************************/

#define HANDLE_MSG(hwnd, message, fn)    \
    case (message): return HANDLE_##message((hwnd), (wParam), (lParam), (fn))

/* void Cls_OnCompacting(HWND hwnd, UINT compactRatio); */
#define HANDLE_WM_COMPACTING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_COMPACTING(hwnd, compactRatio, fn) \
    (void)(fn)((hwnd), WM_COMPACTING, (WPARAM)(UINT)(compactRatio), 0L)

/* void Cls_OnWinIniChange(HWND hwnd, LPCSTR lpszSectionName); */
#define HANDLE_WM_WININICHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_WININICHANGE(hwnd, lpszSectionName, fn) \
    (void)(fn)((hwnd), WM_WININICHANGE, 0, (LPARAM)(LPCSTR)(lpszSectionName))

/* void Cls_OnSysColorChange(HWND hwnd); */
#define HANDLE_WM_SYSCOLORCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_SYSCOLORCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_SYSCOLORCHANGE, 0, 0L)

/* BOOL Cls_OnQueryNewPalette(HWND hwnd); */
#define HANDLE_WM_QUERYNEWPALETTE(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYNEWPALETTE(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYNEWPALETTE, 0, 0L)

/* void Cls_OnPaletteIsChanging(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTEISCHANGING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTEISCHANGING(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTEISCHANGING, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTECHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTECHANGED(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTECHANGED, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnFontChange(HWND hwnd); */
#define HANDLE_WM_FONTCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_FONTCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_FONTCHANGE, 0, 0L)

/* void Cls_OnSpoolerStatus(HWND hwnd, UINT status, int cJobInQueue); */
#define HANDLE_WM_SPOOLERSTATUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SPOOLERSTATUS(hwnd, status, cJobInQueue, fn) \
    (void)(fn)((hwnd), WM_SPOOLERSTATUS, (WPARAM)(status), MAKELPARAM((UINT)(cJobInQueue), 0))

/* void Cls_OnDevModeChange(HWND hwnd, LPCSTR lpszDeviceName); */
#define HANDLE_WM_DEVMODECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_DEVMODECHANGE(hwnd, lpszDeviceName, fn) \
    (void)(fn)((hwnd), WM_DEVMODECHANGE, 0,(LPARAM)(LPCSTR)(lpszDeviceName))

/* void Cls_OnTimeChange(HWND hwnd); */
#define HANDLE_WM_TIMECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_TIMECHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_TIMECHANGE, 0, 0L)

/* void Cls_OnPower(HWND hwnd, int code); */
#define HANDLE_WM_POWER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_POWER(hwnd, code, fn) \
    (void)(fn)((hwnd), WM_POWER, (WPARAM)(code), 0L)

/* BOOL Cls_OnQueryEndSession(HWND hwnd); */
#define HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYENDSESSION(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYENDSESSION, 0, 0L)

/* void Cls_OnEndSession(HWND hwnd, BOOL fEnding); */
#define HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENDSESSION(hwnd, fEnding, fn) \
    (void)(fn)((hwnd), WM_ENDSESSION, (WPARAM)(BOOL)(fEnding), 0L)

/* void Cls_OnQuit(HWND hwnd, int exitCode); */
#define HANDLE_WM_QUIT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_QUIT(hwnd, exitCode, fn) \
    (void)(fn)((hwnd), WM_QUIT, (WPARAM)(exitCode), 0L)

/* void Cls_OnSystemError(HWND hwnd, int errCode); */
#define HANDLE_WM_SYSTEMERROR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_SYSTEMERROR(hwnd, errCode, fn) \
    (void)(fn)((hwnd), WM_SYSTEMERROR, (WPARAM)(errCode), 0L)

/* BOOL Cls_OnCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_CREATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (CREATESTRUCT FAR*)(lParam)) ? 0L : (LRESULT)-1L)
#define FORWARD_WM_CREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_CREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* BOOL Cls_OnNCCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_NCCREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (CREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_NCCREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCCREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* void Cls_OnDestroy(HWND hwnd); */
#define HANDLE_WM_DESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROY, 0, 0L)

/* void Cls_OnNCDestroy(HWND hwnd); */
#define HANDLE_WM_NCDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_NCDESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_NCDESTROY, 0, 0L)

/* void Cls_OnShowWindow(HWND hwnd, BOOL fShow, UINT status); */
#define HANDLE_WM_SHOWWINDOW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_SHOWWINDOW(hwnd, fShow, status, fn) \
    (void)(fn)((hwnd), WM_SHOWWINDOW, (WPARAM)(BOOL)(fShow), MAKELPARAM((UINT)(status), 0))

/* void Cls_OnSetRedraw(HWND hwnd, BOOL fRedraw); */
#define HANDLE_WM_SETREDRAW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_SETREDRAW(hwnd, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETREDRAW, (WPARAM)(fRedraw), 0L)

/* void Cls_OnEnable(HWND hwnd, BOOL fEnable); */
#define HANDLE_WM_ENABLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENABLE(hwnd, fEnable, fn) \
    (void)(fn)((hwnd), WM_ENABLE, (WPARAM)(BOOL)(fEnable), 0L)

/* void Cls_OnSetText(HWND hwnd, LPCSTR lpszText); */
#define HANDLE_WM_SETTEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_SETTEXT(hwnd, lpszText, fn) \
    (void)(fn)((hwnd), WM_SETTEXT, 0, (LPARAM)(LPCSTR)(lpszText))

/* INT Cls_OnGetText(HWND hwnd, int cchTextMax, LPSTR lpszText) */
#define HANDLE_WM_GETTEXT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (int)(wParam), (LPSTR)(lParam))
#define FORWARD_WM_GETTEXT(hwnd, cchTextMax, lpszText, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXT, (WPARAM)(int)(cchTextMax), (LPARAM)(LPSTR)(lpszText))

/* INT Cls_OnGetTextLength(HWND hwnd); */
#define HANDLE_WM_GETTEXTLENGTH(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)(hwnd)
#define FORWARD_WM_GETTEXTLENGTH(hwnd, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXTLENGTH, 0, 0L)

/* BOOL Cls_OnWindowPosChanging(HWND hwnd, WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGING(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (WINDOWPOS FAR*)(lParam))
#define FORWARD_WM_WINDOWPOSCHANGING(hwnd, lpwpos, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_WINDOWPOSCHANGING, 0, (LPARAM)(WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnWindowPosChanged(HWND hwnd, const WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const WINDOWPOS FAR*)(lParam)), 0L)
#define FORWARD_WM_WINDOWPOSCHANGED(hwnd, lpwpos, fn) \
    (void)(fn)((hwnd), WM_WINDOWPOSCHANGED, 0, (LPARAM)(const WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnMove(HWND hwnd, int x, int y); */
#define HANDLE_WM_MOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_MOVE(hwnd, x, y, fn) \
    (void)(fn)((hwnd), WM_MOVE, 0, MAKELPARAM((int)(x), (int)(y)))

/* void Cls_OnSize(HWND hwnd, UINT state, int cx, int cy); */
#define HANDLE_WM_SIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SIZE(hwnd, state, cx, cy, fn) \
    (void)(fn)((hwnd), WM_SIZE, (WPARAM)(UINT)(state), MAKELPARAM((int)(cx), (int)(cy)))

/* void Cls_OnClose(HWND hwnd); */
#define HANDLE_WM_CLOSE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLOSE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLOSE, 0, 0L)

/* BOOL Cls_OnQueryOpen(HWND hwnd); */
#define HANDLE_WM_QUERYOPEN(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYOPEN(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYOPEN, 0, 0L)

/* void Cls_OnGetMinMaxInfo(HWND hwnd, MINMAXINFO FAR* lpMinMaxInfo); */
#define HANDLE_WM_GETMINMAXINFO(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MINMAXINFO FAR*)(lParam)), 0L)
#define FORWARD_WM_GETMINMAXINFO(hwnd, lpMinMaxInfo, fn) \
    (void)(fn)((hwnd), WM_GETMINMAXINFO, 0, (LPARAM)(MINMAXINFO FAR*)(lpMinMaxInfo))

/* void Cls_OnPaint(HWND hwnd); */
#define HANDLE_WM_PAINT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PAINT(hwnd, fn) \
    (void)(fn)((hwnd), WM_PAINT, 0, 0L)

/* BOOL Cls_OnEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ERASEBKGND(hwnd, hdc, fn) \
   (BOOL)(DWORD)(fn)((hwnd), WM_ERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* BOOL Cls_OnIconEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ICONERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ICONERASEBKGND(hwnd, hdc, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_ICONERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* void Cls_OnNCPaint(HWND hwnd, HRGN hrgn); */
#define HANDLE_WM_NCPAINT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HRGN)(wParam)), 0L)
#define FORWARD_WM_NCPAINT(hwnd, hrgn, fn) \
    (void)(fn)((hwnd), WM_NCPAINT, (WPARAM)(HRGN)(hrgn), 0L)

/* UINT Cls_OnNCCalcSize(HWND hwnd, BOOL fCalcValidRects, NCCALCSIZE_PARAMS FAR* lpcsp) */
#define HANDLE_WM_NCCALCSIZE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (NCCALCSIZE_PARAMS FAR*)(lParam))
#define FORWARD_WM_NCCALCSIZE(hwnd, fCalcValidRects, lpcsp, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCCALCSIZE, (WPARAM)(fCalcValidRects), (LPARAM)(NCCALCSIZE_PARAMS FAR*)(lpcsp))

/* UINT Cls_OnNCHitTest(HWND hwnd, int x, int y); */
#define HANDLE_WM_NCHITTEST(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_NCHITTEST(hwnd, x, y, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCHITTEST, 0, MAKELPARAM((int)(x), (int)(y)))

/* HICON Cls_OnQueryDragIcon(HWND hwnd); */
#define HANDLE_WM_QUERYDRAGICON(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_QUERYDRAGICON(hwnd, fn) \
    (HICON)(UINT)(DWORD)(fn)((hwnd), WM_QUERYDRAGICON, 0, 0L)

#ifdef _INC_SHELLAPI
/* void Cls_OnDropFiles(HWND hwnd, HDROP hdrop); */
#define HANDLE_WM_DROPFILES(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HDROP)(wParam)), 0L)
#define FORWARD_WM_DROPFILES(hwnd, hdrop, fn) \
    (void)(fn)((hwnd), WM_DROPFILES, (WPARAM)(hdrop), 0L)
#endif  /* _INC_SHELLAPI */

/* void Cls_OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_ACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATE(hwnd, state, hwndActDeact, fMinimized, fn) \
    (void)(fn)((hwnd), WM_ACTIVATE, (WPARAM)(UINT)(state), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnActivateApp(HWND hwnd, BOOL fActivate, HTASK htaskActDeact); */
#define HANDLE_WM_ACTIVATEAPP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HTASK)LOWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATEAPP(hwnd, fActivate, htaskActDeact, fn) \
    (void)(fn)((hwnd), WM_ACTIVATEAPP, (WPARAM)(BOOL)(fActivate), MAKELPARAM((htaskActDeact),0))

/* BOOL Cls_OnNCActivate(HWND hwnd, BOOL fActive, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_NCACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam))
#define FORWARD_WM_NCACTIVATE(hwnd, fActive, hwndActDeact, fMinimized, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCACTIVATE, (WPARAM)(BOOL)(fActive), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnSetFocus(HWND hwnd, HWND hwndOldFocus) */
#define HANDLE_WM_SETFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_SETFOCUS(hwnd, hwndOldFocus, fn) \
    (void)(fn)((hwnd), WM_SETFOCUS, (WPARAM)(HWND)(hwndOldFocus), 0L)

/* void Cls_OnKillFocus(HWND hwnd, HWND hwndNewFocus); */
#define HANDLE_WM_KILLFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_KILLFOCUS(hwnd, hwndNewFocus, fn) \
    (void)(fn)((hwnd), WM_KILLFOCUS, (WPARAM)(HWND)(hwndNewFocus), 0L)

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_CHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_CHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_DEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_DEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_DEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnSysDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSDEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSDEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSDEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MOUSEMOVE(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MOUSEMOVE, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_LBUTTONDBLCLK : WM_LBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_LBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_RBUTTONDBLCLK : WM_RBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnRButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_RBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_RBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_MBUTTONDBLCLK : WM_MBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnMButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_MBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnNCMouseMove(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMOUSEMOVE(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMOUSEMOVE, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCLBUTTONDBLCLK : WM_NCLBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCLButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCLBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCRBUTTONDBLCLK : WM_NCRBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCRButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCRBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCMBUTTONDBLCLK : WM_NCMBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCMButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* int Cls_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_MOUSEACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam))
#define FORWARD_WM_MOUSEACTIVATE(hwnd, hwndTopLevel, codeHitTest, msg, fn) \
    (int)(DWORD)(fn)((hwnd), WM_MOUSEACTIVATE, (WPARAM)(HWND)(hwndTopLevel), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnCancelMode(HWND hwnd); */
#define HANDLE_WM_CANCELMODE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CANCELMODE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CANCELMODE, 0, 0L)

/* void Cls_OnTimer(HWND hwnd, UINT id); */
#define HANDLE_WM_TIMER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_TIMER(hwnd, id, fn) \
    (void)(fn)((hwnd), WM_TIMER, (WPARAM)(UINT)(id), 0L)

/* void Cls_OnInitMenu(HWND hwnd, HMENU hMenu); */
#define HANDLE_WM_INITMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam)), 0L)
#define FORWARD_WM_INITMENU(hwnd, hMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENU, (WPARAM)(HMENU)(hMenu), 0L)

/* void Cls_OnInitMenuPopup(HWND hwnd, HMENU hMenu, int item, BOOL fSystemMenu); */
#define HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam), (int)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_INITMENUPOPUP(hwnd, hMenu, item, fSystemMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENUPOPUP, (WPARAM)(HMENU)(hMenu), MAKELPARAM((item),(fSystemMenu)))

/* void Cls_OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags); */
#define HANDLE_WM_MENUSELECT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)HIWORD(lParam), (LOWORD(lParam) & MF_POPUP) ? 0 : (int)(wParam), \
                            (LOWORD(lParam) & MF_POPUP) ? (HMENU)(wParam) : 0, LOWORD(lParam)), 0L)
#define FORWARD_WM_MENUSELECT(hwnd, hmenu, item, hmenuPopup, flags, fn) \
    (void)(fn)((hwnd), WM_MENUSELECT, ((flags) & MF_POPUP) ? (WPARAM)(HMENU)(hmenuPopup) : (WPARAM)(int)(item), MAKELPARAM((flags), (hmenu)))

/* DWORD Cls_OnMenuChar(HWND hwnd, UINT ch, UINT flags, HMENU hmenu); */
#define HANDLE_WM_MENUCHAR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam), LOWORD(lParam), (HMENU)HIWORD(lParam));
#define FORWARD_WM_MENUCHAR(hwnd, ch, flags, hmenu, fn) \
    (DWORD)(fn)((hwnd), WM_MENUCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((flags), (UINT)(hmenu)))

/* void Cls_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify); */
#define HANDLE_WM_COMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
    (void)(fn)((hwnd), WM_COMMAND, (WPARAM)(int)(id), MAKELPARAM((UINT)(hwndCtl), (codeNotify)))

/* void Cls_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_HSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_VSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam),  (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnCut(HWND hwnd); */
#define HANDLE_WM_CUT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CUT(hwnd, fn) \
    (void)(fn)((hwnd), WM_CUT, 0, 0L)

/* void Cls_OnCopy(HWND hwnd); */
#define HANDLE_WM_COPY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_COPY(hwnd, fn) \
    (void)(fn)((hwnd), WM_COPY, 0, 0L)

/* void Cls_OnPaste(HWND hwnd); */
#define HANDLE_WM_PASTE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PASTE(hwnd, fn) \
    (void)(fn)((hwnd), WM_PASTE, 0, 0L)

/* void Cls_OnClear(HWND hwnd); */
#define HANDLE_WM_CLEAR(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLEAR(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLEAR, 0, 0L)

/* void Cls_OnUndo(HWND hwnd); */
#define HANDLE_WM_UNDO(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_UNDO(hwnd, fn) \
    (void)(fn)((hwnd), WM_UNDO, 0, 0L)

/* HANDLE Cls_OnRenderFormat(HWND hwnd, UINT fmt); */
#define HANDLE_WM_RENDERFORMAT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HANDLE)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_RENDERFORMAT(hwnd, fmt, fn) \
    (HANDLE)(UINT)(DWORD)(fn)((hwnd), WM_RENDERFORMAT, (WPARAM)(UINT)(fmt), 0L)

/* void Cls_OnRenderAllFormats(HWND hwnd); */
#define HANDLE_WM_RENDERALLFORMATS(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_RENDERALLFORMATS(hwnd, fn) \
    (void)(fn)((hwnd), WM_RENDERALLFORMATS, 0, 0L)

/* void Cls_OnDestroyClipboard(HWND hwnd); */
#define HANDLE_WM_DESTROYCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROYCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROYCLIPBOARD, 0, 0L)

/* void Cls_OnDrawClipboard(HWND hwnd); */
#define HANDLE_WM_DRAWCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DRAWCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DRAWCLIPBOARD, 0, 0L)

/* void Cls_OnPaintClipboard(HWND hwnd, HWND hwndCBViewer, const PAINTSTRUCT FAR* lpPaintStruct) */
#define HANDLE_WM_PAINTCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const PAINTSTRUCT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_PAINTCLIPBOARD(hwnd, hwndCBViewer, lpPaintStruct, fn) \
    (void)(fn)((hwnd), WM_PAINTCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(lpPaintStruct))

/* void Cls_OnSizeClipboard(HWND hwnd, HWND hwndCBViewer, const RECT FAR* lprc); */
#define HANDLE_WM_SIZECLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const RECT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SIZECLIPBOARD(hwnd, hwndCBViewer, lprc, fn) \
    (void)(fn)((hwnd), WM_SIZECLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(lprc))

/* void Cls_OnVScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_VSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnHScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_HSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnAskCBFormatName(HWND hwnd, int cchMax, LPSTR rgchName); */
#define HANDLE_WM_ASKCBFORMATNAME(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (LPSTR)(lParam)), 0L)
#define FORWARD_WM_ASKCBFORMATNAME(hwnd, cchMax, rgchName, fn) \
    (void)(fn)((hwnd), WM_ASKCBFORMATNAME, (WPARAM)(int)(cchMax), (LPARAM)(rgchName))

/* void Cls_OnChangeCBChain(HWND hwnd, HWND hwndRemove, HWND hwndNext); */
#define HANDLE_WM_CHANGECBCHAIN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHANGECBCHAIN(hwnd, hwndRemove, hwndNext, fn) \
    (void)(fn)((hwnd), WM_CHANGECBCHAIN, (WPARAM)(HWND)(hwndRemove), MAKELPARAM((UINT)(hwndNext), 0))

/* BOOL Cls_OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_SETCURSOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam));
#define FORWARD_WM_SETCURSOR(hwnd, hwndCursor, codeHitTest, msg, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_SETCURSOR, (WPARAM)(HWND)(hwndCursor), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnSysCommand(HWND hwnd, UINT cmd, int x, int y); */
#define HANDLE_WM_SYSCOMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSCOMMAND(hwnd, cmd, x, y, fn) \
    (void)(fn)((hwnd), WM_SYSCOMMAND, (WPARAM)(UINT)(cmd), MAKELPARAM((x), (y)))

/* HWND Cls_MDICreate(HWND hwnd, const MDICREATESTRUCT FAR* lpmcs); */
#define HANDLE_WM_MDICREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (MDICREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_MDICREATE(hwnd, lpmcs, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDICREATE, 0, (LPARAM)(lpmcs))

/* void Cls_MDIDestroy(HWND hwnd, HWND hwndDestroy); */
#define HANDLE_WM_MDIDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIDESTROY(hwnd, hwndDestroy, fn) \
    (void)(fn)((hwnd), WM_MDIDESTROY, (WPARAM)(hwndDestroy), 0L)

/* NOTE: Usable only by MDI client windows */
/* void Cls_MDIActivate(HWND hwnd, BOOL fActive, HWND hwndActivate, HWND hwndDeactivate); */
#define HANDLE_WM_MDIACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (HWND)HIWORD(lParam)), 0L)
#define FORWARD_WM_MDIACTIVATE(hwnd, fActive, hwndActivate, hwndDeactivate, fn) \
    (void)(fn)(hwnd, WM_MDIACTIVATE, (WPARAM)(fActive), MAKELPARAM((hwndActivate), (hwndDeactivate)))

/* void Cls_MDIRestore(HWND hwnd, HWND hwndRestore); */
#define HANDLE_WM_MDIRESTORE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIRESTORE(hwnd, hwndRestore, fn) \
    (void)(fn)((hwnd), WM_MDIRESTORE, (WPARAM)(hwndRestore), 0L)

/* HWND Cls_MDINext(HWND hwnd, HWND hwndCur, BOOL fPrev); */
#define HANDLE_WM_MDINEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_MDINEXT(hwnd, hwndCur, fPrev, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDINEXT, (WPARAM)(hwndCur), MAKELPARAM((fPrev), 0))

/* void Cls_MDIMaximize(HWND hwnd, HWND hwndMaximize); */
#define HANDLE_WM_MDIMAXIMIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIMAXIMIZE(hwnd, hwndMaximize, fn) \
    (void)(fn)((hwnd), WM_MDIMAXIMIZE, (WPARAM)(hwndMaximize), 0L)

/* BOOL Cls_MDITile(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDITILE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDITILE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDITILE, (WPARAM)(cmd), 0L)

/* BOOL Cls_MDICascade(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDICASCADE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDICASCADE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDICASCADE, (WPARAM)(cmd), 0L)

/* void Cls_MDIIconArrange(HWND hwnd); */
#define HANDLE_WM_MDIICONARRANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_MDIICONARRANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_MDIICONARRANGE, 0, 0L)

/* HWND Cls_MDIGetActive(HWND hwnd); */
#define HANDLE_WM_MDIGETACTIVE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_MDIGETACTIVE(hwnd, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDIGETACTIVE, 0, 0L)

/* HMENU Cls_MDISetMenu(HWND hwnd, BOOL fRefresh, HMENU hmenuFrame, HMENU hmenuWindow); */
#define HANDLE_WM_MDISETMENU(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (HMENU)LOWORD(lParam), (HMENU)HIWORD(lParam))
#define FORWARD_WM_MDISETMENU(hwnd, fRefresh, hmenuFrame, hmenuWindow, fn) \
    (HMENU)(UINT)(DWORD)(fn)((hwnd), WM_MDISETMENU, (WPARAM)(fRefresh), MAKELPARAM((hmenuFrame), (hmenuWindow)))

/* void Cls_OnChildActivate(HWND hwnd); */
#define HANDLE_WM_CHILDACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CHILDACTIVATE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CHILDACTIVATE, 0, 0L)

/* BOOL Cls_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam); */
#define HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(BOOL)(fn)((hwnd), (HWND)(wParam), lParam);
#define FORWARD_WM_INITDIALOG(hwnd, hwndFocus, lParam, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_INITDIALOG, (WPARAM)(HWND)(hwndFocus), (lParam))

/* HWND Cls_OnNextDlgCtl(HWND hwnd, HWND hwndSetFocus, BOOL fNext) */
#define HANDLE_WM_NEXTDLGCTL(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HWND)(fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam))
#define FORWARD_WM_NEXTDLGCTL(hwnd, hwndSetFocus, fNext, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_NEXTDLGCTL, (WPARAM)(HWND)(hwndSetFocus), MAKELPARAM((fNext), 0))

/* void Cls_OnParentNotify(HWND hwnd, UINT msg, HWND hwndChild, int idChild); */
#define HANDLE_WM_PARENTNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_PARENTNOTIFY(hwnd, msg, hwndChild, idChild, fn) \
    (void)(fn)((hwnd), WM_PARENTNOTIFY, (WPARAM)(UINT)(msg), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(idChild)))

/* void Cls_OnEnterIdle(HWND hwnd, UINT source, HWND hwndSource); */
#define HANDLE_WM_ENTERIDLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_ENTERIDLE(hwnd, source, hwndSource, fn) \
    (void)(fn)((hwnd), WM_ENTERIDLE, (WPARAM)(UINT)(source), MAKELPARAM((UINT)(HWND)(hwndSource), 0))

/* UINT Cls_OnGetDlgCode(HWND hwnd, MSG FAR* lpmsg); */
#define HANDLE_WM_GETDLGCODE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd, (MSG FAR*)(lParam))
#define FORWARD_WM_GETDLGCODE(hwnd, lpmsg, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_GETDLGCODE, (SELECTOROF(lpmsg) ? lpmsg->wParam : 0), (LPARAM)(lpmsg))

/* HBRUSH Cls_OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type); */
#define HANDLE_WM_CTLCOLOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)LOWORD(lParam), (int)(HIWORD(lParam)))
#define FORWARD_WM_CTLCOLOR(hwnd, hdc, hwndChild, type, fn) \
    (HBRUSH)(UINT)(DWORD)(fn)((hwnd), WM_CTLCOLOR, (WPARAM)(HDC)(hdc), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(int)(type)))

/* void Cls_OnSetFont(HWND hwndCtl, HFONT hfont, BOOL fRedraw); */
#define HANDLE_WM_SETFONT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HFONT)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SETFONT(hwnd, hfont, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETFONT, (WPARAM)(HFONT)(hfont), MAKELPARAM((UINT)(BOOL)(fRedraw), 0))

/* HFONT Cls_OnGetFont(HWND hwnd); */
#define HANDLE_WM_GETFONT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HFONT)(fn)(hwnd)
#define FORWARD_WM_GETFONT(hwnd, fn) \
    (HFONT)(UINT)(DWORD)(fn)((hwnd), WM_GETFONT, 0, 0L)

/* void Cls_OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT FAR* lpDrawItem); */
#define HANDLE_WM_DRAWITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DRAWITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DRAWITEM(hwnd, lpDrawItem, fn) \
    (void)(fn)((hwnd), WM_DRAWITEM, 0, (LPARAM)(const DRAWITEMSTRUCT FAR*)(lpDrawItem))

/* void Cls_OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR* lpMeasureItem); */
#define HANDLE_WM_MEASUREITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MEASUREITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_MEASUREITEM(hwnd, lpMeasureItem, fn) \
    (void)(fn)((hwnd), WM_MEASUREITEM, 0, (LPARAM)(MEASUREITEMSTRUCT FAR*)(lpMeasureItem))

/* void Cls_OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT FAR* lpDeleteItem) */
#define HANDLE_WM_DELETEITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DELETEITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DELETEITEM(hwnd, lpDeleteItem, fn) \
    (void)(fn)((hwnd), WM_DELETEITEM, 0, (LPARAM)(const DELETEITEMSTRUCT FAR*)(lpDeleteItem))

/* int Cls_OnCompareItem(HWND hwnd, const COMPAREITEMSTRUCT FAR* lpCompareItem); */
#define HANDLE_WM_COMPAREITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (const COMPAREITEMSTRUCT FAR*)(lParam))
#define FORWARD_WM_COMPAREITEM(hwnd, lpCompareItem, fn) \
    (int)(DWORD)(fn)((hwnd), WM_COMPAREITEM, 0, (LPARAM)(const COMPAREITEMSTRUCT FAR*)(lpCompareItem))

/* int Cls_OnVkeyToItem(HWND hwnd, UINT vk, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_VKEYTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_VKEYTOITEM(hwnd, vk, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_VKEYTOITEM, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* int Cls_OnCharToItem(HWND hwnd, UINT ch, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_CHARTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_CHARTOITEM(hwnd, ch, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_CHARTOITEM, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* void Cls_OnQueueSync(HWND hwnd); */
#define HANDLE_WM_QUEUESYNC(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_QUEUESYNC(hwnd, fn) \
    (void)(fn)((hwnd), WM_QUEUESYNC, 0, 0L)

/* void Cls_OnCommNotify(HWND hwnd, int cid, UINT flags); */
#define HANDLE_WM_COMMNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_COMMNOTIFY(hwnd, cid, flags, fn) \
    (void)(fn)((hwnd), WM_COMMNOTIFY, (WPARAM)(cid), MAKELPARAM((flags), 0))

/****** Static control message APIs ******************************************/

#define Static_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Static_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Static_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Static_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Static_SetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_SETICON, (WPARAM)(HICON)(hIcon), 0L))
#define Static_GetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_GETICON, 0, 0L))

/****** Button control message APIs ******************************************/

#define Button_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Button_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Button_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Button_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Button_GetCheck(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETCHECK, 0, 0L))
#define Button_SetCheck(hwndCtl, check)     ((void)SendMessage((hwndCtl), BM_SETCHECK, (WPARAM)(int)(check), 0L))

#define Button_GetState(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETSTATE, 0, 0L))
#define Button_SetState(hwndCtl, state)     ((UINT)(DWORD)SendMessage((hwndCtl), BM_SETSTATE, (WPARAM)(int)(state), 0L))

#define Button_SetStyle(hwndCtl, style, fRedraw) ((void)SendMessage((hwndCtl), BM_SETSTYLE, (WPARAM)LOWORD(style), MAKELPARAM(((fRedraw) ? TRUE : FALSE), 0)))

/****** Edit control message APIs ********************************************/

#define Edit_Enable(hwndCtl, fEnable)           EnableWindow((hwndCtl), (fEnable))

#define Edit_GetText(hwndCtl, lpch, cchMax)     GetWindowText((hwndCtl), (lpch), (cchMax))
#define Edit_GetTextLength(hwndCtl)             GetWindowTextLength(hwndCtl)
#define Edit_SetText(hwndCtl, lpsz)             SetWindowText((hwndCtl), (lpsz))

#define Edit_LimitText(hwndCtl, cchMax)         ((void)SendMessage((hwndCtl), EM_LIMITTEXT, (WPARAM)(cchMax), 0L))

#define Edit_GetLineCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINECOUNT, 0, 0L))
#define Edit_GetLine(hwndCtl, line, lpch, cchMax) ((*((int FAR*)(lpch)) = (cchMax)), ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINE, (WPARAM)(int)(line), (LPARAM)(LPSTR)(lpch))))

#define Edit_GetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_GETRECT, 0, (LPARAM)(RECT FAR*)(lprc)))
#define Edit_SetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_SETRECT, 0, (LPARAM)(const RECT FAR*)(lprc)))
#define Edit_SetRectNoPaint(hwndCtl, lprc)      ((void)SendMessage((hwndCtl), EM_SETRECTNP, 0, (LPARAM)(const RECT FAR*)(lprc)))

#define Edit_GetSel(hwndCtl)                    ((DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L))
#define Edit_SetSel(hwndCtl, ichStart, ichEnd)  ((void)SendMessage((hwndCtl), EM_SETSEL, 0, MAKELPARAM((ichStart), (ichEnd))))
#define Edit_ReplaceSel(hwndCtl, lpszReplace)   ((void)SendMessage((hwndCtl), EM_REPLACESEL, 0, (LPARAM)(LPCSTR)(lpszReplace)))

#define Edit_GetModify(hwndCtl)                 ((BOOL)(DWORD)SendMessage((hwndCtl), EM_GETMODIFY, 0, 0L))
#define Edit_SetModify(hwndCtl, fModified)      ((void)SendMessage((hwndCtl), EM_SETMODIFY, (WPARAM)(UINT)(fModified), 0L))

#define Edit_LineFromChar(hwndCtl, ich)         ((int)(DWORD)SendMessage((hwndCtl), EM_LINEFROMCHAR, (WPARAM)(int)(ich), 0L))
#define Edit_LineIndex(hwndCtl, line)           ((int)(DWORD)SendMessage((hwndCtl), EM_LINEINDEX, (WPARAM)(int)(line), 0L))
#define Edit_LineLength(hwndCtl, line)          ((int)(DWORD)SendMessage((hwndCtl), EM_LINELENGTH, (WPARAM)(int)(line), 0L))

#define Edit_Scroll(hwndCtl, dv, dh)            ((void)SendMessage((hwndCtl), EM_LINESCROLL, 0, MAKELPARAM((dv), (dh))))

#define Edit_CanUndo(hwndCtl)                   ((BOOL)(DWORD)SendMessage((hwndCtl), EM_CANUNDO, 0, 0L))
#define Edit_Undo(hwndCtl)                      ((BOOL)(DWORD)SendMessage((hwndCtl), EM_UNDO, 0, 0L))
#define Edit_EmptyUndoBuffer(hwndCtl)           ((void)SendMessage((hwndCtl), EM_EMPTYUNDOBUFFER, 0, 0L))

#define Edit_SetPasswordChar(hwndCtl, ch)       ((void)SendMessage((hwndCtl), EM_SETPASSWORDCHAR, (WPARAM)(UINT)(ch), 0L))

#define Edit_SetTabStops(hwndCtl, cTabs, lpTabs) ((void)SendMessage((hwndCtl), EM_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(const int FAR*)(lpTabs)))

#define Edit_FmtLines(hwndCtl, fAddEOL)         ((BOOL)(DWORD)SendMessage((hwndCtl), EM_FMTLINES, (WPARAM)(BOOL)(fAddEOL), 0L))

#define Edit_GetHandle(hwndCtl)                 ((HLOCAL)(UINT)(DWORD)SendMessage((hwndCtl), EM_GETHANDLE, 0, 0L))
#define Edit_SetHandle(hwndCtl, h)              ((void)SendMessage((hwndCtl), EM_SETHANDLE, (WPARAM)(UINT)(HLOCAL)(h), 0L))

#if (WINVER >= 0x030a)
#define Edit_GetFirstVisibleLine(hwndCtl)       ((int)(DWORD)SendMessage((hwndCtl), EM_GETFIRSTVISIBLELINE, 0, 0L))

#define Edit_SetReadOnly(hwndCtl, fReadOnly)    ((BOOL)(DWORD)SendMessage((hwndCtl), EM_SETREADONLY, (WPARAM)(BOOL)(fReadOnly), 0L))

#define Edit_GetPasswordChar(hwndCtl)           ((char)(DWORD)SendMessage((hwndCtl), EM_GETPASSWORDCHAR, 0, 0L))

#define Edit_SetWordBreakProc(hwndCtl, lpfnWordBreak) ((void)SendMessage((hwndCtl), EM_SETWORDBREAKPROC, 0, (LPARAM)(EDITWORDBREAKPROC)(lpfnWordBreak)))
#define Edit_GetWordBreakProc(hwndCtl)          ((EDITWORDBREAKPROC)SendMessage((hwndCtl), EM_GETWORDBREAKPROC, 0, 0L))
#endif /* WINVER >= 0x030a */

/****** ScrollBar control message APIs ***************************************/

/* NOTE: flags parameter is a collection of ESB_* values, NOT a boolean! */
#define ScrollBar_Enable(hwndCtl, flags)            EnableScrollBar((hwndCtl), SB_CTL, (flags))

#define ScrollBar_Show(hwndCtl, fShow)              ShowWindow((hwndCtl), (fShow) ? SW_SHOWNORMAL : SW_HIDE)

#define ScrollBar_SetPos(hwndCtl, pos, fRedraw)     SetScrollPos((hwndCtl), SB_CTL, (pos), (fRedraw))
#define ScrollBar_GetPos(hwndCtl)                   GetScrollPos((hwndCtl), SB_CTL)

#define ScrollBar_SetRange(hwndCtl, posMin, posMax, fRedraw)    SetScrollRange((hwndCtl), SB_CTL, (posMin), (posMax), (fRedraw))
#define ScrollBar_GetRange(hwndCtl, lpposMin, lpposMax)         GetScrollRange((hwndCtl), SB_CTL, (lpposMin), (lpposMax))

/****** ListBox control message APIs *****************************************/

#define ListBox_Enable(hwndCtl, fEnable)            EnableWindow((hwndCtl), (fEnable))

#define ListBox_GetCount(hwndCtl)                   ((int)(DWORD)SendMessage((hwndCtl), LB_GETCOUNT, 0, 0L))
#define ListBox_ResetContent(hwndCtl)               ((BOOL)(DWORD)SendMessage((hwndCtl), LB_RESETCONTENT, 0, 0L))

#define ListBox_AddString(hwndCtl, lpsz)            ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ListBox_InsertString(hwndCtl, index, lpsz)  ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ListBox_AddItemData(hwndCtl, data)          ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(data)))
#define ListBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_DeleteString(hwndCtl, index)        ((int)(DWORD)SendMessage((hwndCtl), LB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ListBox_GetTextLen(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXTLEN, (WPARAM)(int)(index), 0L))
#define ListBox_GetText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ListBox_GetItemData(hwndCtl, index)         ((LRESULT)(DWORD)SendMessage((hwndCtl), LB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ListBox_SetItemData(hwndCtl, index, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_FindString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_FindItemData(hwndCtl, indexStart, data) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_SetSel(hwndCtl, fSelect, index)     ((int)(DWORD)SendMessage((hwndCtl), LB_SETSEL, (WPARAM)(BOOL)(fSelect), MAKELPARAM((index), 0)))
#define ListBox_SelItemRange(hwndCtl, fSelect, first, last)    ((int)(DWORD)SendMessage((hwndCtl), LB_SELITEMRANGE, (WPARAM)(BOOL)(fSelect), MAKELPARAM((first), (last))))

#define ListBox_GetCurSel(hwndCtl)                  ((int)(DWORD)SendMessage((hwndCtl), LB_GETCURSEL, 0, 0L))
#define ListBox_SetCurSel(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), LB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ListBox_SelectString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_SelectItemData(hwndCtl, indexStart, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_GetSel(hwndCtl, index)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETSEL, (WPARAM)(int)(index), 0L))
#define ListBox_GetSelCount(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELCOUNT, 0, 0L))
#define ListBox_GetTopIndex(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETTOPINDEX, 0, 0L))
#define ListBox_GetSelItems(hwndCtl, cItems, lpItems) ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELITEMS, (WPARAM)(int)(cItems), (LPARAM)(int FAR*)(lpItems)))

#define ListBox_SetTopIndex(hwndCtl, indexTop)      ((int)(DWORD)SendMessage((hwndCtl), LB_SETTOPINDEX, (WPARAM)(int)(indexTop), 0L))

#define ListBox_SetColumnWidth(hwndCtl, cxColumn)   ((void)SendMessage((hwndCtl), LB_SETCOLUMNWIDTH, (WPARAM)(int)(cxColumn), 0L))
#define ListBox_GetHorizontalExtent(hwndCtl)        ((int)(DWORD)SendMessage((hwndCtl), LB_GETHORIZONTALEXTENT, 0, 0L))
#define ListBox_SetHorizontalExtent(hwndCtl, cxExtent)     ((void)SendMessage((hwndCtl), LB_SETHORIZONTALEXTENT, (WPARAM)(int)(cxExtent), 0L))

#define ListBox_SetTabStops(hwndCtl, cTabs, lpTabs) ((BOOL)(DWORD)SendMessage((hwndCtl), LB_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(int FAR*)(lpTabs)))

#define ListBox_GetItemRect(hwndCtl, index, lprc)   ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMRECT, (WPARAM)(int)(index), (LPARAM)(RECT FAR*)(lprc)))

#define ListBox_SetCaretIndex(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_SETCARETINDEX, (WPARAM)(int)(index), 0L))
#define ListBox_GetCaretIndex(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETCARETINDEX, 0, 0L))

#define ListBox_SetAnchorIndex(hwndCtl, index)      ((void)SendMessage((hwndCtl), LB_SETANCHORINDEX, (WPARAM)(int)(index), 0L))            /* ;Internal */
#define ListBox_GetAnchorIndex(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), LB_GETANCHORINDEX, 0, 0L))                        /* ;Internal */

#if (WINVER >= 0x030a)
#define ListBox_FindStringExact(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ListBox_SetItemHeight(hwndCtl, index, cy)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMHEIGHT, (WPARAM)(int)(index), MAKELPARAM((cy), 0)))
#define ListBox_GetItemHeight(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMHEIGHT, (WPARAM)(int)(index), 0L))
#endif  /* WINVER >= 0x030a */

#define ListBox_Dir(hwndCtl, attrs, lpszFileSpec)   ((int)(DWORD)SendMessage((hwndCtl), LB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))
#define ListBox_AddFile(hwndCtl, lpszFilename)      ((int)(DWORD)SendMessage((hwndCtl), LB_ADDFILE, 0, (LPARAM)(LPCSTR)(lpszFilename)))    /* ;Internal */

/****** ComboBox control message APIs ****************************************/

#define ComboBox_Enable(hwndCtl, fEnable)       EnableWindow((hwndCtl), (fEnable))

#define ComboBox_GetText(hwndCtl, lpch, cchMax) GetWindowText((hwndCtl), (lpch), (cchMax))
#define ComboBox_GetTextLength(hwndCtl)         GetWindowTextLength(hwndCtl)
#define ComboBox_SetText(hwndCtl, lpsz)         SetWindowText((hwndCtl), (lpsz))

#define ComboBox_LimitText(hwndCtl, cchLimit)   ((int)(DWORD)SendMessage((hwndCtl), CB_LIMITTEXT, (WPARAM)(int)(cchLimit), 0L))

#define ComboBox_GetEditSel(hwndCtl)            ((DWORD)SendMessage((hwndCtl), CB_GETEDITSEL, 0, 0L))
#define ComboBox_SetEditSel(hwndCtl, ichStart, ichEnd) ((int)(DWORD)SendMessage((hwndCtl), CB_SETEDITSEL, 0, MAKELPARAM((ichStart), (ichEnd))))

#define ComboBox_GetCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), CB_GETCOUNT, 0, 0L))
#define ComboBox_ResetContent(hwndCtl)          ((int)(DWORD)SendMessage((hwndCtl), CB_RESETCONTENT, 0, 0L))

#define ComboBox_AddString(hwndCtl, lpsz)       ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ComboBox_InsertString(hwndCtl, index, lpsz) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ComboBox_AddItemData(hwndCtl, data)     ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(data)))
#define ComboBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_DeleteString(hwndCtl, index)   ((int)(DWORD)SendMessage((hwndCtl), CB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ComboBox_GetLBTextLen(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXTLEN, (WPARAM)(int)(index), 0L))
#define ComboBox_GetLBText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ComboBox_GetItemData(hwndCtl, index)        ((LRESULT)(DWORD)SendMessage((hwndCtl), CB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ComboBox_SetItemData(hwndCtl, index, data)  ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_FindString(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ComboBox_FindItemData(hwndCtl, indexStart, data)    ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_GetCurSel(hwndCtl)                 ((int)(DWORD)SendMessage((hwndCtl), CB_GETCURSEL, 0, 0L))
#define ComboBox_SetCurSel(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), CB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ComboBox_SelectString(hwndCtl, indexStart, lpszSelect)  ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszSelect)))
#define ComboBox_SelectItemData(hwndCtl, indexStart, data)      ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_Dir(hwndCtl, attrs, lpszFileSpec)  ((int)(DWORD)SendMessage((hwndCtl), CB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))

#define ComboBox_ShowDropdown(hwndCtl, fShow)       ((BOOL)(DWORD)SendMessage((hwndCtl), CB_SHOWDROPDOWN, (WPARAM)(BOOL)(fShow), 0L))

#if (WINVER >= 0x030a)
#define ComboBox_FindStringExact(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ComboBox_GetDroppedState(hwndCtl)           ((BOOL)(DWORD)SendMessage((hwndCtl), CB_GETDROPPEDSTATE, 0, 0L))
#define ComboBox_GetDroppedControlRect(hwndCtl, lprc) ((void)SendMessage((hwndCtl), CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)(RECT FAR*)(lprc)))

#define ComboBox_GetItemHeight(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), CB_GETITEMHEIGHT, 0, 0L))
#define ComboBox_SetItemHeight(hwndCtl, cyItem)     ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMHEIGHT, (WPARAM)(int)(index), 0L))

#define ComboBox_GetExtendedUI(hwndCtl)             ((UINT)(DWORD)SendMessage((hwndCtl), CB_GETEXTENDEDUI, 0, 0L))
#define ComboBox_SetExtendedUI(hwndCtl, flags)      ((int)(DWORD)SendMessage((hwndCtl), CB_SETEXTENDEDUI, (WPARAM)(UINT)(flags), 0L))
#endif  /* WINVER >= 0x030a */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* !_INC_WINDOWSX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\windows.inc ===
;*************************************************************************
;
;       WINDOWS.INC - Windows assembly language structures & constants
;
;*************************************************************************
;
; Conditional Block includes:   (True states)
;     NOTEXT - don't include TextMetric struc & text drawing modes & stock objs.
;     NORASTOPS - don't include binary and ternary raster ops.
;     NOVK      - don't include virtual key definitions
;     NOMB      - don't include message box definitions
;     NOWM      - don't include window messages
;
;
FALSE   =       0
TRUE    =       1
NULL    =       0

;*******************************************************************
;
;       Rectangle
;
;*******************************************************************

RECT    struc
        rcLeft          dw      ?
        rcTop           dw      ?
        rcRight         dw      ?
        rcBottom        dw      ?
RECT    ends

;*******************************************************************
;
;  Window Class structure
;
;*******************************************************************

WNDCLASS struc
        clsStyle        dw      ?       ; class style
        clsLpfnWndProc  dd      ?
        clsCbClsExtra   dw      ?
        clsCbWndExtra   dw      ?
        clsHInstance    dw      ?       ; instance handle
        clsHIcon        dw      ?       ; class icon handle
        clsHCursor      dw      ?       ; class cursor handle
        clsHbrBackground dw     ?       ; class background brush
        clsLpszMenuName dd      ?       ; menu name
        clsLpszClassName dd     ?       ; far ptr to class name
WNDCLASS ends

IFNDEF NOTEXT
TEXTMETRIC struc
    tmHeight	    dw	    ?
    tmAscent	    dw	    ?
    tmDescent	    dw	    ?
    tmIntLeading    dw	    ?
    tmExtLeading    dw	    ?
    tmAveCharWidth  dw	    ?
    tmMaxCharWidth  dw	    ?
    tmWeight	    dw	    ?
    tmItalic	    db	    ?
    tmUnderlined    db	    ?
    tmStruckOut     db	    ?
    tmFirstChar     db	    ?
    tmLastChar	    db	    ?
    tmDefaultChar   db	    ?
    tmBreakChar     db	    ?
    tmPitch	    db	    ?
    tmCharSet	    db	    ?
    tmOverhang	    dw	    ?
    tmAspectX	    dw	    ?
    tmAspectY	    dw	    ?
TEXTMETRIC ends

LF_FACESIZE	EQU	32

LOGFONT struc
    lfHeight	      dw   ?
    lfWidth	      dw   ?
    lfEscapement      dw   ?
    lfOrientation     dw   ?
    lfWeight	      dw   ?
    lfItalic	      db   ?
    lfUnderline       db   ?
    lfStrikeOut       db   ?
    lfCharSet	      db   ?
    lfOutPrecision    db   ?
    lfClipPrecision   db   ?
    lfQuality	      db   ?
    lfPitchAndFamily  db   ?
    lfFaceName	      db   LF_FACESIZE dup(?)
LOGFONT ends

LOGBRUSH struc
    lbStyle         dw ?
    lbColor         dd ?
    lbHatch         dw ?
LOGBRUSH ends

;
;  Text Drawing modes
;
TRANSPARENT     = 1
OPAQUE          = 2
;
; Mapping Modes
;
MM_TEXT         =   1
MM_LOMETRIC     =   2
MM_HIMETRIC     =   3
MM_LOENGLISH    =   4
MM_HIENGLISH    =   5
MM_TWIPS        =   6
MM_ISOTROPIC    =   7
MM_ANISOTROPIC  =   8
;
; Coordinate Modes
;
ABSOLUTE        =   1
RELATIVE        =   2
;
;  Stock Logical Objects
;
WHITE_BRUSH         =  0
LTGRAY_BRUSH        =  1
GRAY_BRUSH          =  2
DKGRAY_BRUSH        =  3
BLACK_BRUSH         =  4
NULL_BRUSH          =  5
HOLLOW_BRUSH        =  5
WHITE_PEN           =  6
BLACK_PEN           =  7
NULL_PEN            =  8
DOT_MARKER          =  9
OEM_FIXED_FONT      = 10
ANSI_FIXED_FONT     = 11
ANSI_VAR_FONT       = 12
SYSTEM_FONT         = 13
DEVICE_DEFAULT_FONT = 14
DEFAULT_PALETTE     = 15
SYSTEM_FIXED_FONT   = 16
ENDIF
;
; Brush Styles
;
BS_SOLID        =   0
BS_NULL         =   1
BS_HOLLOW       =   BS_NULL
BS_HATCHED      =   2
BS_PATTERN      =   3
BS_INDEXED      =   4
BS_DIBPATTERN	=   5
;
; Hatch Styles
;
HS_HORIZONTAL   =   0       ; -----
HS_VERTICAL     =   1       ; |||||
HS_FDIAGONAL    =   2       ; \\\\\
HS_BDIAGONAL    =   3       ; /////
HS_CROSS        =   4       ; +++++
HS_DIAGCROSS    =   5       ; xxxxx
;
; Pen Styles
;
PS_SOLID        =   0
PS_DASH         =   1       ; -------
PS_DOT          =   2       ; .......
PS_DASHDOT      =   3       ; _._._._
PS_DASHDOTDOT   =   4       ; _.._.._
PS_NULL         =   5
PS_INSIDEFRAME  =   6
;
; Device Parameters for GetDeviceCaps()
;
DRIVERVERSION =0     ; Device driver version
TECHNOLOGY    =2     ; Device classification
HORZSIZE      =4     ; Horizontal size in millimeters
VERTSIZE      =6     ; Vertical size in millimeters
HORZRES       =8     ; Horizontal width in pixels
VERTRES       =10    ; Vertical width in pixels
BITSPIXEL     =12    ; Number of bits per pixel
PLANES        =14    ; Number of planes
NUMBRUSHES    =16    ; Number of brushes the device has
NUMPENS       =18    ; Number of pens the device has
NUMMARKERS    =20    ; Number of markers the device has
NUMFONTS      =22    ; Number of fonts the device has
NUMCOLORS     =24    ; Number of colors the device supports
PDEVICESIZE   =26    ; Size required for device descriptor
CURVECAPS     =28    ; Curve capabilities
LINECAPS      =30    ; Line capabilities
POLYGONALCAPS =32    ; Polygonal capabilities
TEXTCAPS      =34    ; Text capabilities
CLIPCAPS      =36    ; Clipping capabilities
RASTERCAPS    =38    ; Bitblt capabilities
ASPECTX       =40    ; Length of the X leg
ASPECTY       =42    ; Length of the Y leg
ASPECTXY      =44    ; Length of the hypotenuse

LOGPIXELSX    =88    ; Logical pixels/inch in X
LOGPIXELSY    =90    ; Logical pixels/inch in Y

SIZEPALETTE   =104   ; Number of entries in physical palette
NUMRESERVED   =106   ; Number of reserved entries in palette
COLORRES      =108   ; Actual color resolution
;
ifndef NOGDICAPMASKS
;
; Device Capability Masks:
;
; Device Technologies
DT_PLOTTER       =   0  ; /* Vector plotter                   */
DT_RASDISPLAY    =   1  ; /* Raster display                   */
DT_RASPRINTER    =   2  ; /* Raster printer                   */
DT_RASCAMERA     =   3  ; /* Raster camera                    */
DT_CHARSTREAM    =   4  ; /* Character-stream, PLP            */
DT_METAFILE      =   5  ; /* Metafile, VDM                    */
DT_DISPFILE      =   6  ; /* Display-file                     */
;
; Curve Capabilities
CC_NONE          =   0  ; /* Curves not supported             */
CC_CIRCLES       =   1  ; /* Can do circles                   */
CC_PIE           =   2  ; /* Can do pie wedges                */
CC_CHORD         =   4  ; /* Can do chord arcs                */
CC_ELLIPSES      =   8  ; /* Can do ellipese                  */
CC_WIDE          =   16 ; /* Can do wide lines                */
CC_STYLED        =   32 ; /* Can do styled lines              */
CC_WIDESTYLED    =   64 ; /* Can do wide styled lines         */
CC_INTERIORS     =   128; /* Can do interiors                 */
;
; Line Capabilities
LC_NONE          =   0  ; /* Lines not supported              */
LC_POLYLINE      =   2  ; /* Can do polylines                 */
LC_MARKER        =   4  ; /* Can do markers                   */
LC_POLYMARKER    =   8  ; /* Can do polymarkers               */
LC_WIDE          =   16 ; /* Can do wide lines                */
LC_STYLED        =   32 ; /* Can do styled lines              */
LC_WIDESTYLED    =   64 ; /* Can do wide styled lines         */
LC_INTERIORS     =   128; /* Can do interiors                 */
;
; Polygonal Capabilities
PC_NONE          =   0  ; /* Polygonals not supported         */
PC_POLYGON       =   1  ; /* Can do polygons                  */
PC_RECTANGLE     =   2  ; /* Can do rectangles                */
PC_WINDPOLYGON   =   4  ; /* Can do winding polygons          */
PC_TRAPEZOID     =   4  ; /* Can do trapezoids                */
PC_SCANLINE      =   8  ; /* Can do scanlines                 */
PC_WIDE          =   16 ; /* Can do wide borders              */
PC_STYLED        =   32 ; /* Can do styled borders            */
PC_WIDESTYLED    =   64 ; /* Can do wide styled borders       */
PC_INTERIORS     =   128; /* Can do interiors                 */
;
; Polygonal Capabilities */
CP_NONE          =   0  ; /* No clipping of output            */
CP_RECTANGLE     =   1  ; /* Output clipped to rects          */
;
; Text Capabilities
TC_OP_CHARACTER  =   0001h ; /* Can do OutputPrecision   CHARACTER      */
TC_OP_STROKE     =   0002h ; /* Can do OutputPrecision   STROKE         */
TC_CP_STROKE     =   0004h ; /* Can do ClipPrecision     STROKE         */
TC_CR_90         =   0008h ; /* Can do CharRotAbility    90             */
TC_CR_ANY        =   0010h ; /* Can do CharRotAbility    ANY            */
TC_SF_X_YINDEP   =   0020h ; /* Can do ScaleFreedom      X_YINDEPENDENT */
TC_SA_DOUBLE     =   0040h ; /* Can do ScaleAbility      DOUBLE         */
TC_SA_INTEGER    =   0080h ; /* Can do ScaleAbility      INTEGER        */
TC_SA_CONTIN     =   0100h ; /* Can do ScaleAbility      CONTINUOUS     */
TC_EA_DOUBLE     =   0200h ; /* Can do EmboldenAbility   DOUBLE         */
TC_IA_ABLE       =   0400h ; /* Can do ItalisizeAbility  ABLE           */
TC_UA_ABLE       =   0800h ; /* Can do UnderlineAbility  ABLE           */
TC_SO_ABLE       =   1000h ; /* Can do StrikeOutAbility  ABLE           */
TC_RA_ABLE       =   2000h ; /* Can do RasterFontAble    ABLE           */
TC_VA_ABLE       =   4000h ; /* Can do VectorFontAble    ABLE           */
TC_RESERVED      =   8000h
;
; Raster Capabilities
RC_BITBLT        =   1      ; /* Can do standard BLT.             */
RC_BANDING       =   2      ; /* Device requires banding support  */
RC_SCALING       =   4      ; /* Device requires scaling support  */
RC_BITMAP64      =   8      ; /* Device can support >64K bitmap   */
RC_GDI20_OUTPUT  =   0010h  ; /* has 2.0 output calls         */
RC_DI_BITMAP     =   0080h  ; /* supports DIB to memory       */
RC_PALETTE       =   0100h  ; /* supports a palette           */
RC_DIBTODEV      =   0200h  ; /* supports DIBitsToDevice      */
RC_BIGFONT       =   0400h  ; /* supports >64K fonts          */
RC_STRETCHBLT    =   0800h  ; /* supports StretchBlt          */
RC_FLOODFILL     =   1000h  ; /* supports FloodFill           */
RC_STRETCHDIB    =   2000h  ; /* supports StretchDIBits       */

endif       ;NOGDICAPMASKS

; palette entry flags
;
PC_RESERVED     = 1    ;/* palette index used for animation */
PC_EXPLICIT     = 2    ;/* palette index is explicit to device */
PC_NOCOLLAPSE	= 4    ;/* do not match color to system palette */

; DIB color table identifiers
;
DIB_RGB_COLORS  = 0    ;/* color table in RGBTriples */
DIB_PAL_COLORS  = 1    ;/* color table in palette indices */
;

;constants for Get/SetSystemPaletteUse()
;
SYSPAL_STATIC	= 1
SYSPAL_NOSTATIC	= 2

; constants for CreateDIBitmap
CBM_INIT        = 4    ;/* initialize bitmap */
;
; Bitmap format constants
BI_RGB          = 0
BI_RLE8         = 1
BI_RLE4         = 2
;
;
ANSI_CHARSET    = 0
SYMBOL_CHARSET	= 2
OEM_CHARSET     = 255
;
;  styles for CombineRgn
;
RGN_AND  = 1
RGN_OR   = 2
RGN_XOR  = 3
RGN_DIFF = 4
RGN_COPY = 5
;
;  Predefined cursor & icon IDs
;
IDC_ARROW       = 32512
IDC_IBEAM       = 32513
IDC_WAIT        = 32514
IDC_CROSS       = 32515
IDC_UPARROW     = 32516
IDC_SIZE        = 32640
IDC_ICON        = 32641
IDC_SIZENWSE    = 32642
IDC_SIZENESW    = 32643
IDC_SIZEWE      = 32644
IDC_SIZENS      = 32645

IDI_APPLICATION = 32512
IDI_HAND        = 32513
IDI_QUESTION    = 32514
IDI_EXCLAMATION = 32515
IDI_ASTERISK    = 32516

;
; OEM Resource Ordinal Numbers */
;
OBM_CLOSE         =  32754
OBM_UPARROW       =  32753
OBM_DNARROW       =  32752
OBM_RGARROW       =  32751
OBM_LFARROW       =  32750
OBM_REDUCE        =  32749
OBM_ZOOM          =  32748
OBM_RESTORE       =  32747
OBM_REDUCED       =  32746
OBM_ZOOMD         =  32745
OBM_RESTORED      =  32744
OBM_UPARROWD      =  32743
OBM_DNARROWD      =  32742
OBM_RGARROWD      =  32741
OBM_LFARROWD      =  32740
OBM_MNARROW       =  32739
OBM_COMBO         =  32738
OBM_UPARROWI	  =  32737
OBM_DNARROWI	  =  32736
OBM_RGARROWI	  =  32735
OBM_LFARROWI	  =  32734

OBM_OLD_CLOSE     =  32767
OBM_SIZE          =  32766
OBM_OLD_UPARROW   =  32765
OBM_OLD_DNARROW   =  32764
OBM_OLD_RGARROW   =  32763
OBM_OLD_LFARROW   =  32762
OBM_BTSIZE        =  32761
OBM_CHECK         =  32760
OBM_CHECKBOXES    =  32759
OBM_BTNCORNERS    =  32758
OBM_OLD_REDUCE    =  32757
OBM_OLD_ZOOM      =  32756
OBM_OLD_RESTORE   =  32755

OCR_NORMAL        =  32512
OCR_IBEAM         =  32513
OCR_WAIT          =  32514
OCR_CROSS         =  32515
OCR_UP            =  32516
OCR_SIZE          =  32640
OCR_ICON          =  32641
OCR_SIZENWSE      =  32642
OCR_SIZENESW      =  32643
OCR_SIZEWE        =  32644
OCR_SIZENS        =  32645
OCR_SIZEALL       =  32646
OCR_ICOCUR        =  32647

OIC_SAMPLE        =  32512
OIC_HAND          =  32513
OIC_QUES          =  32514
OIC_BANG          =  32515
OIC_NOTE          =  32516

;
;   Scroll bar constants
;
SB_HORZ = 0
SB_VERT = 1
SB_CTL  = 2
SB_BOTH = 3
;
;   Scroll Commands
;
SB_LINEUP        = 0
SB_LINEDOWN      = 1
SB_PAGEUP        = 2
SB_PAGEDOWN      = 3
SB_THUMBPOSITION = 4
SB_THUMBTRACK    = 5
SB_TOP           = 6
SB_BOTTOM        = 7
SB_ENDSCROLL     = 8
;
;  MessageBox type flags
;
IFNDEF                  NOMB
MB_OK                   = 0000H
MB_OKCANCEL             = 0001H
MB_ABORTRETRYIGNORE     = 0002H
MB_YESNOCANCEL          = 0003H
MB_YESNO                = 0004H
MB_RETRYCANCEL          = 0005H

MB_ICONHAND             = 0010H
MB_ICONQUESTION         = 0020H
MB_ICONEXCLAMATION      = 0030H
MB_ICONASTERISK         = 0040H

MB_DEFBUTTON1           = 0000H
MB_DEFBUTTON2           = 0100H
MB_DEFBUTTON3           = 0200H

MB_APPLMODAL            = 0000H
MB_SYSTEMMODAL          = 1000H
MB_TASKMODAL            = 2000H

MB_NOFOCUS              = 8000H

;
;  Conventional dialog box and message box command IDs
;
IDOK     =   1
IDCANCEL =   2
IDABORT  =   3
IDRETRY  =   4
IDIGNORE =   5
IDYES    =   6
IDNO     =   7
;
;  Flags for OpenFile
;
OF_READ 	    = 0000H
OF_WRITE	    = 0001H
OF_READWRITE	    = 0002H
OF_SHARE_COMPAT	    = 0000H
OF_SHARE_EXCLUSIVE  = 0010H
OF_SHARE_DENY_WRITE = 0020H
OF_SHARE_DENY_READ  = 0030H
OF_SHARE_DENY_NONE  = 0040H
OF_PARSE	    = 0100H
OF_DELETE	    = 0200H
OF_VERIFY	    = 0400H     ; Used with OF_REOPEN
OF_SEARCH	    = 0400H     ; Used without OF_REOPEN
OF_CANCEL           = 0800H
OF_CREATE           = 1000H
OF_PROMPT           = 2000H
OF_EXIST            = 4000H
OF_REOPEN           = 8000H

TF_FORCEDRIVE   = 80H

OPENSTRUC       STRUC
opLen   db      ?
opDisk  db      ?
opXtra  dw      ?
opDate  dw      ?
opTime  dw      ?
opFile  db      120 dup (?)
OPENSTRUC       ENDS
;
;  DrawText format flags
;
DT_LEFT         = 00H
DT_CENTER       = 01H
DT_RIGHT        = 02H
DT_TOP          = 00H
DT_VCENTER      = 04H
DT_BOTTOM       = 08H
DT_WORDBREAK    = 10H
DT_SINGLELINE   = 20H
DT_EXPANDTABS   = 40H
DT_TABSTOP      = 80H
DT_NOCLIP       =    0100H
DT_EXTERNALLEADING = 0200H
DT_CALCRECT     =    0400H
DT_NOPREFIX     =    0800H
DT_INTERNAL     =    1000H
ENDIF

;
; ExtFloodFill style flags
;
FLOODFILLBORDER  =  0
FLOODFILLSURFACE =  1

;
; Memory manager flags
;
LMEM_FIXED      =   0000h
LMEM_MOVEABLE   =   0002h
LMEM_NOCOMPACT  =   0010H
LMEM_NODISCARD  =   0020H
LMEM_ZEROINIT   =   0040h
LMEM_MODIFY     =   0080H
LMEM_DISCARDABLE=   0F00h
LHND    =    LMEM_MOVEABLE+LMEM_ZEROINIT
LPTR    =    LMEM_FIXED+LMEM_ZEROINIT
; Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE)
LMEM_DISCARDED  =   4000H
LMEM_LOCKCOUNT  =   00FFH

NONZEROLHND     =    LMEM_MOVEABLE
NONZEROLPTR     =    LMEM_FIXED

LNOTIFY_OUTOFMEM  =  0			;Internal
LNOTIFY_MOVE      =  1			;Internal
LNOTIFY_DISCARD   =  2			;Internal


GMEM_FIXED      =   0000h
GMEM_MOVEABLE   =   0002h
GMEM_NOCOMPACT  =   0010h
GMEM_NODISCARD  =   0020h
GMEM_ZEROINIT   =   0040h
GMEM_MODIFY     =   0080h
GMEM_DISCARDABLE=   0100h
GMEM_NOT_BANKED =   1000h
GMEM_DDESHARE   =   2000h
GMEM_SHARE	=   2000h
GMEM_NOTIFY     =   4000h
GMEM_LOWER      =   GMEM_NOT_BANKED
GHND            =   GMEM_MOVEABLE+GMEM_ZEROINIT
GPTR            =   GMEM_FIXED+GMEM_ZEROINIT

; Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE)
GMEM_DISCARDED  =    4000h
GMEM_LOCKCOUNT  =    00FFh

; Flags returned by GetWinFlags

WF_PMODE        =    0001h
WF_CPU286       =    0002h
WF_CPU386       =    0004h
WF_CPU486       =    0008h
WF_STANDARD	=    0010h
WF_WIN286	=    0010h
WF_ENHANCED	=    0020h
WF_WIN386	=    0020h
WF_CPU086	=    0040h
WF_CPU186	=    0080h
WF_LARGEFRAME   =    0100h
WF_SMALLFRAME   =    0200h
WF_80x87	=    0400h
WF_PAGING	=    0800h
WF_WLO          =    8000h

; WEP fSystemExit flag values
WEP_SYSTEM_EXIT	=	1
WEP_FREE_DLL	=	0

; GetAppCompatFlags flag values 	;Internal
GACF_IGNORENODISCARD	=	0001h	;Internal
GACF_FORCETEXTBAND	=	0002h	;Internal
GACF_ONELANDGRXBAND	=	0004h	;Internal
GACF_IGNORETOPMOST	=	0008h	;Internal
GACF_CALLTTDEVICE	=	0010h	;Internal
GACF_MULTIPLEBANDS	=	0020h	;Internal
GACF_ALWAYSSENDNCPAINT	=	0040h	;Internal
GACF_EDITSETTEXTMUNGE	=	0080h	;Internal
GACF_MOREEXTRAWNDWORDS	=	0100h	;Internal
GACF_TTIGNORERASTERDUPE =	0200h	;Internal
GACF_HACKWINFLAGS	=	0400h	;Internal
GACF_DELAYHWHNDSHAKECHK =	0800h	;Internal

;  Virtual Keys, Standard Set

IFNDEF          NOVK
VK_LBUTTON      = 01H
VK_RBUTTON      = 02H
VK_CANCEL       = 03H
VK_BACK         = 08H
VK_TAB          = 09H
VK_CLEAR        = 0cH
VK_RETURN       = 0dH
VK_SHIFT        = 10H
VK_CONTROL      = 11H
VK_MENU         = 12H
VK_PAUSE        = 13H
VK_CAPITAL      = 14H
VK_ESCAPE       = 1bH
VK_SPACE        = 20H

VK_PRIOR        = 21H
VK_NEXT         = 22H
VK_END          = 23H
VK_HOME         = 24H
VK_LEFT         = 25H
VK_UP           = 26H
VK_RIGHT        = 27H
VK_DOWN         = 28H

;  VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z'
;  VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0'

VK_PRINT        = 2aH
VK_EXECUTE      = 2bH
VK_SNAPSHOT	= 2ch	; Printscreen key..
VK_INSERT       = 2dH
VK_DELETE       = 2eH
VK_HELP         = 2fH

VK_NUMPAD0      = 60H
VK_NUMPAD1      = 61H
VK_NUMPAD2      = 62H
VK_NUMPAD3      = 63H
VK_NUMPAD4      = 64H
VK_NUMPAD5      = 65H
VK_NUMPAD6      = 66H
VK_NUMPAD7      = 67H
VK_NUMPAD8      = 68H
VK_NUMPAD9      = 69H
VK_MULTIPLY     = 6AH
VK_ADD          = 6BH
VK_SEPARATER    = 6CH
VK_SUBTRACT     = 6DH
VK_DECIMAL      = 6EH
VK_DIVIDE       = 6FH

VK_F1           = 70H
VK_F2           = 71H
VK_F3           = 72H
VK_F4           = 73H
VK_F5           = 74H
VK_F6           = 75H
VK_F7           = 76H
VK_F8           = 77H
VK_F9           = 78H
VK_F10          = 79H
VK_F11          = 7aH
VK_F12          = 7bH
VK_F13          = 7cH
VK_F14          = 7dH
VK_F15          = 7eH
VK_F16          = 7fH
VK_F17		= 80H
VK_F18		= 81H
VK_F19		= 82H
VK_F20		= 83H
VK_F21		= 84H
VK_F22		= 85H
VK_F23		= 86H
VK_F24		= 87H

VK_NUMLOCK      = 90H
VK_SCROLL       = 91H
ENDIF

IFNDEF NOWH

; SetWindowsHook() codes
WH_NULLNODE	   = (-100)		;Internal
WH_MSGFILTER       = (-1)
WH_JOURNALRECORD   = 0
WH_JOURNALPLAYBACK = 1
WH_KEYBOARD        = 2
WH_GETMESSAGE      = 3
WH_CALLWNDPROC     = 4
IFNDEF NOWIN31
WH_CBT             = 5
WH_SYSMSGFILTER    = 6
WH_MOUSE	   = 7
WH_HARDWARE	   = 8
WH_DEBUG	   = 9
ENDIF
;
; Hook Codes
HC_GETLPLPFN	   = (-3)
HC_LPLPFNNEXT      = (-2)
HC_LPFNNEXT        = (-1)
HC_ACTION          = 0
HC_GETNEXT         = 1
HC_SKIP            = 2
HC_NOREM           = 3
HC_NOREMOVE        = 3
HC_SYSMODALON      = 4
HC_SYSMODALOFF     = 5
;
; CBT Hook Codes
HCBT_MOVESIZE      = 0
HCBT_MINMAX        = 1
HCBT_QS            = 2
HCBT_CREATEWND	   = 3
HCBT_DESTROYWND	   = 4
HCBT_ACTIVATE	   = 5
HCBT_CLICKSKIPPED  = 6
HCBT_KEYSKIPPED    = 7
HCBT_SYSCOMMAND	   = 8
HCBT_SETFOCUS	   = 9

;
; WH_MSGFILTER Filter Proc Codes
MSGF_DIALOGBOX     = 0
MSGF_MESSAGEBOX    = 1        ;Internal
MSGF_MENU          = 2
MSGF_MOVE          = 3
MSGF_SIZE          = 4
MSGF_SCROLLBAR     = 5
MSGF_NEXTWINDOW    = 6
;
; Window Manager Hook Codes
WC_INIT            = 1
WC_SWP             = 2
WC_DEFWINDOWPROC   = 3
WC_MINMAX          = 4
WC_MOVE            = 5
WC_SIZE            = 6
WC_DRAWCAPTION     = 7
;

; Message Structure used in Journaling
EVENTMSG    struc
    message     dw ?
    paramL      dw ?
    paramH      dw ?
    time        dd ?
EVENTMSG    ends

ENDIF ;NOWH

; Window field offsets for GetWindowLong() and GetWindowWord()
GWL_WNDPROC       =  (-4)
GWW_HINSTANCE     =  (-6)
GWW_HWNDPARENT    =  (-8)
GWW_ID            =  (-12)
GWL_STYLE         =  (-16)
GWL_EXSTYLE       =  (-20)

; GetWindow() Constants
GW_HWNDFIRST	  =  0
GW_HWNDLAST	  =  1
GW_HWNDNEXT	  =  2
GW_HWNDPREV	  =  3
GW_OWNER	  =  4
GW_CHILD	  =  5

; Class field offsets for GetClassLong() and GetClassWord()
GCL_MENUNAME      =  (-8)
GCW_HBRBACKGROUND =  (-10)
GCW_HCURSOR       =  (-12)
GCW_HICON         =  (-14)
GCW_HMODULE       =  (-16)
GCW_CBWNDEXTRA    =  (-18)
GCW_CBCLSEXTRA    =  (-20)
GCL_WNDPROC       =  (-24)
GCW_STYLE         =  (-26)

; WinWhere() Area Codes
HTERROR           =  (-2)
HTTRANSPARENT     =  (-1)
HTNOWHERE         =  0
HTCLIENT          =  1
HTCAPTION         =  2
HTSYSMENU         =  3
HTGROWBOX         =  4
HTSIZE            =  HTGROWBOX
HTMENU            =  5
HTHSCROLL         =  6
HTVSCROLL         =  7
HTREDUCE          =  8
HTZOOM            =  9
HTLEFT            =  10
HTRIGHT           =  11
HTTOP             =  12
HTTOPLEFT         =  13
HTTOPRIGHT        =  14
HTBOTTOM          =  15
HTBOTTOMLEFT      =  16
HTBOTTOMRIGHT     =  17
HTSIZEFIRST       =  HTLEFT
HTSIZELAST        =  HTBOTTOMRIGHT



;*************************************************************************
;
;       Misc structures & constants
;
;*************************************************************************

IFNDEF  NOMST
POINT   struc
        ptX             dw      ?
        ptY             dw      ?
POINT   ends

LOGPEN struc
    lopnStyle       dw ?
    lopnWidth       db (SIZE POINT) DUP(?)
    lopnColor       dd ?
LOGPEN ends


BITMAP STRUC
        bmType         DW ?
        bmWidth        DW ?
        bmHeight       DW ?
        bmWidthBytes   DW ?
        bmPlanes       DB ?
        bmBitsPixel    DB ?
        bmBits         DD ?
BITMAP ENDS

RGBTRIPLE	struc
	rgbBlue		db ?
	rgbGreen	db ?
	rgbRed		db ?
RGBTRIPLE	ends

RGBQUAD         struc
        rgbqBlue        db ?
        rgbqGreen       db ?
        rgbqRed         db ?
        rgbqReserved    db ?
RGBQUAD         ends

; structures for defining DIBs
BITMAPCOREHEADER struc
        bcSize      dd ?
        bcWidth     dw ?
        bcHeight    dw ?
        bcPlanes    dw ?
        bcBitCount  dw ?
BITMAPCOREHEADER ends

BITMAPINFOHEADER struc
        biSize           dd ?
        biWidth          dd ?
        biHeight         dd ?
        biPlanes         dw ?
        biBitCount       dw ?

        biCompression    dd ?
        biSizeImage      dd ?
        biXPelsPerMeter  dd ?
        biYPelsPerMeter  dd ?
        biClrUsed        dd ?
        biClrImportant   dd ?
BITMAPINFOHEADER ends

BITMAPINFO  struc
    bmiHeader   db (SIZE BITMAPINFOHEADER) DUP (?)
    bmiColors   db ?            ; array of RGBQUADs
BITMAPINFO  ends

BITMAPCOREINFO  struc
    bmciHeader  db (SIZE BITMAPCOREHEADER) DUP (?)
    bmciColors  db ?            ; array of RGBTRIPLEs
BITMAPCOREINFO  ends

BITMAPFILEHEADER struc
    bfType          dw ?
    bfSize          dd ?
    bfReserved1     dw ?
    bfReserved2     dw ?
    bfOffBits       dd ?
BITMAPFILEHEADER ends


WNDSTRUC struc
        WSwndStyle        dd      ?
        WSwndID           dw      ?
        WSwndText         dw      ?
        WSwndParent       dw      ?
        WSwndInstance     dw      ?
        WSwndClassProc    dd      ?
WNDSTRUC ends
;
;  Message structure
;
MSGSTRUCT       struc
msHWND          dw      ?
msMESSAGE       dw      ?
msWPARAM        dw      ?
msLPARAM        dd      ?
msTIME          dd      ?
msPT            dd      ?
MSGSTRUCT       ends

NEWPARMS struc
        nprmHwnd        dw      ?
        nprmCmd         db      ?
NEWPARMS ends
ENDIF

PAINTSTRUCT STRUC
    PShdc         DW ?
    PSfErase      DW ?
    PSrcPaint     DB size RECT dup(?)
    PSfRestore    DW ?
    PSfIncUpdate  DW ?
    PSrgbReserved DB 16 dup(?)
PAINTSTRUCT ENDS


CREATESTRUCT struc
    cs_lpCreateParams  dd ?
    cs_hInstance       dw ?
    cs_hMenu           dw ?
    cs_hwndParent      dw ?
    cs_cy              dw ?
    cs_cx              dw ?
    cs_y               dw ?
    cs_x               dw ?
    cs_style           dd ?
    cs_lpszName        dd ?
    cs_lpszClass       dd ?
    cs_dwExStyle       dd ?
CREATESTRUCT  ends
;
;       PostError constants
;
WARNING     = 0           ; command codes
MINOR_ERROR = 1
FATAL_ERROR = 2

IGNORE      = 0           ; response codes
RETRY       = 1
ABORT       = 2
;
; GDI-related constants & commands
;
ERRORREGION     = 0
NULLREGION      = 1
SIMPLEREGION    = 2
COMPLEXREGION   = 3

IFNDEF NORASTOPS
;
; Binary raster ops
;
R2_BLACK        =  1
R2_NOTMERGEPEN  =  2
R2_MASKNOTPEN   =  3
R2_NOTCOPYPEN   =  4
R2_MASKPENNOT   =  5
R2_NOT          =  6
R2_XORPEN       =  7
R2_NOTMASKPEN   =  8
R2_MASKPEN      =  9
R2_NOTXORPEN    = 10
R2_NOP          = 11
R2_MERGENOTPEN  = 12
R2_COPYPEN      = 13
R2_MERGEPENNOT  = 14
R2_MERGEPEN     = 15
R2_WHITE        = 16
;
; Ternary raster ops
;
SRCCOPY_L     = 0020h   ;dest=source
SRCCOPY_H     = 00CCh
SRCPAINT_L    = 0086h   ;dest=source OR dest
SRCPAINT_H    = 00EEh
SRCAND_L      = 00C6h   ;dest=source AND   dest
SRCAND_H      = 0088h
SRCINVERT_L   = 0046h   ;dest= source XOR      dest
SRCINVERT_H   = 0066h
SRCERASE_L    = 0328h   ;dest= source AND (not dest )
SRCERASE_H    = 0044h
NOTSRCCOPY_L  = 0008h   ;dest= (not source)
NOTSRCCOPY_H  = 0033h
NOTSRCERASE_L = 00A6h   ;dest= (not source) AND (not dest)
NOTSRCERASE_H = 0011h
MERGECOPY_L   = 00CAh   ;dest= (source AND pattern)
MERGECOPY_H   = 00C0h
MERGEPAINT_L  = 0226h   ;dest= (source AND pattern) OR dest
MERGEPAINT_H  = 00BBh
PATCOPY_L     = 0021h   ;dest= pattern
PATCOPY_H     = 00F0h
PATPAINT_L    = 0A09h   ;DPSnoo
PATPAINT_H    = 00FBh
PATINVERT_L   = 0049h   ;dest= pattern XOR     dest
PATINVERT_H   = 005Ah
DSTINVERT_L   = 0009h   ;dest= (not dest)
DSTINVERT_H   = 0055h
BLACKNESS_L   = 0042h   ;dest= BLACK
BLACKNESS_H   = 0000h
WHITENESS_L   = 0062h   ;dest= WHITE
WHITENESS_H   = 00FFh
;
; StretchBlt modes
;
BLACKONWHITE    = 1
WHITEONBLACK    = 2
COLORONCOLOR    = 3
;
; New StretchBlt modes
;
STRETCH_ANDSCANS    = 1
STRETCH_ORSCANS     = 2
STRETCH_DELETESCANS = 3
;
; PolyFill modes
;
ALTERNATE       = 1
WINDING         = 2
ENDIF
;
; Text Alignment Options
;
TA_NOUPDATECP   =  0
TA_UPDATECP     =  1

TA_LEFT         =  0
TA_RIGHT        =  2
TA_CENTER       =  6

TA_TOP          =  0
TA_BOTTOM       =  8
TA_BASELINE     =  24

ETO_GRAYED      =  1
ETO_OPAQUE      =  2
ETO_CLIPPED     =  4

ASPECT_FILTERING = 1

ifndef NOMETAFILE

; Metafile Functions */
META_SETBKCOLOR            =  0201h
META_SETBKMODE             =  0102h
META_SETMAPMODE            =  0103h
META_SETROP2               =  0104h
META_SETRELABS             =  0105h
META_SETPOLYFILLMODE       =  0106h
META_SETSTRETCHBLTMODE     =  0107h
META_SETTEXTCHAREXTRA      =  0108h
META_SETTEXTCOLOR          =  0209h
META_SETTEXTJUSTIFICATION  =  020Ah
META_SETWINDOWORG          =  020Bh
META_SETWINDOWEXT          =  020Ch
META_SETVIEWPORTORG        =  020Dh
META_SETVIEWPORTEXT        =  020Eh
META_OFFSETWINDOWORG       =  020Fh
META_SCALEWINDOWEXT        =  0400h
META_OFFSETVIEWPORTORG     =  0211h
META_SCALEVIEWPORTEXT      =  0412h
META_LINETO                =  0213h
META_MOVETO                =  0214h
META_EXCLUDECLIPRECT       =  0415h
META_INTERSECTCLIPRECT     =  0416h
META_ARC                   =  0817h
META_ELLIPSE               =  0418h
META_FLOODFILL             =  0419h
META_PIE                   =  081Ah
META_RECTANGLE             =  041Bh
META_ROUNDRECT             =  061Ch
META_PATBLT                =  061Dh
META_SAVEDC                =  001Eh
META_SETPIXEL              =  041Fh
META_OFFSETCLIPRGN         =  0220h
META_TEXTOUT               =  0521h
META_BITBLT                =  0922h
META_STRETCHBLT            =  0B23h
META_POLYGON               =  0324h
META_POLYLINE              =  0325h
META_ESCAPE                =  0626h
META_RESTOREDC             =  0127h
META_FILLREGION            =  0228h
META_FRAMEREGION           =  0429h
META_INVERTREGION          =  012Ah
META_PAINTREGION           =  012Bh
META_SELECTCLIPREGION      =  012Ch
META_SELECTOBJECT          =  012Dh
META_SETTEXTALIGN          =  012Eh
META_DRAWTEXT              =  062Fh

META_CHORD		   =  0830h
META_SETMAPPERFLAGS	   =  0231h
META_EXTTEXTOUT		   =  0a32h
META_SETDIBTODEV	   =  0d33h
META_SELECTPALETTE	   =  0234h
META_REALIZEPALETTE	   =  0035h
META_ANIMATEPALETTE	   =  0436h
META_SETPALENTRIES	   =  0037h
META_POLYPOLYGON	   =  0538h
META_RESIZEPALETTE	   =  0139h

META_DIBBITBLT		   =  0940h
META_DIBSTRETCHBLT	   =  0b41h
META_DIBCREATEPATTERNBRUSH =  0142h
META_STRETCHDIB		   =  0f43h

META_DELETEOBJECT	   =  01f0h

META_CREATEPALETTE	   =  00f7h
META_CREATEBRUSH           =  00F8h
META_CREATEPATTERNBRUSH    =  01F9h
META_CREATEPENINDIRECT     =  02FAh
META_CREATEFONTINDIRECT    =  02FBh
META_CREATEBRUSHINDIRECT   =  02FCh
META_CREATEBITMAPINDIRECT  =  02FDh
META_CREATEBITMAP          =  06FEh
META_CREATEREGION          =  06FFh

; /* Clipboard Metafile Picture Structure */
HANDLETABLE struc
    ht_objectHandle  dw      ?
HANDLETABLE ends

METARECORD struc
    mr_rdSize	     dd      ?
    mr_rdFunction    dw      ?
    mr_rdParm	     dw      ?
METARECORD ends

METAFILEPICT struc
    mfp_mm	dw	?
    mfp_xExt	dw	?
    mfp_yExt	dw	?
    mfp_hMF	dw	?
METAFILEPICT ends

METAHEADER struc
  mtType	dw	?
  mtHeaderSize	dw	?
  mtVersion	dw	?
  mtSize	dd	?
  mtNoObjects	dw	?
  mtMaxRecord	dd	?
  mtNoParameters dw	?
METAHEADER ends

endif ; NOMETAFILE

; GDI Escapes
NEWFRAME                  =   1
ABORTDOC                  =   2
NEXTBAND                  =   3
SETCOLORTABLE             =   4
GETCOLORTABLE             =   5
FLUSHOUTPUT               =   6
DRAFTMODE                 =   7
QUERYESCSUPPORT           =   8
SETABORTPROC              =   9
STARTDOC                  =   10
;; This value conflicts with a std WIN386 MACRO definition
;;ENDDOC		    =	11
GETPHYSPAGESIZE           =   12
GETPRINTINGOFFSET         =   13
GETSCALINGFACTOR          =   14
MFCOMMENT                 =   15
GETPENWIDTH               =   16
SETCOPYCOUNT              =   17
SELECTPAPERSOURCE         =   18
DEVICEDATA                =   19
PASSTHROUGH               =   19
GETTECHNOLGY		  =   20
GETTECHNOLOGY		  =   20
SETENDCAP                 =   21
SETLINEJOIN               =   22
SETMITERLIMIT             =   23
BANDINFO                  =   24
DRAWPATTERNRECT           =   25
GETVECTORPENSIZE          =   26
GETVECTORBRUSHSIZE        =   27
ENABLEDUPLEX              =   28
ENABLEMANUALFEED	  =   29
GETSETPAPERBINS 	  =   29
GETSETPRINTORIENT	  =   30
ENUMPAPERBINS		  =   31

GETEXTENDEDTEXTMETRICS    =   256
GETEXTENTTABLE            =   257
GETPAIRKERNTABLE          =   258
GETTRACKKERNTABLE         =   259

EXTTEXTOUT                =   512

ENABLERELATIVEWIDTHS      =   768
ENABLEPAIRKERNING         =   769
SETKERNTRACK              =   770
SETALLJUSTVALUES	  =   771
SETCHARSET		  =   772

GETSETSCREENPARAMS        =   3072

STRETCHBLT                =   2048


; Spooler Error Codes
SP_NOTREPORTED            =   4000h
SP_ERROR                  =   (-1)
SP_APPABORT               =   (-2)
SP_USERABORT              =   (-3)
SP_OUTOFDISK              =   (-4)
SP_OUTOFMEMORY            =   (-5)

PR_JOBSTATUS              =   0000

; Object Definitions for EnumObjects()
OBJ_PEN                   =   1
OBJ_BRUSH                 =   2

;
; Menu flags for Change/Check/Enable MenuItem
;
MF_INSERT       =   0000h
MF_CHANGE       =   0080h
MF_APPEND       =   0100h
MF_DELETE       =   0200h
MF_REMOVE       =   1000h

MF_BYCOMMAND    =   0000h
MF_BYPOSITION   =   0400h

MF_SEPARATOR    =   0800h

MF_ENABLED      =   0000h
MF_GRAYED       =   0001h
MF_DISABLED     =   0002h

MF_UNCHECKED    =   0000h
MF_CHECKED      =   0008h
MF_USECHECKBITMAPS= 0200h

MF_STRING       =   0000h
MF_BITMAP       =   0004h
MF_OWNERDRAW    =   0100h

MF_POPUP        =   0010h
MF_MENUBARBREAK =   0020h
MF_MENUBREAK    =   0040h

MF_UNHILITE     =   0000h
MF_HILITE       =   0080h

MF_SYSMENU      =   2000h
MF_HELP         =   4000h
MF_MOUSESELECT  =   8000h


;
;  System Menu Command Values
;
SC_SIZE        = 0F000h
SC_MOVE        = 0F010h
SC_MINIMIZE    = 0F020h
SC_MAXIMIZE    = 0F030h
SC_NEXTWINDOW  = 0F040h
SC_PREVWINDOW  = 0F050h
SC_CLOSE       = 0F060h
SC_VSCROLL     = 0F070h
SC_HSCROLL     = 0F080h
SC_MOUSEMENU   = 0F090h
SC_KEYMENU     = 0F100h
SC_ARRANGE     = 0F110h
SC_RESTORE     = 0F120h
SC_TASKLIST    = 0F130h
SC_SCREENSAVE  = 0F140h
SC_HOTKEY      = 0F150h

SC_ICON        = SC_MINIMIZE
SC_ZOOM        = SC_MAXIMIZE

;
;  Window State Messages
;
IFNDEF  NOWM
WM_STATE            = 0000H

WM_NULL             = 0000h
WM_CREATE           = 0001h
WM_DESTROY          = 0002h
WM_MOVE             = 0003h
WM_SIZEWAIT         = 0004h	;Internal
WM_SIZE             = 0005h
WM_ACTIVATE         = 0006h
WM_SETFOCUS         = 0007h
WM_KILLFOCUS        = 0008h
WM_SETVISIBLE       = 0009h	;Internal
WM_ENABLE           = 000Ah
WM_SETREDRAW        = 000Bh
WM_SETTEXT          = 000Ch
WM_GETTEXT          = 000Dh
WM_GETTEXTLENGTH    = 000Eh
WM_PAINT            = 000Fh
WM_CLOSE            = 0010h
WM_QUERYENDSESSION  = 0011h
WM_QUIT             = 0012h
WM_QUERYOPEN        = 0013h
WM_ERASEBKGND       = 0014h
WM_SYSCOLORCHANGE   = 0015h
WM_ENDSESSION       = 0016h
WM_SYSTEMERROR      = 0017h
WM_SHOWWINDOW       = 0018h
WM_CTLCOLOR         = 0019h
WM_WININICHANGE     = 001Ah
WM_DEVMODECHANGE    = 001Bh
WM_ACTIVATEAPP      = 001Ch
WM_FONTCHANGE       = 001Dh
WM_TIMECHANGE       = 001Eh
WM_CANCELMODE       = 001Fh
WM_SETCURSOR        = 0020h
WM_MOUSEACTIVATE    = 0021h
WM_CHILDACTIVATE    = 0022h
WM_QUEUESYNC        = 0023h
WM_GETMINMAXINFO    = 0024h
WM_PAINTICON        = 0026h
WM_ICONERASEBKGND   = 0027h
WM_NEXTDLGCTL       = 0028h
WM_ALTTABACTIVE     = 0029h	;Internal
WM_SPOOLERSTATUS    = 002Ah
WM_DRAWITEM         = 002Bh
WM_MEASUREITEM      = 002Ch
WM_DELETEITEM       = 002Dh
WM_VKEYTOITEM       = 002Eh
WM_CHARTOITEM       = 002Fh
WM_SETFONT          = 0030h
WM_GETFONT          = 0031h
WM_SETHOTKEY        = 0032h     ;Internal
WM_GETHOTKEY        = 0033h     ;Internal
WM_FILESYSCHANGE    = 0034h	;Internal
WM_ISACTIVEICON     = 0035h	;Internal
WM_UNUSED0036       = 0036h	;Internal
WM_QUERYDRAGICON    = 0037h
WM_COMPAREITEM	    = 0039h
WM_TESTING	    = 0040h	;Internal
WM_COMPACTING       = 0041h
;                     0042h	;Internal
;                     0043h	;Internal
IFNDEF NOWIN31
WM_COMMNOTIFY       = 0044h
;                   = 0045h     ;Internal
WM_WINDOWPOSCHANGING= 0046h
WM_WINDOWPOSCHANGED = 0047h
WM_POWER            = 0048h
ENDIF


WM_NCCREATE         = 0081h
WM_NCDESTROY        = 0082h
WM_NCCALCSIZE       = 0083h
WM_NCHITTEST        = 0084h
WM_NCPAINT          = 0085h
WM_NCACTIVATE       = 0086h
WM_GETDLGCODE       = 0087h
WM_SYNCPAINT        = 0088h	;Internal
WM_SYNCTASK         = 0089h	;Internal
WM_NCMOUSEMOVE      = 00A0h
WM_NCLBUTTONDOWN    = 00A1h
WM_NCLBUTTONUP      = 00A2h
WM_NCLBUTTONDBLCLK  = 00A3h
WM_NCRBUTTONDOWN    = 00A4h
WM_NCRBUTTONUP      = 00A5h
WM_NCRBUTTONDBLCLK  = 00A6h
WM_NCMBUTTONDOWN    = 00A7h
WM_NCMBUTTONUP      = 00A8h
WM_NCMBUTTONDBLCLK  = 00A9h

WM_KEYFIRST         = 0100h
WM_KEYDOWN          = 0100h
WM_KEYUP            = 0101h
WM_CHAR             = 0102h
WM_DEADCHAR         = 0103h
WM_SYSKEYDOWN       = 0104h
WM_SYSKEYUP         = 0105h
WM_SYSCHAR          = 0106h
WM_SYSDEADCHAR      = 0107h
WM_YOMICHAR         = 0108h	;Internal
WM_KEYLAST          = 0108h

WM_CONVERTREQUEST   = 010Ah	;Internal
WM_CONVERTRESULT    = 010Bh	;Internal
WM_INITDIALOG       = 0110h
WM_COMMAND          = 0111h
WM_SYSCOMMAND       = 0112h
WM_TIMER            = 0113h
WM_HSCROLL          = 0114h
WM_VSCROLL          = 0115h
WM_INITMENU         = 0116h
WM_INITMENUPOPUP    = 0117h
WM_SYSTIMER         = 0118h	;Internal
WM_MENUSELECT       = 011Fh
WM_MENUCHAR         = 0120h
WM_ENTERIDLE        = 0121h

WM_LBTRACKPOINT     = 0131h	;Internal
			  
WM_MOUSEFIRST       = 0200h
WM_MOUSEMOVE        = 0200h
WM_LBUTTONDOWN      = 0201h
WM_LBUTTONUP        = 0202h
WM_LBUTTONDBLCLK    = 0203h
WM_RBUTTONDOWN      = 0204h
WM_RBUTTONUP        = 0205h
WM_RBUTTONDBLCLK    = 0206h
WM_MBUTTONDOWN      = 0207h
WM_MBUTTONUP        = 0208h
WM_MBUTTONDBLCLK    = 0209h
WM_MOUSELAST        = 0209h

WM_PARENTNOTIFY     = 0210h
WM_ENTERMENULOOP    = 0211h	;Internal
WM_EXITMENULOOP     = 0212h	;Internal
WM_NEXTMENU         = 0213h	;Internal
WM_MDICREATE        = 0220h
WM_MDIDESTROY       = 0221h
WM_MDIACTIVATE      = 0222h
WM_MDIRESTORE       = 0223h
WM_MDINEXT          = 0224h
WM_MDIMAXIMIZE      = 0225h
WM_MDITILE          = 0226h
WM_MDICASCADE       = 0227h
WM_MDIICONARRANGE   = 0228h
WM_MDIGETACTIVE     = 0229h
WM_DROPOBJECT       = 022Ah	;Internal
WM_QUERYDROPOBJECT  = 022Bh	;Internal
WM_BEGINDRAG        = 022Ch	;Internal
WM_DRAGLOOP         = 022Dh	;Internal
WM_DRAGSELECT       = 022Eh	;Internal
WM_DRAGMOVE         = 022Fh	;Internal
WM_MDISETMENU       = 0230h
WM_ENTERSIZEMOVE    = 0231h	;Internal
WM_EXITSIZEMOVE     = 0232h	;Internal
WM_DROPFILES	    = 0233h

WM_KANJIFIRST       = 0280h	;Internal
WM_KANJILAST        = 029Fh	;Internal

WM_CUT              = 0300h
WM_COPY             = 0301h
WM_PASTE            = 0302h
WM_CLEAR            = 0303h
WM_UNDO             = 0304h
WM_RENDERFORMAT     = 0305h
WM_RENDERALLFORMATS = 0306h
WM_DESTROYCLIPBOARD = 0307h
WM_DRAWCLIPBOARD    = 0308h
WM_PAINTCLIPBOARD   = 0309h
WM_VSCROLLCLIPBOARD = 030Ah
WM_SIZECLIPBOARD    = 030Bh
WM_ASKCBFORMATNAME  = 030Ch
WM_CHANGECBCHAIN    = 030Dh
WM_HSCROLLCLIPBOARD = 030Eh
WM_QUERYNEWPALETTE  = 030Fh
WM_PALETTEGONNACHANGE = 0310h	;Internal
WM_PALETTEISCHANGING = 0310h
WM_CHANGEPALETTE    = 0311h	;Internal
WM_PALETTECHANGED   = 0311h

IFNDEF NOWIN31
WM_PENWINFIRST      equ 0380h
WM_PENWINLAST       equ 038Fh

WM_INTERNAL_COALESCE_FIRST equ 0390h	 ;Internal

WM_COALESCE_FIRST  equ 0390h
WM_COALESCE_LAST   equ 039Fh

; The following message range reserved   ;Internal
; for multi-media                        ;Internal

WM_MM_RESERVED_FIRST  equ 03A0h          ;Internal
WM_MM_RESERVED_LAST   equ 03DFh          ;Internal

WM_INTERNAL_COALESCE_LAST equ (WM_MM_RESERVED_FIRST+16)	;Internal

ENDIF

WM_INTERNAL_DDE_FIRST equ 03E0h    ;Internal
WM_INTERNAL_DDE_LAST  equ 03EFh    ;Internal

; The following messages are reserved for CBT ;Internal
WM_CBT_RESERVED_FIRST equ 03F0h    ;Internal
WM_CBT_RESERVED_LAST  equ 03FFh    ;Internal

;  private window messages start here
WM_USER             = 0400H
ENDIF           ; NOWM

; WM_MOUSEACTIVATE Return Codes
MA_ACTIVATE       =  1
MA_ACTIVATEANDEAT =  2
MA_NOACTIVATE     =  3

; Size message commands
SIZENORMAL       = 0
SIZEICONIC       = 1
SIZEFULLSCREEN   = 2
SIZEZOOMSHOW     = 3
SIZEZOOMHIDE     = 4

; ShowWindow() Commands
SW_HIDE            = 0
SW_SHOWNORMAL      = 1
SW_NORMAL          = 1
SW_SHOWMINIMIZED   = 2
SW_SHOWMAXIMIZED   = 3
SW_MAXIMIZE        = 3
SW_SHOWNOACTIVATE  = 4
SW_SHOW            = 5
SW_MINIMIZE        = 6
SW_SHOWMINNOACTIVE = 7
SW_SHOWNA          = 8
SW_RESTORE         = 9

; Old ShowWindow() Commands
HIDE_WINDOW        = 0
SHOW_OPENWINDOW    = 1
SHOW_ICONWINDOW    = 2
SHOW_FULLSCREEN    = 3
SHOW_OPENNOACTIVATE= 4

;  identifiers for the WM_SHOWWINDOW message
SW_PARENTCLOSING =  1
SW_OTHERZOOM     =  2
SW_PARENTOPENING =  3
SW_OTHERUNZOOM   =  4
;
; Key state masks for mouse messages
;
MK_LBUTTON       = 0001h
MK_RBUTTON       = 0002h
MK_SHIFT         = 0004h
MK_CONTROL       = 0008h
MK_MBUTTON       = 0010h
;
; Class styles
;
CS_VREDRAW         = 0001h
CS_HREDRAW         = 0002h
CS_KEYCVTWINDOW    = 0004H
CS_DBLCLKS         = 0008h
; 		     0010h reserved
CS_OWNDC           = 0020h
CS_CLASSDC         = 0040h
CS_PARENTDC        = 0080h
CS_NOKEYCVT        = 0100h
CS_SAVEBITS        = 0800h
CS_NOCLOSE         = 0200h
CS_BYTEALIGNCLIENT = 1000h
CS_BYTEALIGNWINDOW = 2000h
CS_GLOBALCLASS     = 4000h    ; Global window class

;
; Special CreateWindow position value
;
CW_USEDEFAULT	EQU    8000h

;
; Windows styles (the high words)
;
WS_OVERLAPPED   = 00000h
WS_ICONICPOPUP  = 0C000h
WS_POPUP        = 08000h
WS_CHILD        = 04000h
WS_MINIMIZE     = 02000h
WS_VISIBLE      = 01000h
WS_DISABLED     = 00800h
WS_CLIPSIBLINGS = 00400h
WS_CLIPCHILDREN = 00200h
WS_MAXIMIZE     = 00100h
WS_CAPTION      = 000C0h     ; WS_BORDER | WS_DLGFRAME
WS_BORDER       = 00080h
WS_DLGFRAME     = 00040h
WS_VSCROLL      = 00020h
WS_HSCROLL      = 00010h
WS_SYSMENU      = 00008h
WS_THICKFRAME   = 00004h
WS_HREDRAW      = 00002h
WS_VREDRAW      = 00001h
WS_GROUP        = 00002h
WS_TABSTOP      = 00001h
WS_MINIMIZEBOX  = 00002h
WS_MAXIMIZEBOX  = 00001h

; Common Window Styles

WS_OVERLAPPEDWINDOW = WS_OVERLAPPED + WS_CAPTION + WS_SYSMENU + WS_THICKFRAME + WS_MINIMIZEBOX + WS_MAXIMIZEBOX
WS_POPUPWINDOW  = WS_POPUP + WS_BORDER + WS_SYSMENU
WS_CHILDWINDOW  = WS_CHILD
WS_TILEDWINDOW  = WS_OVERLAPPEDWINDOW

WS_TILED        = WS_OVERLAPPED
WS_ICONIC       = WS_MINIMIZE
WS_SIZEBOX      = WS_THICKFRAME

; Extended Window Styles (low words)
WS_EX_DLGMODALFRAME  = 0001
WS_EX_DRAGOBJECT     = 0002
WS_EX_NOPARENTNOTIFY = 0004
WS_EX_TOPMOST        = 0008

;
; predefined clipboard formats
;
CF_TEXT         =  1
CF_BITMAP       =  2
CF_METAFILEPICT =  3
CF_SYLK         =  4
CF_DIF          =  5
CF_TIFF         =  6
CF_OEMTEXT      =  7
CF_DIB          =  8
CF_PALETTE      =  9
CF_PENDATA      = 10
CF_RIFF         = 11
CF_WAVE         = 12

CF_OWNERDISPLAY = 80h       ; owner display
CF_DSPTEXT      = 81h       ; display text
CF_DSPBITMAP    = 82h       ; display bitmap
CF_DSPMETAFILEPICT  = 83h   ; display metafile
;
; Private clipboard format range
;
CF_PRIVATEFIRST       = 200h       ; Anything in this range doesn't
CF_PRIVATELAST        = 2ffh       ; get GlobalFree'd
CF_GDIOBJFIRST        = 300h       ; Anything in this range gets
CF_GDIOBJLAST         = 3ffh       ; DeleteObject'ed


MAKEINTRESOURCE MACRO a
        mov     ax,a
        xor     dx,dx
        ENDM
;
;  Predefined resource types
;
RT_CURSOR       = 1              ; must be passed through MAKEINTRESOURCE
RT_BITMAP       = 2
RT_ICON         = 3
RT_MENU         = 4
RT_DIALOG       = 5
RT_STRING       = 6
RT_FONTDIR      = 7
RT_FONT         = 8
RT_ACCELERATOR  = 9
RT_RCDATA       = 10

;** NOTE: if any new resource types are introduced above this point, then the
;** value of DIFFERENCE must be changed.
;** (RT_GROUP_CURSOR - RT_CURSOR) must always be equal to DIFFERENCE
;** (RT_GROUP_ICON - RT_ICON) must always be equal to DIFFERENCE

DIFFERENCE       =   11

RT_GROUP_CURSOR  =   RT_CURSOR + DIFFERENCE
RT_GROUP_ICON    =   RT_ICON + DIFFERENCE



IFNDEF NOMDI
MDICREATESTRUCT     struc
    szClass	    dd ?
    szTitle	    dd ?
    hOwner	    dw ?
    x		    dw ?
    y		    dw ?
    cxc 	    dw ?
    cyc 	    dw ?
    style	    dd ?
MDICREATESTRUCT ends

CLIENTCREATESTRUCT  struc
    hWindowMenu     dw ?
    idFirstChild    dw ?
CLIENTCREATESTRUCT ends
ENDIF

; NOMDI


PALETTEENTRY	    struc
    peRed	    db ?
    peGreen	    db ?
    peBlue	    db ?
    peFlags	    db ?
PALETTEENTRY	    ends

; Logical Palette
LOGPALETTE	    struc
    palVersion	    dw ?
    palNumEntries   dw ?
    palPalEntry     db ?  ; array of PALETTEENTRY
LOGPALETTE	    ends

; DRAWITEMSTRUCT for ownerdraw
DRAWITEMSTRUCT	    struc
    drCtlType	      dw ?
    drCtlID	      dw ?
    dritemID	      dw ?
    dritemAction      dw ?
    dritemState       dw ?
    drhwndItem	      dw ?
    drhDC	      dw ?
    drrcItem	      DB size RECT dup(?)
    dritemData	      dd ?
DRAWITEMSTRUCT ends

; DELETEITEMSTRUCT for ownerdraw
DELETEITEMSTRUCT    struc
    deCtlType	      dw ?
    deCtlID	      dw ?
    deitemID	      dw ?
    dehwndItem	      dw ?
    deitemData	      dd ?
DELETEITEMSTRUCT ends

; MEASUREITEMSTRUCT for ownerdraw
MEASUREITEMSTRUCT   struc
    meCtlType	      dw ?
    meCtlID	      dw ?
    meitemID	      dw ?
    meitemWidth       dw ?
    meitemHeight      dw ?
    meitemData	      dd ?
MEASUREITEMSTRUCT ends

; COMPAREITEMSTUCT for ownerdraw sorting
COMPAREITEMSTRUCT   struc
    coCtlType   dw ?
    coCtlID     dw ?
    cohwndItem  dw ?
    coitemID1   dw ?
    coitemData1 dd ?
    coitemID2   dw ?
    coitemData2 dd ?
COMPAREITEMSTRUCT   ends

; Owner draw control types
ODT_MENU      =  1
ODT_LISTBOX   =  2
ODT_COMBOBOX  =  3
ODT_BUTTON    =  4

; Owner draw actions
ODA_DRAWENTIRE = 1
ODA_SELECT     = 2
ODA_FOCUS      = 4

; Owner draw state
ODS_SELECTED   = 0001h
ODS_GRAYED     = 0002h
ODS_DISABLED   = 0004h
ODS_CHECKED    = 0008h
ODS_FOCUS      = 0010h

; PeekMessage() Options
PM_NOREMOVE    = 0000h
PM_REMOVE      = 0001h
PM_NOYIELD     = 0002h

; SetWindowPos Flags
SWP_NOSIZE       =  0001h
SWP_NOMOVE       =  0002h
SWP_NOZORDER     =  0004h
SWP_NOREDRAW     =  0008h
SWP_NOACTIVATE   =  0010h
SWP_DRAWFRAME    =  0020h
SWP_SHOWWINDOW   =  0040h
SWP_HIDEWINDOW   =  0080h
SWP_NOCOPYBITS   =  0100h
SWP_NOREPOSITION =  0200h


IFNDEF NOWINMESSAGES

; Listbox messages
LB_ADDSTRING	       = (WM_USER+1)
LB_INSERTSTRING        = (WM_USER+2)
LB_DELETESTRING        = (WM_USER+3)
LB_RESETCONTENT        = (WM_USER+5)
LB_SETSEL	       = (WM_USER+6)
LB_SETCURSEL	       = (WM_USER+7)
LB_GETSEL	       = (WM_USER+8)
LB_GETCURSEL	       = (WM_USER+9)
LB_GETTEXT	       = (WM_USER+10)
LB_GETTEXTLEN	       = (WM_USER+11)
LB_GETCOUNT	       = (WM_USER+12)
LB_SELECTSTRING        = (WM_USER+13)
LB_DIR		       = (WM_USER+14)
LB_GETTOPINDEX	       = (WM_USER+15)
LB_FINDSTRING	       = (WM_USER+16)
LB_GETSELCOUNT	       = (WM_USER+17)
LB_GETSELITEMS	       = (WM_USER+18)
LB_SETTABSTOPS	       = (WM_USER+19)
LB_GETHORIZONTALEXTENT = (WM_USER+20)
LB_SETHORIZONTALEXTENT = (WM_USER+21)
LB_ADDFILE	       = (WM_USER+23)	;Internal
LB_SETTOPINDEX	       = (WM_USER+24)
LB_GETITEMRECT	       = (WM_USER+25)
LB_GETITEMDATA	       = (WM_USER+26)
LB_SETITEMDATA	       = (WM_USER+27)
LB_SELITEMRANGE        = (WM_USER+28)
LB_SETANCHORINDEX      = (WM_USER+29)	;Internal
LB_GETANCHORINDEX      = (WM_USER+30)	;Internal
LB_SETCARETINDEX       = (WM_USER+31)
LB_GETCARETINDEX       = (WM_USER+32)
IFNDEF NOWIN31
LB_SETITEMHEIGHT       = (WM_USER+33)
LB_GETITEMHEIGHT       = (WM_USER+34)
LB_FINDSTRINGEXACT     = (WM_USER+35)
ENDIF
LBCB_CARETON           = (WM_USER+36)   ;Internal
LBCB_CARETOFF          = (WM_USER+37)   ;Internal
LB_MSGMAX	       = (WM_USER+38)   ;Internal

ENDIF
; NOWINMESSAGES

; Listbox Styles
LBS_NOTIFY            = 0001h
LBS_SORT              = 0002h
LBS_NOREDRAW          = 0004h
LBS_MULTIPLESEL       = 0008h
LBS_OWNERDRAWFIXED    = 0010h
LBS_OWNERDRAWVARIABLE = 0020h
LBS_HASSTRINGS        = 0040h
LBS_USETABSTOPS       = 0080h
LBS_NOINTEGRALHEIGHT  = 0100h
LBS_MULTICOLUMN       = 0200h
LBS_WANTKEYBOARDINPUT = 0400h
LBS_EXTENDEDSEL	      = 0800h
LBS_STANDARD          = LBS_NOTIFY + LBS_SORT + WS_VSCROLL + WS_BORDER
LBS_DISABLENOSCROLL   = 1000h

; Listbox Notification Codes
LBN_ERRSPACE      =  (-2)
LBN_SELCHANGE     =  1
LBN_DBLCLK        =  2
LBN_SELCANCEL     =  3
LBN_SETFOCUS      =  4
LBN_KILLFOCUS     =  5

IFNDEF NOWINMESSAGES

; Edit Control Messages
EM_GETSEL              = (WM_USER+0)
EM_SETSEL              = (WM_USER+1)
EM_GETRECT             = (WM_USER+2)
EM_SETRECT             = (WM_USER+3)
EM_SETRECTNP           = (WM_USER+4)
EM_SCROLL              = (WM_USER+5)
EM_LINESCROLL          = (WM_USER+6)
EM_GETMODIFY           = (WM_USER+8)
EM_SETMODIFY           = (WM_USER+9)
EM_GETLINECOUNT        = (WM_USER+10)
EM_LINEINDEX           = (WM_USER+11)
EM_SETHANDLE           = (WM_USER+12)
EM_GETHANDLE           = (WM_USER+13)
EM_GETTHUMB            = (WM_USER+14) ;Internal
EM_LINELENGTH          = (WM_USER+17)
EM_REPLACESEL          = (WM_USER+18)
EM_SETFONT             = (WM_USER+19)
EM_GETLINE             = (WM_USER+20)
EM_LIMITTEXT           = (WM_USER+21)
EM_CANUNDO             = (WM_USER+22)
EM_UNDO                = (WM_USER+23)
EM_FMTLINES            = (WM_USER+24)
EM_LINEFROMCHAR        = (WM_USER+25)
EM_SETWORDBREAK        = (WM_USER+26)
EM_SETTABSTOPS         = (WM_USER+27)
EM_SETPASSWORDCHAR     = (WM_USER+28)
EM_EMPTYUNDOBUFFER     = (WM_USER+29)
IFNDEF NOWIN31
EM_GETFIRSTVISIBLELINE = (WM_USER+30)
EM_SETREADONLY         = (WM_USER+31)
EM_SETWORDBREAKPROC    = (WM_USER+32)
EM_GETWORDBREAKPROC    = (WM_USER+33)
EM_GETPASSWORDCHAR     = (WM_USER+34)
ENDIF
EM_MSGMAX              = (WM_USER+35) ;Internal

ENDIF
; NOWINMESSAGES


; Edit Control Styles (low word)
ES_LEFT            = 0000h
ES_CENTER          = 0001h
ES_RIGHT           = 0002h
ES_MULTILINE       = 0004h
ES_UPPERCASE       = 0008h
ES_LOWERCASE       = 0010h
ES_PASSWORD        = 0020h
ES_AUTOVSCROLL     = 0040h
ES_AUTOHSCROLL     = 0080h
ES_NOHIDESEL       = 0100h
ES_OEMCONVERT      = 0400h
IFNDEF NOWIN31
ES_READONLY        = 0800h
ES_WANTRETURN      = 1000h
ENDIF


; Edit Control Notification Codes
EN_SETFOCUS        = 0100h
EN_KILLFOCUS       = 0200h
EN_CHANGE          = 0300h
EN_UPDATE          = 0400h
EN_ERRSPACE        = 0500h
EN_MAXTEXT         = 0501h
EN_HSCROLL         = 0601h
EN_VSCROLL         = 0602h

IFNDEF NOWINMESSAGES

; Button Control Messages
BM_GETCHECK	   = (WM_USER+0)
BM_SETCHECK	   = (WM_USER+1)
BM_GETSTATE	   = (WM_USER+2)
BM_SETSTATE	   = (WM_USER+3)
BM_SETSTYLE	   = (WM_USER+4)

ENDIF
; NOWINMESSAGES

; Button Control Styles (low word)
BS_PUSHBUTTON      = 00h
BS_DEFPUSHBUTTON   = 01h
BS_CHECKBOX        = 02h
BS_AUTOCHECKBOX    = 03h
BS_RADIOBUTTON     = 04h
BS_3STATE          = 05h
BS_AUTO3STATE      = 06h
BS_GROUPBOX        = 07h
BS_USERBUTTON      = 08h
BS_AUTORADIOBUTTON = 09h
BS_PUSHBOX         = 0Ah  		;Internal
BS_OWNERDRAW       = 0Bh
BS_LEFTTEXT        = 20h

; User Button Notification Codes
BN_CLICKED         = 0
BN_PAINT           = 1
BN_HILITE          = 2
BN_UNHILITE        = 3
BN_DISABLE         = 4
BN_DOUBLECLICKED   = 5

; Dialog Styles (low words)
DS_ABSALIGN        = 01h
DS_SYSMODAL        = 02h
DS_LOCALEDIT       = 20h  ;/* Edit items get Local storage. */
DS_SETFONT         = 40h  ;/* User specified font for Dlg controls */
DS_MODALFRAME      = 80h  ;/* Can be combined with WS_CAPTION  */
DS_NOIDLEMSG       = 100h ;/* WM_ENTERIDLE message will not be sent */

IFNDEF NOWINMESSAGES

; Dialog box messages
DM_GETDEFID	   = (WM_USER+0)
DM_SETDEFID	   = (WM_USER+1)

ENDIF   ;NOWINMESSAGES

; Dialog Codes
DLGC_WANTARROWS     = 0001h    ;  /* Control wants arrow keys         */
DLGC_WANTTAB        = 0002h    ;  /* Control wants tab keys           */
DLGC_WANTALLKEYS    = 0004h    ;  /* Control wants all keys           */
DLGC_WANTMESSAGE    = 0004h    ;  /* Pass message to control          */
DLGC_HASSETSEL      = 0008h    ;  /* Understands EM_SETSEL message    */
DLGC_DEFPUSHBUTTON  = 0010h    ;  /* Default pushbutton               */
DLGC_UNDEFPUSHBUTTON= 0020h    ;  /* Non-default pushbutton           */
DLGC_RADIOBUTTON    = 0040h    ;  /* Radio button                     */
DLGC_WANTCHARS      = 0080h    ;  /* Want WM_CHAR messages            */
DLGC_STATIC         = 0100h    ;  /* Static item: don't include       */
DLGC_BUTTON         = 2000h    ;  /* Button item: can be checked      */

; Combo Box return Values
CB_OKAY          =   0
CB_ERR           =   (-1)
CB_ERRSPACE      =   (-2)

; Combo Box Notification Codes
CBN_ERRSPACE     =   (-1)
CBN_SELCHANGE    =   1
CBN_DBLCLK       =   2
CBN_SETFOCUS     =   3
CBN_KILLFOCUS    =   4
CBN_EDITCHANGE   =   5
CBN_EDITUPDATE   =   6
CBN_DROPDOWN     =   7

; Combo Box styles (low words)
CBS_SIMPLE           = 0001h
CBS_DROPDOWN         = 0002h
CBS_DROPDOWNLIST     = 0003h
CBS_OWNERDRAWFIXED   = 0010h
CBS_OWNERDRAWVARIABLE= 0020h
CBS_AUTOHSCROLL      = 0040h
CBS_OEMCONVERT       = 0080h
CBS_SORT             = 0100h
CBS_HASSTRINGS       = 0200h
CBS_NOINTEGRALHEIGHT = 0400h

IFNDEF NOWINMESSAGES

; Combo Box messages
CB_GETEDITSEL	         = (WM_USER+0)
CB_LIMITTEXT	         = (WM_USER+1)
CB_SETEDITSEL	         = (WM_USER+2)
CB_ADDSTRING	         = (WM_USER+3)
CB_DELETESTRING          = (WM_USER+4)
CB_DIR		         = (WM_USER+5)
CB_GETCOUNT	         = (WM_USER+6)
CB_GETCURSEL	         = (WM_USER+7)
CB_GETLBTEXT	         = (WM_USER+8)
CB_GETLBTEXTLEN          = (WM_USER+9)
CB_INSERTSTRING          = (WM_USER+10)
CB_RESETCONTENT          = (WM_USER+11)
CB_FINDSTRING	         = (WM_USER+12)
CB_SELECTSTRING          = (WM_USER+13)
CB_SETCURSEL	         = (WM_USER+14)
CB_SHOWDROPDOWN          = (WM_USER+15)
CB_GETITEMDATA           = (WM_USER+16)
CB_SETITEMDATA           = (WM_USER+17)
IFNDEF NOWIN31
CB_GETDROPPEDCONTROLRECT = (WM_USER+18)
CB_SETITEMHEIGHT         = (WM_USER+19)
CB_GETITEMHEIGHT         = (WM_USER+20)
CB_SETEXTENDEDUI         = (WM_USER+21)
CB_GETEXTENDEDUI         = (WM_USER+22)
CB_GETDROPPEDSTATE       = (WM_USER+23)
CB_FINDSTRINGEXACT       = (WM_USER+24)
ENDIF
CB_MSGMAX	         = (WM_USER+25)		;Internal

ENDIF ; NOWINMESSAGES

; Static Control styles (low word)
SS_LEFT            = 00h
SS_CENTER          = 01h
SS_RIGHT           = 02h
SS_ICON            = 03h
SS_BLACKRECT       = 04h
SS_GRAYRECT        = 05h
SS_WHITERECT       = 06h
SS_BLACKFRAME      = 07h
SS_GRAYFRAME       = 08h
SS_WHITEFRAME      = 09h
SS_USERITEM        = 0Ah    ;Internal
SS_SIMPLE          = 0Bh
SS_LEFTNOWORDWRAP  = 0Ch
SS_NOPREFIX        = 80h    ; Don't do "&" character translation

IFNDEF NOWIN31
IFNDEF NOWINMESSAGES

;Static Control Messages
STM_SETICON        = (WM_USER+0)
STM_GETICON        = (WM_USER+1)
STM_MSGMAX         = (WM_USER+2)	;Internal
ENDIF
ENDIF

; Scroll Bar Styles (low word)
SBS_HORZ                    = 0000h
SBS_VERT                    = 0001h
SBS_TOPALIGN                = 0002h
SBS_LEFTALIGN               = 0002h
SBS_BOTTOMALIGN             = 0004h
SBS_RIGHTALIGN              = 0004h
SBS_SIZEBOXTOPLEFTALIGN     = 0002h
SBS_SIZEBOXBOTTOMRIGHTALIGN = 0004h
SBS_SIZEBOX                 = 0008h

IFNDEF NOSYSMETRICS

; GetSystemMetrics() codes
SM_CXSCREEN           =  0
SM_CYSCREEN           =  1
SM_CXVSCROLL          =  2
SM_CYHSCROLL          =  3
SM_CYCAPTION          =  4
SM_CXBORDER           =  5
SM_CYBORDER           =  6
SM_CXDLGFRAME         =  7
SM_CYDLGFRAME         =  8
SM_CYVTHUMB           =  9
SM_CXHTHUMB           =  10
SM_CXICON             =  11
SM_CYICON             =  12
SM_CXCURSOR           =  13
SM_CYCURSOR           =  14
SM_CYMENU             =  15
SM_CXFULLSCREEN       =  16
SM_CYFULLSCREEN       =  17
SM_CYKANJIWINDOW      =  18
SM_MOUSEPRESENT       =  19
SM_CYVSCROLL          =  20
SM_CXHSCROLL          =  21
SM_DEBUG              =  22
SM_SWAPBUTTON         =  23
SM_RESERVED1          =  24
SM_RESERVED2          =  25
SM_RESERVED3          =  26
SM_RESERVED4          =  27
SM_CXMIN              =  28
SM_CYMIN              =  29
SM_CXSIZE             =  30
SM_CYSIZE             =  31
SM_CXFRAME            =  32
SM_CYFRAME            =  33
SM_CXMINTRACK         =  34
SM_CYMINTRACK         =  35
IFNDEF NOWIN31
SM_CXDOUBLECLK        =  36
SM_CYDOUBLECLK        =  37
SM_CXICONSPACING      =  38
SM_CYICONSPACING      =  39
SM_MENUDROPALIGNMENT  =  40
SM_PENWINDOWS         =  41
SM_DBCSENABLED        =  42
ENDIF
SM_CMETRICSMAX        =  76

ENDIF   ;NOSYSMETRICS

IFNDEF  NOCOLOR

COLOR_SCROLLBAR           = 0
COLOR_BACKGROUND          = 1
COLOR_ACTIVECAPTION       = 2
COLOR_INACTIVECAPTION     = 3
COLOR_MENU                = 4
COLOR_WINDOW              = 5
COLOR_WINDOWFRAME         = 6
COLOR_MENUTEXT            = 7
COLOR_WINDOWTEXT          = 8
COLOR_CAPTIONTEXT         = 9
COLOR_ACTIVEBORDER        = 10
COLOR_INACTIVEBORDER      = 11
COLOR_APPWORKSPACE        = 12
COLOR_HIGHLIGHT           = 13
COLOR_HIGHLIGHTTEXT       = 14
COLOR_BTNFACE             = 15
COLOR_BTNSHADOW           = 16
COLOR_GRAYTEXT            = 17
COLOR_BTNTEXT             = 18
IFNDEF NOWIN31
COLOR_INACTIVECAPTIONTEXT = 19
COLOR_BTNHILIGHT          = 20
ENDIF
ENDIF   ;NOCOLOR

; Commands to pass WinHelp()
HELP_CONTEXT	=0001h	;/* Display topic in ulTopic */
HELP_QUIT	=0002h	;/* Terminate help */
HELP_INDEX	=0003h	;/* Display index */
HELP_HELPONHELP =0004h	;/* Display help on using help */
HELP_SETINDEX	=0005h	;/* Set the current Index for multi index help */
HELP_KEY	=0101h	;/* Display topic for keyword in offabData */

IFNDEF NOCOMM

NOPARITY        =   0
ODDPARITY       =   1
EVENPARITY      =   2
MARKPARITY      =   3
SPACEPARITY     =   4

ONESTOPBIT      =   0
ONE5STOPBITS    =   1
TWOSTOPBITS     =   2

IGNORE          =   0      ; /* Ignore signal    */
INFINITE        =   0FFFFh ; /* Infinite timeout */

; Error Flags
CE_RXOVER       =    0001h ; /* Receive Queue overflow       */
CE_OVERRUN      =    0002h ; /* Receive Overrun Error        */
CE_RXPARITY     =    0004h ; /* Receive Parity Error         */
CE_FRAME        =    0008h ; /* Receive Framing error        */
CE_BREAK        =    0010h ; /* Break Detected               */
CE_CTSTO        =    0020h ; /* CTS Timeout                  */
CE_DSRTO        =    0040h ; /* DSR Timeout                  */
CE_RLSDTO       =    0080h ; /* RLSD Timeout                 */
CE_TXFULL       =    0100h ; /* TX Queue is full             */
CE_PTO          =    0200h ; /* LPTx Timeout                 */
CE_IOE          =    0400h ; /* LPTx I/O Error               */
CE_DNS          =    0800h ; /* LPTx Device not selected     */
CE_OOP          =    1000h ; /* LPTx Out-Of-Paper            */
CE_MODE         =    8000h ; /* Requested mode unsupported   */

IE_BADID        =    (-1)  ;  /* Invalid or unsupported id    */
IE_OPEN         =    (-2)  ;  /* Device Already Open          */
IE_NOPEN        =    (-3)  ;  /* Device Not Open              */
IE_MEMORY       =    (-4)  ;  /* Unable to allocate queues    */
IE_DEFAULT      =    (-5)  ;  /* Error in default parameters  */
IE_HARDWARE     =    (-10) ;  /* Hardware Not Present         */
IE_BYTESIZE     =    (-11) ;  /* Illegal Byte Size            */
IE_BAUDRATE     =    (-12) ;  /* Unsupported BaudRate         */

; Events
EV_RXCHAR       =    0001h ; /* Any Character received       */
EV_RXFLAG       =    0002h ; /* Received certain character   */
EV_TXEMPTY      =    0004h ; /* Transmitt Queue Empty        */
EV_CTS          =    0008h ; /* CTS changed state            */
EV_DSR          =    0010h ; /* DSR changed state            */
EV_RLSD         =    0020h ; /* RLSD changed state           */
EV_BREAK        =    0040h ; /* BREAK received               */
EV_ERR          =    0080h ; /* Line status error occurred   */
EV_RING         =    0100h ; /* Ring signal detected         */
EV_PERR         =    0200h ; /* Printer error occured        */
EV_CTSS         =    0400h ; /* CTS state                    */
EV_DSRS         =    0800h ; /* DSR state                    */
EV_RLSDS        =    1000h ; /* RLSD state                   */
EV_RingTe       =    2000h ; /* Ring Trailing Edge Indicator */


; Escape Functions
SETXOFF         =    1     ;  /* Simulate XOFF received       */
SETXON          =    2     ;  /* Simulate XON received        */
SETRTS          =    3     ;  /* Set RTS high                 */
CLRRTS          =    4     ;  /* Set RTS low                  */
SETDTR          =    5     ;  /* Set DTR high                 */
CLRDTR          =    6     ;  /* Set DTR low                  */
RESETDEV        =    7     ;  /* Reset device if possible     */

LPTx            =    80h   ; /* Set if ID is for LPT device  */

IFNDEF NOWIN31
; new escape functions
GETMAXLPT   equ  8	   ; Max supported LPT id
GETMAXCOM   equ  9	   ; Max supported COM id
GETBASEIRQ  equ 10	   ; Get port base & irq for a port

; Comm Baud Rate indices
CBR_110     equ 0FF10h
CBR_300     equ 0FF11h
CBR_600     equ 0FF12h
CBR_1200    equ 0FF13h
CBR_2400    equ 0FF14h
CBR_4800    equ 0FF15h
CBR_9600    equ 0FF16h
CBR_14400   equ 0FF17h
CBR_19200   equ 0FF18h
;		0FF19h	(reserved)
;		0FF1Ah	(reserved)
CBR_38400   equ 0FF1Bh
;		0FF1Ch	(reserved)
;		0FF1Dh	(reserved)
;		0FF1Eh	(reserved)
CBR_56000   equ 0FF1Fh
;		0FF20h	(reserved)
;		0FF21h	(reserved)
;		0FF22h	(reserved)
CBR_128000  equ 0FF23h
;		0FF24h	(reserved)
;		0FF25h	(reserved)
;		0FF26h	(reserved)
CBR_256000  equ 0FF27h

; notifications passed in low word of lParam on WM_COMMNOTIFY messages
CN_RECEIVE  equ 1	    ; bytes are available in the input queue
CN_TRANSMIT equ 2	    ; fewer than wOutTrigger bytes still
			    ; remain in the output queue waiting
			    ; to be transmitted.
CN_EVENT    equ 4	    ; an enabled event has occurred

ENDIF


DCB     struc
    DCB_Id             db ?  ; /* Internal Device ID              */
    DCB_BaudRate       dw ?  ; /* Baudrate at which runing        */
    DCB_ByteSize       db ?  ; /* Number of bits/byte, 4-8        */
    DCB_Parity         db ?  ; /* 0-4=None,Odd,Even,Mark,Space    */
    DCB_StopBits       db ?  ; /* 0,1,2 = 1, 1.5, 2               */
    DCB_RlsTimeout     dw ?  ; /* Timeout for RLSD to be set      */
    DCB_CtsTimeout     dw ?  ; /* Timeout for CTS to be set       */
    DCB_DsrTimeout     dw ?  ; /* Timeout for DSR to be set       */

    DCB_BitMask1       db ?

    ;   BYTE fBinary: 1;     /* Binary Mode (skip EOF check     */
    ;   BYTE fRtsDisable:1;  /* Don't assert RTS at init time   */
    ;   BYTE fParity: 1;     /* Enable parity checking          */
    ;   BYTE fOutxCtsFlow:1; /* CTS handshaking on output       */
    ;   BYTE fOutxDsrFlow:1; /* DSR handshaking on output       */
    ;   BYTE fDummy: 2;      /* Reserved                        */
    ;   BYTE fDtrDisable:1;  /* Don't assert DTR at init time   */

    DCB_BitMask2       db ?

    ;   BYTE fOutX: 1;       /* Enable output X-ON/X-OFF        */
    ;   BYTE fInX: 1;        /* Enable input X-ON/X-OFF         */
    ;   BYTE fPeChar: 1;     /* Enable Parity Err Replacement   */
    ;   BYTE fNull: 1;       /* Enable Null stripping           */
    ;   BYTE fChEvt: 1;      /* Enable Rx character event.      */
    ;   BYTE fDtrflow: 1;    /* DTR handshake on input          */
    ;   BYTE fRtsflow: 1;    /* RTS handshake on input          */
    ;   BYTE fDummy2: 1;

    DCB_XonChar        db ? ; /* Tx and Rx X-ON character        */
    DCB_XoffChar       db ? ; /* Tx and Rx X-OFF character       */
    DCB_XonLim         dw ? ; /* Transmit X-ON threshold         */
    DCB_XoffLim        dw ? ; /* Transmit X-OFF threshold        */
    DCB_PeChar         db ? ; /* Parity error replacement char   */
    DCB_EofChar        db ? ; /* End of Input character          */
    DCB_EvtChar        db ? ; /* Recieved Event character        */
    DCB_TxDelay        dw ? ; /* Amount of time between chars    */
DCB     ends

COMSTAT     struc
    COMS_BitMask1   db ?

;    BYTE fCtsHold: 1;   /* Transmit is on CTS hold         */
;    BYTE fDsrHold: 1;   /* Transmit is on DSR hold         */
;    BYTE fRlsdHold: 1;  /* Transmit is on RLSD hold        */
;    BYTE fXoffHold: 1;  /* Received handshake              */
;    BYTE fXoffSent: 1;  /* Issued handshake                */
;    BYTE fEof: 1;       /* End of file character found     */
;    BYTE fTxim: 1;      /* Character being transmitted     */


    COMS_cbInQue    dw ?  ;   /* count of characters in Rx Queue */
    COMS_cbOutQue   dw ?  ;   /* count of characters in Tx Queue */
COMSTAT     ends

ENDIF       ;NOCOM

;
; Installable Driver Support
;
; Driver Messages
DRV_LOAD	    = 0001h
DRV_ENABLE	    = 0002h
DRV_OPEN	    = 0003h
DRV_CLOSE	    = 0004h
DRV_DISABLE	    = 0005h
DRV_FREE	    = 0006h
DRV_CONFIGURE	    = 0007h
DRV_QUERYCONFIGURE  = 0008h
DRV_INSTALL	    = 0009h
DRV_REMOVE	    = 000Ah
DRV_EXITSESSION	    = 000Bh
DRV_POWER	    = 000Fh
DRV_RESERVED	    = 0800h
DRV_USER	    = 4000h

;LPARAM of DRV_CONFIGURE message and return values
DRVCONFIGINFO struc
    DRVCNF_dwDCISize	      dw ?
    DRVCNF_lpszDCISectionName dd ?
    DRVCNF_lpszDCIAliasName   dd ?
DRVCONFIGINFO ends

DRVCNF_CANCEL	    = 0000h
DRVCNF_OK	    = 0001h
DRVCNF_RESTART	    = 0002h


IFNDEF  NOKERNEL
;
; Common Kernel errors
; 
ERR_GALLOC	= 01030h	; GlobalAlloc Failed
ERR_GREALLOC	= 01031h	; GlobalReAlloc Failed
ERR_GLOCK	= 01032h	; GlobalLock Failed
ERR_LALLOC	= 01033h	; LocalAlloc Failed
ERR_LREALLOC	= 01034h	; LocalReAlloc Failed
ERR_LLOCK	= 01035h	; LocalLock Failed
ERR_ALLOCRES	= 01036h	; AllocResource Failed
ERR_LOCKRES	= 01037h	; LockResource Failed
ERR_LOADMODULE  = 01038h	; LoadModule failed

;
; Common User Errors 
;
ERR_CREATEDLG	     =	01045h ; /* Create Dlg failure due to LoadMenu failure */
ERR_CREATEDLG2	     =	01046h ; /* Create Dlg failure due to CreateWindow Failure */
ERR_REGISTERCLASS    =	01047h ; /* RegisterClass failure due to Class already registered */
ERR_DCBUSY	     =	01048h ; /* DC Cache is full */
ERR_CREATEWND	     =	01049h ; /* Create Wnd failed due to class not found */
ERR_STRUCEXTRA	     =  01050h ; /* Unallocated Extra space is used */
ERR_LOADSTR	     =	01051h ; /* LoadString() failed */
ERR_LOADMENU	     =	01052h ; /* LoadMenu Failed     */
ERR_NESTEDBEGINPAINT =  01053h ; /* Nested BeginPaint() calls */
ERR_BADINDEX	     =  01054h ; /* Bad index to Get/Set Class/Window Word/Long */
ERR_CREATEMENU	     =	01055h ; /* Error creating menu */

;
; Common GDI Errors
;
ERR_CREATEDC	    = 01070h	; /* CreateDC/CreateIC etc., failure */
ERR_CREATEMETA      = 01071h	; /* CreateMetafile failure */
ERR_DELOBJSELECTED  = 01072h	; /* Bitmap being deleted is selected into DC */
ERR_SELBITMAP	    = 01073h	; /* Bitmap being selected is already selected elsewhere */

ENDIF	    ;NOKERNEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\winnls.h ===
/***********************************************************************\
*                                                                      *
* WINNLS.H - East Asia input method editor (DBCS_IME) definitions      *
*                                                                      *
*                                                                      *
* Copyright (c) 1990  Microsoft Corporation	                           *
*                                                                      *
\***********************************************************************/

typedef struct _tagDATETIME {
    WORD	year;
    WORD	month;
    WORD	day;
    WORD	hour;
    WORD	min;
    WORD	sec;
} DATETIME;

typedef struct _tagIMEPRO {
    HWND	hWnd;
    DATETIME	InstDate;
    WORD	wVersion;
    BYTE	szDescription[50];
    BYTE	szName[80];
    BYTE	szOptions[30];
#ifdef TAIWAN
    BYTE	szUsrFontName[80];
    BOOL	fEnable;
#endif
} IMEPRO;
typedef IMEPRO      *PIMEPRO;
typedef IMEPRO near *NPIMEPRO;
typedef IMEPRO far  *LPIMEPRO;

void FAR PASCAL InquireWINNLS( void );			/* ;Internal */
BOOL FAR PASCAL IMPGetIME( HWND, LPIMEPRO );
BOOL FAR PASCAL IMPQueryIME( LPIMEPRO );
BOOL FAR PASCAL IMPDeleteIME( LPIMEPRO );
BOOL FAR PASCAL IMPAddIME( LPIMEPRO );
BOOL FAR PASCAL IMPSetIME( HWND, LPIMEPRO );
BOOL FAR PASCAL IMEModifyIME( LPSTR, LPIMEPRO );	/* ;Internal */
WORD FAR PASCAL IMPGetDefaultIME( LPIMEPRO );		/* ;Internal */
WORD FAR PASCAL IMPSetDefaultIME( LPIMEPRO );		/* ;Internal */
BOOL FAR PASCAL WINNLSSetIMEHandle( LPSTR, HWND );	/* ;Internal */
BOOL FAR PASCAL WINNLSSetIMEStatus( HWND, BOOL );	/* ;Internal */

BOOL FAR PASCAL WINNLSEnableIME( HWND, BOOL );
WORD FAR PASCAL WINNLSGetKeyState( void );		/* ;Internal */
VOID FAR PASCAL WINNLSSetKeyState( WORD );		/* ;Internal */
BOOL FAR PASCAL WINNLSGetEnableStatus( HWND );
BOOL FAR PASCAL WINNLSSetKeyboardHook (BOOL);		/* ;Internal */

#ifdef KOREA
BOOL FAR PASCAL WINNLSSetIMEHotkey( HWND, WORD, WORD );
LONG FAR PASCAL WINNLSGetIMEHotkey( HWND );
#else
BOOL FAR PASCAL WINNLSSetIMEHotkey( HWND, WORD );	/* ;Internal */
WORD FAR PASCAL WINNLSGetIMEHotkey( HWND );
#endif //KOREA

#ifdef TAIWAN
typedef HANDLE HIME;

/* Extended IME information*/
typedef struct _tagIMEInfo {
    BYTE	szIMEName[7];
    BYTE	szPrompMessage[32];
    WORD	nMaxKeyLen;
} IMEINFO;
typedef IMEINFO far *LPIMEINFO;

HWND FAR PASCAL WINNLSGetSysIME(void);
void FAR PASCAL WINNLSSetSysIME(HWND);
BOOL FAR PASCAL SwitchIM( WORD , WORD );
BOOL ToNextIM(void);
void SetFullAbcState(BOOL);
BOOL EngChiSwitch(BOOL);
void FAR PASCAL TimerProc(HWND,int,WORD,LONG);
HWND FAR PASCAL IMPGetFullShapeHWnd(void);
void FAR PASCAL IMPSetFullShapeHWnd(HWND);
BOOL FAR PASCAL IMPSetFirstIME(HWND,LPIMEPRO);
BOOL FAR PASCAL IMPGetFirstIME(HWND,LPIMEPRO);
BOOL FAR PASCAL IMPDialogIME(LPIMEPRO,HWND);
BOOL FAR PASCAL IMPEnableIME(HWND,LPIMEPRO,BOOL);
BOOL FAR PASCAL IMPSetUsrFont(HWND,LPIMEPRO);
BOOL FAR PASCAL WINNLSQueryIMEInfo(HWND,HWND,LPIMEINFO);
#endif //TAIWAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\wpnpinst\wow\inc\wmsyserr.h ===
/****************************************************************************/
/*									    */
/*  WMSYSERR.H -							    */
/*									    */
/*	Message Box String Defines					    */
/*									    */
/****************************************************************************/

/* SysErrorBox() stuff */

#define MAX_SEB_STYLES  7  /* number of SEB_* values */

#define  SEB_OK         1  /* Button with "OK".     */
#define  SEB_CANCEL     2  /* Button with "Cancel"  */
#define  SEB_YES        3  /* Button with "&Yes"     */
#define  SEB_NO         4  /* Button with "&No"      */
#define  SEB_RETRY      5  /* Button with "&Retry"   */
#define  SEB_ABORT      6  /* Button with "&Abort"   */
#define  SEB_IGNORE     7  /* Button with "&Ignore"  */

#define  SEB_DEFBUTTON  0x8000  /* Mask to make this button default */

#define  SEB_BTN1       1  /* Button 1 was selected */
#define  SEB_BTN2       2  /* Button 1 was selected */
#define  SEB_BTN3       3  /* Button 1 was selected */

/* SysErrorBox() button structure definition */

typedef struct tagSEBBTN
  {
    unsigned int style;
    BOOL         finvert;
    RECT         rcbtn;
    POINT        pttext;
    LPSTR        psztext;
    BYTE         chaccel;
  } SEBBTN;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\publish\lmon.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation
All rights reserved

Module Name:

    lmon.h

--*/


typedef struct _PORT_INFO_FFA {
    LPSTR   pName;
    DWORD   cbMonitorData;
    LPBYTE  pMonitorData;
} PORT_INFO_FFA, *PPORT_INFO_FFA, *LPPORT_INFO_FFA;

typedef struct _PORT_INFO_FFW {
    LPWSTR  pName;
    DWORD   cbMonitorData;
    LPBYTE  pMonitorData;
} PORT_INFO_FFW, *PPORT_INFO_FFW, *LPPORT_INFO_FFW;

#ifdef UNICODE
#define PORT_INFO_FF PORT_INFO_FFW
#define PPORT_INFO_FF PPORT_INFO_FFW
#define LPPORT_INFO_FF LPPORT_INFO_FFW
#else
#define PORT_INFO_FF PORT_INFO_FFA
#define PPORT_INFO_FF PPORT_INFO_FFA
#define LPPORT_INFO_FF LPPORT_INFO_FFA
#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\publish\makefile.inc ===
#
# winsprlp.h, winspool.h, winspool.x
#

$(O)\winspool.x $(O)\winsprlp.h: winspool.w
    hsplit -e -o $(O)\winspool.x $(O)\winsprlp.h winspool.w

$(O)\winspool.h : $(O)\winspool.x
    wcshdr < $? > $@

$(WINDOWS_INC_PATH)\winsprlp.h: $(O)\winsprlp.h
    $(PUBLISH_CMD) {$?=$@}

$(SDK_INC_PATH)\winspool.h : $(O)\winspool.h
    $(PUBLISH_CMD) {$?=$@}

$(PROJECT_INC_PATH)\winprtp.h : $(O)\winprtp.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\winprtp.h : winprtp.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\printui.h : $(O)\printui.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\printui.h : printui.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\splapip.h : $(O)\splapip.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\splapip.h : splapip.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\splsetup.h : $(O)\splsetup.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\splsetup.h : splsetup.w
    $(CLEANSE_PUBLISHED_HDR) $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\publish\compstui.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    compstui.h


Abstract:

    This module contains global header definition for the COMMON DRIVER UI


Author:

    19-Jun-1995 Mon 11:52:01 created  -by-  Daniel Chou (danielc)

    17-Aug-1995 Thu 14:59:28 updated  -by-  Daniel Chou (danielc)
        Updated for the first draft.

    23-Aug-1995 Wed 15:13:27 updated  -by-  Daniel Chou (danielc)
        Updated for second draft

    29-Aug-1995 Tue 11:33:24 updated  -by-  Daniel Chou (danielc)
        Adding ExtChkBox for some TVOT_xxx type

    31-Aug-1995 Thu 04:04:23 updated  -by-  Daniel Chou (danielc)
        Making UNICODE type

    01-Sep-1995 Fri 17:29:18 updated  -by-  Daniel Chou (danielc)
        Change the API interface type, so that it can be dynamically called
        and generate the property pages to be merge with the shell

    05-Sep-1995 Tue 11:52:43 updated  -by-  Daniel Chou (danielc)
        Rename to compspui.h and update the API entry structure

    07-Sep-1995 Thu 14:46:55 updated  -by-  Daniel Chou (danielc)
        rename to compstui.h and update comments

    07-Sep-1995 Thu 16:07:31 updated  -by-  Daniel Chou (danielc)
        Adding UNION type for pSel/Sel, pOldSel/OldSel

    08-Sep-1995 Fri 09:23:38 updated  -by-  Daniel Chou (danielc)
        Remove TypeIdx from OPTITEM and use pOptType, and remove all
        pOptType passed in the CPSUICBPARAM and COMPROPSHEETUI structures

    25-Sep-1995 Mon 19:39:45 updated  -by-  Daniel Chou (danielc)
        add other related stuff.

    26-Sep-1995 Tue 11:02:26 updated  -by-  Daniel Chou (danielc)
        Add error codes for GETLASTERROR

    27-Sep-1995 Wed 16:32:37 updated  -by-  Daniel Chou (danielc)
        Move hWndParent, pTitle, hInst and TitleIconID out from
        COMPROPSHEETUI to COMPROPSHEETUIHEADER.

    28-Sep-1995 Thu 17:06:46 updated  -by-  Daniel Chou (danielc)
        Add hInstCaller to COMPROPSHEETUI and add _COMPSTUI_ and cplusplus
        stuff

    28-Sep-1995 Thu 23:16:34 updated  -by-  Daniel Chou (danielc)
        change tick count for trackbar/scrollbar to multiply factor. and
        add the push button flag which can overwrite the update permission so
        it can let user view the current setting from push button's dialog
        display

    07-Feb-1996 Wed 17:45:31 updated  -by-  Daniel Chou (danielc)
        Change the API CommonPropSheetUI to CommonPropertySheetUI so that it
        not using stack but message base, this way any caller can add/delete
        pages as they want without worry about how many pages been added from
        its children.

    7:15 AM 2/14/2001 updated -by- Lazar Ivanov (LazarI)
        Making compstui fusion aware. Attaching a fusion activation context
        to the compstui handles and adding a new message for setting it called 
        CPSFUNC_SET_FUSION_CONTEXT. when a page is about to be created/inserted and 
        it doesn't specify an activation context in its PROPSHEETPAGE structure it 
        will be created into the parent's page activation context. if the parent's 
        activation context is not set then we look up the next parent and so on until 
        the top level parent is reached or until we find a parent with an activation 
        context properly set. if none of the parents have an activation context set, 
        then we force the default (NULL) activation context prior creating the page.

[Environment:]

    NT Windows - Common Property Sheet UI DLL.


[Notes:]


Revision History:


--*/

#ifndef _COMPSTUI_
#define _COMPSTUI_

#ifdef __cplusplus
extern "C" {
#endif


#if (!defined(RC_INVOKED))


//
// For compilers that don't support nameless unions
//

#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME      u
#define DUMMYUNIONNAME2     u2
#define DUMMYUNIONNAME3     u3
#define DUMMYUNIONNAME4     u4
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#endif
#endif

//
// Predefined ID for the TreeView Option Type
//
//


#define TVOT_2STATES        0
#define TVOT_3STATES        1
#define TVOT_UDARROW        2
#define TVOT_TRACKBAR       3
#define TVOT_SCROLLBAR      4
#define TVOT_LISTBOX        5
#define TVOT_COMBOBOX       6
#define TVOT_EDITBOX        7
#define TVOT_PUSHBUTTON     8
#define TVOT_CHKBOX         9
#define TVOT_LAST           TVOT_CHKBOX
#define TVOT_NONE           (TVOT_LAST + 1)

//
// Predefined ID for the TreeView Option Type
//
//
// TVOT_2STATES:
//      Count       = 2
//      pOptParam[0]=pointer to the State 1 OPTPARAM
//      pOptParam[1]=pointer to the State 2 OPTPARAM
//
//      BegCtrlID  = 2 States Group Box ID
//      BegCtrlID+1= 2 States static Text
//      BegCtrlID+2= state 1 Radio button ID
//      BegCtrlID+3= state 1 icon control ID
//      BegCtrlID+4= state 2 Radio button ID
//      BegCtrlID+5= state 2 icon control ID
//      BegCtrlID+6= Extended Check Box/Push Button control ID
//      BegCtrlID+7= Extended Check Box/Push Button Icon control ID
//
//  * For TVOT_3STATES, TVOT_3STATES, each of OPTPARAM consisted
//
//      Style =Ignored
//      pData =Pointer to the string to describe the state
//      IconID=Icons resource ID, or common UI standard icon ID
//      lParam=Ignored
//
//  * OPTITEM's 'Sel' is the selection index range from 0 to 1
//  * On the non-treeview page, this must be a auto radio button
//
//
// TVOT_3STATES:
//      Count       = 3
//      pOptParam[0]=pointer to the State 1 OPTPARAM
//      pOptParam[1]=pointer to the State 2 OPTPARAM
//      pOptParam[2]=pointer to the State 3 OPTPARAM
//
//      BegCtrlID  = 3 States Group Box ID
//      BegCtrlID+1= 3 States static Text
//      BegCtrlID+2= state 1 Radio button ID
//      BegCtrlID+3= state 1 icon control ID
//      BegCtrlID+4= state 2 Radio button ID
//      BegCtrlID+5= state 2 icon control ID
//      BegCtrlID+6= state 3 Radio button ID
//      BegCtrlID+7= state 3 icon control ID
//      BegCtrlID+8= Extended Check Box/Push Button control ID
//      BegCtrlID+9= Extended Check Box/Push Button Icon control ID
//
//  * For TVOT_2STATES, TVOT_3STATES, each of OPTPARAM consisted
//
//      Style =Ignored
//      pData =Pointer to the string to describe the state
//      IconID=Icons resource ID, or common UI standard icon ID
//      lParam=Ignored
//
//  * OPTITEM's 'Sel' is the selection index range from 0 to 1
//  * On the non-treeview page, this must be a auto radio button
//
//  ** For TVOT_2STATES, TVOT_3STSATES the 'Sel' field in the OPTITEM has
//     following definitions
//
//      State 1, Sel = 0
//      State 2, Sel = 1
//      State 3, Sel = 2
//
//      for any selection which based on false/true, no/yes, off/ontrue/false,
//      none/select then state 1 (sel=0) must always be the NO, FALSE, OFF or
//      NONE type.
//
//
// TVOT_UDARROW:
//      Count       = 2
//      pOptParam[0]=Pointer to the text of postfix and ICONS
//      pOptParam[1]=Pointer to the help line text above the control and
//                      IconID = (SHORT)Low range of the up-down control
//                      lParam = (SHORT)High range of the up-down control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//          if pData pointed to no help text then common UI automatically
//          set the (# - #) as help line
//
//      BegCtrlID  = udarrow Group Box ID
//      BegCtrlID+1= udarrow title static title ID
//      BegCtrlID+2= udarrow's editbox ID
//      BegCtrlID+3= udarrow icon control ID
//      BegCtrlID+4= udarrow postfix static text ID
//      BegCtrlID+5= udarrow help static text ID
//      BegCtrlID+6= udarrow arrow ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * Style field in the OPTPARAM is ignored
//
//
// TVOT_TRACKBAR:
//      Count       = 3
//      pOptParam[0]=Pointer to the text for the selection postfix and ICONS
//      pOptParam[1]=Pointer to the <Low Range Text> and
//                      IconID = (SHORT)Low range of the trackbar control
//                      lParam = (SHORT)High range of the trackbar control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//      pOptParam[2]=Pointer to the <High Range Text> and
//                      IconID = 'Sel' multiply factor for display
//                      lParam = Page Size (increment)
//
//          if pData pointed to NULLt then common UI automatically
//          set the Low/High range.
//
//      BegCtrlID  = trackbar Group Box ID
//      BegCtrlID+1= trackbar static title ID
//      BegCtrlID+2= trackbar(horizontal) ID (static FRAME to define size)
//      BegCtrlID+3= trackbar icon control ID
//      BegCtrlID+4= trackbar low range text control ID
//      BegCtrlID+5= trackbar high range text control ID
//      BegCtrlID+6= trackbar postfix ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * The multiply factor is used to multiply the current select with
//        this factor and display it. typically this is one
//      * the tick frequency is automatically to set to PageSize increment
//      * Style field in the OPTPARAM is ignored
//
//
// TVOT_SCROLLBAR:
//      Count       = 3
//      pOptParam[0]=Pointer to the text for the selection postfix and ICONS
//      pOptParam[1]=Pointer to the <Low Range Text> and
//                      IconID = (SHORT)Low range of the scrollbar control
//                      lParam = (SHORT)High range of the scroll control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//      pOptParam[2]=Pointer to the <High Range Text> and
//                      IconID = 'Sel' multiply factor for display
//                      lParam = Page Size (increment)
//
//          if pData pointed to NULLt then common UI automatically
//          set the Low/High range.
//
//
//      BegCtrlID  = scrollbar(horizontal) group box ID
//      BegCtrlID+1= scrollbar(horizontal) static text ID
//      BegCtrlID+2= scrollbar(horizontal) ID
//      BegCtrlID+3= scrollbar icon control ID
//      BegCtrlID+4= scrollbar low range text control ID
//      BegCtrlID+5= scrollbar high range text control ID
//      BegCtrlID+6= scrollbar postfix control ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * The multiply factor is used to multiply the current select with
//        this factor and display it. typically this is one
//      * Style field in the OPTPARAM is ignored
//
//
//
// TVOT_LISTBOX:
// TVOT_COMBOBOX:
//      Count       = N
//      pOptParam[0]=pointer to the first OPTPARAM (pData=string pointer)
//      pOptParam[1]=pointer to the second OPTPARAM (pData=string pointer)
//          .
//          .
//      pOptParam[N-1]=pointer to the N item string
//
//      BegCtrlID  = Listbox/ComboBox group box ID
//      BegCtrlID+1= Listbox/ComboBox static title ID
//      BegCtrlID+2= Listbox/Combobox ID
//      BegCtrlID+3= Listbox/Combobox icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//      * for TVOT_LISTBOX, TVOT_COMBOBOX, the field used as
//
//          Style =Ignored by the common UI
//          pData =Pointer to the name of item
//          IconID=Icon resource ID for the item
//          lParam=ignored by the common UI
//
//      * Only SINGLE selection is supported, to do a multiple selction use
//        multiple OPTITEM and create a header for it
//
//      * an OTLBCBS_SORT style can be specified in the OPTTYPE's LBCBStyle
//        field, and the listbox or combobox will be sorted according to the
//        item's string.
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//
//      * for TVOT_LISTBOX, TVOT_COMBOBOX, when it get received the keyboard
//        focus then common UI will call callback function (only if
//        OPTIF_CALLBACK bit set) with reason of CPSUICB_REASON_LBCB_ACTIVE,
//        this give caller a chance to modify following structure flags/pdata
//        which associate with the current OPTITEM.   The caller's callback
//        function can ONLY modify the flags/data specified here.
//
//          OPTTYPE pointed by the pOptType from OPTITEM
//
//              Style: OTS_LBCB_SORT
//                     OTS_LBCB_INCL_ITEM_NONE
//
//          OPTPARAMs pointed by the pOptParam from the OPTTYPE
//
//              Flags: OPTPF_HIDE
//                     OPTPF_DISABLED
//
//              pData: change string name
//
//
//      * The TVOT_COMBOBOX typically only used in the tree-view if there is
//        only one selection available for that item, when there is only one
//        item then dropdown list will not enabled by the common UI
//
//
//
// TVOT_EDITBOX:
//      Count       = 2
//      pOptParam[0]=Pointer to the text of postfix and ICONS
//      pOptParam[1]=Pointer to the help line text above the control and
//                      IconID = Edit buffer sie in character pointed by pSel
//                                 this is including the NULL terminator.
//                      lParam = ignored.
//
//      BegCtrlID  = editBox group Box ID
//      BegCtrlID+1= editBox static title ID
//      BegCtrlID+2= editbox ID
//      BegCtrlID+3= editbox icon control ID
//      BegCtrlID+4= editbox postfix ID
//      BegCtrlID+5= editbox help ID
//      BegCtrlID+6= Extended Check Box/Push Button control ID
//      BegCtrlID+7= Extended Check Box/Push Button Icon control ID
//
//      * Style field is ignored
//
//      * pSel in the OPTITEM is the pointer to the editing string, the pSel
//        must pointed to a buffer eqaul or larger than the count of the buffer
//        (pOptParam[1]->IconID) size
//
//
// TVOT_PUSHBUTTON:
//      Count       = 1
//
//      BegCtrlID  = push button group box ID
//      BegCtrlID+1= push button static text ID (Not used by common UI)
//      BegCtrlID+2= push button ID
//      BegCtrlID+3= push button icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//
//      PUSHBUTTON_TYPE_xxx specified the action and content of pData in the
//      pOptParam[0] as describe in the following
//
//          PUSHBUTTON_TYPE_DLGPROC
//
//              This push button is designed to bring up caller's dialog box
//
//                  pOptParam[0].pData  = Caller's DLGPROC
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_DLGPROC
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Caller's DIALOG resource template ID
//                                        or handle to the DLGTEMPLATE depends
//                                        on the OPTPF_USE_HDLGTEMPLATE flag
//
//
//              The 'lParam' passed to the DLGPROC's WM_INITDIALOG is the
//              CPSUICBPARAM structure pointer, and the reason field is set
//              to CPSUICB_REASON_DLGPROC.
//
//
//          PUSHBUTTON_TYPE_CALLBACK
//
//              This push button is designed to have caller process the item
//              which cannot accomplished with the dialog box along.
//
//                  pOptParam[0].pData  = CPSUICALLBACK function pointer
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_CALLBACK
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Not Used;
//
//              Durning the callback the Reason field in CPSUICBPARAM will
//              set to CPSUICB_REASON_PUSHBUTTON.
//
//              ** If pOptParam[0].pData callback function is NULL then common
//                 UI will call the pfnCallBack pointer set in the
//                 COMPROPSHEETUI structure if it is not NULL
//
//              ** The callback function should put the result of the callback
//                 in the pSel/Sel of OPTITEM associate with the push button
//
//          PUSHBUTTON_TYPE_HTCLRADJ
//
//              This push button is designed to bring up halftone color
//              adjustment dialog box.
//
//                  pOptParam[0].pData  = pointer to COLORADJUSTMENT structure
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_HTCLRADJ
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam =  Not Used;
//
//
//          PUSHBUTTON_TYPE_HTSETUP
//
//              This push button is designed to bring up device halftone
//              setup dialog box.
//
//                  pOptParam[0].pData  = pointer to DEVHTADJDATA structure
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_HTSETUP
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Not Used;
//
//
//      * 'Sel' field in the OPTITEM for the PUSHBUTTON is the last returned
//        LONG result from the called dialog box or funcitons.  The result
//        only valid if OPTIF_CHANGEONCE flag is set.  The common UI will set
//        OPTIF_CHANGEONCE if push button ever pushed.
//
//      * Since common UI donot know the meaning of the return value and
//        content of the called parameter, it is up to the caller to use
//        callback function to determine the returned result.
//
//      * When returned from the push button except push botton type
//        PUSHBUTTON_TYPE_CALLBACK common ui will call the callback function
//        if the OPTIF_CALLBACK flat is set.  The callback reason is set to
//        CPSUICB_REASON_SEL_CHANGED.
//
//      * If the passed in CPSUIF_UPDATE_PERMISSION Flags in the COMPROPSHEETUI
//        is clear then the callback function must ONLY display the dialog box
//        and not changed any OPTITEM data if OTS_PUSH_ENABLE_ALWAYS
//        flag is set in the OPTTYPE
//
//
// TVOT_CHKBOX:
//      Count               = 1
//
//      pOptparam[0].Style  = CHKBOXS_FALSE_TRUE    False/True
//                            CHKBOXS_NO_YES,       No/YES
//                            CHKBOXS_OFF_ON,       Off/ON
//                            CHKBOXS_FALSEPDATA    False/pData
//                            CHKBOXS_NO_PDATA      No/pData
//                            CHKBOXS_OFF_PDATA     Off/pData
//                            CHKBOXS_NONE_PDATA    None/pData
//      pOptParam[0].pData  = Only used if Style is CHKBOXS_NONE_PDATA
//      pOptParam[0].IconID = Icon resource ID
//      pOptParam[0].lParam = Ignored
//
//
//      BegCtrlID  = check box group ID
//      BegCtrlID+1= Check Box static text (not used by common UI)
//      BegCtrlID+2= check box button ID
//      BegCtrlID+3= check box icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//
//  * BegCtrlID only used if the OPTITEM/OPTTYPE is belong to the the DLGPAGE
//    which has non-common UI dialog box template (DlgTemplateID in the DLGPAGE
//    is not standard DP_STD_xxx common ui dialog box template).    The common
//    UI used this ID to managed caller's dialog boxes item's selections and
//    initialization.
//
//  * for each item, it has group box ID (BegCtrlID) and static text ctronl ID
//    (BegCtrlID + 1).  The common UI will set the text in one of these two
//    control ID in followng seauence.
//
//      1) If group box control ID's window (BegCtrlID) is exist and the
//         OPTITEM's flag OPTIF_NO_GROUPBOX_NAME is not set then common UI will
//         set the pName from OPTITEM to the group box.
//
//      2) If the group box name is not set and static control ID's window
//         (BegCtrlID + 1) is exist then common UI will set the pName from
//         OPTITEM to the static text control.
//
//  * for TVOT_TRACKBAR and TVOT_SCROLLBAR, if pName in the OPTITEM is set to
//    either group box or static text control then common UI will also append
//    the current selection position of trackbar or scroll bar to the pName.
//
//  * If multiple OPTITEMs using the same POPTPARAM and need different
//    BegCtrlID for each control then then a separate OPTTYPE structure should
//    be generated but POPTPARAM pointed to the same OPTPARAM[]
//
//  * If a BegCtrlID+N is not used then skip that ID in your dialog box
//    template
//
//

#define CHKBOXS_FALSE_TRUE          0
#define CHKBOXS_NO_YES              1
#define CHKBOXS_OFF_ON              2
#define CHKBOXS_FALSE_PDATA         3
#define CHKBOXS_NO_PDATA            4
#define CHKBOXS_OFF_PDATA           5
#define CHKBOXS_NONE_PDATA          6


#define PUSHBUTTON_TYPE_DLGPROC     0
#define PUSHBUTTON_TYPE_CALLBACK    1
#define PUSHBUTTON_TYPE_HTCLRADJ    2
#define PUSHBUTTON_TYPE_HTSETUP     3


#define MAX_RES_STR_CHARS           160

//
// Common Printer UI's LPTSTR
//
// All string pointer in common printer UI structures can be either a real
// memory pointer or a string resource ID.  These are applied to LPTSTR type.
//
// The LPTSTR is defined to identify that the pointer can be a real string
// pointer or a resource ID (either common printer UI provided ID or caller's
// own resource ID).  common UI using following logic to get the final string.
//
//  LPTSTR  pData;
//
//      if ((pData & ~(ULONG_PTR)0xFFFF) != 0) then pData is a NULL terminated
//      string pointer
//
//          ELSE
//
//          (pData & (ULONG_PTR)0xFFFF) = Resource ID
//
//          if (Resource ID is within the common UI string resource ID range)
//          then it load the string from common UI DLL
//
//          ELSE
//
//              it load string from caller's resource
//
//
//  *  You can use MAKEINTRESOURCE(StrResID) to set this field
//
//  * The MAX characters loaded by the common UI from the resource is defined
//    as MAX_RES_STR_CHARS
//
//  * You cannot use LPTSTR as resource ID for the TVOT_EDITBOX style's
//    pSel in the OPTITEM, this pointer must be a real buffer pointer
//
//
//
// ICONs
//
//  Common UI using two types of Icons, One is 32x32 and the other is 16x16
//  plus if any monochrome icon with 32x32 and 16x16 sizes.
//
//  The 16x16 icon when displayed on the screen is using 16x17 pixel space,
//  this is ensure that downware adjacent icon is not crowded together.
//
//  In common UI, if you need to passed a ICON ID, it can either passed a
//  common UI's predefined ID or caller's own ICON resource ID.
//
//
//  * You can use to imagedit or any other Window icon editor to create the
//    icon, each icon file should have one unique icon resource ID which is
//    not overlay with the standard common UI IDI_CPSUI_xxx identifier.  For
//    each icon file, its should have both 32x32 and 16x16 size icon on
//    different display. (ie. monochrome).
//
//    Common UI will try to load the correct size of icon from the icon
//    resource, but it will stretch them if the size is not found.
//
//

//
// Flags for the OPTTYPE
//
//

#define OPTPF_HIDE                  0x01
#define OPTPF_DISABLED              0x02
#define OPTPF_ICONID_AS_HICON       0x04
#define OPTPF_OVERLAY_WARNING_ICON  0x08
#define OPTPF_OVERLAY_STOP_ICON     0x10
#define OPTPF_OVERLAY_NO_ICON       0x20
#define OPTPF_USE_HDLGTEMPLATE      0x40

typedef struct _OPTPARAM {
    WORD        cbSize;         // size of this structure
    BYTE        Flags;          // OPTPF_xxxx flags
    BYTE        Style;          // style use in this structure
    LPTSTR      pData;          // pointer to the data
    ULONG_PTR   IconID;         // iconID;
    LPARAM      lParam;         // parameter used
    ULONG_PTR   dwReserved[2];  // reserved dword, must be 0
    } OPTPARAM, *POPTPARAM;


//
// OPTPARAM
//
//  The OPTPARAM structure is used to describe each slectable item in the
//  common UI such as 'letter', 'legal' in the form slection list box
//
//  cbSize      - size of this structure
//
//  Flags       - defined as OPTPF_xxxx
//
//                  OPTPF_HIDE
//
//                      Specified hide this listed selection item and not
//                      availabe for user to select. This only available to
//                      following TVOT_xxx types
//
//                          TVOT_3STATES
//                          TVOT_LISTBOX
//                          TVOT_COMBOBOX
//
//                      If all the seclection items are OPTPF_HIDE then the
//                      OPTITEM is automatically hided by the common UI, if
//                      TVOT_3STATES has 2 states hide then an error is
//                      returned
//
//
//                  OPTPF_DISABLED
//
//                      Specified this listed selection item is disabled and
//                      not availabe for user to select.   This only available
//                      to following TVOT_xxx types
//
//                          TVOT_2STATES
//                          TVOT_3STATES
//                          TVOT_LISTBOX
//                          TVOT_COMBOBOX
//
//
//                  OPTPF_ICONID_AS_HICON
//
//                      If this flag is set then IconID DWORD field is treated
//                      as a handle to the icon rather then the resource ID
//
//
//                  OPTPF_OVERLAY_WARNING_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                  OPTPF_OVERLAY_STOP_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                  OPTPF_OVERLAY_NO_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  Style       - Style for the OPTPARAM, it depends on the TVOT_xxx type as
//                describe below
//
//                  TVOT_PUSBUTTON
//
//                      it can be one of PUSHBUTTON_TYPE_xxxx.
//
//                  other TVOT_xxxx
//
//                      this fields is not used.
//
//
//  pData       - Is either a pointer to the item name (string) or it is
//                used to describe other data.
//
//                   * If the pData in the OPTPARAM is supposed to be a static
//                     pointer to a string and the string is a common UI
//                     standard resource ID then common UI will check if pData
//                     is equal to IDS_CPSUI_NOTINSTALLED, if true then
//                     common UI will overaly a not installed icon on top of
//                     the OPTPARAM's Icon.   This will not applied to the
//                     TVOT_EDITBOX type since the pData is not a static text
//                     pointer or a string resource ID.
//
//                  ** See LPTSTR description above
//
//  IconID      - This is the icon identifier, which can be a common strandard
//                IDI_CPSUI_xxx icon ID, caller's own icon resource ID, or a
//                handle to the caller defined icon if OPTPF_ICONID_AS_HICON
//                flag is set, in any case if the IconID is zero then it
//                indicated no icon.
//
//  lParam      - Extra data used by the OPTPARAM, it depends on the TVOT_xxx
//                type.
//
//  dwReserved[]- Reserved DWORDs, must be 0
//
//


#define OPTTF_TYPE_DISABLED             0x01
#define OPTTF_NOSPACE_BEFORE_POSTFIX    0x02


#define OTS_LBCB_SORT                   0x0001
#define OTS_LBCB_PROPPAGE_LBUSECB       0x0002
#define OTS_LBCB_PROPPAGE_CBUSELB       0x0004
#define OTS_LBCB_INCL_ITEM_NONE         0x0008
#define OTS_LBCB_NO_ICON16_IN_ITEM      0x0010
#define OTS_PUSH_INCL_SETUP_TITLE       0x0020
#define OTS_PUSH_NO_DOT_DOT_DOT         0x0040
#define OTS_PUSH_ENABLE_ALWAYS          0x0080


typedef struct _OPTTYPE {
    WORD        cbSize;
    BYTE        Type;           // TVOT_xxxx type of OPTIONS
    BYTE        Flags;          // OPTTF_xxx flags
    WORD        Count;          // Count of pOptParam passed
    WORD        BegCtrlID;      // start of item's group window ID
    POPTPARAM   pOptParam;      // pointer to the OPTPARAM
    WORD        Style;          // option type style as OTS_xxxx
    WORD        wReserved[3];   // wReserved, must be 0
    ULONG_PTR   dwReserved[3];  // DWORD reserved field (must be 0)
} OPTTYPE, *POPTTYPE;


//
// OPTTYPE
//
//  The OPTTYPE structure is used to describe a set of selection and its
//  select method,  such as Form/Tray assignment.  It has a pointer to a set
//  of selection item (OPTPARAM)
//
//
//  cbSize      - size of this structure
//
//  Type        - Specified the option type using predefined ID as TVOT_xxxx
//
//  Flags       - currently only one flag is defined
//
//
//                  OPTTF_TYPE_DISABLED
//
//                      The whole OPTTYPE's OPTPARAMs are disabled, and non of
//                      the selection in the OPTTYPE can be selected
//
//
//                  OPTTF_NOSPACE_BEFORE_POSTFIX
//
//                      This bit only valid if the OPTTYPE's pOptParam item
//                      specified a postfix string as describe in the above
//                      section.  If this flag is set then it asked common UI
//                      do not add a space character before the postfix string
//                      when it combine the pName in the OPTITEM and postfix
//                      string.   Typeically this bit is not set for the
//                      postfix string, but sometime it may be required not to
//                      add a space character in front of it, such as '%'
//                      postfix string.
//
//
//  Count       - Count of item pointed by pOptParam.  Some predefined number
//                must be set according to the TVOT_XXX description.
//
//  BegCtrlID   - Only used if the OPTITEM/OPTTYPE is belong to the the DLGPAGE
//                which has non-common UI dialog box template (DlgTemplateID
//                in the DLGPAGE is not standard DP_STD_xxx common ui dialog
//                box template).    The common UI used this ID to managed
//                caller's dialog boxes item's selections and initialization.
//
//                Each OPTITEM has predefined number of window ID which
//                associated with that item, the BegCtrlID specified the start
//                control window ID.  Each control window ID in the OPTITEM
//                must have the control ID sequence as describe in the TVOT_xxx
//                above.
//
//  pOptParam   - Pointer to array of OPTPARAM to describe each selectable item
//
//  Style       - Specified the style of type of control box, certain style
//                only apply to centain type of TVOT_xxxx.
//
//                OTS_LBCB_xxx only applied to TVOT_LISTBOX, TVOT_COMBOBOX
//                OTS_PUSH_xxx only applied to TVOT_PUSHBUTTON
//
//
//                  OTS_LBCB_SORT
//
//                      Specified that the listbox or combobox item is sorted
//                      in ascending order based on the pData string
//
//
//                  OTS_LBCB_PROPAGE_LBUSECB
//
//                      Used when Type is TVOT_LISTBOX, if it specified and
//                      this OPTTYPE also on the non-treeview user defined
//                      property sheet page dialog then common UI assume
//                      control is comobobox instead of listbox on the non-
//                      treeview page
//
//
//                  OTS_LBCB_PROPAGE_CBUSELB
//
//                      Used when Type is TVOT_COMBOBOX, if it specified and
//                      this OPTTYPE also on the non-treeview user defined
//                      property sheet page dialog then common UI assume
//                      control is listbox instead of combobox on the non-
//                      treeview page
//
//
//                  OTS_LBCB_INCL_ITEM_NONE
//
//                      when this flag is specified, the common ui will
//                      automatically add a 'None' selection to the listbox or
//                      combobox.   The 'Sel' will set to -1 if 'none' is
//                      selection is selected by the user.  It will also
//                      validate the 'Sel' durning the initialization,  any
//                      out of range value will be set to -1 (None).
//
//
//                  OTS_LBCB_NO_ICON16_IN_ITEM
//
//                      By default, each listbox, combox will have a small
//                      icon (16x16) in front of item text. by specified this
//                      bit, the listbox/combobox will not includes icons
//                      in the listbox/combobox.
//
//                      If clear then it specified that in the listbox/combobox
//                      to have 16x16 Icon added to the front of each item
//
//
//                  OTS_PUSH_INCL_SETUP_TITLE
//
//                      If specified for the push button then it automatically
//                      add the 'Setup' to the end of push botton text.
//
//
//                  OTS_PUSH_NO_DOT_DOT_DOT
//
//                      If specified then common UI will not add '...' to the
//                      end of the pName in the OPTITEM and push button name
//
//
//                  OTS_PUSH_ENABLE_ALWAYS
//
//                      This flag specified that even update permissio is not
//                      allowed, it still let user push the push button, if
//                      this flag is set then callback function or dialog box
//                      proc must disable all the control which let user
//                      modified the content, but just let user view the
//                      current setting.
//
//
//  wReserved[] - Reserved fields, must be 0
//
//  dwReserved[]- Reserved fields, must be 0
//
//


//
// Following are flags for the EXTPUSH
//


#define EPF_PUSH_TYPE_DLGPROC       0x0001
#define EPF_INCL_SETUP_TITLE        0x0002
#define EPF_NO_DOT_DOT_DOT          0x0004
#define EPF_ICONID_AS_HICON         0x0008
#define EPF_OVERLAY_WARNING_ICON    0x0010
#define EPF_OVERLAY_STOP_ICON       0x0020
#define EPF_OVERLAY_NO_ICON         0x0040
#define EPF_USE_HDLGTEMPLATE        0x0080


typedef struct _EXTPUSH {
    WORD                cbSize;         // size of the structure
    WORD                Flags;          // EPCBF_xxx flags
    LPTSTR              pTitle;         // extended push botton title
    union {
        DLGPROC         DlgProc;        // pointer to the dialog box proc
        FARPROC         pfnCallBack;    // callback function pointer
        } DUMMYUNIONNAME;
    ULONG_PTR           IconID;         // icon to be used
    union {
        WORD    DlgTemplateID;          // dialog box template ID
        HANDLE  hDlgTemplate;           // handle to the dialog template
        } DUMMYUNIONNAME;
    ULONG_PTR   dwReserved[3];          // reserved field, must be 0
    } EXTPUSH, *PEXTPUSH;

//
// EXTPUSH structure is used to describe the extened push button available
// on OPTITEM/OPTITEM, each OPTTYPE can optional have either one extended check
// box or one extended push button callback.
//
//
//  cbSize          - size of this structure
//
//  Flags           - flags for the EXTPUSH as EPF_xxxx
//
//                      EPF_PUSH_TYPE_DLGPROC
//
//                          If this bit is set then it specified the extended
//                          push button is type of DLGPROC and DlgProc and
//                          DlgTemplateID is valid for common UI to call.
//
//                          If this bit is clear then it specfied the extended
//                          push button is the callback style and pfnCallBack
//                          should be called by the common UI
//
//
//                      EPF_INCL_SETUP_TITLE
//
//                          If specified for the extended push button then it
//                          automatically add the 'Setup' to the end of
//                          extended push button's title
//
//
//                      EPF_NO_DOT_DOT_DOT
//
//                          If specified then common UI will not add '...' to
//                          the end of the pTitle in the EXTPUSH.
//
//
//                      EPF_ICONID_AS_HICON
//
//                          If this flag is set then IconID DWORD field is
//                          treated as a handle to the icon rather then the
//                          resource ID.
//
//
//                      EPF_OVERLAY_WARNING_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                      EPF_OVERLAY_STOP_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                      EPF_OVERLAY_NO_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  pTitle          - Pointed to extended push botton title
//
//                      ** See LPTSTR description above
//
//  DlgProc         - Pointer to the DLGPROC function supplied by the caller.
//                    When user push the button the common UI will call
//                    DialogBoxParam() with this fucction pointer and passed
//                    CPSUICBPARAM structure pointer to the WM_INITDIALOG with
//                    the Reason set to CPSUICB_REASON_EXTPUSH.  If this
//                    filed is NULL then common UI assumed that EXTPUSH is
//                    disabled (OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE), this
//                    fields only used if EPF_PUSH_TYPE_DLGPROC flag is set
//
//  pfnCallBack     - Pointer to CPSUICALLBACK function, this only used if
//                    EPF_PUSH_TYPE_DLGPROC bit is clear, duringing callback
//                    it passed the CPSUICBPARAM pointer as parameter
//
//  IconID          - This is the icon identifier, which can be a common
//                    strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                    resource ID, or a handle to the caller defined icon if
//                    EPF_ICONID_AS_HICON flag is set, in any case if the
//                    IconID is zero then it indicated no icon.
//
//  DlgTemplateID   - Specified the ressource ID for the dilaog box. If the
//                    DlgTemplateID = 0 then common UI will call the DlgProc
//                    with following parameter.
//
//                      DlgProc(hDlg, WM_USER, NULL, (LPARAM)pCPSUICBPaam);
//
//  hDlgTemplate    - Handle to the DLGTEMPLATE which will be use for pop up
//                    dialog box
//
//  wReserved[]     - WORD reserved field, must be 0
//
//  dwReserved[]    - DWORD reserved field, must be 0
//
//
//


//
// Following are flags for the EXTCHKBOX
//

#define ECBF_CHECKNAME_AT_FRONT         0x0001
#define ECBF_CHECKNAME_ONLY_ENABLED     0x0002
#define ECBF_ICONID_AS_HICON            0x0004
#define ECBF_OVERLAY_WARNING_ICON       0x0008
#define ECBF_OVERLAY_ECBICON_IF_CHECKED 0x0010
#define ECBF_OVERLAY_STOP_ICON          0x0020
#define ECBF_OVERLAY_NO_ICON            0x0040
#define ECBF_CHECKNAME_ONLY             0x0080


typedef struct _EXTCHKBOX {
    WORD        cbSize;         // size of the structure
    WORD        Flags;          // ECBF_xxx flags
    LPTSTR      pTitle;         // extended checkbox title
    LPTSTR      pSeparator;     // pointer to separator string for treeview
    LPTSTR      pCheckedName;   // string to be displayed when checked
    ULONG_PTR   IconID;         // icon to be used
    WORD        wReserved[4];   // reserved word, must be 0
    ULONG_PTR   dwReserved[2];  // reserved field, must be 0
    } EXTCHKBOX, *PEXTCHKBOX;


//
// EXTCHKBOX structure is used to describe the extened check box available on
// OPTITEM/OPTITEM, each OPTTYPE can optional have one extended check box.
// When using EXTCHKBOX the selection item can be checked or not checked
// based on user input.
//
//
//  cbSize      - size of this structure
//
//  Flags       - flags for the EXTCHKBOX as ECBF_xxxx
//
//                  ECBF_CHECKNAME_AT_FRONT
//
//                      This flag specified how to display item's name and its
//                      checked name in the treeview display.   If this flag is
//                      set then the checked name is display in front of
//                      separator name, otherwise the checked name is displayed
//                      after the separator.  For Example.
//
//                      Flag Set:   pCheckedName pSeparator SelectName
//                      Flag Clear: SelectName pSeparator pCheckedName
//
//
//                  ECBF_CHECKNAME_ONLY_ENABLED
//
//                      If set then it specified that in the treeview display,
//                      it will only show the pCheckedName if this extended
//                      check box is visible and enabled.  Some items may not
//                      desired to display the pCheckedName if the extended
//                      check box is disabled, such as Copy/Collate checkbox.
//
//
//                  ECBF_ICONID_AS_HICON
//
//                      If this flag is set then IconID DWORD field is treated
//                      as a handle to the icon rather then the resource ID
//
//
//                  ECBF_OVERLAY_WARNING_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                  ECBF_OVERLAY_ECBICON_IF_CHECKED
//
//                      This bit specified to overlay the ExtChkBox's Icon to
//                      the OPTITEM's icon (or OPTPARAM) if the the extended
//                      checked box is checked
//
//
//                  ECBF_OVERLAY_STOP_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                  ECBF_OVERLAY_NO_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  pTitle      - Pointed to extended check box title
//
//                  ** See LPTSTR description above
//
//  pSeparator  - Pointer to the separator to be used in the treeview
//                display or the static title control in the non-treeview
//                page,
//
//  pCheckedName- Pointed to the name to be displayed in the treeview if item
//                is checked.  pCheckedName is added according to the
//                pSeparator and the ECBF_CHECKNAME_AT_FRONT flags.
//
//                  * If the pCheckedName is equal to IDS_CPSUI_NOTINSTALLED
//                    then common UI will automatically overaly a not installed
//                    icon on top of the extended check box Icon.
//
//                      ** See LPTSTR description above
//
//  IconID      - This is the icon identifier, which can be a common strandard
//                IDI_CPSUI_xxx icon ID, caller's own icon resource ID, or a
//                handle to the caller defined icon if ECBF_ICONID_AS_HICON
//                flag is set, in any case if the IconID is zero then it
//                indicated no icon.
//
//  wReserved[] - WORD reserved field, must be 0
//
//  dwReserved[]- DWORD reserved field, must be 0
//


//
// Following the the Flags for the OPTITEM
//

#define OPTIF_COLLAPSE              0x00000001L
#define OPTIF_HIDE                  0x00000002L
#define OPTIF_CALLBACK              0x00000004L
#define OPTIF_CHANGED               0x00000008L
#define OPTIF_CHANGEONCE            0x00000010L
#define OPTIF_DISABLED              0x00000020L
#define OPTIF_ECB_CHECKED           0x00000040L
#define OPTIF_EXT_HIDE              0x00000080L
#define OPTIF_EXT_DISABLED          0x00000100L
#define OPTIF_SEL_AS_HICON          0x00000200L
#define OPTIF_EXT_IS_EXTPUSH        0x00000400L
#define OPTIF_NO_GROUPBOX_NAME      0x00000800L
#define OPTIF_OVERLAY_WARNING_ICON  0x00001000L
#define OPTIF_OVERLAY_STOP_ICON     0x00002000L
#define OPTIF_OVERLAY_NO_ICON       0x00004000L
#define OPTIF_INITIAL_TVITEM        0x00008000L
#define OPTIF_HAS_POIEXT            0x00010000L

#define OPTIF_MASK                  0x0001ffffL


#define DMPUB_NONE                  0
#define DMPUB_FIRST                 1

#define DMPUB_ORIENTATION           1
#define DMPUB_SCALE                 2
#define DMPUB_COPIES_COLLATE        3
#define DMPUB_DEFSOURCE             4
#define DMPUB_PRINTQUALITY          5
#define DMPUB_COLOR                 6
#define DMPUB_DUPLEX                7
#define DMPUB_TTOPTION              8
#define DMPUB_FORMNAME              9
#define DMPUB_ICMMETHOD             10
#define DMPUB_ICMINTENT             11
#define DMPUB_MEDIATYPE             12
#define DMPUB_DITHERTYPE            13
#define DMPUB_OUTPUTBIN             14
#define DMPUB_QUALITY               15
#define DMPUB_NUP                   16
#define DMPUB_PAGEORDER             17

#define DMPUB_LAST                  17

#define DMPUB_OEM_PAPER_ITEM        97
#define DMPUB_OEM_GRAPHIC_ITEM      98
#define DMPUB_OEM_ROOT_ITEM         99
#define DMPUB_USER                  100

#define MAKE_DMPUB_HIDEBIT(DMPub)   (DWORD)(((DWORD)0x01 << ((DMPub) - 1)))
#define IS_DMPUB_HIDDEN(dw, DMPub)  (BOOL)((DWORD)(dw) &                    \
                                           MAKE_DMPUB_HIDEBIT(DMPub))

//
// DMPUB_xxxx is used in OPTITEM to identify if the item is a DEVMODE public
// field. Following it identify which field correspond to the DMPUB_xxxx
//
//
//  DMPUB_ORIENTATION   - dmOrientation
//
//  DMPUB_SCALE         - dmScale
//
//  DMPUB_COPIES_COLLATE- dmCopies/dmCollate
//
//  DMPUB_DEFSOURCE     - dmDefSource    (Should only used form by caller)
//
//  DMPUB_PRINTQUALITY  - dmPrintQuality
//
//  DMPUB_COLOR         - dmColor
//
//  DMPUB_DUPLEX        - dmDuplex
//
//  DMPUB_TTOPTION      - dmTTOption
//
//  DMPUB_FORMNAME      - dmFormName
//
//  DMPUB_ICMMETHOD     - dmICMMethod
//
//  DMPUB_ICMINTENT     - dmICMIntent
//
//  DMPUB_MEDIATYPE     - dmMediaType
//
//  DMPUB_DITHERTYPE    - dmDitherType
//
//  DMPUB_USER          - Anything greater than or equal to DMPUB_USER can be
//                        used by the caller.
//
//  DMPUB_OUTPUTBIN     - Private
//
//  DMPUB_QUALITY       - Private
//
//  DMPUB_NUP           - Private
//
//  DMPUB_PAGEORDER     - Private
//
// When common UI is called for the 'Document Properties' (DEVMODE), it will
// group some of public items together simillar to the following in the
// treeview. How it group is common UI version dependent and caller should not
// concern its placement
//
//      Paper/Output                (Add in by the common UI)
//        Document Form             (DMPUB_FORMNAME)
//        Output Bin                (DMPUB_OUTPUTBIN)
//        Orientation               (DMPUB_ORIENTATION)
//        Source                    (DMPUB_DEFSOURCE)
//        Media                     (DMPUB_MEDIATYPE)
//        Number of Copies          (DMPUB_COPIES_COLLATE)
//        Page Order                (DMPUB_PAGEORDER)
//        Page Per Sheet            (DMPUB_NUP)
//        Duplex                    (DMPUB_DUPLEX)
//
//      Graphic                     (Add in by the common UI)
//        Print Quality             (DMPUB_PRINTQUALITY)
//        Quality Settings          (DMPUB_QUALITY)
//        Color                     (DMPUB_COLOR)
//          Image Color Matching    (Add in by the common UI)
//              ICM Method          (DMPUB_ICMMETHOD)
//              ICM Intent          (DMPUB_ICMINTENT)
//        Scaling                   (DMPUB_SCALE)
//        Dithering                 (DMPUB_DITHERTYPE)
//        TrueType Option           (DMPUB_TTOPTION)
//
//      Options
//        Halftone Color Adjustment...
//        ALL Other Caller's Document sticky options
//
//
//  For 'Document Properties' the standard page 1 (user friendly page) will
//  consist following items if it appear in the OPTITEM array passed by the
//  caller.   These items must have following predefined TVOT_xxx type
//  defined here and specified in the OPTTYPE's Type field.
//
//  All DMPUB_xxx (except >= DMPUB_USER) public ID must have following
//  TVOT_xxxx type specified, else a CPDU_INVALID_DMPUB_TVOT error is returned
//
//      DMPUB_ORIENTATION       - TVOT_2STATES/TVOT_3STATES
//      DMPUB_SCALE             - TVOT_UDARROW
//      DMPUB_COPIES_COLLATE    - TVOT_UDARROW + EXTCHKBOX (Collate)
//      DMPUB_DEFSOURCE         - TVOT_LISTBOX
//      DMPUB_PRINTQUALITY      - TVOT_LISTBOX
//      DMPUB_COLOR             - TVOT_2STATES
//      DMPUB_DUPLEX            - TVOT_2STATES/TVOT_3STATES
//      DMPUB_TTOPTION          - TVOT_LISTBOX
//      DMPUB_FORMNAME          - TVOT_LISTBOX
//      DMPUB_ICMMETHOD         - TVOT_2STATES/TVOT_3STATES
//      DMPUB_ICMINTENT         - TVOT_2STATES/TVOT_3STATES
//      DMPUB_MEDIATYPE         - TVOT_LISTBOX
//      DMPUB_DITHERTYPE        - TVOT_LISTBOX
//
//


#define OIEXTF_ANSI_STRING      0x0001

typedef struct _OIEXT {
    WORD        cbSize;
    WORD        Flags;
    HINSTANCE   hInstCaller;
    LPTSTR      pHelpFile;
    ULONG_PTR   dwReserved[4];
    } OIEXT, *POIEXT;

//
// OIEXT is a data structure used as extension to the OPTITEM data structure
//
//
//  cbSize      - sizeof this structure
//
//  Flags       - One or more of OIEXTF_xxxx may be specified.
//
//                  OIEXTF_ANSI_STRING
//
//                      Specified that LPTSTR in this data structure is a ansi
//                      string (not UNICODE).  This bit only checked if the
//                      LPTSTR is not the resource string ID
//
//  hInstCaller - DLL instance handle, when this hInst is not NULL then all
//                resource string and icon loading for this OPTITEM and its
//                OPTTYPE, OPTPARAM are loaded from this hInstCaller Handle.
//                If this filed is NULL then it will use the hInstCaller handle
//                specified in the COMPROPSHEETUI data structure
//
//  pHelpFile   - Resource string ID or pointer to the help file for this
//                OPTITEM.  If this pointer is NULL then help file for the
//                help index is assume specified in the pHelpFile field in the
//                COMPROPSHEETUI data structure.
//
//  dwReserved  - These fields are not used now, and must 0
//


typedef struct _OPTITEM {
    WORD        cbSize;                 // size of this structure
    BYTE        Level;                  // level in the tree view
    BYTE        DlgPageIdx;             // Index to the pDlgPage
    DWORD       Flags;                  // OPTIF_xxxx flags
    ULONG_PTR   UserData;               // caller's own data
    LPTSTR      pName;                  // name of the item
    union {
        LONG    Sel;                    // current selection (index)
        LPTSTR  pSel;                   // current selection (pStr)
        } DUMMYUNIONNAME;
    union {
        PEXTCHKBOX  pExtChkBox;         // Pointer to EXTCHKBOX structure
        PEXTPUSH    pExtPush;           // Pointer to EXTPUSH
        } DUMMYUNIONNAME2;
    POPTTYPE    pOptType;               // pointer to OPTTYPE structure
    DWORD       HelpIndex;              // Help file index
    BYTE        DMPubID;                // Devmode public filed ID
    BYTE        UserItemID;             // caller's own item ID
    WORD        wReserved;              // reserved WORD field, must be 0
    POIEXT      pOIExt;                 // Optitem extension pointer
    ULONG_PTR   dwReserved[3];          // reserved DWORD fields (must be 0)
    } OPTITEM, *POPTITEM;

//
// OPTITEM is to describe each treeview item's name, selection type and
// possible selection
//
//  cbSize          - sizeof this structure
//
//  Level           - The level in the treeview, the root should have lowest
//                    number and number should start with level 0.  the maximum
//                    number of levels are 256.
//
//  DlgPageIdx      - Zero-based index to the DLGPAGE araay pointee by
//                    pDlgPage. The Maximum index is MAX_DLGPPAGE_COUNT, if
//                    pDlgPage is a standard CPSUI_PDLGPAGE_xxxx then this
//                    field is automatically set the common UI
//
//  Flags           - OPTIF_xxxx flags as describe above
//
//                      OPTIF_COLLAPSE
//
//                          Collaspe treeview item and its children so it is
//                          not expanded initially.
//
//
//                      OPTIF_HIDE
//
//                          Hide this item from the treeview
//
//
//                      OPTIF_CALLBACK
//
//                          Callback to the caller when user making some
//                          changes a pointer (pfnCallBack) must provided and
//                          process as defined by the common UI.
//
//
//                      OPTIF_CHANGED
//
//                          This item was changed and need to re-display. this
//                          flag only used when caller returned from callback
//                          funciton.
//
//
//                      OPTIF_CHANGEONCE
//
//                          This item has been changed at least once.
//
//
//                      OPTIF_DISABLED
//
//                          Disable this item so it become not selectable.
//
//
//                      OPTIF_ECB_CHECKED
//
//                          Specified the associated extended check box is
//                          in checked state.
//
//
//                      OPTIF_EXT_HIDE
//
//                          Hide the extended check box/extended push botton.
//
//
//                      OPTIF_EXT_DISABLED
//
//                          The Extended check box/push botton is disabled and
//                          not selectable
//
//
//                      OPTIF_SEL_AS_HICON
//
//                          This flag only used if this item has no type,
//                          pOptType=NULL that is, when pOptType is NULL then
//                          'Sel' field is the IconID. if flag is set then it
//                          indicate 'pSel' is the Icon handle rather
//                          than the icon resource ID specified in Sel.
//
//
//                      OPTIF_EXT_IS_EXTPUSH
//
//                          Specified that pExtPush should be used when this
//                          pointer is not NULL, if this pointer is not NULL
//                          and this flag is clear then pExtChkBox is assumed.
//
//
//                      OPTIF_NO_GROUPBOX_NAME
//
//                          Specified that do not overwrite the group box title
//                          text, if group box ID is defined. See the TVOT_xx
//                          description above.
//
//
//                      OPTIF_OVERLAY_WARNING_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's
//                          IDI_CPSUI_WARNING icon.  This bit only used if this
//                          item has no type, pOptType is NULL that is.
//
//
//                      OPTIF_OVERLAY_STOP_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's IDI_CPSUI_STOP
//                          icon.  This bit only used if this item has no type,
//                          pOptType is NULL that is.
//
//
//                      OPTIF_OVERLAY_NO_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's IDI_CPSUI_NO
//                          icon.  This bit only used if this item has no type,
//                          pOptType is NULL that is.
//
//
//                      OPTIF_INITIAL_TVITEM
//
//                          Specified that this item will be the initial item
//                          to be selected and display on the treeview page.
//                          If the selected item is currently a child or
//                          collapse then common UI will expand the selection
//                          then scroll it into view.
//
//                          If this flag is clear or the set item is in hide
//                          status common UI will pick the initial item to
//                          display.
//
//                      OPTIF_HAS_POIEXT
//
//                          Specified that pOIExt field is a valid pointer that
//                          points to OIEXT data structure.  The pOIExt only
//                          used by the common UI if this bit is set.
//
//
//  UserData        - a 32-bit number used by the caller and common UI will not
//                    modify it.
//
//  pName           - Pointer to the item's name, such as 'Upper Tray',
//                    'Memory' or it is used as data as describe in
//                    OPTPARAM/OPTTYPE structure
//
//                      ** See LPTSTR description above
//
//  pSel
//  Sel             - Current selection for this item. This is a union field
//                    which can be a pointer to a string or a LONG index
//                    selection.
//
//                      ** If pOptType field is NULL then 'Sel' is the icon ID
//                         to be used for the header.
//
//  pExtPush
//  pExtChkBox      - Pointer to either EXTPUSH or EXTCHKBOX data structure,
//                    if this pointer is NULL then this item does not have
//                    ectended check box/push botton associate with it.
//
//                    When an extended check box is associate with the
//                    OPTTYPE, the OPTIF_EXT_IS_EXTPUSH must not set, the
//                    OPTIF_ECB_CHECKED flag specified if the extended check
//                    box is checked or not checked.
//
//                    When an Extended push botton is associated with the
//                    OPTTYPE, the OPTIF_EXT_IS_EXTPUSH flag must set.
//
//                    The following flags are used in both EXTCHKBOX or
//                    EXTPUSH
//
//                      OPTIF_EXT_HIDE,
//                      OPTIF_EXT_DISABLED
//                      OPTIF_EXT_CHANGEONCE
//
//
//  pOptType        - Pointer to the OPTTYPE structure to describe the display
//                    and selections of the item.   If this pointer is NULL
//                    then this this item does not have any selection. and it
//                    is used as sub-items' header.
//
//                      * When pOptType is NULL then the 'Sel' is the Icon ID.
//
//
//  HelpIndex       - a index to the help file for context sensitive help
//                    if HelpInex=0 then there is no help for this item
//
//  DMPubID         - specified if this item is one of the public fields in the
//                    DEVMODE structure and supported by the common UI.
//
//                      DMPUB_NONE              - Not DEVMODE public fields
//                      DMPUB_ORIENTATION       - dmOrientation
//                      DMPUB_SCALE             - dmScale
//                      DMPUB_COPIES_COLLATE    - dmCopies/dmCollate
//                      DMPUB_DEFSOURCE         - dmDefSource
//                      DMPUB_PRINTQUALITY      - dmPrintQuality
//                      DMPUB_COLOR             - dmColor
//                      DMPUB_DUPLEX            - dmDuplex
//                      DMPUB_TTOPTION          - dmTTOption
//                      DMPUB_FORMNAME          - dmFormName
//                      DMPUB_ICMMETHOD         - dmICMMethod
//                      DMPUB_ICMINTENT         - dmICMIntent
//                      DMPUB_MEDIATYPE         - dmMediaType
//                      DMPUB_DITHERTYPE        - dmDitherType
//
//                      ** for most of DMPUB_FIRST to DMPUB_LAST each OPTITEM's
//                         pName is automatically set to the standard
//                         IDS_CPSUI_xxx for the consistancy reason, the
//                         standard pName is set according to following table.
//
//                          DMPUB_ORIENTATION    - IDS_CPSUI_ORIENTATION
//                          DMPUB_SCALE          - IDS_CPSUI_SCALING
//                          DMPUB_COPIES_COLLATE - IDS_CPSUI_COPIES
//                          DMPUB_DEFSOURCE      - IDS_CPSUI_SOURCE
//                          DMPUB_PRINTQUALITY   - IDS_CPSUI_PRINTQUALITY
//                                                 IDS_CPSUI_RESOLUTION
//                          DMPUB_COLOR          - IDS_CPSUI_COLOR_APPERANCE
//                          DMPUB_DUPLEX         - IDS_CPSUI_DUPLEX
//                          DMPUB_TTOPTION       - IDS_CPSUI_TTOPTION
//                          DMPUB_FORMNAME       - IDS_CPSUI_FORMNAME
//                          DMPUB_ICMMETHOD      - IDS_CPSUI_ICMMETHOD
//                          DMPUB_ICMINTENT      - IDS_CPSUI_ICMINTENT
//                          DMPUB_MEDIATYPE      - IDS_CPSUI_MEDIA
//                          DMPUB_DITHERTYPE     - IDS_CPSUI_DITHERING
//
//                          for DMPUB_PRINTQUALITY, if the pName is not one of
//                          IDS_CPSUI_PRINTQUALITY or IDS_CPSUI_RESOLUTION then
//                          common UI will automatically default the pName to
//                          IDS_CPSUI_RESOLUTION.
//
//                          Each pData (OPTPARAM) selection in OPTPARAM which
//                          OPTITEM's pOptType pointed to should use as much
//                          as IDS_CPSUI_xxx standard name as possible.
//
//
//                      ** for DMPUB_COPIES_COLLATE the common UI automatically
//                         doing the following before the callback
//
//                          1) Enable/Disable the collate extended check box if
//                             OPTIF_EXT_HIDE is not specified and pExtChkBox
//                             is not NULL in the OPTITEM.
//
//                          2) Automatically change the postfix for this item
//                             to be 'Copy' if selection is one, and 'Copies'
//                             if selection is greater than one in the treeview
//                             page, and it will also set the postfix in
//                             standard document property page if the postfix
//                             ID is provided (BegCtrlID + 4)
//
//
//                      ** for DMPUB_COLOR the common UI automatically doing
//                         the following before the callback, the gray
//                         selection must be Sel=0 and Color slection must be
//                         Sel=1
//
//                          1) Calling halftone color adjustment with current
//                             color/mono selection
//
//                          2) Disable ICM when color is not selected
//
//
//                      ** Please see above DMPUB_xx description for details.
//
//  UserItemID      - This is a byte ID intented to be used by the caller to
//                    identify the item
//
//  wReserved       - WORD reserved. Must be zero
//
//  pOIExt          - Pointer to the OIEXT data structure to specified that
//                    it has a OPTITEM extenstion structure.
//
//  dwReserved[]    - DWORD reserved and must be 0
//
//

//
// predefined ID for call back reason
//

#define CPSUICB_REASON_SEL_CHANGED      0
#define CPSUICB_REASON_PUSHBUTTON       1
#define CPSUICB_REASON_ECB_CHANGED      2
#define CPSUICB_REASON_DLGPROC          3
#define CPSUICB_REASON_UNDO_CHANGES     4
#define CPSUICB_REASON_EXTPUSH          5
#define CPSUICB_REASON_APPLYNOW         6
#define CPSUICB_REASON_OPTITEM_SETFOCUS 7
#define CPSUICB_REASON_ITEMS_REVERTED   8
#define CPSUICB_REASON_ABOUT            9
#define CPSUICB_REASON_SETACTIVE        10
#define CPSUICB_REASON_KILLACTIVE       11


//
// predefined ID for call back action
//

#define CPSUICB_ACTION_NONE             0
#define CPSUICB_ACTION_OPTIF_CHANGED    1
#define CPSUICB_ACTION_REINIT_ITEMS     2
#define CPSUICB_ACTION_NO_APPLY_EXIT    3
#define CPSUICB_ACTION_ITEMS_APPLIED    4


typedef struct _CPSUICBPARAM {
    WORD        cbSize;             // size of this structure
    WORD        Reason;             // CPSUICB_REASON_XXXXX callback reason
    HWND        hDlg;               // handle of the dialog box
    POPTITEM    pOptItem;           // pOptItem field from COMPROPSHEETUI
    WORD        cOptItem;           // cOptItem field from COMPROPSHEETUI
    WORD        Flags;              // flags field from COMPROPSHEETUI
    POPTITEM    pCurItem;           // current selected item of callback
    union {
        LONG    OldSel;             // Last selection (index)
        LPTSTR  pOldSel;            // Last selection (pStr)
        } DUMMYUNIONNAME;
    ULONG_PTR   UserData;           // UserData in the COMPROPSHEETUI struct.
    ULONG_PTR   Result;             // OUT parameter for the APPLYNOW
    } CPSUICBPARAM, *PCPSUICBPARAM;


typedef LONG (APIENTRY *_CPSUICALLBACK)(PCPSUICBPARAM pCPSUICBParam);
#define CPSUICALLBACK   LONG APIENTRY


//
// CPSUICBPARAM is used when commom UI callback to the caller, this structure
// describe the nature of callback and passed all necessary parameter for the
// caller to make changes in the pOptItem and passed an action back to the
// commom UI to redisplay the tree or page 1 data
//
//
//  cbSize      - must be CPSUICBPARAM
//
//  Reason      - defined the nature of the callback
//
//                  CPSUICB_REASON_SEL_CHANGED
//
//                      User make change to the pCurItem.  if the item is
//                      DMPUB_COPIES_COLLATE then common UI automatically
//                      change the collate extended check box without callback
//                      to the caller of the extended check box changes
//
//
//                  CPSUICB_REASON_PUSHBUTTON
//
//                      User push the push button and push button item is set
//                      to PUSHBUTTON_TYPE_CALLBACK.
//
//
//                  CPSUICB_REASON_ECB_CHANGED
//
//                      User make change to the extended checked box (i.e. it
//                      eiterh checked or not checked) EXTCHKBOX in the
//                      pCurItem passed in the call back parameter.
//
//
//                  CPSUICB_REASON_DLGPROC
//
//                      The callback reason is PUSHBUTTON_TYPE_DLGPROC
//
//
//                  CPSUICB_REASON_UNDO_CHANGES
//
//                      This callback currently is not implmented.
//
//
//                  CPSUICB_REASON_EXTPUSH
//
//                      The callback is result of user push the extend push
//                      button.
//
//
//                  CPSUICB_REASON_APPLYNOW
//
//                      The user press the apply now button. Durning callback
//                      the pCurItem is set to equal to pOptItem in this
//                      structure and 'OldSel' is set to the active DlgPageIdx
//                      (compare to the OPTITEM's DlgPageIdx) which the page
//                      user hitting the apply now button if the page is
//                      non-treeview page, otherwise the 'OldSel' is set to -1
//                      (for treeview page) to indicate all valid item should
//                      be apply now, if the callback return
//                      CPSUICB_ACTION_NONE then the common UI will exit the
//                      property sheet and returned CPSUI_OK back to the
//                      caller, and if the callback function returned
//                      CPSUICB_ACTION_NO_APPLY_EXIT then common UI will not
//                      exit the property sheet and callback function must
//                      pop-up messages dialog box to tell user why it cannot
//                      exist the property sheet until certain action is take
//                      by the user.
//
//
//                  CPSUICB_REASON_OPTITEM_SETFOCUS
//
//                      This callback reason is used when an OPTITEM is getting
//                      the keyboard focus. and give the callback function a
//                      chance to examine the item.
//
//
//                  CPSUICB_REASON_ITEMS_REVERTED
//
//                      This callback reason is used when user changed items
//                      and decided to revert changes from the parent item in
//                      the treeview.  The callback funciton is called after
//                      all revertable items are reverted to its original.
//
//                      The CPSUICBPARAM's pCurItem is same as pOptItem and
//                      'OldSel' field is same as cOptItem field.  for each of
//                      reverted item, the OPTIF_CHANGED bit will be set in the
//                      OPTITEM by the common UI to indicate the item is revert
//                      by the common UI.   The callback function MUST NOT
//                      reset this bit if it is set.
//
//
//                  CPSUICB_REASON_ABOUT
//
//                      This callback reason is used when user hit 'About...'
//                      push button in the treeview page, and the flag
//                      CPSUIF_ABOUT_CALLBACK is set.  The pCurItem is set to
//                      same as pOptItem and 'pOldSel' is a pointer pointed to
//                      original copy of COMPROPSHEETUI data structure which
//                      passed to the common UI.
//
//
//                  CPSUICB_REASON_SETACTIVE
//                  CPSUICB_REASON_KILLACTIVE
//
//                      The current property sheet is gaining or loosing focus,
//                      the pCurItem is set to equal to pOptItem in this
//                      structure and 'OldSel' is set to the current active
//                      DlgPageIdx (compare to the OPTITEM's DlgPageIdx).
//                      if the page is non-treeview page, otherwise the
//                      'OldSel' is set to -1 (for treeview page).
//
//  hDlg        - The handle to the dialog box (Properties page TAB) current
//                active for the callback.
//
//                Durning the callback the caller must not change the
//                DWLP_USERDATA on hDlg, otherwise the common UI will be crash.
//                If callback function need to get/set DWLP_USERDATA it should
//                call common UI's SetCPSUIUserData() and GetCPSUIUserData()
//                functions instead.
//
//  pCurItem    - Pointed to POPTITEM which the callback is generated for.
//
//  pOldSel
//  OldSel      - The last OPTITEM's pSel/Sel field before the change was made
//                by the user.  The pOldSel/OldSel only valid if the callback
//                reason is CPSUICB_REASON_SEL_CHANGED, this give the callback
//                function a chance to check against the previous item
//                selection.  This is a union field which can be a pointer to
//                a string or a LONG index selection.
//
//  UserData    - a 32-bit user defined data in the COMPROPSHEETUI structure,
//                commom UI will not changed it.
//
//  Result      - When the reason is CPSUICB_REASON_APPLYNOW, the callback
//                function MUST set the requested result for the caller into
//                'Result' field when it returned a value other than the
//                CPSUICB_ACTION_NO_APPLY_EXIT and common UI will send the
//                'Result' field value to this page's parent.
//
//                The called function should save the current result of
//                pOptItem.  The default 'Result' is set to CPSUI_OK (1) from
//                common UI.  This function can alter this result before it
//                return back to to the common UI.
//
//
//  Return Values:
//
//      CPSUICB_ACTION_NONE             - No action need to be take by the
//                                        common UI.
//
//      CPSUICB_ACTION_OPTIF_CHANGED    - Ask the common UI to examine the
//                                        OPTIF_CHANGED flag in the OPTITEM
//                                        data structure.  if the flag is set
//                                        then that item is assume need to be
//                                        re-display because of OPTITEM's Flags
//                                        field changed or item's selection
//                                        changed.   This is different from
//                                        CPSUICB_ACTION_REINIT_ITEMS which
//                                        it assume OPTTYPE or OPTPARAM data
//                                        also changed.
//
//
//      CPSUICB_ACTION_REINIT_ITEMS     - Ask the common UI to examine the
//                                        OPTIF_CHANGED flag in the OPTITEM
//                                        data structure.  if the flag is set
//                                        then that item is assume need to be
//                                        re-initialized in the dilaog box
//                                        control.  This happened if item's
//                                        OPTTYPE or OPTPARAMs flag/pdata
//                                        changed.
//
//
//      CPSUICB_ACTION_NO_APPLY_EXIT    - This return value only valid durning
//                                        CPSUICB_REASON_APPLYNOW callback
//                                        reason, it tell common UI it has
//                                        some constraints in its OPTITEM which
//                                        must correct or confirm by the user
//                                        before exit.  The callback function
//                                        must display and/or have user taking
//                                        some actions before return this
//                                        action to the common UI
//
//      CPSUICB_ACTION_ITEMS_APPLIED    - When responsed to the
//                                        CPSUICB_REASON_APPLYNOW, if the
//                                        returned action is
//                                        CPSUICB_ACTION_ITEMS_APPLIED then
//                                        common UI will reset OPTIF_CHANGEONCE
//                                        bit and save the new default for the
//                                        future undo operations.
//
//

#define DP_STD_TREEVIEWPAGE             0xFFFF
#define DP_STD_DOCPROPPAGE2             0xFFFE
#define DP_STD_DOCPROPPAGE1             0XFFFD
#define DP_STD_RESERVED_START           0xFFF0

#define MAX_DLGPAGE_COUNT               64

#define DPF_ICONID_AS_HICON             0x0001
#define DPF_USE_HDLGTEMPLATE            0x0002

typedef struct _DLGPAGE {
    WORD        cbSize;         // size of this structure
    WORD        Flags;          // DPF_xxxx flags
    DLGPROC     DlgProc;        // caller's dialog box subclass procedue
    LPTSTR      pTabName;       // pointer to the tab name
    ULONG_PTR   IconID;         // icon to be used
    union {
        WORD    DlgTemplateID;  // dialog box template ID
        HANDLE  hDlgTemplate;   // handle to the dialog template
        } DUMMYUNIONNAME;
    } DLGPAGE, *PDLGPAGE;


//
// DLGPAGE structure describe non-treeview page characteristics
//
//
//  cbSize          - size of this structure
//
//  Flags           - DPF_xxxx flags
//
//                      DPF_ICONID_AS_HICON
//
//                          If this flag is set then IconID DWORD field is
//                          treated as a handle to the icon rather then the
//                          resource ID
//
//
//  DlgProc         - caller's supplied DLGPROC for sub-class the page
//                    dialog box processing,
//
//                    if DlgProc is not NULL then common UI do the following
//                    according the the message received except for the
//                    DP_STD_xxx pages
//
//
//                      WM_INITDIALOG
//
//                          Common UI initialize the dialog box and then call
//                          DlgProc(WM_INITDIALOG) the DlgProc should return
//                          exactly the behavior for the WM_INITDIALOG
//
//                          The lParam in the WM_INITDIALOG data structure is
//                          a pointer to the PROPSHEETPAGE data structure.
//
//                          the lParam field in the PROPSHEETPAGE (lParam
//                          passed to the WM_INITDIALOG) is the UserData
//                          defined in COMPROPSHEETUI data structure
//
//                          To access to the PSPINFO data structure which
//                          associate with this page, use the common UI macro
//                          PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam) where
//                          lParam is the parameter passed to the
//                          WM_INITDIALOG message.
//
//                          The subclass function should save these pointers
//                          for its later use, but it MUST NOT modified the
//                          content of the PSPINFO data structure or system
//                          may crashed.
//
//
//                      OTHER DIALOG MESSAGES
//
//                          Iit call DlgProc() and if it returned the value is
//                          non-zero then common UI assume DlgProc() processed
//                          the message and will not process this message.
//
//                          If the returned vlaue from DlgProc() is zero then
//                          common UI will process this message.
//
//
//                      * Durning the DlgProc the caller must not change the
//                        DWLP_USERDATA on hDlg, otherwise the common UI will
//                        be crash.  If caller need to get/set DWLP_USERDATA it
//                        should call common UI's SetCPSUIUserData() and
//                        GetCPSUIUserData() instead.
//
//  pTabName        - Pointer to a string to describe the TAB title
//
//  IconID          - This is the icon identifier, which can be a common
//                    strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                    resource ID, or a handle to the caller defined icon if
//                    DPF_ICONID_AS_HICON flag is set, in any case if the
//                    IconID is zero then it indicated no icon.
//
//  DlgTemplateID   - The template id to be use for the ProPage, it can be
//                    one of DP_STD_xxxx, the DP_STD_xxx has 240 x 240 dialog
//                    box units.
//
//
//                      DP_STD_TREEVIEWPAGE
//
//                          Specified that this page is a standard treeview
//                          page provided by the common ui.  The treeview page
//                          is a page using treeview display all valid OPTITEM
//                          passed to the common UI.  User can modify every
//                          valid selectable OPTITEM from the treeview page.
//
//                      DP_STD_DOCPROPPAGE
//
//                          Specified that this page is a standard document
//                          property page provided by the common UI
//
//  hDlgTemplate    - Handle to the DLGTEMPLATE which will be use for pop up
//                    dialog box
//
//
//  wReserved[]
//  dwReserved[]    - Reserved fields, must be 0
//
//
//  ** Tips of designing the dialog box controls
//
//      When designing the dialog box controls, each OPTITEM is correspoonds
//      to one input control plus one extended check box or extended push
//      button.  Since common UI will automatically disable and remove
//      OPTIF_HIDE items item from the property sheet and dynamically move
//      other controls, the following tips of designing the dialog box controls
//      should follow.
//
//      * Each item should have one input control plus optional of extended
//        check box/push botton, one icon control and other static controls
//
//      * Each item should occupied whole horizontal spaces of the property
//        sheet, items must not overlay in vertical direction.
//
//      * for TVOT_2STATES, TVOT_3STATES, if it araange radio buttons from
//        left to right in state order (ie. from first state's OPTPARAM to
//        last state's OPTPARAM) then the radio buttons and icons should
//        aligned in the Y coordinate.    If it arrange radio buttons from top
//        to bottom (ie. from first state's OPTPARAM to last state's OPTPARAM)
//        then the radio buttons and icons should aligned in the X coordinate.
//
//        common UI will automatically hide/move the radio buttons to compact
//        the dialog box controls.  If radio buttons/icons are arranged in
//        top/down order and there is other controls obscure in Y direction
//        then radio buttons will only be re-arranged but not remove any white
//        spaces in Y direction.
//
//      * If multiple items shared one group box, then the group box must
//        belongs to the first item (topmost in the dialog box group) in the
//        group, the group box must large enough to cover all the items in
//        side the group box.
//
//


#define CPSUIF_UPDATE_PERMISSION        0x0001
#define CPSUIF_ICONID_AS_HICON          0x0002
#define CPSUIF_ABOUT_CALLBACK           0x0004

#define CPSUI_PDLGPAGE_DOCPROP          (PDLGPAGE)1
#define CPSUI_PDLGPAGE_ADVDOCPROP       (PDLGPAGE)2
#define CPSUI_PDLGPAGE_PRINTERPROP      (PDLGPAGE)3
#define CPSUI_PDLGPAGE_TREEVIEWONLY     (PDLGPAGE)4

//
// For compatible misspelling #define
//

#define CPSUI_PDLGPAGE_TREEVIWONLY      CPSUI_PDLGPAGE_TREEVIEWONLY

typedef struct _COMPROPSHEETUI {
    WORD            cbSize;             // size of this structure
    WORD            Flags;              // CPSUIF_xxxx flags
    HINSTANCE       hInstCaller;        // caller's hInstance
    LPTSTR          pCallerName;        // pointer to the caller's name
    ULONG_PTR       UserData;           // caller's own data
    LPTSTR          pHelpFile;          // pointer to the help file
    _CPSUICALLBACK  pfnCallBack;        // callback function pointer
    POPTITEM        pOptItem;           // pointer to POPTITEM array
    PDLGPAGE        pDlgPage;           // pointer to the DLGPAGE array
    WORD            cOptItem;           // count of pOptItem array
    WORD            cDlgPage;           // count of pDlgPage array
    ULONG_PTR       IconID;             // icon to be used
    LPTSTR          pOptItemName;       // pointer to the optitem's data name
    WORD            CallerVersion;      // version for the caller apps
    WORD            OptItemVersion;     // version for the optitem name
    ULONG_PTR       dwReserved[4];      // reserved, must be 0
    } COMPROPSHEETUI, *PCOMPROPSHEETUI;


//
// COMPROPSHEETUI data structure is used when calling common UI to display dialog
// box of properties pages.
//
//
//  Size                - Must be sizeof (COMPROPSHEETUI)
//
//  Flags               - can be one or more of following
//
//                          CPSUIF_UPDATE_PERMISSION
//
//                              Specified the any valid pOptItem items are
//                              changeable by the user.
//
//
//                          CPSUIF_ICONID_AS_HICON
//
//                              If this flag is set then IconID DWORD field is
//                              treated as a handle to the icon rather then the
//                              resource ID
//
//
//                          CPSUIF_ABOUT_CALLBACK
//
//                              If this flag bit is set, then when user hit
//                              'About...' button in the treeview tab, it will
//                              call the callback function with a reason of
//                              CPSUICB_REASON_ABOUT, and callback MUST handle
//                              the about which pop-up dialog box to show user
//                              the information about the caller and OPTITEMs.
//
//                              If this bit is not set then common UI will call
//                              the ShellAbout() with formatted caller Name and
//                              pOptItemName with version numbers.
//
//
//  hInstCaller         - the caller's handle to its instance.  Commom UI use
//                        this handle to load caller's icon and other resources.
//
//  pCallerName         - Pointer to the caller's NULL terminated caller's
//                        name, most time this is driver's name,
//                        such as 'Postscript Driver'
//
//  UserData            - a 32-bit number used by the caller and common UI will
//                        not modify it.  this 32-bit number is passed back to
//                        the caller durning the callback function
//
//  pHelpFile           - specified a standard microsoft help file (path/file)
//                        for using in the common UI.  in OPTITEM specified
//                        HelpIndex for help in each item.
//
//  pfnCallBack         - Pointer to _CPSUICALLBACK callback function.  Common
//                        UI only callback to the caller if an OPTIF_CALLBACK
//                        is set OPTITEM data structure's flag fields and the
//                        item selection is changed by the user.
//
//  pOptItem            - Pointer to array of OPTITEM structure to be displayed
//                        by the common UI
//
//  pDlgPage            - Pointer to array of DLGPAGE structure to describe
//                        each property sheet page infomation, the following
//                        are the standard common ui DLGPAGEs.  When specified
//                        CPSUI_PDLGPAGE_xxxx, the common UI will automatically
//                        modify DlgPageIdx field in the OPTITEM, caller must
//                        set the iStartPage correctly.
//
//                          CPSUI_PDLGPAGE_DOCPROP
//
//                              specified this a common ui standard document
//                              property sheets. This includes two property
//                              sheets, 1) Page Setup 2) Advance (TreeView)
//
//
//                          CPSUI_PDLGPAGE_ADVDOCPROP
//
//                              Specified this is a treeview page only UI
//                              provided by the common UI, this only has one
//                              treeview page with tab of 'Advance'
//
//
//                          CPSUI_PDLGPAGE_PRINTERPROP
//
//                              Specified this is a common UI standard printer
//                              property sheet.  This only has one treeview
//                              page with tab of 'Device Options'
//
//
//                          CPSUI_PDLGPAGE_TREEVIEWONLY
//
//                              Specified this is a treeview page only UI
//                              provided by the common UI, this only has one
//                              treeview page
//
//
//
//  cOptItem            - Count of OPTITEM pointed by the pOptItem above
//
//  cDlgPage            - Count of DLGPAGE pointed by the pDlgPage.  If
//                        pDlgPage is one of the CPSUI_PDLGPAGE_xxxx then this
//                        field is ignored by the common UI.
//
//  IconID              - This is the icon identifier, which can be a common
//                        strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                        resource ID, or a handle to the caller defined icon
//                        if CPSUIF_ICONID_AS_HICON flag is set, in any case
//                        if the IconID is zero then it indicated no icon.
//
//  pOptItemName        - Pointer to the pOptItem data NULL terminated name,
//                        most time this is device name, such as 'HP 4si'
//
//  CallerVersion       - Version for the caller, the HIBYTE(CallerVersion) is
//                        the major version, and LOBYTE(CallerVersion) is the
//                        minor version, such as 0x310 display as 3.16, 0x3ff
//                        display as 3.255 and 0x30a display as 3.10
//
//  OptItemVersion      - Version for the OPTITEM's data, the
//                        HIBYTE(OptItemVersion) is the major version, and
//                        LOBYTE(OptItemVersion) is the minor version, such as
//                        0x310 display as 3.16, 0x3ff display as 3.255 and
//                        0x30a display as 3.10.
//
//  dwReserved[4]       - reserved fields, must be 0
//
//
//  ** pTitlee and TitleBarIcon only used if CommonPrinterPropSheetUI()
//     is the last one the Property sheet UI chain and call the PropertySheet()
//
//


#define CPSFUNC_ADD_HPROPSHEETPAGE          0
#define CPSFUNC_ADD_PROPSHEETPAGEW          1
#define CPSFUNC_ADD_PCOMPROPSHEETUIA        2
#define CPSFUNC_ADD_PCOMPROPSHEETUIW        3
#define CPSFUNC_ADD_PFNPROPSHEETUIA         4
#define CPSFUNC_ADD_PFNPROPSHEETUIW         5
#define CPSFUNC_DELETE_HCOMPROPSHEET        6
#define CPSFUNC_SET_HSTARTPAGE              7
#define CPSFUNC_GET_PAGECOUNT               8
#define CPSFUNC_SET_RESULT                  9
#define CPSFUNC_GET_HPSUIPAGES              10
#define CPSFUNC_LOAD_CPSUI_STRINGA          11
#define CPSFUNC_LOAD_CPSUI_STRINGW          12
#define CPSFUNC_LOAD_CPSUI_ICON             13
#define CPSFUNC_GET_PFNPROPSHEETUI_ICON     14
#define CPSFUNC_ADD_PROPSHEETPAGEA          15
#define CPSFUNC_INSERT_PSUIPAGEA            16
#define CPSFUNC_INSERT_PSUIPAGEW            17
#define CPSFUNC_SET_PSUIPAGE_TITLEA         18
#define CPSFUNC_SET_PSUIPAGE_TITLEW         19
#define CPSFUNC_SET_PSUIPAGE_ICON           20
#define CPSFUNC_SET_DATABLOCK               21
#define CPSFUNC_QUERY_DATABLOCK             22
#define CPSFUNC_SET_DMPUB_HIDEBITS          23
#define CPSFUNC_IGNORE_CPSUI_PSN_APPLY      24
#define CPSFUNC_DO_APPLY_CPSUI              25
#define CPSFUNC_SET_FUSION_CONTEXT          26
#define MAX_CPSFUNC_INDEX                   26

#ifdef UNICODE
#define CPSFUNC_ADD_PCOMPROPSHEETUI         CPSFUNC_ADD_PCOMPROPSHEETUIW
#define CPSFUNC_ADD_PFNPROPSHEETUI          CPSFUNC_ADD_PFNPROPSHEETUIW
#define CPSFUNC_LOAD_CPSUI_STRING           CPSFUNC_LOAD_CPSUI_STRINGW
#define CPSFUNC_ADD_PROPSHEETPAGE           CPSFUNC_ADD_PROPSHEETPAGEW
#define CPSFUNC_INSERT_PSUIPAGE             CPSFUNC_INSERT_PSUIPAGEW
#define CPSFUNC_SET_PSUIPAGE_TITLE          CPSFUNC_SET_PSUIPAGE_TITLEW

#else
#define CPSFUNC_ADD_PCOMPROPSHEETUI         CPSFUNC_ADD_PCOMPROPSHEETUIA
#define CPSFUNC_ADD_PFNPROPSHEETUI          CPSFUNC_ADD_PFNPROPSHEETUIA
#define CPSFUNC_LOAD_CPSUI_STRING           CPSFUNC_LOAD_CPSUI_STRINGA
#define CPSFUNC_ADD_PROPSHEETPAGE           CPSFUNC_ADD_PROPSHEETPAGEA
#define CPSFUNC_INSERT_PSUIPAGE             CPSFUNC_INSERT_PSUIPAGEA
#define CPSFUNC_SET_PSUIPAGE_TITLE          CPSFUNC_SET_PSUIPAGE_TITLEA

#endif

//
// for the CPSFUNC_SET_RESULT
//

#define SR_OWNER            0
#define SR_OWNER_PARENT     1

typedef struct _SETRESULT_INFO {
    WORD        cbSize;
    WORD        wReserved;
    HANDLE      hSetResult;
    LRESULT     Result;
    } SETRESULT_INFO, *PSETRESULT_INFO;

//
// This is for CPSFUNC_INSERT_PSUIPAGE
//

#define HINSPSUIPAGE_FIRST              (HANDLE)0xFFFFFFFE
#define HINSPSUIPAGE_LAST               (HANDLE)0xFFFFFFFF
#define HINSPSUIPAGE_INDEX(i)           (HANDLE)MAKELONG(i, 0);

#define PSUIPAGEINSERT_GROUP_PARENT     0
#define PSUIPAGEINSERT_PCOMPROPSHEETUI  1
#define PSUIPAGEINSERT_PFNPROPSHEETUI   2
#define PSUIPAGEINSERT_PROPSHEETPAGE    3
#define PSUIPAGEINSERT_HPROPSHEETPAGE   4
#define PSUIPAGEINSERT_DLL              5
#define MAX_PSUIPAGEINSERT_INDEX        5


#define INSPSUIPAGE_MODE_BEFORE         0
#define INSPSUIPAGE_MODE_AFTER          1
#define INSPSUIPAGE_MODE_FIRST_CHILD    2
#define INSPSUIPAGE_MODE_LAST_CHILD     3
#define INSPSUIPAGE_MODE_INDEX          4


typedef struct _INSERTPSUIPAGE_INFO {
    WORD        cbSize;
    BYTE        Type;
    BYTE        Mode;
    ULONG_PTR   dwData1;
    ULONG_PTR   dwData2;
    ULONG_PTR   dwData3;
    } INSERTPSUIPAGE_INFO, *PINSERTPSUIPAGE_INFO;


//
// for the CPSFUNC_SET_HSTARTPAGE
//

#define SSP_TVPAGE          10000
#define SSP_STDPAGE1        10001
#define SSP_STDPAGE2        10002

typedef LONG_PTR (CALLBACK *PFNCOMPROPSHEET)(HANDLE hComPropSheet,
                                             UINT   Function,
                                             LPARAM lParam1,
                                             LPARAM lParam2);


typedef struct _PSPINFO {
    WORD            cbSize;
    WORD            wReserved;
    HANDLE          hComPropSheet;
    HANDLE          hCPSUIPage;
    PFNCOMPROPSHEET pfnComPropSheet;
    } PSPINFO, *PPSPINFO;

//
// PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam) macro retrieve a pointer to the
// PSPINFO data structure. the lParam must be the lParam passed to the
// WM_INITDIALOG, otherwise the system can failed
//

#define PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam)  \
                (PPSPINFO)((LPBYTE)lParam + ((LPPROPSHEETPAGE)lParam)->dwSize)

//
// PSPINFO
//
//  This structure is used durning property sheet page's WM_INITDIALOG message.
//  At WM_INITDIALOG, the lParam is a pointer to the PROPSHEETPAGE, and
//  lParam field in the PROPSHEETPAGE is a pointer to the PSPINFO.  the
//  original lParam in the PROPSHEETPAGE is saved in the lParam field in the
//  PSPINFO data structure.
//
//  When process WM_INITDIALOG message, it should save the lParam (PSPINFO
//  structure pointer) for later to call common UI callback functions.
//
//
//  cbSize          - Size of this structure in bytes
//
//  wReserved       - Reserved, must be set to zero
//
//  hComPropSheet   - Handle to the parent page which is the hComPropSheet
//                    passed to the CPSFUNC_ADD_PROPSHEETPAGE
//
//  hCPSUIPage      - Handle to the this added common UI property sheet page.
//
//  pfnComPropSheet - Pointer to the common UI callback function, using this
//                    function pointer to do CPSFUNC_xxxx
//
//

typedef struct _CPSUIDATABLOCK {
    DWORD   cbData;
    LPBYTE  pbData;
    } CPSUIDATABLOCK, *PCPSUIDATABLOCK;


#define APPLYCPSUI_NO_NEWDEF        0x00000001
#define APPLYCPSUI_OK_CANCEL_BUTTON 0x00000002

//
// PFNCOMPROPSHEET function descriptions
//
// For each function index, it passed a handle, a Function Index and two (2)
// long parameters, the 'hComPropSheet' handle passed must be the handle passed
// from common UI when common UI called the caller supplied function
//
// pfnPropSheetUI(pPropSheetUIData);
//
// Following are the description of each function index
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_HPROPSHEETPAGE
//
//      This function add a page to the hComPropSheet using handle to the
//      PROPSHEETPAGE
//
//
//  Parameters:
//
//      lParam1 - is a handle to the PROPSHEETPAGE that created by the caller
//                using CreatePropertySheetPage()
//
//      lParam2 - Not used, must be 0
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page, if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PROPSHEETPAGE
//
//      This function add a page to the hComPropSheet using PROPSHEETPAGE
//      data structure.
//
//
//  Parameters:
//
//      lParam1 - is a pointer to PROPSHEETPAGE data structure
//
//      lParam2 - Not used.
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page, if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PCOMPROPSHEETUI
//
//      This function add propety page(s) to the hComPropSheet handle using
//      COMPROPSHEETUI data structure.
//
//
//  Parameters:
//
//      lParam1 - is a pointer to COMPROPSHEETUI data structure
//
//      lParam2 - pointer to a 32-bit location that received the total pages
//                added by the COMPROPSHEETUI data structure if sucessful else
//                it contains the ERR_CPSUI_xxx error codes.
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page(s), if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PFNPROPSHEETUI
//
//      This function add property page(s) to the hChild handle using
//      lParam1 as PFNPROPSHEETUI function pointer and lParam2 as the function
//      parameter.   The common UI call supplied function as following
//
//          PROPSHEETUI_INFO    PSUIInfo;
//
//          PSUIInfo.cbSize          = sizeof(PROPSHEETUI_INFO);
//          PSUIInfo.Version         = PROPSHEETUI_INFO_VERSION;
//          PSUIInfo.Flags           = (Ansi) ? 0: PSUIINFO_UNICODE;
//          PSUIInfo.Reason          = PROPSHEETUI_REASON_INIT;
//          PSUIInfo.hComPropSheet   = hComPropSheet;
//          PSUIInfo.pfnComPropSheet = ComPropSheetUICallBack;
//          PSUIInfo.lParamInit      = lParam2;
//          PSUIInfo.UserData        = 0;
//          PSUIInfo.Result          = 0;
//
//          ((PFNPROPSHEETUI)lParam1)(&PSUIInfo, lParam2);
//
//
//          If the pfnPropSheetUI() need to add/delete any common UI pages then
//          it must use hComPropSheet as its handle when calling the
//          ComPropSheetUICallBack().
//
//
//  Parameters:
//
//      lParam1 - a PFNPROPSHEETUI function pointer.
//
//      lParam2 - a 32-bit data that will be used as lParam when calling
//                PFNPROPSHEETUI function pointer.
//
//
//  Return Value:
//
//      The return value is the newly added property pages function handle, if
//      return value is NULL then function failed or no page is added.
//
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_DELETE_HCOMPROPSHEET
//
//      This function delete child property page(s) from hComPropSheet parent
//      using the child handle passed.
//
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that to be deleted.
//                This handle must be the handle returned from CPSFUNC_ADD_xxx
//                functions.
//
//      lParam2 - not used, must be 0
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_PAGECOUNT
//
//      This function return total property sheet pages belongs to a common
//      UI property sheet page handle hComPropSheet
//
//
//  Parameters:
//
//      lParam1 - not used, must be 0
//
//      lParam2 - not used, must be 0.
//
//
//  Return Value:
//
//      The return value is total page count if function sucessful or zero if
//      function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_RESULT
//
//      This function set the result of property sheet page to its owner that
//      added this page by CPSFUNC_ADD_xxx function indices
//
//  Parameters:
//
//      lParam1 - Handle to the common UI property sheet page that setting the
//                result.  If this handle is NULL then it is treated as
//                equal to the hComPropSheet.
//
//      lParam2 - a 32-bit DWORD result to be set.
//
//
//  Return Value:
//
//      > 0: Successful, return value is total count of parents set the result
//      = 0: There is no owner or parent for the lParam1 handle.
//      < 0: function failed because of invalid lParam1 handle.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_HSTARTPAGE
//
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that to be set
//                as initial page that appear when the property sheet dialog
//                boxes is created.  This handle must be the handle returned
//                from CPSFUNC_ADD_xxx functions.
//
//                If lParam1 is NULL then lParam2 is a string pointer to the
//                page name (tab) that to be set for the start page
//
//      lParam2 - a LONG number to specified the children index. if lParam1
//                handle is a parent then lParam2 specified zero base children
//                index for using as start page.
//
//                It also can be one of following special index
//
//                  SSP_TVPAGE
//
//                      set to the treeview page, this only valid if lParam1
//                      handle was added by the CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//                  SSP_STDPAGE
//
//                      Set to the standard document property sheet page
//                      (Page 1 user friendly page).  this only valid if
//                      lParam1 handle was added by the
//                      CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.  This function can only be
//      called when the property sheet is not display yet so the place to
//      call is during the PROPSHEETUI_REASON_GET_INFO_HEADER callback.
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_HPSUIPAGES
//
//      This function return array of children HPROPSHEETPAGE belongs to
//      the parent hComPropSheet UI property sheet page handle hComPropSheet
//
//
//  Parameters:
//
//      lParam1 - Pointer to an array of HPROPSHEETPAGE that to be stored
//                the handle upon return.
//
//      lParam2 - Count of HPROPSHEETPAGE array pointed by the lParam1
//
//
//  Return Value:
//
//      The return value is total HPROPSHEETPAGE stored in the array pointed
//      by the lParam1.   To get all hPropSheetPage for any common property
//      sheet handle's (hCPSUIPage) children, it can use following sequence.
//
//          if ((cPage = pfnComPropSheet(hComPropSheet,
//                                       CPSFUNC_GET_PAGECOUNT,
//                                       (LPARAM)hCPSUIPage,
//                                       0L))   &&
//              (phPage = ALLOCMEM(cPage * sizeof(HANDLE)))) {
//
//              pfnComPropSheet(hCPSUIPage,
//                              CPSFUNC_GET_HPSUIPAGES,
//                              (LPARAM)phPage,
//                              (LPARAM)cPage);
//          }
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_LOAD_CPSUI_STRING
//
//      This function load the common property sheet UI resource string
//
//  Parameters:
//
//      lParam1 - Pointer to LPTSTR string which will stored the loaded
//                resource string from the common property sheet UI DLL.
//
//      lParam2 - LOWORD(lParam2) = Count of characters (includes null
//                                  terminator) which pointed by the lParam1
//
//                HIWORD(lParam2) = Common property sheet UI predefined string
//                                  resource ID as IDS_CPSUI_xxxx
//
//
//  Return Value:
//
//      > 0: Total characters stored in the string pointed by the lParam1, this
//           is not includes the null terminator
//      = 0: Invalid IDS_CPSUI_xxx passed from HIWORD(lParam)
//      < 0: Either lParam1 is NULL or count of character is 0 from
//           LOWORD(lParam2)
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_LOAD_CPSUI_ICON
//
//      This function load the common property sheet UI resource icon.
//
//  Parameters:
//
//      lParam1 - Common property sheet UI predefined icon resource ID as
//                IDI_CPSUI_xxxx.
//
//      lParam2 - LOWORD(lParam2) = cx icon size in pixel.  If zero then
//                                  SM_CXICON is used
//                HIWORD(lParam2) = cy icon size in pixel.  If zero then
//                                  SM_CYICON is used
//
//
//  Return Value:
//
//      Return value is the handle to the hIcon if function succeed, a NULL
//      if function failed. The caller must call DestroyIcon() when it no
//      longer need to use the hIcon returned
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_PFNPROPSHEETUI_ICON
//
//      This function let the caller return hIcon of its children pages that
//      was added by CPSFUNC_ADD_PFNPROPSHEETUI
//
//  Parameters:
//
//      lParam1 - Handle of common property sheet pages that the hIcon will be
//                queried.  This handle must be the handle returned from
//                CPSFUNC_ADD_PFNPROPSHEETUI function.
//
//      lParam2 - LOWORD(lParam2) = cx icon size in pixel.  If zero then
//                                  SM_CXICON is used
//                HIWORD(lParam2) = cy icon size in pixel.  If zero then
//                                  SM_CYICON is used
//
//
//  Return Value:
//
//      Return value is the handle to the hIcon if function succeed, a NULL
//      if function failed. The caller must call DestroyIcon() when it no
//      longer need to use the hIcon returned
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_INSERT_PSUIPAGE
//
//      This function let the caller insert common property sheet pages at
//      set position.  The hComPropSheet must be the parent handle.
//
//  Parameters:
//
//      lParam1 - Handle of common property sheet pages that the page position
//                will be inserted.  This handle must be the handle returned
//                from previous CPSFUNC_ADD_xxx or CPSFUNC_INSERT_PSUIPAGE that
//                added or inserted using the hComPropSheet if the Mode field
//                in INSPSUIPAGE_INFO data structure is one of the follwing
//
//                  INSPSUIPAGE_MODE_BEFORE
//                  INSPSUIPAGE_MODE_AFTER      - Common UI page handle
//
//                  INSPSUIPAGE_MODE_INDEX      - the lParam1 is an zero based
//                                                child index.
//
//                  INSPSUIPAGE_MODE_FIRST_CHILD
//                  INSPSUIPAGE_MODE_LAST_CHILD - The lParam1 is ignonred.
//
//
//                If lParam1 is a valid common property sheet page handle then
//                it is  the child page handle of hComPropSheet that added by
//                CPSFUNC_ADD_xxx or inserted by CPSFUNC_INSERT_PSUIPAGE.
//
//      lParam2 - A pointer that points to INSERTPSUIPAGE_INFO data structure.
//                Fields must set according to the following.
//
//                  cbSize  - size of this structure
//
//                  Type    - Type of page(s) to be inserted.  It can be one
//                            of the following
//
//                      PSUIPAGEINSERT_GROUP_PARENT
//
//                          Insert a group parent that can be used to insert
//                          new pages under it.  This is typically used when
//                          a set of common UI pages must be group together and
//                          can be deleted later using a single group parent
//                          handle without individual deleting each page.
//
//                          This handle can be nested.  After this function
//                          returned the group parent handle, it can be used
//                          as hComPropSheet handle (first parameter in the
//                          common UI callback) as parent handle so insertion
//                          will be inserted at level below returned group
//                          parent handle.
//
//
//                      PSUIPAGEINSERT_PCOMPROPSHEETUI
//
//                          Insert pages using COMPROPSHEETUI data structure,
//                          dwData1 is a pointer to the COMPROPSHEETUI data
//                          structure.
//
//
//                      PSUIPAGEINSERT_PFNPROPSHEETUI
//
//                          Insert pages using PFNPROPSHEETUI function pointer.
//                          The dwData1 is a PFNPROPSHEETUI function pointer.
//                          The common UI will call this pfnPropSheetUI()
//                          function pointer with PROPSHEETUI_REASON_INIT to
//                          have it add pages.
//
//                          When common UI call pfnPropSheetUI() (dwData1) it
//                          also passed a 32-bit parameter from the dwData2
//                          field in INSERTPSUIPAGE_INFO data structure.
//
//
//                      PSUIPAGEINSERT_PROPSHEETPAGE
//
//                          Insert pages using PROPSHEETPAGE data structure.
//                          The dwData1 is a pointer to the PROPSHEETPAGE
//                          data structure.
//
//
//                      PSUIPAGEINSERT_HPROPSHEETPAGE
//
//                          Insert pages using HPROPSHEETPAGE handle.  The
//                          dwData1 is a PROPSHEETPAGE handle which was
//                          created by CreatePropertySheetPage().
//
//
//                      PSUIPAGEINSERT_DLL
//
//                          Insert pages from a dynnmaic link library.  The
//                          dwData1 is a pointer to a null terminated string
//                          that specified the dynamic link library file name.
//
//                          The dwData2 is a pointer to a null terminated ASCII
//                          string that specified the pfnPropSheetUI function
//                          name. (MUST BE ASCII STRING)
//
//                          Common UI will do a LoadLibrary((LPTSTR)dwData1),
//                          pfnPropSheetUI = GetProcAddress((LPTSTR)dwData2)
//                          then call the pfnPropSheetUI with a lParam from
//                          dwData3.  The called reason from common UI is
//                          set to PROPSHEETUI_REASON_INIT.
//
//                          Using this method insert pages will guaranteed that
//                          library will be unload correctly.
//
//
//                  Mode    - Insert Mode, it can be one of the following
//
//
//                      INSPSUIPAGE_MODE_BEFORE
//
//                          Insert pages before the common property sheet page
//                          handle specified by lParam1
//
//
//                      INSPSUIPAGE_MODE_AFTER
//
//                          Insert pages after the common property sheet page
//                          handle specified by lParam1
//
//
//                      INSPSUIPAGE_MODE_FIRST_CHILD
//
//                          Insert pages as the first child of hComPropSheet
//                          parent handle, the lParam1 is ignored
//
//
//                      INSPSUIPAGE_MODE_LAST_CHILD
//
//                          Insert pages as the last child of hComPropSheet
//                          parent handle, the lParam1 is ignored
//
//
//                      INSPSUIPAGE_MODE_INDEX
//
//                          Insert pages as a zero base child index of its
//                          parent handle specified by hComPropSheet.
//
//                          The lParam1 is the zero based index special handle
//                          that must generated by HINSPSUIPAGE_INDEX(Index)
//                          macro.   If the index is greater than or equal to
//                          the total count of children then it will treat the
//                          mode same as INSPSUIPAGE_MODE_LAST_CHILD
//
//
//                  dwData1
//                  dwData2
//                  dwData3 - 32-bit data associate with the 'Type' field
//                            as following
//
//
//                      PSUIPAGEINSERT_GROUP_PARENT
//
//                          dwData1 = Not used, must be 0
//                          dwData2 = Not used, must be 0
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PCOMPROPSHEETUI
//
//                          dwData1 = pointer to COMPORPSHEETUI data structure.
//                          dwData2 = at return if sucessful, it contains total
//                                    page added.  If failed, it contains the
//                                    ERR_CPSUI_xxx codes
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PFNPROPSHEETUI
//
//                          dwData1 = PFNPROPSHEETUI function pointer
//                          dwData2 = 32-bit parameter passed to pfnPropSheetUI
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PROPSHEETPAGE
//
//                          dwData1 = Pointer to PROPSHEETPAGE data structure.
//                          dwData2 = not used, must be 0
//                          dwData3 = not used, must be 0
//
//
//                      PSUIPAGEINSERT_HPROPSHEETPAGE
//
//                          dwData1 = Is the HPROPSHEETPAGE handle that created
//                                    by a call to CreatePropertySheetPage().
//                          dwData2 = not used, must be 0
//                          dwData3 = not used, must be 0
//
//
//                      PSUIPAGEINSERT_DLL
//
//                          dwData1 = Pointer to a null terminated dynamic link
//                                    library filename.
//                          dwData2 = Pointer to a null terminated function
//                                    name (PFNPROPSHEETUI) in the dynamin link
//                                    library.
//                          dwData3 = 32-bit parameter passed to pfnPropSheetUI
//                                    (PFNPROPSHEETUI) function from dwData2
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page(s), if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_PSUIPAGE_TITLE
//
//      This function let the caller set a new title for a particular common
//      UI page title (on the property sheet page tab)
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that title to be
//                set.  This handle must be the handle returned from following
//
//                  CPSFUNC_ADD_PROPSHEETPAGE
//                  CPSFUNC_ADD_HPROPSHEETPAGE
//                  CPSFUNC_INSERT_PSUIPAGE with type of
//                              PSUIPAGEINSERT_PROPSHEETPAGE or
//                              PSUIPAGEINSERT_HPROPSHEETPAGE
//
//      lParam2 - Pointer to a null terminated string for the new title
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
//      This function will returned 0 if the property sheet pages is not
//      currently displayed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_PSUIPAGE_ICON
//
//      This function let the caller set a new icon for a particular common
//      UI page icon (on the property sheet page tab)
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that icon to be
//                set.  This handle must be the handle returned from following
//
//                  CPSFUNC_ADD_PROPSHEETPAGE
//                  CPSFUNC_ADD_HPROPSHEETPAGE
//                  CPSFUNC_INSERT_PSUIPAGE with type of
//                              PSUIPAGEINSERT_PROPSHEETPAGE or
//                              PSUIPAGEINSERT_HPROPSHEETPAGE
//
//      lParam2 - Handle to Icon, this icon is best as 16x16 icon otherwise it
//                will be stretch to 16x16 (pixel).
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
//      This function will returned 0 if the property sheet pages is not
//      currently displayed.
//
//      After this function is successful set the icon, the caller can destroy
//      the hIcon using DestroyIcon() if the hIcon is created by CreateIcon().
//      If the hIcon (lParam2) passed is using LoadIcon() then it does not need
//      to destroy the icon.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_DATABLOCK
//
//      This function let the caller register a new data block so it can be
//      later query by other pages in the property sheet, this function should
//      call durning PSN_KILLACTIVE message
//
//  Parameters:
//
//      lParam1 - pointer CPSUIDATABLOCK structure which speicifed the buffer
//                and size for queried datablock identify by lParam2 to be set.
//
//      lParam2 - DWORD Identifier of data block to be set
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful which
//      indicate total bytes of data block registered.  If return value is less
//      or equal to zero then function failed and data block is not registered.
//
//      If lParam1 is NULL, (lParam1)->cbData or (lParam1)->pbbData is NULL
//      it return a -1 to indicate an error parameter passed.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_QUERY_DATABLOCK
//
//      This function let the caller query a registered data block so it can
//      used this data block to communicate between property sheet pages.
//      This function should call durning PSN_SETACTIVE message
//
//  Parameters:
//
//      lParam1 - pointer CPSUIDATABLOCK structure which speicifed the buffer
//                and size for queried datablock identify by lParam2
//
//      lParam2 - DWORD Identifier of data block to be queried
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful which
//      indicate total bytes of data block copied into the pointer pointed by
//      the lParam1.  If return value is less or equal to zero then function
//      failed and data block is not copied to diciate the spcified datablock
//      Identifier (lParam2) is not found.
//
//      If CPSUIDATABLOCK pointer (lParam1) is NULL, (lParam1)->cbData or
//      (lParam1)->pbData is NULL then return value is the total bytes required
//      to copy the specified datablock identifier, if return value is less or
//      equal to zero then it indicate the spcified datablock identifier is
//      not found.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_DMPUB_HIDEBITS
//
//      This function let the caller hide a set of predefined OPTITEMS in the
//      pages that was created using PSUIPAGEINSERT_PCOMPROPSHEETUI or
//      CPSFUNC_ADD_PCOMPROPSHEETUI with pDlgPage equal to
//      CPSUI_PDLGPAGE_DOCPROP or CPSUI_PDLGPAGE_ADVDOCPROP.
//
//      This function MUST called BEFORE the DOCPROP or ADVDOCPROP property
//      sheet pages are added using  PSUIPAGEINSERT_PCOMPROPSHEETUI or
//      CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//  Parameters:
//
//      lParam1 - prdefined bit array masks to specified which DOCPROP item to
//                be hidden.  Each DMPUB item bit can be generate using macro
//                MAKE_DMPUB_HIDEBIT() and all items can be OR together.
//
//      lParam2 - Not used, MUST be 0
//
//
//  Return Value:
//
//      The return value is equal to lParam1 if this function is called before
//      DOCPROP or ADVDOCPROP pages are added. Return value is zero if these
//      pages already added which means failure.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_IGNORE_CPSUI_PSN_APPLY
//
//      This function let caller control how CPSUI process PSN_APPLY messages
//      for pages added through CPSFUNC_ADD_PCOMPROPSHEETUI or
//      CPSFUNC_INSERT_PSUIPAGE with type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      If this function never called, the Default CPSUI behavior is to process
//      PSN_APPLY messages.
//
//  Parameters:
//
//      lParam1 - Handle to the page returned from pages added by using
//                CPSFUNC_ADD_PCOMPROPSHEETUI or CPSFUNC_INSERT_PSUIPAGE with
//                type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      lParam2 - A non-zero value indicate to IGNORE the PSN_APPLY messages
//                for pages handle of lParam1.
//
//                A zero value to have CPSUI nomally process (not ignored) the
//                PSN_APPLY messages for pages handle of lParam1.
//
//                WARNING: if a PSN_APPLY messages are ignored, the caller must
//                         simulate a PSN_APPLY using CPSFUNC_DO_APPLY_CPSUI
//                         function or all changes WILL NOT applied, this is
//                         true even user hit 'OK' button.
//
//  Return Value:
//
//      the return value is zero if function failed, or non-zero to indicate
//      the function is successful.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_DO_APPLY_CPSUI
//
//      This function let caller simulate an apply (PSN_APPLY) to the pages
//      which added through CPSFUNC_ADD_PCOMPROPSHEETUI or
//      CPSFUNC_INSERT_PSUIPAGE with type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//  Parameters:
//
//      lParam1 - Handle to the page returned from pages added by using
//                CPSFUNC_ADD_PCOMPROPSHEETUI or CPSFUNC_INSERT_PSUIPAGE with
//                type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      lParam2 - 32-bit flag to indicate how to do apply, currently only
//
//                  APPLYCPSUI_NO_NEWDEF
//
//                      The APPLYCPSUI_NO_NEWDEF bit specified that after the
//                      apply is done the undo buffer for all OPTITEMs still
//                      remain unchanged, this make next undo still possible.
//
//                      If APPLYCPSUI_NO_NEWDEF bit is clear then undo buffers
//                      are re-initialized after apply is done, the current
//                      changes for all OPTITEMs become the new undo default.
//
//
//                  APPLYCPSUI_OK_CANCEL_BUTTON
//
//                      If bit is set then it specified the apply is simulate
//                      a user hit 'Ok' or 'Cancel' button, if this bit is
//                      clear then it simulate a user hit 'Close' or 'Apply'
//                      button.  If caller getting a PSN_APPLY message, it can
//                      simulated using passed PSHNOTIFY (passed as lParam in
//                      WM_NOTIFY message) structure to determine how to set
//                      this bit as follow.
//
//                          if PSHNOTIFY.lParam == 0, then clear this bit
//                          otherwise set this bit.
//
//
//  Return Value:
//
//      the return value is less or equal to zero if it encounter an error and
//      apply failed (the active page will be switch to these pages).
//
//      If return value is greater than zero then changes were applied and
//      function sucessful.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_FUSION_CONTEXT
//
//      This function is used to set a fusion activation context for
//      the specified page.
//
//  Parameters:
//
//      lParam1 - handle to fusion context. compstui duplicates the handle 
//                prior attaching it to its internal structures, so the caller
//                is not bound to keep the handle around. we release the 
//                passed in context handle when the compstui handle is deleted.
//
//      lParam2 - not used
//
//  Return Value:
//
//      the return value is less or equal to zero if it encounter an error and/or
//      something failed (look up the last error for details).
//
//      If return value is greater than zero then the call was sucessful.
//
// -------------------------------------------------------------------------
//


#define PROPSHEETUI_REASON_INIT             0
#define PROPSHEETUI_REASON_GET_INFO_HEADER  1
#define PROPSHEETUI_REASON_DESTROY          2
#define PROPSHEETUI_REASON_SET_RESULT       3
#define PROPSHEETUI_REASON_GET_ICON         4
#define MAX_PROPSHEETUI_REASON_INDEX        4

#define PROPSHEETUI_INFO_VERSION            0x0100

#define PSUIINFO_UNICODE                    0x0001

typedef struct _PROPSHEETUI_INFO {
    WORD            cbSize;
    WORD            Version;
    WORD            Flags;
    WORD            Reason;
    HANDLE          hComPropSheet;
    PFNCOMPROPSHEET pfnComPropSheet;
    LPARAM          lParamInit;
    ULONG_PTR       UserData;
    ULONG_PTR       Result;
    } PROPSHEETUI_INFO, *PPROPSHEETUI_INFO;


//
// For the PROPSHEETUI_REASON_GET_ICON call which lParam is a pointer to
// PROPSHEETUI_GETICON_INFO
//

typedef struct _PROPSHEETUI_GETICON_INFO {
    WORD    cbSize;
    WORD    Flags;
    WORD    cxIcon;
    WORD    cyIcon;
    HICON   hIcon;
    } PROPSHEETUI_GETICON_INFO, *PPROPSHEETUI_GETICON_INFO;


typedef LONG (FAR *PFNPROPSHEETUI)(PPROPSHEETUI_INFO   pPSUIInfo,
                                   LPARAM              lParam);


//
// PFNPROPSHEETUI
//
//  This function is user defined function which will be called by the common
//  UI when a caller wish to include the executable property sheets.
//
//  pPSUIInfo   - Pointer to PROPSHEETUI_INFO below for description of
//                PROPSHEETUI_INFO.
//
//                If this pointer is NULL then this function is not called from
//                common UI, and lParam should be used to determined the
//                action and outcome of this funciton.
//
//  lParam      - A LPARAM intented for this funciton depends on the reason.
//                If pPSUIInfo is NULL then this function is not called from
//                common UI, the lParam is the parameter which agreed with
//                the caller.
//
//                if pPSUIInfo is not NULL then this function assume the call
//                is from the common UI.  lParam has following meanion depends
//                on the reason field.
//
//                PROPSHEETUI_REASON_INIT
//
//                  The lParam is either passed from CPSFUNC_ADD_PFNPROPSHEETUI
//                  callback function's second parameter (lParam2) or it is
//                  from CommonPropertySheetUI()'s lParam (seccond parameter)
//                  without any modification.
//
//                  The lParam MUST NOT be a variable or a pointer to memory
//                  block which resides on the caller function's stack, since
//                  after this function exit, the lParam will become invalid
//                  and can cause fatal system error.
//
//                  The lParam parameter is copied to the lParamInit field in
//                  PROPSHEETUI_INFO data structure.  The lParamInit field
//                  will be passed to all subsequent pfnPropSheetUI() calls
//                  without any modification.
//
//
//                PROPSHEETUI_REASON_GET_INFO_HEADER:
//
//                  lParam is a pointer to the PROPSHEETUI_INFO_HEADER data
//                  structure. this function must correctly fill this structure
//                  fields before it returned.
//
//
//                PROPSHEETUI_REASON_DESTROY
//
//                  lParam is zero to indicate the destroy is cause either by a
//                  caller calling CPSFUNC_DELETE_HCOMPROPSHEET or failed
//                  in caller's CPSFUNC_ADD_xxxx.
//
//                  lParam is non zero to indicate the destroy is cause by
//                  exiting from the property sheet user interface.
//
//
//                PROPSHEETUI_REASON_SET_RESULT
//
//                  lParam is a pointer to SETRESULT_INFO data structure.
//                  Fields in SETRESULT_INFO data structure is set to following
//
//                      hSetResult: Handle to the common UI property sheet
//                                  pages which added by the CPSFUNC_ADD_xxx
//                                  callback function indices.
//
//                          Result: The result from the hSetResult to be set.
//                                  When return greater than zero then Result
//                                  in this field is set to its parent.
//
//
//                PROPSHEETUI_REASON_GET_ICON
//
//                  lParam is a pointer to PROPSHEETUI_GETICON_INFO data
//                  structure.  Fields in PROPSHEETUI_GETICON_INFO data
//                  structure are set to following
//
//                      cxIcon = cx Icon size in pixel
//                      cyIcon = cy Icon size in pixel
//                      hIcon  = Initial to NULL, and this function must put
//                               the created icon handle in this field before
//                               returned.
//


//
// PROPSHEETUI_INFO
//
//  This structure is used when common UI calling the caller passed function
//  entry point PFNPROPSHEETUI, the pfnPropSheetUI() return a LONG to
//  indicate result of this function.
//
//  When the pfnPropSheetUI() returned, it must also put the required result
//  in the Result field, each PROPSHEETUI_REASON_xxx has different required
//  result as describe below.
//
//
//
//  cbSize          - sizeof this structure (PROPSHEETUI_INFO)
//
//  Version         - the PROPSHEETUI_INFO data structure version. Current
//                    version is set to PROPSHEETUI_INFO_VERSION
//
//  Flags           - One or more following is may be defined
//
//                      PSUIINFO_UNICODE
//
//                          The caller's executable was original compiled was
//                          intented using unicode.
//
//
//  Reason          - Following reasons are defined.
//
//                      PROPSHEETUI_REASON_INIT
//
//                          When first time the pfnPropSheetUI() called, this
//                          reason is used to have the function initialize
//                          itself and use the pfnComPropSheet() function
//                          pointer provided to add new pages to the
//                          hComPropSheet handle passed.   The UserData in this
//                          data structure is initially set equal to zero (0).
//
//                          * Return > 0 to indicate sucesful and <= 0 to
//                            indicate error.
//
//                      *NOTE*
//
//                          The lParam MUST NOT be a variable or a pointer to
//                          memory block which resides on the caller function's
//                          stack, since after this function exit, the lParam
//                          will become invalid and can cause fatal system
//                          error.
//
//                          If this function reason returned failed ( <= 0),
//                          this function (pfnPropSheetUI) will received a
//                          PROPSHEETUI_REASON_DESTROY function reason right
//                          after this function reason returned.
//
//
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//
//                          It is called after the PROPSHEETUI_REASON_INIT is
//                          successful returned.  This reason is used to asked
//                          the function fill in the PROPSHEETUI_INFO_HEADER
//                          for pop-up the property sheet dialog boxes.
//
//                          lParam in this reason is a pointer to the
//                          PROPSHEETUI_INFO_HEADER data structure, following
//                          fields are requrested to be filled in.
//
//                              Flags       - PSUIHDRF_xxx flags
//                              pTitle      - The property sheet title
//                              hWndParent  - handle to the parent of property
//                                            sheet pages.
//                              hInst       - Instance data handle for this
//                                            function.
//                              hIcon
//                              IconID      - Icon used on the title bar.
//
//                          * Return > 0 to indicate sucesful and pop-up the
//                            property sheet dialog boxes or returned <= 0 to
//                            indicate error (not property sheet UI appeared)
//
//
//                      PROPSHEETUI_REASON_DESTROY
//
//                          When the property sheet ready to dismissed or the
//                          caller is delete the common UI pages added by the
//                          pfnPropSheetUI(), the common UI will call this
//                          entry point to have it de-initialized itself and
//                          free up all the memory used for this function
//                          instance.  The UserData field passed is the
//                          'UserData' field which returned from previous
//                          PROPSHEETUI_REASON_xxxx.
//
//                          When this function called, all hComPropSheet's
//                          children are desotroyed and children's common UI
//                          handles are not longer valid.
//
//                          * Return > 0 to indicate sucesful and <= 0 to
//                            indicate error.
//
//
//                      PROPSHEETUI_REASON_SET_RESULT
//
//                          The reason is used when an added handle from
//                          CPSFUNC_ADD_xxxx whant to return the result to
//                          this pfnPropSheetUI() caller.
//
//                          The lParam in second parameter is a pointer to a
//                          SETRESULT_INFO data structure.
//
//                              hSetResult: specified the common UI property
//                                          sheet page handle which added by
//                                          this function using
//                                          CPSFUNC_ADD_xxx indicies.
//
//                                  Result: Specified the Result to be set to
//                                          this pfnPropSheetUI() form the
//                                          hSetResult property sheet page
//                                          handle. If return value is greater
//                                          than zero then the value in this
//                                          Result field will be set to its
//                                          parent if one exist, at this case
//                                          this function can alter the Result
//                                          field value for its parent.
//
//                          * Returned greater than zero to continue send to
//                            its parent, else it stop sending the Result filed
//                            value to its parent.
//
//
//                      PROPSHEETUI_REASON_GET_ICON
//
//                          The reason is used to retrived the Icon which
//                          represent this pfnPropSheetUI().
//
//                          lParam is a pointer to PROPSHEETUI_GETICON_INFO '
//                          data structure.  Fields in PROPSHEETUI_GETICON_INFO
//                          data structure are set to following
//
//                              cxIcon = cx Icon size in pixel
//                              cyIcon = cy Icon size in pixel
//                              hIcon  = Initial to NULL, and this function
//                                       must put the created icon handle in
//                                       this field before return.
//
//
//                          * Return > 0 to indicate sucesful (hIcon is the
//                            requested icon handle).   Return = 0 to indicate
//                            no icon available, or return < 0 to indicate an
//                            error.
//
//              *NOTE*
//
//                  * For all PROPSHEETUI_REASON_xxx, the function can set new
//                    user defined DWORD data in the PROPSHEETUI_INFO data
//                    structure's UserData field.
//
//                  * For all PROPSHEETUI_REASON_xxx, the function can set new
//                    pfnPropSheetUI() DWORD result in PROPSHEETUI_INFO data
//                    structure's Result field.
//
//
//  hComPropSheet   - Handle to the COMPROPSHEETPAGE which this function should
//                    used as hComPropSheet parameter when calling
//                    pfnComPropSheet() to add or delete common UI property
//                    sheet pages.  The hComPropSheet is the instance handle to
//                    pfnPropSheetUI() function.
//
//  pfnComPropSheet - Pointer to the common UI callback function which for the
//                    pfnPropSheetUI() to add, delete, set user data, for a
//                    completed set of callback, see CPSFUNC_xxx descriptions
//                    above.
//
//  lParamInit      - The lParam originally passed duning the the first call
//                    reason PROPSHEETUI_REASON_INIT.  The lParamInit will be
//                    passed to each PROPSHEETUI_REASON_xxx calls.
//
//  UserData        - the UserData field is an IN and OUT parameter for each
//                    of the Reason,
//
//                      PROPSHEETUI_REASON_INIT
//
//                           IN: Initial set to zero (0).
//
//                          OUT: Specified new callee's own user data which
//                               will be passed back to other reason calls.
//
//
//                      PROPSHEETUI_REASON_DESTROY
//                      PROPSHEETUI_REASON_SET_RESULT
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//
//                           IN: The UserData specified at time when returned
//                               from the previous PROPSHEETUI_REASON_xxx
//
//                          OUT: Specified new callee's own user data which
//                               will be passed back to other reason calls.
//
//
// Result           - The Result field is an IN and OUT parameter for each of
//                    the reason.
//
//                      PROPSHEETUI_REASON_INIT
//
//                           IN: Set to zero (0).
//
//                          OUT: Set to default result of this PropSheetUI()
//                               function.
//
//
//                      PROPSHEETUI_REASON_DESTROY
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//                      PROPSHEETUI_REASON_SET_RESULT
//
//                           IN: The current 'Result' returned from previous
//                               PROPSHEETUI_REASON_xxx function.
//
//                          OUT: Set the new result of this PropSheetUI()
//                               function.
//
//


#define PSUIHDRF_OBSOLETE       0x0001
#define PSUIHDRF_NOAPPLYNOW     0x0002
#define PSUIHDRF_PROPTITLE      0x0004
#define PSUIHDRF_USEHICON       0x0008
#define PSUIHDRF_DEFTITLE       0x0010
#define PSUIHDRF_EXACT_PTITLE   0x0020

typedef struct _PROPSHEETUI_INFO_HEADER {
    WORD                    cbSize;
    WORD                    Flags;
    LPTSTR                  pTitle;
    HWND                    hWndParent;
    HINSTANCE               hInst;
    union {
        HICON               hIcon;
        ULONG_PTR           IconID;
        } DUMMYUNIONNAME;
    } PROPSHEETUI_INFO_HEADER, *PPROPSHEETUI_INFO_HEADER;

//
// PROPSHEETUI_INFO_HEADER
//
//  This data structure is used when common UI ready to pop-up the property
//  sheet page dialog boxes and it asked caller to provide more information.
//
//  Common property sheet UI passed this data structure as lParam when it call
//  provided pfnPropSheetUI() with PROPSHEETUI_REASON_GET_INFO_HEADER reason.
//
//
//  cbSize      - size of this structure
//
//  Flags       - PSUIHDRF_xxxx flags
//
//                  PSUIHDRF_OBSOLETE
//
//                      Not used, must not set this bit
//
//
//                  PSUIHDRF_NOAPPLYNOW
//
//                      Remove 'Apply Now' button.
//
//
//                  PSUIHDRF_PROPTITLE
//
//                      Automatically include 'Properties' in the title bar
//
//
//                  PSUIHDRF_USEHICON
//
//                      If this bit is specified then hIcon union field is
//                      a valid handle to the icon otherwise the IconID is
//                      the either caller's resource ID or common UI standard
//                      icon ID.
//
//                  PSUIHDRF_DEFTITLE
//
//                      Automatically include 'Default' in the title bar, the
//                      'Default' always added right after pTitle and before
//                      'Properties' if PSUIHDRF_PROPTITLE flag is set.
//
//                  PSUIHDRF_EXACT_PTITLE
//
//                      This flag indicate the pTitle set in this structure
//                      will be use without any modification by the compstui
//                      ie. compstui will not modified pTitle in any way and
//                      it will ignored PSUIHDRF_PROPTITLE, PSUIHDRF_DEFTITLE
//
//
//  pTitle      - Pointer to the NULL terminated caption name for the
//                property sheets.
//
//                  ** See LPTSTR typedef description above
//
//  hWndParent  - The handle of the window which will be parent of the common
//                UI property sheets, if NULL then current active window for
//                the calling thread is used.
//
//  hInst       - the caller's handle to its instance.  Commom UI use this
//                handle to load caller's icon and other resources.
//
//  hIcon
//  IconID      - Specified the icon which put on the title bar, it either a
//                handle to the icon or a icon resource ID depends on the
//                PSUIHDRF_USEHICON flag.
//



//
// LONG
// CommonPropertySheetUI(
//     HWND            hWndOwner,
//     PFNPROPSHEETUI  pfnPropSheetUI,
//     LPARAM          lParam,
//     LPDWORD         pResult
//     );
//
//
// The CommonPropSheetUI is the main entry point for the common property sheet
// user interface.   The original caller that wish to using common UI to pop-up
// property sheet will call this function and passed its own PFNPROPSHEETUI
// function address and a long parameter.
//
// If pfnPropSheetUI function return a LONG number greater than zero (0) then
// common UI will pop-up the property sheet page dialog boxes, when Property
// sheet pages is finished. (either hit Ok or Cancel) it will return the
// result of CPSUI_xxxx back to the caller.
//
// If pfnPropSheetUI function return a LONG number equal or less than zero (0)
// then it will return the CPSUI_CANCEL back to caller without pop-up the
// property sheet page dialog boxes.
//
//
//  Parameters:
//
//      hWndOwner       - Window handle for the owner of this proerty sheet
//                        pages dialog boxes.
//
//      pfnPropSheetUI  - a PFNPROPSHEETUI function pointer which is used by
//                        the caller to add its property sheet pages.
//
//      lParam          - a long parameter will be passed to the pfnPropSheetUI
//                        funciton.  The common UI called the pfnPropSheetUI as
//
//                          PROPSHEETUI_INFO    PSUIInfo;
//
//                          pfnPropSheetUI(&PSUIInfo, lParam);
//
//                        The caller must use pfnComPropSheet() to add/delete
//                        pages.  When it is done adding pages, it retuned
//                        greater than zero to indicate successful, and return
//                        less or equal to zero to indicate failure.
//
//      pResult         - a pointer to DWORD which received the final result
//                        of pfnPropSheetUI() funciton, this result is a copy
//                        from Result field of PROPSHEETUI_INFO data structure
//                        which passed to the pfnPropSheetUI() as the first
//                        parameter.  The pResult only will be set if the
//                        returned value from CommonPropertySheetUI() is not
//                        ERR_CPSUI_xxx.
//
//                        if pResult is NULL then common UI will not return
//                        pfnPropSheetUI()'s result back.
//
//
//  Return Value:
//
//      LONG    - < 0                   - property page does not displayed and
//                                        ERR_CPSUI_xxx is the error code
//                CPSUI_OK              - property page displayed.
//                CPSUI_RESTARTWINDOWS  - property page displayed and need to
//                                        restart window to take effect
//                CPSUI_REBOOTSYSTEM    - property page dispalyed and need
//                                        to reboot system to take effect
//
//


LONG
APIENTRY
CommonPropertySheetUIA(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    );

LONG
APIENTRY
CommonPropertySheetUIW(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    );


#ifdef UNICODE
#define CommonPropertySheetUI   CommonPropertySheetUIW
#else
#define CommonPropertySheetUI   CommonPropertySheetUIA
#endif



//
// GetCPSUIUserData() and SetCPSUIUserData() is used for the pages added
// by the CPSFUNC_ADD_PCOMPROPSHEETUI.  The caller add this function and has
// sub class dialog procedure should not set DWLP_USERDATA but calling these
// function instead, otherwise the system can failed.
//

ULONG_PTR
APIENTRY
GetCPSUIUserData(
    HWND    hDlg
    );

BOOL
APIENTRY
SetCPSUIUserData(
    HWND        hDlg,
    ULONG_PTR   CPSUIUserData
    );


#define CPSUI_CANCEL                        0
#define CPSUI_OK                            1
#define CPSUI_RESTARTWINDOWS                2
#define CPSUI_REBOOTSYSTEM                  3

#define ERR_CPSUI_GETLASTERROR              -1
#define ERR_CPSUI_ALLOCMEM_FAILED           -2
#define ERR_CPSUI_INVALID_PDATA             -3
#define ERR_CPSUI_INVALID_LPARAM            -4
#define ERR_CPSUI_NULL_HINST                -5
#define ERR_CPSUI_NULL_CALLERNAME           -6
#define ERR_CPSUI_NULL_OPTITEMNAME          -7
#define ERR_CPSUI_NO_PROPSHEETPAGE          -8
#define ERR_CPSUI_TOO_MANY_PROPSHEETPAGES   -9
#define ERR_CPSUI_CREATEPROPPAGE_FAILED     -10
#define ERR_CPSUI_MORE_THAN_ONE_TVPAGE      -11
#define ERR_CPSUI_MORE_THAN_ONE_STDPAGE     -12
#define ERR_CPSUI_INVALID_PDLGPAGE          -13
#define ERR_CPSUI_INVALID_DLGPAGE_CBSIZE    -14
#define ERR_CPSUI_TOO_MANY_DLGPAGES         -15
#define ERR_CPSUI_INVALID_DLGPAGEIDX        -16
#define ERR_CPSUI_SUBITEM_DIFF_DLGPAGEIDX   -17
#define ERR_CPSUI_NULL_POPTITEM             -18
#define ERR_CPSUI_INVALID_OPTITEM_CBSIZE    -19
#define ERR_CPSUI_INVALID_OPTTYPE_CBSIZE    -20
#define ERR_CPSUI_INVALID_OPTTYPE_COUNT     -21
#define ERR_CPSUI_NULL_POPTPARAM            -22
#define ERR_CPSUI_INVALID_OPTPARAM_CBSIZE   -23
#define ERR_CPSUI_INVALID_EDITBOX_PSEL      -24
#define ERR_CPSUI_INVALID_EDITBOX_BUF_SIZE  -25
#define ERR_CPSUI_INVALID_ECB_CBSIZE        -26
#define ERR_CPSUI_NULL_ECB_PTITLE           -27
#define ERR_CPSUI_NULL_ECB_PCHECKEDNAME     -28
#define ERR_CPSUI_INVALID_DMPUBID           -29
#define ERR_CPSUI_INVALID_DMPUB_TVOT        -30
#define ERR_CPSUI_CREATE_TRACKBAR_FAILED    -31
#define ERR_CPSUI_CREATE_UDARROW_FAILED     -32
#define ERR_CPSUI_CREATE_IMAGELIST_FAILED   -33
#define ERR_CPSUI_INVALID_TVOT_TYPE         -34
#define ERR_CPSUI_INVALID_LBCB_TYPE         -35
#define ERR_CPSUI_SUBITEM_DIFF_OPTIF_HIDE   -36
#define ERR_CPSUI_INVALID_PUSHBUTTON_TYPE   -38
#define ERR_CPSUI_INVALID_EXTPUSH_CBSIZE    -39
#define ERR_CPSUI_NULL_EXTPUSH_DLGPROC      -40
#define ERR_CPSUI_NO_EXTPUSH_DLGTEMPLATEID  -41
#define ERR_CPSUI_NULL_EXTPUSH_CALLBACK     -42
#define ERR_CPSUI_DMCOPIES_USE_EXTPUSH      -43
#define ERR_CPSUI_ZERO_OPTITEM              -44


#define ERR_CPSUI_FUNCTION_NOT_IMPLEMENTED  -9999
#define ERR_CPSUI_INTERNAL_ERROR            -10000

#endif  // (!defined(RC_INVOKED))



//
//****************************************************************************
//*                                                                          *
//*      Common Property Sheet UI resource ID for the ICONs and STRINGs      *
//*                                                                          *
//* The Resource ID from 64000 to 65535 are reserved for common UI and must  *
//* not used as caller resource ID else the string, icon loading will not be *
//* correct.                                                                 *
//*                                                                          *
//****************************************************************************
//


//
// Common UI standard 32x32, 16x16 color and monochrome Icon IDs
//

#define IDI_CPSUI_ICONID_FIRST          64000

#define IDI_CPSUI_EMPTY                 64000
#define IDI_CPSUI_SEL_NONE              64001
#define IDI_CPSUI_WARNING               64002
#define IDI_CPSUI_NO                    64003
#define IDI_CPSUI_YES                   64004
#define IDI_CPSUI_FALSE                 64005
#define IDI_CPSUI_TRUE                  64006
#define IDI_CPSUI_OFF                   64007
#define IDI_CPSUI_ON                    64008
#define IDI_CPSUI_PAPER_OUTPUT          64009
#define IDI_CPSUI_ENVELOPE              64010
#define IDI_CPSUI_MEM                   64011
#define IDI_CPSUI_FONTCARTHDR           64012
#define IDI_CPSUI_FONTCART              64013
#define IDI_CPSUI_STAPLER_ON            64014
#define IDI_CPSUI_STAPLER_OFF           64015
#define IDI_CPSUI_HT_HOST               64016
#define IDI_CPSUI_HT_DEVICE             64017
#define IDI_CPSUI_TT_PRINTASGRAPHIC     64018
#define IDI_CPSUI_TT_DOWNLOADSOFT       64019
#define IDI_CPSUI_TT_DOWNLOADVECT       64020
#define IDI_CPSUI_TT_SUBDEV             64021
#define IDI_CPSUI_PORTRAIT              64022
#define IDI_CPSUI_LANDSCAPE             64023
#define IDI_CPSUI_ROT_LAND              64024
#define IDI_CPSUI_AUTOSEL               64025
#define IDI_CPSUI_PAPER_TRAY            64026
#define IDI_CPSUI_PAPER_TRAY2           64027
#define IDI_CPSUI_PAPER_TRAY3           64028
#define IDI_CPSUI_TRANSPARENT           64029
#define IDI_CPSUI_COLLATE               64030
#define IDI_CPSUI_DUPLEX_NONE           64031
#define IDI_CPSUI_DUPLEX_HORZ           64032
#define IDI_CPSUI_DUPLEX_VERT           64033
#define IDI_CPSUI_RES_DRAFT             64034
#define IDI_CPSUI_RES_LOW               64035
#define IDI_CPSUI_RES_MEDIUM            64036
#define IDI_CPSUI_RES_HIGH              64037
#define IDI_CPSUI_RES_PRESENTATION      64038
#define IDI_CPSUI_MONO                  64039
#define IDI_CPSUI_COLOR                 64040
#define IDI_CPSUI_DITHER_NONE           64041
#define IDI_CPSUI_DITHER_COARSE         64042
#define IDI_CPSUI_DITHER_FINE           64043
#define IDI_CPSUI_DITHER_LINEART        64044
#define IDI_CPSUI_SCALING               64045
#define IDI_CPSUI_COPY                  64046
#define IDI_CPSUI_HTCLRADJ              64047
#define IDI_CPSUI_HALFTONE_SETUP        64048
#define IDI_CPSUI_WATERMARK             64049
#define IDI_CPSUI_ERROR                 64050
#define IDI_CPSUI_ICM_OPTION            64051
#define IDI_CPSUI_ICM_METHOD            64052
#define IDI_CPSUI_ICM_INTENT            64053
#define IDI_CPSUI_STD_FORM              64054
#define IDI_CPSUI_OUTBIN                64055
#define IDI_CPSUI_OUTPUT                64056
#define IDI_CPSUI_GRAPHIC               64057
#define IDI_CPSUI_ADVANCE               64058
#define IDI_CPSUI_DOCUMENT              64059
#define IDI_CPSUI_DEVICE                64060
#define IDI_CPSUI_DEVICE2               64061
#define IDI_CPSUI_PRINTER               64062
#define IDI_CPSUI_PRINTER2              64063
#define IDI_CPSUI_PRINTER3              64064
#define IDI_CPSUI_PRINTER4              64065
#define IDI_CPSUI_OPTION                64066
#define IDI_CPSUI_OPTION2               64067
#define IDI_CPSUI_STOP                  64068
#define IDI_CPSUI_NOTINSTALLED          64069
#define IDI_CPSUI_WARNING_OVERLAY       64070
#define IDI_CPSUI_STOP_WARNING_OVERLAY  64071
#define IDI_CPSUI_GENERIC_OPTION        64072
#define IDI_CPSUI_GENERIC_ITEM          64073
#define IDI_CPSUI_RUN_DIALOG            64074
#define IDI_CPSUI_QUESTION              64075
#define IDI_CPSUI_FORMTRAYASSIGN        64076
#define IDI_CPSUI_PRINTER_FOLDER        64077
#define IDI_CPSUI_INSTALLABLE_OPTION    64078
#define IDI_CPSUI_PRINTER_FEATURE       64079
#define IDI_CPSUI_DEVICE_FEATURE        64080
#define IDI_CPSUI_FONTSUB               64081
#define IDI_CPSUI_POSTSCRIPT            64082
#define IDI_CPSUI_TELEPHONE             64083
#define IDI_CPSUI_DUPLEX_NONE_L         64084
#define IDI_CPSUI_DUPLEX_HORZ_L         64085
#define IDI_CPSUI_DUPLEX_VERT_L         64086
#define IDI_CPSUI_LF_PEN_PLOTTER        64087
#define IDI_CPSUI_SF_PEN_PLOTTER        64088
#define IDI_CPSUI_LF_RASTER_PLOTTER     64089
#define IDI_CPSUI_SF_RASTER_PLOTTER     64090
#define IDI_CPSUI_ROLL_PAPER            64091
#define IDI_CPSUI_PEN_CARROUSEL         64092
#define IDI_CPSUI_PLOTTER_PEN           64093
#define IDI_CPSUI_MANUAL_FEED           64094
#define IDI_CPSUI_FAX                   64095
#define IDI_CPSUI_PAGE_PROTECT          64096
#define IDI_CPSUI_ENVELOPE_FEED         64097
#define IDI_CPSUI_FONTCART_SLOT         64098
#define IDI_CPSUI_LAYOUT_BMP_PORTRAIT   64099
#define IDI_CPSUI_LAYOUT_BMP_ARROWL     64100
#define IDI_CPSUI_LAYOUT_BMP_ARROWS     64101
#define IDI_CPSUI_LAYOUT_BMP_BOOKLETL   64102
#define IDI_CPSUI_LAYOUT_BMP_BOOKLETP   64103
#define IDI_CPSUI_ICONID_LAST           64103

//
// Common UI standard String IDs
//


#define IDS_CPSUI_STRID_FIRST           64700

#define IDS_CPSUI_SETUP                 64700
#define IDS_CPSUI_MORE                  64701
#define IDS_CPSUI_CHANGE                64702
#define IDS_CPSUI_OPTION                64703
#define IDS_CPSUI_OF                    64704
#define IDS_CPSUI_RANGE_FROM            64705
#define IDS_CPSUI_TO                    64706
#define IDS_CPSUI_COLON_SEP             64707
#define IDS_CPSUI_LEFT_ANGLE            64708
#define IDS_CPSUI_RIGHT_ANGLE           64709
#define IDS_CPSUI_SLASH_SEP             64710
#define IDS_CPSUI_PERCENT               64711
#define IDS_CPSUI_LBCB_NOSEL            64712
#define IDS_CPSUI_PROPERTIES            64713
#define IDS_CPSUI_DEFAULTDOCUMENT       64714
#define IDS_CPSUI_DOCUMENT              64715
#define IDS_CPSUI_ADVANCEDOCUMENT       64716
#define IDS_CPSUI_PRINTER               64717
#define IDS_CPSUI_AUTOSELECT            64718
#define IDS_CPSUI_PAPER_OUTPUT          64719
#define IDS_CPSUI_GRAPHIC               64720
#define IDS_CPSUI_OPTIONS               64721
#define IDS_CPSUI_ADVANCED              64722
#define IDS_CPSUI_STDDOCPROPTAB         64723
#define IDS_CPSUI_STDDOCPROPTVTAB       64724
#define IDS_CPSUI_DEVICEOPTIONS         64725
#define IDS_CPSUI_FALSE                 64726
#define IDS_CPSUI_TRUE                  64727
#define IDS_CPSUI_NO                    64728
#define IDS_CPSUI_YES                   64729
#define IDS_CPSUI_OFF                   64730
#define IDS_CPSUI_ON                    64731
#define IDS_CPSUI_DEFAULT               64732
#define IDS_CPSUI_ERROR                 64733
#define IDS_CPSUI_NONE                  64734
#define IDS_CPSUI_NOT                   64735
#define IDS_CPSUI_EXIST                 64736
#define IDS_CPSUI_NOTINSTALLED          64737
#define IDS_CPSUI_ORIENTATION           64738
#define IDS_CPSUI_SCALING               64739
#define IDS_CPSUI_NUM_OF_COPIES         64740
#define IDS_CPSUI_SOURCE                64741
#define IDS_CPSUI_PRINTQUALITY          64742
#define IDS_CPSUI_RESOLUTION            64743
#define IDS_CPSUI_COLOR_APPERANCE       64744
#define IDS_CPSUI_DUPLEX                64745
#define IDS_CPSUI_TTOPTION              64746
#define IDS_CPSUI_FORMNAME              64747
#define IDS_CPSUI_ICM                   64748
#define IDS_CPSUI_ICMMETHOD             64749
#define IDS_CPSUI_ICMINTENT             64750
#define IDS_CPSUI_MEDIA                 64751
#define IDS_CPSUI_DITHERING             64752
#define IDS_CPSUI_PORTRAIT              64753
#define IDS_CPSUI_LANDSCAPE             64754
#define IDS_CPSUI_ROT_LAND              64755
#define IDS_CPSUI_COLLATE               64756
#define IDS_CPSUI_COLLATED              64757
#define IDS_CPSUI_PRINTFLDSETTING       64758
#define IDS_CPSUI_DRAFT                 64759
#define IDS_CPSUI_LOW                   64760
#define IDS_CPSUI_MEDIUM                64761
#define IDS_CPSUI_HIGH                  64762
#define IDS_CPSUI_PRESENTATION          64763
#define IDS_CPSUI_COLOR                 64764
#define IDS_CPSUI_GRAYSCALE             64765
#define IDS_CPSUI_MONOCHROME            64766
#define IDS_CPSUI_SIMPLEX               64767
#define IDS_CPSUI_HORIZONTAL            64768
#define IDS_CPSUI_VERTICAL              64769
#define IDS_CPSUI_LONG_SIDE             64770
#define IDS_CPSUI_SHORT_SIDE            64771
#define IDS_CPSUI_TT_PRINTASGRAPHIC     64772
#define IDS_CPSUI_TT_DOWNLOADSOFT       64773
#define IDS_CPSUI_TT_DOWNLOADVECT       64774
#define IDS_CPSUI_TT_SUBDEV             64775
#define IDS_CPSUI_ICM_BLACKWHITE        64776
#define IDS_CPSUI_ICM_NO                64777
#define IDS_CPSUI_ICM_YES               64778
#define IDS_CPSUI_ICM_SATURATION        64779
#define IDS_CPSUI_ICM_CONTRAST          64780
#define IDS_CPSUI_ICM_COLORMETRIC       64781
#define IDS_CPSUI_STANDARD              64782
#define IDS_CPSUI_GLOSSY                64783
#define IDS_CPSUI_TRANSPARENCY          64784
#define IDS_CPSUI_REGULAR               64785
#define IDS_CPSUI_BOND                  64786
#define IDS_CPSUI_COARSE                64787
#define IDS_CPSUI_FINE                  64788
#define IDS_CPSUI_LINEART               64789
#define IDS_CPSUI_ERRDIFFUSE            64790
#define IDS_CPSUI_HALFTONE              64791
#define IDS_CPSUI_HTCLRADJ              64792
#define IDS_CPSUI_USE_HOST_HT           64793
#define IDS_CPSUI_USE_DEVICE_HT         64794
#define IDS_CPSUI_USE_PRINTER_HT        64795
#define IDS_CPSUI_OUTBINASSIGN          64796
#define IDS_CPSUI_WATERMARK             64797
#define IDS_CPSUI_FORMTRAYASSIGN        64798
#define IDS_CPSUI_UPPER_TRAY            64799
#define IDS_CPSUI_ONLYONE               64800
#define IDS_CPSUI_LOWER_TRAY            64801
#define IDS_CPSUI_MIDDLE_TRAY           64802
#define IDS_CPSUI_MANUAL_TRAY           64803
#define IDS_CPSUI_ENVELOPE_TRAY         64804
#define IDS_CPSUI_ENVMANUAL_TRAY        64805
#define IDS_CPSUI_TRACTOR_TRAY          64806
#define IDS_CPSUI_SMALLFMT_TRAY         64807
#define IDS_CPSUI_LARGEFMT_TRAY         64808
#define IDS_CPSUI_LARGECAP_TRAY         64809
#define IDS_CPSUI_CASSETTE_TRAY         64810
#define IDS_CPSUI_DEFAULT_TRAY          64811
#define IDS_CPSUI_FORMSOURCE            64812
#define IDS_CPSUI_MANUALFEED            64813
#define IDS_CPSUI_PRINTERMEM_KB         64814
#define IDS_CPSUI_PRINTERMEM_MB         64815
#define IDS_CPSUI_PAGEPROTECT           64816
#define IDS_CPSUI_HALFTONE_SETUP        64817
#define IDS_CPSUI_INSTFONTCART          64818
#define IDS_CPSUI_SLOT1                 64819
#define IDS_CPSUI_SLOT2                 64820
#define IDS_CPSUI_SLOT3                 64821
#define IDS_CPSUI_SLOT4                 64822
#define IDS_CPSUI_LEFT_SLOT             64823
#define IDS_CPSUI_RIGHT_SLOT            64824
#define IDS_CPSUI_STAPLER               64825
#define IDS_CPSUI_STAPLER_ON            64826
#define IDS_CPSUI_STAPLER_OFF           64827
#define IDS_CPSUI_STACKER               64828
#define IDS_CPSUI_MAILBOX               64829
#define IDS_CPSUI_COPY                  64830
#define IDS_CPSUI_COPIES                64831
#define IDS_CPSUI_TOTAL                 64832
#define IDS_CPSUI_MAKE                  64833
#define IDS_CPSUI_PRINT                 64834
#define IDS_CPSUI_FAX                   64835
#define IDS_CPSUI_PLOT                  64836
#define IDS_CPSUI_SLOW                  64837
#define IDS_CPSUI_FAST                  64838
#define IDS_CPSUI_ROTATED               64839
#define IDS_CPSUI_RESET                 64840
#define IDS_CPSUI_ALL                   64841
#define IDS_CPSUI_DEVICE                64842
#define IDS_CPSUI_SETTINGS              64843
#define IDS_CPSUI_REVERT                64844
#define IDS_CPSUI_CHANGES               64845
#define IDS_CPSUI_CHANGED               64846
#define IDS_CPSUI_WARNING               64847
#define IDS_CPSUI_ABOUT                 64848
#define IDS_CPSUI_VERSION               64849
#define IDS_CPSUI_NO_NAME               64850
#define IDS_CPSUI_SETTING               64851
#define IDS_CPSUI_DEVICE_SETTINGS       64852
#define IDS_CPSUI_STDDOCPROPTAB1        64853
#define IDS_CPSUI_STDDOCPROPTAB2        64854
#define IDS_CPSUI_PAGEORDER             64855
#define IDS_CPSUI_FRONTTOBACK           64856
#define IDS_CPSUI_BACKTOFRONT           64857
#define IDS_CPSUI_QUALITY_SETTINGS      64858
#define IDS_CPSUI_QUALITY_DRAFT         64859
#define IDS_CPSUI_QUALITY_BETTER        64860
#define IDS_CPSUI_QUALITY_BEST          64861
#define IDS_CPSUI_QUALITY_CUSTOM        64862
#define IDS_CPSUI_OUTPUTBIN             64863
#define IDS_CPSUI_NUP                   64864
#define IDS_CPSUI_NUP_NORMAL            64865
#define IDS_CPSUI_NUP_TWOUP             64866
#define IDS_CPSUI_NUP_FOURUP            64867
#define IDS_CPSUI_NUP_SIXUP             64868
#define IDS_CPSUI_NUP_NINEUP            64869
#define IDS_CPSUI_NUP_SIXTEENUP         64870
#define IDS_CPSUI_SIDE1                 64871
#define IDS_CPSUI_SIDE2                 64872
#define IDS_CPSUI_BOOKLET               64873

#define IDS_CPSUI_STRID_LAST            64873


#ifdef __cplusplus
}
#endif

#endif      // _COMPSTUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\publish\prcomoem.h ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    prcomoem.h

Abstract:

    Interface declaration for Windows NT printer driver OEM plugins

--*/

#ifndef _PRCOMOEM_H_
#define _PRCOMOEM_H_

//
// This file has to be included after printoem.h. We also need to inlude
// objbase.h or comcat.h from sdk\inc.
//

//
// Each dll/exe must initialize the GUIDs once.If you are not using precompiled
// headers for the file(s) which initializes the GUIDs, define INITGUID before
// including objbase.h.
//

//
// Class ID for OEM rendering component. All OEM rendering plugin need to use this ID.
//
// {6d6abf26-9f38-11d1-882a-00c04fb961ec}
//

DEFINE_GUID(CLSID_OEMRENDER, 0x6d6abf26, 0x9f38, 0x11d1, 0x88, 0x2a, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Class ID for OEM UI component. All OEM UI plugin need to use this ID.
//
// {abce80d7-9f46-11d1-882a-00c04fb961ec}
//

DEFINE_GUID(CLSID_OEMUI, 0xabce80d7, 0x9f46, 0x11d1, 0x88, 0x2a, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemCommon Interface
//
// {7f42285e-91d5-11d1-8820-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemCommon, 0x7f42285e, 0x91d5, 0x11d1, 0x88, 0x20, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemEngine Interface
//
// {63d17590-91d8-11d1-8820-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemEngine, 0x63d17590, 0x91d8, 0x11d1, 0x88, 0x20, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemUI Interface
//
// {C6A7A9D0-774C-11d1-947F-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemUI, 0xc6a7a9d0, 0x774c, 0x11d1, 0x94, 0x7f, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintOemUI2 Interface
//
// {292515F9-B54B-489B-9275-BAB56821395E}
//

DEFINE_GUID(IID_IPrintOemUI2, 0x292515f9, 0xb54b, 0x489b, 0x92, 0x75, 0xba, 0xb5, 0x68, 0x21, 0x39, 0x5e);

//
// Interface ID for IPrintOemDriverUI interface
//
// {92B05D50-78BC-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemDriverUI, 0x92b05d50, 0x78bc, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintCoreUI2 interface
//
// {085CCFCA-3ADF-4c9e-B491-D851A6EDC997}
//

DEFINE_GUID(IID_IPrintCoreUI2, 0x85ccfca, 0x3adf, 0x4c9e, 0xb4, 0x91, 0xd8, 0x51, 0xa6, 0xed, 0xc9, 0x97);

//
// Interface ID for IPrintOemPS Interface
//
// {688342b5-8e1a-11d1-881f-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemPS, 0x688342b5, 0x8e1a, 0x11d1, 0x88, 0x1f, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemPS2 Interface
//
// {BECF7F34-51B3-46c9-8A1C-18679BD21F36}
//

DEFINE_GUID(IID_IPrintOemPS2, 0xbecf7f34, 0x51b3, 0x46c9, 0x8a, 0x1c, 0x18, 0x67, 0x9b, 0xd2, 0x1f, 0x36);

//
// Interface ID for IPrintOemDriverPS interface
//
// {d90060c7-8e1a-11d1-881f-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemDriverPS, 0xd90060c7, 0x8e1a, 0x11d1, 0x88, 0x1f, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintCorePS2 interface
//
// {CDBB0B0B-A917-40d7-9FBF-483B3BE7EF22}

DEFINE_GUID(IID_IPrintCorePS2, 0xcdbb0b0b, 0xa917, 0x40d7, 0x9f, 0xbf, 0x48, 0x3b, 0x3b, 0xe7, 0xef, 0x22);

//
// Interface ID for IPrintOemUni Interface
//
// {D67EBBF0-78BF-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemUni, 0xd67ebbf0, 0x78bf, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintOemUni2 Interface
//
// {B91220AC-15CC-4e7a-A21E-9591F34D6F6C}
//

DEFINE_GUID(IID_IPrintOemUni2, 0xb91220ac, 0x15cc, 0x4e7a, 0xa2, 0x1e, 0x95, 0x91, 0xf3, 0x4d, 0x6f, 0x6c);

//
// Interface ID for IPrintOemDriverUni interface
//
// {D67EBBF1-78BF-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemDriverUni, 0xd67ebbf1, 0x78bf, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

#undef IUnknown

#ifdef __cplusplus
extern "C" {
#endif

//
//****************************************************************************
//  IPrintOemCommon interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemCommon
DECLARE_INTERFACE_(IPrintOemCommon, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;
};

#ifndef KERNEL_MODE

//
// Definitions used by user interface module only.
// Make sure the macro KERNEL_MODE is not defined.
//

//
//****************************************************************************
//  IPrintOemUI interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemUI
DECLARE_INTERFACE_(IPrintOemUI, IPrintOemCommon)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemUI methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface) (THIS_ IUnknown *pIUnknown) PURE;


    //
    // CommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_
            DWORD  dwMode,
            POEMCUIPPARAM   pOemCUIPParam
            )PURE;

    //
    // DocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;

    //
    // DevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;


    //
    // DevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            )PURE;

    //
    // DeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            )PURE;

    //
    // UpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            )PURE;

    //
    // PrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            )PURE;

    //
    // DriverEvent
    //

    STDMETHOD(DriverEvent) (THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            )PURE;

    //
    // QueryColorProfile
    //

    STDMETHOD(QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData
            )PURE;

    //
    // FontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            )PURE;

    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
           )PURE;
};


//
//****************************************************************************
//  IPrintOemUI2 interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemUI2
DECLARE_INTERFACE_(IPrintOemUI2, IPrintOemUI)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemUI methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface) (THIS_ IUnknown *pIUnknown) PURE;


    //
    // CommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_
            DWORD  dwMode,
            POEMCUIPPARAM   pOemCUIPParam
            )PURE;

    //
    // DocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;

    //
    // DevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;


    //
    // DevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            )PURE;

    //
    // DeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            )PURE;

    //
    // UpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            )PURE;

    //
    // PrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            )PURE;

    //
    // DriverEvent
    //

    STDMETHOD(DriverEvent) (THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            )PURE;

    //
    // QueryColorProfile
    //

    STDMETHOD(QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData
            )PURE;

    //
    // FontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            )PURE;

    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
           )PURE;

    //
    // IPrintOemUI2 methods
    //

    //
    // QueryJobAttributes
    //

    STDMETHOD(QueryJobAttributes)  (THIS_
            HANDLE      hPrinter,
            PDEVMODE    pDevmode,
            DWORD       dwLevel,
            LPBYTE      lpAttributeInfo
           )PURE;

    //
    // Hide Standard UI
    //

    STDMETHOD(HideStandardUI)  (THIS_
            DWORD       dwMode
           )PURE;

    //
    // DocumentEvent
    //

    STDMETHOD(DocumentEvent) (THIS_
            HANDLE      hPrinter,
            HDC         hdc,
            INT         iEsc,
            ULONG       cbIn,
            PVOID       pvIn,
            ULONG       cbOut,
            PVOID       pvOut,
            PINT        piResult
           )PURE;
};


//
//****************************************************************************
//  IPrintOemDriverUI interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemDriverUI
DECLARE_INTERFACE_(IPrintOemDriverUI, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemDriverUI methods
    //

    //
    // Helper function to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_
                        PVOID   pci,
                        PCSTR   Feature,
                        PVOID   pOutput,
                        DWORD   cbSize,
                        PDWORD  pcbNeeded,
                        PDWORD  pdwOptionsReturned
                        )PURE;

    //
    // Helper function to allow OEM plugins upgrade private registry
    // settings. This function should be called only by OEM's UpgradePrinter()
    //

    STDMETHOD(DrvUpgradeRegistrySetting) (THIS_
                        HANDLE   hPrinter,
                        PCSTR    pFeature,
                        PCSTR    pOption
                        )PURE;

    //
    // Helper function to allow OEM plugins to update the driver UI
    // settings and show constraints. This function should be called only when
    // the UI is present.
    //

    STDMETHOD(DrvUpdateUISetting) (THIS_
                        PVOID    pci,
                        PVOID    pOptItem,
                        DWORD    dwPreviousSelection,
                        DWORD    dwMode
                        )PURE;
};

//
//****************************************************************************
//  IPrintCoreUI2 interface
//
//  This is the revised core driver helper interface OEM UI plugin can call.
//  It supercedes the old helper interface IPrintOemDriverUI.
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintCoreUI2
DECLARE_INTERFACE_(IPrintCoreUI2, IPrintOemDriverUI)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemDriverUI methods
    //

    //
    // Helper function to get driver settings. This function is only supported
    // for UI plugins that do not fully replace core driver's standard UI.
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_
                        PVOID   pci,
                        PCSTR   Feature,
                        PVOID   pOutput,
                        DWORD   cbSize,
                        PDWORD  pcbNeeded,
                        PDWORD  pdwOptionsReturned
                        )PURE;

    //
    // Helper function to allow OEM plugins upgrade private registry
    // settings. This function is supported for any UI plugins and should be
    // called only by OEM's UpgradePrinter.
    //

    STDMETHOD(DrvUpgradeRegistrySetting) (THIS_
                        HANDLE   hPrinter,
                        PCSTR    pFeature,
                        PCSTR    pOption
                        )PURE;

    //
    // Helper function to allow OEM plugins to update the driver UI settings.
    // This function is only supported for UI plugins that do not fully replace
    // core driver's standard UI. It should be called only when the UI is present.
    //

    STDMETHOD(DrvUpdateUISetting) (THIS_
                        PVOID    pci,
                        PVOID    pOptItem,
                        DWORD    dwPreviousSelection,
                        DWORD    dwMode
                        )PURE;

    //
    // IPrintCoreUI2 new methods
    //

    //
    // Following four helper functions are only supported for UI plugins that fully
    // replace core driver's standard UI. They should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet callback
    // functions.
    //
    // Helper function to retrieve driver's current setting as a list of
    // feature/option keyword pairs.
    //

    STDMETHOD(GetOptions) (THIS_
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeaturesRequested,
                           IN  DWORD      cbIn,
                           OUT PSTR       pmszFeatureOptionBuf,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to change driver's setting using a list of feature/option
    // keyword pairs.
    //

    STDMETHOD(SetOptions) (THIS_
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeatureOptionBuf,
                           IN  DWORD      cbIn,
                           OUT PDWORD     pdwResult) PURE;

    //
    // Helper function to retrieve the option(s) of a given feature that are
    // constrained in driver's current setting.
    //

    STDMETHOD(EnumConstrainedOptions) (THIS_
                                       IN  POEMUIOBJ  poemuiobj,
                                       IN  DWORD      dwFlags,
                                       IN  PCSTR      pszFeatureKeyword,
                                       OUT PSTR       pmszConstrainedOptionList,
                                       IN  DWORD      cbSize,
                                       OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to retrieve a list of feature/option keyword pairs from
    // driver's current setting that conflict with the given feature/option pair.
    //

    STDMETHOD(WhyConstrained) (THIS_
                               IN  POEMUIOBJ  poemuiobj,
                               IN  DWORD      dwFlags,
                               IN  PCSTR      pszFeatureKeyword,
                               IN  PCSTR      pszOptionKeyword,
                               OUT PSTR       pmszReasonList,
                               IN  DWORD      cbSize,
                               OUT PDWORD     pcbNeeded) PURE;

    //
    // Following five helper functions are supported for any UI plugins.
    //
    // Helper function to retrieve global attribute.
    //

    STDMETHOD(GetGlobalAttribute) (THIS_
                                   IN  POEMUIOBJ  poemuiobj,
                                   IN  DWORD      dwFlags,
                                   IN  PCSTR      pszAttribute,
                                   OUT PDWORD     pdwDataType,
                                   OUT PBYTE      pbData,
                                   IN  DWORD      cbSize,
                                   OUT PDWORD     pcbNeeded) PURE;


    //
    // Helper function to retrieve attribute of a given feature.
    //

    STDMETHOD(GetFeatureAttribute) (THIS_
                                    IN  POEMUIOBJ  poemuiobj,
                                    IN  DWORD      dwFlags,
                                    IN  PCSTR      pszFeatureKeyword,
                                    IN  PCSTR      pszAttribute,
                                    OUT PDWORD     pdwDataType,
                                    OUT PBYTE      pbData,
                                    IN  DWORD      cbSize,
                                    OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to retrieve attribute of a given feature/option selection.
    //

    STDMETHOD(GetOptionAttribute) (THIS_
                                   IN  POEMUIOBJ  poemuiobj,
                                   IN  DWORD      dwFlags,
                                   IN  PCSTR      pszFeatureKeyword,
                                   IN  PCSTR      pszOptionKeyword,
                                   IN  PCSTR      pszAttribute,
                                   OUT PDWORD     pdwDataType,
                                   OUT PBYTE      pbData,
                                   IN  DWORD      cbSize,
                                   OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to retrieve the list of feature keyword.
    //

    STDMETHOD(EnumFeatures) (THIS_
                             IN  POEMUIOBJ  poemuiobj,
                             IN  DWORD      dwFlags,
                             OUT PSTR       pmszFeatureList,
                             IN  DWORD      cbSize,
                             OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to retrieve the list of options keyword of a given feature.
    //

    STDMETHOD(EnumOptions) (THIS_
                            IN  POEMUIOBJ  poemuiobj,
                            IN  DWORD      dwFlags,
                            IN  PCSTR      pszFeatureKeyword,
                            OUT PSTR       pmszOptionList,
                            IN  DWORD      cbSize,
                            OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to query system simulation support
    //

    STDMETHOD(QuerySimulationSupport) (THIS_
                                       IN  HANDLE  hPrinter,
                                       IN  DWORD   dwLevel,
                                       OUT PBYTE   pCaps,
                                       IN  DWORD   cbSize,
                                       OUT PDWORD  pcbNeeded) PURE;
};

#else   // KERNEL_MODE

//
// Definitions used by rendering module only.
// Make sure the macro KERNEL_MODE is defined.
//

//
//****************************************************************************
//  IPrintOemEngine interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemEngine
DECLARE_INTERFACE_(IPrintOemEngine, IPrintOemCommon)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;
};

//
//****************************************************************************
//  IPrintOemPS interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemPS
DECLARE_INTERFACE_(IPrintOemPS, IPrintOemEngine)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // IPrintOemPS methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_  IUnknown *pIUnknown) PURE;

    //
    // Method for OEM to generate output at specific injection point
    //

    STDMETHOD(Command) (THIS_   PDEVOBJ     pdevobj,
                                DWORD       dwIndex,
                                PVOID       pData,
                                DWORD       cbSize,
                                OUT DWORD   *pdwResult) PURE;
};

//
//****************************************************************************
//  IPrintOemPS2 interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemPS2
DECLARE_INTERFACE_(IPrintOemPS2, IPrintOemPS)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // IPrintOemPS methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_  IUnknown *pIUnknown) PURE;

    //
    // Method for OEM to generate output at specific injection point
    //

    STDMETHOD(Command) (THIS_   PDEVOBJ     pdevobj,
                                DWORD       dwIndex,
                                PVOID       pData,
                                DWORD       cbSize,
                                OUT DWORD   *pdwResult) PURE;

    //
    // IPrintOemPS2 methods
    //

    //
    // Method for plugin to hook out spooler's WritePrinter API so it
    // can get access to output data PostScript driver is generating
    //
    // At DrvEnablePDEV time, PostScript driver will call this function with
    // pdevobj = NULL, pBuf = NULL, cbBuffer = 0 to detect if the plugin
    // implements this function. Plugin should return S_OK to indicate it is
    // implementing this function, or return E_NOTIMPL otherwise.
    //
    // In pcbWritten, plugins should return the number of bytes written to the
    // spooler's WritePrinter function. Zero doesn't carry a special meaning,
    // errors must be reported through the returned HRESULT.
    //

    STDMETHOD(WritePrinter) (THIS_   PDEVOBJ    pdevobj,
                                     PVOID      pBuf,
                                     DWORD      cbBuffer,
                                     PDWORD     pcbWritten) PURE;

    //
    // Method for plugin to implement if it wants to be called to get the chance
    // to override some PDEV settings such as paper margins.
    // Plugins that recognize the adjustment type should return S_OK.
    // If the adjustment type is unrecognized, they should return S_FALSE
    // and not E_NOTIMPL, this code should be reserved for the COM meaning.
    // If the plugin fails the call, it should return E_FAIL.
    // The chain of plugins will be called until a plugin returns S_OK or
    // any failure code other than E_NOTIMPL, in other words, until the first
    // plugin that is designed to handle the adjustment is found.
    //

    STDMETHOD(GetPDEVAdjustment) (THIS_ PDEVOBJ    pdevobj,
                                        DWORD      dwAdjustType,
                                        PVOID      pBuf,
                                        DWORD      cbBuffer,
                                        OUT BOOL  *pbAdjustmentDone) PURE;
};

//
//****************************************************************************
//  IPrintOemDriverPS interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemDriverPS
DECLARE_INTERFACE_(IPrintOemDriverPS, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemDriverPS methods
    //

    //
    // Method for OEM to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_   PVOID   pdriverobj,
                                            PCSTR   Feature,
                                            PVOID   pOutput,
                                            DWORD   cbSize,
                                            PDWORD  pcbNeeded,
                                            PDWORD  pdwOptionsReturned) PURE;

    //
    // Method for OEM to write to spooler buffer
    //

    STDMETHOD(DrvWriteSpoolBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            OUT DWORD   *pdwResult) PURE;
};

//
//****************************************************************************
//  IPrintCorePS2 interface
//
//  This is the revised core driver helper interface OEM PS render plugin can
//  call. It supercedes the old helper interface IPrintOemDriverPS.
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintCorePS2
DECLARE_INTERFACE_(IPrintCorePS2, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintCorePS2 methods
    //

    //
    // Method for OEM to write to spooler buffer.
    //

    STDMETHOD(DrvWriteSpoolBuf)(THIS_
                           IN  PDEVOBJ  pdevobj,
                           IN  PVOID    pBuffer,
                           IN  DWORD    cbSize,
                           OUT DWORD    *pdwResult) PURE;

    //
    // Helper function to retrieve driver's current setting as a list of
    // feature/option keyword pairs.
    //

    STDMETHOD(GetOptions) (THIS_
                           IN  PDEVOBJ  pdevobj,
                           IN  DWORD    dwFlags,
                           IN  PCSTR    pmszFeaturesRequested,
                           IN  DWORD    cbIn,
                           OUT PSTR     pmszFeatureOptionBuf,
                           IN  DWORD    cbSize,
                           OUT PDWORD   pcbNeeded) PURE;

    //
    // Helper function to retrieve global attribute.
    //

    STDMETHOD(GetGlobalAttribute) (THIS_
                                   IN  PDEVOBJ  pdevobj,
                                   IN  DWORD    dwFlags,
                                   IN  PCSTR    pszAttribute,
                                   OUT PDWORD   pdwDataType,
                                   OUT PBYTE    pbData,
                                   IN  DWORD    cbSize,
                                   OUT PDWORD   pcbNeeded) PURE;


    //
    // Helper function to retrieve attribute of a given feature.
    //

    STDMETHOD(GetFeatureAttribute) (THIS_
                                    IN  PDEVOBJ  pdevobj,
                                    IN  DWORD    dwFlags,
                                    IN  PCSTR    pszFeatureKeyword,
                                    IN  PCSTR    pszAttribute,
                                    OUT PDWORD   pdwDataType,
                                    OUT PBYTE    pbData,
                                    IN  DWORD    cbSize,
                                    OUT PDWORD   pcbNeeded) PURE;

    //
    // Helper function to retrieve attribute of a given feature/option selection.
    //

    STDMETHOD(GetOptionAttribute) (THIS_
                                   IN  PDEVOBJ  pdevobj,
                                   IN  DWORD    dwFlags,
                                   IN  PCSTR    pszFeatureKeyword,
                                   IN  PCSTR    pszOptionKeyword,
                                   IN  PCSTR    pszAttribute,
                                   OUT PDWORD   pdwDataType,
                                   OUT PBYTE    pbData,
                                   IN  DWORD    cbSize,
                                   OUT PDWORD   pcbNeeded) PURE;

    //
    // Helper function to retrieve the list of feature keyword.
    //

    STDMETHOD(EnumFeatures) (THIS_
                             IN  PDEVOBJ  pdevobj,
                             IN  DWORD    dwFlags,
                             OUT PSTR     pmszFeatureList,
                             IN  DWORD    cbSize,
                             OUT PDWORD   pcbNeeded) PURE;

    //
    // Helper function to retrieve the list of options keyword of a given feature.
    //

    STDMETHOD(EnumOptions) (THIS_
                            IN  PDEVOBJ  pdevobj,
                            IN  DWORD    dwFlags,
                            IN  PCSTR    pszFeatureKeyword,
                            OUT PSTR     pmszOptionList,
                            IN  DWORD    cbSize,
                            OUT PDWORD   pcbNeeded) PURE;
};

//
//****************************************************************************
//  IPrintOemUni interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemUni
DECLARE_INTERFACE_(IPrintOemUni, IPrintOemEngine)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // IPrintOemUni methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown) PURE;

    //
    // Method for getting OEM implemented methods.
    // Returns S_OK if the given method is implemented.
    // Returns S_FALSE if the given method is not implemented.
    //
    //

    STDMETHOD(GetImplementedMethod) (THIS_  PSTR    pMethodName) PURE;

    //
    // DriverDMS
    //

    STDMETHOD(DriverDMS)(THIS_  PVOID   pDevObj,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;

    //
    // CommandCallback
    //

    STDMETHOD(CommandCallback)(THIS_    PDEVOBJ     pdevobj,
                                        DWORD       dwCallbackID,
                                        DWORD       dwCount,
                                        PDWORD      pdwParams,
                                        OUT INT     *piResult) PURE;


    //
    // ImageProcessing
    //

    STDMETHOD(ImageProcessing)(THIS_    PDEVOBJ             pdevobj,
                                        PBYTE               pSrcBitmap,
                                        PBITMAPINFOHEADER   pBitmapInfoHeader,
                                        PBYTE               pColorTable,
                                        DWORD               dwCallbackID,
                                        PIPPARAMS           pIPParams,
                                        OUT PBYTE           *ppbResult) PURE;

    //
    // FilterGraphics
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen) PURE;

    //
    // Compression
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult) PURE;

    //
    // HalftonePattern
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize) PURE;

    //
    // MemoryUsage
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage) PURE;

    //
    // TTYGetInfo
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded
                                    ) PURE;
    //
    // DownloadFontheader
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // DownloadCharGlyph
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult) PURE;


    //
    // TTDownloadMethod
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // OutputCharStr
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph) PURE;

    //
    // SendFontCmd
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv) PURE;

    //
    // TextOutAsBitmap
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix) PURE;
};

//
//****************************************************************************
//  IPrintOemUni2 interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemUni2
DECLARE_INTERFACE_(IPrintOemUni2, IPrintOemUni)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // IPrintOemUni methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown) PURE;

    //
    // Method for getting OEM implemented methods.
    // Returns S_OK if the given method is implemented.
    // Returns S_FALSE if the given method is not implemented.
    //
    //

    STDMETHOD(GetImplementedMethod) (THIS_  PSTR    pMethodName) PURE;

    //
    // DriverDMS
    //

    STDMETHOD(DriverDMS)(THIS_  PVOID   pDevObj,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;

    //
    // CommandCallback
    //

    STDMETHOD(CommandCallback)(THIS_    PDEVOBJ     pdevobj,
                                        DWORD       dwCallbackID,
                                        DWORD       dwCount,
                                        PDWORD      pdwParams,
                                        OUT INT     *piResult) PURE;


    //
    // ImageProcessing
    //

    STDMETHOD(ImageProcessing)(THIS_    PDEVOBJ             pdevobj,
                                        PBYTE               pSrcBitmap,
                                        PBITMAPINFOHEADER   pBitmapInfoHeader,
                                        PBYTE               pColorTable,
                                        DWORD               dwCallbackID,
                                        PIPPARAMS           pIPParams,
                                        OUT PBYTE           *ppbResult) PURE;

    //
    // FilterGraphics
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen) PURE;

    //
    // Compression
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult) PURE;

    //
    // HalftonePattern
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize) PURE;

    //
    // MemoryUsage
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage) PURE;

    //
    // TTYGetInfo
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded
                                    ) PURE;
    //
    // DownloadFontheader
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // DownloadCharGlyph
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult) PURE;


    //
    // TTDownloadMethod
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // OutputCharStr
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph) PURE;

    //
    // SendFontCmd
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv) PURE;

    //
    // TextOutAsBitmap
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix) PURE;

    //
    // IPrintOemUni2 methods
    //

    //
    // Method for plugin to hook out spooler's WritePrinter API so it
    // can get access to output data Universal driver is generating
    //
    // At DrvEnablePDEV time, Universal driver will call this function with
    // pdevobj = NULL, pBuf = NULL, cbBuffer = 0 to detect if the plugin
    // implements this function. Plugin should return S_OK to indicate it is
    // implementing this function, or return E_NOTIMPL otherwise.
    //
    // In pcbWritten, plugins should return the number of bytes written to the
    // spooler's WritePrinter function. Zero doesn't carry a special meaning,
    // errors must be reported through the returned HRESULT.
    //

    STDMETHOD(WritePrinter) (THIS_   PDEVOBJ    pdevobj,
                                     PVOID      pBuf,
                                     DWORD      cbBuffer,
                                     PDWORD     pcbWritten) PURE;
};


//
//****************************************************************************
//  IPrintOemDriverUni interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemDriverUni
DECLARE_INTERFACE_(IPrintOemDriverUni, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemDriverUni methods
    //

    //
    // Function to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_   PVOID   pdriverobj,
                                            PCSTR   Feature,
                                            PVOID   pOutput,
                                            DWORD   cbSize,
                                            PDWORD  pcbNeeded,
                                            PDWORD  pdwOptionsReturned) PURE;

    //
    // Common to both Unidrv & Pscript
    //

    STDMETHOD(DrvWriteSpoolBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // Unidrv specific XMoveTo and YMoveTo. Returns E_NOT_IMPL in Pscript
    //

    STDMETHOD(DrvXMoveTo)(THIS_     PDEVOBJ     pdevobj,
                                    INT         x,
                                    DWORD       dwFlags,
                                    OUT INT     *piResult) PURE;

    STDMETHOD(DrvYMoveTo)(THIS_     PDEVOBJ     pdevobj,
                                    INT         y,
                                    DWORD       dwFlags,
                                    OUT INT     *piResult) PURE;
    //
    // Unidrv specific. To get the standard variable value.
    //

    STDMETHOD(DrvGetStandardVariable)(THIS_     PDEVOBJ     pdevobj,
                                                DWORD       dwIndex,
                                                PVOID       pBuffer,
                                                DWORD       cbSize,
                                                PDWORD      pcbNeeded) PURE;

    //
    // Unidrv specific.  To Provide OEM plugins access to GPD data.
    //

    STDMETHOD (DrvGetGPDData)(THIS_  PDEVOBJ     pdevobj,
                                     DWORD       dwType,     // Type of the data
                                     PVOID         pInputData,   // reserved. Should be set to 0
                                     PVOID          pBuffer,     // Caller allocated Buffer to be copied
                                     DWORD       cbSize,     // Size of the buffer
                                     PDWORD      pcbNeeded   // New Size of the buffer if needed.
                             ) PURE;


    //
    // Unidrv specific. To do the TextOut.
    //

    STDMETHOD(DrvUniTextOut)(THIS_    SURFOBJ    *pso,
                                      STROBJ     *pstro,
                                      FONTOBJ    *pfo,
                                      CLIPOBJ    *pco,
                                      RECTL      *prclExtra,
                                      RECTL      *prclOpaque,
                                      BRUSHOBJ   *pboFore,
                                      BRUSHOBJ   *pboOpaque,
                                      POINTL     *pptlBrushOrg,
                                      MIX         mix) PURE;

    //
    //   Warning!!!  new method!!  must place at end of
    //   interface - else major incompatibility with previous oem plugins
    //

    STDMETHOD(DrvWriteAbortBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            DWORD       dwWait  //  pause data transmission for this many millisecs.
                               ) PURE;
};

#endif  // !KERNEL_MODE

#ifdef __cplusplus
}
#endif

#endif  // !_PRCOMOEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\publish\minidrv.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    minidrv.h

Abstract:

    Common header file for Plug-in minidrivers.

Environment:

    Windows NT printer drivers

Revision History:


--*/


#ifndef _MINIDRV_H_
#define _MINIDRV_H_

#include <stddef.h>
#include <stdlib.h>

#include <objbase.h>

#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>
#include <tchar.h>
#include <excpt.h>

//
// defined(KERNEL_MODE) Rendering module DLL in either kernel mode or user mode.
// defined(KERNEL_MODE) & defined(USERMODE_DRIVER) User mode rendering DLL
// !defined(KERNEL_MODE) UI module
//

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
// Kernel mode rendering DLL
#include "winsplkm.h"
#else
// User mode DLL
#include <winspool.h>
#endif

#if !defined(KERNEL_MODE)
// UI DLL
#include <windows.h>
#include <compstui.h>
#include <winddiui.h>
#endif

#if defined(USERMODE_DRIVER) || !defined(KERNEL_MODE)
// UI DLL or User mode rendering DLL
#include <stdio.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif


#ifdef WINNT_40
//
// The LONG_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. ULONG_PTR is
//

typedef long LONG_PTR, *PLONG_PTR;
typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef int INT_PTR, *PINT_PTR;
typedef unsigned int UINT_PTR, *PUINT_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;


#define HandleToUlong( h ) ((ULONG) (h) )
#define PtrToUlong( p )    ((ULONG) (p) )
#define PtrToLong( p )     ((LONG) (p) )
#define PtrToUshort( p )   ((unsigned short) (p) )
#define PtrToShort( p )    ((short) (p) )

#define GWLP_USERDATA       GWL_USERDATA
#define DWLP_USER           DWL_USER
#define DWLP_MSGRESULT      0
#define SetWindowLongPtr    SetWindowLong
#define GetWindowLongPtr    GetWindowLong

#endif // WINNT_40

#include <printoem.h>
#include <prntfont.h>

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5

#if DBG

extern INT giDebugLevel;

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

extern VOID DbgPrint(PCSTR, ...);
#define DbgBreakPoint EngDebugBreak

#else

extern ULONG _cdecl DbgPrint(PCSTR, ...);
extern VOID DbgBreakPoint(VOID);

#endif

#define DBGMSG(level, prefix, msg) { \
            if (giDebugLevel <= (level)) { \
                DbgPrint("%s %s (%d): ", prefix, __FILE__, __LINE__); \
                DbgPrint msg; \
            } \
        }

#define DBGPRINT(level, msg) { \
            if (giDebugLevel <= (level)) { \
                DbgPrint msg; \
            } \
        }

#define VERBOSE(msg) DBGPRINT(DBG_VERBOSE, msg)
#define TERSE(msg) DBGPRINT(DBG_TERSE, msg)
#define WARNING(msg) DBGMSG(DBG_WARNING, "WRN", msg)
#define ERR(msg) DBGMSG(DBG_ERROR, "ERR", msg)

#ifndef __MDT__                 // Don't redefine ASSERT when included in MINIDEV.EXE.
#define ASSERT(cond) { \
            if (! (cond)) { \
                RIP(("\n")); \
            } \
        }
#endif

#define ASSERTMSG(cond, msg) { \
            if (! (cond)) { \
                RIP(msg); \
            } \
        }

#define RIP(msg) { \
            DBGMSG(DBG_RIP, "RIP", msg); \
            DbgBreakPoint(); \
        }


#else // !DBG

#define VERBOSE(msg)
#define TERSE(msg)
#define WARNING(msg)
#define ERR(msg)

#ifndef __MDT__                 // Don't redefine ASSERT when included in MINIDEV.EXE.
#define ASSERT(cond)
#endif

#define ASSERTMSG(cond, msg)
#define RIP(msg)
#define DBGMSG(level, prefix, msg)
#define DBGPRINT(level, msg)

#endif

//
// The following macros let you enable tracing on per-file and per-function level.
// To use these macros in a file, here is what you should do:
//
// At the beginning of the file (after header includes):
//
//  Define a bit constant for each function you want to trace
//  Add the following line
//      DEFINE_FUNCTION_TRACE_FLAGS(flags);
//  where flags is a bit-wise OR of the functions you want to trace, e.g.
//      TRACE_FLAG_FUNC1 | TRACE_FLAG_FUNC2 | ...
//
//  To generate trace inside each function you want to trace, use:
//      FUNCTION_TRACE(FunctionTraceFlag, (args));
//

#if DBG

#define DEFINE_FUNCTION_TRACE_FLAGS(flags) \
        static DWORD gdwFunctionTraceFlags = (flags)

#define FUNCTION_TRACE(flag, args) { \
            if (gdwFunctionTraceFlags & (flag)) { \
                DbgPrint args; \
            } \
        }

#else // !DBG

#define DEFINE_FUNCTION_TRACE_FLAGS(flags)
#define FUNCTION_TRACE(flag, args)

#endif // !DBG


//
// Memory allocation function macros
//
#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }


//
// DBCS CharSet handling macros
//
//
// 128: SHIFTJIS_CHARSET
// 129: HANGEUL_CHARSET
// 130: JOHAB_CHARSET (defined if WINVER >= 0x0400)
// 134: GB2312_CHARSET
// 136: CHINESEBIG5_CHARSET

#define IS_DBCSCHARSET(j) \
    (((j) == SHIFTJIS_CHARSET)    || \
    ((j) == HANGEUL_CHARSET)     || \
    ((j) == JOHAB_CHARSET)       || \
    ((j) == GB2312_CHARSET)      || \
    ((j) == CHINESEBIG5_CHARSET))

//  932: Japan
//  936: Chinese (PRC, Singapore)
//  949: Korean
//  950: Chinese (China, Hong Kong SAR, Taiwan)
// 1361: Korean (Johab)

#define IS_DBCSCODEPAGE(j) \
    (((j) == 932)   || \
    ((j) == 936)   || \
    ((j) == 949)   || \
    ((j) == 950)   || \
    ((j) == 1361))


//
//  The following are the resource types used in minidrivers and
//  used in the .rc file.
//

#define RC_TABLES      257
#define RC_FONT        258
#define RC_TRANSTAB    259

//
// 5.0 resource types
//

#define RC_UFM         260
#define RC_GTT         261
#define RC_HTPATTERN   264
//
// Internal resource type
//

#define RC_FD_GLYPHSET 262

#ifdef __cplusplus
}
#endif

#endif //_MINIDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\publish\prntfont.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    prntfont.h

Abstract:

    Declarations for Windows NT printer driver font metrics and glyphset data
    *.UFF, *.UFM and *.GTT file data structure definition

--*/

#ifndef _PRNTFONT_H_
#define _PRNTFONT_H_



//
//
// F O N T  M E T R I C S  ( U F M )
//
//

//
// NOTE: To include this header file, it is necessary to include 
//       winddi.h, that has a definition of IFIMETRICS, FD_KERNINGPAIR
//
//


//
// UNIFM
//
// Universal printer driver (UNIDRV) font file header.
//

#define UNIFM_VERSION_1_0 0x00010000

typedef struct _UNIFM_HDR
{
    DWORD      dwSize;             // a total size of this font file
    DWORD      dwVersion;          // a version number of this font file
    ULONG      ulDefaultCodepage;  // this font's default codepage
    LONG       lGlyphSetDataRCID;  // a resource ID of GLYPHDATA
    DWORD      loUnidrvInfo;       // offset to UNIDRVINFO
    DWORD      loIFIMetrics;       // offset to IFIMETRICS
    DWORD      loExtTextMetric;    // offset to EXTTEXTMETRIC
    DWORD      loWidthTable;       // offset to WIDTHTABLE
    DWORD      loKernPair;         // offset to KERNPAIR
    DWORD      dwReserved[2];
} UNIFM_HDR, *PUNIFM_HDR;

#define GET_UNIDRVINFO(pUFM)    \
        ((PUNIDRVINFO)((PBYTE)(pUFM) + (pUFM)->loUnidrvInfo))
#define GET_IFIMETRICS(pUFM)    \
        ((IFIMETRICS*)((PBYTE)(pUFM) + (pUFM)->loIFIMetrics))
#define GET_EXTTEXTMETRIC(pUFM) \
        ((EXTTEXTMETRIC*)((PBYTE)(pUFM) + (pUFM)->loExtTextMetric))
#define GET_WIDTHTABLE(pUFM)    \
        ((PWIDTHTABLE)((PBYTE)(pUFM) + (pUFM)->loWidthTable))
#define GET_KERNDATA(pUFM)      \
        ((PKERNDATA)((PBYTE)(pUFM) + (pUFM)->loKernPair))

//
// UNIDRVINFO
//
// UNIDRVINFO is used to define printer specific information.
//

typedef struct _INVOC {
        DWORD  dwCount;     // the number of bytes in the invocation string
        DWORD  loOffset;    // byte-offset to the beginning of the array
} INVOC, *PINVOC;

typedef struct _UNIDRVINFO
{
    DWORD   dwSize;
    DWORD   flGenFlags;
    WORD    wType;
    WORD    fCaps;
    WORD    wXRes;
    WORD    wYRes;
    short   sYAdjust;
    short   sYMoved;
    WORD    wPrivateData; 
    short   sShift; 
    INVOC   SelectFont;
    INVOC   UnSelectFont;
    WORD    wReserved[4];
}  UNIDRVINFO, *PUNIDRVINFO;

#define GET_SELECT_CMD(pUni)    \
        ((PCHAR)(pUni) + (pUni)->SelectFont.loOffset)
#define GET_UNSELECT_CMD(pUni)  \
        ((PCHAR)(pUni) + (pUni)->UnSelectFont.loOffset)

//
// flGenFlags
//

#define UFM_SOFT        0x00000001 // Softfont, thus needs downloading 
#define UFM_CART        0x00000002 // This is a cartridge font
#define UFM_SCALABLE    0x00000004 // Font is scalable

//
// wType
//

#define DF_TYPE_HPINTELLIFONT         0     // HP's Intellifont
#define DF_TYPE_TRUETYPE              1     // HP's PCLETTO fonts on LJ4
#define DF_TYPE_PST1                  2     // Lexmark PPDS scalable fonts
#define DF_TYPE_CAPSL                 3     // Canon CAPSL scalable fonts
#define DF_TYPE_OEM1                  4     // OEM scalable font type 1
#define DF_TYPE_OEM2                  5     // OEM scalable font type 2

//
// fCaps
//

#define DF_NOITALIC             0x0001  // Cannot italicize via FONTSIMULATION
#define DF_NOUNDER              0x0002  // Cannot underline via FONTSIMULATION
#define DF_XM_CR                0x0004  // send CR after using this font
#define DF_NO_BOLD              0x0008  // Cannot bold via FONTSIMULATION
#define DF_NO_DOUBLE_UNDERLINE  0x0010  // Cannot double underline via 
                                        // FONTSIMU ATION
#define DF_NO_STRIKETHRU        0x0020  // Cannot strikethru via FONTSIMULATION
#define DF_BKSP_OK              0x0040  // Can use backspace char, see spec 
                                        // for details

//
// EXTTEXTMETRIC
//
// The EXTTEXTMETRIC structure provides extended-metric information for a font. 
// All the measurements are given in the specified units, 
// regardless of the current mapping mode of the display context.
//

#ifndef _EXTTEXTMETRIC_
#define _EXTTEXTMETRIC_

typedef struct _EXTTEXTMETRIC
    {
    short   emSize;
    short   emPointSize;
    short   emOrientation;
    short   emMasterHeight;
    short   emMinScale;
    short   emMaxScale;
    short   emMasterUnits;
    short   emCapHeight;
    short   emXHeight;
    short   emLowerCaseAscent;
    short   emLowerCaseDescent;
    short   emSlant;
    short   emSuperScript;
    short   emSubScript;
    short   emSuperScriptSize;
    short   emSubScriptSize;
    short   emUnderlineOffset;
    short   emUnderlineWidth;
    short   emDoubleUpperUnderlineOffset;
    short   emDoubleLowerUnderlineOffset;
    short   emDoubleUpperUnderlineWidth;
    short   emDoubleLowerUnderlineWidth;
    short   emStrikeOutOffset;
    short   emStrikeOutWidth;
    WORD    emKernPairs;
    WORD    emKernTracks;
} EXTTEXTMETRIC, *PEXTTEXTMETRIC;

#endif // _EXTTEXTMETRIC_


//
// WIDTHTABLE
//
// This data structure represents the character width table. 
// This width table is a continuous GLYPHHANDLE base, 
// not Unicode nor codepage/character code base. 
// GLYPHANDLE information is in the GLYPHDATA.
//

typedef struct _WIDTHRUN
{
    WORD    wStartGlyph;       // index of the first glyph handle
    WORD    wGlyphCount;       // number of glyphs covered
    DWORD   loCharWidthOffset; // glyph width table
} WIDTHRUN, *PWIDTHRUN;

typedef struct _WIDTHTABLE
{
    DWORD   dwSize;        // the size of this structure including every run
    DWORD   dwRunNum;      // the number of widthrun
    WIDTHRUN WidthRun[1];  // width run array
} WIDTHTABLE, *PWIDTHTABLE;

//
// The array has wGlyphCount elements and each element is the char width 
// for a single glyph. The first width corresponds to glyph index wStartGlyph 
// and so on. The byte offset is relative to the beginning of WIDTHTABLE
// structure and must be WORD-aligned.
// In case of Western device font, proportional font has all varibal pitch
// characters. This means that dwRunNum is set to 1 and loCharWidthOffset
// would be an offset from the top of WIDTHTABLE to a width vector of all 
// characters.
// In case of Far Eastern device font, basically IFIMETRICS.fwdAveCharWidth and
// IFIMETRICS.fwdMaxCharWidth are used for single byte and double byte character
// width. If a font is proportional, a UFM has a WIDTHTABLE which represents
// only the proportional pitch characters. Other characters use fdwAveCharWidth
// and fwdMaxCharInc for single and double byte characters.
//

//
// KERNDATA
// This data structure represents kerning pair information.
// This kerning pair table is a Unicode base.
//

typedef struct _KERNDATA
{
    DWORD dwSize;               // the size of this structure including array
    DWORD dwKernPairNum;        // the number of kerning pair
    FD_KERNINGPAIR KernPair[1]; // FD_KERNINGPAIR array
} KERNDATA, *PKERNDATA;



//
//
// G L Y P H  S E T D A T A  ( G T T )
//
//

//
// UNI_GLYPHSETDATA
//
// GLYPHSETDATA data structure represents a character encoding information 
// of printer device font. 
//

typedef struct _UNI_GLYPHSETDATA {
        DWORD   dwSize;
        DWORD   dwVersion;
        DWORD   dwFlags;
        LONG    lPredefinedID;
        DWORD   dwGlyphCount;
        DWORD   dwRunCount;
        DWORD   loRunOffset;
        DWORD   dwCodePageCount;
        DWORD   loCodePageOffset;
        DWORD   loMapTableOffset;
        DWORD   dwReserved[2];
} UNI_GLYPHSETDATA, *PUNI_GLYPHSETDATA;

#define UNI_GLYPHSETDATA_VERSION_1_0    0x00010000

#define GET_GLYPHRUN(pGTT)     \
    ((PGLYPHRUN) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loRunOffset))
#define GET_CODEPAGEINFO(pGTT) \
    ((PUNI_CODEPAGEINFO) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loCodePageOffset))
#define GET_MAPTABLE(pGTT) \
    ((PMAPTABLE) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loMapTableOffset))

//
// UNI_CODEPAGEINFO
//
// This UNI_CODEPAGEINFO dats structure has a list of Codepage values 
// which are supported by this UNI_GLYPHSETDATA.
//

typedef struct _UNI_CODEPAGEINFO {
    DWORD dwCodePage;
    INVOC SelectSymbolSet;
    INVOC UnSelectSymbolSet;
} UNI_CODEPAGEINFO, *PUNI_CODEPAGEINFO;

//
// GLYPHRUN
//
// GLYPHRUN dats structure represents the conversion table from Unicode to 
// UNI_GLYPHSETDATA specific glyph handle. Glyph handle is continuous number 
// starting from zero.
//

typedef struct _GLYPHRUN {
    WCHAR   wcLow;
    WORD    wGlyphCount;
} GLYPHRUN, *PGLYPHRUN;


//
// MAPTABLE and TRANSDATA
//
// This MAPTABLE data structure represents a conversion table fron glyph handle
// to codepage/character code.
//

typedef struct _TRANSDATA {
    BYTE  ubCodePageID; // Codepage index to CODEPAGENFO data structure array
    BYTE  ubType;       // a type of TRANSDATA
    union
    {
        SHORT   sCode;
        BYTE    ubCode;
        BYTE    ubPairs[2];
    } uCode;
} TRANSDATA, *PTRANSDATA;

typedef struct _MAPTABLE {
    DWORD     dwSize;     // the size of MAPTABLE including TRANSDATA array
    DWORD     dwGlyphNum; // the number of glyphs supported in MAPTABLE
    TRANSDATA Trans[1];   // an array of TRANSDATA
} MAPTABLE, *PMAPTABLE;

//
// ubType flags
//
// One of following three can be specified for the type of uCode.
//

#define MTYPE_FORMAT_MASK 0x07
#define MTYPE_COMPOSE   0x01 // wCode is an array of 16-bit offsets from the
                             // beginning of the MAPTABLE pointing to the
                             // strings to use for translation.
                             // bData representes thelength of the translated
                             // string.
#define MTYPE_DIRECT    0x02 // wCode is a byte data of one-to-one translation
#define MTYPE_PAIRED    0x04 // wCode contains a word data to emit.

//
// One of following tow can be specified for Far East multibyte character.
//

#define MTYPE_DOUBLEBYTECHAR_MASK   0x18
#define MTYPE_SINGLE    0x08 // wCode contains a single byte character code in
                             // multi byte character string.
#define MTYPE_DOUBLE    0x10 // wCode contains a double byte character code in
                             // multi byte character string.
//
// One of following three can be specified for replace/add/disable system 
// predefined GTT.
//

#define MTYPE_PREDEFIN_MASK   0xe0
#define MTYPE_REPLACE   0x20 // wCode contains a data to replace predefined one.
#define MTYPE_ADD       0x40 // wCode contains a data to add to predefiend one.
#define MTYPE_DISABLE   0x80 // wCode contains a data to remove from predefined.


//
// System predefined character conversion
//
// UNIDRV is going to support  following system predefined character conversion.
// By speciffying these number in UNIFM.dwGlyphSetDataRCID;
//

#define CC_NOPRECNV 0x0000FFFF // Not use predefined

//
// ANSI
//
#define CC_DEFAULT  0 // Default Character Conversion
#define CC_CP437   -1 // Unicode to IBM Codepage 437
#define CC_CP850   -2 // Unicode to IBM Codepage 850
#define CC_CP863   -3 // Unicode to IBM Codepage 863

//
// Far East
//

#define CC_BIG5     -10 // Unicode to Chinese Big 5. Codepage 950.
#define CC_ISC      -11 // Unicode to Korean Industrial Standard. Codepage 949.
#define CC_JIS      -12 // Unicode to JIS X0208. Codepage 932.
#define CC_JIS_ANK  -13 // Unicode to JIS X0208 except ANK. Codepage 932.
#define CC_NS86     -14 // Big-5 to National Standstand conversion. Codepage 950
#define CC_TCA      -15 // Big-5 to Taipei Computer Association. Codepage 950.
#define CC_GB2312   -16 // Unicode to GB2312. Codepage 936
#define CC_SJIS     -17 // Unicode to Shift-JIS. Codepage 932.
#define CC_WANSUNG  -18 // Unicode to Extented Wansung. Codepage 949.


//
//
// U N I V E R S A L  F O N T  F O R M A T  ( U F F )
//
//

//
// Font file header
//

typedef struct _UFF_FILEHEADER {
    DWORD       dwSignature;            // File magic number
    DWORD       dwVersion;              // UFF file format version number
    DWORD       dwSize;                 // Size of this structure

    DWORD       nFonts;                 // Count of fonts in directory
    DWORD       nGlyphSets;             // Count of glyph set data
    DWORD       nVarData;               // Count of variable data

    DWORD       offFontDir;             // Offset of font directory
    DWORD       dwFlags;                // Miscellaneous flags
    DWORD       dwReserved[4];          // Reserved, set to zero
} UFF_FILEHEADER, *PUFF_FILEHEADER;

//
// Values used in the file header
//

#define UFF_FILE_MAGIC      '1FFU'
#define UFF_VERSION_NUMBER  0x00010001

#define FONT_DIR_SORTED     0x00000001

//
// Font directory structure
//

typedef struct _UFF_FONTDIRECTORY {
    DWORD       dwSignature;            // Signature of font metrics record
    WORD        wSize;                  // Size of this structure
    WORD        wFontID;                // Unique font ID
    SHORT       sGlyphID;               // Associated glyph ID. 0 is default.
                                        // -ve values are predefined IDs
    WORD        wFlags;                 // Miscellaneous flags
    DWORD       dwInstallerSig;         // Signature of installer that installed this font
    DWORD       offFontName;            // Offset to name of font
    DWORD       offCartridgeName;       // Offset to name of font cartridge
    DWORD       offFontData;            // Offset to font data record
    DWORD       offGlyphData;           // Offset to glyph set data
    DWORD       offVarData;             // Offset to softfont data
} UFF_FONTDIRECTORY, *PUFF_FONTDIRECTORY;

#define FONT_REC_SIG            'CERF'  // font metrics record signature

#define WINNT_INSTALLER_SIG     'IFTN'  // NT font installer

//
// Flags used in font directory
//

#define FONT_FL_UFM             0x0001
#define FONT_FL_IFI             0x0002
#define FONT_FL_SOFTFONT        0x0004
#define FONT_FL_PERMANENT_SF    0x0008
#define FONT_FL_DEVICEFONT      0x0010
#define FONT_FL_GLYPHSET_GTT    0x0020
#define FONT_FL_GLYPHSET_RLE    0x0040
#define FONT_FL_RESERVED        0x8000

//
// Data header
//

typedef struct _DATA_HEADER {
    DWORD       dwSignature;            // Signature of data type
    WORD        wSize;                  // Size of this structure
    WORD        wDataID;                // Identifier number for data
    DWORD       dwDataSize;             // Size of data excluding structure
    DWORD       dwReserved;             // Reserved, set to zero
} DATA_HEADER, *PDATA_HEADER;

//
// Data signatures
//

#define DATA_UFM_SIG        'MFUD'
#define DATA_IFI_SIG        'IFID'
#define DATA_GTT_SIG        'TTGD'
#define DATA_CTT_SIG        'TTCD'
#define DATA_VAR_SIG        'RAVD'

//
// Structure passed to font installer dialog proc through LPARAM
//

typedef struct _OEMFONTINSTPARAM {
    DWORD   cbSize;
    HANDLE  hPrinter;
    HANDLE  hModule;
    HANDLE  hHeap;
    DWORD   dwFlags;
    PWSTR   pFontInstallerName;
} OEMFONTINSTPARAM, *POEMFONTINSTPARAM;

#define FG_CANCHANGE        0x00080    // Have access to change data

#define WM_FI_FILENAME      900        // To get the font installer name.



#endif //_PRNTFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\publish\pdrvver.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pdrvver.h

Abstract:

    Printer Driver Version Resource File

Environment:

    Windows NT printer drivers

Revision History:


--*/

//
// Printer Driver Version Resource File
// This file describes a template for the versioning scheme for printer drivers. 
// It is recommended that this file be modified and included in every 
// printer driver DLL resource file, even for monolithic printer drivers, 
// which are not Unidrv-based minidrivers. 
//
// The versioning scheme:
// The versioning scheme is defined in detail in the DDK documentation. 
// Please refer to it for more information.
//

#include <ntverp.h>

//
// The following field sets the type of DLL. For printer drivers it should 
// always be set to VFT_DRV. Don't change this field.
//

#define VER_FILETYPE                VFT_DRV

//
// If the DLL is of type VFT_DRV then the following field contains a more 
// specific description of the driver. For versioned printer drivers it should 
// always be set to VFT2_DRV_VERSIONED_PRINTER. Don't change this field.
//

#define VER_FILESUBTYPE             VFT2_DRV_VERSIONED_PRINTER

//
// For a versioned printer driver, the following field indicates the File 
// Version of the DLL. The file version consists of four 16-bit (WORD) numbers. 
// The description of each of them is as follows. From left to right,
//
//      First WORD  :   Reserved. Should be set to 0.
//      Second WORD :   Major version of the driver. For user-mode drivers, set
//                      this to 3. For kernel-mode drivers, set this to 2.
//      Third WORD  :   Feature set number. 
//                      The high byte of this number represents the major 
//                      feature set and should always be incremented with the
//                      next major release. A newer release is assumed to 
//                      have a superset of the functionality of the previous 
//                      release. 
//                      The low byte represents minor releases - 
//                      new releases from the same code base or the 
//                      same architecture. The low byte should be 
//                      incremented with each new minor release.
//      Fourth WORD :   Bug fix number or service pack number. This field 
//                      represents the releases of major feature set 
//                      binaries for bugs or service packs and should always
//                      be incremented with each minor release.
//
// Example     :   0, 3, 0x0100, 0x0000
// In the above example the third number shows that the DLL belongs to the first
// major release of the driver. After fixing some bugs in this binary the
// version should be changed to  0, 3, 0x0100, 0x0001. For the next minor 
// release of the driver, which is a superset of the previous release, the 
// version  should be changed to 0, 3, 0x0101, 0x0001. In this case the low 
// byte of the feature set was changed instead of the high byte. This allows 
// more control on the versions. It is recommended that the high byte be used 
// to describe different code bases or major architecture changes and the low 
// byte be used for new releases from the same code base or from the same 
// architecture.
//
// Basically the Feature set and Bug Fix numbers should be used in such a way
// that when they are combined (Feature set = HIWORD, Bug fix = LOWORD) in a 
// 32-bit quantity (DWORD), the new number represents all the features of the
// DLL. A larger number represents newer versions, which are supersets of 
// functionality and bug fixes with respect to all previous releases.
//
// This field needs to be changed per the description above.
//
//

#define VER_FILEVERSION             0, 3, 0, 0

//
// The following field describes the driver. It should include a specific name,
// which identifies the driver.
//
// This field needs to be changed.
//

#define VER_FILEDESCRIPTION_STR     "Sample Printer Driver Resource DLL"

//
// The following field specifies the internal name of the file. For more 
// information, refer to the SDK documentation.
//
// This field needs to be changed.
//

#define VER_INTERNALNAME_STR        "SAMPLERES.DLL"

//
// The following field specifies the original name of the file, not including a 
// path. For more information refer to the SDK documentation.
//
// This field needs to be changed.
//

#define VER_ORIGINALFILENAME_STR    "SAMPLERES.DLL"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\publish\winsplp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    WinSplp.h

Abstract:

    Internal Header file for Print APIs

Author:

Revision History:

--*/

#ifndef _WINSPLP_
#define _WINSPLP_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


#define PRINTER_NOTIFY_STATUS_ENDPOINT 1
#define PRINTER_NOTIFY_STATUS_POLL     2
#define PRINTER_NOTIFY_STATUS_INFO     4


#define ROUTER_UNKNOWN      0
#define ROUTER_SUCCESS      1
#define ROUTER_STOP_ROUTING 2


typedef struct _PRINTER_NOTIFY_INIT {
    DWORD Size;
    DWORD Reserved;
    DWORD PollTime;
} PRINTER_NOTIFY_INIT, *PPRINTER_NOTIFY_INIT, *LPPRINTER_NOTIFY_INIT;

typedef struct _SPLCLIENT_INFO_1{
    DWORD       dwSize;
    LPWSTR      pMachineName;
    LPWSTR      pUserName;
    DWORD       dwBuildNum;
    DWORD       dwMajorVersion;
    DWORD       dwMinorVersion;
    WORD        wProcessorArchitecture;
} SPLCLIENT_INFO_1, *PSPLCLIENT_INFO_1, *LPSPLCLIENT_INFO_1;

// This definition is used in the private spooler RPC interface (RpcSplOpenPrinter)
// The handle returned in the struct is the Server Side hPrinter which will used in
// making direct API calls from the client to the server side w/o the overhead of
// RPC. The performance boost is observed mainly in calls to Read/WritePrinter made from
// within the spooler (gdi32.dll during playback)
//
// To be changed.
// According to MIDL: 64-bit Porting Guide ( Last Updated Aug 1999 )
// "My handle is within a machine only, both on 32-bit and 64-bit,
// and it would never ever be sent from a 64-bit process to 32-bit process or vice versa
// You can set up the build separately for 64-bit and 32-bit, using separate 32/64-bit IDL files.
// In this way you can have DWORD on 32-bit platform and ULONG64 on 64-bit platform.
// Or, you can use DWORD_PTR, once the optimization for ULONG_PTR/DWORD_PTR to remote eight bytes
// when talking between 64-bit processes and four bytes otherwise is supported."
//
// Change hSplPrinter back to ULONG_PTR once the RPC optimization is in place.
//
typedef struct _SPLCLIENT_INFO_2{

#ifdef _WIN64
    DWORD64 hSplPrinter;      // Server side handle to be used for direct calls
#else
    DWORD32 hSplPrinter;      // Server side handle to be used for direct calls
#endif

} SPLCLIENT_INFO_2, *PSPLCLIENT_INFO_2, *LPSPLCLIENT_INFO_2;

typedef struct _PRINTPROVIDOR {

   BOOL (*fpOpenPrinter)(LPWSTR   pPrinterName,
                         LPHANDLE phPrinter,
                         LPPRINTER_DEFAULTS pDefault);

   BOOL (*fpSetJob)(HANDLE hPrinter,
                    DWORD JobId,
                    DWORD Level,
                    LPBYTE pJob,
                    DWORD Command);

   BOOL (*fpGetJob)(HANDLE   hPrinter,
                    DWORD    JobId,
                    DWORD    Level,
                    LPBYTE   pJob,
                    DWORD    cbBuf,
                    LPDWORD  pcbNeeded);

   BOOL (*fpEnumJobs)(HANDLE  hPrinter,
                      DWORD   FirstJob,
                      DWORD   NoJobs,
                      DWORD   Level,
                      LPBYTE  pJob,
                      DWORD   cbBuf,
                      LPDWORD pcbNeeded,
                      LPDWORD pcReturned);

   HANDLE (*fpAddPrinter)(LPWSTR  pName,
                          DWORD   Level,
                          LPBYTE  pPrinter);

   BOOL (*fpDeletePrinter)(HANDLE   hPrinter);

   BOOL (*fpSetPrinter)(HANDLE  hPrinter,
                        DWORD   Level,
                        LPBYTE  pPrinter,
                        DWORD   Command);

   BOOL (*fpGetPrinter)(HANDLE  hPrinter,
                        DWORD   Level,
                        LPBYTE  pPrinter,
                        DWORD   cbBuf,
                        LPDWORD pcbNeeded);

   BOOL (*fpEnumPrinters)(DWORD   Flags,
                          LPWSTR  Name,
                          DWORD   Level,
                          LPBYTE  pPrinterEnum,
                          DWORD   cbBuf,
                          LPDWORD pcbNeeded,
                          LPDWORD pcReturned);

   BOOL (*fpAddPrinterDriver)(LPWSTR  pName,
                              DWORD   Level,
                              LPBYTE  pDriverInfo);

   BOOL (*fpEnumPrinterDrivers)(LPWSTR  pName,
                                LPWSTR  pEnvironment,
                                DWORD   Level,
                                LPBYTE  pDriverInfo,
                                DWORD   cbBuf,
                                LPDWORD pcbNeeded,
                                LPDWORD pcReturned);

   BOOL (*fpGetPrinterDriver)(HANDLE  hPrinter,
                              LPWSTR  pEnvironment,
                              DWORD   Level,
                              LPBYTE  pDriverInfo,
                              DWORD   cbBuf,
                              LPDWORD pcbNeeded);

   BOOL (*fpGetPrinterDriverDirectory)(LPWSTR  pName,
                                       LPWSTR  pEnvironment,
                                       DWORD   Level,
                                       LPBYTE  pDriverDirectory,
                                       DWORD   cbBuf,
                                       LPDWORD pcbNeeded);

   BOOL (*fpDeletePrinterDriver)(LPWSTR   pName,
                                 LPWSTR   pEnvironment,
                                 LPWSTR   pDriverName);

   BOOL (*fpAddPrintProcessor)(LPWSTR  pName,
                               LPWSTR  pEnvironment,
                               LPWSTR  pPathName,
                               LPWSTR  pPrintProcessorName);

   BOOL (*fpEnumPrintProcessors)(LPWSTR  pName,
                                 LPWSTR  pEnvironment,
                                 DWORD   Level,
                                 LPBYTE  pPrintProcessorInfo,
                                 DWORD   cbBuf,
                                 LPDWORD pcbNeeded,
                                 LPDWORD pcReturned);

   BOOL (*fpGetPrintProcessorDirectory)(LPWSTR  pName,
                                        LPWSTR  pEnvironment,
                                        DWORD   Level,
                                        LPBYTE  pPrintProcessorInfo,
                                        DWORD   cbBuf,
                                        LPDWORD pcbNeeded);

   BOOL (*fpDeletePrintProcessor)(LPWSTR  pName,
                                  LPWSTR  pEnvironment,
                                  LPWSTR  pPrintProcessorName);

   BOOL (*fpEnumPrintProcessorDatatypes)(LPWSTR  pName,
                                         LPWSTR  pPrintProcessorName,
                                         DWORD   Level,
                                         LPBYTE  pDataypes,
                                         DWORD   cbBuf,
                                         LPDWORD pcbNeeded,
                                         LPDWORD pcReturned);

   DWORD (*fpStartDocPrinter)(HANDLE  hPrinter,
                             DWORD   Level,
                             LPBYTE  pDocInfo);

   BOOL (*fpStartPagePrinter)(HANDLE  hPrinter);

   BOOL (*fpWritePrinter)(HANDLE  hPrinter,
                          LPVOID  pBuf,
                          DWORD   cbBuf,
                          LPDWORD pcWritten);

   BOOL (*fpEndPagePrinter)(HANDLE   hPrinter);

   BOOL (*fpAbortPrinter)(HANDLE   hPrinter);

   BOOL (*fpReadPrinter)(HANDLE  hPrinter,
                         LPVOID  pBuf,
                         DWORD   cbBuf,
                         LPDWORD pNoBytesRead);

   BOOL (*fpEndDocPrinter)(HANDLE   hPrinter);

   BOOL (*fpAddJob)(HANDLE  hPrinter,
                    DWORD   Level,
                    LPBYTE  pData,
                    DWORD   cbBuf,
                    LPDWORD pcbNeeded);

   BOOL (*fpScheduleJob)(HANDLE  hPrinter,
                         DWORD   JobId);

   DWORD (*fpGetPrinterData)(HANDLE   hPrinter,
                             LPWSTR   pValueName,
                             LPDWORD  pType,
                             LPBYTE   pData,
                             DWORD    nSize,
                             LPDWORD  pcbNeeded);

   DWORD (*fpSetPrinterData)(HANDLE  hPrinter,
                             LPWSTR  pValueName,
                             DWORD   Type,
                             LPBYTE  pData,
                             DWORD   cbData);

   DWORD (*fpWaitForPrinterChange)(HANDLE hPrinter, DWORD Flags);

   BOOL (*fpClosePrinter)(HANDLE hPrinter);

   BOOL (*fpAddForm)(HANDLE  hPrinter,
                     DWORD   Level,
                     LPBYTE  pForm);

   BOOL (*fpDeleteForm)(HANDLE  hPrinter,
                        LPWSTR  pFormName);

   BOOL (*fpGetForm)(HANDLE  hPrinter,
                     LPWSTR  pFormName,
                     DWORD   Level,
                     LPBYTE  pForm,
                     DWORD   cbBuf,
                     LPDWORD pcbNeeded);

   BOOL (*fpSetForm)(HANDLE  hPrinter,
                     LPWSTR  pFormName,
                     DWORD   Level,
                     LPBYTE  pForm);

   BOOL (*fpEnumForms)(HANDLE  hPrinter,
                       DWORD   Level,
                       LPBYTE  pForm,
                       DWORD   cbBuf,
                       LPDWORD pcbNeeded,
                       LPDWORD pcReturned);

   BOOL (*fpEnumMonitors)(LPWSTR  pName,
                          DWORD   Level,
                          LPBYTE  pMonitors,
                          DWORD   cbBuf,
                          LPDWORD pcbNeeded,
                          LPDWORD pcReturned);

   BOOL (*fpEnumPorts)(LPWSTR  pName,
                       DWORD   Level,
                       LPBYTE  pPorts,
                       DWORD   cbBuf,
                       LPDWORD pcbNeeded,
                       LPDWORD pcReturned);

   BOOL (*fpAddPort)(LPWSTR  pName,
                     HWND    hWnd,
                     LPWSTR  pMonitorName);

   BOOL (*fpConfigurePort)(LPWSTR  pName,
                           HWND    hWnd,
                           LPWSTR  pPortName);

   BOOL (*fpDeletePort)(LPWSTR  pName,
                        HWND    hWnd,
                        LPWSTR  pPortName);

   HANDLE (*fpCreatePrinterIC)(HANDLE  hPrinter,
                               LPDEVMODEW   pDevMode);

   BOOL (*fpPlayGdiScriptOnPrinterIC)(HANDLE  hPrinterIC,
                                      LPBYTE  pIn,
                                      DWORD   cIn,
                                      LPBYTE  pOut,
                                      DWORD   cOut,
                                      DWORD   ul);

   BOOL (*fpDeletePrinterIC)(HANDLE  hPrinterIC);

   BOOL (*fpAddPrinterConnection)(LPWSTR  pName);

   BOOL (*fpDeletePrinterConnection)(LPWSTR pName);

   DWORD (*fpPrinterMessageBox)(HANDLE  hPrinter,
                                DWORD   Error,
                                HWND    hWnd,
                                LPWSTR  pText,
                                LPWSTR  pCaption,
                                DWORD   dwType);

   BOOL (*fpAddMonitor)(LPWSTR  pName,
                        DWORD   Level,
                        LPBYTE  pMonitorInfo);

   BOOL (*fpDeleteMonitor)(LPWSTR  pName,
                           LPWSTR  pEnvironment,
                           LPWSTR  pMonitorName);

   BOOL (*fpResetPrinter)(HANDLE hPrinter,
                          LPPRINTER_DEFAULTS pDefault);

   BOOL (*fpGetPrinterDriverEx)(HANDLE  hPrinter,
                              LPWSTR  pEnvironment,
                              DWORD   Level,
                              LPBYTE  pDriverInfo,
                              DWORD   cbBuf,
                              LPDWORD pcbNeeded,
                              DWORD   dwClientMajorVersion,
                              DWORD   dwClientMinorVersion,
                              PDWORD  pdwServerMajorVersion,
                              PDWORD  pdwServerMinorVersion);

   BOOL (*fpFindFirstPrinterChangeNotification)(
            HANDLE hPrinter,
            DWORD fdwFlags,
            DWORD fdwOptions,
            HANDLE hNotify,
            PDWORD pfdwStatus,
            PVOID pPrinterNotifyOptions,
            PVOID pPrinterNotifyInit);

   BOOL (*fpFindClosePrinterChangeNotification)(HANDLE hPrinter);


   BOOL (*fpAddPortEx)(LPWSTR   pName,
                       DWORD    Level,
                       LPBYTE   lpBuffer,
                       LPWSTR   lpMonitorName);

   BOOL (*fpShutDown)(LPVOID pvReserved);

   BOOL (*fpRefreshPrinterChangeNotification)(HANDLE hPrinter,
                                              DWORD  Reserved,
                                              PVOID pvReserved,
                                              PVOID pPrinterNotifyInfo);

   BOOL (*fpOpenPrinterEx)(LPWSTR     pPrinterName,
                           LPHANDLE   phPrinter,
                           LPPRINTER_DEFAULTS pDefault,
                           LPBYTE     pClientInfo,
                           DWORD      Level);

   HANDLE (*fpAddPrinterEx)(LPWSTR  pName,
                            DWORD   Level,
                            LPBYTE  pPrinter,
                            LPBYTE  pClientInfo,
                            DWORD   ClientInfoLevel);

   BOOL (*fpSetPort)(LPWSTR     pName,
                     LPWSTR     pPortName,
                     DWORD      Level,
                     LPBYTE     pPortInfo);

   DWORD (*fpEnumPrinterData)(HANDLE   hPrinter,
                              DWORD    dwIndex,
                              LPWSTR   pValueName,
                              DWORD    cbValueName,
                              LPDWORD  pcbValueName,
                              LPDWORD  pType,
                              LPBYTE   pData,
                              DWORD    cbData,
                              LPDWORD  pcbData);

   DWORD (*fpDeletePrinterData)(HANDLE   hPrinter,
                                LPWSTR   pValueName);

   DWORD (*fpClusterSplOpen)( LPCTSTR pszServer,
                              LPCTSTR pszResource,
                              PHANDLE phSpooler,
                              LPCTSTR pszName,
                              LPCTSTR pszAddress );


   DWORD (*fpClusterSplClose)( HANDLE hSpooler );

   DWORD (*fpClusterSplIsAlive)( HANDLE hSpooler );

   DWORD (*fpSetPrinterDataEx)(  HANDLE  hPrinter,
                                 LPCWSTR pKeyName,
                                 LPCWSTR pValueName,
                                 DWORD   Type,
                                 LPBYTE  pData,
                                 DWORD   cbData);

   DWORD (*fpGetPrinterDataEx)(HANDLE   hPrinter,
                               LPCWSTR  pKeyName,
                               LPCWSTR  pValueName,
                               LPDWORD  pType,
                               LPBYTE   pData,
                               DWORD    nSize,
                               LPDWORD  pcbNeeded);

   DWORD (*fpEnumPrinterDataEx)(  HANDLE  hPrinter,
                                  LPCWSTR pKeyName,
                                  LPBYTE  pEnumValues,
                                  DWORD   cbEnumValues,
                                  LPDWORD pcbEnumValues,
                                  LPDWORD pnEnumValues);

   DWORD (*fpEnumPrinterKey)( HANDLE   hPrinter,
                              LPCWSTR  pKeyName,
                              LPWSTR   pSubkey,
                              DWORD    cbSubkey,
                              LPDWORD  pcbSubkey);

   DWORD (*fpDeletePrinterDataEx)(  HANDLE  hPrinter,
                                    LPCWSTR pKeyName,
                                    LPCWSTR pValueName);

   DWORD (*fpDeletePrinterKey)(  HANDLE  hPrinter,
                                 LPCWSTR pKeyName);

   BOOL (*fpSeekPrinter)( HANDLE hPrinter,
                          LARGE_INTEGER liDistanceToMove,
                          PLARGE_INTEGER pliNewPointer,
                          DWORD dwMoveMethod,
                          BOOL bWrite );

   BOOL (*fpDeletePrinterDriverEx)(LPWSTR   pName,
                                   LPWSTR   pEnvironment,
                                   LPWSTR   pDriverName,
                                   DWORD    dwDeleteFlag,
                                   DWORD    dwVersionNum);

   BOOL (*fpAddPerMachineConnection)(LPCWSTR    pServer,
                                     LPCWSTR    pPrinterName,
                                     LPCWSTR    pPrintServer,
                                     LPCWSTR    pProvider);

   BOOL (*fpDeletePerMachineConnection)(LPCWSTR   pServer,
                                        LPCWSTR   pPrinterName);

   BOOL (*fpEnumPerMachineConnections)(LPCWSTR    pServer,
                                       LPBYTE     pPrinterEnum,
                                       DWORD      cbBuf,
                                       LPDWORD    pcbNeeded,
                                       LPDWORD    pcReturned);

   BOOL (*fpXcvData)(   HANDLE  hXcv,
                        LPCWSTR pszDataName,
                        PBYTE   pInputData,
                        DWORD   cbInputData,
                        PBYTE   pOutputData,
                        DWORD   cbOutputData,
                        PDWORD  pcbOutputNeeded,
                        PDWORD  pdwStatus
                        );

   BOOL (*fpAddPrinterDriverEx)(LPWSTR  pName,
                                DWORD   Level,
                                LPBYTE  pDriverInfo,
                                DWORD   dwFileCopyFlags);

   BOOL (*fpSplReadPrinter)(HANDLE hPrinter,
                            LPBYTE *pBuf,
                            DWORD  cbBuf);

   BOOL (*fpDriverUnloadComplete)(LPWSTR  pDriverFile);

   BOOL (*fpGetSpoolFileInfo)(HANDLE    hPrinter,
                              LPWSTR    *pSpoolDir,
                              LPHANDLE  phFile,
                              HANDLE    hSpoolerProcess,
                              HANDLE    hAppProcess);

   BOOL (*fpCommitSpoolData)(HANDLE  hPrinter,
                             DWORD   cbCommit);

   BOOL (*fpCloseSpoolFileHandle)(HANDLE  hPrinter);

   BOOL (*fpFlushPrinter)(HANDLE  hPrinter,
                          LPBYTE  pBuf,
                          DWORD   cbBuf,
                          LPDWORD pcWritten,
                          DWORD   cSleep);
   DWORD (*fpSendRecvBidiData)(HANDLE                    hPrinter,
                               LPCWSTR                   pAction,
                               PBIDI_REQUEST_CONTAINER   pReqData,
                               PBIDI_RESPONSE_CONTAINER* ppResData);

   BOOL (*fpAddDriverCatalog)(HANDLE  hPrinter,
                              DWORD   dwLevel,
                              VOID    *pvDriverInfCatInfo,
                              DWORD   dwCatalogCopyFlags);

} PRINTPROVIDOR, *LPPRINTPROVIDOR;

BOOL
InitializePrintProvidor(
   LPPRINTPROVIDOR  pPrintProvidor,
   DWORD    cbPrintProvidor,
   LPWSTR   pFullRegistryPath
);

typedef struct _PRINTPROCESSOROPENDATA {
    PDEVMODE  pDevMode;
    LPWSTR    pDatatype;
    LPWSTR    pParameters;
    LPWSTR    pDocumentName;
    DWORD     JobId;
    LPWSTR    pOutputFile;
    LPWSTR    pPrinterName;
} PRINTPROCESSOROPENDATA, *PPRINTPROCESSOROPENDATA, *LPPRINTPROCESSOROPENDATA;

HANDLE
OpenPrintProcessor(
    LPWSTR  pPrinterName,
    PPRINTPROCESSOROPENDATA pPrintProcessorOpenData
);

BOOL
PrintDocumentOnPrintProcessor(
    HANDLE  hPrintProcessor,
    LPWSTR  pDocumentName
);

BOOL
ClosePrintProcessor(
    HANDLE  hPrintProcessor
);

BOOL
ControlPrintProcessor(
    HANDLE  hPrintProcessor,
    DWORD   Command
);

DWORD
GetPrintProcessorCapabilities(
    LPTSTR   pValueName,
    DWORD    dwAttributes,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
);

BOOL
InitializeMonitor(
    LPWSTR  pRegistryRoot
);

BOOL
OpenPort(
    LPWSTR  pName,
    PHANDLE pHandle
);

BOOL
WritePort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
);

BOOL
ReadPort(
    HANDLE hPort,
    LPBYTE pBuffer,
    DWORD  cbBuffer,
    LPDWORD pcbRead
);

BOOL
ClosePort(
    HANDLE  hPort
);


BOOL
XcvOpenPort(
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
);

DWORD
XcvDataPort(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
);

BOOL
XcvClosePort(
    HANDLE  hXcv
);


BOOL
AddPortUI
(
    PCWSTR  pszServer,
    HWND    hWnd,
    PCWSTR  pszMonitorNameIn,
    PWSTR  *ppszPortNameOut
);

BOOL
ConfigurePortUI
(
    PCWSTR pszServer,
    HWND   hWnd,
    PCWSTR pszPortName
);

BOOL
DeletePortUI
(
    PCWSTR pszServer,
    HWND   hWnd,
    PCWSTR pszPortName
);


BOOL
SplDeleteSpoolerPortStart(
    PCWSTR pPortName
);

BOOL
SplDeleteSpoolerPortEnd(
    PCWSTR pName,
    BOOL   bDeletePort
);

typedef struct _MONITORREG {

    DWORD cbSize;

    LONG
    (WINAPI *fpCreateKey)(
        HANDLE hcKey,
        LPCTSTR pszSubKey,
        DWORD dwOptions,
        REGSAM samDesired,
        PSECURITY_ATTRIBUTES pSecurityAttributes,
        PHANDLE phckResult,
        PDWORD pdwDisposition,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpOpenKey)(
        HANDLE hcKey,
        LPCTSTR pszSubKey,
        REGSAM samDesired,
        PHANDLE phkResult,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpCloseKey)(
        HANDLE hcKey,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpDeleteKey)(
        HANDLE hcKey,
        LPCTSTR pszSubKey,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpEnumKey)(
        HANDLE hcKey,
        DWORD dwIndex,
        LPTSTR pszName,
        PDWORD pcchName,
        PFILETIME pftLastWriteTime,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpQueryInfoKey)(
        HANDLE hcKey,
        PDWORD pcSubKeys,
        PDWORD pcbKey,
        PDWORD pcValues,
        PDWORD pcbValue,
        PDWORD pcbData,
        PDWORD pcbSecurityDescriptor,
        PFILETIME pftLastWriteTime,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpSetValue)(
        HANDLE hcKey,
        LPCTSTR pszValue,
        DWORD dwType,
        const BYTE* pData,
        DWORD cbData,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpDeleteValue)(
        HANDLE hcKey,
        LPCTSTR pszValue,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpEnumValue)(
        HANDLE hcKey,
        DWORD dwIndex,
        LPTSTR pszValue,
        PDWORD pcbValue,
        PDWORD pType,
        PBYTE pData,
        PDWORD pcbData,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpQueryValue)(
        HANDLE hcKey,
        LPCTSTR pszValue,
        PDWORD pType,
        PBYTE pData,
        PDWORD pcbData,
        HANDLE hSpooler
        );

} MONITORREG, *PMONITORREG;


typedef struct _MONITORINIT {
    DWORD cbSize;
    HANDLE hSpooler;
    HANDLE hckRegistryRoot;
    PMONITORREG pMonitorReg;
    BOOL bLocal;
    LPCWSTR pszServerName;
} MONITORINIT, *PMONITORINIT;


typedef struct _MONITOR
{
    BOOL (WINAPI *pfnEnumPorts)
    (
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    );

    BOOL (WINAPI *pfnOpenPort)
    (
    LPWSTR  pName,
    PHANDLE pHandle
    );

    BOOL (WINAPI *pfnOpenPortEx)
    (
    LPWSTR  pPortName,
    LPWSTR  pPrinterName,
    PHANDLE pHandle,
    struct _MONITOR FAR *pMonitor
    );


    BOOL (WINAPI *pfnStartDocPort)
    (
    HANDLE  hPort,
    LPWSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo
    );

    BOOL (WINAPI *pfnWritePort)
    (
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
    );

    BOOL (WINAPI *pfnReadPort)
    (
    HANDLE hPort,
    LPBYTE pBuffer,
    DWORD  cbBuffer,
    LPDWORD pcbRead
    );

    BOOL (WINAPI *pfnEndDocPort)
    (
    HANDLE   hPort
    );

    BOOL (WINAPI *pfnClosePort)
    (
        HANDLE  hPort
    );

    BOOL (WINAPI *pfnAddPort)
    (
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
    );

    BOOL (WINAPI *pfnAddPortEx)
    (
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   lpBuffer,
    LPWSTR   lpMonitorName
    );

    BOOL (WINAPI *pfnConfigurePort)
    (
    LPWSTR   pName,
    HWND  hWnd,
    LPWSTR pPortName
    );

    BOOL (WINAPI *pfnDeletePort)
    (
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    );

    BOOL (WINAPI *pfnGetPrinterDataFromPort)
    (
    HANDLE  hPort,
    DWORD   ControlID,
    LPWSTR  pValueName,
    LPWSTR  lpInBuffer,
    DWORD   cbInBuffer,
    LPWSTR  lpOutBuffer,
    DWORD   cbOutBuffer,
    LPDWORD lpcbReturned
    );

    BOOL (WINAPI *pfnSetPortTimeOuts)
    (
    HANDLE  hPort,
    LPCOMMTIMEOUTS lpCTO,
    DWORD   reserved    // must be set to 0
    );

    BOOL (WINAPI *pfnXcvOpenPort)
    (
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    );

    DWORD (WINAPI *pfnXcvDataPort)
    (
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
    );

    BOOL (WINAPI *pfnXcvClosePort)
    (
    HANDLE  hXcv
    );


} MONITOR, FAR *LPMONITOR;

typedef struct _MONITOREX
{
    DWORD       dwMonitorSize;
    MONITOR     Monitor;

} MONITOREX, FAR *LPMONITOREX;


typedef struct _MONITOR2
{
    DWORD cbSize;
    BOOL (WINAPI *pfnEnumPorts)
    (
    HANDLE  hMonitor,
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    );

    BOOL (WINAPI *pfnOpenPort)
    (
    HANDLE  hMonitor,
    LPWSTR  pName,
    PHANDLE pHandle
    );

    BOOL (WINAPI *pfnOpenPortEx)
    (
    HANDLE  hMonitor,
    HANDLE  hMonitorPort,
    LPWSTR  pPortName,
    LPWSTR  pPrinterName,
    PHANDLE pHandle,
    struct _MONITOR2 FAR *pMonitor2
    );


    BOOL (WINAPI *pfnStartDocPort)
    (
    HANDLE  hPort,
    LPWSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo
    );

    BOOL (WINAPI *pfnWritePort)
    (
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
    );

    BOOL (WINAPI *pfnReadPort)
    (
    HANDLE hPort,
    LPBYTE pBuffer,
    DWORD  cbBuffer,
    LPDWORD pcbRead
    );

    BOOL (WINAPI *pfnEndDocPort)
    (
    HANDLE   hPort
    );

    BOOL (WINAPI *pfnClosePort)
    (
    HANDLE  hPort
    );

    BOOL (WINAPI *pfnAddPort)
    (
    HANDLE   hMonitor,
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pMonitorName
    );

    BOOL (WINAPI *pfnAddPortEx)
    (
    HANDLE   hMonitor,
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   lpBuffer,
    LPWSTR   lpMonitorName
    );

    BOOL (WINAPI *pfnConfigurePort)
    (
    HANDLE  hMonitor,
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    );

    BOOL (WINAPI *pfnDeletePort)
    (
    HANDLE  hMonitor,
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    );

    BOOL (WINAPI *pfnGetPrinterDataFromPort)
    (
    HANDLE  hPort,
    DWORD   ControlID,
    LPWSTR  pValueName,
    LPWSTR  lpInBuffer,
    DWORD   cbInBuffer,
    LPWSTR  lpOutBuffer,
    DWORD   cbOutBuffer,
    LPDWORD lpcbReturned
    );

    BOOL (WINAPI *pfnSetPortTimeOuts)
    (
    HANDLE  hPort,
    LPCOMMTIMEOUTS lpCTO,
    DWORD   reserved    // must be set to 0
    );

    BOOL (WINAPI *pfnXcvOpenPort)
    (
    HANDLE  hMonitor,
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    );

    DWORD (WINAPI *pfnXcvDataPort)
    (
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
    );

    BOOL (WINAPI *pfnXcvClosePort)
    (
    HANDLE  hXcv
    );

    VOID (WINAPI *pfnShutdown)
    (
    HANDLE hMonitor
    );

    DWORD (WINAPI *pfnSendRecvBidiDataFromPort)
    (
    HANDLE                    hPort,
    DWORD                     dwAccessBit,
    LPCWSTR                   pAction,
    PBIDI_REQUEST_CONTAINER   pReqData,
    PBIDI_RESPONSE_CONTAINER* ppResData
    );

} MONITOR2, *PMONITOR2, FAR *LPMONITOR2;

#define MONITOR2_SIZE_WIN2K ( sizeof(DWORD) + (sizeof(PVOID)*18) )

typedef struct _MONITORUI
{
    DWORD   dwMonitorUISize;

    BOOL (WINAPI *pfnAddPortUI)
    (
        PCWSTR pszServer,
        HWND   hWnd,
        PCWSTR pszMonitorNameIn,
        PWSTR  *ppszPortNameOut
    );

    BOOL (WINAPI *pfnConfigurePortUI)
    (
        PCWSTR  pName,
        HWND    hWnd,
        PCWSTR  pPortName
    );

    BOOL (WINAPI *pfnDeletePortUI)
    (
        PCWSTR pszServer,
        HWND   hWnd,
        PCWSTR pszPortName
    );

} MONITORUI, FAR *PMONITORUI;


HANDLE
CreatePrinterIC(
    HANDLE  hPrinter,
    LPDEVMODEW  pDevMode
);

BOOL
PlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE  pIn,
    DWORD   cIn,
    LPBYTE  pOut,
    DWORD   cOut,
    DWORD   ul
);

BOOL
DeletePrinterIC(
    HANDLE  hPrinterIC
);

BOOL
DevQueryPrint(
    HANDLE      hPrinter,
    LPDEVMODE   pDevMode,
    DWORD      *pResID
);

HANDLE
RevertToPrinterSelf(
    VOID
);

BOOL
ImpersonatePrinterClient(
    HANDLE  hToken
);

BOOL
ReplyPrinterChangeNotification(
    HANDLE hNotify,
    DWORD fdwFlags,
    PDWORD pdwResult,
    PVOID pPrinterNotifyInfo
);

BOOL
PartialReplyPrinterChangeNotification(
    HANDLE hNotify,
    PPRINTER_NOTIFY_INFO_DATA pInfoDataSrc
);

PPRINTER_NOTIFY_INFO
RouterAllocPrinterNotifyInfo(
    DWORD cPrinterNotifyInfoData
);

BOOL
RouterFreePrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo
);


PBIDI_RESPONSE_CONTAINER
RouterAllocBidiResponseContainer(
    DWORD Count
);

PVOID
RouterAllocBidiMem (
    IN size_t NumBytes
);

VOID
RouterFreeBidiMem (
    IN PVOID pMemPointer
);



#define PRINTER_NOTIFY_INFO_DATA_COMPACT 1

BOOL
AppendPrinterNotifyInfoData(
    PPRINTER_NOTIFY_INFO pInfoDest,
    PPRINTER_NOTIFY_INFO_DATA pInfoDataSrc,
    DWORD fdwFlags
);


DWORD
CallRouterFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PVOID pvReserved);

BOOL
ProvidorFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PVOID pvReserved0,
    PVOID pvReserved1);

BOOL
ProvidorFindClosePrinterChangeNotification(
    HANDLE hPrinter);



BOOL
SpoolerFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    PHANDLE phEvent,
    PVOID pPrinterNotifyOptions,
    PVOID pvReserved);

BOOL
SpoolerFindNextPrinterChangeNotification(
    HANDLE hPrinter,
    LPDWORD pfdwChange,
    PVOID pvReserved0,
    PVOID ppPrinterNotifyInfo);

VOID
SpoolerFreePrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo);

BOOL
SpoolerFindClosePrinterChangeNotification(
    HANDLE hPrinter);

LPMONITOR2
WINAPI
InitializePrintMonitor2(
    PMONITORINIT pMonitorInit,
    PHANDLE phMonitor
);

BOOL
WINAPI
InitializeMonitorEx(
    LPWSTR      pRegistryRoot,
    LPMONITOR   pMonitor
);

LPMONITOREX
WINAPI
InitializePrintMonitor(
    LPWSTR      pRegistryRoot
);

PMONITORUI
WINAPI
InitializePrintMonitorUI(
    VOID
);


//
//  The following is added for new point-and-print support which allows
//  specific files to be associated with a print queue (instead of a printer
//  driver) using SetPrinterDataEx under the key "CopyFiles"
//
#define COPYFILE_EVENT_SET_PRINTER_DATAEX           1
#define COPYFILE_EVENT_DELETE_PRINTER               2
#define COPYFILE_EVENT_ADD_PRINTER_CONNECTION       3
#define COPYFILE_EVENT_DELETE_PRINTER_CONNECTION    4
#define COPYFILE_EVENT_FILES_CHANGED                5


BOOL
WINAPI
SpoolerCopyFileEvent(
    LPWSTR  pszPrinterName,
    LPWSTR  pszKey,
    DWORD   dwCopyFileEvent
    );

#define COPYFILE_FLAG_CLIENT_SPOOLER            0x00000001
#define COPYFILE_FLAG_SERVER_SPOOLER            0x00000002


DWORD
WINAPI
GenerateCopyFilePaths(
    IN      LPCWSTR     pszPrinterName,
    IN      LPCWSTR     pszDirectory,
    IN      LPBYTE      pSplClientInfo,
    IN      DWORD       dwLevel,
    IN OUT  LPWSTR      pszSourceDir,
    IN OUT  LPDWORD     pcchSourceDirSize,
    IN OUT  LPWSTR      pszTargetDir,
    IN OUT  LPDWORD     pcchTargetDirSize,
    IN      DWORD       dwFlags
    );


typedef enum {
    kMessageBox = 0    
} UI_TYPE;

typedef struct {
    DWORD       cbSize;     // sizeof(MESSAGEBOX_PARAMS)
    LPWSTR      pTitle;     // Pointer to a null-terminated string for the title bar of the message box.
    LPWSTR      pMessage;   // Pointer to a null-terminated string containing the message to display. 	
    DWORD       Style;      // Specifies the contents and behavior of the message box
    DWORD       dwTimeout;  // If bWait is TRUE, Timeout specifies the time, in seconds, that the function waits for the user's response.
    BOOL        bWait;      // If TRUE, SplPromptUIInUsersSession does not return until the user responds or the time-out interval elapses. 
                            // If Timeout is zero, SplPromptUIInUsersSession doesn't return until the user responds. 
                            // If FALSE, the function returns immediately and pResponse returns IDASYNC. 
 
} MESSAGEBOX_PARAMS, *PMESSAGEBOX_PARAMS;

typedef struct {

    UI_TYPE  UIType;

    union {

        MESSAGEBOX_PARAMS   MessageBoxParams;
    };
	
} SHOWUIPARAMS, *PSHOWUIPARAMS;

BOOL
SplPromptUIInUsersSession(
    IN  HANDLE          hPrinter,
    IN  DWORD           JobId,
    IN  PSHOWUIPARAMS   pUIParams,
    OUT DWORD           *pResponse
);

DWORD
SplIsSessionZero(
    IN  HANDLE  hPrinter,
    IN  DWORD   JobId,
    OUT BOOL    *pIsSessionZero
);

#ifdef __cplusplus
}                   /* End of extern "C" { */
#endif              /* __cplusplus */

#endif // _WINSPLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\publish\printoem.h ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    printoem.h

Abstract:

    Declarations for Windows NT printer driver OEM plugins

--*/


#ifndef _PRINTOEM_
#define _PRINTOEM_

#ifdef __cplusplus
extern "C" {
#endif

//
// Current OEM plugin interface version number
//

#define PRINTER_OEMINTF_VERSION 0x00010000

#define OEM_MODE_PUBLISHER      0x00000001

typedef struct _PUBLISHERINFO {

    DWORD dwMode;           // flags for publisher
    WORD  wMinoutlinePPEM;  // min size to download as Type1
    WORD  wMaxbitmapPPEM;   // max size to download as Type3

} PUBLISHERINFO, *PPUBLISHERINFO;

#define OEMGI_GETSIGNATURE        1
#define OEMGI_GETINTERFACEVERSION 2
#define OEMGI_GETVERSION          3
#define OEMGI_GETPUBLISHERINFO    4

//
// OEMGetInfo
//
BOOL APIENTRY
OEMGetInfo(
    IN  DWORD  dwMode,
    OUT PVOID  pBuffer,
    IN  DWORD  cbSize,
    OUT PDWORD pcbNeeded
    );

BOOL APIENTRY
OEMDriverDMS(
    PVOID    pDevObj,
    PVOID    pBuffer,
    DWORD    cbSize,
    PDWORD   pcbNeeded
    );

//
// OEMDevMode
//

#define OEMDM_SIZE     1
#define OEMDM_DEFAULT  2
#define OEMDM_CONVERT  3
#define OEMDM_MERGE    4

typedef struct _OEMDMPARAM {

    DWORD    cbSize;        // size of OEM_DEVMODEPARAM
    PVOID    pdriverobj;    // reference to driver data structure
    HANDLE   hPrinter;      // PRINTER handle
    HANDLE   hModule;       // OEM module handle
    PDEVMODE pPublicDMIn;   // public devmode in
    PDEVMODE pPublicDMOut;  // public devmode out
    PVOID    pOEMDMIn;      // OEM private devmode in
    PVOID    pOEMDMOut;     // OEM private devmode out
    DWORD    cbBufSize;     // output size of pOEMDMOut buffer

} OEMDMPARAM, *POEMDMPARAM;

typedef struct _OEM_DMEXTRAHEADER {

    DWORD   dwSize;         // size of OEM extra data
    DWORD   dwSignature;    // Unique OEM signature
    DWORD   dwVersion;      // OEM DLL version number

} OEM_DMEXTRAHEADER, *POEM_DMEXTRAHEADER;

//
// USERDATA for OPTITEM.UserData
//

typedef struct _USERDATA {

    DWORD       dwSize;                 // Size of this structure
    ULONG_PTR    dwItemID;               // XXX_ITEM or pointer to FEATURE
    PSTR        pKeyWordName;           // Keyword name
    DWORD       dwReserved[8];
} USERDATA, *PUSERDATA;


BOOL APIENTRY
OEMDevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam
    );

//
// Callback function provided by the driver to
// allow OEM plugins access/set/update to driver private settings
//

typedef BOOL (APIENTRY *PFN_DrvGetDriverSetting)(
        PVOID   pdriverobj,
        PCSTR   Feature,
        PVOID   pOutput,
        DWORD   cbSize,
        PDWORD  pcbNeeded,
        PDWORD  pdwOptionsReturned
        );

//
// Callback function provided by the driver to
// allow OEM plugins upgrade private registry settings.
//

typedef BOOL (APIENTRY *PFN_DrvUpgradeRegistrySetting)(
        HANDLE   hPrinter,
        PCSTR    pFeature,
        PCSTR    pOption
        );

//
// Callback function provided by the driver UI to
// allow OEM plugins to update the driver UI settings and
// shows constraint. This function is called only when the UI is present.
//

typedef BOOL (APIENTRY *PFN_DrvUpdateUISetting)(
        PVOID    pdriverobj,
        PVOID    pOptItem,
        DWORD    dwPreviousSelection,
        DWORD    dwMode
        );



// Predefined feature indices used for accessing driver private settings

#define OEMGDS_MIN_DOCSTICKY        1
#define OEMGDS_PSDM_FLAGS           1       // DWORD - misc. flag bits
#define OEMGDS_PSDM_DIALECT         2       // INT - PS output option
#define OEMGDS_PSDM_TTDLFMT         3       // INT - TrueType font downloading option
#define OEMGDS_PSDM_NUP             4       // INT - N-up option
#define OEMGDS_PSDM_PSLEVEL         5       // INT - target language level
#define OEMGDS_PSDM_CUSTOMSIZE      6       // 5*DWORD - custom page size parameters

#define OEMGDS_UNIDM_GPDVER         0x4000  // WORD - GPD Version
#define OEMGDS_UNIDM_FLAGS          0x4001  // DWORD - misc flag bits

// Indices for private devmode fields - start at 0x4000

#define OEMGDS_MIN_PRINTERSTICKY    0x8000
#define OEMGDS_PRINTFLAGS           0x8000  // DWORD - misc. flag bits
#define OEMGDS_FREEMEM              0x8001  // DWORD - amount of VM, ps only
#define OEMGDS_JOBTIMEOUT           0x8002  // DWORD - job timeout, ps only
#define OEMGDS_WAITTIMEOUT          0x8003  // DWORD - wait timeout, ps only
#define OEMGDS_PROTOCOL             0x8004  // WORD - output protocol, ps only
#define OEMGDS_MINOUTLINE           0x8005  // WORD - min outline font size, ps only
#define OEMGDS_MAXBITMAP            0x8006  // WORD - max bitmap font size, ps only

#define OEMGDS_MAX                  0x10000


// dwType  flags for use with     STDMETHOD (DrvGetGPDData)
#define GPD_OEMCUSTOMDATA           1


/*******************************************************************************
 *
 * Definitions used by kernel-mode rendering module only:
 *  Make sure the macro KERNEL_MODE is defined and
 *  the header file winddi.h is included before this file.
 */

#ifdef KERNEL_MODE

//
// OEMEnableDriver
//

BOOL APIENTRY
OEMEnableDriver(
    DWORD           dwOemIntfVersion,
    DWORD           cbSize,
    PDRVENABLEDATA  pded
    );

typedef struct _DEVOBJ *PDEVOBJ;
typedef PVOID PDEVOEM;

typedef DWORD (APIENTRY *PFN_DrvWriteSpoolBuf)(
    PDEVOBJ pdevobj,
    PVOID   pBuffer,
    DWORD   cbSize
    );

typedef DWORD (APIENTRY *PFN_DrvWriteAbortBuf)(
    PDEVOBJ pdevobj,
    PVOID   pBuffer,
    DWORD   cbSize,
    DWORD       dwWait

    );

typedef INT (APIENTRY *PFN_DrvXMoveTo)(
    PDEVOBJ pdevobj,
    INT     x,
    DWORD   dwFlags
    );

typedef INT (APIENTRY *PFN_DrvYMoveTo)(
    PDEVOBJ pdevobj,
    INT     y,
    DWORD   dwFlags
    );

typedef BOOL (APIENTRY *PFN_DrvGetStandardVariable)(
    PDEVOBJ pdevobj,
    DWORD   dwIndex,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded
    );

typedef enum _STDVARIABLEINDEX{

        SVI_NUMDATABYTES,          // "NumOfDataBytes"
        SVI_WIDTHINBYTES,          // "RasterDataWidthInBytes"
        SVI_HEIGHTINPIXELS,        // "RasterDataHeightInPixels"
        SVI_COPIES,                // "NumOfCopies"
        SVI_PRINTDIRECTION,        // "PrintDirInCCDegrees"
        SVI_DESTX,                 // "DestX"
        SVI_DESTY,                 // "DestY"
        SVI_DESTXREL,              // "DestXRel"
        SVI_DESTYREL,              // "DestYRel"
        SVI_LINEFEEDSPACING,       // "LinefeedSpacing"
        SVI_RECTXSIZE,             // "RectXSize"
        SVI_RECTYSIZE,             // "RectYSize"
        SVI_GRAYPERCENT,           // "GrayPercentage"
        SVI_NEXTFONTID,            // "NextFontID"
        SVI_NEXTGLYPH,             // "NextGlyph"
        SVI_PHYSPAPERLENGTH,       // "PhysPaperLength"
        SVI_PHYSPAPERWIDTH,        // "PhysPaperWidth"
        SVI_FONTHEIGHT,            // "FontHeight"
        SVI_FONTWIDTH,             // "FontWidth"
        SVI_FONTMAXWIDTH,             // "FontMaxWidth"
        SVI_FONTBOLD,              // "FontBold"
        SVI_FONTITALIC,            // "FontItalic"
        SVI_FONTUNDERLINE,         // "FontUnderline"
        SVI_FONTSTRIKETHRU,        // "FontStrikeThru"
        SVI_CURRENTFONTID,         // "CurrentFontID"
        SVI_TEXTYRES,              // "TextYRes"
        SVI_TEXTXRES,              // "TextXRes"
// #ifdef  BETA2
        SVI_GRAPHICSYRES,              // "GraphicsYRes"
        SVI_GRAPHICSXRES,              // "GraphicsXRes"
// #endif
        SVI_ROP3,                  // "Rop3"
        SVI_REDVALUE,              // "RedValue"
        SVI_GREENVALUE,            // "GreenValue"
        SVI_BLUEVALUE,             // "BlueValue"
        SVI_PALETTEINDEXTOPROGRAM, // "PaletteIndexToProgram"
        SVI_CURRENTPALETTEINDEX,   // "CurrentPaletteIndex"
        SVI_PATTERNBRUSH_TYPE,     // "PatternBrushType"
        SVI_PATTERNBRUSH_ID,       // "PatternBrushID"
        SVI_PATTERNBRUSH_SIZE,     // "PatternBrushSize"
        SVI_CURSORORIGINX,           //  "CursorOriginX"
        SVI_CURSORORIGINY,           //  "CursorOriginY"
                //  this is in MasterUnits and in the coordinates of the currently selected orientation.
                //  this value is defined as ImageableOrigin - CursorOrigin
        SVI_PAGENUMBER,  //  "PageNumber"
                //  this value tracks number of times DrvStartBand has been called since
                //  StartDoc.

        SVI_MAX             //  Just a placeholder do not use.
}STDVARIABLEINDEX;

typedef BOOL (APIENTRY *PFN_DrvUnidriverTextOut)(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlBrushOrg,
    MIX         mix
    );

//
// bit fields defined for dwFlags
//
// Note:  The following Bit values are reserved for an internal use!
//  0x4000
//  0x8000
//
//
#define MV_UPDATE       0x0001
#define MV_RELATIVE     0x0002
#define MV_GRAPHICS     0x0004
#define MV_PHYSICAL     0x0008
#define MV_SENDXMOVECMD     0x0010
#define MV_SENDYMOVECMD     0x0020

typedef struct _DRVPROCS {

    PFN_DrvWriteSpoolBuf    DrvWriteSpoolBuf;   // common to both pscript and unidrv
    PFN_DrvXMoveTo          DrvXMoveTo;         // unidrv specific
    PFN_DrvYMoveTo          DrvYMoveTo;         // unidrv specific
    PFN_DrvGetDriverSetting DrvGetDriverSetting;// common to both pscript and unidrv
    PFN_DrvGetStandardVariable BGetStandardVariable; // unidrv specific
    PFN_DrvUnidriverTextOut    DrvUnidriverTextOut;  // unidrv specific
    PFN_DrvWriteAbortBuf    DrvWriteAbortBuf;   // unidrv specific

} DRVPROCS, *PDRVPROCS;

typedef struct _DEVOBJ {

    DWORD       dwSize;       // size of DEVOBJ structure
    PDEVOEM     pdevOEM;      // pointer to OEM's device data
    HANDLE      hEngine;      // GDI handle for current printer
    HANDLE      hPrinter;     // spooler handle for current printer
    HANDLE      hOEM;         // handle to OEM dll
    PDEVMODE    pPublicDM;    // public devmode
    PVOID       pOEMDM;       // OEM private devmode
    PDRVPROCS   pDrvProcs;    // pointer to kernel mode helper function table

} DEVOBJ;

//
// OEMDisableDriver
//

VOID APIENTRY
OEMDisableDriver(
    VOID
    );

//
// OEMEnablePDEV
//

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded
    );

//
// OEMDisablePDEV
//

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj
    );

//
// OEMResetPDEV
//

BOOL APIENTRY
OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    );

//
// OEMCommand - PSCRIPT only
//

DWORD APIENTRY
OEMCommand(
    PDEVOBJ pdevobj,
    DWORD   dwIndex,
    PVOID   pData,
    DWORD   cbSize
    );

INT APIENTRY
OEMCommandCallback(
    PDEVOBJ         pdevobj,
    DWORD           dwCallbackID,
    DWORD           dwCount,
    PDWORD          pdwParams
    );

//
// OEMImageProcessing - UNIDRV only
//

typedef struct {
    DWORD dwSize;
    POINT ptOffset;
    PSTR  pHalftoneOption;
    BOOL  bBanding;
    BOOL  bBlankBand;
} IPPARAMS, *PIPPARAMS;

PBYTE APIENTRY
OEMImageProcessing(
    PDEVOBJ     pdevobj,
    PBYTE       pSrcBitmap,
    PBITMAPINFOHEADER pBitmapInfoHeader,
    PBYTE       pColorTable,
    DWORD       dwCallbackID,
    PIPPARAMS   pIPParams
    );

//
// OEMFilterGraphics - UNIDRV only
//

BOOL APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE   pBuf,
    DWORD   dwLen
    );

//
// OEMCompression - UNIDRV only
//
INT APIENTRY
OEMCompression(
    PDEVOBJ pdevobj,
    PBYTE   pInBuf,
    PBYTE   pOutBuf,
    DWORD   dwInLen,
    DWORD   dwOutLen
    );

//
// OEMHalftone - UNIDRV only
//

BOOL APIENTRY
OEMHalftonePattern(
    PDEVOBJ pdevobj,
    PBYTE   pHTPattern,
    DWORD   dwHTPatternX,
    DWORD   dwHTPatternY,
    DWORD   dwHTNumPatterns,
    DWORD   dwCallbackID,
    PBYTE   pResource,
    DWORD   dwResourceSize
    );

//
// OEMMemoryUsage - UNIDRV only
//

typedef struct {
    DWORD   dwFixedMemoryUsage;
    DWORD   dwPercentMemoryUsage;
    DWORD   dwMaxBandSize;
} OEMMEMORYUSAGE, *POEMMEMORYUSAGE;

VOID APIENTRY
OEMMemoryUsage(
    PDEVOBJ pdevobj,
    POEMMEMORYUSAGE pMemoryUsage
    );

//
// OEMTTYGetInfo - UNIDRV only
//
INT APIENTRY
OEMTTYGetInfo(
    PDEVOBJ pdevobj,
    DWORD   dwInfoIndex,
    PVOID   pOutputBuf,
    DWORD   dwSize,
    DWORD   *pcbcNeeded
    );

#define OEMTTY_INFO_MARGINS     1
#define OEMTTY_INFO_CODEPAGE    2
#define OEMTTY_INFO_NUM_UFMS    3
#define OEMTTY_INFO_UFM_IDS     4

//
// UNIDRV font callback
//

typedef BOOL (*PFNGETINFO)(struct _UNIFONTOBJ*, DWORD, PVOID, DWORD, PDWORD);

typedef struct _UNIFONTOBJ {
    ULONG       ulFontID;
    DWORD       dwFlags;     // General flags
    IFIMETRICS *pIFIMetrics; // Pointer to IFIMETRICS
    PFNGETINFO  pfnGetInfo;  // Pointer to UNIFONTOBJ_GetInfo callback
} UNIFONTOBJ, *PUNIFONTOBJ;

//
// UNIFONTOBJ.dwFlags
//

#define UFOFLAG_TTFONT               0x00000001
#define UFOFLAG_TTDOWNLOAD_BITMAP    0x00000002
#define UFOFLAG_TTDOWNLOAD_TTOUTLINE 0x00000004
#define UFOFLAG_TTOUTLINE_BOLD_SIM   0x00000008
#define UFOFLAG_TTOUTLINE_ITALIC_SIM 0x00000010
#define UFOFLAG_TTOUTLINE_VERTICAL   0x00000020
#define UFOFLAG_TTSUBSTITUTED        0x00000040

//
// UNIFONTOBJ callback ID
//

#define UFO_GETINFO_FONTOBJ     1
#define UFO_GETINFO_GLYPHSTRING 2
#define UFO_GETINFO_GLYPHBITMAP 3
#define UFO_GETINFO_GLYPHWIDTH  4
#define UFO_GETINFO_MEMORY      5
#define UFO_GETINFO_STDVARIABLE 6

//
// UFO_GETINFO_FONTOBJ callback structure
//

typedef struct _GETINFO_FONTOBJ {
    DWORD    dwSize;   // Size of this structure
    FONTOBJ *pFontObj; // Pointer to the FONTOBJ
} GETINFO_FONTOBJ, *PGETINFO_FONTOBJ;

//
// UFO_GETINFO_FONTOBJ callback structure
//

typedef struct _GETINFO_GLYPHSTRING {
    DWORD dwSize;    // Size of this structure
    DWORD dwCount;   // Count of glyphs in pGlyphIn
    DWORD dwTypeIn;  // Glyph type of pGlyphIn, TYPE_GLYPHID/TYPE_HANDLE.
    PVOID pGlyphIn;  // Pointer to the input glyph string
    DWORD dwTypeOut; // Glyph type of pGlyphOut, TYPE_UNICODE/TYPE_TRANSDATA.
    PVOID pGlyphOut; // Pointer to the output glyph string
    DWORD dwGlyphOutSize; // The size of pGlyphOut buffer
} GETINFO_GLYPHSTRING, *PGETINFO_GLYPHSTRING;

//
// UFO_GETINFO_GLYPHBITMAP
//

typedef struct _GETINFO_GLYPHBITMAP {
    DWORD       dwSize;    // Size of this structure
    HGLYPH      hGlyph;    // Glyph hangle passed in OEMDownloadCharGlyph
    GLYPHDATA *pGlyphData; // Pointer to the GLYPHDATA data structure
} GETINFO_GLYPHBITMAP, *PGETINFO_GLYPHBITMAP;

//
// UFO_GETINFO_GLYPHWIDTH
//

typedef struct _GETINFO_GLYPHWIDTH {
    DWORD dwSize;  // Size of this structure
    DWORD dwType;  // Type of glyph stirng in pGlyph, TYPE_GLYPHHANDLE/GLYPHID.
    DWORD dwCount; // Count of glyph in pGlyph
    PVOID pGlyph;  // Pointer to a glyph string
    PLONG plWidth; // Pointer to the buffer of width table.
                   // Minidriver has to prepare this.
} GETINFO_GLYPHWIDTH, *PGETINFO_GLYPHWIDTH;

//
// UFO_GETINFO_MEMORY
//

typedef struct _GETINFO_MEMORY {
    DWORD dwSize;
    DWORD dwRemainingMemory;
} GETINFO_MEMORY, PGETINFO_MEMROY;

//
// UFO_GETINFO_STDVARIABLE
//
// OEM DLL has to prepare all StdVar buffer and set ID in dwStdVarID.
//

typedef struct _GETINFO_STDVAR {
    DWORD dwSize;
    DWORD dwNumOfVariable;
    struct {
        DWORD dwStdVarID;
        LONG  lStdVariable;
    } StdVar[1];
} GETINFO_STDVAR, *PGETINFO_STDVAR;


#define FNT_INFO_PRINTDIRINCCDEGREES  0 // PrintDirInCCDegrees
#define FNT_INFO_GRAYPERCENTAGE       1 // GrayPercentage
#define FNT_INFO_NEXTFONTID           2 // NextfontID
#define FNT_INFO_NEXTGLYPH            3 // NextGlyph
#define FNT_INFO_FONTHEIGHT           4 // FontHeight
#define FNT_INFO_FONTWIDTH            5 // FontWidth
#define FNT_INFO_FONTBOLD             6 // FontBold
#define FNT_INFO_FONTITALIC           7 // FontItalic
#define FNT_INFO_FONTUNDERLINE        8 // FontUnderline
#define FNT_INFO_FONTSTRIKETHRU       9 // FontStrikeThru
#define FNT_INFO_CURRENTFONTID       10 // Current
#define FNT_INFO_TEXTYRES            11 // TextYRes
#define FNT_INFO_TEXTXRES            12 // TextXRes
#define FNT_INFO_FONTMAXWIDTH        13 // FontMaxWidth
#define FNT_INFO_MAX                 14

//
// OEMDownloadFontheader - UNIDRV only
//

DWORD APIENTRY
OEMDownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    );

//
// OEMDownloadCharGlyph - UNIDRV only
//

DWORD APIENTRY
OEMDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth
    );

//
// OEMTTDownloadMethod - UNIDRV only
//

DWORD APIENTRY
OEMTTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    );

#define TTDOWNLOAD_DONTCARE  0
#define TTDOWNLOAD_GRAPHICS  1
#define TTDOWNLOAD_BITMAP    2
#define TTDOWNLOAD_TTOUTLINE 3

//
// OEMOutputCharStr - UNIDRV only
//

VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph
    );

#define TYPE_UNICODE      1
#define TYPE_TRANSDATA    2
#define TYPE_GLYPHHANDLE  3
#define TYPE_GLYPHID      4

//
// OEMSendFontCmd - UNIDRV only
//

typedef struct _FINVOCATION {
    DWORD dwCount;    // Size of command
    PBYTE pubCommand; // Pointer to font selection command
} FINVOCATION, *PFINVOCATION;

VOID APIENTRY
OEMSendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv
    );

//
// OEMTextOutAsBitmap - UNIDRV only
//
BOOL APIENTRY
OEMTextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

//
// OEMBitBlt
//

BOOL APIENTRY
OEMBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    );

//
// OEMStretchBlt
//

BOOL APIENTRY
OEMStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    );

//
// OEMCopyBits
//

BOOL APIENTRY
OEMCopyBits(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    );

//
// OEMTextOut
//

BOOL APIENTRY
OEMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

//
// OEMStrokePath
//

BOOL APIENTRY
OEMStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    );

//
// OEMFillPath
//

BOOL APIENTRY
OEMFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    );

//
// OEMStrokeAndFillPath
//

BOOL APIENTRY
OEMStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    );

//
// OEMRealizeBrush
//

BOOL APIENTRY
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    );

//
// OEMStartPage
//

BOOL APIENTRY
OEMStartPage(
    SURFOBJ    *pso
    );

//
// OEMSendPage
//

BOOL APIENTRY
OEMSendPage(
    SURFOBJ    *pso
    );

//
// OEMEscape
//

ULONG APIENTRY
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

//
// OEMStartDoc
//

BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    );

//
// OEMEndDoc
//

BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl
    );

//
// OEMQueryFont
//

PIFIMETRICS APIENTRY
OEMQueryFont(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG_PTR   *pid
    );

//
// OEMQueryFontTree
//

PVOID APIENTRY
OEMQueryFontTree(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR   *pid
    );

//
// OEMQueryFontData
//

LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

//
// OEMQueryAdvanceWidths
//

BOOL APIENTRY
OEMQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    );

//
// OEMFontManagement
//

ULONG APIENTRY
OEMFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

//
// OEMGetGlyphMode
//

ULONG APIENTRY
OEMGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    );

BOOL APIENTRY
OEMNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    );

BOOL APIENTRY
OEMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    );

ULONG APIENTRY
OEMDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    );

BOOL APIENTRY
OEMPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    );

BOOL APIENTRY
OEMLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    );

#ifndef WINNT_40

//
// OEMStretchBltROP
//

BOOL APIENTRY
OEMStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4
    );

//
// OEMPlgBlt
//

BOOL APIENTRY
OEMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode
    );

//
// OEMAlphaBlend
//

BOOL APIENTRY
OEMAlphaBlend(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj
    );

//
// OEMGradientFill
//

BOOL APIENTRY
OEMGradientFill(
    SURFOBJ    *psoDest,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode
    );

//
// OEMIcmCreateTransform
//

HANDLE APIENTRY
OEMIcmCreateColorTransform(
    DHPDEV           dhpdev,
    LPLOGCOLORSPACEW pLogColorSpace,
    PVOID            pvSourceProfile,
    ULONG            cjSourceProfile,
    PVOID            pvDestProfile,
    ULONG            cjDestProfile,
    PVOID            pvTargetProfile,
    ULONG            cjTargetProfile,
    DWORD            dwReserved
    );

//
// OEMIcmDeleteTransform
//

BOOL APIENTRY
OEMIcmDeleteColorTransform(
    DHPDEV dhpdev,
    HANDLE hcmXform
    );

//
// OEMQueryDeviceSupport
//

BOOL APIENTRY
OEMQueryDeviceSupport(
    SURFOBJ    *pso,
    XLATEOBJ   *pxlo,
    XFORMOBJ   *pxo,
    ULONG      iType,
    ULONG      cjIn,
    PVOID      pvIn,
    ULONG      cjOut,
    PVOID      pvOut
    );

//
// OEMTransparentBlt
//

BOOL APIENTRY
OEMTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved
    );

#endif // !WINNT_40

//
// Function prototype define's for the driver hooks.
//
// NOTE: These are only needed for NT4. For NT5, they are defined in winddi.h.
//

#ifdef WINNT_40

typedef BOOL (APIENTRY  *LPFNDLLINITIALIZE)(
    ULONG           ulReason
    );

typedef BOOL (APIENTRY *PFN_DrvBitBlt)(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    );

typedef BOOL (APIENTRY *PFN_DrvStretchBlt)(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    );

typedef BOOL (APIENTRY *PFN_DrvCopyBits)(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    );

typedef BOOL (APIENTRY *PFN_DrvTextOut)(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

typedef BOOL (APIENTRY *PFN_DrvStrokePath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    );

typedef BOOL (APIENTRY *PFN_DrvFillPath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    );

typedef BOOL (APIENTRY *PFN_DrvStrokeAndFillPath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    );

typedef BOOL (APIENTRY *PFN_DrvRealizeBrush)(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    );

typedef BOOL (APIENTRY *PFN_DrvStartPage)(
    SURFOBJ    *pso
    );

typedef BOOL (APIENTRY *PFN_DrvSendPage)(
    SURFOBJ    *pso
    );

typedef ULONG (APIENTRY *PFN_DrvEscape)(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

typedef BOOL (APIENTRY *PFN_DrvStartDoc)(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    );

typedef BOOL (APIENTRY *PFN_DrvEndDoc)(
    SURFOBJ    *pso,
    FLONG       fl
    );

typedef PIFIMETRICS (APIENTRY *PFN_DrvQueryFont)(
    DHPDEV      dhpdev,
    ULONG_PTR    iFile,
    ULONG       iFace,
    ULONG_PTR   *pid
    );

typedef PVOID (APIENTRY *PFN_DrvQueryFontTree)(
    DHPDEV      dhpdev,
    ULONG_PTR    iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR   *pid
    );

typedef LONG (APIENTRY *PFN_DrvQueryFontData)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

typedef BOOL (APIENTRY *PFN_DrvQueryAdvanceWidths)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    );

typedef ULONG (APIENTRY *PFN_DrvFontManagement)(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

typedef ULONG (APIENTRY *PFN_DrvGetGlyphMode)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    );

typedef BOOL (APIENTRY *PFN_DrvNextBand)(
    SURFOBJ *pso,
    POINTL *pptl
    );

typedef BOOL (APIENTRY *PFN_DrvStartBanding)(
    SURFOBJ *pso,
    POINTL *pptl
    );

typedef ULONG (APIENTRY *PFN_DrvDitherColor)(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    );

typedef BOOL (APIENTRY *PFN_DrvPaint)(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    );

typedef BOOL (APIENTRY *PFN_DrvLineTo)(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    );

#endif // WINNT_40

//
// for the IPrintOemPS2::GetPDEVAdjustment call
//
#define PDEV_ADJUST_PAPER_MARGIN_TYPE 1

typedef struct _PDEV_ADJUST_PAPER_MARGIN {

    RECTL   rcImageableArea;    // contains the imageable area in 0.001 mm units

} PDEV_ADJUST_PAPER_MARGIN;

#define PDEV_HOSTFONT_ENABLED_TYPE 2

typedef struct _PDEV_HOSTFONT_ENABLED {

    BOOL bHostfontEnabled;

} PDEV_HOSTFONT_ENABLED;

#define PDEV_USE_TRUE_COLOR_TYPE 3

typedef struct _PDEV_USE_TRUE_COLOR {

    BOOL bUseTrueColor;

} PDEV_USE_TRUE_COLOR;

#endif // KERNEL_MODE


/*******************************************************************************
 *
 * Definitions used by user-mode UI module only:
 *  Make sure the macro KERNEL_MODE is NOT defined and
 *  the header file winddiui.h is included before this file.
 *
 */

#ifndef KERNEL_MODE

//
// Reports capability of simulated features
//
typedef struct _SIMULATE_CAPS_1 {
    DWORD     dwLevel;
    DWORD     dwPageOrderFlags;         // Reverse page order
    DWORD     dwNumberOfCopies;         // Max number of copies
    DWORD     dwCollate;                // Collate support
    DWORD     dwNupOptions;             // The (1-base) bit set represents the N-up option available.
                                        // 0x0001 means 1-up
                                        // 0x0002 means 2-up
                                        // 0x0008 means 4-up
                                        // 0x812B means (1,2,4,6,9,16)
} SIMULATE_CAPS_1, *PSIMULATE_CAPS_1;

//
// Reference to driver data structure. This is passed to
// most of the OEM UI DLL entrypoints.
//

typedef struct _OEMUIPROCS {

    PFN_DrvGetDriverSetting DrvGetDriverSetting;
    PFN_DrvUpdateUISetting  DrvUpdateUISetting;

} OEMUIPROCS, *POEMUIPROCS;

typedef struct _OEMUIOBJ {

    DWORD       cbSize;             // size of this structure
    POEMUIPROCS pOemUIProcs;        // pointer to user mode helper function table

} OEMUIOBJ, *POEMUIOBJ;


//
// OEMCommonUIProp
//

typedef struct _OEMCUIPPARAM *POEMCUIPPARAM;
typedef LONG (APIENTRY *OEMCUIPCALLBACK)(PCPSUICBPARAM, POEMCUIPPARAM);

typedef struct _OEMCUIPPARAM {

    DWORD           cbSize;         // size of this structure
    POEMUIOBJ       poemuiobj;      // reference to driver data structure
    HANDLE          hPrinter;       // handle to the current printer
    PWSTR           pPrinterName;   // name of current printer
    HANDLE          hModule;        // instance handle to OEM DLL
    HANDLE          hOEMHeap;       // handle to the OEM memory heap
    PDEVMODE        pPublicDM;      // public devmode
    PVOID           pOEMDM;         // OEM private devmode
    DWORD           dwFlags;        // misc. flag bits
    POPTITEM        pDrvOptItems;   // pointer to driver items
    DWORD           cDrvOptItems;   // number of driver items
    POPTITEM        pOEMOptItems;   // pointer to OEM items
    DWORD           cOEMOptItems;   // number of OEM items
    PVOID           pOEMUserData;   // pointer to OEM private data
    OEMCUIPCALLBACK  OEMCUIPCallback; // address of callback function

} OEMCUIPPARAM;

BOOL APIENTRY
OEMCommonUIProp(
    DWORD           dwMode,
    POEMCUIPPARAM   pOemCUIPParam
    );

//
// OEMCommonUIProp dwMode parameter value
//
#define OEMCUIP_DOCPROP       1
#define OEMCUIP_PRNPROP       2

//
// OEMDocumentPropertySheets
//

LRESULT APIENTRY
OEMDocumentPropertySheets(
    PPROPSHEETUI_INFO pPSUIInfo,
    LPARAM            lParam
    );

//
// OEMDevicePropertySheets
//

LRESULT APIENTRY
OEMDevicePropertySheets(
    PPROPSHEETUI_INFO pPSUIInfo,
    LPARAM            lParam
    );

//
// pPSUIInfo->lParamInit is a pointer to _OEMUIPSPARAM structure defined below.
//
typedef struct _OEMUIPSPARAM {

    DWORD           cbSize;         // size of this structure
    POEMUIOBJ       poemuiobj;      // reference to driver data structure
    HANDLE          hPrinter;       // handle to the current printer
    PWSTR           pPrinterName;   // name of current printer
    HANDLE          hModule;        // instance handle to OEM DLL
    HANDLE          hOEMHeap;       // handle to the OEM memory heap
    PDEVMODE        pPublicDM;      // public devmode
    PVOID           pOEMDM;         // OEM private devmode
    PVOID           pOEMUserData;   // pointer to OEM private data
    DWORD           dwFlags;        // misc. flag bits
    PVOID           pOemEntry;

} OEMUIPSPARAM, *POEMUIPSPARAM;

//
// OEMDevQueryPrintEx
//

BOOL APIENTRY
OEMDevQueryPrintEx(
    POEMUIOBJ           poemuiobj,
    PDEVQUERYPRINT_INFO pDQPInfo,
    PDEVMODE            pPublicDM,
    PVOID               pOEMDM
    );

//
// OEMDeviceCapabilities
//

DWORD APIENTRY
OEMDeviceCapabilities(
    POEMUIOBJ   poemuiobj,
    HANDLE      hPrinter,
    PWSTR       pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    PDEVMODE    pPublicDM,
    PVOID       pOEMDM,
    DWORD       dwLastResult
    );

//
// OEMUpgradePrinter
//

BOOL APIENTRY
OEMUpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo
    );

//
// OEMUpgradeRegistry
//

BOOL APIENTRY
OEMUpgradeRegistry(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo,
    PFN_DrvUpgradeRegistrySetting pfnUpgrade
    );


//
// OEMPrinterEvent
//

BOOL APIENTRY
OEMPrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam
    );

//
// OEMDriverEvent
//

BOOL APIENTRY
OEMPDriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam
    );


//
// OEMQueryColorProfile
//

BOOL APIENTRY
OEMQueryColorProfile(
    HANDLE      hPrinter,
    POEMUIOBJ   poemuiobj,
    PDEVMODE    pPublicDM,
    PVOID       pOEMDM,
    ULONG       ulQueryMode,
    VOID       *pvProfileData,
    ULONG      *pcbProfileData,
    FLONG      *pflProfileData
    );

//
// Font Installer dialog proc
//

INT_PTR CALLBACK
OEMFontInstallerDlgProc(
    HWND    hWnd,
    UINT    usMsg,
    WPARAM  wParam,
    LPARAM  lParam
    );


BOOL CALLBACK
OEMUpdateExternalFonts(
    HANDLE  hPrinter,
    HANDLE  hHeap,
    PWSTR   pwstrCartridges
   );


#endif // !KERNEL_MODE

//
// Datatypes for attributes plugin can get by calling core driver's
// following helper functions:
//
// GetGlobalAttribute, GetFeatureAttribute, GetOptionAttribute
//

typedef enum _EATTRIBUTE_DATATYPE {

    kADT_UNKNOWN,
    kADT_BOOL,
    kADT_INT,
    kADT_LONG,
    kADT_DWORD,
    kADT_ASCII,              // NULL terminated ASCII string
    kADT_UNICODE,            // NULL terminated Unicode string
    kADT_BINARY,             // binary blob
    kADT_SIZE,
    kADT_RECT,
    kADT_CUSTOMSIZEPARAMS,   // array of CUSTOMSIZEPARAM structures

} EATTRIBUTE_DATATYPE;

//
// Data structure for storing information about PPD's *ParamCustomPageSize entries
//

#define CUSTOMPARAM_WIDTH        0
#define CUSTOMPARAM_HEIGHT       1
#define CUSTOMPARAM_WIDTHOFFSET  2
#define CUSTOMPARAM_HEIGHTOFFSET 3
#define CUSTOMPARAM_ORIENTATION  4
#define CUSTOMPARAM_MAX          5

typedef struct _CUSTOMSIZEPARAM {

    LONG    dwOrder;                // order value
    LONG    lMinVal;                // min value (in microns)
    LONG    lMaxVal;                // max value (in microns)

} CUSTOMSIZEPARAM, *PCUSTOMSIZEPARAM;

//
// constants for SetOptions helper function
//
// SetOptions flag
//

#define SETOPTIONS_FLAG_RESOLVE_CONFLICT       0x00000001
#define SETOPTIONS_FLAG_KEEP_CONFLICT          0x00000002

//
// SetOptions result code
//

#define SETOPTIONS_RESULT_NO_CONFLICT          0
#define SETOPTIONS_RESULT_CONFLICT_RESOLVED    1
#define SETOPTIONS_RESULT_CONFLICT_REMAINED    2

#ifdef __cplusplus
}
#endif

#endif  // !_PRINTOEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uienv.inc ===
##########################################################################
#
#   Microsoft Confidential
#   Copyright (C) Microsoft Corporation 1997-1999
#   All Rights Reserved.
#
##########################################################################

#
# Common include file 'sources' files in the imagein project.
#
#
# These definitions are required in your sources file:
#
#     FREEBUILD
#        Set by makefile.def file for you.  One of the following:
#          0      - build debug
#          1      - build retail
#
# Definitions used if defined:
#
#     CHICAGO_PRODUCT
#        Build component explicitly for the Win95 platform.  If this is
#        not defined, default is NT or both.
#
#     TARGET_BOTH
#        Build component to run on both platforms.
#
#     NO_PRIVATE_HEADERS
#        If set to 1, this is defined as a manifest constant, so the
#        stub headers in shell\inc\stubs do not include the private
#        companion headers.
#
# Environment Variables and their meanings
#
#     ATL_DEBUG_QI
#        When set to 1, debug builds will also have _ATL_DEBUG_QI
#        defined.  ATL code spews a bunch of debug stuff during QueryInterface.
#
#     ATL_DEBUG_REFCOUNT
#        When set to 1, debug builds will also have _ATL_DEBUG_REFCOUNT
#        defined.  ATL code spews a bunch of debug stuff during AddRef
#        and Release.
#
#     MAXDEBUG
#        If set to 1, then debug builds will also have MAXDEBUG defined.
#        Retail builds unaffected.  This is highly encouraged for regular
#        development purposes.  Not to be set or used by the build labs.
#
#     MEASURE_PERF
#        If set to 1, enables performance timing code for both debug and
#        retail builds.  This code squirts the timings for interesting
#        events to the debug terminal.
#

#
# As this include file is used only for user mode windows components - set
# components IDs appropriately
#
MAJORCOMP=printscan
MINORCOMP=ui



#
# Set imagedir placement correctly
#
WIA_DIR = $(PROJECT_ROOT)\wia
UI_DIR  = $(PROJECT_ROOT)\ui

!IF "$(BUILD_PRODUCT)"=="millen"
CHICAGO_PRODUCT=1
!ENDIF

#
# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
#
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

#
# Necessary for gdiplus
#
C_DEFINES=$(C_DEFINES) \
    -DDCR_USE_NEW_105760 \
    -DDCR_USE_NEW_125467 \
    -DDCR_USE_NEW_127084 \
    -DDCR_USE_NEW_135429 \
    -DDCR_USE_NEW_137252 \
    -DDCR_USE_NEW_140782 \
    -DDCR_USE_NEW_140855 \
    -DDCR_USE_NEW_140857 \
    -DDCR_USE_NEW_140861 \
    -DDCR_USE_NEW_145135 \
    -DDCR_USE_NEW_145138 \
    -DDCR_USE_NEW_145139 \
    -DDCR_USE_NEW_145804 \
    -DDCR_USE_NEW_146933 \
    -DDCR_USE_NEW_152154 \
    -DDCR_USE_NEW_168772 \
    -DDCR_USE_NEW_174340 \
    -DDCR_USE_NEW_175866 \
    -DDCR_USE_NEW_186091 \
    -DDCR_USE_NEW_186151 \
    -DDCR_USE_NEW_186764 \
    -DDCR_USE_NEW_188922 \
    -DDCR_USE_NEW_197819 \
    -DDCR_USE_NEW_202903 \
    -DDCR_USE_NEW_235072 \
    -DDCR_USE_NEW_250932 \
    -DDCR_USE_NEW_284635 \
    -DDCR_USE_NEW_284841 \
    -DDCR_USE_NEW_293849 \
    -DDCR_USE_NEW_299162


#
# Pick up the latest common controls
#
C_DEFINES=$(C_DEFINES) -DUXCTRL_VERSION=0x0100

#
# Set private paths
#
INCLUDES        = .;..;\
    $(SDK_INC_PATH);\
    $(BASEDIR)\published\sdk\inc;\
    $(PROJECT_ROOT)\publish\inc;\
    $(PROJECT_ROOT)\inc;\
    $(WIA_DIR)\inc;\
    $(UI_DIR)\inc;\
    $(BASEDIR)\public\internal\shell\inc;\
    $(UI_DIR)\uicommon;\
    $(SDK_INC_PATH)\gdiplus;\
    $(PROJECT_ROOT)\inc\psutil; \
    $(WINDOWS_INC_PATH)\DUser;\
    $(INCLUDES)

#
# Set platform dependent settings
#
#  PLATFORM_SUFFIX is used for generating platform specific static libs path , a la public\sdk\lib\win98
#
!if !defined(CHICAGO_PRODUCT)

#
# Require v500 to use NT5 specific APIs
#

WIN32_WINNT_VERSION=$(LATEST_WIN32_WINNT_VERSION)

LIBRARY_PLATFORM_PATH   = $(BASEDIR)\public\sdk\lib

PLATFORM_SUFFIX=.

USE_MSVCRT=1

!else

NOT_UNICODE =1

# (use 'chicago' since that is already used in the NT tree)

LIBRARY_PLATFORM_PATH   = $(BASEDIR)\published\sdk\lib\chicago
ALT_PROJECT_TARGET      = chicago
USE_MAPSYM              = 1

# Where to put static libraries
PLATFORM_SUFFIX=chicago

#
# Cheat on version for Millenium
#
WIN32_WIN95_VERSION=0x500


#
# VC5 libs not shipped yet
#
USE_MSVCRT=1
#USE_MSVCRT40=1
#USE_LIBCMT=1

#
# Indicate target is not supporting robust RPC validation
#
MIDL_NO_ROBUST=1

#
# Indicate we fully support DCOM
#
C_DEFINES       = $(C_DEFINES) -D_WIN32_DCOM
##-D_WIN32_WINDOWS

#
!endif

#
# Include and lib directories private to the PrintScan project
#

PRV_INC_PATH=$(PROJECT_ROOT)\inc
!if $(386)
PRV_LIB_PATH=$(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\i386
!elseif $(IA64)
PRV_LIB_PATH=$(PROJECT_ROOT)\lib\ia64
!elseif $(AXP64)
PRV_LIB_PATH=$(PROJECT_ROOT)\lib\axp64
!elseif $(ALPHA)
PRV_LIB_PATH=$(PROJECT_ROOT)\lib\alpha
!endif

#
# Set common options
#

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1


# user mode executable type
UMTYPE          = windows

# Don't link to NTDLL if this runs on both platforms
!ifdef TARGET_BOTH
NO_NTDLL=1
!endif

#
# Additional compiler flags
#

C_DEFINES       = $(C_DEFINES) -DWIN32 -D_WIN32 -D_NTSDK

!ifdef USE_ICECAP
C_DEFINES = $(C_DEFINES) -DPRODUCT_PROF
!endif

!if !defined(CHICAGO_PRODUCT )

C_DEFINES       = $(C_DEFINES) -DNT -DWINNT

! if !defined(NOT_UNICODE)
UNICODE=1
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
! endif

!else

UNICODE=0

C_DEFINES       = $(C_DEFINES) -DWIN9X

!endif


# ------ Debug Only Defines --------


#
# make us completely self contained
#
COFFBASE_TXT_FILE=$(UI_DIR)\coffbase.txt
BINPLACE_PLACEFILE=$(UI_DIR)\placefil.txt


#
# Commonly used libraries
#
!if !defined(DONT_DO_COMMON_LIBS)
!if !defined(CHICAGO_PRODUCT)
TARGETLIBS=$(TARGETLIBS)\
        $(LIBRARY_PATH)\advapi32.lib                                \
        $(LIBRARY_PATH)\cfgmgr32.lib                                \
        $(LIBRARY_PATH)\gdi32.lib                                   \
        $(LIBRARY_PATH)\gdiplus.lib                                 \
        $(LIBRARY_PATH)\kernel32.lib                                \
        $(LIBRARY_PATH)\msimg32.lib                                 \
        $(LIBRARY_PATH)\msvcrt.lib                                  \
        $(LIBRARY_PATH)\ole32.lib                                   \
        $(LIBRARY_PATH)\oleaut32.lib                                \
        $(LIBRARY_PATH)\rpcndr.lib                                  \
        $(LIBRARY_PATH)\rpcns4.lib                                  \
        $(LIBRARY_PATH)\rpcrt4.lib                                  \
        $(LIBRARY_PATH)\setupapi.lib                                \
        $(LIBRARY_PATH)\shell32.lib                                 \
        $(LIBRARY_PATH)\shlwapi.lib                                 \
        $(LIBRARY_PATH)\sti.lib                                     \
        $(LIBRARY_PATH)\user32.lib                                  \
        $(LIBRARY_PATH)\uuid.lib                                    \
        $(LIBRARY_PATH)\winmm.lib                                   \
        $(SHELL_LIB_PATH)\shell32p.lib                              \
        $(SHELL_LIB_PATH)\shlwapip.lib                              \
        $(BASEDIR)\public\sdk\lib\$(PLATFORM_SUFFIX)\*\wiaguid.lib  \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\psutil.lib         \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\*\uicommon.lib

# people who use shfusion cannot link to comdlg32
!if !defined(USE_SHFUSION)
TARGETLIBS=$(TARGETLIBS)\
        $(LIBRARY_PATH)\comdlg32.lib
!endif

!else
TARGETLIBS=$(TARGETLIBS)\
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\cfgmgr32.lib  \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\setupapi.lib  \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\iprop.lib     \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\psutil.lib         \
        $(LIBRARY_PLATFORM_PATH)\*\ADVAPI32.lib \
        $(LIBRARY_PLATFORM_PATH)\*\KERNEL32.lib \
        $(LIBRARY_PLATFORM_PATH)\*\user32.lib   \
        $(LIBRARY_PATH)\GDI32.lib     \
        $(LIBRARY_PATH)\oleaut32.lib  \
        $(LIBRARY_PATH)\shlwapi.lib   \
        $(LIBRARY_PATH)\ole32.lib     \
        $(LIBRARY_PATH)\rpcndr.lib    \
        $(LIBRARY_PATH)\rpcns4.lib    \
        $(LIBRARY_PATH)\rpcrt4.lib    \
        $(LIBRARY_PATH)\uuid.lib
!endif
!endif

#
# Skip these files when determining dependencies
#
CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
                  atlbase.h  \
                  atlcom.h   \
                  atlconv.h  \
                  atlctl.h   \
                  atlctl.cpp \
                  atliface.h \
                  atlimpl.cpp \
                  atlwin.h   \
                  atlwin.cpp \
                  ia64inst.h \
                  macapi.h   \
                  macname1.h \
                  macname2.h \
                  macocidl.h \
                  macpub.h   \
                  macwin32.h \
                  mainwin.h  \
                  mwversion.h \
                  penwin.h \
                  pshpck16.h \
                  rpcerr.h   \
                  rpcmac.h   \
                  setupx.h   \
                  skbapi.h   \
                  statreg.h  \
                  statreg.cpp \
                  unixstuff.h \
                  version.h  \
                  winwlm.h   \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\annotlib\makefile.inc ===
$(PROJECT_INC_PATH)\annotlib.h : annot.h
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\annotlib\annot.h ===
#ifndef _ANNOT_H_
#define _ANNOT_H_

#include <windows.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <gdiplus.h>
using namespace Gdiplus;
#include <shimgdata.h>
// This file defines classes used to render and edit TIFF 6.0 annotations.
// These annotations are stored in tag #32932. The specification for these annotations
// is defined by Eastman Software, the spec version is 1.00.06.

#define ANNOTATION_IMAGE_TAG 32932

// These structures define the in-file layout of the annotations.
// Note that most of the structs are variable-sized.
// The annotation parser reads the annotations into these structures, wraps them in a descriptor
// and passes the descriptor to the annotation factory object to construct
// CAnnotationMark-derived classes that implement
// the rendering, editing, and saving of the different types of marks.

// MT_* used in ANNOTATIONMARK::uType
#define MT_IMAGEEMBED         1
#define MT_IMAGEREF           2
#define MT_STRAIGHTLINE       3
#define MT_FREEHANDLINE       4
#define MT_HOLLOWRECT         5
#define MT_FILLRECT           6
#define MT_TYPEDTEXT          7
#define MT_FILETEXT           8
#define MT_STAMP              9
#define MT_ATTACHANOTE       10
#define MT_FORM              11
#define MT_OCR               12 // unsupported

// ANNOTATIONMARK is fixed size and exists for every mark in the file
// We only support files with 4 byte integers
// this struct is not declared as UNALIGNED because we never typecast a variable
// as this type.
struct ANNOTATIONMARK
{
    UINT uType;                 /* The type of the mark (or operation).
                                    This will be ignored for sets.*/
    RECT lrBounds;             /* Rect in FULLSIZE units.
                                    This could be a rect or 2 points.*/
    RGBQUAD rgbColor1;          /* This is the main color. (Example: This is the
                                    color of all lines, rects, and stand alone
                                    text.*/
    RGBQUAD rgbColor2;          /* This is the secondary color. (Example: This
                                    is the color of the text of an ATTACH_A_NOTE.)*/
    BOOL bHighlighting;         /* TRUE = The mark will be drawn highlighted.
                                    This attribute is currently only valid
                                    for lines, rectangles, and freehand.*/
    BOOL bTransparent;          /* TRUE = The mark will be drawn transparent.
                                    If the mark is drawn transparent, then white
                                    pixels are not drawn (ie. there is nothing
                                    drawn for this mark where it contains white
                                    pixels. This attribute is currently only
                                    available for images. This attribute being
                                    set to TRUE will cause significant
                                    performance reduction.*/
    UINT uLineSize;             /* The size of the line etc. This is passed
                                    onto Windows and is currently in logical
                                    pixels for lines and rectangles.*/
    UINT uStartingPoint;        /* The shape put on the starting of a
                                    line (arrow, circle, square, etc).
                                    For this release, this must be set to 0.*/
    UINT uEndPoint;             /* The shape put on the end of a
                                    line (arrow, circle, square, etc).
                                    For this release, this must be set to 0.*/
    LOGFONTA lfFont;             /* The font information for the text. */
    BOOL bMinimizable;          /* TRUE = This mark can be minimized
                                    by the user. This flag is only used for
                                    marks that have a minimizable
                                    characteristic such as ATTACH_A_NOTE.*/
    UINT  Time;                /* The time that the mark was first saved.
                                    in seconds from 00:00:00 1-1-1970 (GMT).*/
    BOOL bVisible;              /* TRUE means that the layer is currently set
                                    to be visible.*/
    DWORD dwPermissions;        /* Reserved. Must be set to 0x0ff83f */
    UINT lReserved[10];         /* Reserved for future expansion.
                                    For this release these must be set to 0.*/
};


// ANNOTATIONHEADER is the first 4 bytes of data in the annotation property.
struct _ANNOTATIONHEADER
{
    BYTE reserved[4];
    UINT IntIs32Bit;
};

typedef UNALIGNED struct _ANNOTATIONHEADER ANNOTATIONHEADER;
//
// for OiAnoDat
//
struct _ANPOINTS
{
    int nMaxPoints;
    int nPoints;
    POINT ptPoint[1];
};

typedef UNALIGNED struct _ANPOINTS ANPOINTS;

struct _ANROTATE
{
    int rotation;
    int scale;
    int nHRes;
    int nVRes;
    int nOrigHRes;
    int nOrigVRes;
    BOOL bReserved1;
    BOOL bReserved2;
    int nReserved[6];
};

typedef UNALIGNED struct _ANROTATE ANROTATE;
// for OiFilNam
struct _ANNAME
{
    char szName[1];
};

typedef UNALIGNED struct _ANNAME ANNAME;
// for OiDIB
struct _ANIMAGE
{
    BYTE dibInfo[1]; // standard memory DIB
};

typedef UNALIGNED struct _ANIMAGE ANIMAGE;
// for OiAnText
struct _ANTEXTPRIVDATA
{
    int nCurrentOrientation;
    UINT uReserved1; // always 1000 when writing, ignore when reading
    UINT uCreationScale; // always 72000 divided by the vertical resolution of the base image when writing.
                         // Used to modify the Attributes.lfFont.lfHeight variable for display
    UINT uAnoTextLength; // 64k byte limit, except 255 byte limit for text stamp
    char szAnoText[1];
};

typedef UNALIGNED struct _ANTEXTPRIVDATA ANTEXTPRIVDATA;

// These structures provide descriptors for the data read from the annotation property blob.
// The extra data includes the size of each annotation structure
// _NAMEDBLOCK is our in-memory representation
struct _NAMEDBLOCK
{
    UINT cbSize;
    char szType[9];
    BYTE data[1];
};

typedef UNALIGNED struct _NAMEDBLOCK NAMEDBLOCK;

// _FILENAMEDBLOCK is what the namedblock looks like in the file
struct _FILENAMEDBLOCK
{
    char szType[8];
    UINT cbSize;
    BYTE data[1];
};

typedef UNALIGNED struct _FILENAMEDBLOCK FILENAMEDBLOCK;

struct ANNOTATIONDESCRIPTOR
{
    UINT cbSize;
    ANNOTATIONMARK mark;
    BYTE blocks[1];
};

// Define a base class for the various annotation types
class CAnnotation
{
public:
    static CAnnotation* CreateAnnotation(UINT type, ULONG uCreationScale);
    static CAnnotation* CreateAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
    virtual ~CAnnotation();

    // render to the given rectangle in window client coordinates.
    virtual void Render(HDC hdc) { return; }
    // return the in-file representation of this annotation, as well as its total size
    HRESULT GetBlob(SIZE_T &cbSize, LPBYTE pBuffer, LPCSTR szDefaultGroup, LPCSTR szNextIndex);
    // return our image coordinates
    virtual void GetRect(RECT &rect) {rect = _mark.lrBounds;}
    // return the type of Annotation Mark used to change the selection handles for straight lines
    virtual UINT GetType() { return _mark.uType; }
    // moves the annotation on the page by the specified offset
    virtual void Move(SIZE sizeOffset) { OffsetRect(&_mark.lrBounds, sizeOffset.cx, sizeOffset.cy); }
    // return true if the object can be resized (true for every thing but freehand lines and images)
    virtual BOOL CanResize() { return true; }
    // resizes the annotation on the page to the new rect specified
    virtual void Resize(RECT rectNewSize);

    virtual void Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise = TRUE);

    virtual BOOL HasWidth() { return true; }
    virtual UINT GetWidth() { return _mark.uLineSize; }
    virtual void SetWidth(UINT nWidth) { _mark.uLineSize = nWidth; }

    virtual BOOL HasTransparent() { return true; }
    virtual BOOL GetTransparent() { return _mark.bHighlighting; }
    virtual void SetTransparent(BOOL bTransparent) { _mark.bHighlighting = bTransparent; }

    virtual BOOL HasColor() { return true; }
    virtual COLORREF GetColor() { return RGB(_mark.rgbColor1.rgbRed, _mark.rgbColor1.rgbGreen, _mark.rgbColor1.rgbBlue); }
    virtual void SetColor(COLORREF crColor) { _mark.rgbColor1.rgbRed = GetRValue(crColor); _mark.rgbColor1.rgbGreen = GetGValue(crColor); _mark.rgbColor1.rgbBlue = GetBValue(crColor); }

    virtual BOOL HasFont() { return true; }
    virtual void GetFont(LOGFONTA& lfFont) { CopyMemory (&lfFont, &_mark.lfFont, sizeof(lfFont)); }
    virtual void GetFont(LOGFONTW& lfFont);
    virtual void SetFont(LOGFONTA& lfFont) { CopyMemory (&_mark.lfFont, &lfFont, sizeof(lfFont)); }
    virtual void SetFont(LOGFONTW& lfFont);
    virtual LONG GetFontHeight(HDC hdc) { return _mark.lfFont.lfHeight; }

    virtual COLORREF GetFontColor() { return RGB(_mark.rgbColor1.rgbRed, _mark.rgbColor1.rgbGreen, _mark.rgbColor1.rgbBlue); }
    virtual void SetFontColor(COLORREF crColor) { _mark.rgbColor1.rgbRed = GetRValue(crColor); _mark.rgbColor1.rgbGreen = GetGValue(crColor); _mark.rgbColor1.rgbBlue = GetBValue(crColor); }

protected:
    CAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor);
    NAMEDBLOCK *_FindNamedBlock (LPCSTR szName, ANNOTATIONDESCRIPTOR *pDesc);
    virtual HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer) {return E_NOTIMPL;};
    // define helper functions for writing the different named block types
    SIZE_T _WriteStringBlock(LPBYTE pBuffer, UINT uType, LPCSTR szName, LPCSTR szData, SIZE_T len);
    SIZE_T _WritePointsBlock(LPBYTE pBuffer, UINT uType, const POINT *ppts, int nPoints, int nMaxPoints);
    SIZE_T _WriteRotateBlock(LPBYTE pBuffer, UINT uType, const ANROTATE *pRotate);
    SIZE_T _WriteTextBlock(LPBYTE pBuffer, UINT uType, int nOrient, UINT uScale, LPCSTR szText, int nMaxLen);
    SIZE_T _WriteImageBlock(LPBYTE pBuffer, UINT uType, LPBYTE pDib, SIZE_T cbDib);

    ANNOTATIONMARK _mark;
    LPSTR          _szGroup;
    FILENAMEDBLOCK *   _pUGroup;
};

class CRectMark : public CAnnotation
{
public:
    CRectMark (ANNOTATIONDESCRIPTOR *pDescriptor);
    void Render (HDC hdc);

    virtual BOOL HasWidth() { return (_mark.uType == MT_HOLLOWRECT); }
    virtual BOOL HasFont() { return false; }
};

class CImageMark : public CAnnotation
{
public:
    CImageMark (ANNOTATIONDESCRIPTOR *pDescriptor, bool bEmbedded);
    ~CImageMark();
    void Render (HDC hdc);
    HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer);
    virtual BOOL CanResize() { return false; };
    virtual void Resize(RECT rectNewSize) { return; };

private:
    HANDLE _hDibSection; // cached image for quicker render
    LPBYTE _pDib;        // the DIB data from the annotation. If NULL, this is a reference mark
    ANROTATE _rotation;  // rotation info
    LPSTR    _szFilename;  // image file name from the annotation
    bool     _bRotate; //REVIEW_SDK: Shouldn't there just be a known blank rotation value? If I rotate something 0 degrees shouldn't just not write the rotation record?
    SIZE_T   _cbDib;
};

class CLineMark : public CAnnotation
{
public:
    CLineMark(ANNOTATIONDESCRIPTOR *pDescriptor, bool bFreehand);
    ~CLineMark();
    void Render(HDC hdc);
    void GetRect(RECT &rect);
    void SetPoints(POINT* pPoints, int cPoints);
    void GetPointsRect(RECT &rect);
    virtual void Move(SIZE sizeOffset);
    virtual BOOL CanResize() { return (_nPoints == 2); };
    virtual void Resize(RECT rectNewSize);
    virtual void Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise = TRUE);

    virtual BOOL HasFont() { return false; }

    HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer);

private:
    int    _iMaxPts;
    int    _nPoints;
    POINT *_points; // 2 points for a straight line, more for a freehand line
};

// all text annotations render and initialize the same way so use a common base class
class CTextAnnotation : public CAnnotation
{
public:
    CTextAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale, UINT nMaxText=65536, bool _bUseColor2=false);
    void Render(HDC hdc);
    virtual ~CTextAnnotation();
    HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer);

    virtual BOOL HasWidth() { return false; }
    virtual BOOL HasTransparent() { return false; }
    virtual BOOL HasColor() { return false; }
    virtual LONG GetFontHeight(HDC hdc);
    virtual int GetOrientation() { return _nCurrentOrientation; }

    BSTR GetText();
    void SetText(BSTR bstrText);

    virtual void Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise = TRUE);

private:
    int _nCurrentOrientation;
    UINT _uCreationScale;
    UINT _uAnoTextLength;
    UINT _nMaxText;
    LPSTR _szText;
    bool _bUseColor2;
};

class CTypedTextMark : public CTextAnnotation
{
public:
    CTypedTextMark(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
};

class CFileTextMark : public CTextAnnotation
{
public:
    CFileTextMark(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
};

class CTextStampMark : public CTextAnnotation
{
public:
    CTextStampMark(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
};

class CAttachNoteMark : public CTextAnnotation
{
public:
    CAttachNoteMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
    virtual BOOL HasColor() { return true; }
    virtual COLORREF GetFontColor() { return RGB(_mark.rgbColor2.rgbRed, _mark.rgbColor2.rgbGreen, _mark.rgbColor2.rgbBlue); }
    virtual void SetFontColor(COLORREF crColor) { _mark.rgbColor2.rgbRed = GetRValue(crColor); _mark.rgbColor2.rgbGreen = GetGValue(crColor); _mark.rgbColor2.rgbBlue = GetBValue(crColor); }
};

class CAnnotationSet
{
public:
    CAnnotationSet ();
    ~CAnnotationSet ();

    // Draw all the marks
    void RenderAllMarks (HDC hdc);
    // construct annotation set from raw data
    HRESULT BuildAllMarksFromData( LPVOID pData, UINT cbSize, ULONG xDPI, ULONG yDPI );
    // Return the annotation at this point in image coordinates
    CAnnotation* GetAnnotation (INT_PTR nIndex);
    // Add a new annotation to the list. Should only be called from a CAnnotation
    BOOL AddAnnotation(CAnnotation *pMark);
    // Remove an annotation from the list. Should only be called from a CAnnotation
    BOOL RemoveAnnotation (CAnnotation *pMark);
    // Save the current set of annotations to the image
    HRESULT CommitAnnotations (IShellImageData *pimg);
    // Forget our old annotations and load new ones
    void SetImageData (IShellImageData *pimg);
    INT_PTR GetCount ()
    {
        if (_dpaMarks)
            return DPA_GetPtrCount(_dpaMarks);
        return 0;
    };

    UINT GetCreationScale();
    void ClearAllMarks();


private:
    HDPA    _dpaMarks;
    LPBYTE  _pDefaultData;
    SIZE_T  _cbDefaultData;
    ULONG   _xDPI;
    ULONG   _yDPI;

    static int CALLBACK _FreeMarks(LPVOID pMark, LPVOID pUnused);
    void   _ClearMarkList ();
    void   _BuildMarkList (IShellImageData *pimg);
    void   _BuildListFromData (LPVOID pData, UINT cbSize);
    INT    _NamedBlockDataSize (UINT uType, LPBYTE pData, LPBYTE pEOD);
    LPBYTE _MakeAnnotationBlob ();
    HRESULT _SaveAnnotationProperty(IShellImageData *pimg, LPBYTE pData, SIZE_T cbBuffer);
    ANNOTATIONDESCRIPTOR *_ReadMark (LPBYTE pMark, LPBYTE *ppNext, LPBYTE pEOD);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\annotlib\annot.cpp ===
#include "annotlib.h"
#include "assert.h"
#pragma hdrstop

#if !defined(ARRAYSIZE)
#define ARRAYSIZE(x)  (sizeof((x))/sizeof((x)[0]))
#endif
// Private definitions of tag types and values

//
// Each entry in the annotation has a type
//
#define DEFAULTDATA    2
#define ANNOTMARK      5
#define MARKBLOCK      6

// Reserved names for named blocks. case sensitive
static const char c_szAnoDat[] = "OiAnoDat";
static const char c_szFilNam[] = "OiFilNam";
static const char c_szDIB[] = "OiDIB";
static const char c_szGroup[] = "OiGroup";
static const char c_szIndex[] = "OiIndex";
static const char c_szAnText[] = "OiAnText";
static const char c_szHypLnk[] = "OiHypLnk";
static const char c_szDefaultGroup[] = "[Untitled]";

#define CBHEADER      8 // unused 4 bytes plus int size specifier
#define CBDATATYPE    8 // type specifier plus data size
#define CBNAMEDBLOCK 12 // name of block + sizeof block
#define CBINDEX      10 // length of the index string
#define CBBLOCKNAME   8 // length of the name of the named block

static const SIZE_T c_cbDefaultData = 144;
static const BYTE c_pDefaultData[] = {
0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x4f, 0x69, 0x55, 0x47, 0x72, 0x6f, 0x75, 0x70,
0x2a, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x5b, 0x55, 0x6e, 0x74, 0x69, 0x74, 0x6c, 0x65,
0x64, 0x5d, 0x00, 0x00, 0x5b, 0x00, 0x55, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x69, 0x00, 0x74, 0x00,
0x6c, 0x00, 0x65, 0x00, 0x64, 0x00, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x4f, 0x69, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x00, 0x0c, 0x00,
0x00, 0x00, 0x5b, 0x55, 0x6e, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x64, 0x5d, 0x00, 0x00, 0x02, 0x00,
0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x4f, 0x69, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x00, 0x1e, 0x00,
0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE c_pDefaultUGroup [] = {
0x4f, 0x69, 0x55, 0x47, 0x72, 0x6f, 0x75, 0x70,
0x2a, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x5b, 0x55, 0x6e, 0x74, 0x69, 0x74, 0x6c, 0x65,
0x64, 0x5d, 0x00, 0x00, 0x5b, 0x00, 0x55, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x69, 0x00, 0x74, 0x00,
0x6c, 0x00, 0x65, 0x00, 0x64, 0x00, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const INT AnnotHeader[] =
{
    0, 1
};

void NormalizeRect (RECT *prect)
{
    int nTemp;
    if (prect->left > prect->right)
    {
        nTemp = prect->left;
        prect->left = prect->right;
        prect->right = nTemp;
    }
    if (prect->top > prect->bottom)
    {
        nTemp = prect->top;
        prect->top = prect->bottom;
        prect->bottom = nTemp;
    }
}

static void RotateHelper(LPPOINT ppoint, int cSize, int nNewImageWidth, int nNewImageHeight, BOOL bClockwise)
{
    int nNewX, nNewY;
    for(int i=0;i<cSize;i++)
    {
        if (bClockwise)
        {
            nNewX = nNewImageWidth - ppoint[i].y;
            nNewY = ppoint[i].x;
        }
        else
        {
            nNewX = ppoint[i].y;
            nNewY = nNewImageHeight - ppoint[i].x;
        }
        ppoint[i].x = nNewX;
        ppoint[i].y = nNewY;
    }
}

CAnnotationSet::CAnnotationSet()
    : _dpaMarks(NULL)
{
    _pDefaultData = (LPBYTE)c_pDefaultData;
    _cbDefaultData = c_cbDefaultData;
}

CAnnotationSet::~CAnnotationSet()
{
    _ClearMarkList ();
}

void CAnnotationSet::RenderAllMarks(HDC hdc)
{
    CAnnotation *pCur;

    if(_dpaMarks == NULL)
        return;

    for (INT_PTR i=0;i<DPA_GetPtrCount(_dpaMarks);i++)
    {
        pCur = (CAnnotation*)DPA_GetPtr(_dpaMarks, i);
        if (pCur)
        {
            pCur->Render (hdc);
        }
    }
}

CAnnotation* CAnnotationSet::GetAnnotation(INT_PTR nIndex)
{
    if(_dpaMarks == NULL)
        return NULL;

    if (nIndex >= 0 && nIndex < DPA_GetPtrCount(_dpaMarks))
    {
        CAnnotation *pCur;
        pCur = (CAnnotation *)DPA_GetPtr(_dpaMarks, nIndex);
        return pCur;
    }
    return NULL;
}

BOOL CAnnotationSet::AddAnnotation(CAnnotation *pMark)
{
    DPA_AppendPtr(_dpaMarks, pMark);
    return true;
}

BOOL CAnnotationSet::RemoveAnnotation(CAnnotation *pMark)
{
    CAnnotation *pCur;

    if(_dpaMarks == NULL)
        return true;

    for (int i=0;i<DPA_GetPtrCount(_dpaMarks);i++)
    {
        pCur = (CAnnotation*)DPA_GetPtr(_dpaMarks, i);
        if (pCur == pMark)
        {
            DPA_DeletePtr(_dpaMarks, i);
            return true;
        }
    }
    return false;
}

void CAnnotationSet::SetImageData(IShellImageData *pimg)
{
    GUID guidFmt;
    pimg->GetRawDataFormat(&guidFmt);
    _ClearMarkList();
    if (ImageFormatTIFF == guidFmt)
    {        
        _BuildMarkList(pimg);
    }
}

//
// This function reassembles the in-file representation of the current
// annotations and writes it to the IPropertyStorage
//
HRESULT CAnnotationSet::CommitAnnotations(IShellImageData * pSID)
{
    HRESULT hr = E_OUTOFMEMORY;
    SIZE_T cbItem;
    CAnnotation *pItem;
    LPBYTE pData;

    if (NULL == _dpaMarks || DPA_GetPtrCount(_dpaMarks) == 0)
    {
        hr = _SaveAnnotationProperty(pSID, NULL, 0);
        return hr;
    }

    //
    // First, calculate the size of the buffer needed
    // Begin with the header and the size of the default data
    //
    SIZE_T cbBuffer = CBHEADER+_cbDefaultData;
    //
    // Now query the individual items' sizes
    //
    for (INT_PTR i=0;i<DPA_GetPtrCount(_dpaMarks);i++)
    {
        pItem = (CAnnotation*)DPA_GetPtr(_dpaMarks, i);
        if (pItem)
        {
            if (SUCCEEDED(pItem->GetBlob(cbItem, NULL, c_szDefaultGroup, NULL)))
            {
                // cbItem includes the named blocks of the item as well
                // as the ANNOTATIONMARK struct
                cbBuffer += CBDATATYPE + cbItem;
            }
        }
    }
    //
    // Allocate the buffer to hold the annotations
    //
    pData = new BYTE[cbBuffer];
    if (pData)
    {
        LPBYTE pCur = pData;
        //
        // Copy in the header and the int size
        //
        CopyMemory(pCur, AnnotHeader, CBHEADER);
        pCur+=CBHEADER;
        //
        // Copy in the default data
        //
        CopyMemory(pCur, _pDefaultData, _cbDefaultData);
        pCur+=_cbDefaultData;
        //
        // Scan through the items again and have them copy in their data
        //
        for (INT_PTR i=0;i<DPA_GetPtrCount(_dpaMarks);i++)
        {
            pItem = (CAnnotation*)DPA_GetPtr(_dpaMarks, i);
            if (pItem)
            {
                UINT nIndex = (UINT)i;
                CHAR szIndex[11];
                ZeroMemory(szIndex, 11);

                wsprintfA(szIndex, "%d", nIndex);

                if (SUCCEEDED(pItem->GetBlob(cbItem, pCur+CBDATATYPE, c_szDefaultGroup, szIndex)))
                {
                    *(UNALIGNED UINT *)pCur = ANNOTMARK; // next item is an ANNOTATIONMARK
                    *(UNALIGNED UINT *)(pCur+4) = sizeof(ANNOTATIONMARK); // size of the mark
                    pCur+=CBDATATYPE + cbItem;
                }
            }
        }
        //
        // Now save the annotation blob as a property
        //
        hr = _SaveAnnotationProperty(pSID, pData, cbBuffer);
    }
    delete [] pData;
    return hr;
}

void CAnnotationSet::ClearAllMarks()
{
    _ClearMarkList();
}

//
// _BuildMarkList reads the PROPVARIANT for tag 32932 from the image.
// It walks through the data building a list of CAnnotation-derived objects
//
void CAnnotationSet::_BuildMarkList(IShellImageData * pSID)
{
    if(!pSID)
    {
        return;
    }

    pSID->GetResolution(&_xDPI, &_yDPI);

    IPropertySetStorage * pss;
    if(SUCCEEDED(pSID->GetProperties(STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pss)))
    {
        IPropertyStorage * pstg;
        if(SUCCEEDED( pss->Open(FMTID_ImageProperties, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, &pstg)))
        {
            _dpaMarks = DPA_Create(16);

            PROPVARIANT pv = {0};
            PROPSPEC ps;
            ps.propid = ANNOTATION_IMAGE_TAG;
            ps.ulKind = PRSPEC_PROPID;
            if(S_OK == pstg->ReadMultiple(1, &ps, &pv))
            {
                if (pv.vt != VT_NULL && pv.vt != VT_EMPTY)
                {
                    LPVOID pData = NULL;
                    long lUBound;
                    //
                    // This property is a SAFEARRAY of bytes
                    //
                    assert(pv.vt ==(VT_UI1 | VT_ARRAY));
                    SafeArrayGetUBound(pv.parray, 1, &lUBound);
                    SafeArrayAccessData(pv.parray, &pData);
                    if(pData)
                    {
                        _BuildListFromData(pData, SafeArrayGetElemsize(pv.parray)*(lUBound+1));
                    }
                    SafeArrayUnaccessData(pv.parray);                    
                }
                PropVariantClear (&pv);
            }
            pstg->Release();
        }
        pss->Release();
    }
}

// Given the raw annotation data, do set up and then call _BuildListFromData
HRESULT CAnnotationSet::BuildAllMarksFromData(LPVOID pData, UINT cbSize, ULONG xDPI, ULONG yDPI)
{
    // check for bad params
    if (!pData)
    {
        return E_INVALIDARG;
    }

    // First, clear out any old marks...
    _ClearMarkList();

    // Set up DPI info
    _xDPI = xDPI;
    _yDPI = yDPI;

    //  Create DPA if it doesn't exist
    if (!_dpaMarks)
    {
        _dpaMarks = DPA_Create(16);

        if (!_dpaMarks)
        {
            return E_OUTOFMEMORY;
        }
    }

    // build list of marks
    _BuildListFromData(pData,cbSize);

    return S_OK;

}

// Given the raw annotation data, swizzle it to in-memory CAnnotation objects
// and add those object pointers to our list
void CAnnotationSet::_BuildListFromData(LPVOID pData, UINT cbSize)
{
    ANNOTATIONDESCRIPTOR *pDesc;
    LPBYTE   pNextData =(LPBYTE)pData;
    LPBYTE  pDefaultData;
    CAnnotation *pMark;

    if(!_dpaMarks)
    {
        return;
    }
    // Skip the 4 byte header
    pNextData += 4;
    // Make sure the int size is 32 bits
    if(!((UNALIGNED int *)*pNextData))
    {
        return;
    }
    // skip the int size marker
    pNextData += 4;
    pDefaultData = pNextData;
    // skip the default data. It gets stored for future use, as it will be appended to all
    // new marks the user creates on this image.
    pNextData += _NamedBlockDataSize(2,pNextData,(LPBYTE)pData+cbSize);
    _cbDefaultData = (SIZE_T)(pNextData-pDefaultData);
    _pDefaultData = new BYTE[_cbDefaultData];
    if(_pDefaultData)
    {
        CopyMemory(_pDefaultData, pDefaultData, _cbDefaultData);
    }
    // pNextData now points to the first mark in the data.
    do
    {
        // Create a descriptor from the raw mark data
        pDesc = _ReadMark(pNextData, &pNextData,(LPBYTE)pData+cbSize);
        if(pDesc)
        {
            // Now create a CAnnotation from the descriptor and add it to the list
            pMark = CAnnotation::CreateAnnotation(pDesc, _yDPI);
            if(pMark)
            {
                DPA_AppendPtr(_dpaMarks, pMark);
            }
            delete pDesc;
        }       
    }while(pNextData &&(((LPBYTE)pData+cbSize) > pNextData) );
}

#define CHECKEOD if(pCur>pEOD)return -1;

INT CAnnotationSet::_NamedBlockDataSize(UINT uType, LPBYTE pData, LPBYTE pEOD)
{
    LPBYTE pCur = pData;
    UINT cbSkip=0;

    while(pCur < pEOD && *(UNALIGNED UINT*)pCur == uType)
    {
        pCur+=4;
        CHECKEOD
        // skip type and size
        cbSkip +=8+*(UNALIGNED UINT*)pCur;
        pCur+=4;
        //skip name
        pCur+=8;
        CHECKEOD
        // skip size plus the actual data
        cbSkip+=*(UNALIGNED UINT*)pCur;
        pCur+=4+*(UNALIGNED UINT*)pCur;        
    }
    return cbSkip;
}

ANNOTATIONDESCRIPTOR *CAnnotationSet::_ReadMark(LPBYTE pMark, LPBYTE *ppNext, LPBYTE pEOD)
{
    assert(*(UNALIGNED UINT*)pMark == 5);
    LPBYTE pBegin;
    UINT cbMark;                // size of the ANNOTATIONMARK in pMark
    UINT cbNamedBlocks= -1;         // size of the named blocks in pMark
    UINT cbDesc = sizeof(UINT); // size of the ANNOTATIONDESCRIPTOR
    ANNOTATIONDESCRIPTOR *pDesc = NULL;

    *ppNext = NULL;
    if (pMark+8+sizeof(ANNOTATIONMARK)+sizeof(UINT) < pEOD)
    {
        // skip the type
        pMark+=4;
        //point pBegin at the ANNOTATIONMARK struct
        pBegin=pMark+4;
        cbMark = *(UNALIGNED UINT*)pMark;
        assert(cbMark == sizeof(ANNOTATIONMARK));
        cbDesc+=cbMark;
        pMark+=4+cbMark;
        cbNamedBlocks = _NamedBlockDataSize(6, pMark, pEOD);
    }
    if (-1 != cbNamedBlocks)
    {
        cbDesc+=cbNamedBlocks;
        // Allocate the descriptor
        pDesc =(ANNOTATIONDESCRIPTOR *)new BYTE[cbDesc];
    }
    if(pDesc)
    {
        UINT uOffset = 0;
        // populate the descriptor
        pDesc->cbSize = cbDesc;
        CopyMemory(&pDesc->mark, pBegin, sizeof(pDesc->mark));
        // Set pBegin at the beginning of the named blocks and read them in
        pBegin+=cbMark;
        NAMEDBLOCK *pBlock =(NAMEDBLOCK*)(&pDesc->blocks);
        while(uOffset < cbNamedBlocks)
        {
            assert(*(UNALIGNED UINT*)(pBegin+uOffset) == 6);
            uOffset += 4;
            assert(*(UNALIGNED UINT*)(pBegin+uOffset) = 12); // name plus data size
            uOffset+=4;
            // Copy in the name of the block
            lstrcpynA(pBlock->szType,(LPCSTR)(pBegin+uOffset), ARRAYSIZE(pBlock->szType));
            uOffset+=8;
            cbMark = *(UNALIGNED UINT*)(pBegin+uOffset);
            // Calculate the total size of the NAMEDBLOCK structure
            pBlock->cbSize = sizeof(pBlock->cbSize)+sizeof(pBlock->szType)+cbMark;
            uOffset+=4;
            CopyMemory(&pBlock->data,pBegin+uOffset, cbMark);
            uOffset+=cbMark;
            // move our block pointer to the next chunk
            pBlock =(NAMEDBLOCK*)((LPBYTE)pBlock+pBlock->cbSize);
        }
        *ppNext =(LPBYTE)(pBegin+cbNamedBlocks);
    }
    return pDesc;
}

void CAnnotationSet::_ClearMarkList()
{
    if(_dpaMarks)
    {
        DPA_DestroyCallback(_dpaMarks, _FreeMarks, NULL);
        _dpaMarks = NULL;
    }
    if (_pDefaultData != c_pDefaultData)
    {
       delete[] _pDefaultData;
    }
    _pDefaultData = (LPBYTE)c_pDefaultData;
    _cbDefaultData = c_cbDefaultData;
}

int CALLBACK CAnnotationSet::_FreeMarks(LPVOID pMark, LPVOID pUnused)
{
    delete (CAnnotation*)pMark;
    return 1;
}

HRESULT CAnnotationSet::_SaveAnnotationProperty(IShellImageData * pSID, LPBYTE pData, SIZE_T cbBuffer)
{
    IPropertySetStorage * pss;
    HRESULT hr = pSID->GetProperties(STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pss);
    if (SUCCEEDED(hr))
    {
        IPropertyStorage * pstg;
        hr = pss->Open(FMTID_ImageProperties, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, &pstg);
        if (SUCCEEDED(hr))
        {
            PROPVARIANT pv;
            static PROPSPEC ps = {PRSPEC_PROPID, ANNOTATION_IMAGE_TAG};
            SAFEARRAYBOUND bound;
            bound.cElements = (ULONG)cbBuffer;
            bound.lLbound = 0;
            PropVariantInit(&pv);
            if (pData != NULL)
            {
                pv.vt = VT_UI1 | VT_ARRAY;
                pv.parray = SafeArrayCreate(VT_UI1,1,&bound);
                if (pv.parray)
                {
                    LPVOID pBits;
                    hr = SafeArrayAccessData(pv.parray, &pBits);
                    if (SUCCEEDED(hr))
                    {
                        CopyMemory(pBits, pData, cbBuffer);
                        SafeArrayUnaccessData(pv.parray);
                        if (S_OK != pstg->WriteMultiple(1, &ps, &pv, 1024))
                        {
                            hr = E_FAIL;
                        }
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                pv.vt = VT_NULL;
                if (S_OK != pstg->WriteMultiple(1, &ps, &pv, 1024))
                {
                    hr = E_FAIL;
                }
            }
            PropVariantClear(&pv);
            pstg->Release();
        }
        pss->Release();
    }
    return hr;
}

CAnnotation::CAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor)
{
    NAMEDBLOCK *pb;

    CopyMemory(&_mark, &pDescriptor->mark, sizeof(_mark));
    // every annotation read from the image should have a group name
    // and an index

    _szGroup = NULL;
    pb = _FindNamedBlock("OiGroup", pDescriptor);
    if(pb)
    {
        _szGroup = new char[pb->cbSize-sizeof(pb->szType)];
        if(_szGroup)
        {
            lstrcpyA(_szGroup,(LPCSTR)(pb->data));
        }
    }
    _pUGroup = (FILENAMEDBLOCK*)c_pDefaultUGroup;
    pb = _FindNamedBlock("OiUGroup", pDescriptor);
    if (pb)
    {
        _pUGroup = (FILENAMEDBLOCK*)new BYTE[pb->cbSize-1];
        if (_pUGroup)
        {
            CopyMemory(_pUGroup->szType, pb->szType, ARRAYSIZE(_pUGroup->szType));
            _pUGroup->cbSize = pb->cbSize-CBNAMEDBLOCK-1;
            CopyMemory(_pUGroup->data, pb->data, _pUGroup->cbSize);
        }
        else
        {
            _pUGroup = (FILENAMEDBLOCK*)c_pDefaultUGroup;
        }
    }
}

// return a blank annotation object
CAnnotation *CAnnotation::CreateAnnotation(UINT type, ULONG uCreationScale)
{
    ANNOTATIONDESCRIPTOR desc;
    ZeroMemory(&desc, sizeof(desc));
    desc.cbSize = sizeof(desc.cbSize)+sizeof(desc.mark)+sizeof(desc.blocks);
    desc.mark.uType = type;
    // MSDN mentions this required permission value
    desc.mark.dwPermissions = 0x0ff83f;
    desc.mark.bVisible = 1;
    return CreateAnnotation(&desc, uCreationScale);
}

CAnnotation *CAnnotation::CreateAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale)
{

    CAnnotation *pNew = NULL;
    switch(pDescriptor->mark.uType)
    {
        case MT_IMAGEEMBED:
        case MT_IMAGEREF:
            pNew = new CImageMark(pDescriptor, pDescriptor->mark.uType == MT_IMAGEEMBED);
            break;
        case MT_STRAIGHTLINE:
        case MT_FREEHANDLINE:
            pNew = new CLineMark(pDescriptor, pDescriptor->mark.uType == MT_FREEHANDLINE);
            break;
        case MT_FILLRECT:
        case MT_HOLLOWRECT:
            pNew = new CRectMark(pDescriptor);
            break;
        case MT_TYPEDTEXT:
            pNew = new CTypedTextMark(pDescriptor, uCreationScale);
            break;
        case MT_FILETEXT:
            pNew = new CFileTextMark(pDescriptor, uCreationScale);
            break;
        case MT_STAMP:
            pNew = new CTextStampMark(pDescriptor, uCreationScale);
            break;
        case MT_ATTACHANOTE:
            pNew = new CAttachNoteMark(pDescriptor, uCreationScale);
            break;
        default:

            break;
    }
    return pNew;
}

void CAnnotation::Resize(RECT rectNewSize)
{
    _mark.lrBounds = rectNewSize;
    NormalizeRect(&_mark.lrBounds);
}

NAMEDBLOCK *CAnnotation::_FindNamedBlock(LPCSTR szName, ANNOTATIONDESCRIPTOR *pDescriptor)
{
    NAMEDBLOCK *pCur;
    NAMEDBLOCK *pRet = NULL;
    UINT uOffset;
    LPBYTE pb =(LPBYTE)pDescriptor;
    uOffset = sizeof(pDescriptor->cbSize)+sizeof(pDescriptor->mark);
    while(!pRet && uOffset < pDescriptor->cbSize)
    {
        pCur =(NAMEDBLOCK*)(pb+uOffset);
        if(!lstrcmpA(pCur->szType, szName))
        {
            pRet = pCur;
        }
        else
        {
            if (pCur->cbSize == 0)
                return NULL;

            uOffset+=pCur->cbSize;
        }
    }
    return pRet;
}

CAnnotation::~CAnnotation()
{
    if(_szGroup)
    {
        delete _szGroup;
    }
    if (_pUGroup && _pUGroup != (FILENAMEDBLOCK*)c_pDefaultUGroup)
    {
        delete [] (BYTE*)_pUGroup;
    }
}

// GetBlob writes out the ANNOTATIONMARK plus the group and index blocks
// It then queries the subclass through a virtual function to get
// extra named blocks
//
HRESULT CAnnotation::GetBlob(SIZE_T &cbSize, LPBYTE pBuffer, LPCSTR szDefaultGroup, LPCSTR szNextIndex)
{
    SIZE_T cbExtra = 0;
    HRESULT hr = S_OK;
    LPCSTR szGroup = _szGroup;
    if (szGroup == NULL)
        szGroup = szDefaultGroup;

    // add in the ANNOTATIONMARK
    cbSize = sizeof(_mark);
    // for the group and index, add in the
    cbSize += 2*(CBDATATYPE+CBNAMEDBLOCK);
    // add in the length of the group name
    cbSize += lstrlenA(szGroup)+1;
    // add in the size of the index string
    cbSize += CBINDEX;
    if (_pUGroup)
    {
        cbSize += CBDATATYPE+CBNAMEDBLOCK+_pUGroup->cbSize;
    }
    // Add in the size of any named blocks from the subclass
    _WriteBlocks(cbExtra, NULL);
    cbSize += cbExtra;
    if (pBuffer)
    {
        // now write the data
        CopyMemory (pBuffer, &_mark, sizeof(_mark));
        pBuffer += sizeof(_mark);
        // write the mark-specific blocks before the group and index blocks
        if (cbExtra)
        {
            if (SUCCEEDED(_WriteBlocks(cbExtra, pBuffer)))
            {
                pBuffer+=cbExtra;
            }
        }
        // write the group and index blocks
        if (_pUGroup)
        {
            *(UNALIGNED UINT*)pBuffer = 6;
            *(UNALIGNED UINT*)(pBuffer + 4) = CBNAMEDBLOCK;
            CopyMemory(pBuffer+CBDATATYPE,_pUGroup, CBNAMEDBLOCK+_pUGroup->cbSize);
            pBuffer += CBDATATYPE + CBNAMEDBLOCK+_pUGroup->cbSize;
        }
        pBuffer += _WriteStringBlock(pBuffer, 6, c_szGroup, szGroup, lstrlenA(szGroup)+1);
        pBuffer += _WriteStringBlock(pBuffer, 6, c_szIndex, szNextIndex, CBINDEX);
    }
    return hr;
}

void CAnnotation::Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise)
{
    RECT rect = _mark.lrBounds;
    RotateHelper((LPPOINT)&rect, 2, nNewImageWidth, nNewImageHeight, bClockwise);
    NormalizeRect(&rect);
    _mark.lrBounds = rect;
}

void CAnnotation::GetFont(LOGFONTW& lfFont)
{
    lfFont.lfHeight = _mark.lfFont.lfHeight;
    lfFont.lfWidth = _mark.lfFont.lfWidth;
    lfFont.lfEscapement = _mark.lfFont.lfEscapement;
    lfFont.lfOrientation = _mark.lfFont.lfOrientation;
    lfFont.lfWeight = _mark.lfFont.lfWeight;
    lfFont.lfItalic = _mark.lfFont.lfItalic;
    lfFont.lfUnderline = _mark.lfFont.lfUnderline;
    lfFont.lfStrikeOut = _mark.lfFont.lfStrikeOut;
    lfFont.lfCharSet = _mark.lfFont.lfCharSet;
    lfFont.lfOutPrecision = _mark.lfFont.lfOutPrecision;
    lfFont.lfClipPrecision = _mark.lfFont.lfClipPrecision;
    lfFont.lfQuality = _mark.lfFont.lfQuality;
    lfFont.lfPitchAndFamily = _mark.lfFont.lfPitchAndFamily;

    ::MultiByteToWideChar(CP_ACP, 0, _mark.lfFont.lfFaceName, LF_FACESIZE, lfFont.lfFaceName, LF_FACESIZE);
}

void CAnnotation::SetFont(LOGFONTW& lfFont)
{
    _mark.lfFont.lfHeight = lfFont.lfHeight;
    _mark.lfFont.lfWidth = lfFont.lfWidth;
    _mark.lfFont.lfEscapement = lfFont.lfEscapement;
    _mark.lfFont.lfOrientation = lfFont.lfOrientation;
    _mark.lfFont.lfWeight = lfFont.lfWeight;
    _mark.lfFont.lfItalic = lfFont.lfItalic;
    _mark.lfFont.lfUnderline = lfFont.lfUnderline;
    _mark.lfFont.lfStrikeOut = lfFont.lfStrikeOut;
    _mark.lfFont.lfCharSet = lfFont.lfCharSet;
    _mark.lfFont.lfOutPrecision = lfFont.lfOutPrecision;
    _mark.lfFont.lfClipPrecision = lfFont.lfClipPrecision;
    _mark.lfFont.lfQuality = lfFont.lfQuality;
    _mark.lfFont.lfPitchAndFamily = lfFont.lfPitchAndFamily;

    ::WideCharToMultiByte(CP_ACP, 0, lfFont.lfFaceName, LF_FACESIZE, _mark.lfFont.lfFaceName, LF_FACESIZE, NULL, NULL);
}

SIZE_T CAnnotation::_WriteStringBlock(LPBYTE pBuffer, UINT uType, LPCSTR szName, LPCSTR szData, SIZE_T len)
{
    if (pBuffer)
    {
        *(UNALIGNED UINT*)pBuffer = uType;
        *(UNALIGNED UINT*)(pBuffer + 4) = CBNAMEDBLOCK;
        lstrcpynA((LPSTR)(pBuffer + CBDATATYPE), szName, CBNAMEDBLOCK+1); // named block name
        *(UNALIGNED UINT*)(pBuffer + CBDATATYPE + 8) = (UINT)len; // the named block name isn't null terminated
        CopyMemory(pBuffer + CBDATATYPE + CBNAMEDBLOCK, szData, len);
    }
    return CBDATATYPE + CBNAMEDBLOCK + len;
}

SIZE_T CAnnotation::_WritePointsBlock(LPBYTE pBuffer, UINT uType, const POINT *ppts, int nPoints, int nMaxPoints)
{
    UINT cbAnPoints = sizeof(int)+sizeof(int)+nPoints*sizeof(POINT);
    if (pBuffer)
    {
        *(UNALIGNED UINT *)pBuffer = uType;
        *(UNALIGNED UINT *)(pBuffer + 4) = CBNAMEDBLOCK;
        lstrcpynA((LPSTR)(pBuffer + CBDATATYPE), c_szAnoDat, CBNAMEDBLOCK+1);
        pBuffer += CBDATATYPE + 8;
        *(UNALIGNED UINT *)pBuffer = cbAnPoints;
        pBuffer+=4;
        // Write out the ANPOINTS equivalent
        *(UNALIGNED int*)pBuffer = nMaxPoints;
        *(UNALIGNED int*)(pBuffer+4) = nPoints;
        CopyMemory(pBuffer+8, ppts, nPoints*sizeof(POINT));
    }
    return CBDATATYPE + CBNAMEDBLOCK + cbAnPoints;
}

SIZE_T CAnnotation::_WriteRotateBlock(LPBYTE pBuffer, UINT uType, const ANROTATE *pRotate)
{
    if (pBuffer)
    {
        *(UNALIGNED UINT *)pBuffer = uType;
        *(UNALIGNED UINT *)(pBuffer + 4) = CBNAMEDBLOCK;
        lstrcpynA((LPSTR)(pBuffer + CBDATATYPE), c_szAnoDat, CBNAMEDBLOCK+1);
        *(UNALIGNED UINT *)(pBuffer + CBDATATYPE + 8) = sizeof(ANROTATE);
        CopyMemory(pBuffer + CBDATATYPE + CBNAMEDBLOCK, pRotate, sizeof(ANROTATE));
    }
    return CBDATATYPE + CBNAMEDBLOCK + sizeof(ANROTATE);
}


SIZE_T CAnnotation::_WriteTextBlock(LPBYTE pBuffer, UINT uType, int nOrient, UINT uScale, LPCSTR szText, int nMaxLen)
{
    LPCSTR pText = szText ? szText : "";
    UINT cbString =  min(lstrlenA(pText)+1, nMaxLen);
    UINT cbPrivData = sizeof(ANTEXTPRIVDATA)+cbString;
    if (pBuffer)
    {
        *(UNALIGNED UINT *)pBuffer = uType;
        *(UNALIGNED UINT *)(pBuffer + 4) = CBNAMEDBLOCK;
        lstrcpynA((LPSTR)(pBuffer + CBDATATYPE), c_szAnText, CBNAMEDBLOCK+1);
        *(UNALIGNED UINT *)(pBuffer + CBDATATYPE + 8) = cbPrivData;
        // write out the ANTEXTPRIVDATA equivalent
        pBuffer += CBDATATYPE + CBNAMEDBLOCK;
        *(UNALIGNED int*)pBuffer = nOrient;
        *(UNALIGNED UINT *)(pBuffer+4) = 1000;
        *(UNALIGNED UINT *)(pBuffer+8) = uScale;
        *(UNALIGNED UINT *)(pBuffer+12) = cbString;
        lstrcpynA((LPSTR)(pBuffer+16), pText, nMaxLen);
    }
    return CBDATATYPE + CBNAMEDBLOCK + cbPrivData;
}

SIZE_T CAnnotation::_WriteImageBlock(LPBYTE pBuffer, UINT uType, LPBYTE pDib, SIZE_T cbDib)
{
    if (pBuffer)
    {
        *(UNALIGNED UINT *)pBuffer = uType;
        *(UNALIGNED UINT *)(pBuffer+4) = CBNAMEDBLOCK;
        lstrcpynA((LPSTR)(pBuffer + CBDATATYPE), c_szAnText, CBNAMEDBLOCK+1);


/* REVIEW_SDK
        Now that I think about it, it might make sense to define a struct that could make this more clear.
        Something like:

        struct AnnoBlock
        {
                UINT uBlockType;
                UINT uBlockSize;
                CHAR sName[8]; // Not NULL terminated
                UINT uVariableDataSize;
                BYTE Data[];
        };

*/
        *(UNALIGNED UINT *)(pBuffer + CBDATATYPE + 8) = (UINT)cbDib;
        CopyMemory(pBuffer + CBDATATYPE + CBNAMEDBLOCK, pDib, cbDib);
    }
    return CBDATATYPE + CBNAMEDBLOCK + cbDib;
}

CRectMark::CRectMark(ANNOTATIONDESCRIPTOR *pDescriptor)
    : CAnnotation(pDescriptor)
{
    // rects have no named blocks to read
}

void CRectMark::Render(HDC hdc)
{
    int nROP = R2_COPYPEN;
    if (_mark.bHighlighting)
        nROP = R2_MASKPEN;

    int nOldROP = ::SetROP2(hdc, nROP);

    HPEN hPen = NULL;
    HPEN hOldPen = NULL;
    HBRUSH hBrush = NULL;
    HBRUSH hOldBrush = NULL;

    if (_mark.uType == MT_HOLLOWRECT)
    {
        hPen = ::CreatePen(PS_INSIDEFRAME, max(1, _mark.uLineSize),
                          RGB(_mark.rgbColor1.rgbRed,
                              _mark.rgbColor1.rgbGreen,
                              _mark.rgbColor1.rgbBlue));
        if(hPen)
            hOldPen =(HPEN)::SelectObject(hdc, hPen);

        hOldBrush = (HBRUSH)::SelectObject(hdc, ::GetStockObject(NULL_BRUSH));
    }
    else
    {
        hBrush = CreateSolidBrush(RGB(_mark.rgbColor1.rgbRed,
                                    _mark.rgbColor1.rgbGreen,
                                    _mark.rgbColor1.rgbBlue));
        if (hBrush)
            hOldBrush = (HBRUSH)::SelectObject(hdc, hBrush);

        hOldPen =(HPEN)::SelectObject(hdc, GetStockObject(NULL_PEN));
    }

    ::Rectangle(hdc, _mark.lrBounds.left, _mark.lrBounds.top, _mark.lrBounds.right, _mark.lrBounds.bottom);

    if (hOldPen)
        ::SelectObject(hdc, hOldPen);

    if (hOldBrush)
        ::SelectObject(hdc, hOldBrush);

    if (hPen)
        ::DeleteObject(hPen);

    if (hBrush)
        ::DeleteObject(hBrush);

    ::SetROP2(hdc, nOldROP);
}

CImageMark::CImageMark(ANNOTATIONDESCRIPTOR *pDescriptor, bool bEmbedded) :
    CAnnotation(pDescriptor), _hDibSection(NULL), _pDib(NULL)
{
    ZeroMemory(&_rotation, sizeof(_rotation));
    NAMEDBLOCK *pb = _FindNamedBlock(c_szAnoDat, pDescriptor);
    UINT cb;
    _cbDib = 0;
    _bRotate = false;
    if (pb)
    {
        CopyMemory(&_rotation, pb->data, sizeof(_rotation));
    }
    pb= _FindNamedBlock(c_szFilNam, pDescriptor);
    if (pb)
    {
        cb = pb->cbSize-sizeof(pb->cbSize)-sizeof(pb->szType);
        _szFilename = new char[cb+1];
        if (_szFilename)
        {
            lstrcpynA (_szFilename, (LPCSTR)(pb->data), cb+1);
        }
    }
    pb = _FindNamedBlock(c_szDIB, pDescriptor);
    if (pb)
    {
        assert (bEmbedded);
        cb = pb->cbSize-sizeof(pb->cbSize)-sizeof(pb->szType);
        _pDib = new BYTE[cb];
        if (_pDib)
        {
            CopyMemory (_pDib, pb->data, cb);
            _cbDib = cb;
        }
        // what do we do if allocation fails?
    }
    // If an image has IoAnoDat, the structure is a rotation structure
    pb = _FindNamedBlock(c_szAnoDat, pDescriptor);
    if (pb)
    {
        assert(pb->cbSize-sizeof(pb->cbSize)-sizeof(pb->szType) == sizeof(_rotation));
        _bRotate = true;
        CopyMemory(&_rotation, pb->data, sizeof(_rotation));
    }
}

CImageMark::~CImageMark()
{
    if (_pDib)
    {
        delete [] _pDib;
    }
    if (_szFilename)
    {
        delete [] _szFilename;
    }
}

HRESULT CImageMark::_WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer)
{
    cbSize = 0;
    if (_szFilename)
    {
        cbSize += _WriteStringBlock(pBuffer, 6, c_szFilNam, _szFilename, lstrlenA(_szFilename)+1);
    }
    if (_pDib)
    {
        cbSize += _WriteImageBlock(pBuffer, 6, _pDib, _cbDib);
    }
    if (_bRotate)
    {
        cbSize += _WriteRotateBlock(pBuffer, 6, &_rotation);
    }
    return S_OK;
}

void CImageMark::Render(HDC hdc)
{

}

CLineMark::CLineMark(ANNOTATIONDESCRIPTOR *pDescriptor, bool bFreehand)
    : CAnnotation(pDescriptor)
{
    NAMEDBLOCK *pb=_FindNamedBlock(c_szAnoDat, pDescriptor);
    _points = NULL;
    _nPoints = 0;
    if (pb)
    {
        ANPOINTS *ppts = (ANPOINTS*)&pb->data;
        _iMaxPts = bFreehand ? ppts->nMaxPoints : 2;

        assert(_nPoints > 2?bFreehand:TRUE);
        _points = new POINT[_iMaxPts];
        if (_points)
        {
            _nPoints = ppts->nPoints;
            CopyMemory (_points, &ppts->ptPoint, sizeof(POINT)*_nPoints);
            // each point is relative to the upper left cornder of _mark.lrBounds
            for (int i=0;i<_nPoints;i++)
            {
                _points[i].x += _mark.lrBounds.left;
                _points[i].y += _mark.lrBounds.top;
            }
        }
    }
}

CLineMark::~CLineMark()
{
    if (_points)
    {
        delete [] _points;
    }
}

void CLineMark::SetPoints(POINT* pPoints, int cPoints)
{
    assert(_mark.uType == MT_FREEHANDLINE);

    if (_points != NULL)
        delete[] _points;

    _points = pPoints;
    _nPoints = cPoints;
    _iMaxPts = _nPoints;

    RECT rect;
    rect.left = _points[0].x;
    rect.top =  _points[0].y;
    rect.right = _points[0].x;
    rect.bottom= _points[0].y;

    for(int i = 1; i < _nPoints; i++)
    {
        if (rect.left > _points[i].x)
            rect.left = _points[i].x;
        else if (rect.right < _points[i].x)
            rect.right = _points[i].x;

        if (rect.top > _points[i].y)
            rect.top = _points[i].y;
        else if (rect.bottom < _points[i].y)
            rect.bottom = _points[i].y;
    }

    _mark.lrBounds = rect;
}

void CLineMark::Render(HDC hdc)
{
    int nROP = R2_COPYPEN;
    if (_mark.bHighlighting)
        nROP = R2_MASKPEN;

    int nOldROP = ::SetROP2(hdc, nROP);

    HPEN hPen = NULL;
    HPEN hOldPen = NULL;

    hPen = ::CreatePen(PS_SOLID, max(1, _mark.uLineSize),
                      RGB(_mark.rgbColor1.rgbRed,
                          _mark.rgbColor1.rgbGreen,
                          _mark.rgbColor1.rgbBlue));
    if(hPen)
        hOldPen =(HPEN)::SelectObject(hdc, hPen);

    ::Polyline(hdc, _points, _nPoints);

    if (hOldPen)
        ::SelectObject(hdc, hOldPen);

    if (hPen)
        ::DeleteObject(hPen);

    ::SetROP2(hdc, nOldROP);
}

void CLineMark::GetRect(RECT &rect)
{
    
    int nPadding = (_mark.uLineSize / 2) + 6; 
    // one because LineTo is inclusive
    // one for rounding error on odd line widths
    // one for rounding error in scaling large files
    // and three more just so we don't have to tweak this again
    
    rect = _mark.lrBounds;
    InflateRect(&rect, nPadding , nPadding);
}

// Usually we are interested in the bounding rect of the line above
// but if we are directly manipulating the line we need a way to get
// to the unadjusted points (left, top) and (right, bottom)
void CLineMark::GetPointsRect(RECT &rect)
{
    if (_nPoints != 2)
        return;

    rect.top = _points[0].y;
    rect.left = _points[0].x;
    rect.bottom = _points[1].y;
    rect.right = _points[1].x;
}

void CLineMark::Move(SIZE sizeOffset)
{
    _points[0].x += sizeOffset.cx;
    _points[0].y += sizeOffset.cy;

    RECT rect;
    rect.left = _points[0].x;
    rect.top =  _points[0].y;
    rect.right = _points[0].x;
    rect.bottom = _points[0].y;
    for(int i = 1; i < _nPoints; i++)
    {
        _points[i].x += sizeOffset.cx;
        if (rect.left > _points[i].x)
            rect.left = _points[i].x;
        else if (rect.right < _points[i].x)
            rect.right = _points[i].x;

        _points[i].y += sizeOffset.cy;
        if (rect.top > _points[i].y)
            rect.top = _points[i].y;
        else if (rect.bottom < _points[i].y)
            rect.bottom = _points[i].y;
    }

    _mark.lrBounds = rect;
}

void CLineMark::Resize(RECT rectNewSize)
{
    if ((_points == NULL) && (_mark.uType == MT_STRAIGHTLINE))
    {
      _iMaxPts = _nPoints = 2;
      _points = new POINT[_iMaxPts];
    }

    if ((_nPoints == 2) && (_points != NULL))
    {
        _points[0].y = rectNewSize.top;
        _points[0].x = rectNewSize.left;
        _points[1].y = rectNewSize.bottom;
        _points[1].x = rectNewSize.right;

        _mark.lrBounds = rectNewSize;
        NormalizeRect(&_mark.lrBounds);
    }
}

void CLineMark::Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise)
{
    RotateHelper(_points, _nPoints, nNewImageWidth, nNewImageHeight, bClockwise);

    RECT rect;
    rect.left = _points[0].x;
    rect.top =  _points[0].y;
    rect.right = _points[0].x;
    rect.bottom= _points[0].y;
    for(int i = 1; i < _nPoints; i++)
    {
        if (rect.left > _points[i].x)
            rect.left = _points[i].x;
        else if (rect.right < _points[i].x)
            rect.right = _points[i].x;

        if (rect.top > _points[i].y)
            rect.top = _points[i].y;
        else if (rect.bottom < _points[i].y)
            rect.bottom = _points[i].y;
    }

    _mark.lrBounds = rect;
}

HRESULT CLineMark::_WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer)
{
    if (_points)
    {
        for (int i=0;i<_nPoints;i++)
        {
            _points[i].x -= _mark.lrBounds.left;
            _points[i].y -= _mark.lrBounds.top;
        }

        cbSize = _WritePointsBlock(pBuffer, 6, _points, _nPoints, _iMaxPts);

        for (int i=0;i<_nPoints;i++)
        {
            _points[i].x += _mark.lrBounds.left;
            _points[i].y += _mark.lrBounds.top;
        }
    }

    return S_OK;
}

CTextAnnotation::CTextAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale, UINT nMaxLen, bool bUseColor2 )
    : CAnnotation(pDescriptor)
{
    NAMEDBLOCK *pb = _FindNamedBlock(c_szAnText, pDescriptor);
    _nCurrentOrientation  = 0;
    _uCreationScale = 0;
    _uAnoTextLength = 0;
    _szText = NULL;
    _nMaxText = nMaxLen;
    _bUseColor2 = bUseColor2;
    if (pb)
    {
        ANTEXTPRIVDATA *pData = (ANTEXTPRIVDATA*)&pb->data;
        _szText = new char[pData->uAnoTextLength+1];
        if (_szText)
        {
            _nCurrentOrientation = pData->nCurrentOrientation;
            _uCreationScale = pData->uCreationScale;
            _uAnoTextLength = pData->uAnoTextLength;
            lstrcpynA (_szText, pData->szAnoText, _uAnoTextLength+1);
        }
    }
    if (_uCreationScale == 0)
    {
        _uCreationScale = 72000 / uCreationScale;
    }
}

CTextAnnotation::~CTextAnnotation()
{
    if (_szText)
    {
        delete [] _szText;
    }
}

void CTextAnnotation::Render(HDC hdc)
{
    COLORREF crOld;
    int nOldROP = ::SetROP2(hdc, R2_COPYPEN);

    if (_mark.uType == MT_ATTACHANOTE)
    {
        HPEN hOldPen =(HPEN)::SelectObject(hdc, GetStockObject(NULL_PEN));
        HBRUSH hBrush = ::CreateSolidBrush(RGB(_mark.rgbColor1.rgbRed,
                                              _mark.rgbColor1.rgbGreen,
                                              _mark.rgbColor1.rgbBlue));
        if (hBrush != NULL)
        {
            HBRUSH hOldBrush = (HBRUSH)::SelectObject(hdc, hBrush);

            ::Rectangle(hdc, _mark.lrBounds.left, _mark.lrBounds.top, _mark.lrBounds.right, _mark.lrBounds.bottom);

            ::SelectObject(hdc, hOldBrush);
            ::DeleteObject(hBrush);
        }
        ::SelectObject(hdc, hOldPen);

        crOld = ::SetTextColor(hdc, RGB(_mark.rgbColor2.rgbRed,
                                      _mark.rgbColor2.rgbGreen,
                                      _mark.rgbColor2.rgbBlue));
    }
    else
    {
        crOld = ::SetTextColor(hdc, RGB(_mark.rgbColor1.rgbRed,
                                      _mark.rgbColor1.rgbGreen,
                                      _mark.rgbColor1.rgbBlue));
    }

    int nOldBkMode = ::SetBkMode(hdc, TRANSPARENT);

    LOGFONT lf;
    GetFont(lf);

    lf.lfHeight = GetFontHeight(hdc);

    HFONT hFont = CreateFontIndirect(&lf);
    HFONT hOldFont = NULL;
    if (hFont != NULL)
        hOldFont = (HFONT)::SelectObject(hdc, hFont);

    BSTR bstrText = GetText();

    // Handle angle of orientation in 1/10s of a degree
    if (_nCurrentOrientation != 0)
    {
        XFORM xForm;
        RECT rectSource = _mark.lrBounds;
        ::LPtoDP(hdc, (LPPOINT)&rectSource, 2);

        if (_nCurrentOrientation == 900)
        {
            xForm.eM11 = (FLOAT)0.0;
            xForm.eM12 = (FLOAT)-1.0;
            xForm.eM21 = (FLOAT)1.0;
            xForm.eM22 = (FLOAT)0.0;
            // Rotate Source (left, top) to (left, bottom)
            int nTmp = rectSource.bottom;
            rectSource.bottom = rectSource.top;
            rectSource.top = nTmp;
        }
        else if (_nCurrentOrientation == 1800)
        {
            xForm.eM11 = (FLOAT)-1.0;
            xForm.eM12 = (FLOAT)0.0;
            xForm.eM21 = (FLOAT)0.0;
            xForm.eM22 = (FLOAT)-1.0;
            // Rotate Source (left, top) to (right, bottom)
            int nTmp = rectSource.right;
            rectSource.right = rectSource.left;
            rectSource.left = nTmp;
            nTmp = rectSource.bottom;
            rectSource.bottom = rectSource.top;
            rectSource.top = nTmp;
        }
        else
        {
            xForm.eM11 = (FLOAT)0.0;
            xForm.eM12 = (FLOAT)1.0;
            xForm.eM21 = (FLOAT)-1.0;
            xForm.eM22 = (FLOAT)0.0;
            // Rotate Source (left, top) to (right, top)
            int nTmp = rectSource.right;
            rectSource.right = rectSource.left;
            rectSource.left = nTmp;
        }

        xForm.eDx = (FLOAT)0.0;
        xForm.eDy = (FLOAT)0.0;

        int nOldGraphicsMode = ::SetGraphicsMode(hdc, GM_ADVANCED);
        ::SetWorldTransform(hdc, &xForm);

        RECT rectTarget = rectSource;
        ::DPtoLP(hdc, (LPPOINT)&rectTarget, 2);

        ::DrawText(hdc, bstrText, -1, &rectTarget, DT_LEFT | DT_EDITCONTROL | DT_NOPREFIX | DT_WORDBREAK);

        ::ModifyWorldTransform(hdc, &xForm, MWT_IDENTITY);
        ::SetGraphicsMode(hdc, nOldGraphicsMode);
    }
    else
    {
        ::DrawText(hdc, bstrText, -1, &_mark.lrBounds, DT_LEFT | DT_EDITCONTROL | DT_NOPREFIX | DT_WORDBREAK);
    }

    if (hFont != NULL)
    {
        ::SelectObject(hdc, hOldFont);
        ::DeleteObject(hFont);
    }

    if (nOldBkMode != 0)
        ::SetBkMode(hdc, nOldBkMode);

    if (crOld != CLR_INVALID)
        ::SetTextColor (hdc, crOld);

    ::SetROP2(hdc, nOldROP);
    if (bstrText)
    {
        SysFreeString(bstrText);
    }
}

LONG CTextAnnotation::GetFontHeight(HDC hdc)
{
    LONG lHeight = MulDiv(_mark.lfFont.lfHeight, 96, 72);
//> REVIEW : This needs work, the 1000 below is rather random and should be fixed after Beta1
    lHeight = MulDiv(lHeight, 1000, _uCreationScale);
    lHeight = max(lHeight, 2);

    return lHeight;
}

BSTR CTextAnnotation::GetText()
{
    if (_szText == NULL)
        return NULL;

    int nLen = ::MultiByteToWideChar(CP_ACP, 0, _szText, -1, NULL, NULL);

    BSTR bstrResult = ::SysAllocStringLen(NULL, nLen);
    if (bstrResult != NULL)
    {
        ::MultiByteToWideChar(CP_ACP, 0, _szText, -1, bstrResult, nLen);
    }
    return bstrResult;
}

void CTextAnnotation::SetText(BSTR bstrText)
{
    UINT nLen = ::WideCharToMultiByte(CP_ACP, 0, bstrText, -1, NULL, 0, NULL, NULL);
    if (nLen > _nMaxText)
        return;

    if (nLen > _uAnoTextLength)
    {
        if (_szText != NULL)
        {
            delete [] _szText;
        }
        _uAnoTextLength = nLen - 1;
        _szText = new char[_uAnoTextLength+1];
    }

    if (_szText)
        ::WideCharToMultiByte(CP_ACP, 0, bstrText, -1, _szText, nLen, NULL, NULL);
}

void CTextAnnotation::Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise)
{
    RECT rect = _mark.lrBounds;
    RotateHelper((LPPOINT)&rect, 2, nNewImageWidth, nNewImageHeight, bClockwise);
    _mark.lrBounds = rect;
    NormalizeRect(&_mark.lrBounds);
    if (bClockwise)
        _nCurrentOrientation += 2700;
    else
        _nCurrentOrientation += 900;

    _nCurrentOrientation = _nCurrentOrientation % 3600;
}

HRESULT CTextAnnotation::_WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer)
{
    cbSize = _WriteTextBlock(pBuffer,
                             6,
                             _nCurrentOrientation,
                             _uCreationScale,
                             _szText,
                             _nMaxText);
    return S_OK;
}

CTypedTextMark::CTypedTextMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale)
    : CTextAnnotation(pDescriptor, uCreationScale)
{
}


CFileTextMark::CFileTextMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale)
    : CTextAnnotation(pDescriptor, uCreationScale)
{
}


CTextStampMark::CTextStampMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale)
    : CTextAnnotation(pDescriptor, uCreationScale, 255)
{
}

CAttachNoteMark::CAttachNoteMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale)
    : CTextAnnotation(pDescriptor, uCreationScale, 65536, true)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\camdlg\sources.inc ===
!include $(PROJECT_ROOT)\ui\uienv.inc

TARGETNAME=camdlg
TARGETTYPE=LIBRARY
TARGETPATHLIB = $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)

ATL_VER         = 30
USE_STATIC_ATL  = 1

TARGETPATH=$(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)

SOURCES=    ..\camdlg.cpp \
            ..\wiacamd.cpp

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\camdlg\wiacamd.cpp ===
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include <commctrl.h>
#include <objbase.h>
#include "wiadebug.h"
#include "wiadevd.h"
#include "camdlg.rh"
#include "camdlg.h"
#include "pviewids.h"
#include "wiatextc.h"
#include "wiacamd.h"

HRESULT WINAPI CameraDeviceDialog( PDEVICEDIALOGDATA pDialogDeviceData )
{
    HRESULT hr = E_FAIL;
    if (pDialogDeviceData && pDialogDeviceData->cbSize == sizeof(DEVICEDIALOGDATA))
    {
        InitCommonControls();
        RegisterWiaPreviewClasses( g_hInstance );
        CWiaTextControl::RegisterClass(g_hInstance);
        hr = (HRESULT)DialogBoxParam( g_hInstance, MAKEINTRESOURCE(IDD_CAMERA), pDialogDeviceData->hwndParent, CCameraAcquireDialog::DialogProc, (LPARAM)pDialogDeviceData );
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\camdlg\camdlg.cpp ===
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include <wia.h>
#include <wiadef.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <propidl.h>
#include "simstr.h"
#include "camdlg.h"
#include "camdlg.rh"
#include "simcrack.h"
#include "pviewids.h"
#include "dlgunits.h"
#include "miscutil.h"
#include "waitcurs.h"
#include "movewnd.h"
#include "simrect.h"
#include "simbstr.h"
#include "uiexthlp.h"
#include "gwiaevnt.h"
#include "wiacsh.h"
#include "wiadevdp.h"

//
// Thread queue messages
//
#define TQ_DESTROY      (WM_USER+1)
#define TQ_GETTHUMBNAIL (WM_USER+2)
#define TQ_GETPREVIEW   (WM_USER+3)
#define TQ_DELETEITEM   (WM_USER+4)

//
// Control ids
//
#define IDC_TOOLBAR         1112
#define IDC_SIZEBOX         1113

//
// The UI thread will notify us that it took ownership of the data.
// otherwise, it will be deleted in the worker thread
//
#define HANDLED_THREAD_MESSAGE  1000

//
// Help IDs
//
static const DWORD g_HelpIDs[] =
{
    IDC_CAMDLG_BIG_TITLE,     -1,
    IDC_CAMDLG_SUBTITLE,      -1,
    IDC_TOOLBAR_FRAME,        IDH_WIA_BUTTONS,
    IDC_TOOLBAR,              IDH_WIA_BUTTONS,
    IDOK,                     IDH_WIA_GET_PICS,
    IDC_THUMBNAILLIST,        IDH_WIA_PIC_LIST,
    IDC_YOU_CAN_ALSO,         IDH_WIA_VIEW_PIC_INFO,
    IDC_CAMDLG_PROPERTIES,    IDH_WIA_VIEW_PIC_INFO,
    IDC_PREVIEW,              IDH_WIA_PREVIEW_DETAIL,
    IDC_INNER_PREVIEW_WINDOW, IDH_WIA_PREVIEW_DETAIL,
    IDCANCEL,                 IDH_CANCEL,
    0, 0
};

//
// Update timer
//
#define IDT_UPDATEPREVIEW     1000
#define UPDATE_PREVIEW_DELAY   500

//
// Number of milliseconds between percent display updates
//
#define PERCENT_UPDATE_GRANULARITY 1000

//
// Private messages
//
#define PWM_POSTINIT         (WM_USER+1)
#define PWM_CHANGETOPARENT   (WM_USER+2)
#define PWM_THUMBNAILSTATUS  (WM_USER+3)
#define PWM_PREVIEWSTATUS    (WM_USER+4)
#define PWM_PREVIEWPERCENT   (WM_USER+5)
#define PWM_ITEMDELETED      (WM_USER+6)
#define PWM_WIAEVENT         (WM_USER+7)


//
// Thumbnail whitespace: the space in between images and their selection rectangles
// These values were discovered by trail and error.  For instance, if you reduce
// c_nAdditionalMarginY to 20, you get really bizarre spacing problems in the list view
// in vertical mode.  These values could become invalid in future versions of the listview.
//
static const int c_nAdditionalMarginX = 10;
static const int c_nAdditionalMarginY = 6;

static int c_nMinThumbnailWidth  = 90;
static int c_nMinThumbnailHeight = 90;

static int c_nMaxThumbnailWidth  = 120;
static int c_nMaxThumbnailHeight = 120;

//
// Button bar button bitmap sizes
//
static const int c_nButtonBitmapSizeX = 16;
static const int c_nButtonBitmapSizeY = 16;

//
// Button bar button sizes
//
static const int c_nButtonSizeX = 300;  // Ridiculously large size to compensate for BTNS_AUTOSIZE bug.
static const int c_nButtonSizeY = 16;

//
// Default preview mode list width
//
static const int c_nDefaultListViewWidth = 120;

//
// These defines let me compile with pre-nt5 headers
//
#ifndef BTNS_SEP
#define BTNS_SEP TBSTYLE_SEP
#endif

#ifndef BTNS_BUTTON
#define BTNS_BUTTON TBSTYLE_BUTTON
#endif

#ifndef ListView_SetExtendedListViewStyleEx
#define ListView_SetExtendedListViewStyleEx( h, m, s )
#endif


class CGlobalInterfaceTableThreadMessage : public CNotifyThreadMessage
{
private:
    DWORD m_dwGlobalInterfaceTableCookie;

private:
    //
    // No implementation
    //
    CGlobalInterfaceTableThreadMessage(void);
    CGlobalInterfaceTableThreadMessage &operator=( const CGlobalInterfaceTableThreadMessage & );
    CGlobalInterfaceTableThreadMessage( const CGlobalInterfaceTableThreadMessage & );

public:
    CGlobalInterfaceTableThreadMessage( int nMessage, HWND hWndNotify, DWORD dwGlobalInterfaceTableCookie )
      : CNotifyThreadMessage( nMessage, hWndNotify ),
        m_dwGlobalInterfaceTableCookie(dwGlobalInterfaceTableCookie)
    {
    }
    DWORD GlobalInterfaceTableCookie(void) const
    {
        return(m_dwGlobalInterfaceTableCookie);
    }
};


class CThumbnailThreadMessage : public CGlobalInterfaceTableThreadMessage
{
private:
    SIZE  m_sizeThumb;

private:
    //
    // No implementation
    //
    CThumbnailThreadMessage(void);
    CThumbnailThreadMessage &operator=( const CThumbnailThreadMessage & );
    CThumbnailThreadMessage( const CThumbnailThreadMessage & );

public:
    CThumbnailThreadMessage( HWND hWndNotify, DWORD dwGlobalInterfaceTableCookie, const SIZE &sizeThumb )
      : CGlobalInterfaceTableThreadMessage( TQ_GETTHUMBNAIL, hWndNotify, dwGlobalInterfaceTableCookie ),
        m_sizeThumb(sizeThumb)
    {
    }
    const SIZE &ThumbSize(void) const
    {
        return(m_sizeThumb);
    }
};

class CDeleteThreadMessage : public CGlobalInterfaceTableThreadMessage
{
private:
    //
    // No implementation
    //
    CDeleteThreadMessage(void);
    CDeleteThreadMessage &operator=( const CDeleteThreadMessage & );
    CDeleteThreadMessage( const CDeleteThreadMessage & );

public:
    CDeleteThreadMessage( HWND hWndNotify, DWORD dwGlobalInterfaceTableCookie )
      : CGlobalInterfaceTableThreadMessage( TQ_DELETEITEM, hWndNotify, dwGlobalInterfaceTableCookie )
    {
    }
};


class CPreviewThreadMessage : public CGlobalInterfaceTableThreadMessage
{
private:
    CSimpleEvent m_CancelEvent;

private:
    //
    // No implementation
    //
    CPreviewThreadMessage(void);
    CPreviewThreadMessage &operator=( const CPreviewThreadMessage & );
    CPreviewThreadMessage( const CPreviewThreadMessage & );

public:
    CPreviewThreadMessage( HWND hWndNotify, DWORD dwGlobalInterfaceTableCookie, HANDLE hCancelEvent )
      : CGlobalInterfaceTableThreadMessage( TQ_GETPREVIEW, hWndNotify, dwGlobalInterfaceTableCookie ),
        m_CancelEvent(hCancelEvent)
    {
    }
    CSimpleEvent &CancelEvent(void)
    {
        return(m_CancelEvent);
    }
};


BOOL WINAPI CCameraAcquireDialog::OnThreadDestroy( CThreadMessage * )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnThreadDestroy"));
    return(FALSE);
}

BOOL WINAPI CCameraAcquireDialog::OnThreadDeleteItem( CThreadMessage *pMsg )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnThreadDeleteItem"));
    CDeleteThreadMessage *pDeleteMsg = (CDeleteThreadMessage *)(pMsg);
    if (pDeleteMsg)
    {
        CComPtr<IGlobalInterfaceTable> pGlobalInterfaceTable;
        HRESULT hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&pGlobalInterfaceTable);
        if (SUCCEEDED(hr))
        {
            CComPtr<IWiaItem> pIWiaItem;
            hr = pGlobalInterfaceTable->GetInterfaceFromGlobal( pDeleteMsg->GlobalInterfaceTableCookie(), IID_IWiaItem, (void**)&pIWiaItem );
            if (SUCCEEDED(hr))
            {
                hr = WiaUiUtil::DeleteItemAndChildren(pIWiaItem);
                WIA_TRACE((TEXT("********************* pIWiaItem->DeleteItem returned %08X"), hr ));
                PostMessage( pDeleteMsg->NotifyWindow(), PWM_ITEMDELETED, pDeleteMsg->GlobalInterfaceTableCookie(), SUCCEEDED(hr) );
            }
        }
    }
    return(TRUE);
}

class CWiaDataCallback : public IWiaDataCallback
{
private:
    ULONG                   m_cRef;
    HWND                    m_hWndNotify;
    DWORD                   m_dwGlobalInterfaceTableCookie;
    CSimpleEvent            m_CancelEvent;
    DWORD                   m_dwPreviousTickCount;
    int                     m_nPercentGranularity;
public:
    CWiaDataCallback();
    ~CWiaDataCallback();

    HRESULT _stdcall QueryInterface(const IID&,void**);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

    HRESULT _stdcall Initialize( HWND hWndNotify, DWORD dwGlobalInterfaceTableCookie, HANDLE hCancelEvent );

    HRESULT _stdcall BandedDataCallback(
                                       LONG lReason,
                                       LONG lStatus,
                                       LONG lPercentComplete,
                                       LONG lOffset,
                                       LONG lLength,
                                       LONG lReserved,
                                       LONG lResLength,
                                       BYTE *pbBuffer );
};




HRESULT _stdcall CWiaDataCallback::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IWiaDataCallback)
    {
        *ppv = (IWiaDataCallback*)this;
    }
    else
    {
        return(E_NOINTERFACE);
    }

    AddRef();
    return(S_OK);
}

ULONG _stdcall CWiaDataCallback::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return(m_cRef);
}

ULONG _stdcall CWiaDataCallback::Release()
{
    ULONG ulRefCount = m_cRef - 1;
    if (InterlockedDecrement((long*) &m_cRef) == 0)
    {
        delete this;
        return(0);
    }
    return(ulRefCount);
}

CWiaDataCallback::CWiaDataCallback()
  : m_cRef(0),
    m_hWndNotify(NULL)
{
}


CWiaDataCallback::~CWiaDataCallback()
{
}


HRESULT _stdcall CWiaDataCallback::Initialize( HWND hWndNotify, DWORD dwGlobalInterfaceTableCookie, HANDLE hCancelEvent )
{
    m_hWndNotify = hWndNotify;
    m_dwGlobalInterfaceTableCookie = dwGlobalInterfaceTableCookie;
    m_CancelEvent = hCancelEvent;
    m_dwPreviousTickCount = 0xFFFFFF;
    m_nPercentGranularity = 3;
    return(S_OK);
}



HRESULT _stdcall CWiaDataCallback::BandedDataCallback(
                                                     LONG lMessage,
                                                     LONG lStatus,
                                                     LONG lPercentComplete,
                                                     LONG lOffset,
                                                     LONG lLength,
                                                     LONG lReserved,
                                                     LONG lResLength,
                                                     BYTE * /* pbBuffer */
                                                     )
{
    WIA_TRACE((TEXT("BandedDataCallback: lMessage: %d, lStatus: %d, lPercentComplete: %d, lOffset: %d, lLength: %d, lReserved: %d, lResLength: %d"), lMessage, lStatus, lPercentComplete, lOffset, lLength, lReserved, lResLength ));
    if (m_CancelEvent.Signalled())
        return(S_FALSE);
    switch (lMessage)
    {
    case IT_MSG_DATA_HEADER:
        {
        } // IT_MSG_DATA_HEADER

    case IT_MSG_DATA:
        {
        } // IT_STATUS_TRANSFER_TO_CLIENT
        break;

    case IT_MSG_STATUS:
        {
            // Don't send status messages too frequently.  Limit to one per PERCENT_UPDATE_GRANULARITY ms
            DWORD dwTickCount = GetTickCount();
            if ((dwTickCount - m_dwPreviousTickCount >= PERCENT_UPDATE_GRANULARITY) || (m_dwPreviousTickCount > dwTickCount))
            {
                m_dwPreviousTickCount = dwTickCount;
                PostMessage( m_hWndNotify, PWM_PREVIEWPERCENT, (WPARAM)m_dwGlobalInterfaceTableCookie, (LPARAM)MAKELPARAM((WORD)lPercentComplete,(WORD)lStatus));
            }
        } // IT_MSG_STATUS
        break;

    case IT_MSG_TERMINATION:
        {
        } // IT_MSG_TERMINATION
        break;
    }
    return(S_OK);
}


BOOL WINAPI CCameraAcquireDialog::OnGetPreview( CThreadMessage *pMsg )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnGetThumbnail"));
    CSimpleStringWide strwImageName(L"");
    CPreviewThreadMessage *pPreviewMsg = (CPreviewThreadMessage *)(pMsg);
    if (pPreviewMsg)
    {
        CComPtr<IGlobalInterfaceTable> pGlobalInterfaceTable;
        HRESULT hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable,
                                       NULL,
                                       CLSCTX_INPROC_SERVER,
                                       IID_IGlobalInterfaceTable,
                                       (void **)&pGlobalInterfaceTable);
        if (SUCCEEDED(hr))
        {
            CComPtr<IWiaItem> pIWiaItem;
            hr = pGlobalInterfaceTable->GetInterfaceFromGlobal( pPreviewMsg->GlobalInterfaceTableCookie(), IID_IWiaItem, (void**)&pIWiaItem );
            if (SUCCEEDED(hr))
            {
                CComPtr<IWiaDataTransfer> pIBandedTran;
                WIA_TRACE((TEXT("Preparing to call pIWiaItem->QueryInterface for IID_IWiaDataTransfer")));
                hr = pIWiaItem->QueryInterface(IID_IWiaDataTransfer, (void**)&pIBandedTran);
                if (SUCCEEDED(hr))
                {
                    if (PropStorageHelpers::SetProperty( pIWiaItem, WIA_IPA_FORMAT, WiaImgFmt_BMP, WIA_IPA_FIRST ) &&
                        PropStorageHelpers::SetProperty( pIWiaItem, WIA_IPA_TYMED, TYMED_FILE, WIA_IPA_FIRST ))
                    {
                        CWiaDataCallback* pCDataCB = new CWiaDataCallback();
                        WIA_TRACE((TEXT("Preparing to call pCDataCB->Initialize")));
                        if (pCDataCB)
                        {
                            hr = pCDataCB->Initialize( pPreviewMsg->NotifyWindow(), pPreviewMsg->GlobalInterfaceTableCookie(), pPreviewMsg->CancelEvent().Event() );
                            if (SUCCEEDED(hr))
                            {
                                WIA_TRACE((TEXT("Preparing to call pCDataCB->QueryInterface on IID_IWiaDataCallback")));
                                CComPtr<IWiaDataCallback> pIWiaDataCallback;
                                hr = pCDataCB->QueryInterface(IID_IWiaDataCallback,(void **)&pIWiaDataCallback);
                                if (SUCCEEDED(hr))
                                {
                                    STGMEDIUM StgMedium;
                                    StgMedium.tymed          = TYMED_FILE;
                                    StgMedium.pUnkForRelease = NULL;
                                    StgMedium.hGlobal        = NULL;
                                    StgMedium.lpszFileName   = NULL;

                                    WIA_TRACE((TEXT("Preparing to call pIBandedTran->ibtGetData")));
                                    hr = pIBandedTran->idtGetData( &StgMedium, pIWiaDataCallback );
                                    if (SUCCEEDED(hr) && S_FALSE != hr)
                                    {
                                        strwImageName = StgMedium.lpszFileName;
                                        WIA_TRACE((TEXT("pIBandedTran->ibtGetData returned %s"),StgMedium.lpszFileName));
                                    }
                                    else
                                    {
                                        WIA_PRINTHRESULT((hr,TEXT("CCameraAcquireDialog::OnGetPreview, ibtGetData failed")));
                                    }
                                    //
                                    // Prevent leaks by freeing the filename.  We don't call ReleaseStgMeduim, because
                                    // it deletes the file as well.
                                    //
                                    if (SUCCEEDED(hr) && StgMedium.lpszFileName)
                                    {
                                        CoTaskMemFree(StgMedium.lpszFileName);
                                    }
                                }
                                else
                                {
                                    WIA_PRINTHRESULT((hr,TEXT("CCameraAcquireDialog::OnGetPreview, QI of IID_IWiaDataCallback failed")));
                                }
                            }
                            else
                            {
                                WIA_PRINTHRESULT((hr,TEXT("pCDataCB->Initialize failed")));
                            }
                        }
                        else
                        {
                            WIA_ERROR((TEXT("CCameraAcquireDialog::OnGetPreview, new on CWiaDataCallback failed")));
                        }
                    }
                    else
                    {
                        hr = MAKE_HRESULT(3,FACILITY_WIN32,ERROR_INVALID_DATA);
                        WIA_ERROR((TEXT("SetProperty on TYMED or FORMAT failed")));
                    }
                }
                else
                {
                    WIA_PRINTHRESULT((hr,TEXT("CCameraAcquireDialog::OnGetPreview, QI of IID_IWiaDataTransfer failed")));
                }
                WIA_TRACE((TEXT("End CCameraAcquireDialog::OnGetPreviewBandedTransfer")));
            }
        }
        
        //
        // Allocate the filename string to return to the UI thread
        //
        CSimpleString *pstrDibFilename = new CSimpleString( CSimpleStringConvert::NaturalString(strwImageName) );

        //
        // Send the message to the UI thread
        //
        LRESULT lRes = SendMessage( pPreviewMsg->NotifyWindow(), PWM_PREVIEWSTATUS, pPreviewMsg->GlobalInterfaceTableCookie(), reinterpret_cast<LPARAM>(pstrDibFilename));

        //
        // If it fails for any reason, we will clean up to avoid leaks and orphaned temp files
        //
        if (HANDLED_THREAD_MESSAGE != lRes)
        {
            DeleteFile(CSimpleStringConvert::NaturalString(strwImageName));
            if (pstrDibFilename)
            {
                delete pstrDibFilename;
            }
        }

    }

    return(TRUE);
}

BOOL WINAPI CCameraAcquireDialog::OnGetThumbnail( CThreadMessage *pMsg )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnGetThumbnail"));
    HBITMAP hBmpThumbnail = NULL;
    CThumbnailThreadMessage *pThumbMsg = (CThumbnailThreadMessage *)(pMsg);
    if (pThumbMsg)
    {
        CComPtr<IGlobalInterfaceTable> pGlobalInterfaceTable;
        HRESULT hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable,
                                       NULL,
                                       CLSCTX_INPROC_SERVER,
                                       IID_IGlobalInterfaceTable,
                                       (void **)&pGlobalInterfaceTable);
        if (SUCCEEDED(hr))
        {
            CComPtr<IWiaItem> pIWiaItem;
            hr = pGlobalInterfaceTable->GetInterfaceFromGlobal( pThumbMsg->GlobalInterfaceTableCookie(), IID_IWiaItem, (void**)&pIWiaItem );
            if (SUCCEEDED(hr))
            {
#if defined(DBG)
                CSimpleStringWide strItemName;
                PropStorageHelpers::GetProperty( pIWiaItem, WIA_IPA_FULL_ITEM_NAME, strItemName );
                WIA_TRACE((TEXT("Getting thumbnail for %ws (0x%d, 0x%p)"), strItemName.String(), pThumbMsg->GlobalInterfaceTableCookie(), pIWiaItem.p ));
#endif
                CComPtr<IWiaPropertyStorage> pIWiaPropertyStorage;
                hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropertyStorage);
                if (SUCCEEDED(hr))
                {
                    PROPVARIANT PropVar[3];
                    PROPSPEC PropSpec[3];

                    PropSpec[0].ulKind = PRSPEC_PROPID;
                    PropSpec[0].propid = WIA_IPC_THUMB_WIDTH;

                    PropSpec[1].ulKind = PRSPEC_PROPID;
                    PropSpec[1].propid = WIA_IPC_THUMB_HEIGHT;

                    PropSpec[2].ulKind = PRSPEC_PROPID;
                    PropSpec[2].propid = WIA_IPC_THUMBNAIL;
                    hr = pIWiaPropertyStorage->ReadMultiple(ARRAYSIZE(PropSpec),PropSpec,PropVar );
                    if (SUCCEEDED(hr))
                    {
                        WIA_TRACE((TEXT("Attempting to get the thumbnail for GIT entry: %08X, %08X, %08X, %08X"),pThumbMsg->GlobalInterfaceTableCookie(),PropVar[0].vt,PropVar[1].vt,PropVar[2].vt));
                        if ((PropVar[0].vt == VT_I4 || PropVar[0].vt == VT_UI4) &&
                            (PropVar[1].vt == VT_I4 || PropVar[1].vt == VT_UI4) &&
                            (PropVar[2].vt == (VT_UI1|VT_VECTOR)))
                        {
                            UINT nBitmapDataSize = WiaUiUtil::Align(PropVar[0].ulVal*3,sizeof(DWORD)) * PropVar[1].ulVal;
                            if (nBitmapDataSize  <= PropVar[2].caub.cElems)
                            {
                                BITMAPINFO bmi = {0};
                                bmi.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
                                bmi.bmiHeader.biWidth           = PropVar[0].ulVal;
                                bmi.bmiHeader.biHeight          = PropVar[1].ulVal;
                                bmi.bmiHeader.biPlanes          = 1;
                                bmi.bmiHeader.biBitCount        = 24;
                                bmi.bmiHeader.biCompression     = BI_RGB;
                                bmi.bmiHeader.biSizeImage       = 0;
                                bmi.bmiHeader.biXPelsPerMeter   = 0;
                                bmi.bmiHeader.biYPelsPerMeter   = 0;
                                bmi.bmiHeader.biClrUsed         = 0;
                                bmi.bmiHeader.biClrImportant    = 0;

                                HDC hDC = GetDC(NULL);
                                if (hDC)
                                {
                                    PBYTE *pBits;
                                    HBITMAP hDibSection = CreateDIBSection( hDC, &bmi, DIB_RGB_COLORS, (PVOID*)&pBits, NULL, 0 );
                                    if (hDibSection)
                                    {
                                        WIA_TRACE((TEXT("pBits: 0x%p, PropVar[2].caub.pElems: 0x%p, PropVar[2].caub.cElems: %d"), pBits, PropVar[2].caub.pElems, PropVar[2].caub.cElems));
                                        CopyMemory( pBits, PropVar[2].caub.pElems, nBitmapDataSize );
                                        hr = ScaleImage( hDC, hDibSection, hBmpThumbnail, pThumbMsg->ThumbSize());
                                        if (SUCCEEDED(hr))
                                        {
                                            WIA_TRACE((TEXT("Sending this image (%p) to the notification window: %p"), hBmpThumbnail, pThumbMsg->NotifyWindow() ));
                                        }
                                        else hBmpThumbnail = NULL;
                                        DeleteObject(hDibSection);
                                    }
                                    else
                                    {
                                        WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("CreateDIBSection failed")));
                                    }
                                    ReleaseDC(NULL,hDC);
                                }
                                else
                                {
                                    WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("GetDC failed")));
                                }
                            }
                            else
                            {
                                WIA_ERROR((TEXT("nBitmapDataSize <= PropVar[2].caub.cElems was FALSE (%d, %d)"), nBitmapDataSize, PropVar[2].caub.cElems ));
                            }
                        }
                        PropVariantClear(&PropVar[0]);
                        PropVariantClear(&PropVar[1]);
                        PropVariantClear(&PropVar[2]);
                    }
                    else
                    {
                        WIA_PRINTHRESULT((hr,TEXT("pIWiaPropertyStorage->ReadMultiple failed")));
                    }
                }
                else
                {
                    WIA_PRINTHRESULT((hr,TEXT("QueryInterface failed on IID_IWiaPropertyStorage")));
                }
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("GetInterfaceFromGlobal failed on %08X"), pThumbMsg->GlobalInterfaceTableCookie() ));
            }
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("CoCreateInstance failed on CLSID_StdGlobalInterfaceTable")));
        }
        
        //
        // Send the message to the UI thread
        //
        LRESULT lRes = SendMessage( pThumbMsg->NotifyWindow(), PWM_THUMBNAILSTATUS, (WPARAM)pThumbMsg->GlobalInterfaceTableCookie(), (LPARAM)hBmpThumbnail );

        //
        // If it fails for any reason, we will clean up to avoid leaks
        //
        if (HANDLED_THREAD_MESSAGE != lRes)
        {
            if (hBmpThumbnail)
            {
                DeleteObject( hBmpThumbnail );
            }
        }
    }
    else
    {
        WIA_ERROR((TEXT("pThumbMsg")));
    }
    return(TRUE);
}


int CCameraAcquireDialog::FindItemInList( CCameraItem *pItem )
{
    WIA_PUSH_FUNCTION((TEXT("CCameraAcquireDialog::FindItemInList( %08X )"), pItem ));
    if (pItem)
    {
        HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
        if (hwndList)
        {
            for (int i=0;i<ListView_GetItemCount(hwndList);i++)
            {
                CCameraItem *pCurrItem = GetListItemNode(i);
                if (pCurrItem)
                {
                    WIA_TRACE((TEXT("Comparing %08X and %08X [%ws] [%ws]"), pCurrItem, pItem, pCurrItem->FullItemName().String(), pItem->FullItemName().String() ));
                    if (*pCurrItem == *pItem)
                    {
                        return i;
                    }
                }
            }
        }
    }
    return(-1);
}

CCameraItem *CCameraAcquireDialog::GetCurrentPreviewItem(void)
{
    CSimpleDynamicArray<int> aSelIndices;
    GetSelectionIndices(aSelIndices);
    if (0 == aSelIndices.Size())
        return(NULL);
    if (1 == aSelIndices.Size())
        return(GetListItemNode(aSelIndices[0]));
    return(NULL);
}

bool CCameraAcquireDialog::SetCurrentPreviewImage( const CSimpleString &strFilename, const CSimpleString &strTitle )
{
    CWaitCursor wc;
    bool bResult = true;
    SendDlgItemMessage( m_hWnd, IDC_PREVIEW, WM_SETTEXT, 0, (LPARAM)strTitle.String() );
    SIZE sizeSavedAspectRatio = m_CurrentAspectRatio;
    // Set up a reasonable default
    m_CurrentAspectRatio.cx = 4;
    m_CurrentAspectRatio.cy = 3;
    if (strFilename.Length())
    {
        HBITMAP hBmp = (HBITMAP)LoadImage( g_hInstance, strFilename.String(), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION|LR_LOADFROMFILE );
        if (hBmp)
        {
            BITMAP bm;
            if (GetObject( hBmp, sizeof(BITMAP), &bm ))
            {
                m_CurrentAspectRatio.cx = bm.bmWidth;
                m_CurrentAspectRatio.cy = bm.bmHeight;
            }
        }
        SendDlgItemMessage( m_hWnd, IDC_PREVIEW, PWM_SETBITMAP, MAKEWPARAM(FALSE,FALSE), (LPARAM)hBmp );
        if (memcmp(&sizeSavedAspectRatio,&m_CurrentAspectRatio,sizeof(SIZE)))
            ResizeAll();
        bResult = (hBmp != NULL);
    }
    else
    {
        if (SendDlgItemMessage( m_hWnd, IDC_PREVIEW, PWM_GETBITMAP, 0, 0 ))
            SendDlgItemMessage( m_hWnd, IDC_PREVIEW, PWM_SETBITMAP, MAKEWPARAM(FALSE,FALSE), 0 );
        if (memcmp(&sizeSavedAspectRatio,&m_CurrentAspectRatio,sizeof(SIZE)))
            ResizeAll();
    }
    InvalidateRect( GetDlgItem( m_hWnd, IDC_PREVIEW ), NULL, FALSE );
    UpdateWindow( GetDlgItem( m_hWnd, IDC_PREVIEW ) );
    return(bResult);
}

// wParam = GIT cookie
// lParam = nPercent
LRESULT CCameraAcquireDialog::OnPreviewPercent( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnPreviewPercent"));
    CCameraItem *pCameraItem = m_CameraItemList.Find( (DWORD)wParam );
    if (pCameraItem)
    {
        pCameraItem->CurrentPreviewPercentage((int)LOWORD(lParam));
        CCameraItem *pCurrSel = GetCurrentPreviewItem();
        if (pCameraItem == pCurrSel)
        {
            UpdatePreview();
        }
    }
    return(0);
}

// wParam = GIT cookie
// lParam = HBITMAP
LRESULT CCameraAcquireDialog::OnPreviewStatus( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnPreviewStatus"));
    CSimpleString *pstrFilename = reinterpret_cast<CSimpleString*>(lParam);
    if (pstrFilename)
    {
        CCameraItem *pCameraItem = m_CameraItemList.Find( static_cast<DWORD>(wParam) );
        if (pCameraItem)
        {
            if (!pCameraItem->CancelQueueEvent().Signalled())
            {
                // If we weren't cancelled, set the filename
                pCameraItem->PreviewFileName(*pstrFilename);
            }
            pCameraItem->CloseCancelEvent();

            CCameraItem *pCurrSel = GetCurrentPreviewItem();
            if (pCameraItem == pCurrSel)
            {
                SetCurrentPreviewImage( pCameraItem->PreviewFileName() );
            }
        }
        delete pstrFilename;
    }

    return HANDLED_THREAD_MESSAGE;
}

LRESULT CCameraAcquireDialog::OnThumbnailStatus( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnThumbnailStatus"));
    WIA_TRACE((TEXT("Looking for the item with the ID %08X"),wParam));
    CCameraItem *pCameraItem = m_CameraItemList.Find( (DWORD)wParam );
    if (pCameraItem)
    {
        WIA_TRACE((TEXT("Found a CameraItem * (%08X)"),pCameraItem));
        HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
        if (hwndList)
        {
            WIA_TRACE((TEXT("Got the list control")));
            HIMAGELIST hImageList = ListView_GetImageList( hwndList, LVSIL_NORMAL );
            if (hImageList)
            {
                WIA_TRACE((TEXT("Got the image list")));
                if ((HBITMAP)lParam)
                {
                    WIA_TRACE((TEXT("hBitmap = %p"), lParam));
                    if (ImageList_Replace( hImageList, pCameraItem->ImageListIndex(), reinterpret_cast<HBITMAP>(lParam), NULL ))
                    {
                        WIA_TRACE((TEXT("Replaced the image in the list")));
                        int nItem = FindItemInList(pCameraItem);
                        if (nItem >= 0)
                        {
                            WIA_TRACE((TEXT("Found the item in the list")));
                            //
                            // Set the image to a dummy image
                            //
                            LV_ITEM lvItem;
                            ::ZeroMemory(&lvItem,sizeof(LV_ITEM));
                            lvItem.iItem = nItem;
                            lvItem.mask = LVIF_IMAGE;
                            lvItem.iImage = -1;
                            ListView_SetItem( hwndList, &lvItem );

                            //
                            // Then set the image to the real image
                            //
                            ::ZeroMemory(&lvItem,sizeof(LV_ITEM));
                            lvItem.iItem = nItem;
                            lvItem.mask = LVIF_IMAGE;
                            lvItem.iImage = pCameraItem->ImageListIndex();
                            ListView_SetItem( hwndList, &lvItem );
                        }
                    }
                }
            }
        }
    }

    //
    // Clean up the bitmap, regardless of any other failures, to avoid memory leaks
    //
    HBITMAP hBmpThumb = reinterpret_cast<HBITMAP>(lParam);
    if (hBmpThumb)
    {
        DeleteObject(hBmpThumb);
    }
    return HANDLED_THREAD_MESSAGE;
}

static CThreadMessageMap g_MsgMap[] =
{
    { TQ_DESTROY, CCameraAcquireDialog::OnThreadDestroy },
    { TQ_GETTHUMBNAIL, CCameraAcquireDialog::OnGetThumbnail },
    { TQ_GETPREVIEW, CCameraAcquireDialog::OnGetPreview },
    { TQ_DELETEITEM, CCameraAcquireDialog::OnThreadDeleteItem },
    { 0, NULL}
};

//
// Sole constructor
//
CCameraAcquireDialog::CCameraAcquireDialog( HWND hWnd )
  : m_hWnd(hWnd),
    m_bPreviewActive(false),
    m_pCurrentParentItem(NULL),
    m_bFirstTime(true),
    m_hBackgroundThread(NULL),
    m_hBigFont(NULL),
    m_nDialogMode(0),
    m_hAccelTable(NULL),
    m_nListViewWidth(0),
    m_hIconLarge(NULL),
    m_hIconSmall(NULL),
    m_pThreadMessageQueue(NULL),
    m_bTakePictureIsSupported(false),
    m_ToolbarBitmapInfo( g_hInstance, IDB_TOOLBAR )
{
    m_pThreadMessageQueue = new CThreadMessageQueue;
    if (m_pThreadMessageQueue)
    {
        //
        // Note that CBackgroundThread takes ownership of m_pThreadMessageQueue, and it doesn't have to be deleted in this thread
        //
        m_hBackgroundThread = CBackgroundThread::Create( m_pThreadMessageQueue, g_MsgMap, m_CancelEvent.Event(), g_hInstance );
    }
    m_sizeThumbnails.cx = c_nMaxThumbnailWidth;
    m_sizeThumbnails.cy = c_nMaxThumbnailHeight;
    m_CurrentAspectRatio.cx = 4;
    m_CurrentAspectRatio.cy = 3;
    WIA_ASSERT(m_hBackgroundThread != NULL);
}

HWND CCameraAcquireDialog::CreateCameraDialogToolbar(VOID)
{
    ToolbarHelper::CButtonDescriptor aSingleSelModeButtons[] =
    {
        { 0, IDC_ICONMODE,     TBSTATE_ENABLED|TBSTATE_CHECKED, BTNS_AUTOSIZE|BTNS_BUTTON|BTNS_CHECK, true, NULL, IDS_ICONMODE },
        { 1, IDC_PREVIEWMODE,  TBSTATE_ENABLED,                 BTNS_AUTOSIZE|BTNS_BUTTON|BTNS_CHECK, true, NULL, IDS_PREVIEWMODE },
        { 2, IDC_TAKEPICTURE,  TBSTATE_ENABLED,                 BTNS_AUTOSIZE|BTNS_BUTTON, true, &m_bTakePictureIsSupported, IDS_TAKEPICTURE },
        { 4, IDC_DELETE,       TBSTATE_ENABLED,                 BTNS_AUTOSIZE|BTNS_BUTTON, false, NULL, IDS_DELETE_SINGULAR }
    };
    ToolbarHelper::CButtonDescriptor aMultiSelModeButtons[] =
    {
        { 0, IDC_ICONMODE,     TBSTATE_ENABLED|TBSTATE_CHECKED, BTNS_AUTOSIZE|BTNS_BUTTON|BTNS_CHECK, true, NULL, IDS_ICONMODE },
        { 1, IDC_PREVIEWMODE,  TBSTATE_ENABLED,                 BTNS_AUTOSIZE|BTNS_BUTTON|BTNS_CHECK, true, NULL, IDS_PREVIEWMODE },
        { 2, IDC_TAKEPICTURE,  TBSTATE_ENABLED,                 BTNS_AUTOSIZE|BTNS_BUTTON, true, &m_bTakePictureIsSupported, IDS_TAKEPICTURE },
        { 3, IDC_SELECTALL,    TBSTATE_ENABLED,                 BTNS_AUTOSIZE|BTNS_BUTTON, true, NULL, IDS_SELECTALL },
        { 4, IDC_DELETE,       TBSTATE_ENABLED,                 BTNS_AUTOSIZE|BTNS_BUTTON, false, NULL, IDS_DELETE }
    };
    
    ToolbarHelper::CButtonDescriptor *pButtonDescriptors = aSingleSelModeButtons;
    int nButtonDescriptorCount = ARRAYSIZE(aSingleSelModeButtons);
    if (m_nDialogMode & MULTISEL_MODE)
    {
        pButtonDescriptors = aMultiSelModeButtons;
        nButtonDescriptorCount = ARRAYSIZE(aMultiSelModeButtons);
    }
    
    return ToolbarHelper::CreateToolbar( m_hWnd, GetDlgItem( m_hWnd, IDC_CAMDLG_SUBTITLE ), GetDlgItem( m_hWnd, IDC_TOOLBAR_FRAME ), ToolbarHelper::AlignLeft|ToolbarHelper::AlignTop, IDC_TOOLBAR, m_ToolbarBitmapInfo, pButtonDescriptors, nButtonDescriptorCount );
}


HRESULT CCameraAcquireDialog::EnumerateItems( CCameraItem *pCurrentParent, IEnumWiaItem *pIEnumWiaItem )
{
    WIA_PUSHFUNCTION(TEXT("CCameraItemList::EnumerateItems"));
    HRESULT hr = E_FAIL;
    if (pIEnumWiaItem != NULL)
    {
        hr = pIEnumWiaItem->Reset();
        while (hr == S_OK)
        {
            CComPtr<IWiaItem> pIWiaItem;
            hr = pIEnumWiaItem->Next(1, &pIWiaItem, NULL);
            if (hr == S_OK)
            {
                CCameraItem *pNewCameraItem = new CCameraItem( pIWiaItem );
                if (pNewCameraItem && pNewCameraItem->Item())
                {
                    LONG ItemType = 0;
                    hr = pNewCameraItem->Item()->GetItemType(&ItemType);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // If it is an image, add it to the list
                        //
                        if (ItemType & WiaItemTypeImage)
                        {
                            //
                            // Add it to the list
                            //
                            m_CameraItemList.Add( pCurrentParent, pNewCameraItem );
                            WIA_TRACE((TEXT("Found an image")));
                        }

                        //
                        // If it is a folder, enumerate its child items and recurse
                        //
                        else if (ItemType & WiaItemTypeFolder)
                        {
                            //
                            // Add this folder to the list
                            //
                            m_CameraItemList.Add( pCurrentParent, pNewCameraItem );

                            //
                            // Enumerate the child items
                            //
                            CComPtr <IEnumWiaItem> pIEnumChildItem;
                            if (S_OK == pIWiaItem->EnumChildItems(&pIEnumChildItem))
                            {
                                EnumerateItems( pNewCameraItem, pIEnumChildItem );
                            }
                        }
                        else
                        {
                            //
                            // Delete this item, since we didn't add it to the list
                            //
                            delete pNewCameraItem;
                            WIA_TRACE((TEXT("Found something that is NOT an image")));
                        }
                    }
                }
            }
        }
    }
    return hr;
}



HRESULT CCameraAcquireDialog::EnumerateAllCameraItems(void)
{
    CComPtr<IEnumWiaItem> pIEnumItem;
    HRESULT hr = m_pDeviceDialogData->pIWiaItemRoot->EnumChildItems(&pIEnumItem);
    if (hr == S_OK)
    {
        hr = EnumerateItems( NULL, pIEnumItem );
    }
    return(hr);
}

void CCameraAcquireDialog::OnItemCreatedEvent( CGenericWiaEventHandler::CEventMessage *pEventMessage )
{
    //
    // Get the listview, which we'll need later
    //
    HWND hwndListview = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (hwndListview)
    {
        //
        // Get the image list
        //
        HIMAGELIST hImageList = ListView_GetImageList( hwndListview, LVSIL_NORMAL );
        if (hImageList)
        {
            //
            // Make sure we don't already have this item
            //
            CCameraItem *pCreatedItem = m_CameraItemList.Find(CSimpleBStr(pEventMessage->FullItemName()));
            if (!pCreatedItem)
            {
                //
                // Get the IWiaItem* for this item
                //
                CComPtr<IWiaItem> pWiaItem;
                HRESULT hr = m_pDeviceDialogData->pIWiaItemRoot->FindItemByName(0,CSimpleBStr(pEventMessage->FullItemName()).BString(),&pWiaItem);
                if (SUCCEEDED(hr) && pWiaItem.p)
                {
                    //
                    // Create an item wrapper
                    //
                    CCameraItem *pNewCameraItem = new CCameraItem( pWiaItem );
                    if (pNewCameraItem && pNewCameraItem->Item())
                    {
                        //
                        // Add it to the list
                        //
                        m_CameraItemList.Add( NULL, pNewCameraItem );

                        //
                        // Generate a thumbnail
                        //
                        CreateThumbnail( pNewCameraItem, hImageList, false );

                        //
                        // If this item is in the current folder, add it to the listview
                        //
                        if (m_pCurrentParentItem == pNewCameraItem->Parent())
                        {
                            int nListViewCount = ListView_GetItemCount(hwndListview);

                            //
                            // Add the item
                            //
                            LVITEM lvItem = {0};
                            lvItem.iItem = nListViewCount;
                            lvItem.mask = LVIF_IMAGE|LVIF_PARAM;
                            lvItem.iImage = pNewCameraItem->ImageListIndex();
                            lvItem.lParam = reinterpret_cast<LPARAM>(pNewCameraItem);
                            int nIndex = ListView_InsertItem( hwndListview, &lvItem );

                            //
                            // Make sure the new item is visible
                            //
                            if (nIndex >= 0)
                            {
                                ListView_EnsureVisible( hwndListview, nIndex, FALSE );
                            }
                        }

                        //
                        // Request a thumbnail from the background thread
                        //
                        m_pThreadMessageQueue->Enqueue( new CThumbnailThreadMessage( m_hWnd, pNewCameraItem->GlobalInterfaceTableCookie(), m_sizeThumbnails ) );
                    }
                }
            }
        }
    }
}


bool CCameraAcquireDialog::PopulateList( CCameraItem *pOldParent )
{
    //
    // Which item should be selected?
    //
    int nSelItem = 0;

    //
    // Get the list view control
    //
    HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (hwndList)
    {
        //
        // Empty the list
        //
        ListView_DeleteAllItems( hwndList );

        //
        // Where to insert the current item
        //
        int nCurrentItem = 0;


        CCameraItem *pCurr;

        //
        // If this is a child directory...
        //
        if (m_pCurrentParentItem)
        {
            //
            // Start adding children
            //
            pCurr = m_pCurrentParentItem->Children();

            //
            // Insert a dummy item that the user can use to switch to the parent directory
            //
            LVITEM lvItem;
            ZeroMemory( &lvItem, sizeof(lvItem) );
            lvItem.iItem = nCurrentItem++;
            lvItem.mask = LVIF_IMAGE|LVIF_PARAM;
            lvItem.iImage = m_nParentFolderImageListIndex;
            lvItem.lParam = 0;
            ListView_InsertItem( hwndList, &lvItem );
        }
        //
        // Otherwise, we are at the root
        //
        else pCurr = m_CameraItemList.Root();

        //
        // Iterate through this list of images, and add each one
        //
        while (pCurr)
        {
            //
            // If this is the last parent directory, we want it to be selected instead of the first image
            //
            if (pOldParent && *pCurr == *pOldParent)
            {
                nSelItem = nCurrentItem;
            }

            //
            // If this image hasn't been deleted
            //
            if (pCurr->DeleteState() != CCameraItem::Delete_Deleted)
            {
                //
                // Add the item
                //
                LVITEM lvItem = {0};
                lvItem.iItem = nCurrentItem++;
                lvItem.mask = LVIF_IMAGE|LVIF_PARAM;
                lvItem.iImage = pCurr->ImageListIndex();
                lvItem.lParam = reinterpret_cast<LPARAM>(pCurr);
                int nIndex = ListView_InsertItem( hwndList, &lvItem );

                if (nIndex >= 0 && pCurr->DeleteState() == CCameraItem::Delete_Pending)
                {
                    MarkItemDeletePending(nIndex,true);
                }
            }

            //
            // Advance
            //
            pCurr = pCurr->Next();
        }
    }

    //
    // If we've not calculated the width of the list in preview mode, attempt to do it
    //
    if (!m_nListViewWidth)
    {
        RECT rcItem;
        if (ListView_GetItemRect( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ), 0, &rcItem, LVIR_ICON ))
        {
            m_nListViewWidth = (rcItem.right-rcItem.left) + rcItem.left * 2 + GetSystemMetrics(SM_CXHSCROLL)  + c_nAdditionalMarginX;
        }
    }

    //
    // Set the selected item to either the previous directory, or the first image
    //
    SetSelectedListItem(nSelItem);
    return(true);
}

void CCameraAcquireDialog::CreateThumbnail( CCameraItem *pCurr, HIMAGELIST hImageList, bool bForce )
{
    //
    // Make sure we have a valid item
    //
    if (pCurr && (pCurr->ImageListIndex()<0 || bForce))
    {
        //
        // Get the item name
        //
        CSimpleStringWide strItemName;
        PropStorageHelpers::GetProperty( pCurr->Item(), WIA_IPA_ITEM_NAME, strItemName );

        //
        // Create the title for the icon
        //
        CSimpleString strIconTitle;
        if (pCurr->IsFolder())
        {
            strIconTitle = CSimpleStringConvert::NaturalString(strItemName);
        }
        else if (strItemName.Length())
        {
            strIconTitle.Format( IDS_DOWNLOADINGTHUMBNAIL, g_hInstance, CSimpleStringConvert::NaturalString(strItemName).String() );
        }

        //
        // Create the thumbnail
        //
        HBITMAP hBmp = WiaUiUtil::CreateIconThumbnail( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ), m_sizeThumbnails.cx, m_sizeThumbnails.cy, g_hInstance, pCurr->IsImage()?IDI_UNAVAILABLE:IDI_FOLDER, strIconTitle );
        if (hBmp)
        {
            //
            // If we don't have an image yet, add it
            //
            if (pCurr->ImageListIndex()<0)
            {
                pCurr->ImageListIndex(ImageList_Add( hImageList, hBmp, NULL ));
            }

            //
            // Otherwise, replace it
            //
            else
            {
                pCurr->ImageListIndex(ImageList_Replace( hImageList, pCurr->ImageListIndex(), hBmp, NULL ));
            }

            //
            // Delete it, since the imagelist makes a copy
            //
            DeleteObject(hBmp);
        }
    }
}

void CCameraAcquireDialog::CreateThumbnails( CCameraItem *pRoot, HIMAGELIST hImageList, bool bForce )
{
    CCameraItem *pCurr = pRoot;
    while (pCurr)
    {
        //
        // Create the thumbnail
        //
        CreateThumbnail( pCurr, hImageList, bForce );

        //
        // If there are children, recurse into that list
        //
        CreateThumbnails( pCurr->Children(), hImageList, bForce );

        //
        // Advance
        //
        pCurr = pCurr->Next();
    }
}


void CCameraAcquireDialog::RequestThumbnails( CCameraItem *pRoot )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::RequestThumbnails"));
    CCameraItem *pCurr = pRoot;
    while (pCurr)
    {
        if (pCurr->IsImage())
        {
            m_pThreadMessageQueue->Enqueue( new CThumbnailThreadMessage( m_hWnd, pCurr->GlobalInterfaceTableCookie(), m_sizeThumbnails ) );
        }
        if (pCurr->Children())
        {
            RequestThumbnails( pCurr->Children() );
        }
        pCurr = pCurr->Next();
    }
}


void CCameraAcquireDialog::CreateThumbnails( bool bForce )
{
    HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (hwndList)
    {
        HIMAGELIST hImageList = ListView_GetImageList( hwndList, LVSIL_NORMAL );
        if (hImageList)
        {
            //
            // Create the parent folder image
            //
            HBITMAP hParentBitmap = WiaUiUtil::CreateIconThumbnail( hwndList, m_sizeThumbnails.cx, m_sizeThumbnails.cy, g_hInstance, IDI_PARENTFOLDER, TEXT("(..)") );
            if (hParentBitmap)
            {
                m_nParentFolderImageListIndex = ImageList_Add( hImageList, hParentBitmap, NULL );
                DeleteObject(hParentBitmap);
            }
            CCameraAcquireDialog::CreateThumbnails( m_CameraItemList.Root(), hImageList, bForce );
        }
    }
}

bool CCameraAcquireDialog::FindMaximumThumbnailSize(void)
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::FindMaximumThumbnailSize"));
    bool bResult = false;
    if (m_pDeviceDialogData && m_pDeviceDialogData->pIWiaItemRoot)
    {
        LONG nWidth, nHeight;
        if (PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPC_THUMB_WIDTH, nWidth ) &&
            PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPC_THUMB_WIDTH, nHeight ))
        {
            m_sizeThumbnails.cx = max(c_nMinThumbnailWidth,min(nWidth,c_nMaxThumbnailWidth));
            m_sizeThumbnails.cy = max(c_nMinThumbnailHeight,min(nHeight,c_nMaxThumbnailHeight));
        }
        else WIA_TRACE((TEXT("FindMaximumThumbnailSize: Unable to retrieve thumbnail size for device")));
    }
    return(bResult && m_sizeThumbnails.cx && m_sizeThumbnails.cy);
}

//
// Hook procedure and static variables used to handle accelerators
//
LRESULT CALLBACK CCameraAcquireDialog::DialogHookProc( int nCode, WPARAM wParam, LPARAM lParam )
{
    if (nCode < 0) 
        return CallNextHookEx( s_hMessageHook, nCode, wParam, lParam );
    if (nCode == MSGF_DIALOGBOX)
    {
        MSG *pMsg = reinterpret_cast<MSG*>(lParam);
        if (pMsg)
        {
            if (pMsg->hwnd == s_hWndDialog || (s_hWndDialog && IsChild(s_hWndDialog,pMsg->hwnd)))
            {
                CCameraAcquireDialog *pCameraAcquireDialog = reinterpret_cast<CCameraAcquireDialog*>(GetWindowLongPtr(s_hWndDialog,DWLP_USER));
                if (pCameraAcquireDialog && pCameraAcquireDialog->m_hAccelTable)
                {
                    if (TranslateAccelerator(s_hWndDialog,pCameraAcquireDialog->m_hAccelTable,pMsg))
                        return 1; // Ensure the window won't process the message
                }
            }
        }
    }
    return CallNextHookEx( s_hMessageHook, nCode, wParam, lParam );
}


LRESULT CCameraAcquireDialog::OnInitDialog( WPARAM, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnInitDialog"));
    CWaitCursor wc;

    //
    // Make sure the background queue was successfully created
    //
    if (!m_pThreadMessageQueue)
    {
        WIA_ERROR((TEXT("CAMDLG: unable to start background queue")));
        EndDialog( m_hWnd, E_OUTOFMEMORY );
        return(0);
    }

    m_pDeviceDialogData = (PDEVICEDIALOGDATA)lParam;

    // Save the window handle for the hook
    s_hWndDialog = m_hWnd;

    // Install the message hook, which we use for accelerator support
    s_hMessageHook = SetWindowsHookEx( WH_MSGFILTER, DialogHookProc, g_hInstance, GetCurrentThreadId() );
    if (!s_hMessageHook)
    {
        WIA_ERROR((TEXT("CAMDLG: Unable to set thread msg hook")));
        EndDialog( m_hWnd, HRESULT_FROM_WIN32(GetLastError()));
        return(0);
    }

    // Make sure we have valid arguments
    if (!m_pDeviceDialogData)
    {
        WIA_ERROR((TEXT("CAMDLG: Invalid paramater: PDEVICEDIALOGDATA")));
        EndDialog( m_hWnd, E_INVALIDARG );
        return(0);
    }

    // Initialialize our return stuff
    if (m_pDeviceDialogData)
    {
        m_pDeviceDialogData->lItemCount = 0;
        m_pDeviceDialogData->ppWiaItems = NULL;
    }

    // Make sure we have valid a valid device
    if (!m_pDeviceDialogData->pIWiaItemRoot)
    {
        WIA_ERROR((TEXT("CAMDLG: Invalid paramaters: pIWiaItem")));
        EndDialog( m_hWnd, E_INVALIDARG );
        return(0);
    }

    //
    // Find out if Take Picture is supported
    //
    m_bTakePictureIsSupported = WiaUiUtil::IsDeviceCommandSupported( m_pDeviceDialogData->pIWiaItemRoot, WIA_CMD_TAKE_PICTURE );

    // Prevent multiple selection
    if (m_pDeviceDialogData->dwFlags & WIA_DEVICE_DIALOG_SINGLE_IMAGE)
    {
        LONG_PTR lStyle = GetWindowLongPtr( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ), GWL_STYLE );
        SetWindowLongPtr( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ), GWL_STYLE, lStyle | LVS_SINGLESEL );

        // Set the single sel titles
        CSimpleString( IDS_TITLE_SINGLE_SEL, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_CAMDLG_BIG_TITLE ) );
        CSimpleString( IDS_SUBTITLE_SINGLE_SEL, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_CAMDLG_SUBTITLE ) );
        CSimpleString( IDS_OK_SINGLE_SEL, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDOK ) );
        m_nDialogMode = SINGLESEL_MODE;
    }
    else
    {
        // Set the multi sel subtitle
        CSimpleString( IDS_TITLE_MULTI_SEL, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_CAMDLG_BIG_TITLE ) );
        CSimpleString( IDS_SUBTITLE_MULTI_SEL, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_CAMDLG_SUBTITLE ) );
        CSimpleString( IDS_OK_MULTI_SEL, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDOK ) );
        m_nDialogMode = MULTISEL_MODE;
    }


    // Make the lovely font
    m_hBigFont = WiaUiUtil::CreateFontWithPointSizeFromWindow( GetDlgItem(m_hWnd,IDC_CAMDLG_BIG_TITLE), 14, false, false );
    if (m_hBigFont)
        SendDlgItemMessage( m_hWnd, IDC_CAMDLG_BIG_TITLE, WM_SETFONT, reinterpret_cast<WPARAM>(m_hBigFont), MAKELPARAM(TRUE,0));


    // Create the Tool Bar and resize the dialog to accommodate it
    (void)CreateCameraDialogToolbar();

    // Get the minimum size of the dialog
    RECT rcWindow;
    GetWindowRect( m_hWnd, &rcWindow );
    m_sizeMinimumWindow.cx = rcWindow.right - rcWindow.left;
    m_sizeMinimumWindow.cy = rcWindow.bottom - rcWindow.top;

    // Initialize the preview control
    WiaPreviewControl_AllowNullSelection( GetDlgItem( m_hWnd, IDC_PREVIEW ), TRUE );
    WiaPreviewControl_ClearSelection( GetDlgItem( m_hWnd, IDC_PREVIEW ) );
    WiaPreviewControl_DisableSelection( GetDlgItem( m_hWnd, IDC_PREVIEW ), TRUE );
    WiaPreviewControl_SetBorderSize( GetDlgItem( m_hWnd, IDC_PREVIEW ), FALSE, FALSE, 0 );
    WiaPreviewControl_SetBgAlpha( GetDlgItem( m_hWnd, IDC_PREVIEW ), FALSE, 0xFF );

    // Set the lovely title
    CSimpleStringWide strwDeviceName;
    if (PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DIP_DEV_NAME, strwDeviceName ))
    {
        CSimpleString().Format( IDS_CAMERADLG_TITLE, g_hInstance, strwDeviceName.String() ).SetWindowText( m_hWnd );
    }

    // Create the sizing control
    (void)CreateWindowEx( 0, TEXT("scrollbar"), TEXT(""),
        WS_CHILD|WS_VISIBLE|SBS_SIZEGRIP|WS_CLIPSIBLINGS|SBS_SIZEBOXBOTTOMRIGHTALIGN|SBS_BOTTOMALIGN|WS_GROUP,
        CSimpleRect(m_hWnd).Width()-GetSystemMetrics(SM_CXVSCROLL),
        CSimpleRect(m_hWnd).Height()-GetSystemMetrics(SM_CYHSCROLL),
        GetSystemMetrics(SM_CXVSCROLL),
        GetSystemMetrics(SM_CYHSCROLL),
        m_hWnd, reinterpret_cast<HMENU>(IDC_SIZEBOX),
        g_hInstance, NULL );

    // Reposition all the controls
    ResizeAll();

    // Center the window over its parent
    WiaUiUtil::CenterWindow( m_hWnd, GetParent(m_hWnd) );

    // Get the device icons and set the window icons
    CSimpleStringWide strwDeviceId, strwClassId;
    LONG nDeviceType;
    if (PropStorageHelpers::GetProperty(m_pDeviceDialogData->pIWiaItemRoot,WIA_DIP_UI_CLSID,strwClassId) &&
        PropStorageHelpers::GetProperty(m_pDeviceDialogData->pIWiaItemRoot,WIA_DIP_DEV_ID,strwDeviceId) &&
        PropStorageHelpers::GetProperty(m_pDeviceDialogData->pIWiaItemRoot,WIA_DIP_DEV_TYPE,nDeviceType))
    {
        //
        // Register for disconnect event
        //
        CGenericWiaEventHandler::RegisterForWiaEvent( strwDeviceId.String(), WIA_EVENT_DEVICE_DISCONNECTED, &m_DisconnectEvent, m_hWnd, PWM_WIAEVENT );
        CGenericWiaEventHandler::RegisterForWiaEvent( strwDeviceId.String(), WIA_EVENT_ITEM_DELETED, &m_DeleteItemEvent, m_hWnd, PWM_WIAEVENT );
        CGenericWiaEventHandler::RegisterForWiaEvent( strwDeviceId.String(), WIA_EVENT_ITEM_CREATED, &m_CreateItemEvent, m_hWnd, PWM_WIAEVENT );

        if (SUCCEEDED(WiaUiExtensionHelper::GetDeviceIcons( CSimpleBStr(strwClassId), nDeviceType, &m_hIconSmall, &m_hIconLarge )))
        {
            if (m_hIconSmall)
            {
                SendMessage( m_hWnd, WM_SETICON, ICON_SMALL, reinterpret_cast<LPARAM>(m_hIconSmall) );
            }
            if (m_hIconLarge)
            {
                SendMessage( m_hWnd, WM_SETICON, ICON_BIG, reinterpret_cast<LPARAM>(m_hIconLarge) );
            }
        }
    }

    int nAcceleratorCount = 0;
    ACCEL Accelerators[10];
    //
    // Load the accelerator table resource and convert it to an ACCEL array
    //
    HACCEL hAccel = LoadAccelerators( g_hInstance, MAKEINTRESOURCE(IDR_CAMERA_ACCEL) );
    if (hAccel)
    {
        //
        // Copy the accelerator table to an array of ACCEL
        //
        nAcceleratorCount = CopyAcceleratorTable( hAccel, Accelerators, ARRAYSIZE(Accelerators) );

        //
        // Free the accelerator table
        //
        DestroyAcceleratorTable( hAccel );
    }

    //
    // Create the accelerator table for the toolbar
    //
    nAcceleratorCount += ToolbarHelper::GetButtonBarAccelerators( GetDlgItem( m_hWnd, IDC_TOOLBAR ), Accelerators+nAcceleratorCount, ARRAYSIZE(Accelerators)-nAcceleratorCount );
    if (nAcceleratorCount)
    {
        m_hAccelTable = CreateAcceleratorTable( Accelerators, nAcceleratorCount );
        if (!m_hAccelTable)
        {
            WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("CreateAcceleratorTable failed")));
        }
    }

    SetForegroundWindow(m_hWnd);

    //
    // Make sure the listview has the focus
    //
    SetFocus( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ) );

    return (TRUE);
}

VOID CCameraAcquireDialog::ResizeAll(VOID)
{
    CSimpleRect rcClient(m_hWnd);
    CMoveWindow mw;
    CDialogUnits dialogUnits(m_hWnd);

    // Resize the big title
    mw.Size( GetDlgItem( m_hWnd, IDC_CAMDLG_BIG_TITLE ),
             rcClient.Width() - dialogUnits.StandardMargin().cx * 2,
             0,
             CMoveWindow::NO_SIZEY );

    // Resize the subtitle
    mw.Size( GetDlgItem( m_hWnd, IDC_CAMDLG_SUBTITLE ),
             rcClient.Width() - dialogUnits.StandardMargin().cx * 2,
             0,
             CMoveWindow::NO_SIZEY );

    int nToolBarHeight = (int)(HIWORD((DWORD)(SendMessage(GetDlgItem( m_hWnd, IDC_TOOLBAR ), TB_GETBUTTONSIZE, 0,0))));

    // Resize the toolbar frame
    mw.Size( GetDlgItem(m_hWnd,IDC_TOOLBAR_FRAME),
             rcClient.Width() - dialogUnits.StandardMargin().cx * 2,
             nToolBarHeight + 4,
             0 );

    // Get the dialog's client coordinates of the toolbar frame's client rect
    CSimpleRect rcToolbarFrameInside( GetDlgItem(m_hWnd,IDC_TOOLBAR_FRAME), CSimpleRect::ClientRect );
    rcToolbarFrameInside = rcToolbarFrameInside.ClientToScreen(GetDlgItem(m_hWnd,IDC_TOOLBAR_FRAME));
    rcToolbarFrameInside = rcToolbarFrameInside.ScreenToClient(m_hWnd);

    // Move and resize the toolbar
    mw.SizeMove( GetDlgItem( m_hWnd, IDC_TOOLBAR ),
                 rcToolbarFrameInside.left + 2,
                 rcToolbarFrameInside.top + 2,
                 rcClient.Width() - dialogUnits.StandardMargin().cx * 2 - 4,
                 nToolBarHeight,
                 0 );

    // Save the bottom of this control for later
    int nBottomOfToolbarFrame = CSimpleRect( GetDlgItem(m_hWnd,IDC_TOOLBAR_FRAME), CSimpleRect::WindowRect ).ScreenToClient(m_hWnd).top + nToolBarHeight + 4;


    // Move the Properties control
    mw.SizeMove( GetDlgItem( m_hWnd, IDC_CAMDLG_PROPERTIES ),
                 0,
                 rcClient.Height() - dialogUnits.StandardMargin().cy - dialogUnits.Y(8) + 2,
                 dialogUnits.StandardMargin().cx,
                 dialogUnits.Y(8) + 2,
                 CMoveWindow::NO_MOVEX|CMoveWindow::NO_SIZEX );

    // Move the static text above it
    mw.Move( GetDlgItem( m_hWnd, IDC_YOU_CAN_ALSO ),
             dialogUnits.StandardMargin().cx,
             rcClient.Height() - dialogUnits.StandardMargin().cy - dialogUnits.Y(8) - 2 - dialogUnits.Y(8)
           );


    CSimpleRect rcOK( GetDlgItem( m_hWnd, IDOK ), CSimpleRect::WindowRect );
    CSimpleRect rcCancel( GetDlgItem( m_hWnd, IDOK ), CSimpleRect::WindowRect );

    // Move the OK button
    mw.Move( GetDlgItem( m_hWnd, IDOK ),
             rcClient.Width() - dialogUnits.StandardMargin().cx - dialogUnits.StandardButtonMargin().cx - rcCancel.Width() - rcOK.Width(),
             rcClient.Height() - dialogUnits.StandardMargin().cy - rcOK.Height(),
             0 );

    // Move the cancel button
    mw.Move( GetDlgItem( m_hWnd, IDCANCEL ),
             rcClient.Width() - dialogUnits.StandardMargin().cx - rcCancel.Width(),
             rcClient.Height() - dialogUnits.StandardMargin().cy - rcCancel.Height(),
             0 );

    // Move the resizing handle
    mw.Move( GetDlgItem( m_hWnd, IDC_SIZEBOX ),
             rcClient.Width() - GetSystemMetrics(SM_CXVSCROLL),
             rcClient.Height() - GetSystemMetrics(SM_CYHSCROLL)
             );

    int nHeightOfBottomControls =
        dialogUnits.Y(8) + 2 +            // Highlight control
        dialogUnits.Y(8) +                // Static description text
        dialogUnits.StandardMargin().cy;  // Top of these controls

    CSimpleRect rcAvailableArea(
        dialogUnits.StandardMargin().cx,
        nBottomOfToolbarFrame + dialogUnits.StandardMargin().cy,
        rcClient.right - dialogUnits.StandardMargin().cx,
        rcClient.bottom - nHeightOfBottomControls - dialogUnits.StandardMargin().cy
        );

    if (m_bPreviewActive)
    {
        // If we've already calculated the actual width of the preview mode list, use it, otherwise use the default
        int nListViewWidth = m_nListViewWidth ? m_nListViewWidth : c_nDefaultListViewWidth;

        // Move the thumbnail list
        mw.SizeMove( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ),
                     rcAvailableArea.left,
                     rcAvailableArea.top,
                     nListViewWidth,
                     rcAvailableArea.Height()
                   );

        // Remove the rect of the list view from the preview area
        rcAvailableArea.left += nListViewWidth + dialogUnits.StandardMargin().cx;

        // Use up the remaining area
        mw.SizeMove( GetDlgItem( m_hWnd, IDC_PREVIEW ),
                     rcAvailableArea.left,
                     rcAvailableArea.top,
                     rcAvailableArea.Width(),
                     rcAvailableArea.Height() );

    }
    else
    {
        // Move the thumbnail list
        mw.SizeMove( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ),
                     rcAvailableArea.left,
                     rcAvailableArea.top,
                     rcAvailableArea.Width(),
                     rcAvailableArea.Height()
                   );

    }

    // Explicitly apply the moves, because the toolbar frame doesn't get painted properly
    mw.Apply();

    if (m_bPreviewActive)
    {
        // Show the preview in case it isn't visible
        mw.Show( GetDlgItem( m_hWnd, IDC_PREVIEW ) );
    }
    else
    {
        // Hide the preview in case it is visible
        mw.Hide( GetDlgItem( m_hWnd, IDC_PREVIEW ) );
    }

    //
    // Update the dialog's background to remove any weird stuff left behind
    //
    InvalidateRect( m_hWnd, NULL, FALSE );
    UpdateWindow( m_hWnd );
}


LRESULT CCameraAcquireDialog::OnItemDeleted( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnItemDeleted"));
    CCameraItem *pDeletedItem = m_CameraItemList.Find((DWORD)wParam);
    if (pDeletedItem)
    {
        BOOL bSuccess = (BOOL)lParam;
        pDeletedItem->DeleteState( bSuccess ? CCameraItem::Delete_Deleted : CCameraItem::Delete_Visible );
        if (pDeletedItem == m_pCurrentParentItem)
        {
            ChangeFolder(m_pCurrentParentItem->Parent());
        }

        int nIndex = FindItemInList(pDeletedItem);
        if (nIndex >= 0)
        {
            if (bSuccess)
            {
                // Remove the item from the list
                ListView_DeleteItem(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ),nIndex);

                // Make sure we leave something selected
                if (!ListView_GetSelectedCount(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST )))
                {
                    int nItemCount = ListView_GetItemCount(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ));
                    if (nItemCount)
                    {
                        if (nIndex >= nItemCount)
                            nIndex = nItemCount-1;
                        SetSelectedListItem(nIndex);
                    }
                }
                else
                {
                    // Make sure we update control's state when the list is empty
                    HandleSelectionChange();
                }
            }
            else
            {
                // If the delete failed, remove the deleted state
                MarkItemDeletePending(nIndex,false);

                // Tell the user
                MessageBeep( MB_ICONASTERISK );
            }
        }
    }
    return (0);
}

LRESULT CCameraAcquireDialog::OnWiaEvent( WPARAM, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnWiaEvent"));
    CGenericWiaEventHandler::CEventMessage *pEventMessage = reinterpret_cast<CGenericWiaEventHandler::CEventMessage *>(lParam);
    if (pEventMessage)
    {
        if (pEventMessage->EventId() == WIA_EVENT_DEVICE_DISCONNECTED)
        {
            WIA_TRACE((TEXT("Received disconnect event")));
            EndDialog( m_hWnd, WIA_ERROR_OFFLINE );
        }
        else if (pEventMessage->EventId() == WIA_EVENT_ITEM_CREATED)
        {
            OnItemCreatedEvent( pEventMessage );
        }
        else if (pEventMessage->EventId() == WIA_EVENT_ITEM_DELETED)
        {
            WIA_TRACE((TEXT("Received deleted item event")));

            CCameraItem *pDeletedItem = m_CameraItemList.Find(CSimpleBStr(pEventMessage->FullItemName()));
            if (pDeletedItem)
            {
                //
                // If we're deleting the current parent item,
                // select a new one.
                //
                if (pDeletedItem == m_pCurrentParentItem)
                {
                    ChangeFolder(m_pCurrentParentItem->Parent());
                }

                int nIndex = FindItemInList(pDeletedItem);
                if (nIndex >= 0)
                {
                    //
                    // Remove the item from the listview
                    //
                    ListView_DeleteItem(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ),nIndex);

                    //
                    // Make sure we leave something selected
                    //
                    if (!ListView_GetSelectedCount(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST )))
                    {
                        int nItemCount = ListView_GetItemCount(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ));
                        if (nItemCount)
                        {
                            if (nIndex >= nItemCount)
                            {
                                nIndex = nItemCount-1;
                            }

                            SetSelectedListItem(nIndex);
                        }
                    }
                    else
                    {
                        //
                        // Make sure we update control's state when the list is empty
                        //
                        HandleSelectionChange();
                    }
                }
                else
                {
                    WIA_ERROR((TEXT("FindItemInList coulnd't find the item")));
                }

                //
                // Mark the item as deleted.
                //
                pDeletedItem->DeleteState( CCameraItem::Delete_Deleted );

            }
            else
            {
                WIA_ERROR((TEXT("The item could not be found in m_CameraItemList")));
            }
        }
        delete pEventMessage;
    }
    return HANDLED_EVENT_MESSAGE;
}


LRESULT CCameraAcquireDialog::OnEnterSizeMove( WPARAM, LPARAM )
{
    SendDlgItemMessage( m_hWnd, IDC_PREVIEW, WM_ENTERSIZEMOVE, 0, 0 );
    return(0);
}


LRESULT CCameraAcquireDialog::OnExitSizeMove( WPARAM, LPARAM )
{
    SendDlgItemMessage( m_hWnd, IDC_PREVIEW, WM_EXITSIZEMOVE, 0, 0 );
    return(0);
}


LRESULT CCameraAcquireDialog::OnSize( WPARAM, LPARAM )
{
    ResizeAll();
    return(0);
}


LRESULT CCameraAcquireDialog::OnShow( WPARAM, LPARAM )
{
    if (m_bFirstTime)
    {
        PostMessage( m_hWnd, PWM_POSTINIT, 0, 0 );
        m_bFirstTime = false;
    }
    return(0);
}


LRESULT CCameraAcquireDialog::OnGetMinMaxInfo( WPARAM, LPARAM lParam )
{
    LPMINMAXINFO pMinMaxInfo = (LPMINMAXINFO)lParam;
    pMinMaxInfo->ptMinTrackSize.x = m_sizeMinimumWindow.cx;
    pMinMaxInfo->ptMinTrackSize.y = m_sizeMinimumWindow.cy;
    return(0);
}


LRESULT CCameraAcquireDialog::OnDestroy( WPARAM, LPARAM )
{
    //
    // Get rid of all preview requests
    //
    CancelAllPreviewRequests( m_CameraItemList.Root() );

    //
    // Tell the background thread to destroy itself
    //
    m_pThreadMessageQueue->Enqueue( new CThreadMessage(TQ_DESTROY),CThreadMessageQueue::PriorityUrgent);

    //
    // Set the window icon to NULL
    //
    SendMessage( m_hWnd, WM_SETICON, ICON_BIG, 0 );
    SendMessage( m_hWnd, WM_SETICON, ICON_SMALL, 0 );

    //
    // Clear the image list and list view.  This should be unnecessary, but BoundsChecker
    // complains if I don't do it.
    //
    HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (hwndList)
    {
        ListView_DeleteAllItems(hwndList);

        HIMAGELIST hImgList = ListView_SetImageList( hwndList, NULL, LVSIL_NORMAL );
        if (hImgList)
        {
            ImageList_Destroy(hImgList);
        }
    }


    //
    // Delete resources
    //
    if (m_hBigFont)
    {
        DeleteObject(m_hBigFont);
        m_hBigFont = NULL;
    }
    if (m_hImageList)
    {
        m_hImageList = NULL;
    }
    if (m_hAccelTable)
    {
        DestroyAcceleratorTable(m_hAccelTable);
        m_hAccelTable = NULL;
    }
    if (s_hMessageHook)
    {
        UnhookWindowsHookEx(s_hMessageHook);
        s_hMessageHook = NULL;
    }
    if (m_hIconLarge)
    {
        DestroyIcon(m_hIconLarge);
        m_hIconLarge = NULL;
    }
    if (m_hIconSmall)
    {
        DestroyIcon(m_hIconSmall);
        m_hIconSmall = NULL;
    }
    if (m_hBackgroundThread)
    {
        CloseHandle(m_hBackgroundThread);
        m_hBackgroundThread = NULL;
    }
    return(0);
}



VOID CCameraAcquireDialog::OnPreviewMode( WPARAM, LPARAM )
{
    m_bPreviewActive = true;
    SendDlgItemMessage( m_hWnd, IDC_TOOLBAR, TB_SETSTATE, IDC_PREVIEWMODE, MAKELONG(TBSTATE_ENABLED|TBSTATE_CHECKED,0) );
    SendDlgItemMessage( m_hWnd, IDC_TOOLBAR, TB_SETSTATE, IDC_ICONMODE, MAKELONG(TBSTATE_ENABLED,0) );
    ResizeAll();
    UpdatePreview();
}

VOID CCameraAcquireDialog::OnTakePicture( WPARAM, LPARAM )
{
    //
    // Tell the device to snap a picture
    //
    if (m_pDeviceDialogData->pIWiaItemRoot && m_bTakePictureIsSupported)
    {
        CWaitCursor wc;
        CComPtr<IWiaItem> pNewWiaItem;
        m_pDeviceDialogData->pIWiaItemRoot->DeviceCommand(0,&WIA_CMD_TAKE_PICTURE,&pNewWiaItem);
    }
}

VOID CCameraAcquireDialog::OnIconMode( WPARAM, LPARAM )
{
    m_bPreviewActive = false;
    SendDlgItemMessage( m_hWnd, IDC_TOOLBAR, TB_SETSTATE, IDC_ICONMODE, MAKELONG(TBSTATE_ENABLED|TBSTATE_CHECKED,0) );
    SendDlgItemMessage( m_hWnd, IDC_TOOLBAR, TB_SETSTATE, IDC_PREVIEWMODE, MAKELONG(TBSTATE_ENABLED,0) );
    ResizeAll();
    UpdatePreview();
}

LRESULT CCameraAcquireDialog::OnPostInit( WPARAM, LPARAM )
{
    //
    // Create the progress dialog
    //
    CComPtr<IWiaProgressDialog> pWiaProgressDialog;
    HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaProgressDialog, (void**)&pWiaProgressDialog );
    if (SUCCEEDED(hr))
    {
        //
        // Initialize the progress dialog
        //
        pWiaProgressDialog->Create( m_hWnd, WIA_PROGRESSDLG_ANIM_CAMERA_COMMUNICATE|WIA_PROGRESSDLG_NO_PROGRESS|WIA_PROGRESSDLG_NO_CANCEL|WIA_PROGRESSDLG_NO_TITLE );
        pWiaProgressDialog->SetTitle( CSimpleStringConvert::WideString(CSimpleString(IDS_CAMDLG_PROGDLG_TITLE,g_hInstance)));
        pWiaProgressDialog->SetMessage( CSimpleStringConvert::WideString(CSimpleString(IDS_CAMDLG_PROGDLG_MESSAGE,g_hInstance)));

        //
        // Show the progress dialog
        //
        pWiaProgressDialog->Show();

        //
        // Find all of the images in the camera
        //
        EnumerateAllCameraItems();

        //
        // Find the largest possible thumbnail
        //
        FindMaximumThumbnailSize();

        //
        // Initialize Thumbnail Listview control
        //
        HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
        if (hwndList)
        {
            //
            // Get rid of the border and icon labels
            //
            ListView_SetExtendedListViewStyleEx( hwndList, LVS_EX_BORDERSELECT|LVS_EX_HIDELABELS|LVS_EX_DOUBLEBUFFER, LVS_EX_BORDERSELECT|LVS_EX_HIDELABELS|LVS_EX_DOUBLEBUFFER );

            //
            // Create the large image list
            //
            m_hImageList = ImageList_Create( m_sizeThumbnails.cx, m_sizeThumbnails.cy, ILC_COLOR24|ILC_MIRROR, 50, 50 );
            if (m_hImageList)
            {

                //
                // Set the image list
                //
                ListView_SetImageList( hwndList, m_hImageList, LVSIL_NORMAL );
            }

            //
            // Set the icon spacing
            //
            ListView_SetIconSpacing( hwndList, m_sizeThumbnails.cx + c_nAdditionalMarginX, m_sizeThumbnails.cy + c_nAdditionalMarginY );
        }

        //
        // Create all of the initial thumbnails
        //
        CreateThumbnails();

        //
        // This causes the list to be populated
        //
        ChangeFolder(NULL);

        //
        // Force a selection change
        //
        HandleSelectionChange();

        //
        // Download all of the thumbnails
        //
        RequestThumbnails( m_CameraItemList.Root() );

        //
        // Close the progress dialog
        //
        pWiaProgressDialog->Destroy();
    }
    return(0);
}

LRESULT CCameraAcquireDialog::OnChangeToParent( WPARAM, LPARAM )
{
    if (m_pCurrentParentItem)
        ChangeFolder(m_pCurrentParentItem->Parent());
    return(0);
}

VOID CCameraAcquireDialog::OnParentDir( WPARAM, LPARAM )
{
    if (m_pCurrentParentItem && m_pCurrentParentItem->Parent())
        ChangeFolder(m_pCurrentParentItem->Parent());
    else ChangeFolder(NULL);
}

void CCameraAcquireDialog::MarkItemDeletePending( int nIndex, bool bSet )
{
    HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (hwndList)
    {
        ListView_SetItemState( hwndList, nIndex, bSet ? LVIS_CUT : 0, LVIS_CUT );
    }
}

// Recursively delete items
void CCameraAcquireDialog::DeleteItem( CCameraItem *pItemNode )
{
    if (pItemNode)
    {
        CCameraItem *pChild = pItemNode->Children();
        while (pChild)
        {
            DeleteItem(pChild);
            pChild = pChild->Next();
        }
        if (pItemNode->DeleteState() == CCameraItem::Delete_Visible)
        {
            int nIndex = FindItemInList( pItemNode );
            if (nIndex >= 0)
            {
                //
                // Mark it pending in the UI
                //
                MarkItemDeletePending(nIndex,true);
            }
            //
            // Mark it pending
            //
            pItemNode->DeleteState( CCameraItem::Delete_Pending );

            //
            // Fire off the request
            //
            m_pThreadMessageQueue->Enqueue( new CDeleteThreadMessage(m_hWnd, pItemNode->GlobalInterfaceTableCookie()), CThreadMessageQueue::PriorityHigh );
        }
    }
}


VOID CCameraAcquireDialog::OnDelete( WPARAM, LPARAM )
{
    CSimpleDynamicArray<int> aSelIndices;
    if (GetSelectionIndices( aSelIndices ))
    {
        //
        // We only want to show the confirm dialog once
        //
        bool bShowConfirmDialog = true;
        for (int i=0;i<aSelIndices.Size();i++)
        {
            CCameraItem *pItemNode = GetListItemNode(aSelIndices[i]);

            //
            // If we haven't already deleted this image, do so
            //
            if (pItemNode && pItemNode->DeleteState() == CCameraItem::Delete_Visible && pItemNode->ItemRights() & WIA_ITEM_CAN_BE_DELETED)
            {
                if (bShowConfirmDialog)
                {
                    bShowConfirmDialog = false;
                    if (IDYES!=MessageBox( m_hWnd, CSimpleString( IDS_DELETE_CONFIRM, g_hInstance ), CSimpleString( IDS_DELETE_CONFIRM_TITLE, g_hInstance ), MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2 ))
                    {
                        break;
                    }
                }
                DeleteItem( pItemNode );
            }
        }
    }
}


int CCameraAcquireDialog::GetSelectionIndices( CSimpleDynamicArray<int> &aIndices )
{
    HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (!hwndList)
        return(0);
    int iCount = ListView_GetItemCount(hwndList);
    for (int i=0;i<iCount;i++)
        if (ListView_GetItemState(hwndList,i,LVIS_SELECTED) & LVIS_SELECTED)
            aIndices.Append(i);
    return(aIndices.Size());
}

bool CCameraAcquireDialog::SetSelectedListItem( int nIndex )
{
    HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (!hwndList)
        return(false);
    int iCount = ListView_GetItemCount(hwndList);
    for (int i=0;i<iCount;i++)
        ListView_SetItemState(hwndList,i,LVIS_SELECTED|LVIS_FOCUSED,0);
    ListView_SetItemState(hwndList,nIndex,LVIS_SELECTED|LVIS_FOCUSED,LVIS_SELECTED|LVIS_FOCUSED);
    ListView_EnsureVisible(hwndList,nIndex,FALSE);
    return(true);
}

CCameraItem *CCameraAcquireDialog::GetListItemNode( int nIndex )
{
    HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (!hwndList)
        return(NULL);
    LV_ITEM lvItem;
    ::ZeroMemory(&lvItem,sizeof(LV_ITEM));
    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = nIndex;
    if (!ListView_GetItem( hwndList, &lvItem ))
        return(NULL);
    return((CCameraItem *)lvItem.lParam);
}

bool CCameraAcquireDialog::ChangeFolder( CCameraItem *pNode )
{
    CCameraItem *pOldParent = m_pCurrentParentItem;
    m_pCurrentParentItem = pNode;
    return(PopulateList(pOldParent));
}

bool CCameraAcquireDialog::ChangeToSelectedFolder(void)
{
    CSimpleDynamicArray<int> aSelIndices;
    if (GetSelectionIndices(aSelIndices))
    {
        //
        // Find out if only folders are selected
        //
        bool bOnlyFoldersSelected = true;
        for (int i=0;i<aSelIndices.Size();i++)
        {
            CCameraItem *pItemNode = GetListItemNode(aSelIndices[i]);
            if (pItemNode && !pItemNode->IsFolder())
            {
                bOnlyFoldersSelected = false;
                break;
            }
        }

        WIA_TRACE((TEXT("bOnlyFoldersSelected = %d"),bOnlyFoldersSelected));

        //
        // If only folders are selected, switch to the first selected folder
        //
        if (bOnlyFoldersSelected && aSelIndices.Size())
        {
            CCameraItem *pItemNode = GetListItemNode(aSelIndices[0]);
            if (!pItemNode)
            {
                //
                // NULL item node == parent folder
                //
                SendMessage( m_hWnd, PWM_CHANGETOPARENT, 0, 0 );
                return(true);
            }
            if (pItemNode && pItemNode->IsFolder() && pItemNode->DeleteState() == CCameraItem::Delete_Visible)
            {
                if (ChangeFolder(pItemNode))
                {
                    return(true);
                }
            }
        }
    }
    return(false);
}

VOID CCameraAcquireDialog::OnOK( WPARAM, LPARAM )
{
    if (!ChangeToSelectedFolder())
    {
        HRESULT hr = S_OK;
        m_pDeviceDialogData->lItemCount = 0;
        m_pDeviceDialogData->ppWiaItems = NULL;
        CSimpleDynamicArray<int> aIndices;
        GetSelectionIndices( aIndices );
        if (aIndices.Size())
        {
            int nArraySizeInBytes = sizeof(IWiaItem*) * aIndices.Size();
            m_pDeviceDialogData->ppWiaItems = (IWiaItem**)CoTaskMemAlloc(nArraySizeInBytes);
            if (m_pDeviceDialogData->ppWiaItems)
            {
                ZeroMemory( m_pDeviceDialogData->ppWiaItems, nArraySizeInBytes );
                int nCurrItem = 0;
                for (int i=0;i<aIndices.Size();i++)
                {
                    CCameraItem *pItem = GetListItemNode(aIndices[i]);

                    //
                    // Add the item to the list if it is both a valid picture item and it hasn't been deleted
                    //
                    if (pItem && pItem->Item() && pItem->IsImage() && pItem->DeleteState() == CCameraItem::Delete_Visible)
                    {
                        m_pDeviceDialogData->ppWiaItems[nCurrItem] = pItem->Item();
                        m_pDeviceDialogData->ppWiaItems[nCurrItem]->AddRef();
                        nCurrItem++;
                    }
                }
                m_pDeviceDialogData->lItemCount = nCurrItem;
            }
            else
            {
                // Unable to alloc mem
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            return;
        }
        EndDialog( m_hWnd, hr );
    }
}


VOID CCameraAcquireDialog::OnCancel( WPARAM, LPARAM )
{
    EndDialog( m_hWnd, S_FALSE );
}

VOID CCameraAcquireDialog::OnSelectAll( WPARAM, LPARAM )
{
    ListView_SetItemState( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ), -1, LVIS_SELECTED, LVIS_SELECTED );
}

VOID CCameraAcquireDialog::OnProperties( WPARAM, LPARAM )
{
    CSimpleDynamicArray<int> aSelIndices;
    if (GetSelectionIndices( aSelIndices ))
    {
        if (aSelIndices.Size() == 1)
        {
            CCameraItem *pItemNode = GetListItemNode(aSelIndices[0]);
            if (pItemNode && pItemNode->Item())
            {
                m_pThreadMessageQueue->Pause();
                HRESULT hr = WiaUiUtil::SystemPropertySheet( g_hInstance, m_hWnd, pItemNode->Item(), CSimpleString( IDS_CAMDLG_PROPERTIES_TITLE, g_hInstance ) );
                if (!SUCCEEDED(hr))
                {
                    if (PROP_SHEET_ERROR_NO_PAGES == hr)
                    {
                        MessageBox( m_hWnd, CSimpleString( IDS_CAMDLG_PROPSHEETNOPAGES, g_hInstance ), CSimpleString( IDS_CAMDLG_ERROR_TITLE, g_hInstance ), MB_ICONINFORMATION );
                    }
                    else
                    {
                        MessageBox( m_hWnd, CSimpleString( IDS_CAMDLG_PROPSHEETERROR, g_hInstance ), CSimpleString( IDS_CAMDLG_ERROR_TITLE, g_hInstance ), MB_ICONINFORMATION );
                    }
                    WIA_PRINTHRESULT((hr,TEXT("SystemPropertySheet failed")));
                }
                m_pThreadMessageQueue->Resume();
            }
        }
    }
}

LRESULT CCameraAcquireDialog::OnDblClkImageList( WPARAM, LPARAM )
{
    SendMessage( m_hWnd, WM_COMMAND, MAKEWPARAM(IDOK,0), 0 );
    return(0);
}

void CCameraAcquireDialog::CancelAllPreviewRequests( CCameraItem *pRoot )
{
    CCameraItem *pCurr = pRoot;
    while (pCurr)
    {
        if (pCurr->PreviewRequestPending())
            pCurr->SetCancelEvent();
        if (pCurr->Children())
            CancelAllPreviewRequests( pCurr->Children() );
        pCurr = pCurr->Next();
    }
}

void CCameraAcquireDialog::UpdatePreview(void)
{
    if (m_bPreviewActive)
    {
        CCameraItem *pCurrPreviewItem = GetCurrentPreviewItem();
        if (pCurrPreviewItem && pCurrPreviewItem->IsImage())
        {
            // If we're not already downloading this preview image...
            if (!pCurrPreviewItem->PreviewRequestPending())
            {
                // Cancel all other preview requests
                CancelAllPreviewRequests( m_CameraItemList.Root() );

                if (pCurrPreviewItem->PreviewFileName().Length())
                {
                    // Set the preview if we've got it cached
                    SetCurrentPreviewImage( pCurrPreviewItem->PreviewFileName() );
                }
                else
                {
                    CSimpleString strPct;
                    strPct.Format( IDS_DOWNLOADINGPREVIEW, g_hInstance, 0 );

                    // Clear the preview window
                    SetCurrentPreviewImage( TEXT(""), strPct );

                    // Create our cancel event
                    pCurrPreviewItem->CreateCancelEvent();
                    // Reset it, just in case
                    pCurrPreviewItem->ResetCancelEvent();
                    // Make the request
                    m_pThreadMessageQueue->Enqueue( new CPreviewThreadMessage( m_hWnd, pCurrPreviewItem->GlobalInterfaceTableCookie(), pCurrPreviewItem->CancelQueueEvent().Event() ), CThreadMessageQueue::PriorityHigh );
                }
            }
            else
            {
                CSimpleString strPct;
                strPct.Format( IDS_DOWNLOADINGPREVIEW, g_hInstance, pCurrPreviewItem->CurrentPreviewPercentage() );

                SetCurrentPreviewImage( TEXT(""), strPct );
            }
        }
        else
        {
            SetCurrentPreviewImage( TEXT("") );
            CancelAllPreviewRequests( m_CameraItemList.Root() );
        }
    }
    else
    {
        CancelAllPreviewRequests( m_CameraItemList.Root() );
        SetCurrentPreviewImage( TEXT("") );
    }
}

LRESULT CCameraAcquireDialog::OnTimer( WPARAM wParam, LPARAM )
{
    switch (wParam)
    {
    case IDT_UPDATEPREVIEW:
        {
            KillTimer( m_hWnd, IDT_UPDATEPREVIEW );
            UpdatePreview();
        }
        break;
    }
    return(0);
}

// Avoids unnecessary state changes
static inline void MyEnableWindow( HWND hWnd, BOOL bEnable )
{
    if (bEnable && !IsWindowEnabled(hWnd))
        EnableWindow(hWnd,TRUE);
    else if (!bEnable && IsWindowEnabled(hWnd))
        EnableWindow(hWnd,FALSE);
}

// Avoids unnecessary state changes
static inline void MyEnableToolbarButton( HWND hWnd, int nId, BOOL bEnable )
{
    LRESULT nState = SendMessage( hWnd, TB_GETSTATE, nId, 0 );
    if (nState < 0)
        return;
    if ((nState & TBSTATE_ENABLED) && !bEnable)
        SendMessage( hWnd, TB_ENABLEBUTTON, nId, nState & ~TBSTATE_ENABLED);
    else if (!(nState & TBSTATE_ENABLED) && bEnable)
        SendMessage( hWnd, TB_ENABLEBUTTON, nId, nState | TBSTATE_ENABLED );
}


void CCameraAcquireDialog::HandleSelectionChange(void)
{
    CWaitCursor wc;
    int nSelCount = ListView_GetSelectedCount(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ) );
    int nItemCount = ListView_GetItemCount(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ) );

    //
    // Properties should be disabled for multiple items
    // and parent folder icons
    //
    bool bDisableProperties = true;
    if (nSelCount == 1)
    {
        CSimpleDynamicArray<int> aIndices;
        if (CCameraAcquireDialog::GetSelectionIndices( aIndices ))
        {
            if (CCameraAcquireDialog::GetListItemNode( aIndices[0] ))
            {
                bDisableProperties = false;
            }
        }
    }

    MyEnableWindow( GetDlgItem(m_hWnd,IDC_CAMDLG_PROPERTIES), !bDisableProperties );

    // OK should be disabled for 0 items
    MyEnableWindow( GetDlgItem(m_hWnd,IDOK), nSelCount != 0 );

    // Select all should be disabled for 0 items
    MyEnableToolbarButton( GetDlgItem(m_hWnd,IDC_TOOLBAR), IDC_SELECTALL, nItemCount != 0 );

    //
    // Decide whether or not delete should be enabled
    // If any of the selected items are deletable, then delete is enabled
    //
    bool bEnableDelete = false;

    //
    // Get the selected items
    //
    CSimpleDynamicArray<int> aSelIndices;
    if (GetSelectionIndices( aSelIndices ))
    {
        //
        // Loop through all of the selected items.  Break out if we find a reason
        // to enable delete.
        //
        for (int i=0;i<aSelIndices.Size() && !bEnableDelete;i++)
        {
            //
            // Get the item
            //
            CCameraItem *pItemNode = GetListItemNode(aSelIndices[i]);

            //
            // If we don't have an item, it is a parent folder
            //
            if (pItemNode)
            {
                //
                // If the access rights include the right to delete items,
                // break out.
                //
                if (pItemNode->ItemRights() & WIA_ITEM_CAN_BE_DELETED)
                {
                    //
                    // Found one, so we are done.
                    //
                    bEnableDelete = true;
                    break;
                }
            }
        }
    }

    MyEnableToolbarButton( GetDlgItem(m_hWnd,IDC_TOOLBAR), IDC_DELETE, bEnableDelete );

    KillTimer( m_hWnd, IDT_UPDATEPREVIEW );
    SetTimer( m_hWnd, IDT_UPDATEPREVIEW, UPDATE_PREVIEW_DELAY, NULL );
}


LRESULT CCameraAcquireDialog::OnImageListItemChanged( WPARAM, LPARAM )
{
    HandleSelectionChange();
    return(0);
}

LRESULT CCameraAcquireDialog::OnImageListKeyDown( WPARAM, LPARAM lParam )
{
    LPNMLVKEYDOWN pnkd = reinterpret_cast<LPNMLVKEYDOWN>(lParam);
    if (pnkd)
    {
        bool bAlt = ((GetKeyState(VK_MENU) & 0x8000) != 0);
        bool bControl = ((GetKeyState(VK_CONTROL) & 0x8000) != 0);
        bool bShift = ((GetKeyState(VK_SHIFT) & 0x8000) != 0);
        if (VK_LEFT == pnkd->wVKey && bAlt && !bControl && !bShift)
        {
            SendMessage( m_hWnd, PWM_CHANGETOPARENT, 0, 0 );
        }
        else if (VK_BACK == pnkd->wVKey && !bAlt && !bControl && !bShift)
        {
            SendMessage( m_hWnd, PWM_CHANGETOPARENT, 0, 0 );
        }
        else if (VK_DELETE == pnkd->wVKey)
        {
            SendMessage( m_hWnd, WM_COMMAND, IDC_DELETE, 0 );
        }
    }
    return (0);
}

LRESULT CCameraAcquireDialog::OnHelp( WPARAM wParam, LPARAM lParam )
{
    return WiaHelp::HandleWmHelp( wParam, lParam, g_HelpIDs );
}

LRESULT CCameraAcquireDialog::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    return WiaHelp::HandleWmContextMenu( wParam, lParam, g_HelpIDs );
}

LRESULT CCameraAcquireDialog::OnSysColorChange( WPARAM wParam, LPARAM lParam )
{
    WiaPreviewControl_SetBkColor( GetDlgItem( m_hWnd, IDC_PREVIEW ), TRUE, TRUE, GetSysColor(COLOR_WINDOW) );
    WiaPreviewControl_SetBkColor( GetDlgItem( m_hWnd, IDC_PREVIEW ), TRUE, FALSE, GetSysColor(COLOR_WINDOW) );
    SendDlgItemMessage( m_hWnd, IDC_THUMBNAILLIST, WM_SYSCOLORCHANGE, wParam, lParam );
    SendDlgItemMessage( m_hWnd, IDC_TOOLBAR, WM_SYSCOLORCHANGE, wParam, lParam );
    SendDlgItemMessage( m_hWnd, IDC_CAMDLG_PROPERTIES, WM_SYSCOLORCHANGE, wParam, lParam );
    m_ToolbarBitmapInfo.ReloadAndReplaceBitmap();
    return 0;
}

LRESULT CCameraAcquireDialog::OnNotify( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
    {
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL( NM_DBLCLK, IDC_THUMBNAILLIST, OnDblClkImageList );
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL( LVN_ITEMCHANGED, IDC_THUMBNAILLIST, OnImageListItemChanged );
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL( LVN_KEYDOWN, IDC_THUMBNAILLIST, OnImageListKeyDown );
    }
    SC_END_NOTIFY_MESSAGE_HANDLERS();
}

// WM_COMMAND Handler
LRESULT CCameraAcquireDialog::OnCommand( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_COMMAND_HANDLERS()
    {
        SC_HANDLE_COMMAND(IDOK,OnOK);
        SC_HANDLE_COMMAND(IDCANCEL,OnCancel);
        SC_HANDLE_COMMAND(IDC_CAMDLG_PROPERTIES,OnProperties);
        SC_HANDLE_COMMAND(IDC_PREVIEWMODE,OnPreviewMode);
        SC_HANDLE_COMMAND(IDC_TAKEPICTURE,OnTakePicture);
        SC_HANDLE_COMMAND(IDC_ICONMODE,OnIconMode);
        SC_HANDLE_COMMAND(IDC_DELETE,OnDelete);
        SC_HANDLE_COMMAND(IDC_SELECTALL,OnSelectAll);
    }
    SC_END_COMMAND_HANDLERS();
}

INT_PTR CALLBACK CCameraAcquireDialog::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CCameraAcquireDialog)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_SIZE, OnSize );
        SC_HANDLE_DIALOG_MESSAGE( WM_SHOWWINDOW, OnShow );
        SC_HANDLE_DIALOG_MESSAGE( WM_ENTERSIZEMOVE, OnEnterSizeMove );
        SC_HANDLE_DIALOG_MESSAGE( WM_EXITSIZEMOVE, OnExitSizeMove );
        SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        SC_HANDLE_DIALOG_MESSAGE( WM_GETMINMAXINFO, OnGetMinMaxInfo );
        SC_HANDLE_DIALOG_MESSAGE( WM_NOTIFY, OnNotify );
        SC_HANDLE_DIALOG_MESSAGE( WM_DESTROY, OnDestroy );
        SC_HANDLE_DIALOG_MESSAGE( PWM_POSTINIT, OnPostInit );
        SC_HANDLE_DIALOG_MESSAGE( PWM_CHANGETOPARENT, OnChangeToParent );
        SC_HANDLE_DIALOG_MESSAGE( PWM_THUMBNAILSTATUS, OnThumbnailStatus );
        SC_HANDLE_DIALOG_MESSAGE( PWM_PREVIEWSTATUS, OnPreviewStatus );
        SC_HANDLE_DIALOG_MESSAGE( PWM_PREVIEWPERCENT, OnPreviewPercent );
        SC_HANDLE_DIALOG_MESSAGE( PWM_ITEMDELETED, OnItemDeleted );
        SC_HANDLE_DIALOG_MESSAGE( PWM_WIAEVENT, OnWiaEvent );
        SC_HANDLE_DIALOG_MESSAGE( WM_TIMER, OnTimer );
        SC_HANDLE_DIALOG_MESSAGE( WM_HELP, OnHelp );
        SC_HANDLE_DIALOG_MESSAGE( WM_CONTEXTMENU, OnContextMenu );
        SC_HANDLE_DIALOG_MESSAGE( WM_SYSCOLORCHANGE, OnSysColorChange );
    }
    SC_END_DIALOG_MESSAGE_HANDLERS();
}

// Static hook-related data
HWND CCameraAcquireDialog::s_hWndDialog = NULL;
HHOOK CCameraAcquireDialog::s_hMessageHook = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\camdlg\wiacamd.h ===
#ifndef __WIACAMD_H_INCLUDED
#define __WIACAMD_H_INCLUDED

#include <windows.h>
#include "wiadevd.h"

HRESULT WINAPI CameraDeviceDialog( PDEVICEDIALOGDATA pDialogDeviceData );

#endif //__WIACAMD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\camdlg\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for camera dialog
 *
 *****************************************************************************/

#ifndef __PRECOMP_H_INCLUDED
#define __PRECOMP_H_INCLUDED

#include <windows.h>
#include <atlbase.h>
#include <commctrl.h>
#include <objbase.h>
#include <propidl.h>
#include <wia.h>
#include <wiadef.h>

#include "camdlg.rh"
#include "wiadebug.h"
#include "wianew.h"
#include "wiadevd.h"

#include "pshelper.h"
#include "uicommon.h"
#include "miscutil.h"

#include "simcrack.h"
#include "simstr.h"
#include "simbstr.h"
#include "simevent.h"

#include "multistr.h"
#include "pviewids.h"
#include "dlgunits.h"
#include "proparry.h"
#include "waitcurs.h"
#include "dbgtimer.h"

extern HINSTANCE g_hInstance;

#include <shfusion.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\camdlg\camdlg.h ===
#ifndef __CAMDLG_H_INCLUDED
#define __CAMDLG_H_INCLUDED

#include <windows.h>
#include "wia.h"
#include "wiadevd.h"
#include "citemlst.h"
#include "simarray.h"
#include "bkthread.h"
#include "gwiaevnt.h"
#include "createtb.h"

#define DEF_PICTURE_ICON 0
#define DEF_FOLDER_ICON 1
#define DEF_PARENT_ICON 2

class CCameraAcquireDialog
{
private:
    enum
    {
        MULTISEL_MODE  = 1,
        SINGLESEL_MODE = 2,
        BOTH_MODES     = 3
    };


private:
    HWND                              m_hWnd;
    bool                              m_bPreviewActive;
    SIZE                              m_sizeMinimumWindow;
    SIZE                              m_sizeThumbnails;
    PDEVICEDIALOGDATA                 m_pDeviceDialogData;
    SIZE                              m_CurrentAspectRatio;
    CCameraItemList                   m_CameraItemList;
    CCameraItem                      *m_pCurrentParentItem;
    CThreadMessageQueue              *m_pThreadMessageQueue;
    CSimpleEvent                      m_CancelEvent;
    bool                              m_bFirstTime;
    HANDLE                            m_hBackgroundThread;
    HIMAGELIST                        m_hImageList;
    HFONT                             m_hBigFont;
    DWORD                             m_nDialogMode;
    int                               m_nParentFolderImageListIndex;
    HACCEL                            m_hAccelTable;
    int                               m_nListViewWidth;
    HICON                             m_hIconLarge;
    HICON                             m_hIconSmall;
    CComPtr<IUnknown>                 m_DisconnectEvent;
    CComPtr<IUnknown>                 m_DeleteItemEvent;
    CComPtr<IUnknown>                 m_CreateItemEvent;
    bool                              m_bTakePictureIsSupported;
    ToolbarHelper::CToolbarBitmapInfo m_ToolbarBitmapInfo;

private:
    // No implementation
    CCameraAcquireDialog(void);
    CCameraAcquireDialog &operator=( const CCameraAcquireDialog & );
    CCameraAcquireDialog( const CCameraAcquireDialog & );
private:
    CCameraAcquireDialog( HWND hWnd );
protected:
    HWND CreateCameraDialogToolbar(VOID);
    VOID ResizeAll(VOID);
    HRESULT EnumerateItems( CCameraItem *pCurrentParent, IEnumWiaItem *pIWiaEnumItem );
    HRESULT EnumerateAllCameraItems(void);
    bool PopulateList( CCameraItem *pOldParent=NULL );
    HBITMAP CreateDefaultThumbnail( HDC hDC, HFONT hFont, int nWidth, int nHeight, LPCWSTR pszTitle, int nType );
    void CreateThumbnails( bool bForce=false );
    bool FindMaximumThumbnailSize(void);
    int GetSelectionIndices( CSimpleDynamicArray<int> &aIndices );
    CCameraItem *GetListItemNode( int nIndex );
    bool ChangeFolder( CCameraItem *pNode );
    bool ChangeToSelectedFolder(void);
    bool IsAFolderSelected(void);
    bool SetSelectedListItem( int nIndex );
    int FindItemInList( CCameraItem *pItem );
    void RequestThumbnails( CCameraItem *pRoot );
    void UpdatePreview(void);
    CCameraItem *GetCurrentPreviewItem(void);
    bool SetCurrentPreviewImage( const CSimpleString &strFilename, const CSimpleString &strTitle = TEXT("") );
    LRESULT OnEnterSizeMove( WPARAM, LPARAM );
    LRESULT OnExitSizeMove( WPARAM, LPARAM );
    void CancelAllPreviewRequests( CCameraItem *pRoot );
    void MarkItemDeletePending( int nIndex, bool bSet );
    void DeleteItem( CCameraItem *pItemNode );
    void HandleSelectionChange(void);

    void CreateThumbnails( CCameraItem *pRoot, HIMAGELIST hImageList, bool bForce );
    void CreateThumbnail( CCameraItem *pCurr, HIMAGELIST hImageList, bool bForce );
    void OnItemCreatedEvent( CGenericWiaEventHandler::CEventMessage *pEventMessage );

    LRESULT OnInitDialog( WPARAM, LPARAM );
    LRESULT OnSize( WPARAM, LPARAM );
    LRESULT OnShow( WPARAM, LPARAM );
    LRESULT OnGetMinMaxInfo( WPARAM, LPARAM );
    LRESULT OnDestroy( WPARAM, LPARAM );
    LRESULT OnDblClkImageList( WPARAM, LPARAM );
    LRESULT OnImageListItemChanged( WPARAM, LPARAM );
    LRESULT OnImageListKeyDown( WPARAM, LPARAM );
    LRESULT OnTimer( WPARAM, LPARAM );
    LRESULT OnHelp( WPARAM, LPARAM );
    LRESULT OnContextMenu( WPARAM, LPARAM );
    LRESULT OnSysColorChange( WPARAM, LPARAM );

    LRESULT OnChangeToParent( WPARAM, LPARAM );
    LRESULT OnPostInit( WPARAM, LPARAM );

    LRESULT OnThumbnailStatus( WPARAM, LPARAM );
    LRESULT OnPreviewStatus( WPARAM, LPARAM );
    LRESULT OnPreviewPercent( WPARAM, LPARAM );
    LRESULT OnItemDeleted( WPARAM, LPARAM );
    LRESULT OnWiaEvent( WPARAM, LPARAM );

    VOID OnParentDir( WPARAM, LPARAM );
    VOID OnPreviewMode( WPARAM, LPARAM );
    VOID OnIconMode( WPARAM, LPARAM );
    VOID OnDelete( WPARAM, LPARAM );
    VOID OnOK( WPARAM, LPARAM );
    VOID OnCancel( WPARAM, LPARAM );
    VOID OnProperties( WPARAM, LPARAM );
    VOID OnSelectAll( WPARAM, LPARAM );
    VOID OnTakePicture( WPARAM, LPARAM );

    LRESULT OnNotify( WPARAM wParam, LPARAM lParam );
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam );

    // Hook procedure and static variables used to handle accelerators
    static HWND s_hWndDialog;
    static HHOOK s_hMessageHook;
    static LRESULT CALLBACK DialogHookProc( int nCode, WPARAM wParam, LPARAM );

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

public: // For now
    static BOOL WINAPI OnThreadDestroy( CThreadMessage *pMsg );
    static BOOL WINAPI OnGetThumbnail( CThreadMessage *pMsg );
    static BOOL WINAPI OnGetPreview( CThreadMessage *pMsg );
    static BOOL WINAPI OnThreadDeleteItem( CThreadMessage *pMsg );
};

#endif //__CAMDLG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\cimage\cimage.cpp ===
// CIMAGE.CPP

// Implementation of CDIBImage and its kin


#include <windows.h>
#include <objbase.h>
#include <shlobj.h>
#include "wiadebug.h"
#include "cunknown.h"
#include <initguid.h>
#include "util.h"
#define DEFINE_GUIDS
#include "cimage.h"

STDMETHODIMP
CDIBImage::QueryInterface (
                            REFIID riid, LPVOID* ppvObject
                          )
{
    HRESULT hr;
    INTERFACES iface[] =
    {
        &IID_IBitmapImage,    (IBitmapImage *)    this,
        &IID_IPersistFile,    (IPersistFile *) this,
        &IID_IDIBProperties,  (IDIBProperties *)  this,
        &IID_IImageProperties, (IImageProperties *) this,
    };

    //
    // Next, try the normal cases...
    //

    hr = HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));
    return hr;
}

STDMETHODIMP_(ULONG)
CDIBImage::AddRef()
{
    return CUnknown::HandleAddRef();
}



STDMETHODIMP_(ULONG)
CDIBImage::Release()
{
    return CUnknown::HandleRelease();
}

CDIBImage::CDIBImage() :
           m_hDIB(NULL),
           m_hBitmap(NULL),
           m_bDirty(FALSE),
           m_szFile(NULL),
           m_szDefaultExt (L"*.bmp")
{
}

CDIBImage::~CDIBImage()
{
    if (m_hDIB)
    {
        GlobalFree (m_hDIB);
    }
    if (m_hBitmap)
    {
        DeleteObject (m_hBitmap);
    }
    if (m_szFile)
    {
        delete [] m_szFile;
    }
}

/*++

Name:
    CDIBImage::InternalCreate

Description:
    Given a global memory DIB or an HBITMAP, init the
    object. Both a DIB and an HBITMAP are stored for quick
    access at the expense of increased memory use.


Arguments:
    hDIB - global handle to a DIB
    hBmp - handle to a dibsection or compatible bitmap

Return Value:
    S_OK on success, error code otherwise

Notes:


--*/

HRESULT
CDIBImage::InternalCreate (HANDLE hDIB, HBITMAP hBmp)
{
    WIA_PUSHFUNCTION (TEXT("CDIBImage::InternalCreate"));

    HDC hdc = NULL;
    PBYTE pDIB = NULL;
    HRESULT hr = S_OK;

    if (!hDIB && !hBmp)
    {
        hr = E_INVALIDARG;
        goto exit_gracefully;// (hr, TEXT("NULL handles to InternalCreate"));
    }

    hdc = GetDC (NULL);
    if (m_hDIB)
    {
        GlobalFree (m_hDIB);
    }
    if (m_hBitmap)
    {
        DeleteObject (m_hBitmap);
    }
    if (hDIB)
    {
        m_hDIB = hDIB;
    }
    else
    {
        m_hDIB = Util::BitmapToDIB (hdc, hBmp);
        if (!m_hDIB)
        {
            hr = E_FAIL;
            goto exit_gracefully;
        }
    }
    if (hBmp)
    {
        m_hBitmap = hBmp;
    }
    else
    {
        pDIB = reinterpret_cast<PBYTE>(GlobalLock(m_hDIB));
        m_hBitmap = Util::DIBBufferToBMP (hdc, pDIB, FALSE);
        if (!m_hBitmap)
        {
            hr = E_FAIL;

            goto exit_gracefully;
        }
    }
exit_gracefully:
   if (hdc)
   {
       ReleaseDC (NULL, hdc);
   }
   if (pDIB)
   {
       GlobalUnlock (m_hDIB);
   }
   return hr;
}

/*++

Name:
    CDIBImage::CreateFromDataObject

Description:
    Given an IDataObject pointer, retrieve an IBitmapImage interface
    for the data.


Arguments:
    pdo - IDataObject interface

Return Value:
    S_OK on success

Notes:
    the pdo is not released by this function
    TODO: Add support for CF_BITMAP and other TYMED values
--*/

STDMETHODIMP
CDIBImage::CreateFromDataObject (
                                 IDataObject *pdo
                                )
{
    FORMATETC fmt;
    STGMEDIUM stg;
    HRESULT hr = E_FAIL;

    WIA_PUSHFUNCTION(TEXT("CDIBImage::CreateFromDataObject"));

    if (!pdo)
    {
        goto exit_gracefully;// (hr, TEXT("NULL IDataObject passed to CreateFromDataObject"));
    }

    // Try with CF_DIB and TYMED_HGLOBAL only
    memset (&stg, 0, sizeof(stg));
    fmt.cfFormat = CF_DIB;
    fmt.ptd = NULL;
    fmt.dwAspect = DVASPECT_CONTENT;
    fmt.lindex = -1;
    fmt.tymed = TYMED_HGLOBAL;
    if (SUCCEEDED(hr=pdo->GetData(&fmt, &stg)))
    {

        hr = InternalCreate (stg.hGlobal, NULL);

        if (stg.pUnkForRelease)
        {
            stg.pUnkForRelease->Release();
        }
        else
        {
            GlobalFree (stg.hGlobal);
        }
    }
exit_gracefully:

    return hr;
}

/*++

Name:

    CDIBImage::CreateFromBitmap

Description:
    Given an HBITMAP, init the object


Arguments:
    hBitmap - dibsection or compatible bitmap

Return Value:
    S_OK on success

Notes:


--*/

STDMETHODIMP
CDIBImage::CreateFromBitmap (
                             HBITMAP hBitmap
                            )
{
    return InternalCreate (NULL, hBitmap);
}


/*++

Name:
    CDIBImage::CreateFromDIB

Description:
    Given a global memory DIB, init the object


Arguments:
    hDIB - global DIB handle

Return Value:
    S_OK on success

Notes:


--*/

STDMETHODIMP
CDIBImage::CreateFromDIB (
                          HANDLE  hDIB
                         )
{
    return InternalCreate (hDIB, NULL);
}

/*++

Name:

    CDIBImage::Blt

Description:
    Draw the image to the given DC


Arguments:
    hdcDest- target DC
    prect  -  rectangle to fill in the DC
    xSrc   - x coord to start in the image
    ySrc   - y coord to start in the image
    dwRop  - GDI ROP code

Return Value:
    S_OK on success, E_FAIL if BitBlt fails

Notes:


--*/

STDMETHODIMP
CDIBImage::Blt (
                HDC hdcDest,
                LPRECT prect,
                INT xSrc,
                INT ySrc,
                DWORD dwRop
               )
{
    WIA_PUSHFUNCTION(TEXT("CDIBImage::Blt"));


    HDC hdc = CreateCompatibleDC (hdcDest);
    HGDIOBJ hOld;
    BITMAP bm;
    HRESULT hr = S_OK;
    ZeroMemory (&bm, sizeof(bm));
    GetObject (m_hBitmap, sizeof(bm), &bm);
    if (hdc)
    {

        hOld = SelectObject (hdc, m_hBitmap);
        if (!::BitBlt (hdcDest,
                       prect->left,
                       prect->top,
                       prect->right-prect->left,
                       prect->bottom-prect->top,
                       hdc,
                       xSrc,
                       ySrc,
                       dwRop
                       ))
        {
            hr = E_FAIL;
        }
        SelectObject (hdc, hOld);
        DeleteDC (hdc);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


/*++

Name:
    CDIBImage::Stretch

Description:
    StretchBlt wrapper for the image


Arguments:
    hdcDest - destination DC
    prcSrc  - rectangle of the image to blt
    prcDest - rectangle of the DC to fill
    dwRop   - GDI ROP code

Return Value:
    S_OK on success, E_FAIL if StretchBlt fails

Notes:


--*/

STDMETHODIMP
CDIBImage::Stretch (
                    HDC hdcDest,
                    LPRECT prcSrc,
                    LPRECT prcDest,
                    DWORD dwRop
                   )
{
    WIA_PUSHFUNCTION(TEXT("CDIBImage::Stretch"));
    HRESULT hr = S_OK;


    if (!prcSrc || !prcDest)
    {
        hr = E_INVALIDARG;

    }
    else
    {
        HDC hdc = CreateCompatibleDC (hdcDest);
        HGDIOBJ hOld = NULL;


        if (hdc)
        {

            hOld = SelectObject (hdc, m_hBitmap);
            if (!::StretchBlt (hdcDest,
              prcDest->left,
              prcDest->top,
              prcDest->right-prcDest->left,
              prcDest->bottom-prcDest->top,
              hdc,
              prcSrc->left,
              prcSrc->top,
              prcSrc->right-prcSrc->left,
              prcSrc->bottom-prcDest->top,
              dwRop
             ))
            {
                hr = E_FAIL;
            }
            SelectObject (hdc, hOld);
            DeleteDC (hdc);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

/*++

Name:
    CDIBImage::GetProperties

Description:
    Retrieve an IImageProperties interface for the image

Arguments:
    ppip - IImageProperties pointer to fill in

Return Value:
    S_OK on success

Notes:


--*/

STDMETHODIMP
CDIBImage::GetProperties (
                          IImageProperties **ppip
                         )
{
    if (!ppip)
    {
        return E_INVALIDARG;
    }
    return QueryInterface (IID_IImageProperties,
                    reinterpret_cast<LPVOID *>(ppip));

}

/*++

Name:
    CDIBImage::ConvertToDIB

Description:
    Allocate a global DIB and fill it with the current image


Arguments:
    phDIB - handle pointer to fill in

Return Value:
    S_OK on success

Notes:


--*/

STDMETHODIMP
CDIBImage::ConvertToDIB (
                         HANDLE *phDIB
                        )
{
    HANDLE hDIB;
    SIZE_T size;
    HRESULT hr = S_OK;
    PVOID   pdib = NULL;
    PVOID   pcopy = NULL;

    WIA_PUSHFUNCTION(TEXT("CDIBImage::ConvertToDIB"));

    if (!phDIB)
    {
        hr = E_INVALIDARG;
        goto exit_gracefully;// (hr, TEXT("NULL phDIB to ConvertToDIB"));
    }
    *phDIB = NULL;
    size = GlobalSize (m_hDIB);

    pdib = GlobalLock (m_hDIB);
    if (!pdib)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;// (hr, TEXT("GlobalLock failed in ConvertToDIB"));

    }
    hDIB = GlobalAlloc (GHND, size);
    if (!hDIB)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;// (hr, TEXT("GlobalAlloc failed in ConvertToDIB"));

    }
    pcopy = GlobalLock (hDIB);
    if (!pcopy)
    {
        GlobalFree (hDIB);
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;// (hr, TEXT("GlobalLock failed in ConvertToDIB"));

    }
    memcpy (pcopy, pdib, size);


exit_gracefully:
    if (phDIB && hDIB && pcopy)
    {
        GlobalUnlock (hDIB);
        *phDIB = hDIB;
    }
    if (pdib)
    {
        GlobalUnlock (m_hDIB);
    }
    return hr;

}

/*++

Name:
    CDIBImage::CopyToClipboard

Description:
    Put the image contents delimited by prect on the clipboard


Arguments:
    prect - part of the image to copy

Return Value:
    S_OK on success

Notes:


--*/

STDMETHODIMP
CDIBImage::CopyToClipboard (
                            LPRECT prect
                           )
{
    WIA_PUSHFUNCTION(TEXT("CDIBImage::CopyToClipboard"));
    HRESULT hr = S_OK;

    OpenClipboard (NULL);
    EmptyClipboard();

    if (!prect)
    {
        //default to CF_DIB for whole image
        hr = SetClipboardData (CF_DIB, m_hDIB) ? S_OK:E_FAIL;
    }
    else
    {
        // Create an HBITMAP for the selected region
        HBITMAP hbmp = CropBitmap (m_hBitmap, prect);
        if (!hbmp)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;// (hr, TEXT("CropBitmap failed in CopyToClipboard"));
        }
        hr = SetClipboardData (CF_BITMAP, hbmp) ? S_OK : E_FAIL;
        DeleteObject (hbmp);
    }
exit_gracefully:
    CloseClipboard ();
    return hr;
}

/*++

Name:
    CDIBImage::Rotate

Description:
    Rotate the image around its center


Arguments:
    nDegrees - amount to rotate

Return Value:
    S_OK on success

Notes:
    Currently only 90,180,270 degrees are supported

--*/

STDMETHODIMP
CDIBImage::Rotate (
                   INT nDegrees
                  )
{
    WIA_PUSHFUNCTION (TEXT("CDIBImage::Rotate"));
    HRESULT hr = S_OK;
    HBITMAP hNew;
    hNew = RotateBitmap (m_hBitmap, nDegrees);
    if (!hNew)
    {
        hr = E_FAIL;
        goto exit_gracefully;// (hr, TEXT("RotateBitmap failed in Rotate"));
    }
    else
    {
        m_bDirty = TRUE;
        InternalCreate (NULL, hNew);
    }
exit_gracefully:
    return hr;
}

STDMETHODIMP
CDIBImage::Crop (RECT *prcCrop,
                 IBitmapImage **ppImage
                 )
{
    HBITMAP hBitmap;
    HRESULT hr = S_OK;
    CDIBImage *pObj;
    *ppImage = NULL;


    hBitmap = CropBitmap (m_hBitmap, prcCrop);
    if (hBitmap)
    {
        pObj = new CDIBImage ();
        if (pObj)
        {
            (pObj)->QueryInterface (IID_IBitmapImage,
                                      reinterpret_cast<PVOID*>(ppImage));
            (*ppImage)->CreateFromBitmap (hBitmap);
            pObj->Release();
        }
        DeleteObject (hBitmap);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;

}


////////////////////////////////IImageProperties methods

/*++

Name:
    CDIBImage::GetSize

Description:
        Returns the dimensions of the image


Arguments:
        pSize - pointer to SIZE structure to fill

Return Value:
        S_OK on success

Notes:

--*/

STDMETHODIMP
CDIBImage::GetSize  (
                     SIZE *pSize
                    )
{
    WIA_PUSHFUNCTION (TEXT("CDIBImage::GetSize"));
    BITMAP bm;
    if (!pSize)
    {
        return E_INVALIDARG;
    }
    ZeroMemory (&bm, sizeof(bm));
    GetObject (m_hBitmap, sizeof (bm), &bm);
    pSize->cx = bm.bmWidth;
    pSize->cy = bm.bmHeight;
    return S_OK;
}

/*++

Name:
    CDIBImage::GetDepth

Description:
    Return the bits per pixel of the image


Arguments:
    pwBPP - pointer to value to fill in

Return Value:
    S_OK on success

Notes:


--*/

STDMETHODIMP
CDIBImage::GetDepth (
                     WORD *pwBPP
                    )
{
    WIA_PUSHFUNCTION (TEXT("CDIBImage::GetDepth"));
    BITMAP bm;
    if (!pwBPP)
    {
        return E_INVALIDARG;
    }

    if (GetObject (m_hBitmap, sizeof (bm), &bm) >= sizeof(bm))
    {
        *pwBPP = bm.bmBitsPixel;
        return S_OK;
    }
    return E_FAIL;
}


STDMETHODIMP
CDIBImage::SetDepth (
                     WORD wBPP
                    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDIBImage::GetAlpha (
                     BYTE *pAlpha
                    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDIBImage::SetAlpha (
                       BYTE Alpha
                      )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDIBImage::GetAspectRatio(
                          SIZE *pAspect
                         )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDIBImage::SetAspectRatio(
                          SIZE *pAspect
                         )
{
    return E_NOTIMPL;
}

//IDIBProperties methods
/*++

Name:
    CDIBImage::GetInfo

Description:
    Construct a BITMAPINFO structure for the current image


Arguments:
    ppbmi - pointer to BITMAPINFO pointer to allocate

Return Value:
    S_OK on success

Notes:


--*/

STDMETHODIMP
CDIBImage::GetInfo(
                   BITMAPINFO **ppbmi
                  )
{
    WIA_PUSHFUNCTION(TEXT("CDIBImage::GetInfo"));
    IMalloc *pMalloc = NULL;
    ULONG uSize;
    HRESULT hr = S_OK;
    BITMAPINFO *pDIB = NULL;

    hr = CoGetMalloc (1, &pMalloc);
    if (FAILED(hr))
    {
        goto exit_gracefully;// (hr, TEXT("SHGetMalloc in GetInfo"));
    }

    pDIB = reinterpret_cast<BITMAPINFO *>(GlobalLock (m_hDIB));
    if (!pDIB)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;// (TEXT("GlobalLock failed in GetInfo"));
    }

    uSize = static_cast<LONG>(Util::GetBmiSize (pDIB));
    *ppbmi = reinterpret_cast<BITMAPINFO*>(pMalloc->Alloc (uSize));
    if (!*ppbmi)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;// (hr, TEXT("IMalloc::Alloc"));
    }
    memcpy (*ppbmi, pDIB, uSize);

exit_gracefully:
    if (pMalloc)
    {
        pMalloc->Release();
    }
    if (pDIB)
    {
        GlobalUnlock (m_hDIB);
    }
    return hr;
}

STDMETHODIMP
CDIBImage::GetDIBSize(
                      DWORD *pdwSize
                     )
{
    if (!pdwSize)
    {
        return E_POINTER;
    }
    *pdwSize = static_cast<DWORD>(GlobalSize(m_hDIB));
    return S_OK;
}

////////////////////////////////// IPersistFile methods
STDMETHODIMP
CDIBImage::IsDirty(
                   void
                  )
{
    return m_bDirty? S_OK:S_FALSE;
}

/*++

Name:
    CDIBImage::Load

Description:
    Init the image from an image file

Arguments:
    pszFileName - path to the image file
    dwMode      - storage mode to open with, currently ignored

Return Value:
    S_OK on success

Notes:


--*/

STDMETHODIMP
CDIBImage::Load(
                LPCOLESTR pszFileName,
                DWORD dwMode
               )
{

    HRESULT hr = S_OK;
    LPTSTR szDibFile = NULL;
    HBITMAP hBitmap;

    WIA_PUSHFUNCTION (TEXT("CDIBImage::Load"));

    if (!pszFileName || !*pszFileName)
    {
        hr = E_INVALIDARG;
        goto exit_gracefully;// (hr, TEXT("NULL filename to Load"));
    }
    if (m_szFile)
    {
        delete [] m_szFile;
    }
    m_szFile = new WCHAR[lstrlenW(pszFileName)+1];
    if (!m_szFile)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    wcscpy (m_szFile, pszFileName);
#ifdef UNICODE
    szDibFile = m_szFile;
#else
    INT len;

    len = WideCharToMultiByte (CP_ACP,
                               0,
                               m_szFile,
                               -1,
                               szDibFile,
                               0,
                               NULL,
                               NULL);
    szDibFile = new CHAR[len+1];
    if (!szDibFile)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;// (hr, TEXT("Unable to allocate file name in Load"));
    }
    WideCharToMultiByte (CP_ACP,
                         0,
                         m_szFile,
                         -1,
                         szDibFile,
                         len,
                         NULL,
                         NULL);
#endif // UNICODE
   hBitmap = reinterpret_cast<HBITMAP>(LoadImage(NULL,
                                                 szDibFile,
                                                 IMAGE_BITMAP,
                                                 0,
                                                 0,
                                                 LR_CREATEDIBSECTION|LR_LOADFROMFILE));

    hr = CreateFromBitmap (hBitmap);
    m_bDirty = FALSE;
exit_gracefully:
#ifndef UNICODE
    if (szDibFile)
    {
        delete [] szDibFile;
    }
#endif //ndef UNICODE
    return hr;

}

STDMETHODIMP
CDIBImage::GetClassID (
                       CLSID *pClassID
                      )
{
    memcpy (pClassID, &CLSID_WIAImage, sizeof(CLSID));
    return S_OK;
}

/*++

Name:
    CDIBImage::Save

Description:
    Save the current image to file


Arguments:
    pszFileName - file to save to. If NULL, use the current file name
    fRemember   - whether to keep pszFileName as the new file name

Return Value:
    S_OK on success

Notes:


--*/

STDMETHODIMP
CDIBImage::Save (
                 LPCOLESTR pszFileName,
                 BOOL fRemember
                )
{
    HANDLE hFile;
    HRESULT hr = S_OK;
    LPTSTR pszDibFile = NULL;
    PBYTE pDibFile = NULL;
    PBITMAPINFOHEADER pDIB = NULL;
    PBYTE pBits;
    DWORD dw;
    WIA_PUSHFUNCTION(TEXT("CDIBImage::Save"));
    if (!*pszFileName)
    {
        hr = E_INVALIDARG;
        goto exit_gracefully;// (hr, TEXT("Empty filename to Save"));
    }
    if (fRemember && pszFileName)
    {
        if (m_szFile)
        {
            delete [] m_szFile;
        }
        m_szFile = new WCHAR[lstrlenW(pszFileName)+1];
        if (!m_szFile)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
        lstrcpyW (m_szFile, pszFileName);
    }
#ifdef UNICODE
    pszDibFile = const_cast<LPTSTR>(pszFileName);
#else
    INT len;

    len = WideCharToMultiByte (CP_ACP,
                               0,
                               pszFileName,
                               -1,
                               NULL,
                               0,
                               NULL,
                               NULL);
    pszDibFile = new CHAR[len+1];
    if (!pszDibFile)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;// (hr, TEXT("Unable to allocate file name in Load"));
    }
    WideCharToMultiByte (CP_ACP,
                         0,
                         pszFileName,
                         -1,
                         pszDibFile,
                         len,
                         NULL,
                         NULL);
#endif // UNICODE
    pDIB = reinterpret_cast<PBITMAPINFOHEADER>(GlobalLock (m_hDIB));
    pBits = reinterpret_cast<PBYTE>(pDIB) + Util::GetBmiSize(reinterpret_cast<PBITMAPINFO>(pDIB));
    pDibFile = Util::AllocDibFileFromBits (pBits,
                                           pDIB->biWidth,
                                           pDIB->biHeight,
                                           pDIB->biBitCount);
    if (!pDibFile)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;// (hr, TEXT("AllocDibFileFromBits in Save"));
    }

    hFile = CreateFile (pszDibFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        hr = E_FAIL;
        goto exit_gracefully;// (hr, TEXT("CreateFile in Save"));
    }
    WriteFile (hFile,
               pDibFile,
               reinterpret_cast<PBITMAPFILEHEADER>(pDibFile)->bfSize,
               &dw,
               NULL);
    CloseHandle (hFile);

exit_gracefully:
    if (pDIB)
    {
        GlobalUnlock (m_hDIB);
    }
    if (pDibFile)
    {
        LocalFree (pDibFile);
    }
#ifndef UNICODE
    if (pszDibFile)
    {
        delete [] pszDibFile;
    }
#endif //ndef UNICODE

    return hr;
}


STDMETHODIMP
CDIBImage::SaveCompleted (
                          LPCOLESTR pszFileName
                         )
{
    return E_NOTIMPL;
}

/*++

Name:
    CDIBImage::GetCurFile

Description:
    Return the current file name of the image, or the
    preferred "file mask" for this kind of file.
    In this case the preferred mask is "*.bmp"

Arguments:
    ppszFileName - pointer to string to fill in

Return Value:
    S_OK on success

Notes:


--*/

STDMETHODIMP
CDIBImage::GetCurFile (
                       LPOLESTR *ppszFileName
                      )
{
    HRESULT hr = S_OK;
    LPOLESTR szCur;
    IMalloc *pMalloc = NULL;
    WIA_PUSHFUNCTION(TEXT("CDIBImage::GetCurFile"));
    if (!ppszFileName)
    {
        hr = E_INVALIDARG;
        goto exit_gracefully;// (hr, TEXT("NULL out pointer to GetCurFile"));
    }
    if (!m_szFile)
    {
        szCur = const_cast<LPOLESTR>(m_szDefaultExt);
    }
    else
    {
        szCur = m_szFile;
    }
    hr = CoGetMalloc (1,&pMalloc);
    if (FAILED(hr))
    {
        goto exit_gracefully;// (hr, TEXT("CoGetMalloc in GetCurFile"));
    }

    *ppszFileName = reinterpret_cast<LPOLESTR>(pMalloc->Alloc((lstrlenW(szCur)+1)*sizeof(OLECHAR)));
    if (*ppszFileName)
    {
        lstrcpyW (*ppszFileName, szCur);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

exit_gracefully:
    if (pMalloc)
    {
        pMalloc->Release();
    }

    return hr;
}

    // IDataObject methods
STDMETHODIMP
CDIBImage::GetData (
                    FORMATETC *pformatetcIn,
                    STGMEDIUM *pmedium
                   )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDIBImage::GetDataHere (
                        FORMATETC *pformatetc,
                        STGMEDIUM *pmedium
                       )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDIBImage::QueryGetData (
                         FORMATETC *pformatetc
                        )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDIBImage::GetCanonicalFormatEtc (
                                  FORMATETC *pformatectIn,
                                  FORMATETC *pformatetcOut
                                 )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDIBImage::SetData (
                    FORMATETC *pformatetc,
                    STGMEDIUM *pmedium,
                    BOOL fRelease
                   )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDIBImage::EnumFormatEtc (
                          DWORD dwDirection,
                          IEnumFORMATETC **ppenumFormatEtc
                         )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDIBImage::DAdvise (
                    FORMATETC *pformatetc,
                    DWORD advf,
                    IAdviseSink *pAdvSink,
                    DWORD *pdwConnection
                   )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDIBImage::DUnadvise (
                      DWORD dwConnection
                     )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDIBImage::EnumDAdvise (
                        IEnumSTATDATA **ppenumAdvise
                       )
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
// Helper APIs

/*++

Name:
    MakeNewDIBImage

Description:
    Create an IBitmapImage interface for a CDIBImage object given an IDataObject


Arguments:
    pdo - IDataObject pointer
    pbiOut - IBitmapImage pointer to fill in
    pfe - type of data to use

Return Value:
    S_OK on success

Notes:


--*/

HRESULT MakeNewDIBImage (IDataObject *pdo, IBitmapImage **pbiOut, FORMATETC *pfe)
{
    WIA_PUSHFUNCTION (TEXT("MakeNewDIBImage"));
    CDIBImage *pDibImage = NULL;
    IBitmapImage *pbi = NULL;
    IPersistFile *ppf;
    STGMEDIUM stg;
    FORMATETC fmt;
    HRESULT hr = S_OK;

    *pbiOut = NULL;
    pDibImage = new CDIBImage ();
    if (!pDibImage)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    if (FAILED(hr = pDibImage->QueryInterface (IID_IBitmapImage,
                                    reinterpret_cast<LPVOID*>(&pbi)
                                   )))
    {
        goto exit_gracefully;// (hr, TEXT("QueryInterface for IBitmapImage"));
    }

    if (pfe)
    {
        if (FAILED(hr = pdo->GetData (pfe, &stg)))
        {
            goto exit_gracefully;// (hr, TEXT("GetData in MakeNewDIBImage"));
        }

        switch (pfe->tymed)
        {
            case TYMED_HGLOBAL:
                hr = pbi->CreateFromDIB (stg.hGlobal);
                break;

            case TYMED_GDI:
                hr = pbi->CreateFromBitmap (stg.hBitmap);
                break;

            case TYMED_FILE:
                hr = pbi->QueryInterface (IID_IPersistFile,
                                          reinterpret_cast<LPVOID *>(&ppf)
                                         );
                if (SUCCEEDED(hr))
                {
                    hr = ppf->Load (stg.lpszFileName, STGM_READ);
                    ppf->Release();
                }
                else
                {
                    hr = DV_E_TYMED;
                }
                break;

           default:
               hr=  DV_E_TYMED;
               break;
        }
    }
    else
    {
        // try HGLOBAL
        fmt.cfFormat = CF_DIB;
        fmt.tymed = TYMED_HGLOBAL;
        fmt.lindex = -1;
        fmt.dwAspect = DVASPECT_CONTENT;
        fmt.ptd = NULL;
        hr = MakeNewDIBImage (pdo, &pbi, &fmt);
    }
exit_gracefully:
    if (pDibImage)
    {
        pDibImage->Release ();
    }

    if (SUCCEEDED(hr))
    {
        *pbiOut = pbi;
    }
    else if (pbi)
    {
        pbi->Release();
    }
    return hr;

}

/*++

Name:
    GetImageFromDataObject

Description:
    Retrieve an IBitmapImage interface for an IDataObject


Arguments:
    pdo - IDataObject pointer
    pbi - IBitmapImage pointer to fill in

Return Value:
    S_OK on success

Notes:
    In the future, private formats in the IDataObject may allow this
   function to return interfaces for other formats than DIB

--*/

HRESULT
GetImageFromDataObject (IN IDataObject *pdo, OUT IBitmapImage **pbi)
{
    WIA_PUSHFUNCTION(TEXT("GetImageFromDataObject"));

    IEnumFORMATETC *pEnum;
    FORMATETC fe;
    ULONG     ul;
    BOOL      bMatch = FALSE;
    HRESULT hr = S_OK;

    if (SUCCEEDED(pdo->EnumFormatEtc (DATADIR_GET, &pEnum)))
    {
        while (S_OK == pEnum->Next (1, &fe,&ul))
        {
            switch (fe.cfFormat)
            {
                case CF_DIB:
                case CF_BITMAP:
                    if (SUCCEEDED(hr= MakeNewDIBImage (pdo, pbi, &fe)))
                    {
                        bMatch = TRUE;
                    }
                    break;
                default:
                    break;
            }
        }
        if (!bMatch)
        {
            hr = E_FAIL;
        }
        pEnum->Release();
    }
    else
    {
        // just try DIBImage
        hr = MakeNewDIBImage (pdo, pbi, NULL);
    }
    return hr;
}


#define MAKEPOINT(p,i,j) {(p).x = i;(p).y = j;}
HBITMAP RotateBitmap (HBITMAP hbm, UINT uAngle)
{

    HDC     hMemDCsrc = NULL;
    HDC     hMemDCdst = NULL;
    HDC     hdc = NULL;
    HBITMAP hNewBm = NULL;
    BITMAP  bm;
    LONG    cx, cy;
    POINT   pts[3];
    if (!hbm)
         return NULL;


    ZeroMemory (&bm, sizeof(bm));
    GetObject (hbm, sizeof(BITMAP), (LPSTR)&bm);
    switch (uAngle)
    {
        case 0:
        case 360:
            cx = bm.bmWidth;
            cy = bm.bmHeight;
            MAKEPOINT (pts[0], 0, 0)
            MAKEPOINT (pts[1], bm.bmWidth, 0)
            MAKEPOINT (pts[2], 0, bm.bmHeight)
            break;

        case 90:
            cx = bm.bmHeight;
            cy = bm.bmWidth;
            MAKEPOINT(pts[0],bm.bmHeight,0)
            MAKEPOINT(pts[1],bm.bmHeight,bm.bmWidth)
            MAKEPOINT(pts[2],0,0)
            break;

        case 180:
            cx = bm.bmWidth;
            cy = bm.bmHeight;
            MAKEPOINT(pts[0],bm.bmWidth, bm.bmHeight)
            MAKEPOINT(pts[1],0,bm.bmHeight)
            MAKEPOINT(pts[2],bm.bmWidth,0)

            break;

        case 270:
        case -90:
            cx = bm.bmHeight;
            cy = bm.bmWidth;
            MAKEPOINT(pts[0],0, bm.bmWidth)
            MAKEPOINT(pts[1],0,0)
            MAKEPOINT(pts[2],bm.bmHeight, bm.bmWidth)

            break;

        default:
            return NULL;
            WIA_TRACE((TEXT("RotateBitmap called with unsupported angle %d\n"), uAngle));
            break;
    }



    hdc = GetDC (NULL);
    if (hdc)
    {

        hMemDCsrc = CreateCompatibleDC (hdc);
        hMemDCdst = CreateCompatibleDC (hdc);
    }

    if (hdc && hMemDCsrc && hMemDCdst)
    {

        hNewBm = CreateBitmap(cx, cy, bm.bmPlanes, bm.bmBitsPixel, NULL);
        if (hNewBm)
        {
            SelectObject (hMemDCsrc, hbm);
            SelectObject (hMemDCdst, hNewBm);

            PlgBlt (  hMemDCdst,
                      pts,
                      hMemDCsrc,
                      0,
                      0,
                      bm.bmWidth,
                      bm.bmHeight,
                      NULL,
                      0,0);

        }
    }
    if (hdc)
        ReleaseDC (NULL,hdc);
    if (hMemDCsrc)
        DeleteDC (hMemDCsrc);
    if (hMemDCdst)
        DeleteDC (hMemDCdst);
    return hNewBm;
}

HBITMAP CropBitmap (
    HBITMAP hbm,
    PRECT prc)
{
    HDC     hMemDCsrc = NULL;
    HDC     hMemDCdst = NULL;
    HDC     hdc;
    HBITMAP hNewBm = NULL;
    BITMAP  bm;
    INT     dx,dy;

    if (!hbm)
         return NULL;

    hdc = GetDC (NULL);
    if (hdc)
    {
        hMemDCsrc = CreateCompatibleDC (hdc);
        hMemDCdst = CreateCompatibleDC (hdc);

    }
    if (hdc && hMemDCsrc && hMemDCdst)
    {

        ZeroMemory (&bm, sizeof(bm));
        GetObject (hbm, sizeof(BITMAP), (LPSTR)&bm);
        dx = prc->right  - prc->left;
        dy = prc->bottom - prc->top;

    /*hNewBm = +++CreateBitmap - Not Recommended(use CreateDIBitmap)+++ (dx, dy, bm.bmPlanes, bm.bmBitsPixel, NULL);*/
        hNewBm = CreateBitmap(dx, dy, bm.bmPlanes, bm.bmBitsPixel, NULL);
        if (hNewBm)
        {
            SelectObject (hMemDCsrc, hbm);
            SelectObject (hMemDCdst, hNewBm);

            BitBlt (hMemDCdst,
                    0,
                    0,
                    dx,
                    dy,
                    hMemDCsrc,
                    prc->left,
                    prc->top,
                    SRCCOPY);
        }
    }
    if (hdc)
        ReleaseDC (NULL,hdc);
    if (hMemDCsrc)
        DeleteDC (hMemDCsrc);
    if (hMemDCdst)
        DeleteDC (hMemDCdst);
    return hNewBm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\cimage\sources.inc ===
#
# Builds the ImageIn common library, cimage.lib
#

!include $(PROJECT_ROOT)\ui\uienv.inc

TARGETNAME=cimage
TARGETTYPE=LIBRARY
TARGETPATH=$(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)

INCLUDES= \
        $(PROJECT_ROOT)\ui\shellext\inc;\
        $(INCLUDES);

SOURCES=..\cimage.cpp ..\util.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\cimage\util.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       Util.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        26 Dec, 1997
*
*  DESCRIPTION:
*   Declarations and definitions for the shared utility functions.
*
*******************************************************************************/

#include <strstrea.h>

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif

interface IWiaItem;

namespace Util
{
   void    _stdcall SetBMI(PBITMAPINFO, LONG, LONG, LONG);
   LONG    _stdcall GetBmiSize(PBITMAPINFO);
   PBYTE   _stdcall AllocDibFileFromBits(PBYTE, UINT, UINT, UINT);
   HBITMAP _stdcall DIBBufferToBMP(HDC hDC, PBYTE pDib, BOOLEAN bFlip);
   HRESULT _stdcall ReadDIBFile(LPTSTR pszFileName, PBYTE *ppDib);
   HGLOBAL _stdcall BitmapToDIB (HDC hdc, HBITMAP hBitmap);
};


#ifndef __WAITCURS_H_INCLUDED
#define __WAITCURS_H_INCLUDED

class CWaitCursor
{
private:
    HCURSOR m_hCurOld;
public:
    CWaitCursor(void)
    {
        m_hCurOld = SetCursor( LoadCursor( NULL, IDC_WAIT ) );
    }
    ~CWaitCursor(void)
    {
        SetCursor(m_hCurOld);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\cimage\util.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       Util.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        26 Dec, 1997
*
*  DESCRIPTION:
*   Implementation of common utility functions.
*
*******************************************************************************/

#include <objbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "wia.h"
#include "util.h"
#include "wiadebug.h"

/*******************************************************************************
*
*                     G O L B A L   D A T A
*
*******************************************************************************/


// extern HWND   g_hWndListBox;    // Optional debug listbox window handle.
// extern HANDLE g_hfDebugLog;     // Optional debug log file handle.
// extern TCHAR  g_szAppName[];    // Window caption.


namespace Util
{


/*******************************************************************************
*
*  SetBMI
*
*  DESCRIPTION:
*   Setup bitmap info.
*
*  PARAMETERS:
*
*******************************************************************************/

void _stdcall SetBMI(
    PBITMAPINFO pbmi,
    LONG        width,
    LONG        height,
    LONG        depth)
{
   pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
   pbmi->bmiHeader.biWidth           = width;
   pbmi->bmiHeader.biHeight          = height;
   pbmi->bmiHeader.biPlanes          = 1;
   pbmi->bmiHeader.biBitCount        = (WORD) depth;
   pbmi->bmiHeader.biCompression     = BI_RGB;
   pbmi->bmiHeader.biSizeImage       = 0;
   pbmi->bmiHeader.biXPelsPerMeter   = 0;
   pbmi->bmiHeader.biYPelsPerMeter   = 0;
   pbmi->bmiHeader.biClrUsed         = 0;
   pbmi->bmiHeader.biClrImportant    = 0;
}

/*******************************************************************************
*
*  AllocDibFileFromBits
*
*  DESCRIPTION:
*   Given an unaligned bits buffer, allocate a buffer lager enough to hold the
*   DWORD aligned DIB file and fill it in.
*
*  PARAMETERS:
*
*******************************************************************************/

PBYTE _stdcall AllocDibFileFromBits(
   PBYTE    pBits,
   UINT     width,
   UINT     height,
   UINT     depth)
{
   PBYTE pdib;
   UINT  i, uiScanLineWidth, uiSrcScanLineWidth, cbDibSize;

   // Align scanline to ULONG boundary
   uiSrcScanLineWidth = (width * depth) / 8;
   uiScanLineWidth    = (uiSrcScanLineWidth + 3) & 0xfffffffc;

   // Calculate DIB size and allocate memory for the DIB.
   cbDibSize = height * uiScanLineWidth;
   cbDibSize += sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFO);
   pdib = (PBYTE) LocalAlloc(0, cbDibSize);
   if (pdib) {
      PBITMAPFILEHEADER pbmfh = (PBITMAPFILEHEADER)pdib;
      PBITMAPINFO       pbmi  = (PBITMAPINFO)(pdib + sizeof(BITMAPFILEHEADER));
      PBYTE             pb    = (PBYTE)pbmi+ sizeof(BITMAPINFO);

      // Setup bitmap file header.
      pbmfh->bfType = 'MB';
      pbmfh->bfSize = cbDibSize;
      pbmfh->bfOffBits = static_cast<DWORD>(pb - pdib);

      // Setup bitmap info.
      SetBMI(pbmi,width, height, depth);

      WIA_TRACE(("AllocDibFileFromBits, uiScanLineWidth: %d, pdib: 0x%08X, pbmi: 0x%08X, pbits: 0x%08X", uiScanLineWidth, pdib, pbmi, pb));

      // Copy the bits.
      for (i = 0; i < height; i++) {
         memcpy(pb, pBits, uiSrcScanLineWidth);
         pb += uiScanLineWidth;
         pBits += uiScanLineWidth;
      }
   }
   else {
      WIA_ERROR(("AllocDibFileFromBits, LocalAlloc of %d bytes failed", cbDibSize));
   }
   return pdib;
}

/*******************************************************************************
*
*  DIBBufferToBMP
*
*  DESCRIPTION:
*   Make a BMP object from a DWORD aligned DIB file memory buffer
*
*  PARAMETERS:
*
*******************************************************************************/

HBITMAP _stdcall DIBBufferToBMP(HDC hDC, PBYTE pDib, BOOLEAN bFlip)
{
   HBITMAP     hBmp  = NULL;
   PBITMAPINFO pbmi  = (BITMAPINFO*)(pDib);
   PBYTE       pBits = pDib + GetBmiSize(pbmi);

   if (bFlip) {
      pbmi->bmiHeader.biHeight = -pbmi->bmiHeader.biHeight;
   }
   hBmp = CreateDIBitmap(hDC, &pbmi->bmiHeader, CBM_INIT, pBits, pbmi, DIB_RGB_COLORS);
   if (!hBmp) {
      WIA_ERROR(("DIBBufferToBMP, CreateDIBitmap failed %d", GetLastError()));
   }
   return hBmp;
}

/*******************************************************************************
*
*  ReadDIBFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall ReadDIBFile(LPTSTR pszFileName, PBYTE *ppDib)
{
   HRESULT  hr = S_FALSE;
   HANDLE   hFile, hMap;
   PBYTE    pFile, pBits;

   *ppDib = NULL;
   hFile = CreateFile(pszFileName,
                      GENERIC_WRITE | GENERIC_READ,
                      FILE_SHARE_WRITE,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);

   if (hFile == INVALID_HANDLE_VALUE) {
      WIA_ERROR(("ReadDIBFile, unable to open %s", pszFileName));
      return hr;
   }

   hMap = CreateFileMapping(hFile,
                            NULL,
                            PAGE_READWRITE,
                            0,
                            0,
                            NULL);
   if (!hMap) {
      WIA_ERROR(("ReadDIBFile, CreateFileMapping failed"));
      goto close_hfile_exit;
   }

   pFile = (PBYTE)MapViewOfFileEx(hMap,
                                  FILE_MAP_READ | FILE_MAP_WRITE,
                                  0,
                                  0,
                                  0,
                                  NULL);
   if (pFile) {
      PBITMAPFILEHEADER pbmFile  = (PBITMAPFILEHEADER)pFile;
      PBITMAPINFO       pbmi     = (PBITMAPINFO)(pFile + sizeof(BITMAPFILEHEADER));

      // validate bitmap
      if (pbmFile->bfType == 'MB') {
         // Calculate color table size.
         LONG bmiSize, ColorMapSize = 0;

         if (pbmi->bmiHeader.biBitCount == 1) {
             ColorMapSize = 2 - 1;
         } else if (pbmi->bmiHeader.biBitCount == 4) {
             ColorMapSize = 16 - 1;
         } else if (pbmi->bmiHeader.biBitCount == 8) {
             ColorMapSize = 256 - 1;
         }
         bmiSize = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * ColorMapSize;
         pBits = pFile + sizeof(BITMAPFILEHEADER) + bmiSize;

         *ppDib = AllocDibFileFromBits(pBits,
                                       pbmi->bmiHeader.biWidth,
                                       pbmi->bmiHeader.biHeight,
                                       pbmi->bmiHeader.biBitCount);
         if (*ppDib) {
            hr = S_OK;
         }
      }
      else {
         WIA_ERROR(("ReadDIBFile, %s is not a valid bitmap file", pszFileName));
      }
   }
   else {
      WIA_ERROR(("ReadDIBFile, MapViewOfFileEx failed"));
      goto close_hmap_exit;
   }

   UnmapViewOfFile(pFile);
close_hmap_exit:
   CloseHandle(hMap);
close_hfile_exit:
   CloseHandle(hFile);
   return hr;
}

/*******************************************************************************
*
*  GetBmiSize
*
*  DESCRIPTION:
*   Should never get biCompression == BI_RLE.
*
*  PARAMETERS:
*
*******************************************************************************/

LONG _stdcall GetBmiSize(PBITMAPINFO pbmi)
{
   // determine the size of bitmapinfo
   LONG lSize = pbmi->bmiHeader.biSize;

   // no color table cases
   if (
      (pbmi->bmiHeader.biBitCount == 24) ||
      ((pbmi->bmiHeader.biBitCount == 32) &&
       (pbmi->bmiHeader.biCompression == BI_RGB))) {

      // no colors unless stated
      lSize += sizeof(RGBQUAD) * pbmi->bmiHeader.biClrUsed;
      return (lSize);
   }

   // bitfields cases
   if (((pbmi->bmiHeader.biBitCount == 32) &&
       (pbmi->bmiHeader.biCompression == BI_BITFIELDS)) ||
       (pbmi->bmiHeader.biBitCount == 16)) {

      lSize += 3 * sizeof(RGBQUAD);
      return (lSize);
   }

   // palette cases
   if (pbmi->bmiHeader.biBitCount == 1) {

      LONG lPal = pbmi->bmiHeader.biClrUsed;

      if ((lPal == 0) || (lPal > 2)) {
         lPal = 2;
      }

      lSize += lPal * sizeof(RGBQUAD);
      return (lSize);
   }

   // palette cases
   if (pbmi->bmiHeader.biBitCount == 4) {

      LONG lPal = pbmi->bmiHeader.biClrUsed;

      if ((lPal == 0) || (lPal > 16)) {
         lPal = 16;
      }

      lSize += lPal * sizeof(RGBQUAD);
      return (lSize);
   }

   // palette cases
   if (pbmi->bmiHeader.biBitCount == 8) {

      LONG lPal = pbmi->bmiHeader.biClrUsed;

      if ((lPal == 0) || (lPal > 256)) {
         lPal = 256;
      }

      lSize += lPal * sizeof(RGBQUAD);
      return (lSize);
   }

   // error
   return (0);
}

INT GetColorTableSize (UINT uBitCount, UINT uCompression)
{
INT nSize;


switch(uBitCount)
{
    case 32:
        if (uCompression != BI_BITFIELDS)
        {
            nSize = 0;
            break;
        }
        // fall through
    case 16:
        nSize = 3 * sizeof(DWORD);
        break;

    case 24:
        nSize = 0;
        break;

    default:
        nSize = ((UINT)1 << uBitCount) * sizeof(RGBQUAD);
        break;
}

return(nSize);
}

DWORD CalcBitsSize (UINT uWidth, UINT uHeight, UINT uBitCount, UINT uPlanes, int nAlign)
{
    int    nAWidth,nHeight,nABits;
    DWORD  dwSize;


    nABits  = (nAlign << 3);
    nAWidth = nABits-1;


    // Determine the size of the bitmap based on the (nAlign) size.  Convert
    // this to size-in-bytes.
    //
    nHeight = uHeight * uPlanes;
    dwSize  = (DWORD)(((uWidth * uBitCount) + nAWidth) / nABits) * nHeight;
    dwSize  = dwSize * nAlign;

    return(dwSize);
}

//
// Converts hBitmap to a DIB
//
HGLOBAL _stdcall BitmapToDIB (HDC hdc, HBITMAP hBitmap)
{
BITMAP bm;
HANDLE hDib;
PBYTE  lpDib,lpBits;
DWORD  dwLength;
DWORD  dwBits;
UINT   uColorTable;
INT    iNeedMore;
BOOL   bDone;
INT    nBitCount;
// Get the size of the bitmap.  These values are used to setup the memory
// requirements for the DIB.
//
if(GetObject(hBitmap,sizeof(BITMAP),reinterpret_cast<PVOID>(&bm)))
{
    nBitCount = bm.bmBitsPixel * bm.bmPlanes;
    uColorTable  = GetColorTableSize((UINT)nBitCount, BI_RGB);
    dwBits       = CalcBitsSize(bm.bmWidth,bm.bmHeight,nBitCount,1,sizeof(DWORD));

    do
    {
        bDone = TRUE;

        dwLength     = dwBits + sizeof(BITMAPINFOHEADER) + uColorTable;


        // Create the DIB.  First, to the size of the bitmap.
        //
        if(hDib = GlobalAlloc(GHND,dwLength))
        {
            if(lpDib = reinterpret_cast<PBYTE>(GlobalLock(hDib)))
            {
                ((LPBITMAPINFOHEADER)lpDib)->biSize          = sizeof(BITMAPINFOHEADER);
                ((LPBITMAPINFOHEADER)lpDib)->biWidth         = (DWORD)bm.bmWidth;
                ((LPBITMAPINFOHEADER)lpDib)->biHeight        = (DWORD)bm.bmHeight;
                ((LPBITMAPINFOHEADER)lpDib)->biPlanes        = 1;
                ((LPBITMAPINFOHEADER)lpDib)->biBitCount      = (WORD)nBitCount;
                ((LPBITMAPINFOHEADER)lpDib)->biCompression   = 0;
                ((LPBITMAPINFOHEADER)lpDib)->biSizeImage     = 0;
                ((LPBITMAPINFOHEADER)lpDib)->biXPelsPerMeter = 0;
                ((LPBITMAPINFOHEADER)lpDib)->biYPelsPerMeter = 0;
                ((LPBITMAPINFOHEADER)lpDib)->biClrUsed       = 0;
                ((LPBITMAPINFOHEADER)lpDib)->biClrImportant  = 0;


                // Get the size of the bitmap.
                // The biSizeImage contains the bytes
                // necessary to store the DIB.
                //
                GetDIBits(hdc,hBitmap,0,bm.bmHeight,NULL,(LPBITMAPINFO)lpDib,DIB_RGB_COLORS);

                iNeedMore = ((LPBITMAPINFOHEADER)lpDib)->biSizeImage - dwBits;

                if ( iNeedMore > 0 )
                {
                    dwBits = dwBits + (((iNeedMore + 3) / 4)*4);
                    bDone = FALSE;
                }
                else
                {
                    lpBits = lpDib+sizeof(BITMAPINFOHEADER)+uColorTable;
                    GetDIBits(hdc,hBitmap,0,bm.bmHeight,lpBits,(LPBITMAPINFO)lpDib,DIB_RGB_COLORS);

                    GlobalUnlock(hDib);

                    return(hDib);
                }

                GlobalUnlock(hDib);
            }

            GlobalFree(hDib);
        }
    }
    while (!bDone);
}

return(NULL);

}

}; // End Namespace Util
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\apilayer.c ===
/**++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    apilayer.c


Abstract:

    This module contains functions for the common UI api layer. this layer
    managed all property sheet page handles, create, destroy and inter-page
    communications.


Author:

    28-Dec-1995 Thu 16:02:12 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma  hdrstop


#define DBG_CPSUIFILENAME   DbgApilayer


#define DBG_PAGEDLGPROC         0x00000001
#define DBG_SHOWPAGE            0x00000002
#define DBG_DEL_PROC            0x00000004
#define DBG_GET_PAGE            0x00000008
#define DBG_ADD_CPSUIPAGE       0x00000010
#define DBG_ADD_PSPAGE          0x00000020
#define DBG_ADDCOMPAGE          0x00000040
#define DBG_ADD_CPSUI           0x00000080
#define DBG_PFNCOMPROPSHEET     0x00000100
#define DBG_GETSETREG           0x00000200
#define DBG_DOCOMPROPSHEET      0x00000400
#define DBG_DO_CPSUI            0x00000800
#define DBG_CALLPFN             0x00001000
#define DBG_SETHSTARTPAGE       0x00002000
#define DBG_PAGE_PROC           0x00004000
#define DBG_TCMPROC             0x00008000
#define DBG_TABTABLE            0x00010000
#define DBG_INSPAGE             0x00020000
#define DBG_PSPCB               0x00040000
#define DBG_DMPUBHIDEBITS       0x00080000
#define DBG_APPLYDOC            0x00100000
#define DBG_GET_PAGEHWND        0x00200000
#define DBG_GET_TABWND          0x00400000
#define DBG_ALWAYS_APPLYNOW     0x80000000
#define DBG_IGNORE_PSN_APPLY    0x40000000

DEFINE_DBGVAR(0);

#define REGDPF_TVPAGE           0x00000001
#define REGDPF_EXPAND_OPTIONS   0x00000002
#define REGDPF_STD_P1           0x00000004
#define REGDPF_MASK             0x00000007
#define REGDPF_DEFAULT          0x00000000


extern HINSTANCE        hInstDLL;
extern HANDLE           hCPSUIMutex;
extern CPSUIHANDLETABLE CPSUIHandleTable;
extern DWORD            TlsIndex;


static const WCHAR  szCPSUIRegKey[] = L"Software\\Microsoft\\ComPstUI";
static const WCHAR  szDocPropKeyName[] = L"DocPropFlags";


#if DBG

LPSTR  pszCPSFUNC[] = { "CPSFUNC_ADD_HPROPSHEETPAGE",
                        "CPSFUNC_ADD_PROPSHEETPAGE",
                        "CPSFUNC_ADD_PCOMPROPSHEETUIA",
                        "CPSFUNC_ADD_PCOMPROPSHEETUIW",
                        "CPSFUNC_ADD_PFNPROPSHEETUIA",
                        "CPSFUNC_ADD_PFNPROPSHEETUIW",
                        "CPSFUNC_DELETE_HCOMPROPSHEET",
                        "CPSFUNC_SET_HSTARTPAGE",
                        "CPSFUNC_GET_PAGECOUNT",
                        "CPSFUNC_SET_RESULT",
                        "CPSFUNC_GET_HPSUIPAGES",
                        "CPSFUNC_LOAD_CPSUI_STRINGA",
                        "CPSFUNC_LOAD_CPSUI_STRINGW",
                        "CPSFUNC_LOAD_CPSUI_ICON",
                        "CPSFUNC_GET_PFNPROPSHEETUI_ICON",
                        "CPSFUNC_ADD_PROPSHEETPAGEA",
                        "CPSFUNC_INSERT_PSUIPAGEA",
                        "CPSFUNC_INSERT_PSUIPAGEW",
                        "CPSFUNC_SET_PSUIPAGE_TITLEA",
                        "CPSFUNC_SET_PSUIPAGE_TITLEW",
                        "CPSFUNC_SET_PSUIPAGE_ICON",
                        "CPSFUNC_SET_DATABLOCK",
                        "CPSFUNC_QUERY_DATABLOCK",
                        "CPSFUNC_SET_DMPUB_HIDEBITS",
                        "CPSFUNC_IGNORE_CPSUI_PSN_APPLY",
                        "CPSFUNC_DO_APPLY_CPSUI",
                        "CPSFUNC_SET_FUSION_CONTEXT"
                    };


LPSTR  pszPFNReason[] = { "PROPSHEETUI_REASON_INIT",
                          "PROPSHEETUI_REASON_GET_INFO_HEADER",
                          "PROPSHEETUI_REASON_DESTROY",
                          "PROPSHEETUI_REASON_SET_RESULT",
                          "PROPSHEETUI_REASON_GET_ICON" };

LPSTR  pszTabMode[] = { "TAB_MODE_INIT",
                        "TAB_MODE_FIND",
                        "TAB_MODE_INSERT",
                        "TAB_MODE_DELETE",
                        "TAB_MODE_DELETE_ALL" };

LPSTR   pszInsType[] = { "PSUIPAGEINSERT_GROUP_PARENT",
                         "PSUIPAGEINSERT_PCOMPROPSHEETUI",
                         "PSUIPAGEINSERT_PFNPROPSHEETUI",
                         "PSUIPAGEINSERT_PROPSHEETPAGE",
                         "PSUIPAGEINSERT_HPROPSHEETPAGE",
                         "PSUIPAGEINSERT_DLL" };

#define DBG_SHOW_CPSUIPAGE(pPage, Level)                                            \
{                                                                                   \
    CPSUIDBG(DBG_SHOWPAGE, ("\n\n------ Show Current Page from %08lx, Level=%ld-------", \
                pPage, Level));                                                            \
                                                                                    \
    DbgShowCPSUIPage(pPage, Level);                                                 \
}
#define DBG_SHOW_PTCI(psz, w, ptci)         Show_ptci(psz, w, ptci)


VOID
DbgShowCPSUIPage(
    PCPSUIPAGE  pPage,
    LONG        Level
    )
{
    while (pPage) {

        if (pPage->Flags & CPF_PARENT) {

            if (pPage->Flags & CPF_ROOT) {

                CPSUIDBG(DBG_SHOWPAGE, ("%02ld!%08lx:%08lx: ROOT - Flags=%08lx, hDlg=%08lx, cPage=%ld/%ld, pStartPage=%08lx",
                    Level,
                    pPage, pPage->hPage, pPage->Flags,
                    pPage->RootInfo.hDlg,
                    (DWORD)pPage->RootInfo.cCPSUIPage,
                    (DWORD)pPage->RootInfo.cPage,
                    pPage->RootInfo.pStartPage));

            } else if (pPage->Flags & CPF_PFNPROPSHEETUI) {

                CPSUIDBG(DBG_SHOWPAGE,
                    ("%02ld!%08lx:%08lx: PFN - Flags=%08lx, pfnPSUI=%08lx, UserData=%08lx, Result=%ld",
                    Level, pPage, pPage->hPage, pPage->Flags,
                    pPage->pfnInfo.pfnPSUI, (DWORD)pPage->pfnInfo.UserData,
                    pPage->pfnInfo.Result));

            } else if (pPage->Flags & CPF_COMPROPSHEETUI) {

                CPSUIDBG(DBG_SHOWPAGE, ("%02ld!%08lx:%08lx: CPSUI - Flags=%08lx, pTVWnd=%08lx, lParam=%08lx, TV=%ld, Std1=%ld, Std2=%ld",
                    Level,
                    pPage, pPage->hPage, pPage->Flags,
                    pPage->CPSUIInfo.pTVWnd, pPage->CPSUIInfo.Result,
                    (DWORD)pPage->CPSUIInfo.TVPageIdx,
                    (DWORD)pPage->CPSUIInfo.StdPageIdx1,
                    (DWORD)pPage->CPSUIInfo.StdPageIdx2));

            } else if (pPage->Flags & CPF_USER_GROUP) {

                CPSUIDBG(DBG_SHOWPAGE, ("%02ld!%08lx:%08lx: GROUP_PARENT - Flags=%08lx",
                    Level, pPage, pPage->hPage, pPage->Flags));

            } else {

                CPSUIDBG(DBG_SHOWPAGE, ("%02ld!%08lx:%08lx: UNKNOWN - Flags=%08lx",
                    Level, pPage, pPage->hPage, pPage->Flags));
            }

            DbgShowCPSUIPage(pPage->pChild, Level + 1);

        } else {

            CPSUIDBG(DBG_SHOWPAGE, ("%02ld!%08lx:%08lx: %ws - Flags=%08lx, hDlg=%08lx, DlgProc=%08lx",
                    (LONG)Level,
                    pPage, pPage->hPage,
                    (pPage->Flags & CPF_CALLER_HPSPAGE) ? L"USER_HPAGE" :
                                                        L"PROPSHEETPAGE",
                    pPage->Flags,
                    pPage->hPageInfo.hDlg, pPage->hPageInfo.DlgProc));
        }

        pPage = pPage->pNext;
    }
}



VOID
Show_ptci(
    LPSTR   pszHeader,
    WPARAM  wParam,
    TC_ITEM *ptci
    )
{

    if (ptci) {

        if (pszHeader) {

            CPSUIDBG(DBG_TCMPROC, ("%hs", pszHeader));
        }

        CPSUIDBG(DBG_TCMPROC, ("    IdxItem=%ld", wParam));
        CPSUIDBG(DBG_TCMPROC, ("    Mask=%08lx", ptci->mask));

        if ((ptci->mask & TCIF_TEXT) &&
            (ptci->pszText)) {

            CPSUIDBG(DBG_TCMPROC, ("    pszText=%ws", ptci->pszText));
        }

        CPSUIDBG(DBG_TCMPROC, ("    cchTextMax=%ld", ptci->cchTextMax));
        CPSUIDBG(DBG_TCMPROC, ("    iImage=%ld", ptci->iImage));
    }
}


VOID
SHOW_TABWND(
    LPWSTR      pName,
    PTABTABLE   pTabTable
    )
{
    WORD        w;
    PTABINFO    pTI = pTabTable->TabInfo;


    for (w = 0; w < pTabTable->cTab; w++, pTI++) {

        WORD        Idx = pTI->HandleIdx;
        PCPSUIPAGE  pPage;


        if (((Idx = pTI->HandleIdx) != 0xFFFF)    &&
            (pPage = HANDLETABLE_GetCPSUIPage(WORD_2_HANDLE(Idx)))) {

            TC_ITEM tci;
            WCHAR   wBuf[80];


            tci.mask       = TCIF_TEXT;
            tci.pszText    = wBuf;
            tci.cchTextMax = sizeof(wBuf) / sizeof(WCHAR);

            if (!SendMessage(pTabTable->hWndTab,
                             TCM_GETITEMW,
                             (WPARAM)w,
                             (LPARAM)(TC_ITEM FAR *)&tci)) {

                wsprintf(wBuf, L"FAILED TabName");
            }

            CPSUIDBG(DBG_GET_TABWND,
                    ("  %ws: %2ld/%2ld=[%20ws] hDlg=%08lx, DlgProc=%08lx, hIdx=%04lx, hDlg=%08lx, pPage=%08lx",
                        pName, w, pTI->OrgInsIdx, wBuf, pPage->hPageInfo.hDlg,
                        pPage->hPageInfo.DlgProc, Idx, pTI->hDlg, pPage));

            HANDLETABLE_UnGetCPSUIPage(pPage);
        }
    }
}



#else

#define DBG_SHOW_CPSUIPAGE(pPage, Level)
#define DBG_SHOW_PTCI(psz, w, ptci)
#define SHOW_TABWND(pName, pTabTable)

#endif

BOOL 
GetPageActivationContext(
    PCPSUIPAGE      pCPSUIPage,
    HANDLE         *phActCtx
    )
{
    BOOL bRet = FALSE;

    if (phActCtx) {

        //
        // climb up in the hierarchy to the first parent page which has an 
        // activation context properly set.
        //
        while (pCPSUIPage && INVALID_HANDLE_VALUE == pCPSUIPage->hActCtx) {

            pCPSUIPage = pCPSUIPage->pParent;
        }

        if (pCPSUIPage) {

            //
            // we found a parent with an activation context properly set.
            // return success.
            //
            *phActCtx = pCPSUIPage->hActCtx;
            bRet = TRUE;
        }
    }

    return bRet;
}


DWORD
FilterException(
    HANDLE                  hPage,
    LPEXCEPTION_POINTERS    pExceptionPtr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-Feb-1996 Tue 09:36:00 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hWnd = NULL;
    PCPSUIPAGE  pPage;
    PCPSUIPAGE  pRootPage = NULL;
    LPSTR       pFormat;
    LPSTR       pMsg = NULL;
    CHAR        Buf[2048];
    UINT        i;
    UINT        IDSLast;


    //
    // Buffer is long enough, reserve MAX_PATH characters for LoadString() and wsprintf()
    //
    if ((pPage = HANDLETABLE_GetCPSUIPage(hPage))       &&
        (pRootPage = HANDLETABLE_GetRootPage(pPage))    &&
        (hWnd = pPage->RootInfo.hDlg)) {

        IDSLast = IDS_INT_CPSUI_AV4;
        i       = GetWindowTextA(pPage->RootInfo.hDlg, Buf, COUNT_ARRAY(Buf) - MAX_PATH);

    } else {

        IDSLast = IDS_INT_CPSUI_AV3;
        i       = GetModuleFileNameA(NULL, Buf, COUNT_ARRAY(Buf) - MAX_PATH);
    }

    pMsg = &Buf[++i];

    i += LoadStringA(hInstDLL, IDS_INT_CPSUI_AV1, &Buf[i], COUNT_ARRAY(Buf)-i);
    i += wsprintfA(&Buf[i], " 0x%lx ",
                    pExceptionPtr->ExceptionRecord->ExceptionAddress);
    i += LoadStringA(hInstDLL, IDS_INT_CPSUI_AV2, &Buf[i], COUNT_ARRAY(Buf)-i);
    i += wsprintfA(&Buf[i], " 0x%08lx",
                    pExceptionPtr->ExceptionRecord->ExceptionCode);
    i += LoadStringA(hInstDLL, IDSLast, &Buf[i], COUNT_ARRAY(Buf)-i);


    HANDLETABLE_UnGetCPSUIPage(pPage);
    HANDLETABLE_UnGetCPSUIPage(pRootPage);

    CPSUIERR((Buf));
    CPSUIERR((pMsg));

    MessageBoxA(hWnd, pMsg, Buf, MB_ICONSTOP | MB_OK);

    return(EXCEPTION_EXECUTE_HANDLER);
}




LONG
DoTabTable(
    UINT        Mode,
    PTABTABLE   pTabTable,
    SHORT       Idx,
    SHORT       OrgInsIdx
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    12-Feb-1996 Mon 18:18:56 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTABINFO    pTI;
    PTABINFO    pTmp;
    UINT        cTab;
    UINT        i;
    SHORT       CurIdx;
    SHORT       OldIdx;
    SHORT       RetIdx;


    pTI    =
    pTmp   = pTabTable->TabInfo;
    cTab   = (UINT)pTabTable->cTab;
    RetIdx = -1;

    switch (Mode) {

    case TAB_MODE_FIND:

        CPSUIDBG(DBG_TABTABLE, ("TAB_MODE_FIND:  Index=%ld, cTab=%ld", Idx, cTab));

        if ((Idx >= 0) && (Idx < (SHORT)cTab)) {

            for (i = 0; i < cTab; i++, pTI++) {

                CPSUIDBG(DBG_TABTABLE,
                        ("    i=%2ld, Idx=%2ld, cTab=%2ld, OrgIdx=%2ld",
                                    i, Idx, cTab, pTI->OrgInsIdx));

                if (pTI->OrgInsIdx == Idx) {

                    RetIdx = (SHORT)i;

                    CPSUIDBG(DBG_TABTABLE,  ("    FOUND: RetIdx=%ld", RetIdx));

                    break;
                }
            }
        }

        break;

    case TAB_MODE_DELETE_ALL:

        FillMemory(pTI, sizeof(pTabTable->TabInfo), 0xFF);

        pTabTable->cTab           = 0;
        pTabTable->CurSel         =
        pTabTable->InsIdx         =
        pTabTable->HandleIdx      = 0xFFFF;
        pTabTable->cPostSetCurSel = 0;
        pTabTable->iPostSetCurSel = -1;
        RetIdx                    = MAXPROPPAGES;

        break;

    case TAB_MODE_DELETE:

        //
        // Delete the pTabTable->TabInfo[].OrgInsIdx = Idx, reduced every
        // TabInfo[] which is > Idx by one, if pTabTable->TabInfo[] == Idx
        // then overwrite that entry
        //

        if (Idx < (SHORT)cTab) {

            //
            // Remove the one which match to the Idx
            //

            for (i = 0; i < cTab; i++, pTI++) {

                if ((CurIdx = pTI->OrgInsIdx) == Idx) {

                    RetIdx = Idx;

                } else {

                    if (CurIdx > Idx) {

                        --CurIdx;
                    }

                    pTmp->OrgInsIdx = CurIdx;
                    pTmp->HandleIdx = pTI->HandleIdx;

                    ++pTmp;
                }
            }

            if (RetIdx >= 0) {

                RetIdx          = (SHORT)(--(pTabTable->cTab));
                pTmp->OrgInsIdx =
                pTmp->HandleIdx = 0xFFFF;
            }
        }

        break;

    case TAB_MODE_INSERT:

        //
        // Make room for the Idx location, move everything right one space
        // from the Idx, for every pTabTable->TabInfo[].OrgInsIdx if it is
        // greater or eqaul to OrgInsIdx then add it by one, then set the
        // pTabTable->TabInfo[Idx].OrgInsIdx = OrgInsIdx
        //

        CurIdx  = (SHORT)cTab;
        pTI    += cTab;

        if (Idx > CurIdx) {

            Idx = CurIdx;
        }

        do {

            if (CurIdx == Idx) {

                pTI->OrgInsIdx = OrgInsIdx;
                pTI->HandleIdx = 0xFFFF;

            } else {

                if (CurIdx > Idx) {

                    *pTI = *(pTI - 1);
                }

                if (pTI->OrgInsIdx >= OrgInsIdx) {

                    ++pTI->OrgInsIdx;
                }
            }

            pTI--;

        } while (CurIdx--);

        RetIdx = (SHORT)(++(pTabTable->cTab));

        break;
    }

    CPSUIDBG(DBG_TABTABLE,
             ("%hs(0x%lx, %ld, %ld)=%ld",
                pszTabMode[Mode], pTabTable, (LONG)Idx, (LONG)OrgInsIdx,
                (LONG)RetIdx));

    return((LONG)RetIdx);
}



BOOL
CALLBACK
NO_PSN_APPLY_PROC(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
#define pNMHdr      ((NMHDR *)lParam)
#define pPN         ((PSHNOTIFY *)lParam)

    DLGPROC OldDlgProc;


    if (OldDlgProc = (DLGPROC)GetProp(hDlg, CPSUIPROP_WNDPROC)) {

        switch (Msg) {

        case WM_NOTIFY:

            if (pNMHdr->code == PSN_APPLY) {

                //
                // Ignore it
                //

                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);

                CPSUIDBG(DBG_GET_TABWND,
                        ("!!IGNORE NO_PSN_APPLY_PROC(%ld, PSN_APPLY %08lx (%08lx), %ld (%ld), %ld, %ld), hDlg=%08lx",
                        wParam,
                        pNMHdr->hwndFrom, GetParent(hDlg),
                        pNMHdr->idFrom, GetWindowLongPtr(GetParent(hDlg), GWLP_ID),
                        pNMHdr->code, pPN->lParam, hDlg));

                return(TRUE);
            }

            break;

        case WM_DESTROY:

            RemoveProp(hDlg, CPSUIPROP_WNDPROC);
            SetWindowLongPtr(hDlg, DWLP_DLGPROC, (LPARAM)OldDlgProc);

            CPSUIDBG(DBG_GET_TABWND,
                    ("!! NO_PSN_APPLY_PROC(WM_DESTORY): hDlg=%08lx, Change DlgProc back to %08lx",
                            hDlg, OldDlgProc));
            break;
        }

        return((BOOL)CallWindowProc((WNDPROC)OldDlgProc,
                                    hDlg,
                                    Msg,
                                    wParam,
                                    lParam));
    }

    return(TRUE);


#undef pPN
#undef pNMHdr
}




BOOL
CALLBACK
SetIgnorePSNApplyProc(
    PCPSUIPAGE  pPage
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    04-Feb-1998 Wed 22:51:57 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hDlg;
    DLGPROC OldDlgProc;
    BOOL    Ok = FALSE;

    if (hDlg = pPage->hPageInfo.hDlg) {

        if (pPage->Flags & CPF_NO_PSN_APPLY) {

            //
            // Following will prevent us to set it more than once
            //

            if ((!(pPage->Flags & CPF_DLGPROC_CHANGED))                      &&
                (OldDlgProc = (DLGPROC)GetWindowLongPtr(hDlg, DWLP_DLGPROC)) &&
                (OldDlgProc != (DLGPROC)NO_PSN_APPLY_PROC)                   &&
                (!GetProp(hDlg, CPSUIPROP_WNDPROC))                          &&
                (SetProp(hDlg, CPSUIPROP_WNDPROC, (HANDLE)OldDlgProc))       &&
                (SetWindowLongPtr(hDlg,
                                  DWLP_DLGPROC,
                                  (LPARAM)NO_PSN_APPLY_PROC))) {

                Ok            = TRUE;
                pPage->Flags |= CPF_DLGPROC_CHANGED;

                CPSUIDBG(DBG_GET_TABWND,
                            ("SetIgnorePSNApplyProc:  pPage=%08lx, DlgProc: %08lx --> NO_PSN_APPLY_PROC",
                                pPage, OldDlgProc));
            }

        } else {

            if ((pPage->Flags & CPF_DLGPROC_CHANGED)                     &&
                (OldDlgProc = (DLGPROC)GetProp(hDlg, CPSUIPROP_WNDPROC)) &&
                (SetWindowLongPtr(hDlg, DWLP_DLGPROC, (LPARAM)OldDlgProc))) {

                Ok            = TRUE;
                pPage->Flags &= ~CPF_DLGPROC_CHANGED;

                RemoveProp(hDlg, CPSUIPROP_WNDPROC);

                CPSUIDBG(DBG_GET_TABWND,
                            ("SetIgnorePSNApplyProc:  pPage=%08lx, DlgProc: NO_PSN_APPLY_PROC --> %08lx",
                                pPage, OldDlgProc));
            }
        }

    } else {

        CPSUIDBG(DBG_GET_TABWND,
                ("SetIgnorePSNApplyProc:  pPage=%08lx, hDlg=NULL", pPage));
    }

    if (!Ok) {

        CPSUIDBG(DBG_GET_TABWND,
                ("SetIgnorePSNApplyProc:  hDlg=%08lx, pPage=%08lx, Handle=%08lx, FAILED",
                        hDlg, pPage, pPage->hCPSUIPage));
    }

    return(Ok);
}




LRESULT
CALLBACK
TabCtrlWndProc(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PTABTABLE   pTabTable;
    LRESULT     Result = 0;
    WORD        Idx;


    if ((pTabTable = (PTABTABLE)GetProp(hWnd, CPSUIPROP_TABTABLE))  &&
        (!IsBadWritePtr(pTabTable, sizeof(TABTABLE)))               &&
        (pTabTable->pTabTable == pTabTable)) {

        NULL;

    } else {

        pTabTable = NULL;

        CPSUIERR(("TabCtrlWndProc: pTabTable=%08lx, BadPtr=%ld",
                pTabTable, IsBadWritePtr(pTabTable, sizeof(TABTABLE))));
    }

    CPSUIDBGBLK(
    {
        if (Msg >= TCM_FIRST) {

            switch (Msg) {

            case TCM_GETCURSEL:

                CPSUIDBG(DBG_TCMPROC, ("TCM_GETCURSEL"));
                break;

            case TCM_HITTEST:

                CPSUIDBG(DBG_TCMPROC, ("TCM_HITTEST"));
                break;

            case TCM_DELETEITEM:

                CPSUIDBG(DBG_TCMPROC, ("TCM_DELETEITEM"));
                break;

            case TCM_GETITEMRECT:

                CPSUIDBG(DBG_TCMPROC, ("TCM_GETITEMRECT"));
                break;

            case TCM_GETITEMA:

                CPSUIDBG(DBG_TCMPROC, ("TCM_GETITEMA"));
                break;

            case TCM_GETITEMW:

                CPSUIDBG(DBG_TCMPROC, ("TCM_GETITEMW"));
                break;

            case TCM_SETITEMA:

                CPSUIDBG(DBG_TCMPROC, ("TCM_SETITEMA"));
                break;

            case TCM_SETITEMW:

                CPSUIDBG(DBG_TCMPROC, ("TCM_SETITEMW"));
                break;

            case TCM_SETCURSEL:

                CPSUIDBG(DBG_TCMPROC, ("TCM_SETCURSEL"));
                break;

            case TCM_INSERTITEMA:

                CPSUIDBG(DBG_TCMPROC, ("TCM_INSERTITEMA"));
                break;

            case TCM_INSERTITEMW:

                CPSUIDBG(DBG_TCMPROC, ("TCM_INSERTITEMW"));
                break;

            case TCM_DELETEALLITEMS:

                CPSUIDBG(DBG_TCMPROC, ("TCM_DELETEALLITEMS"));
                break;

            default:

                CPSUIDBG(DBG_TCMPROC, ("TCM_FIRST + %ld",  Msg - TCM_FIRST));
                break;
            }
        }
    })

    if (pTabTable) {

        TC_ITEM     *ptci;
        WPARAM      OldwParam;
        WORD        wIdx;
        BOOL        CallOldProc;


        ptci        = (TC_ITEM *)lParam;
        OldwParam   = wParam;
        CallOldProc = TRUE;


        switch (Msg) {

        //
        // These are TAB_MODE_INSERT after call
        //

        case TCM_INSERTITEMA:
        case TCM_INSERTITEMW:

            DBG_SHOW_PTCI("!!BEFORE!!", wParam, ptci);

            if (pTabTable->cTab >= MAXPROPPAGES) {

                CPSUIERR(("Too may TABs=%ld, can not add any more.",
                                        pTabTable->cTab));
                return(-1);
            }

            if (OldwParam > pTabTable->cTab) {

                OldwParam = (WPARAM)pTabTable->cTab;
            }

            if ((wIdx = pTabTable->InsIdx) > pTabTable->cTab) {

                wIdx = pTabTable->cTab;
            }

            wParam = (WPARAM)wIdx;

            break;

        //
        // These are TAB_MODE_FIND after call
        //

        case TCM_GETCURSEL:
        case TCM_HITTEST:

            ptci = NULL;

            if ((Result = CallWindowProc(pTabTable->WndProc,
                                         hWnd,
                                         Msg,
                                         wParam,
                                         lParam)) >= 0) {

                if ((Msg == TCM_GETCURSEL)                  &&
                    (pTabTable->CurSel != (WORD)Result)     &&
                    (!(pTabTable->TabInfo[Result].hDlg))) {

                    CPSUIDBG(DBG_GET_TABWND, ("!! TCM_GETCURSEL:  PostMessage(TCM_SETCURSEL=%ld, CurSel=%ld) to Get hDlg/DlgProc",
                                            Result, pTabTable->CurSel));

                    CPSUIDBG(DBG_GET_TABWND,
                            ("TCM_GETCURSEL: MAP TabInfo[%ld]=%d, Handle=%08lx, hDlg=%08lx",
                                Result, pTabTable->TabInfo[Result].OrgInsIdx,
                                pTabTable->TabInfo[Result].HandleIdx,
                                pTabTable->TabInfo[Result].hDlg));

                    pTabTable->cPostSetCurSel = COUNT_POSTSETCURSEL;
                    pTabTable->iPostSetCurSel = (SHORT)Result;

                    PostMessage(hWnd, TCM_SETCURSEL, Result, 0);
                }

                Result = (LONG)pTabTable->TabInfo[Result].OrgInsIdx;
            }

            CallOldProc = FALSE;
            break;

        //
        // These are TAB_MODE_FIND before call, and return TRUE/FALSE
        //

        case TCM_DELETEITEM:
        case TCM_GETITEMRECT:

            ptci = NULL;

        case TCM_GETITEMA:
        case TCM_GETITEMW:
        case TCM_SETITEMA:
        case TCM_SETITEMW:

            DBG_SHOW_PTCI("!!BEFORE!!", wParam, ptci);

            if ((Result = DoTabTable(TAB_MODE_FIND,
                                     pTabTable,
                                     (SHORT)wParam,
                                     0)) >= 0) {

                wParam = (WPARAM)Result;

            } else {

                CallOldProc = FALSE;
            }

            break;

        //
        // These are TAB_MODE_FIND before call, and return Index
        //

        case TCM_SETCURSEL:

            ptci = NULL;

            DBG_SHOW_PTCI("!!BEFORE!!", wParam, ptci);

            CPSUIDBG(DBG_GET_TABWND, ("SETCURSEL: %ld --> %ld, CurSel=%ld",
                wParam, DoTabTable(TAB_MODE_FIND, pTabTable, (SHORT)wParam, 0),
                pTabTable->CurSel));

            if ((Result = DoTabTable(TAB_MODE_FIND,
                                     pTabTable,
                                     (SHORT)wParam,
                                     0)) >= 0) {

                wParam = (WPARAM)Result;

            } else {

                CallOldProc = FALSE;
            }

            break;

        //
        // These are no item index passed
        //

        default:

            ptci = NULL;
            break;
        }

        if (CallOldProc) {

            Result = CallWindowProc(pTabTable->WndProc,
                                    hWnd,
                                    Msg,
                                    wParam,
                                    lParam);

            DBG_SHOW_PTCI("!!AFTER!!", wParam, ptci);
        }

        switch (Msg) {

        case TCM_DELETEALLITEMS:

            if (Result) {

                DoTabTable(TAB_MODE_DELETE_ALL, pTabTable, 0, 0);
            }

            break;

        case TCM_DELETEITEM:

            if (Result) {

                DoTabTable(TAB_MODE_DELETE, pTabTable, (SHORT)OldwParam, 0);

                CPSUIDBG(DBG_GET_TABWND,
                         ("DeleteItem: Result=%ld, OldwParam=%u, Count=%ld",
                                Result, OldwParam, pTabTable->cTab));
                SHOW_TABWND(L"TCM_DELETEITEM", pTabTable);
            }

            break;

        case TCM_GETITEMA:
        case TCM_GETITEMW:

            if (pTabTable->iPostSetCurSel >= 0) {

                pTabTable->cPostSetCurSel = COUNT_POSTSETCURSEL;

                PostMessage(hWnd,
                            TCM_SETCURSEL,
                            (WPARAM)pTabTable->iPostSetCurSel,
                            0);
            }

            break;

        case TCM_INSERTITEMA:
        case TCM_INSERTITEMW:

            if (Result >= 0) {

                DoTabTable(TAB_MODE_INSERT,
                           pTabTable,
                           (SHORT)Result,
                           (SHORT)OldwParam);

                pTabTable->TabInfo[Result].HandleIdx = pTabTable->HandleIdx;

                CPSUIDBG(DBG_GET_TABWND,
                         ("InsertItem: OldwParam=%ld, Result=%ld, Count=%ld, Handle=%08lx",
                                OldwParam, Result, pTabTable->cTab,
                                WORD_2_HANDLE(pTabTable->HandleIdx)));
                SHOW_TABWND(L"TCM_INSERTITEM", pTabTable);
            }

            //
            // Reset to the maximum
            //

            pTabTable->InsIdx    =
            pTabTable->HandleIdx = 0xFFFF;

            break;

        case TCM_SETCURSEL:

            if (Result >= 0) {

                PCPSUIPAGE  pPage;
                HWND        hDlg;
                DLGPROC     DlgProc;
                PTABINFO    pTI;

                //
                // Invert the return value from tab table
                //

                pTI = &(pTabTable->TabInfo[wParam]);

                CPSUIDBG(DBG_GET_TABWND, ("SETCURSEL: Result:OldSel=%ld --> %ld, CurSel=%ld",
                        Result, pTabTable->TabInfo[Result].OrgInsIdx, wParam));

                pTabTable->CurSel = (WORD)wParam;

                if (!pTI->hDlg) {

                    Idx = pTI->HandleIdx;

                    if (hDlg = (HWND)SendMessage(pTabTable->hPSDlg,
                                                 PSM_GETCURRENTPAGEHWND,
                                                 (WPARAM)0,
                                                 (LPARAM)0)) {

                        UINT        i = (UINT)pTabTable->cTab;
                        PTABINFO    pTIChk = pTabTable->TabInfo;

                        //
                        // Find out if we already has this hDlg, if we do
                        // then we are in trouble, since it cannot have two
                        // Tab Pages with same hDlg
                        //

                        while (i--) {

                            if (pTIChk->hDlg == hDlg) {

                                CPSUIASSERT(0, "SetCurSel: Table.hDlg already exist in TabInfo[%ld]",
                                            pTIChk->hDlg != hDlg, UIntToPtr(pTabTable->cTab - i - 1));

                                hDlg = NULL;

                                break;

                            } else {

                                pTIChk++;
                            }
                        }
                    }

                    if ((hDlg)  &&
                        (DlgProc = (DLGPROC)GetWindowLongPtr(hDlg,
                                                             DWLP_DLGPROC)) &&
                        (pPage =
                                HANDLETABLE_GetCPSUIPage(WORD_2_HANDLE(Idx)))) {

                        pTabTable->cPostSetCurSel = 0;
                        pTabTable->iPostSetCurSel = -1;

                        CPSUIDBG(DBG_GET_TABWND,
                                    ("SETCURSEL(%08lx): TabInfo[%u]: Handle=%08lx, hDlg=%08lx (%08lx), DlgProc=%08lx --> %08lx",
                                        pTabTable->hPSDlg,
                                        wParam, WORD_2_HANDLE(Idx),
                                        pPage->hPageInfo.hDlg, hDlg,
                                        pPage->hPageInfo.DlgProc, DlgProc));

                        pTI->hDlg                 =
                        pPage->hPageInfo.hDlg     = hDlg;
                        pPage->hPageInfo.DlgProc  = DlgProc;
                        pPage->Flags             |= CPF_ACTIVATED;

                        if ((pPage->Flags & (CPF_NO_PSN_APPLY |
                                             CPF_DLGPROC_CHANGED)) ==
                                                        CPF_NO_PSN_APPLY) {

                            SetIgnorePSNApplyProc(pPage);
                        }

                        HANDLETABLE_UnGetCPSUIPage(pPage);

                        SHOW_TABWND(L"TCM_SETCURSEL", pTabTable);

                    } else if (pTabTable->cPostSetCurSel) {

                        --(pTabTable->cPostSetCurSel);

                        CPSUIDBG(DBG_GET_TABWND,
                            ("!! FAILED: (Dlg=%08lx, DlgProc=%08lx, pPage=%08lx), PostMessage(TCM_SETCURSEL=%ld)",
                            hDlg, DlgProc, pPage, pTI->OrgInsIdx));

                        PostMessage(hWnd,
                                    TCM_SETCURSEL,
                                    (WPARAM)pTI->OrgInsIdx,
                                    0);

                    } else {

                        pTabTable->iPostSetCurSel = (SHORT)pTI->OrgInsIdx;
                    }

                } else {

                    pTabTable->cPostSetCurSel = 0;
                    pTabTable->iPostSetCurSel = -1;
                }

                Result = (LONG)pTabTable->TabInfo[Result].OrgInsIdx;

                CPSUIDBG(DBG_TCMPROC, ("TCM_SETCURSEL: MAP TabInfo[%ld]=%d (%08lx)",
                        Result, pTabTable->TabInfo[Result].OrgInsIdx,
                        WORD_2_HANDLE(pTabTable->TabInfo[Result].HandleIdx)));
            }

            break;

        case TCM_GETITEMCOUNT:

            if (Result != (LONG)pTabTable->cTab) {

                CPSUIERR(("TCM_GETITEMCOUNT=%ld is not equal to cTab=%ld",
                        Result, (LONG)pTabTable->cTab));
            }

            break;

        case WM_DESTROY:

            SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LPARAM)pTabTable->WndProc);
            RemoveProp(hWnd, CPSUIPROP_TABTABLE);
            break;
        }

        if (Msg >= TCM_FIRST) {

            CPSUIDBG(DBG_TCMPROC, ("!! Result=%ld !!\n", Result));
        }
    }

    return(Result);
}



LONG_PTR
SetPSUIPageTitle(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pPage,
    LPWSTR      pTitle,
    BOOL        AnsiCall
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    21-Feb-1996 Wed 14:16:17 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND            hWndTab;
    INSPAGEIDXINFO  InsPageIdxInfo;

    if ((pTitle)                                                    &&
        (InsPageIdxInfo.pCPSUIPage = pPage)                         &&
        (pRootPage->RootInfo.hDlg)                                  &&
        (!(pPage->Flags & CPF_PARENT))                              &&
        (pPage->hPage)                                              &&
        (InsPageIdxInfo.pTabTable = pRootPage->RootInfo.pTabTable)  &&
        (hWndTab = pRootPage->RootInfo.pTabTable->hWndTab)) {

        //
        // The property sheet already displayed
        //

        EnumCPSUIPagesSeq(pRootPage,
                          pRootPage,
                          SetInsPageIdxProc,
                          (LPARAM)&InsPageIdxInfo);

        if (InsPageIdxInfo.pCPSUIPage == NULL) {

            TC_ITEM tcItem;

            tcItem.mask    = TCIF_TEXT;
            tcItem.pszText = pTitle;

            if (SendMessage(hWndTab,
                            (AnsiCall) ? TCM_SETITEMA : TCM_SETITEMW,
                            (WPARAM)GET_REAL_INSIDX(InsPageIdxInfo.pTabTable),
                            (LPARAM)(TC_ITEM FAR*)&tcItem)) {

                return(1);
            }
        }
    }

    return(0);
}



LONG_PTR
SetPSUIPageIcon(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pPage,
    HICON       hIcon
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    21-Feb-1996 Wed 14:16:17 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND            hWndTab;
    INSPAGEIDXINFO  InsPageIdxInfo;

    while ((pPage) && (pPage->Flags & CPF_PARENT)) {

        pPage = pPage->pChild;
    }

    if ((InsPageIdxInfo.pCPSUIPage = pPage)                         &&
        (pRootPage->RootInfo.hDlg)                                  &&
        (!(pPage->Flags & CPF_PARENT))                              &&
        (pPage->hPage)                                              &&
        (InsPageIdxInfo.pTabTable = pRootPage->RootInfo.pTabTable)  &&
        (hWndTab = pRootPage->RootInfo.pTabTable->hWndTab)) {

        //
        // The property sheet already displayed
        //

        EnumCPSUIPagesSeq(pRootPage,
                          pRootPage,
                          SetInsPageIdxProc,
                          (LPARAM)&InsPageIdxInfo);

        if (InsPageIdxInfo.pCPSUIPage == NULL) {

            HIMAGELIST  himi;
            TC_ITEM     tcItem;
            UINT        InsIdx;


            InsIdx = (UINT)GET_REAL_INSIDX(InsPageIdxInfo.pTabTable);
            himi   = TabCtrl_GetImageList(hWndTab);

            if (pPage->hPageInfo.hIcon) {

                //
                // Replace the Image ID icon
                //

                if (!himi) {

                    CPSUIERR(("SetPSUIPageIcon: No Image List in Tab Control"));
                    return(0);
                }

                tcItem.mask = TCIF_IMAGE;

                if (SendMessage(hWndTab,
                                TCM_GETITEMW,
                                (WPARAM)InsIdx,
                                (LPARAM)(TC_ITEM FAR*)&tcItem)) {

                    if (hIcon) {

                        tcItem.iImage = ImageList_ReplaceIcon(himi,
                                                              tcItem.iImage,
                                                              hIcon);

                    } else {

                        //
                        // We need to remove this from image list
                        //

                        ImageList_Remove(himi, tcItem.iImage);
                        tcItem.iImage = -1;
                    }

                } else {

                    tcItem.iImage = -1;
                }

            } else {

                //
                // Add new icon to the image list only if hIcon is not NULL
                //
                //


                if (hIcon) {

                    if (!himi) {

                        if (!(himi = ImageList_Create(16,
                                                      16,
                                                      ILC_COLOR4 | ILC_MASK,
                                                      16,
                                                      16))) {

                            CPSUIERR(("SetPSUIPageIcon: Create Tab Contrl Image List FAILED"));
                            return(0);
                        }

                        if (SendMessage(hWndTab,
                                        TCM_SETIMAGELIST,
                                        0,
                                        (LPARAM)himi)) {

                            CPSUIERR(("SetPSUIPageIcon: ?Has Previous Image list"));
                        }
                    }

                    tcItem.iImage = ImageList_AddIcon(himi, hIcon);

                } else {

                    //
                    // nothing to do
                    //

                    return(1);
                }
            }

            pPage->hPageInfo.hIcon = hIcon;
            tcItem.mask            = TCIF_IMAGE;

            if (SendMessage(hWndTab,
                            TCM_SETITEMW,
                            (WPARAM)InsIdx,
                            (LPARAM)(TC_ITEM FAR*)&tcItem)) {

                return(1);
            }

        }
    }

    return(0);
}



UINT
CALLBACK
PropSheetProc(
    HWND    hWnd,
    UINT    Msg,
    LPARAM  lParam
    )
{
    HWND    hWndTab;


    if (hWnd) {

        PTABTABLE   pTabTable;
        HANDLE      hRootPage;
        PCPSUIPAGE  pRootPage;
        HWND        hWndTab;
        WORD        Idx;

        LOCK_CPSUI_HANDLETABLE();

        Idx       = TLSVALUE_2_IDX(TlsGetValue(TlsIndex));
        hRootPage = WORD_2_HANDLE(Idx);

        CPSUIDBG(DBG_PAGE_PROC, ("ProcessID=%ld, ThreadID=%ld [TIsValue=%08lx]",
                GetCurrentProcessId(), GetCurrentThreadId(),
                TlsGetValue(TlsIndex)));

        if (pRootPage = HANDLETABLE_GetCPSUIPage(hRootPage)) {

            if ((pRootPage->Flags & CPF_ROOT)                   &&
                (pRootPage->RootInfo.hDlg = hWnd)               &&
                (pTabTable = pRootPage->RootInfo.pTabTable)     &&
                (pTabTable->hWndTab == NULL)                    &&
                (pTabTable->hWndTab = hWndTab =
                                            PropSheet_GetTabControl(hWnd))) {

                //
                // Done and remembered so reset it back to 0
                //

                CPSUIDBG(DBG_PAGE_PROC,
                         ("PropSheetProc: hDlg RootPage=%08lx", hWnd));

                pTabTable->hPSDlg  = hWnd;
                pTabTable->WndProc = (WNDPROC)GetWindowLongPtr(hWndTab,
                                                               GWLP_WNDPROC);

                SetProp(hWndTab, CPSUIPROP_TABTABLE, (HANDLE)pTabTable);
                SetWindowLongPtr(hWndTab, GWLP_WNDPROC, (LPARAM)TabCtrlWndProc);
            }

            HANDLETABLE_UnGetCPSUIPage(pRootPage);

        } else {

            CPSUIERR(("PropSheetProc(): Invalid pRootPage=%08lx ???", pRootPage));
        }

        UNLOCK_CPSUI_HANDLETABLE();
    }

    CPSUIDBG(DBG_PAGE_PROC,
             ("hWnd=%08lx, Msg=%ld, lParam=%08lx", hWnd, Msg, lParam));

    return(0);
}




UINT
CALLBACK
CPSUIPSPCallBack(
    HWND            hWnd,
    UINT            Msg,
    LPPROPSHEETPAGE pPSPage
    )

/*++

Routine Description:

    This function trap user supplied PropSheetPageProc callback function to
    fixed up our PROPSHEETPAGE structure's lParam, pfnCallback, pfnDlgProc and
    dwSize.

Arguments:




Return Value:




Author:

    28-Jun-1996 Fri 12:49:48 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    ULONG_PTR ulCookie = 0;
    BOOL bCtxActivated = FALSE;
    HANDLE hActCtx = INVALID_HANDLE_VALUE;

    if (Msg == PSPCB_CREATE) {

        PCPSUIPAGE          pCPSUIPage;
        DLGPROC             DlgProc;
        LPFNPSPCALLBACK     pspCB;
        DWORD               dwSize;
        UINT                Result;


        pCPSUIPage = (PCPSUIPAGE)pPSPage->lParam;
        DlgProc    = pPSPage->pfnDlgProc;
        pspCB      = pPSPage->pfnCallback;
        dwSize     = pPSPage->dwSize;

        CPSUIDBG(DBG_PAGEDLGPROC,
                 ("PSPCB_CREATE(1): pCPSUIPage=%08lx, DlgProc=%08lx,  lParam=%08lx, pspCB=%08lx, Size=%ld",
                 pCPSUIPage, pPSPage->pfnDlgProc,
                 pPSPage->lParam, pPSPage->pfnCallback, pPSPage->dwSize));

        //
        // fixed up user's pfnDlgProc, lParam, pfnCallback, dwSize
        //

        pPSPage->pfnDlgProc  = pCPSUIPage->hPageInfo.DlgProc;
        pPSPage->lParam      = pCPSUIPage->hPageInfo.lParam;
        pPSPage->pfnCallback = pCPSUIPage->hPageInfo.pspCB;
        pPSPage->dwSize      = pCPSUIPage->hPageInfo.dwSize;

        CPSUIDBG(DBG_PSPCB,
                ("CPSUIPSPCallBack(hWnd=%08lx, Msg=%ld, pPSPage=%08lx)",
                                            hWnd, Msg, pPSPage));

        try {

            if (GetPageActivationContext(pCPSUIPage, &hActCtx)) {

                bCtxActivated = ActivateActCtx(hActCtx, &ulCookie);
            }

            __try {

                Result = pPSPage->pfnCallback(hWnd, Msg, pPSPage);
            } 
            __finally  {

                //
                // we need to deactivate the context, no matter what!
                //
                if (bCtxActivated) {
                    
                    DeactivateActCtx(0, ulCookie);
                }
            }

        } except (FilterException(pCPSUIPage->hCPSUIPage,
                                  GetExceptionInformation())) {

            Result = 0;
        }

        //
        // save back if user change it
        //

        pCPSUIPage->hPageInfo.DlgProc  = pPSPage->pfnDlgProc;
        pCPSUIPage->hPageInfo.lParam   = pPSPage->lParam;
        pCPSUIPage->hPageInfo.pspCB    = pPSPage->pfnCallback;

        CPSUIDBG(DBG_PAGEDLGPROC,
                 ("PSPCB_CREATE(2): pCPSUIPage=%08lx, DlgProc=%08lx,  lParam=%08lx, pspCB=%08lx, Size=%ld",
                 pCPSUIPage, pPSPage->pfnDlgProc,
                 pPSPage->lParam, pPSPage->pfnCallback, pPSPage->dwSize));

        //
        // Now put in original content at this call
        //

        pPSPage->pfnDlgProc  = DlgProc;
        pPSPage->lParam      = (LPARAM)pCPSUIPage;
        pPSPage->pfnCallback = pspCB;
        pPSPage->dwSize      = dwSize;

        CPSUIDBG(DBG_PAGEDLGPROC,
                 ("PSPCB_CREATE(3): pCPSUIPage=%08lx, DlgProc=%08lx,  lParam=%08lx, pspCB=%08lx, Size=%ld",
                 pCPSUIPage, pPSPage->pfnDlgProc,
                 pPSPage->lParam, pPSPage->pfnCallback, pPSPage->dwSize));

        return(Result);

    } else {

        CPSUIERR(("CPSUIPSPCallBack: Invalid Msg=%u passed, return 0", Msg));
        return(0);
    }
}




INT_PTR
CALLBACK
CPSUIPageDlgProc(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    This function trap for each property sheet page activation for remember
    its hDlg and handle to the property sheet, after we trap the WM_INITDIALOG
    we will release the trap DlgProc.


Arguments:



Return Value:




Author:

    28-Jun-1995 Wed 17:00:44 created  -by-  Daniel Chou (danielc)


Revision History:

    Add original dwSize, pfnCallback trap

--*/

{
    ULONG_PTR ulCookie = 0;
    BOOL bCtxActivated = FALSE;
    HANDLE hActCtx = INVALID_HANDLE_VALUE;

    if (Msg == WM_INITDIALOG) {

        LPPROPSHEETPAGE pPSPage;
        PCPSUIPAGE      pCPSUIPage;
        PCPSUIPAGE      pRootPage;
        LONG            Result;


        pPSPage    = (LPPROPSHEETPAGE)lParam;
        pRootPage  =
        pCPSUIPage = (PCPSUIPAGE)pPSPage->lParam;

        while (pRootPage->pParent) {

            pRootPage = pRootPage->pParent;
        }

        CPSUIASSERT(0, "CPSUIPageDlgProc: No ROOT Page=%08lx",
                    (pRootPage->Flags & CPF_ROOT), pRootPage);

        if (pRootPage->Flags & CPF_ROOT) {

            if (pRootPage->RootInfo.hDlg) {

                CPSUIDBG(DBG_PAGEDLGPROC,
                         ("CPSUIPageDlgProc: Already has a hDlg in ROOT=%08lx",
                            pRootPage->RootInfo.hDlg));

            } else {

                pRootPage->RootInfo.hDlg = GetParent(hDlg);
            }
        }

        //
        // Fixed up user's DlgProc, lParam, pfnCallBack and dwSize and remember
        // this hDlg.  After we call the WM_INITDIALOG, we will not reset it
        // back since we will already trap it and will not need any more of
        // these information, the pfnCallback for the PSPCB_RELEASE will go to
        // the user supplied callback directly if one exist.
        //

        pPSPage->pfnDlgProc         = pCPSUIPage->hPageInfo.DlgProc;
        pPSPage->lParam             = pCPSUIPage->hPageInfo.lParam;
        pPSPage->pfnCallback        = pCPSUIPage->hPageInfo.pspCB;
        pPSPage->dwSize             = pCPSUIPage->hPageInfo.dwSize;
        pCPSUIPage->hPageInfo.hDlg  = hDlg;
        pCPSUIPage->Flags          |= CPF_ACTIVATED;

        CPSUIDBG(DBG_PAGEDLGPROC,
                ("CPSUIPageDlgProc: WM_INITDIALOG: hDlg=%08lx, pCPSUIPage=%08lx, DlgProc=%08lx,  lParam=%08lx, pspCB=%08lx, Size=%ld",
                hDlg, pCPSUIPage, pPSPage->pfnDlgProc,
                pPSPage->lParam, pPSPage->pfnCallback, pPSPage->dwSize));

        SetWindowLongPtr(hDlg, DWLP_DLGPROC, (LPARAM)pPSPage->pfnDlgProc);

        try {

            if (GetPageActivationContext(pCPSUIPage, &hActCtx)) {

                bCtxActivated = ActivateActCtx(hActCtx, &ulCookie);
            }

            __try {

                Result = pPSPage->pfnDlgProc(hDlg, Msg, wParam, lParam) ? TRUE : FALSE;
            } 
            __finally  {

                //
                // we need to deactivate the context, no matter what!
                //
                if (bCtxActivated) {
                    
                    DeactivateActCtx(0, ulCookie);
                }
            }

        } except (FilterException(pRootPage->hCPSUIPage,
                                  GetExceptionInformation())) {

            Result = FALSE;
        }

        return(Result);
    }

    return(FALSE);
}



BOOL
EnumCPSUIPagesSeq(
    PCPSUIPAGE          pRootPage,
    PCPSUIPAGE          pCPSUIPage,
    CPSUIPAGEENUMPROC   CPSUIPageEnumProc,
    LPARAM              lParam
    )

/*++

Routine Description:

    This function enumerate pCPSUIPage and all its children includes header
    page of children.   The enumeration always enumerate in the order of
    Parent first then the children in the sequence of tree.


Arguments:

    pCPSUIPage          - The starting parent page to be enumberated

    CPSUIPageEnumProc   - The caller supplied function for each enumberated
                          page, this fucntion return FALSE to stop enumeration.

    lParam              - a 32-bit parameter passed to the caller supplied
                          enumeration funciton


Return Value:

    BOOLEAN


Author:

    29-Dec-1995 Fri 15:25:01 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BOOL    Ok = TRUE;

    //
    // now enumerate the parent
    //

    LOCK_CPSUI_HANDLETABLE();

    if (CPSUIPageEnumProc(pRootPage, pCPSUIPage, lParam)) {

        if (pCPSUIPage->Flags & CPF_PARENT) {

            //
            // If this a parent then enum all its children first
            //

            PCPSUIPAGE  pCurPage = pCPSUIPage->pChild;
            PCPSUIPAGE  pNext;

            while (pCurPage) {

                pNext = pCurPage->pNext;

                if (!EnumCPSUIPagesSeq(pRootPage,
                                       pCurPage,
                                       CPSUIPageEnumProc,
                                       lParam)) {

                    Ok = FALSE;
                    break;
                }

                pCurPage = pNext;
            }
        }

    } else {

        Ok = FALSE;
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(Ok);
}



BOOL
EnumCPSUIPages(
    PCPSUIPAGE          pRootPage,
    PCPSUIPAGE          pCPSUIPage,
    CPSUIPAGEENUMPROC   CPSUIPageEnumProc,
    LPARAM              lParam
    )

/*++

Routine Description:

    This function enumerate pCPSUIPage and all its children includes header
    page of children.   The enumeration always enumerate in the order of
    children first then the parent.


Arguments:

    pCPSUIPage          - The starting parent page to be enumberated

    CPSUIPageEnumProc   - The caller supplied function for each enumberated
                          page, this fucntion return FALSE to stop enumeration.

    lParam              - a 32-bit parameter passed to the caller supplied
                          enumeration funciton


Return Value:

    BOOLEAN


Author:

    29-Dec-1995 Fri 15:25:01 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BOOL    Ok = TRUE;


    LOCK_CPSUI_HANDLETABLE();

    if (pCPSUIPage->Flags & CPF_PARENT) {

        //
        // If this a parent then enum all its children first
        //

        PCPSUIPAGE  pCurPage = pCPSUIPage->pChild;
        PCPSUIPAGE  pNext;

        while (pCurPage) {

            pNext = pCurPage->pNext;

            if (!EnumCPSUIPages(pRootPage,
                                pCurPage,
                                CPSUIPageEnumProc,
                                lParam)) {

                Ok = FALSE;
                break;
            }

            pCurPage = pNext;
        }
    }

    //
    // now enumerate the parent
    //

    if (Ok) {

        Ok = CPSUIPageEnumProc(pRootPage, pCPSUIPage, lParam);
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(Ok);
}





LONG
CallpfnPSUI(
    PCPSUIPAGE  pCPSUIPage,
    WORD        Reason,
    LPARAM      lParam
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    31-Jan-1996 Wed 14:27:21 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    ULONG_PTR ulCookie = 0;
    BOOL bCtxActivated = FALSE;
    HANDLE hActCtx = INVALID_HANDLE_VALUE;

    LONG    Result = 0;
    DWORD   dwErr = ERROR_SUCCESS;

    HANDLETABLE_LockCPSUIPage(pCPSUIPage);

    CPSUIDBG(DBG_CALLPFN, ("\n@ CallpfnPSUI(%08lx, %hs, %08lx)", pCPSUIPage,
                (Reason <= MAX_PROPSHEETUI_REASON_INDEX) ?
                        pszPFNReason[Reason] : "??? Unknown Reason",
                (Reason == PROPSHEETUI_REASON_SET_RESULT) ?
                    ((PSETRESULT_INFO)lParam)->Result : lParam));

    CPSUIASSERT(0, "CallpfnPSUI() Invalid Reason=%08lx",
                (Reason <= MAX_PROPSHEETUI_REASON_INDEX), Reason);

    if ((pCPSUIPage)                                &&
        (pCPSUIPage->Flags & CPF_PFNPROPSHEETUI)    &&
        (pCPSUIPage->hCPSUIPage)                    &&
        (pCPSUIPage->pfnInfo.pfnPSUI)) {

        PCPSUIPAGE          pRootPage;
        PROPSHEETUI_INFO    PSUIInfo;

        ZeroMemory(&PSUIInfo, sizeof(PSUIInfo));
        PSUIInfo.cbSize          = sizeof(PROPSHEETUI_INFO);
        PSUIInfo.Version         = PROPSHEETUI_INFO_VERSION;
        PSUIInfo.Flags           = (pCPSUIPage->Flags & CPF_ANSI_CALL) ?
                                                       0 : PSUIINFO_UNICODE;
        PSUIInfo.hComPropSheet   = pCPSUIPage->hCPSUIPage;
        PSUIInfo.pfnComPropSheet = CPSUICallBack;

        if ((PSUIInfo.Reason = Reason) == PROPSHEETUI_REASON_INIT) {

            pCPSUIPage->pfnInfo.lParamInit =
            PSUIInfo.lParamInit            = lParam;
            PSUIInfo.UserData              = 0;
            PSUIInfo.Result                = 0;

        } else {

            PSUIInfo.lParamInit = pCPSUIPage->pfnInfo.lParamInit;
            PSUIInfo.UserData   = pCPSUIPage->pfnInfo.UserData;
            PSUIInfo.Result     = pCPSUIPage->pfnInfo.Result;
        }

        CPSUIDBG(DBG_CALLPFN, ("CallpfnCPSUI: cbSize=%ld", (DWORD)PSUIInfo.cbSize));
        CPSUIDBG(DBG_CALLPFN, ("              Version=%04lx", (DWORD)PSUIInfo.Version));
        CPSUIDBG(DBG_CALLPFN, ("              Reason=%ld", (DWORD)PSUIInfo.Reason));
        CPSUIDBG(DBG_CALLPFN, ("              Flags=%08lx", (DWORD)PSUIInfo.Flags));
        CPSUIDBG(DBG_CALLPFN, ("              hComPropSheet=%08lx", PSUIInfo.hComPropSheet));
        CPSUIDBG(DBG_CALLPFN, ("              pfnComPropSheet=%08lx", PSUIInfo.pfnComPropSheet));
        CPSUIDBG(DBG_CALLPFN, ("              Result=%08lx", PSUIInfo.Result));
        CPSUIDBG(DBG_CALLPFN, ("              UserData=%08lx", PSUIInfo.UserData));

        try {

            if (GetPageActivationContext(pCPSUIPage, &hActCtx)) {

                bCtxActivated = ActivateActCtx(hActCtx, &ulCookie);
            }

            __try {

                Result = pCPSUIPage->pfnInfo.pfnPSUI(&PSUIInfo, lParam);
            } 
            __finally  {

                //
                // we need to deactivate the context, no matter what!
                //
                if (bCtxActivated) {
                    
                    DeactivateActCtx(0, ulCookie);
                }
            }

        } except (FilterException(pCPSUIPage->hCPSUIPage,
                                  GetExceptionInformation())) {

            Result = -1;
        }

        if (Result <= 0) {
            //
            // Something has failed. Save the last error here.
            //
            dwErr = GetLastError();
        }

        //
        // Save the new UserData and Result
        //

        pCPSUIPage->pfnInfo.UserData = PSUIInfo.UserData;
        pCPSUIPage->pfnInfo.Result   = PSUIInfo.Result;

        //
        // If this is the first pfnPropSheetUI() added and it passed a pResult
        // to the CommonPropertySheetUI() then set the result for it too.
        //

        if ((pRootPage = pCPSUIPage->pParent)   &&
            (pRootPage->Flags & CPF_ROOT)       &&
            (pRootPage->RootInfo.pResult)) {

            *(pRootPage->RootInfo.pResult) = (DWORD)PSUIInfo.Result;
        }

        CPSUIDBG(DBG_CALLPFN, ("---------CallpfnCPSUI()=%ld----------", Result));
        CPSUIDBG(DBG_CALLPFN, ("    New Result=%08lx%ws", PSUIInfo.Result,
                ((pRootPage) && (pRootPage->Flags & CPF_ROOT) &&
                 (pRootPage->RootInfo.pResult)) ? L" (== *pResult)" : L""));
        CPSUIDBG(DBG_CALLPFN, ("    New UserData=%08lx\n", PSUIInfo.UserData));

    } else {

        CPSUIERR(("CallpfnPSUI(): Invalid pCPSUIPage=%08lx", pCPSUIPage));
    }

    HANDLETABLE_UnLockCPSUIPage(pCPSUIPage);

    if (ERROR_SUCCESS != dwErr) {
        //
        // Set the preserved last error.
        //
        SetLastError(dwErr);
    }

    return(Result);
}




HICON
pfnGetIcon(
    PCPSUIPAGE  pPage,
    LPARAM      lParam
    )

/*++

Routine Description:

    This function return the hIcon for the pfnPropSheetUI()


Arguments:

    pPage   - The page has CPF_PFNPROPSHEETUI flag set

    lParam  - LOWORD(lParam) = cxIcon
              HIWORD(lParam) = cyIcon

Return Value:




Author:

    11-Feb-1996 Sun 12:18:39 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCPSUIPAGE                  pChild;
    PTVWND                      pTVWnd;
    POPTITEM                    pItem;
    PROPSHEETUI_GETICON_INFO    PSUIGetIconInfo;


    PSUIGetIconInfo.cbSize = sizeof(PSUIGetIconInfo);
    PSUIGetIconInfo.Flags  = 0;

    if (!(PSUIGetIconInfo.cxIcon = LOWORD(lParam))) {

        PSUIGetIconInfo.cxIcon = (WORD)GetSystemMetrics(SM_CXICON);
    }

    if (!(PSUIGetIconInfo.cyIcon = HIWORD(lParam))) {

        PSUIGetIconInfo.cyIcon = (WORD)GetSystemMetrics(SM_CYICON);
    }

    PSUIGetIconInfo.hIcon = NULL;

    //
    // If this is the PFNPROPSHEETUI and it got only one child which is the
    // COMPROPSHEETUI then we can return the Icon for the COMPROPSHEETUI
    // internally
    //

    //
    // Skip to last PFNPROPSHEETUI in the chain
    //

    LOCK_CPSUI_HANDLETABLE();

    while ((pPage->Flags & CPF_PFNPROPSHEETUI)  &&
           (pChild = pPage->pChild)             &&
           (pChild->Flags & CPF_PFNPROPSHEETUI) &&
           (pChild->pNext == NULL)) {

        pPage = pChild;
    }

    if ((pPage->Flags & CPF_PFNPROPSHEETUI)                 &&
        (pChild = pPage->pChild)                            &&
        (pChild->Flags & CPF_COMPROPSHEETUI)                &&
        (pChild->pNext == NULL)                             &&
        (pTVWnd = pChild->CPSUIInfo.pTVWnd)                 &&
        (pItem = PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT))    &&
        (PSUIGetIconInfo.hIcon = MergeIcon(_OI_HINST(pItem),
                                           GETSELICONID(pItem),
                                           MK_INTICONID(0, 0),
                                           (UINT)PSUIGetIconInfo.cxIcon,
                                           (UINT)PSUIGetIconInfo.cyIcon))) {

        UNLOCK_CPSUI_HANDLETABLE();

    } else {

        UNLOCK_CPSUI_HANDLETABLE();

        CallpfnPSUI(pPage,
                    PROPSHEETUI_REASON_GET_ICON,
                    (LPARAM)&PSUIGetIconInfo);
    }

    return(PSUIGetIconInfo.hIcon);

}



LONG_PTR
pfnSetResult(
    HANDLE      hPage,
    ULONG_PTR   Result
    )

/*++

Routine Description:

    This function set the result to the pPage's parent page which has
    CPF_PFNPROPSHEETUI bit set


Arguments:




Return Value:




Author:

    04-Feb-1996 Sun 00:48:40 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCPSUIPAGE      pPage;
    PCPSUIPAGE      pParent;
    SETRESULT_INFO  SRInfo;


    if (!(pPage = HANDLETABLE_GetCPSUIPage(hPage))) {

        CPSUIERR(("pfnSetResult(): Invalid hPage=%08lx", hPage));
        return(-1);
    }

    SRInfo.cbSize    = sizeof(SRInfo);
    SRInfo.wReserved = 0;
    SRInfo.Result    = Result;
    Result           = 0;

    //
    // Finding its Parent first
    //

    HANDLETABLE_UnGetCPSUIPage(pPage);

    LOCK_CPSUI_HANDLETABLE();

    while ((pPage) && (pParent = pPage->pParent)) {

        if (pParent->Flags & CPF_PFNPROPSHEETUI) {

            BOOL    bRet;


            SRInfo.hSetResult = pPage->hCPSUIPage;

            ++Result;

            //
            // We did not unlock the handletable, so if called switch to other
            // thread and callback here then dead lock will occurred
            //

            bRet = (BOOL)(CallpfnPSUI(pParent,
                                      PROPSHEETUI_REASON_SET_RESULT,
                                      (LPARAM)&SRInfo) <= 0);

            if (bRet) {

                break;
            }
        }

        pPage = pParent;
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(Result);
}




LONG_PTR
SethStartPage(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pPage,
    LONG        Index
    )

/*++

Routine Description:

    This function find the index (lParam) page from the pPage

Arguments:




Return Value:




Author:

    06-Feb-1996 Tue 05:33:11 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG    Result;


    if (!pPage) {

        CPSUIERR(("SethStartPage(NULL): Invalid Page to set"));
        return(0);

    } else if (pRootPage->Flags & CPF_DONE_PROPSHEET) {

        CPSUIERR(("*Cannot Set StartPage now, Flags=%08lx*", pRootPage->Flags));

        return(0);
    }

    if (pPage->Flags & CPF_PARENT) {

        Result = Index;

        if (pPage->Flags & CPF_COMPROPSHEETUI) {

            switch (Result) {

            case SSP_TVPAGE:

                if ((Result = pPage->CPSUIInfo.TVPageIdx) == PAGEIDX_NONE) {

                    Result = pPage->CPSUIInfo.StdPageIdx1;
                }

                break;

            case SSP_STDPAGE1:

                Result = pPage->CPSUIInfo.StdPageIdx1;
                break;

            case SSP_STDPAGE2:

                Result = pPage->CPSUIInfo.StdPageIdx2;
                break;

            default:

                break;
            }
        }

        if (Result >= 0) {

            pPage = pPage->pChild;

            while ((pPage) && (Result--) && (pPage->pNext)) {

                pPage = pPage->pNext;
            }

        } else {

            Result = 0;
        }

    } else {

        Result = -1;
    }

    CPSUIDBG(DBG_SETHSTARTPAGE, ("SethStartPage: Result=%ld, pPage=%08lx",
                        (LONG)Result, pPage));

    if ((Result == -1) && (pPage)) {

        pRootPage->RootInfo.pStartPage = pPage;
        Result                         = 1;

        if ((pRootPage->Flags & CPF_SHOW_PROPSHEET) &&
            (pRootPage->RootInfo.hDlg)) {

            PropSheet_SetCurSel(pRootPage->RootInfo.hDlg,
                                pPage->hPage,
                                0);
        }

    } else {

        Result = 0;
        CPSUIERR(("SethStartPage: INVALID Index=%ld for pPage=%08lx",
                                Index, pPage));
    }

    return(Result);
}




BOOL
CALLBACK
SetPageProcInfo(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pCPSUIPage,
    LPARAM      lParam
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    29-Jan-1996 Mon 16:28:48 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define pPageProcInfo   ((PPAGEPROCINFO)lParam)

    if ((!(pCPSUIPage->Flags & CPF_PARENT)) &&
        (pCPSUIPage->hPage)) {

        PTABTABLE   pTabTable;
        WORD        i;

        if ((i = pPageProcInfo->iPage) < pPageProcInfo->cPage) {

            if (pPageProcInfo->phPage) {

                pPageProcInfo->phPage[i] = pCPSUIPage->hPage;
            }

            if (pPageProcInfo->pHandle) {

                pPageProcInfo->pHandle[i] = pCPSUIPage->hCPSUIPage;
            }

            if (pTabTable = pPageProcInfo->pTabTable) {

                pTabTable->cTab++;
                pTabTable->TabInfo[i].hDlg      = NULL;
                pTabTable->TabInfo[i].OrgInsIdx = i;
                pTabTable->TabInfo[i].HandleIdx =
                                        HANDLE_2_IDX(pCPSUIPage->hCPSUIPage);
            }

            pPageProcInfo->iPage++;

        } else {

            return(FALSE);
        }
    }

    return(TRUE);

#undef pPageProcInfo
}




BOOL
CALLBACK
SetInsPageIdxProc(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pCPSUIPage,
    LPARAM      lParam
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    14-Feb-1996 Wed 23:07:51 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PINSPAGEIDXINFO pInsPageIdxInfo = (PINSPAGEIDXINFO)lParam;

    if (pCPSUIPage->Flags & CPF_ROOT) {

        pInsPageIdxInfo->pTabTable->InsIdx = 0;

    } else if ((!(pCPSUIPage->Flags & CPF_PARENT)) &&
               (pCPSUIPage->hPage)) {

        if (pInsPageIdxInfo->pCPSUIPage == pCPSUIPage) {

            pInsPageIdxInfo->pCPSUIPage = NULL;
            return(FALSE);

        } else {

            ++(pInsPageIdxInfo->pTabTable->InsIdx);
        }
    }

    return(TRUE);
}



BOOL
CALLBACK
DeleteCPSUIPageProc(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pCPSUIPage,
    LPARAM      lParam
    )

/*++

Routine Description:

    This function is the enumeration proc for each of page need to be deleted


Arguments:

    pCPSUIPage  - Pointer to the page currently enumerated and need to be
                  deleted.

    lParam      - Pointer to the DWORD to be accumerate the total property
                  sheet pages deleted.


Return Value:

    BOOLEAN


Author:

    29-Dec-1995 Fri 13:43:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    DWORD   dw;

    //
    // Delete the Page, link sibling prev/next together
    //

    if (pCPSUIPage->pNext) {

        pCPSUIPage->pNext->pPrev = pCPSUIPage->pPrev;
    }

    if (pCPSUIPage->pPrev) {

        pCPSUIPage->pPrev->pNext = pCPSUIPage->pNext;
    }

    CPSUIDBG(DBG_DEL_PROC,
            ("DeleteCPSUIPage: Delete pCPSUIPage=%08lx, hCPSUIPage=%08lx, cPage=%ld",
            pCPSUIPage, pCPSUIPage->hCPSUIPage, pRootPage->RootInfo.cPage));

    if ((pCPSUIPage->pParent) &&
        (pCPSUIPage->pParent->pChild == pCPSUIPage)) {

        //
        // We are deleting the first child of the parent, set the next sibling
        // to be its first child.
        //

        CPSUIDBG(DBG_DEL_PROC, ("DeleteCPSUIPage: Delete First child, link head"));

        CPSUIASSERT(0, "DeleteCPSUIPageProc: First Child (%08lx) has pPrev",
                                        pCPSUIPage->pPrev == NULL, pCPSUIPage);

        pCPSUIPage->pParent->pChild = pCPSUIPage->pNext;
    }

    CPSUIASSERT(0, "DeleteCPSUIPageProc: Parent (%08lx) still has children",
                ((pCPSUIPage->Flags & CPF_PARENT) == 0)  ||
                 (pCPSUIPage->pChild == NULL), pCPSUIPage);


    if (pCPSUIPage->Flags & CPF_PARENT) {

        //
        // Clean up the COMPROPSHEETUI stuff if PTVWND exists
        //

        if (pCPSUIPage->Flags & CPF_PFNPROPSHEETUI) {

            CPSUIDBG(DBG_DEL_PROC,
                    ("DeleteCPSUIPage: Destroy CPF_PFNPROPSHEETUI=%08lx",
                    pCPSUIPage));

            CallpfnPSUI(pCPSUIPage,
                        PROPSHEETUI_REASON_DESTROY,
                        (LPARAM)(pRootPage->Flags & CPF_DONE_PROPSHEET));

            if ((pCPSUIPage->Flags & CPF_DLL) &&
                (pCPSUIPage->pfnInfo.hInst)) {

                CPSUIDBG(DBG_DEL_PROC, ("DeleteProc(%08lx): FreeLibrary(%08lx)",
                                    pCPSUIPage, pCPSUIPage->pfnInfo.hInst));

                FreeLibrary(pCPSUIPage->pfnInfo.hInst);
            }

        } else if ((pCPSUIPage->Flags & CPF_COMPROPSHEETUI) &&
                   (pCPSUIPage->CPSUIInfo.pTVWnd)) {

            CPSUIDBG(DBG_DEL_PROC,
                    ("DeleteCPSUIPage: CPF_CPSUI=%08lx, CleanUp/Free pTVWnd=%08lx",
                        pCPSUIPage->CPSUIInfo.pTVWnd));

            CleanUpTVWND(pCPSUIPage->CPSUIInfo.pTVWnd);
            LocalFree((HLOCAL)pCPSUIPage->CPSUIInfo.pTVWnd);
        }

    } else {

        //
        // Do any end processing needed for this page
        //

        if (pCPSUIPage->hPage) {

            if (!(pRootPage->Flags & CPF_DONE_PROPSHEET)) {

                if (pRootPage->RootInfo.hDlg) {

                    //
                    // The Property sheet already displayed
                    //

                    CPSUIDBG(DBG_DEL_PROC,
                        ("DeleteCPSUIPage: REMOVE hPage=%08lx", pCPSUIPage->hPage));

                    PropSheet_RemovePage(pRootPage->RootInfo.hDlg,
                                         0,
                                         pCPSUIPage->hPage);

                } else {

                    CPSUIDBG(DBG_DEL_PROC,
                        ("DeleteCPSUIPage: DESTROY hPage=%08lx", pCPSUIPage->hPage));

                    DestroyPropertySheetPage(pCPSUIPage->hPage);
                }
            }

            pRootPage->RootInfo.cPage--;

            if (lParam) {

                ++(*(LPDWORD)lParam);
            }

        } else if (!(pCPSUIPage->Flags & CPF_CALL_TV_DIRECT)) {

            CPSUIWARN(("DeleteCPSUIPageProc: CHILD (%08lx) but hPage=NULL",
                                                                pCPSUIPage));
        }

        CPSUIDBG(DBG_DEL_PROC, ("DeleteCPSUIPage: Delete pCPSUIPage, cPage=%ld",
                                    pRootPage->RootInfo.cPage));
    }

    //
    // Remove it from the handle table
    //

    if (HANDLETABLE_DeleteHandle(pCPSUIPage->hCPSUIPage)) {

        if ((pCPSUIPage != pRootPage)   &&
            (pRootPage->RootInfo.pStartPage == pCPSUIPage)) {

            pRootPage->RootInfo.pStartPage = NULL;
        }
    }

    return(TRUE);
}



PCPSUIPAGE
AddCPSUIPage(
    PCPSUIPAGE  pParent,
    HANDLE      hInsert,
    BYTE        Mode
    )

/*++

Routine Description:

    This function add a new CPSUIPAGE to the pParent page.  If pParent is NULL
    then it create ROOT page.   The new page always added as last child of the
    pParent.


Arguments:

    pParent     - Pointer to the CPSUIPAGE which will be new child's parent

    hInsert     - Handle to the children page will insert at. The meaning of
                  hInsert depends on the Mode passed.   if pParent is NULL
                  then hInsert is ignored

    Mode        - Mode of insertion, it can be one of the following

                    INSPSUIPAGE_MODE_BEFORE

                        Insert pages before the common property sheet page
                        handle specified by hInsert


                    INSPSUIPAGE_MODE_AFTER

                        Insert pages after the common property sheet page
                        handle specified by hInsert


                    INSPSUIPAGE_MODE_FIRST_CHILD

                        Insert pages as the first child of hComPropSheet
                        parent handle.


                    INSPSUIPAGE_MODE_LAST_CHILD

                        Insert pages as the last child of hComPropSheet
                        parent handle.


                    INSPSUIPAGE_MODE_INDEX

                        Insert pages as a zero base child index of its
                        parent handle specified by hComPropSheet.

                        The hInsert is the zero based index special handle
                        that must generated by HINSPSUIPAGE_INDEX(Index)
                        macro.

Return Value:

    PCPSUIPAGE, if function sucessful, when this function sucessed, it also
    return the hChild handle in hCPSUIPage field.  It return NULL if this
    function failed.

Author:

    02-Jan-1996 Tue 13:49:34 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HANDLE      hChild;
    PCPSUIPAGE  pChild;


    if (!(pChild = (PCPSUIPAGE)LocalAlloc(LPTR, sizeof(CPSUIPAGE)))) {

        CPSUIERR(("AddCPSUIPage: LocalAlloc(CPSUIPAGE) failed"));
        return(NULL);
    }

    LOCK_CPSUI_HANDLETABLE();

    if (hChild = HANDLETABLE_AddCPSUIPage(pChild)) {

        pChild->ID         = CPSUIPAGE_ID;
        pChild->hCPSUIPage = hChild;
        pChild->hActCtx    = INVALID_HANDLE_VALUE;
        pChild->pParent    = pParent;

        if (pParent) {

            PCPSUIPAGE  pCurPage;
            BOOL        Ok = FALSE;

            //
            // Either insert first, or this is the first child
            //

            if ((!(pCurPage = pParent->pChild))         ||
                (Mode == INSPSUIPAGE_MODE_FIRST_CHILD)  ||
                ((Mode == INSPSUIPAGE_MODE_INDEX)   &&
                 (!HINSPSUIPAGE_2_IDX(hInsert)))) {

                //
                // Insert as first child, link to the first one first
                //
                //

                if (pChild->pNext = pCurPage) {

                    pCurPage->pPrev = pChild;
                }

                pParent->pChild = pChild;
                Ok              = TRUE;

            } else {

                PCPSUIPAGE  pNext;
                UINT        i = 0xFFFF;


                switch (Mode) {

                case INSPSUIPAGE_MODE_INDEX:

                    i = HINSPSUIPAGE_2_IDX(hInsert);

                case INSPSUIPAGE_MODE_LAST_CHILD:

                    while ((i--) && (pCurPage)) {

                        if ((!i) || (!(pCurPage->pNext))) {

                            Ok = TRUE;
                            break;
                        }

                        pCurPage = pCurPage->pNext;
                    }

                    break;

                case INSPSUIPAGE_MODE_BEFORE:

                    while (pCurPage) {

                        if ((pNext = pCurPage->pNext)   &&
                            (pNext->hCPSUIPage == hInsert)) {

                            Ok = TRUE;
                            break;
                        }

                        pCurPage = pNext;
                    }

                    break;

                case INSPSUIPAGE_MODE_AFTER:

                    while (pCurPage) {

                        if (pCurPage->hCPSUIPage == hInsert) {

                            Ok = TRUE;
                            break;
                        }

                        pCurPage = pCurPage->pNext;
                    }

                    break;

                default:

                    CPSUIERR(("Invalid inseert Mode = %u passed", Mode));
                    break;
                }

                if (Ok) {

                    pChild->pPrev = pCurPage;

                    if (pChild->pNext = pCurPage->pNext) {

                        pCurPage->pNext->pPrev = pChild;
                    }

                    pCurPage->pNext = pChild;

                } else {

                    //
                    // We never insert after
                    //

                    CPSUIERR(("AddCPSUIPage: Cannot Insert Page: Mode=%ld, hInsert=%08lx, pParent=%08lx",
                                Mode, hInsert, pParent));

                    HANDLETABLE_UnGetCPSUIPage(pChild);
                    HANDLETABLE_DeleteHandle(hChild);
                    pChild = NULL;
                }
            }

        } else {

            //
            // This is the ROOT page
            //

            CPSUIDBG(DBG_ADD_CPSUIPAGE,
                     ("AddCPSUIPage: Add %08lx as ROOT PAGE", pChild));

            pChild->Flags |= (CPF_ROOT | CPF_PARENT);
        }

    } else {

        CPSUIERR(("AddCPSUIPage: HANDLETABLE_AddCPSUIPage(pChild=%08lx) failed",
                    pChild));

        LocalFree((HLOCAL)pChild);
        pChild = NULL;
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(pChild);
}




BOOL
AddPropSheetPage(
    PCPSUIPAGE      pRootPage,
    PCPSUIPAGE      pCPSUIPage,
    LPPROPSHEETPAGE pPSPage,
    HPROPSHEETPAGE  hPSPage
    )

/*++

Routine Description:

    Add this PROPSHEETPAGE page to the property sheet dialog box and associate
    with the pCPSUIPage


Arguments:

    pRootPage   - Pointer to the root page of CPSUIPAGE which this data
                  instance is associated with.

    pCPSUIPage  - Pointer to the CPSUIPAGE which the pPropSheetPage will
                  be associated with.

    pPSPage     - Pointer to the PROPSHEETPAGE data structure of the page to
                  be added, if this is NULL then hPSPage will be used

    hPSPage     - Handle to PROPSHEETPAGE created by the caller to be added


Return Value:




Author:

    03-Jan-1996 Wed 13:28:31 created  -by-  Daniel Chou (danielc)


Revision History:

    17-Dec-1997 Wed 16:21:52 updated  -by-  Daniel Chou (danielc)
        Unlock the handle table when we display the direct treeview page, this
        is done because when handle table is locked, any other thread in the
        current process cannot display anymore cpsui pages.


--*/

{
    PROPSHEETPAGE psp;
    HANDLE  hActCtx = INVALID_HANDLE_VALUE;
    BOOL    Ok = TRUE;


    LOCK_CPSUI_HANDLETABLE();

    if (pRootPage->RootInfo.cPage >= MAXPROPPAGES) {

        CPSUIASSERT(0, "AddPropSheetPage: Too many pages=%08lx", FALSE,
                                            pRootPage->RootInfo.cPage);
        Ok = FALSE;

    } else if (pPSPage) {

        LPBYTE          pData;
        PPSPINFO        pPSPInfo;
        DWORD           dwSize;

        //
        // Create a local copy of the PROPSHEETPAGE and add in our own PSPINFO
        // at end of the structure.
        //

        dwSize = pPSPage->dwSize;

        if (pData = (LPBYTE)LocalAlloc(LPTR, dwSize + sizeof(PSPINFO))) {

            CopyMemory(pData, pPSPage, dwSize);

            pPSPage                       = (LPPROPSHEETPAGE)pData;
            pPSPInfo                      = (PPSPINFO)(pData + dwSize);

            pPSPInfo->cbSize              = sizeof(PSPINFO);
            pPSPInfo->wReserved           = 0;
            pPSPInfo->hComPropSheet       = pCPSUIPage->pParent->hCPSUIPage;
            pPSPInfo->hCPSUIPage          = pCPSUIPage->hCPSUIPage;
            pPSPInfo->pfnComPropSheet     = CPSUICallBack;

            CPSUIDBG(DBG_PAGEDLGPROC,
                     ("AddPropSheetPage: pCPSUIPage=%08lx, DlgProc=%08lx,  lParam=%08lx, pspCB=%08lx, Size=%ld",
                     pCPSUIPage, pPSPage->pfnDlgProc,
                     pPSPage->lParam, pPSPage->pfnCallback, pPSPage->dwSize));

            pCPSUIPage->hPageInfo.DlgProc = pPSPage->pfnDlgProc;
            pCPSUIPage->hPageInfo.lParam  = pPSPage->lParam;
            pCPSUIPage->hPageInfo.pspCB   = pPSPage->pfnCallback;
            pCPSUIPage->hPageInfo.dwSize  = dwSize;
            pPSPage->pfnCallback          = CPSUIPSPCallBack;
            pPSPage->pfnDlgProc           = CPSUIPageDlgProc;
            pPSPage->lParam               = (LPARAM)pCPSUIPage;
            pPSPage->dwSize               = dwSize + sizeof(PSPINFO);

            if (pCPSUIPage->Flags & CPF_CALL_TV_DIRECT) {

                CPSUIDBG(DBG_ADD_PSPAGE,
                         ("AddPropSheetPage(CPF_CALL_TV_DIRECT): cPage=%ld",
                            pRootPage->RootInfo.cPage));

                //
                // We will

                UNLOCK_CPSUI_HANDLETABLE();

                if (DialogBoxParam(hInstDLL,
                                   pPSPage->pszTemplate,
                                   pRootPage->RootInfo.hDlg,
                                   CPSUIPageDlgProc,
                                   (LPARAM)pPSPage) == -1) {

                    CPSUIERR(("DialogBoxParam(CALL_TV_DIRECT), hDlg=%08lx, Template=%08lx, FAILED",
                              pRootPage->RootInfo.hDlg, pPSPage->pszTemplate));
                }

                return(FALSE);

            } else {

                CPSUIDBG(DBG_ADD_PSPAGE, ("AddPropSheetPage: Add PROPSHEETPAGE=%08lx",
                                pPSPage));

                if (pPSPage->dwSize <= PROPSHEETPAGE_V2_SIZE) {

                    //
                    // the passed in PROPSHEETPAGE structure is version 2 or less
                    // which means it doesn't have fusion activation context at all
                    // let's thunk to the latest version (V3) so we can provide
                    // proper activation context.
                    //
                    ZeroMemory(&psp, sizeof(psp));

                    // first copy the data from the passed in page
                    CopyMemory(&psp, pPSPage, pPSPage->dwSize);

                    // set the new size (V3) and set pPSPage to point to psp
                    psp.dwSize = sizeof(psp);
                    pPSPage = &psp;
                }

                if (0 == (pPSPage->dwFlags & PSP_USEFUSIONCONTEXT)) {

                    if ((ULONG)(ULONG_PTR)pPSPage->pszTemplate >= DP_STD_RESERVED_START && 
                        (ULONG)(ULONG_PTR)pPSPage->pszTemplate <= DP_STD_TREEVIEWPAGE) {

                        // if the page is standard page or treeview page, we'll force to context 
                        // to V6
                        pPSPage->dwFlags |= PSP_USEFUSIONCONTEXT;
                        pPSPage->hActCtx = g_hActCtx;

                    } else if (GetPageActivationContext(pCPSUIPage, &hActCtx)) {

                        // if the caller did not provide an activation context explicitly
                        // then we set the activation context from the compstui handle (if any)
                        // by climbing up the hierarchy until we find a page with a proper 
                        // activation context set.

                        pPSPage->dwFlags |= PSP_USEFUSIONCONTEXT;
                        pPSPage->hActCtx = hActCtx;
                    }
                }

                if (pCPSUIPage->Flags & CPF_ANSI_CALL) {

                    hPSPage = SHNoFusionCreatePropertySheetPageA((LPPROPSHEETPAGEA)pPSPage);

                } else {

                    hPSPage = SHNoFusionCreatePropertySheetPageW(pPSPage);
                }

                if (!hPSPage) {

                    CPSUIASSERT(0, "AddPropSheetPage: CreatePropertySheetPage(%08lx) failed",
                                FALSE, pPSPage);
                    Ok = FALSE;
                }
            }

            LocalFree((HLOCAL)pData);

        } else {

            Ok = FALSE;

            CPSUIASSERT(0, "AddPropSheetPage: Allocate %08lx bytes failed",
                        FALSE, ULongToPtr(pPSPage->dwSize));
        }

    } else if (hPSPage) {

        CPSUIDBG(DBG_ADD_PSPAGE, ("AddPropSheetPage: Add *HPROPSHEETPAGE*=%08lx",
                            hPSPage));

        pCPSUIPage->Flags |= CPF_CALLER_HPSPAGE;

    } else {

        Ok = FALSE;

        CPSUIASSERT(0, "AddPropSheetPage: hPSPage = NULL", FALSE, 0);
    }

    if (Ok) {

        pCPSUIPage->hPage = hPSPage;

        if (pRootPage->RootInfo.hDlg) {

            INSPAGEIDXINFO  InsPageIdxInfo;

            //
            // The property sheet already displayed
            //

            if (InsPageIdxInfo.pTabTable = pRootPage->RootInfo.pTabTable) {

                InsPageIdxInfo.pCPSUIPage = pCPSUIPage;

                EnumCPSUIPagesSeq(pRootPage,
                                  pRootPage,
                                  SetInsPageIdxProc,
                                  (LPARAM)&InsPageIdxInfo);
            }

            CPSUIDBG(DBG_ADD_PSPAGE,
                     ("AddPropSheetPage: PropSheet_AddPage(%08lx) INSERT Index=%u / %u",
                            hPSPage, (UINT)InsPageIdxInfo.pTabTable->InsIdx,
                            (UINT)pRootPage->RootInfo.cPage));

            InsPageIdxInfo.pTabTable->HandleIdx =
                                        HANDLE_2_IDX(pCPSUIPage->hCPSUIPage);

            if (!PropSheet_AddPage(pRootPage->RootInfo.hDlg, hPSPage)) {

                Ok = FALSE;

                CPSUIASSERT(0, "AddPropSheetPage: PropSheet_AddPage(%08lx) failed",
                            FALSE, hPSPage);
            }
        }
    }

    if (Ok) {

        pRootPage->RootInfo.cPage++;

        CPSUIDBG(DBG_ADD_PSPAGE, ("AddPropSheetPage: cPage=%ld",
                            pRootPage->RootInfo.cPage));

    } else {

        CPSUIERR(("AddPropSheetPage: FAILED"));

        if (pCPSUIPage->hPage) {

            DestroyPropertySheetPage(pCPSUIPage->hPage);
            pCPSUIPage->hPage = NULL;
        }
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(Ok);
}




LONG
AddComPropSheetPage(
    PCPSUIPAGE  pCPSUIPage,
    UINT        PageIdx
    )

/*++

Routine Description:

    This function add the common property sheet UI standard pages to the
    hParent Page passed.

Arguments:

    pCPSUIPage  - pointer to the parent page which child will be added for the
                  common UI

    PageIdx     - Page index to be added. (zero based)


Return Value:

    LONG result, if <= 0 then error occurred, > 0 if sucessful


Author:

    24-Jan-1996 Wed 17:58:15 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTVWND          pTVWnd;
    PMYDLGPAGE      pCurMyDP;
    PROPSHEETPAGE   psp;
    LONG            Result;
    WORD            DlgTemplateID;
    WCHAR           Buf[MAX_RES_STR_CHARS];


    pTVWnd            = pCPSUIPage->CPSUIInfo.pTVWnd;
    pCurMyDP          = pTVWnd->pMyDlgPage + PageIdx;
    pCurMyDP->pTVWnd  = (LPVOID)pTVWnd;
    pCurMyDP->PageIdx = (BYTE)PageIdx;

    //
    // Set default User data for the callback
    //

    pCurMyDP->CPSUIUserData = pTVWnd->pCPSUI->UserData;

    if (pCurMyDP->DlgPage.cbSize != sizeof(DLGPAGE)) {

        return(ERR_CPSUI_INVALID_DLGPAGE_CBSIZE);
    }

    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = 0;

    //
    // psp.dwFlags     = (pTVWnd->Flags & TWF_HAS_HELPFILE) ? PSP_HASHELP : 0;
    //

    psp.lParam = (LPARAM)pCurMyDP;

    if (pCurMyDP->DlgPage.Flags & DPF_USE_HDLGTEMPLATE) {

        psp.pResource  = pCurMyDP->DlgPage.hDlgTemplate;
        psp.dwFlags   |= PSP_DLGINDIRECT;
        DlgTemplateID  = 0;

    } else {

        DlgTemplateID   = pCurMyDP->DlgPage.DlgTemplateID;
        psp.pszTemplate = MAKEINTRESOURCE(DlgTemplateID);
    }

    psp.pfnDlgProc  = PropPageProc;
    psp.hInstance   = hInstDLL;

    switch (DlgTemplateID) {

    case DP_STD_INT_TVPAGE:
    case DP_STD_TREEVIEWPAGE:

        CPSUIDBG(DBG_ADDCOMPAGE, ("AddComPropSheetPage: Add TVPage"));

        if (pTVWnd->TVPageIdx == PAGEIDX_NONE) {

            pCPSUIPage->CPSUIInfo.TVPageIdx = (LONG)PageIdx;
            pTVWnd->TVPageIdx               = (BYTE)PageIdx;
            psp.pfnDlgProc                  = TreeViewProc;

        } else {

            return(ERR_CPSUI_MORE_THAN_ONE_TVPAGE);
        }

        break;

    case DP_STD_DOCPROPPAGE1:

        CPSUIDBG(DBG_ADDCOMPAGE, ("AddComPropSheetPage: Add StdPage 1"));

        if (pTVWnd->cDMPub > 0) {

            if (pTVWnd->StdPageIdx1 == PAGEIDX_NONE) {

                pCPSUIPage->CPSUIInfo.StdPageIdx1 = (LONG)PageIdx;
                pTVWnd->StdPageIdx1               = (BYTE)PageIdx;

            } else {

                return(ERR_CPSUI_MORE_THAN_ONE_STDPAGE);
            }

        } else {

            //
            // This page got nothing
            //

            return(0);
        }

        break;


    case DP_STD_DOCPROPPAGE2:

        CPSUIDBG(DBG_ADDCOMPAGE, ("AddComPropSheetPage: Add StdPage 2"));

        if (pTVWnd->cDMPub > 0) {

            if (pTVWnd->StdPageIdx2 == PAGEIDX_NONE) {

                pCPSUIPage->CPSUIInfo.StdPageIdx2= (LONG)PageIdx;
                pTVWnd->StdPageIdx2              = (BYTE)PageIdx;

            } else {

                return(ERR_CPSUI_MORE_THAN_ONE_STDPAGE);
            }

        } else {

            //
            // This page got nothing
            //

            return(0);
        }

        break;


    default:

        psp.hInstance = pTVWnd->hInstCaller;
        break;
    }

    //
    // If we have error counting the page items or the page got not item then
    // return it now
    //

    if ((Result = CountPropPageItems(pTVWnd, (BYTE)PageIdx)) <= 0) {

        return(Result);
    }

    if (pCurMyDP->DlgPage.Flags & DPF_ICONID_AS_HICON) {

        psp.dwFlags |= PSP_USEHICON;
        psp.hIcon    = (HICON)pCurMyDP->DlgPage.IconID;

    } else if (psp.hIcon = GETICON16(pTVWnd->hInstCaller,
                                     pCurMyDP->DlgPage.IconID)) {

        psp.dwFlags     |= PSP_USEHICON;
        pCurMyDP->hIcon  = psp.hIcon;
    }

    Buf[0] = L'\0';

    if (pCPSUIPage->Flags & CPF_CALL_TV_DIRECT) {

        ComposeStrData(pTVWnd->hInstCaller,
                       (WORD)(GBF_PREFIX_OK        |
                              GBF_INT_NO_PREFIX    |
                              ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                       GBF_ANSI_CALL : 0)),
                       Buf,
                       COUNT_ARRAY(Buf),
                       IDS_INT_CPSUI_ADVDOCOPTION,
                       pTVWnd->ComPropSheetUI.pOptItemName,
                       0,
                       0);

    } else {

        GetStringBuffer(pTVWnd->hInstCaller,
                        (WORD)(GBF_PREFIX_OK        |
                               GBF_INT_NO_PREFIX    |
                               ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                        GBF_ANSI_CALL : 0)),
                        L'\0',
                        pCurMyDP->DlgPage.pTabName,
                        Buf,
                        COUNT_ARRAY(Buf));
    }

    if (Buf[0] != L'\0') {

        psp.pszTitle = (LPTSTR)Buf;
        psp.dwFlags |= PSP_USETITLE;
    }

    //
    // Internally we always translate to the UNICODE
    //

    if (CPSUICallBack(pCPSUIPage->hCPSUIPage,
                      CPSFUNC_ADD_PROPSHEETPAGEW,
                      (LPARAM)&psp,
                      (LPARAM)0L)) {

        return(1);

    } else {

        switch (DlgTemplateID) {

        case DP_STD_INT_TVPAGE:
        case DP_STD_TREEVIEWPAGE:

            pCPSUIPage->CPSUIInfo.TVPageIdx = PAGEIDX_NONE;
            pTVWnd->TVPageIdx               = PAGEIDX_NONE;

            break;

        case DP_STD_DOCPROPPAGE1:

            pCPSUIPage->CPSUIInfo.StdPageIdx1 = PAGEIDX_NONE;
            pTVWnd->StdPageIdx1               = PAGEIDX_NONE;

            break;


        case DP_STD_DOCPROPPAGE2:

            pCPSUIPage->CPSUIInfo.StdPageIdx2 = PAGEIDX_NONE;
            pTVWnd->StdPageIdx2               = PAGEIDX_NONE;

            break;
        }

        if (!(pCPSUIPage->Flags & CPF_CALL_TV_DIRECT)) {

            CPSUIERR(("AddComPropSheetPage() FAILED, IdxPage=%ld", PageIdx));
        }

        return(ERR_CPSUI_CREATEPROPPAGE_FAILED);
    }
}




LONG
AddComPropSheetUI(
    PCPSUIPAGE      pRootPage,
    PCPSUIPAGE      pCPSUIPage,
    PCOMPROPSHEETUI pCPSUI
    )

/*++

Routine Description:

    This is the main entry point to the common UI


Arguments:

    pRootPage   - Pointer to the CPSUIPAGE data structure of ROOT

    pCPSUIPage  - Pointer to the CPSUIPAGE which represent the hCPSUIPage

    pCPSUI      - Pointer to the COMPROPSHEETUI data structure to specified
                  how to add common UI pages.


Return Value:

    LONG

    <=0: Error occurred (Error Code of ERR_CPSUI_xxxx)
     >0: Total Pages added


Author:

    24-Jan-1996 Wed 16:54:30 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTVWND  pTVWnd = NULL;
    UINT    cPage = 0;
    LONG    Result = 0;
    DWORD   DMPubHideBits;
    DWORD   CPF_FlagsOr;


    if ((!pCPSUI) ||
        (pCPSUI->cbSize < sizeof(COMPROPSHEETUI))) {

        Result = ERR_CPSUI_INVALID_PDATA;

    } else if (!pCPSUI->hInstCaller) {

        Result = ERR_CPSUI_NULL_HINST;

    } else if (!pCPSUI->cOptItem) {

        Result = ERR_CPSUI_ZERO_OPTITEM;

    } else if (!pCPSUI->pOptItem) {

        Result = ERR_CPSUI_NULL_POPTITEM;

    } else if (!(pTVWnd = (PTVWND)LocalAlloc(LPTR,
                                             sizeof(TVWND) + sizeof(OIDATA) *
                                                        pCPSUI->cOptItem))) {

        Result = ERR_CPSUI_ALLOCMEM_FAILED;

    } else {

        if (pCPSUIPage->Flags & CPF_ANSI_CALL) {

            pTVWnd->Flags |= TWF_ANSI_CALL;
        }

        if (pCPSUI->Flags & CPSUIF_UPDATE_PERMISSION) {

            pTVWnd->Flags |= TWF_CAN_UPDATE;
        }

        //
        // Now convert the pCPSUI to the local buffer
        //

        Result = GetCurCPSUI(pTVWnd, (POIDATA)(pTVWnd + 1), pCPSUI);

        pTVWnd->pCPSUI        = pCPSUI;
        pCPSUI                = &(pTVWnd->ComPropSheetUI);
        pTVWnd->hCPSUIPage    = pCPSUIPage->hCPSUIPage;
        pTVWnd->pRootFlags    = (LPDWORD)&(pRootPage->Flags);
        pTVWnd->hInstCaller   = pCPSUI->hInstCaller;
        pTVWnd->pLastItem     = pCPSUI->pOptItem + pCPSUI->cOptItem - 1;
        pTVWnd->ActiveDlgPage =
        pTVWnd->TVPageIdx     =
        pTVWnd->StdPageIdx1   =
        pTVWnd->StdPageIdx2   = PAGEIDX_NONE;

        if (!pCPSUI->pCallerName) {

            pCPSUI->pCallerName = (LPTSTR)IDS_CPSUI_NO_NAME;
        }

        if (!pCPSUI->pOptItemName) {

            pCPSUI->pOptItemName = (LPTSTR)IDS_CPSUI_NO_NAME;
        }

        pCPSUIPage->CPSUIInfo.pTVWnd     = pTVWnd;
        pCPSUIPage->CPSUIInfo.TVPageIdx  = PAGEIDX_NONE;
        pCPSUIPage->CPSUIInfo.StdPageIdx1= PAGEIDX_NONE;
        pCPSUIPage->CPSUIInfo.StdPageIdx2= PAGEIDX_NONE;
    }

    //
    // Remember this one in the page
    //

    DMPubHideBits = pRootPage->RootInfo.DMPubHideBits;

    switch ((ULONG_PTR)pCPSUI->pDlgPage) {

    case (ULONG_PTR)CPSUI_PDLGPAGE_PRINTERPROP:

        CPF_FlagsOr   = CPF_PRINTERPROP;
        DMPubHideBits = 0;
        break;

    case (ULONG_PTR)CPSUI_PDLGPAGE_DOCPROP:

        CPF_FlagsOr = CPF_DOCPROP;
        break;

    case (ULONG_PTR)CPSUI_PDLGPAGE_ADVDOCPROP:

        CPF_FlagsOr = CPF_ADVDOCPROP;
        break;

    default:

        DMPubHideBits =
        CPF_FlagsOr   = 0;
        break;
    }

    if ((Result >= 0)                                                       &&
        ((Result = AddIntOptItem(pTVWnd)) >= 0)                             &&
        ((Result = SetpMyDlgPage(pTVWnd, pRootPage->RootInfo.cPage)) > 0)   &&
        ((Result = ValidatepOptItem(pTVWnd, DMPubHideBits)) >= 0)) {

        UINT    iPage = 0;

        //
        // Go through each page and add them to the property sheet if the
        // page got item
        //

        while ((iPage < (UINT)pTVWnd->cInitMyDlgPage) && (Result >= 0)) {

            if ((Result = AddComPropSheetPage(pCPSUIPage, iPage++)) > 0) {

                ++cPage;
            }
        }

        if ((cPage == 0) && (pTVWnd->Flags & TWF_HAS_ADVANCED_PUSH)) {

            //
            // If the advance is via push button but we did not add any pages
            // then we need to add the advanced page as default
            //

            pTVWnd->Flags &= ~TWF_HAS_ADVANCED_PUSH;
            pTVWnd->Flags |= TWF_ADVDOCPROP;

            if ((Result = AddComPropSheetPage(pCPSUIPage, iPage++)) > 0) {

                ++cPage;
            }

        } else {

            pTVWnd->cInitMyDlgPage = (BYTE)iPage;
        }
    }

    if (Result >= 0) {

        pCPSUIPage->Flags              |= CPF_FlagsOr;
        pRootPage->Flags               |= CPF_FlagsOr | CPF_HAS_CPSUI;
        pRootPage->RootInfo.cCPSUIPage += (WORD)cPage;

        CPSUIDBG(DBG_ADD_CPSUI, ("\nAddComPropSheetUI: TV=%ld, P1=%ld, p2=%ld, pTVWnd->Flags=%08lx, %08lx->RootFlags=%08lx, (%08lx)",
                    pTVWnd->TVPageIdx, pTVWnd->StdPageIdx1,
                    pTVWnd->StdPageIdx2, pTVWnd->Flags,
                    pRootPage, pRootPage->Flags,
                    pCPSUI->pDlgPage));

        return((LONG)cPage);

    } else {

        CPSUIERR(("AddComPropSheetUI() Failed = %ld", Result));
        return(Result);
    }
}




LONG_PTR
InsertPSUIPage(
    PCPSUIPAGE              pRootPage,
    PCPSUIPAGE              pParentPage,
    HANDLE                  hInsert,
    PINSERTPSUIPAGE_INFO    pInsPageInfo,
    BOOL                    AnsiCall
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    14-Feb-1996 Wed 14:03:20 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BOOL                bCtxActivated = FALSE;
    ULONG_PTR           ulCookie = 0;
    HANDLE              hActCtx = INVALID_HANDLE_VALUE;
    WCHAR               wszDLLName[MAX_PATH];
    PCPSUIPAGE          pCPSUIPage;
    INSERTPSUIPAGE_INFO IPInfo;
    LONG                cPage;
    BOOL                Ok = FALSE;
    DWORD               dwErr = ERROR_SUCCESS;


    if (!pInsPageInfo) {

        CPSUIERR(("InsertPSUIPage: Pass a NULL pInsPageInfo"));
        return(0);

    } else if (pInsPageInfo->cbSize < sizeof(INSERTPSUIPAGE_INFO)) {

        CPSUIERR(("InsertPSUIPage: Invalid cbSize=%u in pInsPageInfo",
                                                    pInsPageInfo->cbSize));
        return(0);
    }

    //
    // Make a local copy
    //

    IPInfo = *pInsPageInfo;

    if (IPInfo.Type > MAX_PSUIPAGEINSERT_INDEX) {

        CPSUIERR(("InsertPSUIPage: Invalid Type=%u in pInsPageInfo",
                                            IPInfo.Type));
        return(0);

    } else if ((IPInfo.Type != PSUIPAGEINSERT_GROUP_PARENT) &&
               (IPInfo.dwData1 == 0)) {

        CPSUIERR(("InsertPSUIPage: dwData1 is NULL in pInsPageInfo"));
        return(0);
    }

    CPSUIDBG(DBG_INSPAGE,
             ("InsertPSUIPage: Type=%hs, Mode=%u, hInsert=%08lx, pInsPageInfo=%08lx%hs",
                    pszInsType[IPInfo.Type], IPInfo.Mode, hInsert, pInsPageInfo,
                    (AnsiCall) ? " (ANSI)" : ""));

    if (!(pCPSUIPage = AddCPSUIPage(pParentPage, hInsert, IPInfo.Mode))) {

        CPSUIERR(("InsertPSUIPage: AddCPSUIPage() failed"));
        return(0);
    }

    if (AnsiCall) {

        pCPSUIPage->Flags |= CPF_ANSI_CALL;
    }

    switch (IPInfo.Type) {

    case PSUIPAGEINSERT_GROUP_PARENT:

        //
        // Nothing to do except setting the flags
        //

        Ok                 = TRUE;
        pCPSUIPage->Flags |= CPF_PARENT | CPF_USER_GROUP;
        break;

    case PSUIPAGEINSERT_PCOMPROPSHEETUI:

        pCPSUIPage->Flags |= (CPF_PARENT | CPF_COMPROPSHEETUI);

        //
        // 20-Jul-1996 Sat 07:58:34 updated  -by-  Daniel Chou (danielc)
        //  Set dwData2 to cPage if sucessful, and dwData=ERR_CPSUI_xxx if
        //  failed
        //
        // This are cases that we want to add 0 page, so only negative value 
        // is falure return.
        //

        if ((cPage = AddComPropSheetUI(pRootPage,
                                       pCPSUIPage,
                                       (PCOMPROPSHEETUI)IPInfo.dwData1)) >= 0) {

            Ok = TRUE;
        }

        pInsPageInfo->dwData2 = (ULONG_PTR)cPage;

        break;

    case PSUIPAGEINSERT_DLL:

        pCPSUIPage->Flags |= (CPF_PARENT | CPF_DLL | CPF_PFNPROPSHEETUI);

        if (AnsiCall) {

            CPSUIDBG(DBG_INSPAGE, ("Loading DLL: %hs", IPInfo.dwData1));

        } else {

            CPSUIDBG(DBG_INSPAGE, ("Loading DLL: %ws", IPInfo.dwData1));
        }

        CPSUIDBG(DBG_INSPAGE, ("Get pfnPropSheetU() = %hs", IPInfo.dwData2));

        if (AnsiCall)
        {
            // convert from ANSI to UNICODE
            SHAnsiToUnicode((LPCSTR)IPInfo.dwData1, wszDLLName, ARRAYSIZE(wszDLLName));
        }
        else
        {
            // just copy the UNICODE name into the buffer
            SHUnicodeToUnicode((LPCWSTR)IPInfo.dwData1, wszDLLName, ARRAYSIZE(wszDLLName));
        }

        //
        // this is a third party DLL and we don't know if it is fusion aware
        // or not, so we just try if there is an external manifest file or 
        // a manifest embedded in the resources.
        //
        if (SUCCEEDED(CreateActivationContextFromExecutable(wszDLLName, &hActCtx)))
        {
            // compstui page takes the ownership of the activation context handle.
            pCPSUIPage->hActCtx = hActCtx;

            // activate the context prior loading the DLL and calling into it.
            bCtxActivated = ActivateActCtx(pCPSUIPage->hActCtx, &ulCookie);
        }

        __try {

            if ((pCPSUIPage->pfnInfo.hInst = LoadLibraryW(wszDLLName)) &&
                (IPInfo.dwData2)                                            &&
                (pCPSUIPage->pfnInfo.pfnPSUI = (PFNPROPSHEETUI)
                                    GetProcAddress(pCPSUIPage->pfnInfo.hInst,
                                                   (LPCSTR)IPInfo.dwData2))) {

                pCPSUIPage->pfnInfo.lParamInit  = IPInfo.dwData3;
                pCPSUIPage->pfnInfo.Result      = 0;

                Ok = (BOOL)((CallpfnPSUI(pCPSUIPage,
                                         PROPSHEETUI_REASON_INIT,
                                         (LPARAM)IPInfo.dwData3) > 0) &&
                            (pCPSUIPage->pChild));
            }
        }
        __finally {

            if (bCtxActivated) {

                //
                // we need to deactivate the context, no matter what!
                //
                DeactivateActCtx(0, ulCookie);
            }
        }

        break;

    case PSUIPAGEINSERT_PFNPROPSHEETUI:

        pCPSUIPage->Flags             |= (CPF_PARENT | CPF_PFNPROPSHEETUI);
        pCPSUIPage->pfnInfo.pfnPSUI    = (PFNPROPSHEETUI)IPInfo.dwData1;
        pCPSUIPage->pfnInfo.lParamInit = IPInfo.dwData2;
        pCPSUIPage->pfnInfo.Result     = 0;

        //
        // If this function successful and it got any pages then
        // we returned ok, else failed it.
        //

        Ok = (BOOL)((CallpfnPSUI(pCPSUIPage,
                                 PROPSHEETUI_REASON_INIT,
                                 (LPARAM)IPInfo.dwData2) > 0) &&
                    (pCPSUIPage->pChild));

        break;

    case PSUIPAGEINSERT_PROPSHEETPAGE:

        //
        // This is set only if we are calling Treeview Page with a seperate
        // dialog box, when calling direct with DialogBoxParam() with treeview
        // at return of AddPropSheetPage() the treeview dialog box already
        // done, so there is no need for error
        //

        pCPSUIPage->Flags |= (pParentPage->Flags & CPF_CALL_TV_DIRECT);

        Ok = AddPropSheetPage(pRootPage,
                              pCPSUIPage,
                              (LPPROPSHEETPAGE)IPInfo.dwData1,
                              NULL);
        break;

    case PSUIPAGEINSERT_HPROPSHEETPAGE:

        Ok = AddPropSheetPage(pRootPage,
                              pCPSUIPage,
                              NULL,
                              (HPROPSHEETPAGE)IPInfo.dwData1);
        break;
    }

    if (!Ok) {
        //
        // Save the last error.
        //
        dwErr = GetLastError();
    }

    HANDLETABLE_UnGetCPSUIPage(pCPSUIPage);

    if (Ok) {

        DBG_SHOW_CPSUIPAGE(pRootPage, 0);

        return((ULONG_PTR)pCPSUIPage->hCPSUIPage);

    } else {

        EnumCPSUIPages(pRootPage, pCPSUIPage, DeleteCPSUIPageProc, 0L);

        if (!(pCPSUIPage->Flags & CPF_CALL_TV_DIRECT)) {

            CPSUIERR(("InsertPSUIPage(): Insertion of %hs failed",
                        pszInsType[IPInfo.Type]));
        }

        SetLastError(dwErr);
        return(0);
    }
}



LONG
CALLBACK
IgnorePSNApplyProc(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pCPSUIPage,
    LPARAM      lParam
    )

/*++

Routine Description:

    This function send the APPLYNOW message to the CPSUIPAGE's page


Arguments:




Return Value:

    FALSE   - Apply done by not successful, the callee need more user changes
    TRUE    - Apply done with sucessful

Author:

    17-Nov-1997 Mon 13:38:18 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{

    if (!(pCPSUIPage->Flags & CPF_PARENT)) {

        DWORD   Flags = pCPSUIPage->Flags;

        if (lParam) {

            pCPSUIPage->Flags |= CPF_NO_PSN_APPLY;

        } else {

            pCPSUIPage->Flags &= ~CPF_NO_PSN_APPLY;
        }

        if ((pCPSUIPage->Flags & CPF_ACTIVATED) &&
            (Flags ^ (pCPSUIPage->Flags & CPF_NO_PSN_APPLY))) {

            SetIgnorePSNApplyProc(pCPSUIPage);
        }

        CPSUIDBG(DBG_GET_TABWND,
                    ("IgnorePSNApplyProc(%u): pPage=%08lx, Handle=%08lx",
                    (pCPSUIPage->Flags & CPF_NO_PSN_APPLY) ? 1 : 0,
                    pCPSUIPage, pCPSUIPage->hCPSUIPage));
    }


    return(TRUE);
}




LONG
CALLBACK
ApplyCPSUIProc(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pCPSUIPage,
    LPARAM      lParam
    )

/*++

Routine Description:

    This function send the APPLYNOW message to the CPSUIPAGE's page


Arguments:




Return Value:

    FALSE   - Apply done by not successful, the callee need more user changes
    TRUE    - Apply done with sucessful

Author:

    17-Nov-1997 Mon 13:38:18 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hDlg;
    DLGPROC DlgProc;


    if ((!(pCPSUIPage->Flags & CPF_PARENT))     &&
        (hDlg = pCPSUIPage->hPageInfo.hDlg)     &&
        (DlgProc = pCPSUIPage->hPageInfo.DlgProc)) {

        PCPSUIPAGE  pParent;
        PTVWND      pTVWnd = NULL;
        PSHNOTIFY   PN;

        PN.hdr.hwndFrom = pRootPage->RootInfo.hDlg;
        PN.hdr.idFrom   = (UINT)GetWindowLongPtr(PN.hdr.hwndFrom, GWLP_ID);
        PN.hdr.code     = PSN_APPLY;
        PN.lParam       = (lParam & APPLYCPSUI_OK_CANCEL_BUTTON) ? 1 : 0;

        CPSUIDBG(DBG_GET_TABWND,
                 ("*ApplyCPSUIProc(PSN_APPLY): Page=%08lx, Handle=%08lx, hDlg=%08lx, DlgPorc=%08lx",
                    pCPSUIPage, pCPSUIPage->hCPSUIPage, hDlg, DlgProc));

        if ((pParent = pCPSUIPage->pParent)                             &&
            ((pParent->Flags & (CPF_PARENT | CPF_COMPROPSHEETUI)) ==
                               (CPF_PARENT | CPF_COMPROPSHEETUI))       &&
            (pTVWnd = pParent->CPSUIInfo.pTVWnd)) {

            if (lParam & APPLYCPSUI_NO_NEWDEF) {

                pTVWnd->Flags |= TWF_APPLY_NO_NEWDEF;

            } else {

                pTVWnd->Flags &= ~TWF_APPLY_NO_NEWDEF;
            }

            CPSUIDBG(DBG_GET_TABWND,
                    ("*    APPLY ComPropSheetUI, pParent=%08lx: APPLY_NO_NEWDEF=%ld",
                    pParent->hCPSUIPage, (pTVWnd->Flags & TWF_APPLY_NO_NEWDEF) ? 1 : 0));
        }

        if (CallWindowProc((WNDPROC)DlgProc,
                           hDlg,
                           WM_NOTIFY,
                           (WPARAM)PN.hdr.idFrom,
                           (LPARAM)&PN)) {

            CPSUIDBG(DBG_GET_TABWND,
                     ("*ApplyCPSUIProc(PSN_APPLY): Return=%ld",
                        GetWindowLongPtr(hDlg, DWLP_MSGRESULT)));

            switch (GetWindowLongPtr(hDlg, DWLP_MSGRESULT)) {

            case PSNRET_INVALID:
            case PSNRET_INVALID_NOCHANGEPAGE:

                PostMessage(pRootPage->RootInfo.hDlg,
                            PSM_SETCURSEL,
                            (WPARAM)0,
                            (LPARAM)pCPSUIPage->hPage);

                return(FALSE);

            case PSNRET_NOERROR:
            default:

                break;
            }
        }

        if (pTVWnd) {

            pTVWnd->Flags &= ~TWF_APPLY_NO_NEWDEF;
        }
    }

    return(TRUE);
}




LONG_PTR
CALLBACK
CPSUICallBack(
    HANDLE  hComPropSheet,
    UINT    Function,
    LPARAM  lParam1,
    LPARAM  lParam2
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    29-Dec-1995 Fri 11:36:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCPSUIPAGE      pParentPage;
    PCPSUIPAGE      pRootPage = NULL;
    PMYDATABLOCK    pMyDB;
    PCPSUIDATABLOCK pCPSUIDB;
    HCURSOR         hCursor;
    DWORD           Count = 0;
    LONG_PTR        Result = 0;
    DWORD           dwErr = ERROR_SUCCESS;

    //
    // Compstui.dll should not set the wait cursor, it is the
    // responsibility of the top level caller to display any
    // progress UI if applicable. SteveKi 12/06/97
    //
#if 0
    hCursor = SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));
#endif

    CPSUIDBG(DBG_PFNCOMPROPSHEET,
             ("*CPSUICallBack(%08lx, %hs, %08lx, %08lx)",
            hComPropSheet,
            (Function <= MAX_CPSFUNC_INDEX) ? pszCPSFUNC[Function] :
                                              "??? Unknown Function",
            lParam1, lParam2));

    if ((pParentPage = HANDLETABLE_GetCPSUIPage(hComPropSheet)) &&
        ((pParentPage->Flags & CPF_PARENT)  ||
         (pParentPage->pChild))                                 &&
        (pRootPage = HANDLETABLE_GetRootPage(pParentPage))) {

        PCPSUIPAGE          pChildPage = NULL;
        PAGEPROCINFO        PageProcInfo;
        INSERTPSUIPAGE_INFO IPInfo;


        switch (Function) {

        case CPSFUNC_INSERT_PSUIPAGEA:
        case CPSFUNC_INSERT_PSUIPAGEW:

            Result = InsertPSUIPage(pRootPage,
                                    pParentPage,
                                    (HANDLE)lParam1,
                                    (PINSERTPSUIPAGE_INFO)lParam2,
                                    Function == CPSFUNC_INSERT_PSUIPAGEA);
            break;

        case CPSFUNC_ADD_HPROPSHEETPAGE:
        case CPSFUNC_ADD_PROPSHEETPAGEA:
        case CPSFUNC_ADD_PROPSHEETPAGEW:
        case CPSFUNC_ADD_PFNPROPSHEETUIA:
        case CPSFUNC_ADD_PFNPROPSHEETUIW:
        case CPSFUNC_ADD_PCOMPROPSHEETUIA:
        case CPSFUNC_ADD_PCOMPROPSHEETUIW:

            IPInfo.cbSize  = sizeof(IPInfo);
            IPInfo.Mode    = INSPSUIPAGE_MODE_LAST_CHILD;
            IPInfo.dwData1 = (ULONG_PTR)lParam1;
            IPInfo.dwData2 = (ULONG_PTR)lParam2;
            IPInfo.dwData3 = 0;

            switch (Function) {

            case CPSFUNC_ADD_HPROPSHEETPAGE:

                IPInfo.Type = PSUIPAGEINSERT_HPROPSHEETPAGE;
                break;

            case CPSFUNC_ADD_PROPSHEETPAGEA:    IPInfo.dwData3 = 1;
            case CPSFUNC_ADD_PROPSHEETPAGEW:

                Result = 0;
                IPInfo.Type = PSUIPAGEINSERT_PROPSHEETPAGE;
                break;

            case CPSFUNC_ADD_PCOMPROPSHEETUIA:  IPInfo.dwData3 = 1;
            case CPSFUNC_ADD_PCOMPROPSHEETUIW:

                IPInfo.Type = PSUIPAGEINSERT_PCOMPROPSHEETUI;
                break;

            case CPSFUNC_ADD_PFNPROPSHEETUIA:   IPInfo.dwData3 = 1;
            case CPSFUNC_ADD_PFNPROPSHEETUIW:

                IPInfo.Type = PSUIPAGEINSERT_PFNPROPSHEETUI;
                break;
            }

            Result = InsertPSUIPage(pRootPage,
                                    pParentPage,
                                    NULL,
                                    &IPInfo,
                                    (BOOL)IPInfo.dwData3);

            if (!Result) {
                //
                // Save the last error.
                //
                dwErr = GetLastError();
            }

            //
            // 20-Jul-1996 Sat 07:58:34 updated  -by-  Daniel Chou (danielc)
            //  Set dwData2 to cPage if sucessful, and dwData=ERR_CPSUI_xxx if
            //  failed
            //

            if ((IPInfo.Type == PSUIPAGEINSERT_PCOMPROPSHEETUI) &&
                (lParam2)) {

                *(LPDWORD)lParam2 = (DWORD)IPInfo.dwData2;
            }

            break;

        case CPSFUNC_GET_PAGECOUNT:

            PageProcInfo.pTabTable = NULL;
            PageProcInfo.pHandle   = NULL;
            PageProcInfo.phPage    = NULL;
            PageProcInfo.iPage     = 0;
            PageProcInfo.cPage     = (WORD)pRootPage->RootInfo.cPage;

            EnumCPSUIPagesSeq(pRootPage,
                              pParentPage,
                              SetPageProcInfo,
                              (LPARAM)&PageProcInfo);

            Result = (LONG_PTR)PageProcInfo.iPage;
            break;

        case CPSFUNC_GET_HPSUIPAGES:

            if (((LONG)lParam2 > 0)                         &&
                (PageProcInfo.pHandle = (HANDLE *)lParam1)  &&
                (PageProcInfo.cPage   = (WORD)lParam2)) {

                PageProcInfo.iPage     = 0;
                PageProcInfo.phPage    = NULL;
                PageProcInfo.pTabTable = NULL;

                EnumCPSUIPagesSeq(pRootPage,
                                  pParentPage,
                                  SetPageProcInfo,
                                  (LPARAM)&PageProcInfo);

                Result = (LONG_PTR)PageProcInfo.iPage;
            }

            break;

        case CPSFUNC_LOAD_CPSUI_STRINGA:
        case CPSFUNC_LOAD_CPSUI_STRINGW:

            Result = (LONG_PTR)LoadCPSUIString((LPTSTR)lParam1,
                                               LOWORD(lParam2),
                                               HIWORD(lParam2),
                                               Function ==
                                                    CPSFUNC_LOAD_CPSUI_STRINGA);
            break;

        case CPSFUNC_LOAD_CPSUI_ICON:

            if (((LONG)lParam1 >= IDI_CPSUI_ICONID_FIRST)   &&
                ((LONG)lParam1 <= IDI_CPSUI_ICONID_LAST)) {

                Result = lParam1;

                if (!(lParam1 = (LONG)LOWORD(lParam2))) {

                    lParam1 = (LONG)GetSystemMetrics(SM_CXICON);
                }

                if (!(lParam2 = (LONG)HIWORD(lParam2))) {

                    lParam2 = (LONG)GetSystemMetrics(SM_CYICON);
                }

                Result = (LONG_PTR)LoadImage(hInstDLL,
                                             MAKEINTRESOURCE(Result),
                                             IMAGE_ICON,
                                             (INT)lParam1,
                                             (INT)lParam2,
                                             0);

            } else {

                Result = 0;
            }

            break;

        case CPSFUNC_SET_RESULT:

            Result = pfnSetResult((lParam1) ? (HANDLE)lParam1 : hComPropSheet,
                                  (ULONG_PTR)lParam2);
            break;

        case CPSFUNC_SET_FUSION_CONTEXT:

            // check to release the current activation context (if any)
            if (pParentPage->hActCtx && pParentPage->hActCtx != INVALID_HANDLE_VALUE) {

                ReleaseActCtx(pParentPage->hActCtx);
                pParentPage->hActCtx = INVALID_HANDLE_VALUE;
            }

            // attach the new passed in fusion activation context to the compstui page
            pParentPage->hActCtx = (HANDLE)lParam1;

            // check to addref the passed in activation context handle
            if (pParentPage->hActCtx && pParentPage->hActCtx != INVALID_HANDLE_VALUE) {

                AddRefActCtx(pParentPage->hActCtx);
            }

            // indicate success
            Result = 1;

            break;

        case CPSFUNC_SET_HSTARTPAGE:

            //
            // Assume OK first
            //

            Result = 0xFFFF;

            if (pRootPage->Flags & CPF_SHOW_PROPSHEET) {

                break;

            } else if (!lParam1) {

                if (lParam2) {

                    pRootPage->Flags               |= CPF_PSZ_PSTARTPAGE;
                    pRootPage->RootInfo.pStartPage  = (PCPSUIPAGE)lParam2;
                    Result                          = lParam2;
                }

                break;
            }

            //
            // Fall through
            //

        case CPSFUNC_DELETE_HCOMPROPSHEET:
        case CPSFUNC_GET_PFNPROPSHEETUI_ICON:
        case CPSFUNC_SET_PSUIPAGE_TITLEA:
        case CPSFUNC_SET_PSUIPAGE_TITLEW:
        case CPSFUNC_SET_PSUIPAGE_ICON:
        case CPSFUNC_IGNORE_CPSUI_PSN_APPLY:
        case CPSFUNC_DO_APPLY_CPSUI:

            if ((lParam1)                                                   &&
                (pChildPage = HANDLETABLE_GetCPSUIPage((HANDLE)lParam1))    &&
                (HANDLETABLE_IsChildPage(pChildPage, pParentPage))) {

                switch (Function) {

                case CPSFUNC_SET_HSTARTPAGE:

                    Result = SethStartPage(pRootPage,
                                           pChildPage,
                                           (LONG)lParam2);
                    break;

                case CPSFUNC_DELETE_HCOMPROPSHEET:

                    HANDLETABLE_UnGetCPSUIPage(pChildPage);

                    EnumCPSUIPages(pRootPage,
                                   pChildPage,
                                   DeleteCPSUIPageProc,
                                   (LPARAM)&Count);

                    Result     = (LONG_PTR)Count;
                    pChildPage = NULL;

                    break;

                case CPSFUNC_GET_PFNPROPSHEETUI_ICON:

                    Result = (LONG_PTR)pfnGetIcon(pChildPage, lParam2);
                    break;

                case CPSFUNC_SET_PSUIPAGE_TITLEA:
                case CPSFUNC_SET_PSUIPAGE_TITLEW:

                    Result = SetPSUIPageTitle(pRootPage,
                                              pChildPage,
                                              (LPWSTR)lParam2,
                                              Function ==
                                                CPSFUNC_SET_PSUIPAGE_TITLEA);
                    break;

                case CPSFUNC_SET_PSUIPAGE_ICON:

                    Result = SetPSUIPageIcon(pRootPage,
                                             pChildPage,
                                             (HICON)lParam2);
                    break;

                case CPSFUNC_IGNORE_CPSUI_PSN_APPLY:

                    CPSUIDBG(DBG_GET_TABWND,
                         ("*\n\nCPSFUNC_IGNORE_CPSUI_PSN_APPLY: Page=%08lx, lParam2=%08lx, hDlg=%08lx\n",
                            pChildPage, lParam2, pRootPage->RootInfo.hDlg));

                    if (EnumCPSUIPagesSeq(pRootPage,
                                          pChildPage,
                                          IgnorePSNApplyProc,
                                          lParam2)) {

                        Result = 1;
                    }

                    break;


                case CPSFUNC_DO_APPLY_CPSUI:

                    if ((pRootPage->Flags & CPF_SHOW_PROPSHEET) &&
                        (pRootPage->RootInfo.hDlg)) {

                        CPSUIDBG(DBG_GET_TABWND,
                             ("*\n\nCPSFUNC_DO_APPLY_CPSUI: Page=%08lx, lParam2=%08lx, hDlg=%08lx\n",
                                pChildPage, lParam2, pRootPage->RootInfo.hDlg));

                        if (EnumCPSUIPagesSeq(pRootPage,
                                              pChildPage,
                                              ApplyCPSUIProc,
                                              lParam2)) {

                            Result = 1;
                        }
                    }

                    break;

                }
            }

            HANDLETABLE_UnGetCPSUIPage(pChildPage);

            break;

        case CPSFUNC_SET_DATABLOCK:

            LOCK_CPSUI_HANDLETABLE();

            if ((pCPSUIDB = (PCPSUIDATABLOCK)lParam1)   &&
                (lParam2)                               &&
                (pCPSUIDB->cbData)                      &&
                (pCPSUIDB->pbData)                      &&
                (pMyDB = (PMYDATABLOCK)LocalAlloc(LPTR,
                                                  SIZE_DB(pCPSUIDB->cbData)))) {

                PMYDATABLOCK    pPrevDB = NULL;
                PMYDATABLOCK    pCurDB = pRootPage->RootInfo.pMyDB;

                //
                // Try to find the old ID and delete it
                //

                while (pCurDB) {

                    if (pCurDB->ID == (DWORD)lParam2) {

                        if (pPrevDB) {

                            pPrevDB->pNext = pCurDB->pNext;

                        } else {

                            //
                            // This is the first one
                            //

                            pRootPage->RootInfo.pMyDB = pCurDB->pNext;
                        }

                        CPSUIDBG(DBG_PFNCOMPROPSHEET,
                                 ("SET_DATABLOCK()=Free ID=%08lx, pCurDB=%08lx (%ld)",
                                            pCurDB->ID, pCurDB, pCurDB->cb));

                        LocalFree((HLOCAL)pCurDB);
                        pCurDB = NULL;

                    } else {

                        pPrevDB = pCurDB;
                        pCurDB  = pCurDB->pNext;
                    }
                }

                //
                // Insert to the front
                //

                pMyDB->pNext              = pRootPage->RootInfo.pMyDB;
                pMyDB->ID                 = (DWORD)lParam2;
                pMyDB->cb                 = pCPSUIDB->cbData;
                pRootPage->RootInfo.pMyDB = pMyDB;
                Result                    = (LONG_PTR)pCPSUIDB->cbData;

                CopyMemory((LPBYTE)(pMyDB + 1),
                           pCPSUIDB->pbData,
                           LODWORD(Result));
            }

            UNLOCK_CPSUI_HANDLETABLE();

            break;

        case CPSFUNC_QUERY_DATABLOCK:

            LOCK_CPSUI_HANDLETABLE();

            if (pMyDB = pRootPage->RootInfo.pMyDB) {

                while (pMyDB) {

                    if (pMyDB->ID == (DWORD)lParam2) {

                        break;

                    } else {

                        pMyDB = pMyDB->pNext;
                    }
                }

                if (pMyDB) {

                    Result = (LONG_PTR)pMyDB->cb;

                    //
                    // Only do it if has a pointer and buffer count is
                    // not zero or the pointer is not NULL
                    //

                    if ((pCPSUIDB = (PCPSUIDATABLOCK)lParam1)   &&
                        (pCPSUIDB->cbData)                      &&
                        (pCPSUIDB->pbData)) {

                        //
                        // Limit to total bytes to copy = min(lParam2, Result)
                        //

                        if ((LONG_PTR)Result > (LONG_PTR)pCPSUIDB->cbData) {

                            Result = (LONG_PTR)pCPSUIDB->cbData;
                        }

                        CopyMemory(pCPSUIDB->pbData,
                                   (LPBYTE)(pMyDB + 1),
                                   LODWORD(Result));
                    }
                }
            }

            UNLOCK_CPSUI_HANDLETABLE();

            break;

        case CPSFUNC_SET_DMPUB_HIDEBITS:

            //
            // Only do it when these page is not register yet
            //

            if (!(pRootPage->Flags & (CPF_DOCPROP | CPF_ADVDOCPROP))) {

                (DWORD)lParam1 &= ~((DWORD)0xFFFFFFFF << DMPUB_LAST);

                pRootPage->RootInfo.DMPubHideBits = (DWORD)(Result = lParam1);
            }

            break;

        default:

            CPSUIERR(("CPSUICallBack(%ld) Unknown function index", Function));

            Result = (ULONG_PTR)-1;
            break;
        }
    }

    HANDLETABLE_UnGetCPSUIPage(pParentPage);
    HANDLETABLE_UnGetCPSUIPage(pRootPage);

    //
    // Compstui.dll should not set the wait cursor, it is the
    // responsibility of the top level caller to display any
    // progress UI if applicable. SteveKi 12/06/97
    //
#if 0
    SetCursor(hCursor);
#endif

    CPSUIDBG(DBG_PFNCOMPROPSHEET, ("CPSUICallBack()=%08lx", Result));

    if (dwErr != ERROR_SUCCESS) {
        //
        // Set the last error if preserved.
        //
        SetLastError(dwErr);
    }
    return(Result);
}




DWORD
GetSetCurUserReg(
    HKEY    *phRegKey,
    PTVWND  pTVWnd,
    LPDWORD pdw
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    30-Jan-1996 Tue 13:36:59 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTITEM    pItem;
    DWORD       dw      = 0;


    if (*phRegKey) {

        if (pTVWnd->ActiveDlgPage == pTVWnd->TVPageIdx) {

            dw = REGDPF_TVPAGE;

        } else if (pTVWnd->ActiveDlgPage == 0) {

            dw = REGDPF_STD_P1;

        } else {

            dw = 0;
        }

        if ((pTVWnd->IntTVOptIdx)                                   &&
            (pItem = PIDX_INTOPTITEM(pTVWnd, pTVWnd->IntTVOptIdx))  &&
            (!(pItem->Flags & OPTIF_COLLAPSE))) {

            dw |= REGDPF_EXPAND_OPTIONS;
        }

        if (dw != *pdw) {

            CPSUIDBG(DBG_GETSETREG, ("GetSetCurUserReg(): Set New DW=%08lx", dw));

            RegSetValueEx(*phRegKey,
                          szDocPropKeyName,
                          0,
                          REG_DWORD,
                          (CONST BYTE *)&dw,
                          sizeof(DWORD));
        }

        RegCloseKey(*phRegKey);
        *phRegKey = NULL;

    } else if (((ULONG_PTR)pTVWnd->ComPropSheetUI.pDlgPage ==
                                        (ULONG_PTR)CPSUI_PDLGPAGE_DOCPROP)   &&
               (RegCreateKey(HKEY_CURRENT_USER,
                             szCPSUIRegKey,
                             phRegKey) == ERROR_SUCCESS)                    &&
               (*phRegKey)) {

        DWORD   Type = REG_DWORD;
        DWORD   Size = sizeof(DWORD);

        if (RegQueryValueEx(*phRegKey,
                            szDocPropKeyName,
                            NULL,
                            &Type,
                            (LPBYTE)pdw,
                            &Size) != ERROR_SUCCESS) {

            *pdw = REGDPF_DEFAULT;
        }

        *pdw &= REGDPF_MASK;

        CPSUIDBG(DBG_GETSETREG, ("GetSetCurUserReg(): Get Cur DW=%08lx", *pdw));

        if ((*pdw & REGDPF_TVPAGE) &&
            (pTVWnd->TVPageIdx != PAGEIDX_NONE)) {

            dw = pTVWnd->TVPageIdx;


        } else if ((*pdw & REGDPF_STD_P1)   &&
                   (pTVWnd->StdPageIdx1 != PAGEIDX_NONE)) {

            dw = pTVWnd->StdPageIdx1;

        } else if (pTVWnd->StdPageIdx2 != PAGEIDX_NONE) {

            dw = pTVWnd->StdPageIdx2;

        } else {

            dw = (DWORD)-1;
        }

        if ((pTVWnd->IntTVOptIdx) &&
            (pItem = PIDX_INTOPTITEM(pTVWnd, pTVWnd->IntTVOptIdx))) {

            if (*pdw & REGDPF_EXPAND_OPTIONS) {

                pItem->Flags &= ~OPTIF_COLLAPSE;

            } else {

                pItem->Flags |= OPTIF_COLLAPSE;
            }
        }
    }

    return(dw);
}


LONG
DoComPropSheet(
    PCPSUIPAGE                  pRootPage,
    PPROPSHEETUI_INFO_HEADER    pPSUIInfoHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    29-Aug-1995 Tue 12:55:41 created  -by-  Daniel Chou (danielc)


Revision History:

    28-Nov-1995 Tue 16:30:29 updated  -by-  Daniel Chou (danielc)
        Remove help button, since all help will be right mouse/question mark
        activated.


--*/

{
    PTVWND          pTVWnd;
    PCPSUIPAGE      pPage = NULL;
    PROPSHEETHEADER psh;
    PPSHINFO        pPSHInfo;
    LPTSTR          pTitle;
    PAGEPROCINFO    PageProcInfo;
    HICON           hIcon = NULL;
    HKEY            hRegKey = NULL;
    DWORD           Data;
    DWORD           dw;
    UINT            IntFmtStrID;
    LONG            Result;
    WORD            GBFAnsi;
    BOOL            AnsiCall;
    UINT            Idx = 0;


    GBFAnsi  = (WORD)((pRootPage->Flags & CPF_ANSI_CALL) ? GBF_ANSI_CALL : 0);
    Result   = sizeof(PSHINFO) +
               (pRootPage->RootInfo.cPage * sizeof(HPROPSHEETPAGE));

    if ((pRootPage->RootInfo.cPage) &&
        (pPSHInfo = (PPSHINFO)LocalAlloc(LPTR, Result))) {

        PageProcInfo.pTabTable = pRootPage->RootInfo.pTabTable;
        PageProcInfo.pHandle   = NULL;
        PageProcInfo.phPage    = (HPROPSHEETPAGE *)(pPSHInfo + 1);
        PageProcInfo.iPage     = 0;
        PageProcInfo.cPage     = (WORD)pRootPage->RootInfo.cPage;

        EnumCPSUIPagesSeq(pRootPage,
                          pRootPage,
                          SetPageProcInfo,
                          (LPARAM)&PageProcInfo);

        SHOW_TABWND(L"DoComPropSheet", PageProcInfo.pTabTable);

    } else {

        return(ERR_CPSUI_ALLOCMEM_FAILED);
    }

    psh.dwSize  = sizeof(PROPSHEETHEADER);
    psh.dwFlags = 0;

    if (pPSUIInfoHdr->Flags & PSUIHDRF_PROPTITLE) {

        psh.dwFlags |= PSH_PROPTITLE;
    }

    if (pPSUIInfoHdr->Flags & PSUIHDRF_NOAPPLYNOW) {

        psh.dwFlags      |= PSH_NOAPPLYNOW;
        pRootPage->Flags |= CPF_NO_APPLY_BUTTON;
    }

    CPSUIDBGBLK(
    {
        if (DBG_CPSUIFILENAME & DBG_ALWAYS_APPLYNOW) {

            psh.dwFlags      &= ~PSH_NOAPPLYNOW;
            pRootPage->Flags &= ~CPF_NO_APPLY_BUTTON;
        }
    })

    psh.hwndParent  = pPSUIInfoHdr->hWndParent;
    psh.hInstance   = pPSUIInfoHdr->hInst;
    psh.pStartPage  = NULL;
    psh.nPages      = (UINT)pRootPage->RootInfo.cPage;
    psh.phpage      = PageProcInfo.phPage;
    psh.pszCaption  = (LPTSTR)pPSHInfo->CaptionName;

    if (pPSUIInfoHdr->Flags & PSUIHDRF_USEHICON) {

        psh.dwFlags |= PSH_USEHICON;
        psh.hIcon    = pPSUIInfoHdr->hIcon;

    } else {

        if (!(hIcon = GETICON16(pPSUIInfoHdr->hInst, pPSUIInfoHdr->IconID))) {

            hIcon = GETICON16(hInstDLL, IDI_CPSUI_OPTION);
        }

        psh.dwFlags |= PSH_USEHICON;
        psh.hIcon    = hIcon;
    }

    //
    // Set Start page now
    //

    if (pPage = pRootPage->RootInfo.pStartPage) {

        if (pRootPage->Flags & CPF_PSZ_PSTARTPAGE) {

            psh.dwFlags    |= PSH_USEPSTARTPAGE;
            psh.pStartPage  = (LPCTSTR)pPage;

        } else {

            while ((pPage) && (pPage->Flags & CPF_PARENT)) {

                pPage = pPage->pChild;
            }

            if ((pPage)                         &&
                (!(pPage->Flags & CPF_PARENT))  &&
                (pPage->hPage)) {

                while (psh.nStartPage < psh.nPages) {

                    if (psh.phpage[psh.nStartPage] == pPage->hPage) {

                        //
                        // Found it
                        //

                        break;
                    }

                    psh.nStartPage++;
                }
            }
        }
    }

    //
    // Get the internal format string ID for the title bar
    //

    if ((pTitle = pPSUIInfoHdr->pTitle) &&
        (pPSUIInfoHdr->Flags & PSUIHDRF_EXACT_PTITLE)) {

        psh.dwFlags &= ~PSH_PROPTITLE;
        IntFmtStrID  = 0;

    } else {

        IntFmtStrID = (pPSUIInfoHdr->Flags & PSUIHDRF_DEFTITLE) ?
                                                IDS_INT_CPSUI_DEFAULT : 0;

        if ((pRootPage->Flags & (CPF_DOCPROP | CPF_ADVDOCPROP)) &&
            (pRootPage->RootInfo.cPage >= pRootPage->RootInfo.cCPSUIPage)) {

            if (pRootPage->Flags & CPF_ADVDOCPROP) {

                //
                // Can only be 'XXX Advance Document Properties';
                //

                IntFmtStrID  = IDS_INT_CPSUI_ADVDOCUMENT;
                psh.dwFlags |= PSH_PROPTITLE;

            } else if (pRootPage->Flags & CPF_DOCPROP) {

                //
                // Can be 'XXX Document Properties' or
                //        'XXX Default Document Properties'
                //

                IntFmtStrID  = (pPSUIInfoHdr->Flags & PSUIHDRF_DEFTITLE) ?
                                                    IDS_INT_CPSUI_DEFDOCUMENT :
                                                    IDS_INT_CPSUI_DOCUMENT;
                psh.dwFlags |= PSH_PROPTITLE;

                if (!pRootPage->RootInfo.pStartPage) {

                    pPage = pRootPage;

                    while ((pPage) && (pPage->Flags & CPF_PARENT)) {

                        pPage = pPage->pChild;
                    }

                    if ((pPage)                                         &&
                        (pPage->pParent->Flags & CPF_COMPROPSHEETUI)    &&
                        (pTVWnd = pPage->pParent->CPSUIInfo.pTVWnd)) {

                        if ((dw = GetSetCurUserReg(&hRegKey,
                                                   pTVWnd,
                                                   &Data)) != (DWORD)-1) {

                            psh.nStartPage += dw;
                        }
                    }
                }
            }
        }
    }

    //
    // Compose Title, first make sure the title exist, if not then use
    // 'Options' as title
    //

    if ((!pTitle)   ||
        (!GetStringBuffer(pPSUIInfoHdr->hInst,
                          (WORD)(GBF_PREFIX_OK      |
                                 GBF_INT_NO_PREFIX  |
                                 GBFAnsi),
                          L'\0',
                          pTitle,
                          pPSHInfo->CaptionName,
                          COUNT_ARRAY(pPSHInfo->CaptionName)))) {

        GetStringBuffer(hInstDLL,
                        (WORD)(GBF_PREFIX_OK      |
                               GBF_INT_NO_PREFIX  |
                               GBFAnsi),
                        L'\0',
                        pTitle = (LPTSTR)IDS_CPSUI_OPTIONS,
                        pPSHInfo->CaptionName,
                        COUNT_ARRAY(pPSHInfo->CaptionName));
    }

    //
    // If we need to composed with internal format string, then redo it using
    // compose calls, otherwise the CaptionName already has user title
    //

    if (IntFmtStrID) {

        ComposeStrData(pPSUIInfoHdr->hInst,
                       (WORD)(GBF_PREFIX_OK | GBF_INT_NO_PREFIX | GBFAnsi),
                       pPSHInfo->CaptionName,
                       COUNT_ARRAY(pPSHInfo->CaptionName),
                       IntFmtStrID,
                       pTitle,
                       0,
                       0);
    }

    if ((!(psh.dwFlags & PSH_USEPSTARTPAGE))    &&
        (psh.nStartPage >= psh.nPages)) {

        psh.nStartPage = 0;
    }

    CPSUIDBG(DBG_DOCOMPROPSHEET, ("pRootPage=%08lx, RootFlags=%08lx, pPSUIInfoHdr->Flags=%08lx\nCaption(%ld)='%ws', Start Page=%ld (%08lx)",
                    pRootPage, pRootPage->Flags, pPSUIInfoHdr->Flags,
                    (LONG)Idx, pPSHInfo->CaptionName, psh.nStartPage,
                    psh.pStartPage));

    psh.dwFlags     |= PSH_USECALLBACK;
    psh.pfnCallback  = PropSheetProc;

    //
    // Make sure only one person go through the PropertySheet
    //

    LOCK_CPSUI_HANDLETABLE();

    CPSUIDBG(DBG_PAGE_PROC, ("<< ProcessID=%ld, ThreadID=%ld, TIsValue(%ld)=%08lx",
                GetCurrentProcessId(), GetCurrentThreadId(),
                TlsIndex, TlsGetValue(TlsIndex)));

    Data = (DWORD)TLSVALUE_2_CWAIT(TlsGetValue(TlsIndex));
    Idx  = (UINT)HANDLE_2_IDX(pRootPage->hCPSUIPage);

    TlsSetValue(TlsIndex, ULongToPtr(MK_TLSVALUE(Data, Idx)));

    UNLOCK_CPSUI_HANDLETABLE();

    DBG_SHOW_CPSUIPAGE(pRootPage, 0);

    if ((Result = (LONG)PropertySheet((LPCPROPSHEETHEADER)&psh)) < 0) {

        Result = ERR_CPSUI_GETLASTERROR;

    } else if (Result == ID_PSRESTARTWINDOWS) {

        Result = CPSUI_RESTARTWINDOWS;

    } else if (Result == ID_PSREBOOTSYSTEM) {

        Result = CPSUI_REBOOTSYSTEM;

    } else {

        Result = CPSUI_OK;
    }

    //
    // Free all the stuff first
    //

    LocalFree((HLOCAL)pPSHInfo);

    if (hIcon) {

        DestroyIcon(hIcon);
    }

    //
    // Save things back to registry if we got one
    //

    if (hRegKey) {

        GetSetCurUserReg(&hRegKey, pTVWnd, &Data);
    }

    CPSUIINT(("PropertySheet() = %ld", Result));

    return(Result);
}



LONG
DoCommonPropertySheetUI(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult,
    BOOL            AnsiCall
    )

/*++

Routine Description:

    The CommonPropSheetUI is the main entry point for the common property sheet
    user interface.   The original caller that wish to using common UI to
    pop-up property sheet will call this function and passed its own
    PFNPROPSHEETUI function address and a long parameter.

    If pfnPropSheetUI function return a LONG number greater than zero (0) then
    common UI will pop-up the property sheet page dialog boxes, when Property
    sheet pages is finished. (either hit Ok or Cancel) it will return the
    result of CPSUI_xxxx back to the caller.

    If pfnPropSheetUI function return a LONG number equal or less than zero (0)
    then it will return the CPSUI_CANCEL back to caller without pop-up the
    property sheet page dialog boxes.



Arguments:


    hWndOwner       - Window handle for the owner of this proerty sheet
                      pages dialog boxes.

    pfnPropSheetUI  - a PFNPROPSHEETUI function pointer which is used by
                      the caller to add its property sheet pages.

    lParam          - a long parameter will be passed to the pfnPropSheetUI
                      funciton.  The common UI called the pfnPropSheetUI as

                        PROPSHEETUI_INFO    PSUIInfo;

                        pfnPropSheetUI(&PSUIInfo, lParam);

                      The caller must use pfnComPropSheet() to add/delete
                      pages.  When it is done adding pages, it retuned
                      greater than zero to indicate successful, and return
                      less or equal to zero to indicate failure.

    pResult         - a pointer to DWORD which received the final result
                      of pfnPropSheetUI() funciton, this result is a copy
                      from Result field of PROPSHEETUI_INFO data structure
                      which passed to the pfnPropSheetUI() as the first
                      parameter.

                      if pResult is NULL then common UI will not return
                      pfnPropSheetUI()'s result back.


Return Value:

    LONG    - < 0                   - Error, ERR_CPSUI_xxxx
              CPSUI_CANCEL          - User hit Cancel.
              CPSUI_OK              - User hit Ok.
              CPSUI_RESTARTWINDOWS  - Ok and need to restart window
              CPSUI_REBOOTSYSTEM    - Ok and need to reboot system


Author:

    04-Feb-1996 Sun 07:52:49 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTABTABLE                   pTabTable = NULL;
    PCPSUIPAGE                  pRootPage;
    PROPSHEETUI_INFO_HEADER     PSUIInfoHdr;
    PMYDATABLOCK                pMyDB;
    LONG                        Result;


    if (!(pRootPage = AddCPSUIPage(NULL, NULL, 0))) {

        CPSUIERR(("DoCommonPropertySheetUI(), Create RootPage failed"));
        return(ERR_CPSUI_ALLOCMEM_FAILED);
    }

    PSUIInfoHdr.cbSize          = sizeof(PROPSHEETUI_INFO_HEADER);
    PSUIInfoHdr.Flags           = 0;
    PSUIInfoHdr.pTitle          = NULL;
    PSUIInfoHdr.hWndParent      = hWndOwner;
    PSUIInfoHdr.hInst           = NULL;
    PSUIInfoHdr.IconID          = IDI_CPSUI_OPTION;
    pRootPage->RootInfo.pResult = pResult;

    CPSUIDBG(DBG_DO_CPSUI, ("DoComPropSheetUI(hWndOwner=%08lx, Active=%08lx, Focus=%08lx)",
                hWndOwner, GetActiveWindow(), GetFocus()));

    if (GetCapture()) {

        CPSUIDBG(DBG_DO_CPSUI, ("DoComPropSheetUI(): MouseCapture=%08lx",
                                GetCapture()));
        ReleaseCapture();
    }

    if (AnsiCall) {

        CPSUIDBG(DBG_DO_CPSUI, ("DoComPropSheetUI(ANSI CALL)"));

        pRootPage->Flags |= CPF_ANSI_CALL;
    }

    if (!CPSUICallBack(pRootPage->hCPSUIPage,
                      (AnsiCall) ? CPSFUNC_ADD_PFNPROPSHEETUIA :
                                   CPSFUNC_ADD_PFNPROPSHEETUIW,
                      (LPARAM)pfnPropSheetUI,
                      (LPARAM)lParam)) {

        CPSUIERR(("DoCommonPropertySheetUI: ADD_PFNPROPSHEETUI failed"));
        Result = ERR_CPSUI_GETLASTERROR;

    } else if (CallpfnPSUI(pRootPage->pChild,
                           PROPSHEETUI_REASON_GET_INFO_HEADER,
                           (LPARAM)&PSUIInfoHdr) <= 0) {

        CPSUIERR(("DoCommonPropertySheetUI: GET_INFO_HEADER, Canceled"));
        Result = CPSUI_CANCEL;

    } else if (!(pRootPage->RootInfo.cPage)) {

        CPSUIERR(("DoCommonPropertySheetUI: RootInfo.cPage=0, Canceled."));
        Result = ERR_CPSUI_NO_PROPSHEETPAGE;

    } else if (!(pTabTable = (PTABTABLE)LocalAlloc(LMEM_FIXED,
                                                   sizeof(TABTABLE)))) {

        CPSUIERR(("DoCommonPropertySheetUI: Allocation of TABTABLE=%ld failed",
                                                sizeof(TABTABLE)));

        Result = ERR_CPSUI_ALLOCMEM_FAILED;

    } else {

        DoTabTable(TAB_MODE_DELETE_ALL, pTabTable, 0, 0);

        pRootPage->RootInfo.pTabTable =
        pTabTable->pTabTable          = pTabTable;
        pTabTable->hWndTab            = NULL;
        pTabTable->WndProc            = NULL;
        pTabTable->hPSDlg             = NULL;
        // pTabTable->hRootPage          = pRootPage->hCPSUIPage;

        pRootPage->Flags |= CPF_SHOW_PROPSHEET;

        Result = DoComPropSheet(pRootPage, &PSUIInfoHdr);

        pRootPage->Flags &= ~CPF_SHOW_PROPSHEET;
        pRootPage->Flags |= CPF_DONE_PROPSHEET;
    }

    if (pTabTable) {

        CPSUIDBG(DBG_PAGE_PROC, ("=+=+ FREE pTableTable=%08lx", pTabTable));
        LocalFree((HLOCAL)pTabTable);
        pTabTable = NULL;
    }

    //
    // Free up the Datablock even if failed, so if misbehave by the caller
    // that register the data block then we should remove it now
    //

    while (pMyDB = pRootPage->RootInfo.pMyDB) {

        pRootPage->RootInfo.pMyDB = pMyDB->pNext;

        CPSUIDBG(DBG_DO_CPSUI,
                 ("Free DataBlock: ID=%08lx, pCurDB=%08lx (%ld)",
                            pMyDB->ID, pMyDB, pMyDB->cb));

        LocalFree((HLOCAL)pMyDB);
    }

    HANDLETABLE_UnGetCPSUIPage(pRootPage);
    EnumCPSUIPages(pRootPage, pRootPage, DeleteCPSUIPageProc, (LPARAM)0);

    if (pResult) {

        CPSUIDBG(DBG_DO_CPSUI, ("DoCommonPropertySheetUI(): Result=%ld, *pResult=%ld",
                    Result, *pResult));

    } else {

        CPSUIDBG(DBG_DO_CPSUI, ("DoCommonPropertySheetUI(): Result=%ld, *pResult=NULL",
                    Result));
    }

    return(Result);
}



LONG
APIENTRY
CommonPropertySheetUIA(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    )

/*++

Routine Description:

    SEE DoCommonPropertySheetUI description


Arguments:

    SEE DoCommonPropertySheetUI description


Return Value:

    SEE DoCommonPropertySheetUI description

Author:

    01-Sep-1995 Fri 12:29:10 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    return(DoCommonPropertySheetUI(hWndOwner,
                                   pfnPropSheetUI,
                                   lParam,
                                   pResult,
                                   TRUE));
}



LONG
APIENTRY
CommonPropertySheetUIW(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    )

/*++

Routine Description:

    SEE DoCommonPropertySheetUI description


Arguments:

    SEE DoCommonPropertySheetUI description

Return Value:

    SEE DoCommonPropertySheetUI description


Author:

    30-Jan-1996 Tue 15:30:41 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    return(DoCommonPropertySheetUI(hWndOwner,
                                   pfnPropSheetUI,
                                   lParam,
                                   pResult,
                                   FALSE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\convert.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    convert.c


Abstract:

    This module contains all version conversion function


Author:

    10-Oct-1995 Tue 19:24:43 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma  hdrstop


#define DBG_CPSUIFILENAME   DbgConvert


DEFINE_DBGVAR(0);




LONG
InitMYDLGPAGE(
    PMYDLGPAGE  pMyDP,
    PDLGPAGE    pDP,
    UINT        cDP
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    10-Oct-1995 Tue 19:45:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/


{
    LONG    Result = 0;

    while (cDP--) {

        pMyDP->ID = MYDP_ID;

        CopyMemory(&(pMyDP->DlgPage),
                   pDP,
                   (pDP->cbSize > sizeof(DLGPAGE)) ? sizeof(DLGPAGE) :
                                                      pDP->cbSize);
        ++Result;

        pMyDP++;
        pDP++;
    }

    return(Result);
}



LONG
GetCurCPSUI(
    PTVWND          pTVWnd,
    POIDATA         pOIData,
    PCOMPROPSHEETUI pCPSUIFrom
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    10-Oct-1995 Tue 19:56:15 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTITEM    pItem;
    POIEXT      pOIExt;
    OIEXT       OIExt;
    UINT        cItem;
    LONG        cConvert = 0;


    CopyMemory(&pTVWnd->ComPropSheetUI,
               pCPSUIFrom,
               (pCPSUIFrom->cbSize > sizeof(COMPROPSHEETUI)) ?
                                sizeof(COMPROPSHEETUI) : pCPSUIFrom->cbSize);

    //
    // This is the default OIEXT
    //

    OIExt.cbSize      = sizeof(OIEXT);
    OIExt.Flags       = (pTVWnd->Flags & TWF_ANSI_CALL) ? OIEXTF_ANSI_STRING :
                                                          0;
    OIExt.hInstCaller = pTVWnd->ComPropSheetUI.hInstCaller;
    OIExt.pHelpFile   = pTVWnd->ComPropSheetUI.pHelpFile;
    pItem             = pTVWnd->ComPropSheetUI.pOptItem;
    cItem             = pTVWnd->ComPropSheetUI.cOptItem;

    while (cItem--) {

        pItem->wReserved = 0;

        ZeroMemory(&(pItem->dwReserved[0]),
                   sizeof(OPTITEM) - FIELD_OFFSET(OPTITEM, dwReserved));


        if ((pItem->Flags & OPTIF_HAS_POIEXT)   &&
            (pOIExt = pItem->pOIExt)            &&
            (pOIExt->cbSize >= sizeof(OIEXT))) {

            cConvert++;

        } else {

            pOIExt = &OIExt;
        }

        pOIData->OIExtFlags  = pOIExt->Flags;
        pOIData->hInstCaller = pOIExt->hInstCaller ? pOIExt->hInstCaller : OIExt.hInstCaller;
        pOIData->pHelpFile   = pOIExt->pHelpFile;
        _OI_POIDATA(pItem)   = pOIData;

        pOIData++;
        pItem++;
    }

    return(cConvert);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\compstui.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    compstui.c


Abstract:

    This module contains all major entry porint for the common printer
    driver UI


Author:

    28-Aug-1995 Mon 16:19:45 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma  hdrstop


#define DBG_CPSUIFILENAME   DbgComPtrUI


#define DBG_DLLINIT         0x00000001


DEFINE_DBGVAR(0);


HINSTANCE   hInstDLL = NULL;
DWORD       TlsIndex = 0xFFFFFFFF;



DWORD
APIENTRY
CommonPropSheetUI_DLLInit(
    HMODULE hModule,
    ULONG   Reason,
    LPVOID  Reserved
    )

/*++

Routine Description:

    This function is DLL main entry point, at here we will save the module
    handle, in the future we will need to do other initialization stuff.

Arguments:

    hModule     - Handle to this moudle when get loaded.

    Reason      - may be DLL_PROCESS_ATTACH

    Reserved    - reserved

Return Value:

    Always return 1L


Author:

    07-Sep-1995 Thu 12:43:45 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    LPVOID  pv;
    WORD    cWait;
    WORD    Idx;


    UNREFERENCED_PARAMETER(Reserved);



    CPSUIDBG(DBG_DLLINIT,
            ("\n!! CommonPropSheetUI_DLLInit: ProcesID=%ld, ThreadID=%ld !!",
            GetCurrentProcessId(), GetCurrentThreadId()));

    switch (Reason) {

    case DLL_PROCESS_ATTACH:

        CPSUIDBG(DBG_DLLINIT, ("DLL_PROCESS_ATTACH"));

        // initialize fusion
        if (!SHFusionInitializeFromModule(hModule)) {

            CPSUIERR(("SHFusionInitializeFromModule Failed, DLL Initialzation Failed"));
            return (0);
        }

        if ((TlsIndex = TlsAlloc()) == 0xFFFFFFFF) {

            CPSUIERR(("TlsAlloc() Failed, Initialzation Failed"));
            return(0);
        }

        if (!HANDLETABLE_Create()) {

            TlsFree(TlsIndex);
            TlsIndex = 0xFFFFFFFF;

            CPSUIERR(("HANDLETABLE_Create() Failed, Initialzation Failed"));

            return(0);
        }

        hInstDLL = (HINSTANCE)hModule;

        //
        // Fall through to do the per thread initialization
        //

    case DLL_THREAD_ATTACH:

        if (Reason == DLL_THREAD_ATTACH) {

            CPSUIDBG(DBG_DLLINIT, ("DLL_THREAD_ATTACH"));
        }

        TlsSetValue(TlsIndex, (LPVOID)MK_TLSVALUE(0, 0));

        break;

    case DLL_PROCESS_DETACH:

        CPSUIDBG(DBG_DLLINIT, ("DLL_PROCESS_DETACH"));

        //
        // Fall through to de-initialize
        //

    case DLL_THREAD_DETACH:

        if (Reason == DLL_THREAD_DETACH) {

            CPSUIDBG(DBG_DLLINIT, ("DLL_THREAD_DETACH"));
        }

        pv = TlsGetValue(TlsIndex);

        if (cWait = TLSVALUE_2_CWAIT(pv)) {

            CPSUIERR(("Thread=%ld: Some (%ld) mutex owned not siginaled, do it now",
                        GetCurrentThreadId(), cWait));

            while (cWait--) {

                UNLOCK_CPSUI_HANDLETABLE();
            }
        }

        if (Reason == DLL_PROCESS_DETACH) {

            TlsFree(TlsIndex);
            HANDLETABLE_Destroy();
        }

        if (DLL_PROCESS_DETACH == Reason) {

            // shutdown fusion
            SHFusionUninitialize();
        }

        break;

    default:

        CPSUIDBG(DBG_DLLINIT, ("DLLINIT UNKNOWN"));
        return(0);
    }

    return(1);
}



ULONG_PTR
APIENTRY
GetCPSUIUserData(
    HWND    hDlg
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Oct-1995 Wed 23:13:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PMYDLGPAGE  pMyDP;


    if ((pMyDP = GET_PMYDLGPAGE(hDlg)) && (pMyDP->ID == MYDP_ID)) {

        return(pMyDP->CPSUIUserData);

    } else {

        CPSUIERR(("GetCPSUIUserData: Invalid hDlg=%08lx", hDlg));
        return(0);
    }
}




BOOL
APIENTRY
SetCPSUIUserData(
    HWND        hDlg,
    ULONG_PTR   CPSUIUserData
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Oct-1995 Wed 23:13:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PMYDLGPAGE  pMyDP;


    if ((pMyDP = GET_PMYDLGPAGE(hDlg)) && (pMyDP->ID == MYDP_ID)) {

        CPSUIINT(("SetCPSUIUserData: DlgPageIdx=%ld, UserData=%p",
                    pMyDP->PageIdx, CPSUIUserData));

        pMyDP->CPSUIUserData = CPSUIUserData;
        return(TRUE);

    } else {

        CPSUIERR(("SetCPSUIUserData: Invalid hDlg=%08lx", hDlg));

        return(FALSE);
    }
}



#if 0

//
//=======O L D    S T U F F, WILL BE REMOVED=========================
//


#define MAX_COMPROPSHEETUI_PAGES    64


#define CPSUIHDRF_USESTARTPAGE      0x0001
#define CPSUIHDRF_NOAPPLYNOW        0x0002
#define CPSUIHDRF_PROPTITLE         0x0004
#define CPSUIHDRF_USEHICON          0x0008
#define CPSUIHDRF_DEFTITLE          0x0010


typedef struct _COMPROPSHEETUIHEADER {
    WORD            cbSize;
    WORD            Flags;
    LPTSTR          pTitle;
    HWND            hWndParent;
    HINSTANCE       hInst;
    union {
        HICON       hIcon;
        WORD        IconID;
        } DUMMYUNIONNAME;
    WORD            cPages;
    WORD            iStartPage;
    HPROPSHEETPAGE  hPages[MAX_COMPROPSHEETUI_PAGES];
    LPVOID          pData;
    LPARAM          lParam;
    } COMPROPSHEETUIHEADER, *PCOMPROPSHEETUIHEADER;

//
// COMPROPSHEETUIHEADER
//
//  This structure describe the property sheets needed for the UI.
//
//  cbSize      - size of this structure
//
//  Flags       - CPSUIHDRF_xxxx flags
//
//                  CPSUIHDRF_USESTARTPAGE
//
//                      Use iStartPage for the first page to be come up in
//                      property sheet.
//
//
//                  CPSUIHDRF_NOAPPLYNOW
//
//                      Remove Apply Now button.
//
//
//                  CPSUIHDRF_PROPTITLE
//
//                      Automatically include 'Properties' in the title bar
//
//
//                  CPSUIHDRF_USEHICON
//
//                      If this bit is specified then hIcon union field is
//                      a valid handle to the icon otherwise the IconID is
//                      the either caller's resource ID or common UI standard
//                      icon ID.
//
//                  CPSUIHDRF_DEFTITLE
//
//                      Automatically include 'Default' in the title bar, the
//                      'Default' always added right after pTitle and before
//                      'Properties' if CPSUIHDRF_PROPTITLE flag is set.
//
//  pTitle      - Pointer to the NULL terminated caption name for the
//                property sheets.
//
//                  * See LPTSTR typedef description above
//
//  hWndParent  - The handle of the window which will be parent of the common
//                UI property sheets, if NULL then current active window for
//                the calling thread is used.
//
//  hInst       - the caller's handle to its instance.  Commom UI use this
//                handle to load caller's icon and other resources.
//
//  hIcon
//  IconID      - Specified the icon which put on the title bar, it either a
//                handle to the icon or a icon resource ID depends on the
//                CPSUIHDRF_USEHICON flag.
//
//  cPages      - Total valid Pages (start from hPages[0]) currently
//                initialized and set in the hPage[].
//
//  iStartPage  - Zero-based index of initial page that appears when the
//                propperty sheet dialog box is created
//
//  pData       - Pointer to requested data for the called CommonPropSheetUI()
//                function.   for the Common Prnter UI function
//                CommonPropSheetUI(), this must a valid pointer pointed to
//                the COMPROPSHEETUI structure.
//
//  lParam      - a LONG parameter which requested for the called
//                CommonPropSheetUI() function, for the common printer UI
//                function this is the mode
//


typedef LONG (APIENTRY *_COMPROPSHEETUIFUNC)(
                                    PCOMPROPSHEETUIHEADER  pComPropSheetUIHdr,
                                    LONG (APIENTRY         *pfnNext)());
#define COMPROPSHEETUIFUNC  LONG APIENTRY


//
// COMPROPSHEETUIFUNC
// CommonPropSheeteUI(
//     PCOMPROPSHEETUIHEADER    pComPropSheetUIHdr,
//     _COMPROPSHEETUIFUNC      pfnNext
//     )
//
// /*++
//
// Routine Description:
//
//     This is the main entry point to the common printer property sheet
//     user interface.
//
//
// Arguments:
//
//  pComPropSheetUIHdr  - Pointer to the COMPROPSHEETUIHEADER structure.
//
//                       * The pData in this structure must be a valid
//                         pointer to the COMPROPSHEETUI structure
//
//  pfnNext             - a _COMPROPSHEETUIFUNC pointer.  This is the pointer
//                        to the next CommonPropSheetUI function, when this
//                        function finished adding property sheets to the
//                        COMPROPSHEETUIHEADER structure, it will call this
//                        function pointer.
//
//                        if this function pointer is NULL then it will add its
//                        own property sheet pages to the COMPROPSHEETUIHEADER
//                        and then call PropertySheet() function to pop up the
//                        proerty sheet UI
//
//
// Return Value:
//
//     <0: Error occurred (Return value is error code ERR_CPSUI_xxxx)
//     =0: User select 'Cancel' button (CPSUI_OK)
//     >0: User select 'Ok' button (CPSUI_CANCEL)
//
//
// Author:
//
//     01-Sep-1995 Fri 12:29:10 created  -by-  Daniel Chou (danielc)
//
//
//



COMPROPSHEETUIFUNC
CommonPropSheetUIA(
    PCOMPROPSHEETUIHEADER   pComPropSheetUIHdr,
    _COMPROPSHEETUIFUNC     pfnNext
    );

COMPROPSHEETUIFUNC
CommonPropSheetUIW(
    PCOMPROPSHEETUIHEADER   pComPropSheetUIHdr,
    _COMPROPSHEETUIFUNC     pfnNext
    );

#ifdef UNICODE
#define CommonPropSheetUI   CommonPropSheetUIW
#else
#define CommonPropSheetUI   CommonPropSheetUIA
#endif

//
//==========================================================================
//


typedef struct _CPSUIHDREX {
    COMPROPSHEETUIHEADER    Hdr;
    _COMPROPSHEETUIFUNC     pfnNext;
    HANDLE                  hParent;
    PFNCOMPROPSHEET         pfnCPS;
    DWORD                   Result;
    } CPSUIHDRX, *PCPSUIHDRX;



LONG
AddOldCPSUIPages(
    PCPSUIHDRX  pCPSUIHdrX,
    BOOL        Unicode
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    03-Feb-1996 Sat 20:08:59 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HANDLE          hAdd;
    HPROPSHEETPAGE  hPage;
    LONG            cPages = 0;
    UINT            i;
    UINT            iStartPage;
    DWORD           dw;


    if (pCPSUIHdrX->Hdr.Flags & CPSUIHDRF_USESTARTPAGE) {

        iStartPage = (UINT)pCPSUIHdrX->Hdr.iStartPage;

    } else {

        iStartPage = 0xFFFF;
    }

    for (i = 0; i < (UINT)pCPSUIHdrX->Hdr.cPages; i++) {

        if (hPage = pCPSUIHdrX->Hdr.hPages[i]) {

            if (hAdd = (HANDLE)pCPSUIHdrX->pfnCPS(pCPSUIHdrX->hParent,
                                                  CPSFUNC_ADD_HPROPSHEETPAGE,
                                                  (LPARAM)hPage,
                                                  (LPARAM)NULL)) {

                CPSUIDBG(DBG_ADDOLDCPSUI,
                         ("AddOldCPSUIPage: Add %u hAdd=%08lx", i, hAdd));

                if (iStartPage == i) {

                    pCPSUIHdrX->pfnCPS(pCPSUIHdrX->hParent,
                                       CPSFUNC_SET_HSTARTPAGE,
                                       (LPARAM)hAdd,
                                       (LPARAM)0);
                }

                cPages++;
            }

        } else {

            CPSUIERR(("AddOldCPSUIPage: Add hPage FAILED"));
        }

        pCPSUIHdrX->Hdr.hPages[i] = NULL;
    }

    if (pCPSUIHdrX->Hdr.pData) {

        if (hAdd = (HANDLE)pCPSUIHdrX->pfnCPS(pCPSUIHdrX->hParent,
                                              (Unicode) ?
                                                CPSFUNC_ADD_PCOMPROPSHEETUIW :
                                                CPSFUNC_ADD_PCOMPROPSHEETUIA,
                                              (LPARAM)pCPSUIHdrX->Hdr.pData,
                                              (LPARAM)&dw)) {

            CPSUIDBG(DBG_ADDOLDCPSUI,
                     ("AddOldCPSUIPage: Add COMPROPSHEETUI Pages=%ld", dw));

            if ((iStartPage >= i) && (iStartPage < (UINT)(i + dw))) {

                pCPSUIHdrX->pfnCPS(pCPSUIHdrX->hParent,
                                   CPSFUNC_SET_HSTARTPAGE,
                                   (LPARAM)hAdd,
                                   (LPARAM)0);
            }

            while (dw--) {

                cPages++;
                pCPSUIHdrX->Hdr.hPages[i++] = NULL;
            }

            pCPSUIHdrX->Hdr.pData = NULL;

        } else {

            CPSUIERR(("AddOldCPSUIPage: Add COMPROPSHEETUI FAILED"));
        }
    }

    if (pCPSUIHdrX->pfnNext) {

        CPSUIDBG(DBG_ADDOLDCPSUI,
                 ("AddOldCPSUIPage: Call pfnNext=%08lx", pCPSUIHdrX->pfnNext));

        return(pCPSUIHdrX->pfnNext((PCOMPROPSHEETUIHEADER)pCPSUIHdrX, NULL));
    }

    return(cPages);
}



LONG
CALLBACK
CommonPropSheetUIFunc(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )

/*++

Routine Description:

    This is main entry for old DrvDocumentProperties() and
    DrvAdvanceDocumentProperties() which using the new common UI functions


Arguments:

    pPSUIInfo   - Pointer to the PROPSHEETUI_INFO data structure

    lParam      - LPARAM for this call, it is a pointer to the
                  PROPSHEETUI_INFO_HEADER


Return Value:

    LONG


Author:

    02-Feb-1996 Fri 14:39:15 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCPSUIHDRX                  pCPSUIHdrX;
    PPROPSHEETUI_INFO_HEADER    pPSUIInfoHdr;


    if ((!pPSUIInfo)    ||
        (!(pCPSUIHdrX = (PCPSUIHDRX)pPSUIInfo->lParamInit))) {

        CPSUIASSERT(0, "ComPropSheetUI: Pass a NULL pPSUIInfo", FALSE, 0);

        SetLastError(ERROR_INVALID_DATA);
        return(-1);
    }

    switch (pPSUIInfo->Reason) {

    case PROPSHEETUI_REASON_INIT:

        pPSUIInfo->Result   = pCPSUIHdrX->Result;
        pCPSUIHdrX->hParent = pPSUIInfo->hComPropSheet;
        pCPSUIHdrX->pfnCPS  = pPSUIInfo->pfnComPropSheet;

        return(AddOldCPSUIPages(pCPSUIHdrX,
                                (pPSUIInfo->Flags & PSUIINFO_UNICODE)));

    case PROPSHEETUI_REASON_GET_INFO_HEADER:

        if (!(pPSUIInfoHdr = (PPROPSHEETUI_INFO_HEADER)lParam)) {

            CPSUIERR(("GET_INFO_HEADER: Pass a NULL pPSUIInfoHdr"));
            return(-1);
        }

        pPSUIInfoHdr->Flags      = pCPSUIHdrX->Hdr.Flags;
        pPSUIInfoHdr->pTitle     = pCPSUIHdrX->Hdr.pTitle;
        pPSUIInfoHdr->hWndParent = pCPSUIHdrX->Hdr.hWndParent;
        pPSUIInfoHdr->hInst      = pCPSUIHdrX->Hdr.hInst;
        pPSUIInfoHdr->IconID     = pCPSUIHdrX->Hdr.IconID;

        break;

    case PROPSHEETUI_REASON_SET_RESULT:

        //
        // Save the result and propagate it to the owner
        //

        pPSUIInfo->Result = ((PSETRESULT_INFO)lParam)->Result;
        return(1);

    case PROPSHEETUI_REASON_DESTROY:

        return(1);
    }
}




LONG
DoCommonPropSheetUI(
    PCOMPROPSHEETUIHEADER   pCPSUIHdr,
    _COMPROPSHEETUIFUNC     pfnNext,
    BOOL                    AnsiCall
    )

/*++

Routine Description:

    This is the main entry point to the common UI


Arguments:



Return Value:

    LONG

    <0: Error occurred (Error Code of ERR_CPSUI_xxxx)
    =0: User select 'Cancel' button (CPSUI_CANCEL)
    >0: User select 'Ok' button (CPSUI_OK)


Author:

    28-Aug-1995 Mon 16:21:42 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    WORD    cPages;


    if ((!pCPSUIHdr)    ||
        (pCPSUIHdr->cbSize != sizeof(COMPROPSHEETUIHEADER))) {

        return(ERR_CPSUI_INVALID_PDATA);
    }

    if (!pCPSUIHdr->hInst) {

        return(ERR_CPSUI_NULL_HINST);
    }

    if ((!(cPages = pCPSUIHdr->cPages)) ||
        ((cPages) && (pCPSUIHdr->hPages[cPages - 1] != NULL))) {

        CPSUIHDRX   CPSUIHdrX;
        LONG        Result;
        LONG        Ret;

        //
        // This is the first time around
        //

        CPSUIDBG(DBG_DOCPSUI, ("DoComPropSheetUI: FIRST time call"));

        CPSUIHdrX.Hdr     = *pCPSUIHdr;
        CPSUIHdrX.pfnNext = pfnNext;
        CPSUIHdrX.hParent = NULL;
        CPSUIHdrX.pfnCPS  = NULL;
        CPSUIHdrX.Result  = CPSUI_CANCEL;

        if ((Ret = DoCommonPropertySheetUI(CPSUIHdrX.Hdr.hWndParent,
                                           CommonPropSheetUIFunc,
                                           (LPARAM)&CPSUIHdrX,
                                           (LPDWORD)&Result,
                                           AnsiCall)) >= 0L) {

            Ret = Result;
        }

        CPSUIDBG(DBG_DOCPSUI, ("DoCommonPropSheetUI() = %ld", Ret));

        return(Ret);

    } else {

        CPSUIDBG(DBG_DOCPSUI, ("DoComPropSheetUI: Second+ time call"));

        ((PCPSUIHDRX)pCPSUIHdr)->pfnNext = pfnNext;

        return(AddOldCPSUIPages((PCPSUIHDRX)pCPSUIHdr, !AnsiCall));
    }
}




COMPROPSHEETUIFUNC
CommonPropSheetUIW(
    PCOMPROPSHEETUIHEADER   pComPropSheetUIHdr,
    _COMPROPSHEETUIFUNC     pfnNext
    )

/*++

Routine Description:

    This is the main entry point to the common printer property sheet
    user interface.


Arguments:

 pComPropSheetUIHdr  - Pointer to the COMPROPSHEETUIHEADER structure.

                      * The pData in this structure must be a valid
                        pointer to the COMPROPSHEETUI structure

 pfnNext             - a _COMPROPSHEETUIFUNC pointer.  This is the pointer
                       to the next CommonPropSheetUI function, when this
                       function finished adding property sheets to the
                       COMPROPSHEETUIHEADER structure, it will call this
                       function pointer.

                       if this function pointer is NULL then it will add its
                       own property sheet pages to the COMPROPSHEETUIHEADER
                       and then call PropertySheet() function to pop up the
                       proerty sheet UI


Return Value:

    <0: Error occurred (Return value is error code ERR_CPSUI_xxxx)
    =0: User select 'Cancel' button (CPSUI_OK)
    >0: User select 'Ok' button (CPSUI_CANCEL)


Author:

    01-Sep-1995 Fri 12:29:10 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG    Result;

    Result = DoCommonPropSheetUI(pComPropSheetUIHdr, pfnNext, FALSE);

    if (Result < 0) {

        CPSUIERR(("CommonPropSheetUIW() = %ld", Result));

    } else {

        CPSUIINT(("CommonPropSheetUIW() = %ld", Result));
    }

    return(Result);
}



COMPROPSHEETUIFUNC
CommonPropSheetUIA(
    PCOMPROPSHEETUIHEADER   pComPropSheetUIHdr,
    _COMPROPSHEETUIFUNC     pfnNext
    )

/*++

Routine Description:

    This is the main entry point to the common printer property sheet
    user interface.


Arguments:

 pComPropSheetUIHdr  - Pointer to the COMPROPSHEETUIHEADER structure.

                      * The pData in this structure must be a valid
                        pointer to the COMPROPSHEETUI structure

 pfnNext             - a _COMPROPSHEETUIFUNC pointer.  This is the pointer
                       to the next CommonPropSheetUI function, when this
                       function finished adding property sheets to the
                       COMPROPSHEETUIHEADER structure, it will call this
                       function pointer.

                       if this function pointer is NULL then it will add its
                       own property sheet pages to the COMPROPSHEETUIHEADER
                       and then call PropertySheet() function to pop up the
                       proerty sheet UI


Return Value:

    <0: Error occurred (Return value is error code ERR_CPSUI_xxxx)
    =0: User select 'Cancel' button (CPSUI_OK)
    >0: User select 'Ok' button (CPSUI_CANCEL)


Author:

    01-Sep-1995 Fri 12:29:10 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG    Result;

    Result = DoCommonPropSheetUI(pComPropSheetUIHdr, pfnNext, TRUE);

    if (Result < 0) {

        CPSUIERR(("CommonPropSheetUIA() = %ld", Result));

    } else {

        CPSUIINT(("CommonPropSheetUIA() = %ld", Result));
    }

    return(Result);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\apilayer.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    apilayer.h


Abstract:

    This module contains all API layer's definiton


Author:

    02-Jan-1996 Tue 13:28:08 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/

#ifndef CPSUI_APILAYER
#define CPSUI_APILAYER


//================= Internal Data structures =============================
//


#define TABTABLE_COUNT          (MAXPROPPAGES + 3)

#define TAB_MODE_INIT           0
#define TAB_MODE_FIND           1
#define TAB_MODE_INSERT         2
#define TAB_MODE_DELETE         3
#define TAB_MODE_DELETE_ALL     4

#define GET_REAL_INSIDX(ptbl)  ((ptbl)->TabInfo[(ptbl)->InsIdx].OrgInsIdx)

#define DP_STD_INT_TVPAGE       DP_STD_RESERVED_START

#define COUNT_POSTSETCURSEL     32

typedef struct _TABINFO {
    SHORT   OrgInsIdx;
    WORD    HandleIdx;
    HWND    hDlg;
    } TABINFO, *PTABINFO;

#define TTF_POST_SETCURSEL      0x0001

typedef struct _TABTABLE {
    struct _TABTABLE    *pTabTable;
    HWND                hPSDlg;
    HWND                hWndTab;
    WNDPROC             WndProc;
    WORD                cPostSetCurSel;
    SHORT               iPostSetCurSel;
    WORD                cTab;
    WORD                CurSel;
    WORD                InsIdx;
    WORD                HandleIdx;
    TABINFO             TabInfo[TABTABLE_COUNT];
    } TABTABLE, *PTABTABLE;


#define CPSUIPAGE_ID            0x43444955

#define CPF_ROOT                0x00000001
#define CPF_PARENT              0x00000002
#define CPF_PFNPROPSHEETUI      0x00000004
#define CPF_COMPROPSHEETUI      0x00000008
#define CPF_USER_GROUP          0x00000010
#define CPF_DLL                 0x00000020
#define CPF_CALLER_HPSPAGE      0x00000040
#define CPF_ANSI_CALL           0x00000080
#define CPF_DONE_PROPSHEET      0x00000100
#define CPF_DONE_PROPSHEETPROC  0x00000200
#define CPF_SHOW_PROPSHEET      0x00000400
#define CPF_DOCPROP             0x00000800
#define CPF_ADVDOCPROP          0x00001000
#define CPF_PRINTERPROP         0x00002000
#define CPF_CALL_TV_DIRECT      0x00004000
#define CPF_NO_PSN_APPLY        0x00008000
#define CPF_HAS_CPSUI           0x00010000
#define CPF_NO_APPLY_BUTTON     0x00020000
#define CPF_ACTIVATED           0x00040000
#define CPF_DLGPROC_CHANGED     0x00080000
#define CPF_PSZ_PSTARTPAGE      0x00100000

typedef struct _CPSUIPAGE;


typedef struct _MYDATABLOCK {
    struct _MYDATABLOCK *pNext;
    DWORD               ID;
    DWORD               cb;
    } MYDATABLOCK, *PMYDATABLOCK;

#define SIZE_DB(c)      (sizeof(MYDATABLOCK) + (c))

typedef struct _ROOTINFO {
    HWND                hDlg;
    LPDWORD             pResult;
    PTABTABLE           pTabTable;
    struct _CPSUIPAGE   *pStartPage;
    WORD                cPage;
    WORD                cCPSUIPage;
    DWORD               DMPubHideBits;
    PMYDATABLOCK        pMyDB;
    } ROOTINFO, *PROOTINFO;

typedef struct _PFNINFO {
    HINSTANCE       hInst;
    PFNPROPSHEETUI  pfnPSUI;
    LPARAM          lParamInit;
    ULONG_PTR       UserData;
    ULONG_PTR       Result;
    } PFNINFO, *PPFNINFO;

typedef struct _CPSUIINFO {
    PTVWND  pTVWnd;
    LONG    Result;
    LONG    TVPageIdx;
    LONG    StdPageIdx1;
    LONG    StdPageIdx2;
    } CPSUIINFO, PCPSUIINFO;

typedef struct _HPAGEINFO {
    HWND                hDlg;
    DLGPROC             DlgProc;
    LPFNPSPCALLBACK     pspCB;
    LPARAM              lParam;
    HICON               hIcon;
    DWORD               dwSize;
    } HPAGEINFO, *PHPAGEINFO;


typedef struct _CPSUIPAGE {
    DWORD                   ID;
    DWORD                   cLock;
    DWORD                   Flags;
    HANDLE                  hCPSUIPage;
    HANDLE                  hActCtx;
    struct _CPSUIPAGE       *pParent;
    struct _CPSUIPAGE       *pPrev;
    struct _CPSUIPAGE       *pNext;
    union {
        struct _CPSUIPAGE   *pChild;
        HPROPSHEETPAGE      hPage;
        } DUMMYUNIONNAME;
    union {
        ROOTINFO            RootInfo;
        PFNINFO             pfnInfo;
        CPSUIINFO           CPSUIInfo;
        HPAGEINFO           hPageInfo;
        } DUMMYUNIONNAME2;
    } CPSUIPAGE, *PCPSUIPAGE;


typedef BOOL (CALLBACK *CPSUIPAGEENUMPROC)(PCPSUIPAGE   pRootPage,
                                           PCPSUIPAGE   pCPSUIPage,
                                           LPARAM       lParam);


#define SET_APPLY_BUTTON(pTVWnd, hDlg)                                      \
{                                                                           \
    if (!(*((pTVWnd)->pRootFlags) & CPF_NO_APPLY_BUTTON)) {                 \
                                                                            \
        if (CountRevertOptItem((pTVWnd),                                    \
                               NULL,                                        \
                               TreeView_GetRoot((pTVWnd)->hWndTV),          \
                               0)) {                                        \
                                                                            \
            PropSheet_Changed(GetParent(hDlg), hDlg);                       \
                                                                            \
        } else {                                                            \
                                                                            \
            PropSheet_UnChanged(GetParent(hDlg), hDlg);                     \
        }                                                                   \
    }                                                                       \
}

#define HINSPSUIPAGE_2_IDX(h)           ((UINT)LOWORD(LODWORD(h)))
#define ARRAYSIZE(x)                    (sizeof(x)/sizeof(x[0]))

//
// Local structure
//

typedef struct _PSPEX {
    PROPSHEETPAGE   psp;
    PSPINFO         pspInfo;
    } PSPEX, *PPSPEX;

typedef struct _PSHINFO {
    WCHAR   CaptionName[MAX_RES_STR_CHARS];
    } PSHINFO, *PPSHINFO;

typedef struct _PAGEPROCINFO {
    PTABTABLE       pTabTable;
    HPROPSHEETPAGE  *phPage;
    HANDLE          *pHandle;
    WORD            cPage;
    WORD            iPage;
    } PAGEPROCINFO, *PPAGEPROCINFO;


typedef struct _INSPAGEIDXINFO {
    PCPSUIPAGE  pCPSUIPage;
    PTABTABLE   pTabTable;
    } INSPAGEIDXINFO, *PINSPAGEIDXINFO;


//
// Function prototypes
//


DWORD
FilterException(
    HANDLE                  hPage,
    LPEXCEPTION_POINTERS    pExceptionPtr
    );


BOOL
CALLBACK
SetInsPageIdxProc(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pCPSUIPage,
    LPARAM      lParam
    );

LONG_PTR
CALLBACK
CPSUICallBack(
    HANDLE  hComPropSheet,
    UINT    Function,
    LPARAM  lParam1,
    LPARAM  lParam2
    );

LONG
AddComPropSheetPage(
    PCPSUIPAGE  pCPSUIPage,
    UINT        PageIdx
    );

BOOL
EnumCPSUIPagesSeq(
    PCPSUIPAGE          pRootPage,
    PCPSUIPAGE          pCPSUIPage,
    CPSUIPAGEENUMPROC   CPSUIPageEnumProc,
    LPARAM              lParam
    );


BOOL 
GetPageActivationContext(
    PCPSUIPAGE      pCPSUIPage, 
    HANDLE         *phActCtx
    );

#endif  // CPSUI_APILAYER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\dialogs.h ===
#define STDPAGE1_TAB                65533
#define STDPAGE2_TAB                65534
#define TREEVIEW_TAB                65535
#define STDPAGE1_TEST               65530
#define DLGABOUT                    65510

#define IDD_TRAY_GROUP              1199
#define IDD_DEFSOURCE_GROUP         1200
#define IDD_DEFSOURCE_TEXT          1201
#define IDD_DEFSOURCE               1202
#define IDD_DEFSOURCE_ICON          1203
#define IDD_DEFSOURCE_ECB           1204
#define IDD_DEFSOURCE_ECBV_ICON     1205

#define IDD_OUTPUTBIN_GROUP         1210
#define IDD_OUTPUTBIN_TEXT          1211
#define IDD_OUTPUTBIN               1212
#define IDD_OUTPUTBIN_ICON          1213
#define IDD_OUTPUTBIN_ECB           1214
#define IDD_OUTPUTBIN_ECB_ICON      1215

#define IDD_MEDIATYPE_GROUP         1220
#define IDD_MEDIATYPE_TEXT          1221
#define IDD_MEDIATYPE               1222
#define IDD_MEDIATYPE_ICON          1223
#define IDD_MEDIATYPE_ECB           1224
#define IDD_MEDIATYPE_ECB_ICON      1225

#define IDD_ORIENT_GROUP            1230
#define IDD_ORIENT_TEXT             1231
#define IDD_ORIENT_S1               1232
#define IDD_ORIENT_S1_ICON          1233
#define IDD_ORIENT_S2               1234
#define IDD_ORIENT_S2_ICON          1235
#define IDD_ORIENT_S3               1236
#define IDD_ORIENT_S3_ICON          1237
#define IDD_ORIENT_ECB              1238
#define IDD_ORIENT_ECB_ICON         1239

#define IDD_COPIES_GROUP            1240
#define IDD_COPIES_TEXT             1241
#define IDD_COPIES                  1242
#define IDD_COPIES_ICON             1243
#define IDD_COPIES_POSTFIX          1244
#define IDD_COPIES_HELP             1245
#define IDD_COPIES_UDARROW          1246
#define IDD_COPIES_ECB              1247
#define IDD_COPIES_ECB_ICON         1248

#define IDD_COLOR_GROUP             1260
#define IDD_COLOR_TEXT              1261
#define IDD_COLOR_S1                1262
#define IDD_COLOR_S1_ICON           1263
#define IDD_COLOR_S2                1264
#define IDD_COLOR_S2_ICON           1265
#define IDD_COLOR_ECB               1266
#define IDD_COLOR_ECB_ICON          1267

#define IDD_DUPLEX_GROUP            1270
#define IDD_DUPLEX_TEXT             1271
#define IDD_DUPLEX_S1               1272
#define IDD_DUPLEX_S1_ICON          1273
#define IDD_DUPLEX_S2               1274
#define IDD_DUPLEX_S2_ICON          1275
#define IDD_DUPLEX_S3               1276
#define IDD_DUPLEX_S3_ICON          1277
#define IDD_DUPLEX_ECB              1278
#define IDD_DUPLEX_ECB_ICON         1279

#define IDD_QUALITY_GROUP           1290
#define IDD_QUALITY_TEXT            1291
#define IDD_QUALITY_S1              1292
#define IDD_QUALITY_S1_ICON         1293
#define IDD_QUALITY_S2              1294
#define IDD_QUALITY_S2_ICON         1295
#define IDD_QUALITY_S3              1296
#define IDD_QUALITY_S3_ICON         1297
#define IDD_QUALITY_ECB             1298
#define IDD_QUALITY_ECB_ICON        1299


#define IDD_PAGEORDER_GROUP         1400
#define IDD_PAGEORDER_TEXT          1401
#define IDD_PAGEORDER_S1            1402
#define IDD_PAGEORDER_S1_ICON       1403
#define IDD_PAGEORDER_S2            1404
#define IDD_PAGEORDER_S2_ICON       1405
#define IDD_PAGEORDER_ECB           1406
#define IDD_PAGEORDER_ECB_ICON      1407

#define IDD_NUP_GROUP               1450
#define IDD_NUP_TEXT                1451
#define IDD_NUP                     1452
#define IDD_NUP_ICON                1453
#define IDD_NUP_ECB                 1454
#define IDD_NUP_ECB_ICON            1455

#define IDD_ADVANCED_PUSH1          1500
#define IDD_ADVANCED_PUSH2          1502
#define IDD_LAYOUT_PICTURE_GROUP    1503
#define IDD_LAYOUT_PICTURE          1504
 
#define IDD_TV_UDARROW              9000
#define IDD_TV_UDARROW_EDIT         9001
#define IDD_TV_UDARROW_HELP         9002
#define IDD_TV_UDARROW_ENDTEXT      9003

#define IDD_TV_PUSH                 9020
#define IDD_TV_OPTION               9030
#define IDD_TV_LB                   9040

#define IDD_TV_EDIT_EDIT            9050
#define IDD_TV_EDIT_ENDTEXT         9051
#define IDD_TV_EDIT_HELP            9052

#define IDD_TV_CB                   9060

#define IDD_TV_ICON                 9070
#define IDD_TV_BMP                  9071

#define IDD_TV_MSAA_NAME            9080

#define IDD_3STATES_1               9090
#define IDD_3STATES_2               9092
#define IDD_3STATES_3               9094

#define IDD_TV_WND                  9110

#define IDD_TV_TRACKBAR             9120

#define IDD_TV_SB                   9130
#define IDD_TV_SB_LOW               9131
#define IDD_TV_SB_HIGH              9132

#define IDD_TV_CHKBOX               9140
#define IDD_TV_EXTCHKBOX            9150
#define IDD_TV_ECB_ICON             9151
#define IDD_TV_HDR_PUSH_ICON        9160
#define IDD_TV_EXTPUSH              9170


#define IDS_INT_CPSUI_AV1           20000
#define IDS_INT_CPSUI_AV2           20001
#define IDS_INT_CPSUI_AV3           20002
#define IDS_INT_CPSUI_AV4           20003
#define IDS_INT_CPSUI_HELPFILE      20004


#define IDS_INT_CPSUI_ABOUT         20100
#define IDS_INT_CPSUI_SETUP         20101
#define IDS_INT_CPSUI_UNDO_OPT      20102
#define IDS_INT_CPSUI_UNDO_OPTS     20103
#define IDS_INT_CPSUI_VERSION       20104
#define IDS_INT_CPSUI_DOC_SET       20105
#define IDS_INT_CPSUI_ADVDOC_SET    20106
#define IDS_INT_CPSUI_DEVICE_SET    20107
#define IDS_INT_CPSUI_SETTINGS      20108

#define IDS_INT_CPSUI_OPTIONS       20109
#define IDS_INT_CPSUI_CHANGE_SET    20110
#define IDS_INT_CPSUI_RANGE         20111
#define IDS_INT_CPSUI_SPACE_CHAR    20112
#define IDS_INT_CPSUI_DEFAULT       20113
#define IDS_INT_CPSUI_DOCUMENT      20114
#define IDS_INT_CPSUI_DEFDOCUMENT   20115
#define IDS_INT_CPSUI_ADVDOCUMENT   20116
#define IDS_INT_CPSUI_ADVDOCOPTION  20117
#define IDS_INT_CPSUI_WHATISTHIS    20118

#define IDS_ABOUT_COMPANY           30000
#define IDS_ABOUT_PRODUCT           30005
#define IDS_ABOUT_CALLER            30010
#define IDS_ABOUT_COPYRIGHT         30015
#define IDS_ABOUT_OPTITEM           30020
#define IDI_ABOUT_ICON              30050

#define ADVANCED_PUSH               8000
#define IDOK                        1
#define TREEVIEW_TAB_CLOSE          65520
#define TV_EDIT_DLG                 100
#define TREEVIEW_TAB_CLOSE_TMP      200
#define TREEVIEW_TAB_TMP            300
#define TREEVIEW_TAB_CLOSE_TMP2     400
#define TREEVIEW_TAB_TMP2           500
#define TREEVIEW_TAB_CLOSE_TMP1     600
#define TMP_WND_HOLDER              160
#define IDD_PRE_EDIT                40000
#define IDD_POST_EDIT               40001

#define IDD_TMP_ABOUT_WND           40050

#define ID_CMD_ABOUT                40100
#define ID_CMD_HELP                 40101
#define ID_CMD_UNDO                 40102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\convert.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    convert.h


Abstract:

    This module contains all previous version data


Author:

    10-Oct-1995 Tue 19:27:36 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/


LONG
InitMYDLGPAGE(
    PMYDLGPAGE  pMyDP,
    PDLGPAGE    pDP,
    UINT        cDP
    );

LONG
GetCurCPSUI(
    PTVWND          pTVWnd,
    POIDATA         pOIData,
    PCOMPROPSHEETUI pCPSUIFrom
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\compstui\dlgctrl.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    dlgctrl.c


Abstract:

    This module contains most of dialog control update procedures


Author:

    24-Aug-1995 Thu 19:42:09 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop


#define DBG_CPSUIFILENAME   DbgDlgCtrl



#define DBG_CTB             0x00000001
#define DBG_CUDA            0x00000002
#define DBG_INITTBSB        0x00000004
#define DBG_UCBC            0x00000008
#define DBG_DOCB            0x00000010
#define DBG_DOPB            0x00000020
#define DBG_CS              0x00000040
#define DBG_INITLBCB        0x00000080
#define DBGITEM_CB          0x00000100
#define DBGITEM_PUSH        0x00000200
#define DBGITEM_CS          0x00000400
#define DBG_UDARROW         0x00000800
#define DBG_HELP            0x00001000
#define DBG_FNLC            0x00002000
#define DBG_CLBCB           0x00004000
#define DBG_IFW             0x00008000
#define DBG_SCID            0x00010000
#define DBG_VALIDATE_UD     0x00020000
#define DBG_CB_CY           0x00040000
#define DBG_FOCUS           0x00080000
#define DBG_CBWNDPROC       0x00100000
#define DBG_TMP             0x80000000

DEFINE_DBGVAR(0);

#define SPSF_USE_BUTTON_CY      0x0001
#define SPSF_ALIGN_EXTPUSH      0x0002


#define PUSH_CY_EXTRA           12
#define PUSH_CX_EXTRA_W         2
#define ICON16_CX_SPACE         6

#define LBCBID_DISABLED         0x80000000L
#define LBCBID_FILL             0x40000000L
#define LBCBID_NONE             0x20000000L


#define INTDMPUB_CHANGED        0x0001
#define INTDMPUB_REINIT         0x0002

//
// Following EDF_xxx is used     for Up-Down-Arrow control
//

#define EDF_MINUS_OK            0x80
#define EDF_IN_TVPAGE           0x40
#define EDF_NUMBERS             0x20
#define EDF_BACKSPACE           0x10
#define EDF_BEGIDXMASK          0x07

#define EDF_STATIC_MASK         (EDF_MINUS_OK | EDF_IN_TVPAGE)

#define MAX_UDARROW_TEXT_LEN    7


extern HINSTANCE    hInstDLL;
extern BYTE         cTVOTCtrls[];
extern OPTTYPE      OptTypeHdrPush;
extern EXTPUSH      ExtPushAbout;
extern BYTE         cTVOTCtrls[];


typedef struct _ABOUTINFO {
    PTVWND      pTVWnd;
    HICON       hIcon;
    LPARAM      Pos;
    } ABOUTINFO, *PABOUTINFO;


typedef struct _ABOUTPOS {
    _CPSUICALLBACK  pfnCallBack;
    PCPSUICBPARAM   pCBParam;
    HWND            hFocus;
    LPARAM          Pos;
    } ABOUTPOS, *PABOUTPOS;


extern
LONG
APIENTRY
HTUI_ColorAdjustmentA(
    LPSTR               pDeviceName,
    HANDLE              hDIB,
    LPSTR               pDIBTitle,
    PCOLORADJUSTMENT    pca,
    BOOL                ShowMonoOnly,
    BOOL                UpdatePermission
    );

extern
LONG
APIENTRY
HTUI_ColorAdjustmentW(
    LPWSTR              pDeviceName,
    HANDLE              hDIB,
    LPWSTR              pDIBTitle,
    PCOLORADJUSTMENT    pca,
    BOOL                ShowMonoOnly,
    BOOL                UpdatePermission
    );

extern
LONG
APIENTRY
HTUI_DeviceColorAdjustmentA(
    LPSTR           pDeviceName,
    PDEVHTADJDATA   pDevHTAdjData
    );

extern
LONG
APIENTRY
HTUI_DeviceColorAdjustmentW(
    LPWSTR          pDeviceName,
    PDEVHTADJDATA   pDevHTAdjData
    );


#define IS_TVDLG    (InitFlags & INITCF_TVDLG)

#define SHOWCTRL(hCtrl, Enable, swMode)                                     \
{                                                                           \
    EnableWindow(hCtrl, (Enable) && (InitFlags & INITCF_ENABLE));           \
    ShowWindow(hCtrl, (swMode));                                            \
}

#define SETCTRLTEXT(hCtrl, pTitle)                                          \
{                                                                           \
    GSBUF_RESET; GSBUF_GETSTR(pTitle);                                      \
    SetWindowText(hCtrl, GSBUF_BUF);                                        \
}


#define GETHCTRL(i)                                                         \
    if (i) { hCtrl=GetDlgItem(hDlg,(i)); } else { hCtrl=NULL; }
#define HCTRL_TEXT(h,p)     if (h) { SETCTRLTEXT(h,(p)); }
#define HCTRL_STATE(h,e,m)  if (h) { SHOWCTRL((h),(e),(m)); }

#define HCTRL_TEXTSTATE(hCtrl, pTitle, Enable, swMode)                      \
{                                                                           \
    if (hCtrl) {                                                            \
                                                                            \
        SETCTRLTEXT(hCtrl, (pTitle));                                       \
        SHOWCTRL(hCtrl, (Enable), (swMode));                                \
    }                                                                       \
}

#define ID_TEXTSTATE(i,p,e,m)   GETHCTRL(i); HCTRL_TEXTSTATE(hCtrl,p,e,m)

#define SET_EXTICON(IS_ECB)                                                 \
{                                                                           \
    BOOL    swIcon = swMode;                                                \
                                                                            \
    if ((!(hCtrl2 = GetDlgItem(hDlg, ExtIconID)))   ||                      \
        ((!IconResID) && (!(IconMode & MIM_MASK)))) {                       \
                                                                            \
         swIcon = SW_HIDE;                                                  \
         Enable = FALSE;                                                    \
    }                                                                       \
                                                                            \
    HCTRL_STATE(hCtrl2, Enable, swIcon);                                    \
    HCTRL_SETCTRLDATA(hCtrl2, CTRLS_ECBICON, 0xFF);                         \
                                                                            \
    if (swIcon == SW_SHOW) {                                                \
                                                                            \
        SetIcon(_OI_HINST(pItem),                                           \
                hCtrl2,                                                     \
                IconResID,                                                  \
                MK_INTICONID(0, IconMode),                                  \
                (IS_TVDLG) ? pTVWnd->cxcyECBIcon : 32);                     \
    }                                                                       \
                                                                            \
    if (IS_ECB) {                                                           \
                                                                            \
        if (hCtrl2) {                                                       \
                                                                            \
            DWORD   dw = (DWORD)GetWindowLongPtr(hCtrl2, GWL_STYLE);        \
                                                                            \
            if ((swIcon == SW_SHOW) &&                                      \
                (Enable)            &&                                      \
                (InitFlags & INITCF_ENABLE)) {                              \
                                                                            \
                dw |= SS_NOTIFY;                                            \
                                                                            \
            } else {                                                        \
                                                                            \
                dw &= ~SS_NOTIFY;                                           \
            }                                                               \
                                                                            \
            SetWindowLongPtr(hCtrl2, GWL_STYLE, dw);                        \
        }                                                                   \
    }                                                                       \
                                                                            \
    return((BOOL)(swMode == SW_SHOW));                                      \
}


#if 0
static  const CHAR szShellDLL[]      = "shell32";
static  const CHAR szShellAbout[]    = "ShellAboutW";
#endif

static  const CHAR szHTUIClrAdj[]    = "HTUI_ColorAdjustmentW";
static  const CHAR szHTUIDevClrAdj[] = "HTUI_DeviceColorAdjustmentW";


BOOL
CALLBACK
SetUniqChildIDProc(
    HWND    hWnd,
    LPARAM  lParam
    )
{
    DWORD   dw;
    UINT    DlgID;


    if (GetWindowLongPtr(hWnd, GWLP_ID)) {

        CPSUIDBG(DBG_SCID, ("The hWnd=%08lx has GWLP_ID=%ld, CtrlID=%ld",
                hWnd, GetWindowLongPtr(hWnd, GWLP_ID), GetDlgCtrlID(hWnd)));

    } else {

        HWND        hCtrl;
        DLGIDINFO   DlgIDInfo = *(PDLGIDINFO)lParam;

        while (hCtrl = GetDlgItem(DlgIDInfo.hDlg, DlgIDInfo.CurID)) {

            CPSUIDBG(DBG_SCID, ("The ID=%ld is used by hCtrl=%08lx",
                                DlgIDInfo.CurID, hCtrl));

            --DlgIDInfo.CurID;
        }

        SetWindowLongPtr(hWnd, GWLP_ID, (LONG)DlgIDInfo.CurID);

        CPSUIDBG(DBG_SCID, ("The hWnd=%08lx, GWLP_ID set to %ld",
                            hWnd, DlgIDInfo.CurID));
    }

    return(TRUE);
}



VOID
SetUniqChildID(
    HWND    hDlg
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Nov-1995 Wed 15:40:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    DLGIDINFO   DlgIDInfo;

    DlgIDInfo.hDlg  = hDlg;
    DlgIDInfo.CurID = 0xFFFF;

    EnumChildWindows(hDlg, SetUniqChildIDProc, (LPARAM)&DlgIDInfo);
}




BOOL
hCtrlrcWnd(
    HWND    hDlg,
    HWND    hCtrl,
    RECT    *prc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    17-Sep-1995 Sun 07:34:41 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    if (hCtrl) {

        GetWindowRect(hCtrl, prc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)prc, 2);
        return(TRUE);

    } else {

        return(FALSE);
    }
}



HWND
CtrlIDrcWnd(
    HWND    hDlg,
    UINT    CtrlID,
    RECT    *prc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    17-Sep-1995 Sun 07:34:41 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hCtrl;

    if ((CtrlID) && (hCtrl = GetDlgItem(hDlg, CtrlID))) {

        GetWindowRect(hCtrl, prc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)prc, 2);

        return(hCtrl);

    } else {

        return(NULL);
    }
}




BOOL
ChkhWndEdit0KEYDOWN(
    HWND    hWnd,
    WPARAM  VKey
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-Aug-1998 Thu 11:13:41 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTVWND  pTVWnd;


    switch (VKey) {

    case VK_LEFT:
    case VK_BACK:
    case VK_RIGHT:

        if (pTVWnd = (PTVWND)GetProp(hWnd, CPSUIPROP_PTVWND)) {

            switch (VKey) {

            case VK_LEFT:
            case VK_BACK:

                if ((pTVWnd->hWndTV) &&
                    (GetDlgCtrlID(pTVWnd->hWndTV) == IDD_TV_WND)) {

                    SetFocus(pTVWnd->hWndTV);
                    return(TRUE);
                }

                break;

            case VK_RIGHT:

                if (hWnd = pTVWnd->hWndEdit[1]) {

                    SetFocus(hWnd);
                }

                return(TRUE);
            }
        }

        break;
    }

    return(FALSE);
}



LRESULT
CALLBACK
MyCBWndProc(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    This is the subclass WNDPROC for the numberical edit control, it check
    valid input for the number entered.


Arguments:

    WNDPROC standard


Return Value:

    INT (The original WNDPROC returned), if the entered keys are not valid
    then it return right away without processing


Author:

    20-Mar-1996 Wed 15:36:48 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hDlg;
    PTVWND      pTVWnd;
    HWND        hWndTV;
    LONG_PTR    SelIdx;
    WNDPROC     OldWndProc;


    if (OldWndProc = (WNDPROC)GetProp(hWnd, CPSUIPROP_WNDPROC)) {

        switch (Msg) {

        case WM_KEYDOWN:

            CPSUIDBG(DBG_CBWNDPROC,
                     ("MyCBWndProc: WM_KEYDOWN, VKey=%ld", wParam));

            if (SendMessage(hWnd, CB_GETDROPPEDSTATE, 0, 0)) {

                //
                // When user hit escape during the drop down box open AND
                // the selection did changed, then we post message to change
                // the selection back to original and post a selection
                // change message (POST since this will be done after CLOSEUP)
                //

                if ((wParam == VK_ESCAPE)                               &&
                    (SelIdx = (LONG_PTR)GetProp(hWnd, CPSUIPROP_CBPRESEL))  &&
                    ((SelIdx - 1) != SendMessage(hWnd, CB_GETCURSEL, 0, 0))) {

                    CPSUIDBG(DBG_CBWNDPROC,
                         ("MyCBWndProc: ESCAPE: Restore SEL from %ld to %ld",
                                (DWORD)SendMessage(hWnd, CB_GETCURSEL, 0, 0),
                                SelIdx - 1));

                    PostMessage(hWnd, CB_SETCURSEL, (WPARAM)(SelIdx - 1), 0L);
                    PostMessage(GetParent(hWnd),
                                WM_COMMAND,
                                MAKEWPARAM(GetDlgCtrlID(hWnd), CBN_SELCHANGE),
                                (LPARAM)hWnd);
                    break;
                }

            } else if (ChkhWndEdit0KEYDOWN(hWnd, wParam)) {

                return(0);
            }

            break;

        case WM_DESTROY:

            CPSUIDBG(DBG_CBWNDPROC, ("MyCBWndProc: WM_DESTROY"));

            SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LPARAM)OldWndProc);
            RemoveProp(hWnd, CPSUIPROP_WNDPROC);
            RemoveProp(hWnd, CPSUIPROP_PTVWND);
            RemoveProp(hWnd, CPSUIPROP_CBPRESEL);

            break;

        default:

            break;
        }

        return(CallWindowProc(OldWndProc, hWnd, Msg, wParam, lParam));

    } else {

        CPSUIERR(("MyCBWndProc: GetProc(%08lx) FAILED", hWnd));

        return(0);
    }
}



DWORD
ReCreateLBCB(
    HWND    hDlg,
    UINT    CtrlID,
    BOOL    IsLB
    )

/*++

Routine Description:

    This functon create a new listbox/combobox which has same control ID and
    size of the original one except with the owner draw item

Arguments:

    hDlg    - Handle to the dialog

    CtrlID  - The original control ID for the LB/CB

    IsLB    - True if this is a List box


Return Value:


    BOOL


Author:

    12-Sep-1995 Tue 00:23:17 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hLBCB;
    WORD    cxRet = 0;
    WORD    cyRet = 0;
    RECT    rc;


    if (hLBCB = CtrlIDrcWnd(hDlg, CtrlID, &rc)) {

        HWND    hNewLBCB;
        DWORD   dw;
        RECT    rcDrop;
        WORD    cxSize;
        WORD    cySize;
        BOOL    SetExtUI = FALSE;


        CPSUIDBG(DBG_CLBCB, ("Dropped=(%ld, %ld)-(%ld, %ld), %ld x %ld",
                            rc.left, rc.top, rc.right, rc.bottom,
                            rc.right - rc.left, rc.bottom - rc.top));

        dw = (DWORD)(GetWindowLongPtr(hLBCB, GWL_STYLE) |
                     (WS_VSCROLL | WS_GROUP | WS_TABSTOP | WS_BORDER));

        if ((!IsLB) && (dw & (CBS_DROPDOWNLIST | CBS_DROPDOWN))) {

            SetExtUI = TRUE;

            CPSUIDBG(DBG_TMP, ("Original CB Edit CY=%ld",
                                (LONG)SendMessage(hLBCB,
                                                  CB_GETITEMHEIGHT,
                                                  (WPARAM)-1,
                                                  0)));

            SendMessage(hLBCB, CB_SETEXTENDEDUI, (WPARAM)TRUE, 0L);
            SendMessage(hLBCB, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)&rcDrop);

            CPSUIDBG(DBG_CLBCB, ("Dropped=(%ld, %ld)-(%ld, %ld), %ld x %ld",
                    rcDrop.left, rcDrop.top, rcDrop.right, rcDrop.bottom,
                    rcDrop.right - rcDrop.left, rcDrop.bottom - rcDrop.top));

            rc.bottom += (rcDrop.bottom - rcDrop.top) * 2;
        }

        cxSize = (WORD)(rc.right - rc.left);
        cySize = (WORD)(rc.bottom - rc.top);

        CPSUIDBG(DBG_CLBCB, ("%ws: cxSize=%ld, cySize=%ld",
                (IsLB) ? L"ListBox" : L"ComboBox", cxSize, cySize));

        if (IsLB) {

            dw &= ~LBS_OWNERDRAWVARIABLE;
            dw |= (LBS_OWNERDRAWFIXED       |
                    LBS_HASSTRINGS          |
                    LBS_SORT                |
                    LBS_NOINTEGRALHEIGHT);

        } else {

            dw &= ~(CBS_OWNERDRAWVARIABLE | CBS_NOINTEGRALHEIGHT);
            dw |= (CBS_OWNERDRAWFIXED | CBS_HASSTRINGS | CBS_SORT);
        }

        CPSUIDBG(DBG_CLBCB, ("dwStyle=%08lx", dw));

        if (hNewLBCB = CreateWindowEx(WS_EX_NOPARENTNOTIFY | WS_EX_CLIENTEDGE,
                                      (IsLB) ? L"listbox" : L"combobox",
                                      L"",
                                      dw | WS_CHILD | WS_TABSTOP | WS_GROUP,
                                      rc.left,
                                      rc.top,
                                      rc.right - rc.left,
                                      cySize,
                                      hDlg,
                                      (HMENU)UIntToPtr(CtrlID),
                                      hInstDLL,
                                      0)) {

            SetWindowPos(hNewLBCB,
                         hLBCB,
                         0, 0, 0, 0,
                         SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);

            SendMessage(hNewLBCB,
                        WM_SETFONT,
                        (WPARAM)SendMessage(hLBCB, WM_GETFONT, 0, 0),
                        TRUE);

            if (SetExtUI) {

                SendMessage(hNewLBCB, CB_SETEXTENDEDUI, (WPARAM)TRUE, 0L);
            }

            DestroyWindow(hLBCB);

            if ((hLBCB = GetDlgItem(hDlg, CtrlID)) == hNewLBCB) {

                cxRet = (WORD)((GetSystemMetrics(SM_CXFIXEDFRAME) * 2) +
                               (GetSystemMetrics(SM_CXEDGE      ) * 2) +
                               (GetSystemMetrics(SM_CXVSCROLL)));

                CPSUIDBG(DBG_CLBCB, ("SM_CXFIXEDFRAME=%ld, SM_CXEDGE=%ld, SM_CXVSCROLL=%ld",
                            GetSystemMetrics(SM_CXFIXEDFRAME),
                            GetSystemMetrics(SM_CXEDGE      ),
                            GetSystemMetrics(SM_CXVSCROLL)));

                if (!IsLB) {

                    WNDPROC OldWndProc;

                    OldWndProc = (WNDPROC)GetWindowLongPtr(hLBCB, GWLP_WNDPROC);

                    if ((ULONG_PTR)OldWndProc != (ULONG_PTR)MyCBWndProc) {

                        SetProp(hLBCB, CPSUIPROP_WNDPROC, (HANDLE)OldWndProc);
                        SetProp(hLBCB,
                                CPSUIPROP_PTVWND,
                                (HANDLE)GET_PTVWND(hDlg));
                        SetWindowLongPtr(hLBCB,
                                         GWLP_WNDPROC,
                                         (LPARAM)MyCBWndProc);
                    }
                }

                cyRet  = cySize;

            } else {

                CPSUIASSERT(0, "Newly Create LBCB's ID=%08lx is different",
                                            hLBCB == hNewLBCB, UIntToPtr(CtrlID));
            }

        } else {

            CPSUIERR(("CreateLBCB: CreateWindowEx() FAILED"));
        }

    } else {

        CPSUIERR(("CreateLBCB: GetDlgItem() failed"));
    }

    return((DWORD)MAKELONG(cxRet, cyRet));
}




HWND
CreateTrackBar(
    HWND    hDlg,
    UINT    TrackBarID
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Aug-1995 Thu 19:43:08 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hCtrl;
    HWND    hTrackBar;
    RECT    rc;


    //
    // Create TrackBar Control
    //

    if (hCtrl = CtrlIDrcWnd(hDlg, TrackBarID, &rc)) {

        CPSUIDBG(DBG_CTB,
                ("\nCreate TrackBar Control=%ld, rc=(%ld, %ld) - (%ld, %ld)",
                            TrackBarID, rc.left, rc.top, rc.right, rc.bottom));

        if (hTrackBar = CreateWindowEx(0,
                                       TRACKBAR_CLASS,
                                       L"",
                                       WS_VISIBLE           |
                                            WS_CHILD        |
                                            WS_TABSTOP      |
                                            WS_GROUP        |
                                            TBS_AUTOTICKS,
                                       rc.left,
                                       rc.top,
                                       rc.right - rc.left,
                                       rc.bottom - rc.top,
                                       hDlg,
                                       (HMENU)UIntToPtr(TrackBarID),
                                       hInstDLL,
                                       0)) {

            SetWindowPos(hTrackBar,
                         hCtrl,
                         0, 0, 0, 0,
                         SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);

            DestroyWindow(hCtrl);

            SetWindowLongPtr(hTrackBar, GWLP_ID, (LONG)TrackBarID);

            hCtrl = GetDlgItem(hDlg, TrackBarID);

            CPSUIINT(("hDlg=%08lx, hTrackBar=%08lx, TrackBarID=%08lx",
                            hDlg, hTrackBar, hCtrl));
        }
#if 0
        HCTRL_SETCTRLDATA(hCtrl, CTRLS_NOINPUT, 0);
        ShowWindow(hCtrl, SW_HIDE);
        EnableWindow(hCtrl, FALSE);
#endif
        return(hTrackBar);

    } else {

        return(NULL);
    }
}




BOOL
ChkEditKEYDOWN(
    HWND    hWnd,
    WPARAM  VKey
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-Aug-1998 Thu 10:56:21 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTVWND  pTVWnd;
    LONG    SelBeg;
    LONG    SelEnd;


    switch (VKey) {

    case VK_LEFT:
    case VK_BACK:
    case VK_RIGHT:

        SelEnd = (LONG)SendMessage(hWnd, EM_GETSEL, 0, 0);
        SelBeg = (LONG)LOWORD(SelEnd);
        SelEnd = (LONG)HIWORD(SelEnd);

        CPSUIDBG(DBG_CBWNDPROC,
                 ("ChkEditKEYDOWN: WM_KEYDOWN, VKey=%ld, Sel=%ld-%ld, Len=%ld",
                        VKey, SelBeg, SelEnd, GetWindowTextLength(hWnd)));

        if ((SelBeg == SelEnd)  &&
            (pTVWnd = (PTVWND)GetProp(hWnd, CPSUIPROP_PTVWND))) {

            switch (VKey) {

            case VK_LEFT:
            case VK_BACK:

                //
                // If already at position 0, and a left key go back to
                // treeview
                //

                if ((!SelBeg)   &&
                    (pTVWnd->hWndTV) &&
                    (GetDlgCtrlID(pTVWnd->hWndTV) == IDD_TV_WND)) {

                    SetFocus(pTVWnd->hWndTV);
                    return(TRUE);
                }

                break;

            case VK_RIGHT:

                //
                // If already at end position and there is a extended checkbox
                // or extended push then move a right key move to it
                //

                if ((pTVWnd->hWndEdit[1]) &&
                    (SelEnd == (LONG)GetWindowTextLength(hWnd))) {

                    SetFocus(pTVWnd->hWndEdit[1]);
                    return(TRUE);
                }

                break;
            }
        }
    }

    return(FALSE);
}





LRESULT
CALLBACK
CPSUIUDArrowWndProc(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    This is the subclass WNDPROC for the numberical edit control, it check
    valid input for the number entered.


Arguments:

    WNDPROC standard


Return Value:

    INT (The original WNDPROC returned), if the entered keys are not valid
    then it return right away without processing


Author:

    20-Mar-1996 Wed 15:36:48 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    WNDPROC OldWndProc;
    WCHAR   wch;
    DWORD   dw;
    LONG    SelBegIdx;
    LONG    SelEndIdx;
    WORD    InitItemIdx;
    BYTE    CtrlData;
    BYTE    CtrlStyle;


    if (OldWndProc = (WNDPROC)GetProp(hWnd, CPSUIPROP_WNDPROC)) {

        CPSUIDBG(DBG_VALIDATE_UD,
                 ("CPSUIUDArrowWndProc: hWnd=%08lx, OldWndProc=%08lx",
                    hWnd, OldWndProc));

        switch (Msg) {

        case WM_KEYDOWN:

            if (ChkEditKEYDOWN(hWnd, (DWORD)wParam)) {

                return(0);
            }

            break;

        case WM_CHAR:

            wch = (WCHAR)wParam;
            dw  = (DWORD)GetWindowLongPtr(hWnd, GWLP_USERDATA);

            GETCTRLDATA(dw, InitItemIdx, CtrlStyle, CtrlData);

            SendMessage(hWnd, EM_GETSEL, (WPARAM)&SelBegIdx, (LPARAM)&SelEndIdx);
            CPSUIDBG(DBG_VALIDATE_UD,
                     ("WM_CHAR=0x%04lx, ItemIdx=%u, Style=0x%02lx, Data=0x%02lx (%ld, %ld)",
                                wch, InitItemIdx, CtrlStyle, CtrlData,
                                SelBegIdx, SelEndIdx));

            CtrlData &= EDF_STATIC_MASK;
            CtrlData |= (BYTE)(SelBegIdx & EDF_BEGIDXMASK);

            if (wch < L' ') {

                if (wch == 0x08) {

                    CtrlData |= EDF_BACKSPACE;
                }

            } else if (((wch == L'-') && (CtrlData & EDF_MINUS_OK)) ||
                       ((wch >= L'0') && (wch <= L'9'))) {

                WCHAR   SelBuf[MAX_UDARROW_TEXT_LEN+1];
                WCHAR   LastCh;
                LONG    Len;

                Len    = (LONG)GetWindowText(hWnd, SelBuf, ARRAYSIZE(SelBuf));
                LastCh = (SelEndIdx >= Len) ? L'\0' : SelBuf[SelEndIdx];

                if ((SelBegIdx == 0) && (LastCh == L'-')) {

                    wch = 0;

                } else if (wch == L'-') {

                    if (SelBegIdx) {

                        wch = 0;
                    }

                } else if (wch == L'0') {

                    if (LastCh) {

                        if (((SelBegIdx == 1) && (SelBuf[0] == L'-'))   ||
                            ((SelBegIdx == 0) && (LastCh != L'-'))) {

                            wch = 0;
                        }
                    }
                }

                if ((wch >= L'0') && (wch <= L'9')) {

                    CtrlData |= EDF_NUMBERS;
                }

            } else {

                wch = 0;
            }

            SETCTRLDATA(hWnd, CtrlStyle, CtrlData);

            if (!wch) {

                MessageBeep(MB_ICONHAND);
                return(0);
            }

            break;

        case WM_DESTROY:

            CPSUIDBG(DBG_VALIDATE_UD, ("UDArrow: WM_DESTROY"));

            SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LPARAM)OldWndProc);
            RemoveProp(hWnd, CPSUIPROP_WNDPROC);
            RemoveProp(hWnd, CPSUIPROP_PTVWND);

            break;

        default:

            break;
        }

        return(CallWindowProc(OldWndProc, hWnd, Msg, wParam, lParam));

    } else {

        CPSUIERR(("CPSUIUDArrowWndProc: GetProc(%08lx) FAILED", hWnd));

        return(0);
    }
}



HWND
CreateUDArrow(
    HWND    hDlg,
    UINT    EditBoxID,
    UINT    UDArrowID,
    LONG    RangeL,
    LONG    RangeH,
    LONG    Pos
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Aug-1995 Thu 18:55:07 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hUDArrow;
    HWND    hCtrl;
    RECT    rc;
    WNDPROC OldWndProc;


    if (hCtrl = CtrlIDrcWnd(hDlg, EditBoxID, &rc)) {

        if (Pos < RangeL) {

            Pos = RangeL;

        } else if (Pos > RangeH) {

            Pos = RangeH;
        }

        CPSUIDBG(DBG_CUDA, ("CreateUDArrow Window, rc=(%ld, %ld) - (%ld, %ld), Range=%ld-%ld (%ld)",
                            rc.left, rc.top, rc.right, rc.bottom,
                            RangeL, RangeH, Pos));

        if (hUDArrow = CreateUpDownControl(WS_BORDER        |
                                            WS_CHILD        |
                                            WS_TABSTOP      |
                                            WS_GROUP        |
                                            UDS_ARROWKEYS   |
                                            UDS_NOTHOUSANDS |
                                            UDS_ALIGNRIGHT  |
                                            UDS_SETBUDDYINT,
                                           rc.right,
                                           rc.top,
                                           rc.bottom - rc.top,
                                           rc.bottom - rc.top,
                                           hDlg,
                                           UDArrowID,
                                           hInstDLL,
                                           hCtrl,
                                           (INT)RangeH,
                                           (INT)RangeL,
                                           (INT)Pos)) {

            SetWindowLongPtr(hUDArrow,
                             GWL_EXSTYLE,
                             GetWindowLongPtr(hUDArrow, GWL_EXSTYLE) |
                                  WS_EX_NOPARENTNOTIFY | WS_EX_CONTEXTHELP);

            SetWindowPos(hUDArrow,
                         hCtrl,
                         0, 0, 0, 0,
                         SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);

            SendMessage(hUDArrow, UDM_SETBASE, (WPARAM)10, 0L);

            OldWndProc = (WNDPROC)GetWindowLongPtr(hCtrl, GWLP_WNDPROC);

            if ((ULONG_PTR)OldWndProc != (ULONG_PTR)CPSUIUDArrowWndProc) {

                SetProp(hCtrl, CPSUIPROP_WNDPROC, (HANDLE)OldWndProc);
                SetProp(hCtrl, CPSUIPROP_PTVWND, (HANDLE)GET_PTVWND(hDlg));
                SetWindowLongPtr(hCtrl,
                                 GWLP_WNDPROC,
                                 (LPARAM)CPSUIUDArrowWndProc);

                CPSUIDBG(DBG_VALIDATE_UD, ("hUDArrow=%08lx: Save OldWndProc=%08lx",
                                    hUDArrow, OldWndProc));
            }
        }

        return(hUDArrow);

    } else {

        return(NULL);
    }
}




BOOL
SetDlgPageItemName(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem,
    UINT        InitFlags,
    UINT        UDArrowHelpID
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    19-Sep-1995 Tue 18:29:44 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hCtrl = NULL;
    POPTTYPE    pOptType;
    UINT        TitleID;
    BOOL        AddItemSep;
    GSBUF_DEF(pItem, MAX_RES_STR_CHARS * 2);


    if (pOptType = GET_POPTTYPE(pItem)) {

        GSBUF_FLAGS |= GBF_PREFIX_OK;

        if ((TitleID = pOptType->BegCtrlID)      &&
            (hCtrl = GetDlgItem(hDlg, TitleID))) {

            if (pItem->Flags & OPTIF_NO_GROUPBOX_NAME) {

                //
                // If we don't display the group name for TitleID and TitleID 
                // exists in the page, we will enable/disable the group box 
                // depending on InitFlag value. This is mainly for the "Tray 
                // Selection" group, since it has both TitleID and TitleID + 1 
                // in the page.
                //
                SHOWCTRL(hCtrl, TRUE, SW_SHOW);
                AddItemSep = TRUE;
                hCtrl      = GetDlgItem(hDlg, TitleID + 1);

            } else {

                AddItemSep = FALSE;
            }

        } else {

            AddItemSep = TRUE;
            hCtrl      = GetDlgItem(hDlg, TitleID + 1);
        }

        if (hCtrl) {

            POPTPARAM   pOptParam = pOptType->pOptParam;


            //
            // Get the name first, and add in the seperator add needed
            //

            GSBUF_GETSTR(pItem->pName);

            if (InitFlags & INITCF_ADDSELPOSTFIX) {

                GSBUF_GETSTR(IDS_CPSUI_COLON_SEP);
                GSBUF_ADDNUM(pItem->Sel, TRUE);

                if (!(pOptType->Flags & OPTTF_NOSPACE_BEFORE_POSTFIX)) {

                    GSBUF_ADD_SPACE(1);
                }

                GSBUF_GETSTR(pOptParam[0].pData);

            } else if (AddItemSep) {

                GSBUF_GETSTR(IDS_CPSUI_COLON_SEP);
            }

            //
            // If we have the UDARROW Help ID and it does not have control
            // associated it then put the range on the title bar
            //

            if ((UDArrowHelpID) && (!GetDlgItem(hDlg, UDArrowHelpID))) {

                GSBUF_ADD_SPACE(2);

                if (pOptParam[1].pData) {

                    GSBUF_GETSTR(pOptParam[1].pData);

                } else {

                    GSBUF_COMPOSE(IDS_INT_CPSUI_RANGE,
                                  NULL,
                                  pOptParam[1].IconID,
                                  pOptParam[1].lParam);
                }
            }

            //
            // We actually don't want the title enabled because we end up having this problem
            // with the shortcuts. When you have a shortcut to a static label (let's say
            // "Page&s Per Sheet") and you hit Alt-S, but the control this caption is
            // referring to is disabled then the focus goes into the next enabled control
            // in the tab order which has the WS_TABSTOP bit up (in out case this is the
            // "Advanced" button. We don't want this behavior.
            //

            // InitFlags |= INITCF_ENABLE;

            SetWindowText(hCtrl, (LPCTSTR)GSBUF_BUF);
            SHOWCTRL(hCtrl, TRUE, SW_SHOW);

            return(TRUE);
        }
    }

    return(FALSE);
}


#if (DO_IN_PLACE == 0)


VOID
SetPushSize(
    PTVWND  pTVWnd,
    HWND    hPush,
    LPWSTR  pPushText,
    UINT    cPushText,
    UINT    SPSFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    02-Nov-1995 Thu 12:25:49 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hExtPush;
    HDC     hDC;
    HGDIOBJ hOld;
    SIZE    szl;
    LONG    xAdd;
    RECT    rc;

    //
    // Adjust the size of push button
    //

    hOld = SelectObject(hDC = GetWindowDC(hPush),
                        (HANDLE)SendMessage(hPush, WM_GETFONT, 0, 0L));

    GetTextExtentPoint32(hDC, L"W", 1, &szl);
    LPtoDP(hDC, (LPPOINT)&szl, 1);
    xAdd = szl.cx * PUSH_CX_EXTRA_W;

    GetTextExtentPoint32(hDC, pPushText, cPushText, &szl);
    LPtoDP(hDC, (LPPOINT)&szl, 1);

    SelectObject(hDC, hOld);
    ReleaseDC(hPush, hDC);

    hCtrlrcWnd(pTVWnd->hDlgTV, hPush, &rc);

    szl.cx += xAdd;
    szl.cy  = (SPSFlags & SPSF_USE_BUTTON_CY) ? rc.bottom - rc.top :
                                                (szl.cy + PUSH_CY_EXTRA);

    CPSUIINT(("SetPushSize: Text=%ld x %ld, xAdd=%ld, Push=%ld x %ld",
                szl.cx - xAdd, szl.cy, xAdd, szl.cx, szl.cy));

    if ((SPSFlags & SPSF_ALIGN_EXTPUSH)                         &&
        (hExtPush = GetDlgItem(pTVWnd->hDlgTV, IDD_TV_EXTPUSH)) &&
        (hCtrlrcWnd(pTVWnd->hDlgTV, hExtPush, &rc))) {

        if ((xAdd = rc.right - rc.left) > szl.cx) {

            //
            // Increase the CX of the push button
            //

            CPSUIINT(("SetPushSize: Adjust PUSH equal to ExtPush (%ld)", xAdd));

            szl.cx = xAdd;

        } else if (xAdd < szl.cx) {

            //
            // Ext PUSH's CX is smaller, increase the cx
            //

            CPSUIINT(("SetPushSize: Adjust ExtPush equal to PUSH (%ld)", szl.cx));

            SetWindowPos(hExtPush, NULL,
                         0, 0,
                         szl.cx, rc.bottom - rc.top,
                         SWP_NOMOVE | SWP_NOZORDER |
                         SWP_FRAMECHANGED | SWP_DRAWFRAME);
        }
    }

    SetWindowPos(hPush, NULL, 0, 0, szl.cx, szl.cy,
                 SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);
}

#endif


BOOL
InitExtPush(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        ExtChkBoxID,
    UINT        ExtPushID,
    UINT        ExtIconID,
    WORD        InitItemIdx,
    WORD        InitFlags
    )

/*++

Routine Description:

    This fucntion initialize the extended check box, and if will not allowed
    a item to be udpated if TWF_CAN_UPDATE is clear


Arguments:




Return Value:




Author:

    28-Aug-1995 Mon 21:01:35 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hCtrl;


    if ((InitFlags & INITCF_INIT)   &&
        (ExtChkBoxID)               &&
        (ExtChkBoxID != ExtPushID)  &&
        (hCtrl = GetDlgItem(hDlg, ExtChkBoxID))) {

        EnableWindow(hCtrl, FALSE);
        ShowWindow(hCtrl, SW_HIDE);
    }

    if ((ExtPushID) &&
        (hCtrl =  GetDlgItem(hDlg, ExtPushID))) {

        HWND        hCtrl2;
        PEXTPUSH    pEP;
        BOOL        Enable = FALSE;
        UINT        swMode = SW_SHOW;
        BYTE        CtrlData;
        ULONG_PTR   IconResID = 0;
        WORD        IconMode = 0;
        GSBUF_DEF(pItem, MAX_RES_STR_CHARS);

#if DO_IN_PLACE
        if (!IS_TVDLG) {
#else
        {
#endif
            GSBUF_FLAGS |= GBF_PREFIX_OK;
        }

        if (pItem == PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT)) {

            InitFlags |= INITCF_ENABLE;

        } else if (!(pTVWnd->Flags & TWF_CAN_UPDATE)) {

            InitFlags &= ~INITCF_ENABLE;
        }

        if ((!(pEP = pItem->pExtPush))   ||
            // (!(pItem->pOptType))            ||
            (pItem->Flags & (OPTIF_HIDE | OPTIF_EXT_HIDE))) {

            swMode = SW_HIDE;

        } else if (!(pItem->Flags & (OPTIF_HIDE | OPTIF_EXT_DISABLED))) {

            Enable = TRUE;
        }

#if DO_IN_PLACE
        pTVWnd->hWndEdit[1] = ((IS_TVDLG)  && (swMode == SW_SHOW)) ? hCtrl :
                                                                     NULL;
#endif
        CtrlData = (BYTE)((pEP->Flags & EPF_PUSH_TYPE_DLGPROC) ? 1 : 0);
        HCTRL_SETCTRLDATA(hCtrl,  CTRLS_EXTPUSH, CtrlData);
        HCTRL_STATE(hCtrl,  Enable, swMode);

        if ((InitFlags & INITCF_INIT) && (pEP)) {

            if (pEP == &ExtPushAbout) {

                GSBUF_COMPOSE(IDS_INT_CPSUI_ABOUT,
                              pTVWnd->ComPropSheetUI.pCallerName,
                              0,
                              0);

            } else {

                if (pEP->Flags & EPF_INCL_SETUP_TITLE) {

                    GSBUF_COMPOSE(IDS_INT_CPSUI_SETUP, pEP->pTitle, 0, 0);

                } else {

                    GSBUF_GETSTR(pEP->pTitle);
                }
            }

            if (!(pEP->Flags & EPF_NO_DOT_DOT_DOT)) {

                GSBUF_GETSTR(IDS_CPSUI_MORE);
            }

            if (IS_TVDLG) {

                SIZEL   szlText;

                //
                // Adjust the size of push button
                //

#if DO_IN_PLACE
                szlText.cx = 0;

                GetTextExtentPoint(pTVWnd->hDCTVWnd,
                                   GSBUF_BUF,
                                   GSBUF_COUNT,
                                   &szlText);

                _OI_CXEXT(pItem)    = (WORD)szlText.cx +
                                      (WORD)(pTVWnd->cxSpace * 4);
                _OI_CYEXTADD(pItem) = 0;
#else
                SetPushSize(pTVWnd,
                            hCtrl,
                            GSBUF_BUF,
                            GSBUF_COUNT,
                            SPSF_USE_BUTTON_CY);
#endif
            }

            SetWindowText(hCtrl, GSBUF_BUF);
        }

#if DO_IN_PLACE
        if (IS_TVDLG) {

            return((BOOL)(swMode == SW_SHOW));
        }
#endif
        if (pEP) {

            if (pEP->Flags & EPF_OVERLAY_WARNING_ICON) {

                IconMode |= MIM_WARNING_OVERLAY;
            }

            if (pEP->Flags & EPF_OVERLAY_STOP_ICON) {

                IconMode |= MIM_STOP_OVERLAY;
            }

            if (pEP->Flags & EPF_OVERLAY_NO_ICON) {

                IconMode |= MIM_NO_OVERLAY;
            }

            IconResID = GET_ICONID(pEP, EPF_ICONID_AS_HICON);
        }

        SET_EXTICON(TRUE);

    } else {

        return(FALSE);
    }
}





BOOL
InitExtChkBox(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        ExtChkBoxID,
    UINT        ExtPushID,
    UINT        ExtIconID,
    WORD        InitItemIdx,
    WORD        InitFlags
    )

/*++

Routine Description:

    This fucntion initialize the extended check box, and if will not allowed
    a item to be udpated if TWF_CAN_UPDATE is clear


Arguments:




Return Value:




Author:

    28-Aug-1995 Mon 21:01:35 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hCtrl;


    if ((InitFlags & INITCF_INIT)   &&
        (ExtPushID)                 &&
        (ExtPushID != ExtChkBoxID)  &&
        (hCtrl = GetDlgItem(hDlg, ExtPushID))) {

        EnableWindow(hCtrl, FALSE);
        ShowWindow(hCtrl, SW_HIDE);
    }

    if ((ExtChkBoxID) &&
        (hCtrl = GetDlgItem(hDlg, ExtChkBoxID))) {

        HWND        hCtrl2;
        PEXTCHKBOX  pECB;
        BOOL        Enable = FALSE;
        UINT        swMode = SW_SHOW;
        ULONG_PTR   IconResID = 0;
        WORD        IconMode = 0;
        GSBUF_DEF(pItem, MAX_RES_STR_CHARS);


#if DO_IN_PLACE
        if (!IS_TVDLG) {
#else
        {
#endif
            GSBUF_FLAGS |= GBF_PREFIX_OK;
        }

        if (pItem == PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT)) {

            InitFlags |= INITCF_ENABLE;

        } else if (!(pTVWnd->Flags & TWF_CAN_UPDATE)) {

            InitFlags &= ~INITCF_ENABLE;
        }

        if ((!(pECB = pItem->pExtChkBox))   ||
            // (!(pItem->pOptType))            ||
            (pItem->Flags & (OPTIF_HIDE | OPTIF_EXT_HIDE))) {

            swMode = SW_HIDE;

        } else if (!(pItem->Flags & OPTIF_EXT_DISABLED)) {

            Enable = TRUE;
        }

#if DO_IN_PLACE
        pTVWnd->hWndEdit[1] = ((IS_TVDLG)  && (swMode == SW_SHOW)) ? hCtrl :
                                                                     NULL;
#endif
        HCTRL_SETCTRLDATA(hCtrl,  CTRLS_EXTCHKBOX, 0);
        HCTRL_STATE(hCtrl,  Enable, swMode);

        if ((InitFlags & INITCF_INIT) && (pECB)) {

            LPTSTR  pTitle;


            if (!(pTitle = pECB->pCheckedName)) {

                pTitle = pECB->pTitle;
            }

            HCTRL_TEXT(hCtrl, pTitle);

#if DO_IN_PLACE
            if (IS_TVDLG) {

                SIZEL   szlText;

                szlText.cx = 0;

                GSBUF_FLAGS &= ~GBF_PREFIX_OK;
                GSBUF_RESET;
                GSBUF_GETSTR(pTitle);

                szlText.cy = (LONG)GSBUF_COUNT;
                pTitle     = &GSBUF_BUF[szlText.cy - 1];

                while (*pTitle == L' ') {

                    --pTitle;
                    --szlText.cy;
                }

                pTitle = GSBUF_BUF;

                while (*pTitle == L' ') {

                    ++pTitle;
                    --szlText.cy;
                }

                GetTextExtentPoint(pTVWnd->hDCTVWnd,
                                   pTitle,
                                   szlText.cy,
                                   &szlText);

                CPSUIINT(("ExtChkBox: '%ws' = %ld", GSBUF_BUF, szlText.cx));

                _OI_CXEXT(pItem)    = (WORD)szlText.cx +
                                      (WORD)GetSystemMetrics(SM_CXSMICON) +
                                      (WORD)pTVWnd->cxSpace * 2;
                _OI_CYEXTADD(pItem) = 0;
            }
#endif
        }

        CheckDlgButton(hDlg,
                       ExtChkBoxID,
                       (pItem->Flags & OPTIF_ECB_CHECKED) ? BST_CHECKED :
                                                            BST_UNCHECKED);
#if DO_IN_PLACE
        if (IS_TVDLG) {

            return((BOOL)(swMode == SW_SHOW));
        }
#endif
        if (pECB) {

            if (pECB->Flags & ECBF_OVERLAY_WARNING_ICON) {

                IconMode |= MIM_WARNING_OVERLAY;
            }

            if (pECB->Flags & ECBF_OVERLAY_STOP_ICON) {

                IconMode |= MIM_STOP_OVERLAY;
            }

            if (pECB->Flags & ECBF_OVERLAY_NO_ICON) {

                IconMode |= MIM_NO_OVERLAY;
            }

            IconResID = GET_ICONID(pECB, ECBF_ICONID_AS_HICON);
        }

        SET_EXTICON(TRUE);

    } else {

        return(FALSE);
    }
}



UINT
InitStates(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    POPTTYPE    pOptType,
    UINT        IDState1,
    WORD        InitItemIdx,
    LONG        NewSel,
    WORD        InitFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Aug-1995 Thu 20:16:29 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hCtrl;
    HWND        hCtrlIcon;
    POPTPARAM   pOP;
    UINT        CtrlID;
    UINT        i;
    UINT        MaxStates;

    MaxStates = (UINT)(pOptType->Count - 1);

    if (InitFlags & INITCF_INIT) {

        for (i = 0, CtrlID = IDState1, pOP = pOptType->pOptParam;
             i <= (UINT)MaxStates;
             i++, CtrlID += 2, pOP++) {

            INT     swMode;
            BOOL    Enable;
            GSBUF_DEF(pItem, MAX_RES_STR_CHARS);


            GSBUF_FLAGS |= GBF_PREFIX_OK;

            //
            // All the radio hide button already hided
            //

            if (pOP->Flags & OPTPF_HIDE) {

                CPSUIASSERT(0, "2/3 States %d: 'Sel' item is OPTPF_HIDE",
                                            NewSel != (LONG)i, UIntToPtr(i + 1));

                if (NewSel == (LONG)i) {

                    if (++NewSel > (LONG)MaxStates) {

                        NewSel = 0;
                    }
                }

            } else {

                hCtrl = NULL;

                if (CtrlID) {

                    hCtrl = GetDlgItem(hDlg, CtrlID);
                }

                hCtrlIcon = GetDlgItem(hDlg, CtrlID + 1);

                if (hCtrl) {

                    HCTRL_SETCTRLDATA(hCtrl, CTRLS_RADIO, i);

                    if (InitFlags & INITCF_INIT) {

                        HCTRL_TEXT(hCtrl, pOP->pData);
                    }

                    Enable = !(BOOL)(pOP->Flags & OPTPF_DISABLED);

                    HCTRL_STATE(hCtrl,
                                !(BOOL)(pOP->Flags & OPTPF_DISABLED),
                                SW_SHOW);
                }

                HCTRL_STATE(hCtrlIcon, TRUE,  SW_SHOW);
            }
        }
    }

    CheckRadioButton(hDlg,
                     IDState1,
                     IDState1 + (WORD)(MaxStates << 1),
                     IDState1 + (DWORD)(NewSel << 1));

    return(NewSel);
}




LONG
InitUDArrow(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    POPTPARAM   pOptParam,
    UINT        UDArrowID,
    UINT        EditBoxID,
    UINT        PostfixID,
    UINT        HelpID,
    WORD        InitItemIdx,
    LONG        NewPos,
    WORD        InitFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Aug-1995 Thu 18:55:07 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hUDArrow;
    HWND    hEdit;
    HWND    hCtrl;
    DWORD   dw;
    LONG    Range[2];
    BYTE    CtrlData;
    GSBUF_DEF(pItem, MAX_RES_STR_CHARS * 2);

    //
    // Create Up/Down Control
    //

    GSBUF_FLAGS |= GBF_PREFIX_OK;

    hUDArrow = (UDArrowID) ? GetDlgItem(hDlg, UDArrowID) : NULL;
    hEdit    = (EditBoxID) ? GetDlgItem(hDlg, EditBoxID) : NULL;

    if ((!hUDArrow) || (!hEdit)) {

        return(ERR_CPSUI_CREATE_UDARROW_FAILED);
    }

    Range[0] = (LONG)pOptParam[1].IconID;
    Range[1] = (LONG)pOptParam[1].lParam;

    if (NewPos < Range[0]) {

        NewPos = Range[0];

    } else if (NewPos > Range[1]) {

        NewPos = Range[1];
    }

    if (InitFlags & INITCF_SETCTRLDATA) {

        CtrlData = ((Range[0] < 0) || (Range[1] < 0)) ? EDF_MINUS_OK : 0;

        if (IS_TVDLG) {

            CtrlData |= EDF_IN_TVPAGE;
        }

        HCTRL_SETCTRLDATA(hEdit, CTRLS_UDARROW_EDIT, CtrlData);
        HCTRL_SETCTRLDATA(hUDArrow, CTRLS_UDARROW, CtrlData);
    }


    if (InitFlags & INITCF_INIT) {

        RECT    rc;

#if DO_IN_PLACE
        PostfixID =
        HelpID    = 0;
#endif
        HCTRL_STATE(hEdit,    FALSE, SW_HIDE);
        HCTRL_STATE(hUDArrow, FALSE, SW_HIDE);

        if ((PostfixID) && (hCtrl = GetDlgItem(hDlg, PostfixID))) {

            GSBUF_RESET;
            GSBUF_GETSTR(pOptParam[0].pData);

            SetWindowText(hCtrl, GSBUF_BUF);
            HCTRL_STATE(hCtrl, TRUE, SW_SHOW);
        }

        if ((HelpID) && (hCtrl = GetDlgItem(hDlg, HelpID))) {

            GSBUF_RESET;

            if (pOptParam[1].pData) {

                GSBUF_GETSTR(pOptParam[1].pData);

            } else {

                GSBUF_COMPOSE(IDS_INT_CPSUI_RANGE,
                              NULL,
                              Range[0],
                              Range[1]);
            }

            SetWindowText(hCtrl, GSBUF_BUF);
            HCTRL_STATE(hCtrl, TRUE, SW_SHOW);
        }

        //
        // Set the style so that it only take numbers v4.0 or later
        //

        SetWindowLongPtr(hEdit,
                         GWL_STYLE,
                         GetWindowLong(hEdit, GWL_STYLE) | ES_NUMBER);

        //
        // Set the UD arrow edit control to maximum 7 characters
        //

        SendMessage(hEdit, EM_SETLIMITTEXT, MAX_UDARROW_TEXT_LEN, 0L);

#if DO_IN_PLACE
        if ((IS_TVDLG) &&
            (TreeView_GetItemRect(pTVWnd->hWndTV,
                                  _OI_HITEM(pItem),
                                  &rc,
                                  TRUE))) {

            LONG    OrgL;

            pTVWnd->ptCur.x = rc.left;
            pTVWnd->ptCur.y = rc.top;

            OrgL     = rc.right;
            rc.left  = rc.right + pTVWnd->cxSelAdd;
            rc.right = rc.left + pTVWnd->cxMaxUDEdit;

            SetWindowPos(pTVWnd->hWndEdit[0] = hEdit,
                         NULL,
                         rc.left,
                         rc.top,
                         rc.right - rc.left,
                         rc.bottom - rc.top + 1,
                         SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);

            //
            // Following code is only for exposing edit box name in MSAA
            //
            {
                TVITEM      tvi;
                HWND        hCtrl;
                GSBUF_DEF(pItem, MAX_RES_STR_CHARS);

                tvi.hItem       = _OI_HITEM(pItem);
                tvi.mask        = TVIF_TEXT;
                tvi.pszText     = GSBUF_BUF;
                tvi.cchTextMax  = MAX_RES_STR_CHARS;

                if (TreeView_GetItem(pTVWnd->hWndTV, &tvi) && (hCtrl = GetDlgItem(pTVWnd->hWndTV, IDD_TV_MSAA_NAME)))
                {
                    SetWindowText(hCtrl, tvi.pszText);

                    //
                    // Insert the invisible label ahead of the combo box.
                    //
                    SetWindowPos(hCtrl, hEdit, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);
                    SetWindowPos(hEdit, hCtrl, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);
                }
            }

            DestroyWindow(hUDArrow);

            pTVWnd->hWndEdit[2] =
            hUDArrow            = CreateUDArrow(hDlg,
                                                IDD_TV_UDARROW_EDIT,
                                                IDD_TV_UDARROW,
                                                Range[0],
                                                Range[1],
                                                NewPos);

            HCTRL_SETCTRLDATA(hUDArrow, CTRLS_UDARROW, CtrlData);

            if (pTVWnd->hWndEdit[1]) {

                rc.left  = rc.right + pTVWnd->cxExtAdd;
                rc.right = rc.left + (LONG)_OI_CXEXT(pItem);

                SetWindowPos(pTVWnd->hWndEdit[1],
                             hUDArrow,
                             rc.left,
                             rc.top,
                             rc.right - rc.left,
                             rc.bottom - rc.top + (LONG)_OI_CYEXTADD(pItem),
                             SWP_FRAMECHANGED | SWP_DRAWFRAME);
            }

            pTVWnd->chWndEdit = 3;
            pTVWnd->cxEdit    = (WORD)(rc.right - OrgL);
            pTVWnd->cxItem    = (WORD)(rc.right - pTVWnd->ptCur.x);



        }
#endif
        SendMessage(hUDArrow,
                    UDM_SETRANGE,
                    (WPARAM)0,
                    (LPARAM)MAKELONG((SHORT)Range[1], (SHORT)Range[0]));

        Range[0] = 0;
        Range[1] = -1;

    } else {

        SendMessage(hEdit, EM_GETSEL, (WPARAM)&Range[0], (LPARAM)&Range[1]);
    }

    HCTRL_STATE(hEdit,    TRUE, SW_SHOW);
    HCTRL_STATE(hUDArrow, TRUE, SW_SHOW);

    SendMessage(hUDArrow, UDM_SETPOS, 0, (LPARAM)MAKELONG(NewPos, 0));
    SendMessage(hEdit, EM_SETSEL, (WPARAM)Range[0], (LPARAM)Range[1]);

    CPSUIDBG(DBG_VALIDATE_UD, ("InitUDArrow: NewPos=%ld, SELECT=%ld / %ld",
                                    NewPos, Range[0], Range[1]));

    return(1);
}





VOID
InitTBSB(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    HWND        hTBSB,
    POPTTYPE    pOptType,
    UINT        PostfixID,
    UINT        RangeLID,
    UINT        RangeHID,
    WORD        InitItemIdx,
    LONG        NewPos,
    WORD        InitFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Aug-1995 Fri 14:25:50 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hCtrl;
    POPTPARAM   pOptParam;
    LONG        Range[2];
    LONG        CurRange;
    LONG        MulFactor;
    UINT        i;
    BOOL        IsTB;
    GSBUF_DEF(pItem, MAX_RES_STR_CHARS);



    IsTB      = (BOOL)(GetWindowLongPtr(hTBSB, GWLP_ID) == IDD_TV_TRACKBAR);
    pOptParam = pOptType->pOptParam;
    Range[0]  = (LONG)pOptParam[1].IconID;
    Range[1]  = (LONG)pOptParam[1].lParam;
    MulFactor = (LONG)pOptParam[2].IconID;


    if ((NewPos < Range[0]) || (NewPos > Range[1])) {

        NewPos = Range[0];
    }

    if (InitFlags & INITCF_INIT) {

#if DO_IN_PLACE
        RECT    rc;
        LONG    MaxR;

        GetClientRect(pTVWnd->hWndTV, &rc);

        MaxR = rc.right;
#endif
        CPSUIDBG(DBG_INITTBSB, ("TB/SB Range=%ld to %ld", Range[0], Range[1]));

        //
        // Set Low/High range text
        //

#if DO_IN_PLACE
        if ((IS_TVDLG)  &&
            (TreeView_GetItemRect(pTVWnd->hWndTV,
                                  _OI_HITEM(pItem),
                                  &rc,
                                  TRUE))) {

            LONG    OrgL;

            pTVWnd->ptCur.x = rc.left;
            pTVWnd->ptCur.y = rc.top;

            OrgL           = rc.right;
            rc.left        = rc.right + pTVWnd->cxSelAdd;
            rc.right       = rc.left + (pTVWnd->cxAveChar * 32);

            SetWindowPos(pTVWnd->hWndEdit[0] = hTBSB,
                         NULL,
                         rc.left,
                         rc.top,
                         rc.right - rc.left,
                         rc.bottom - rc.top,
                         SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);

            if (pTVWnd->hWndEdit[1]) {

                pTVWnd->chWndEdit = 2;
                rc.left           = rc.right + pTVWnd->cxExtAdd;
                rc.right          = rc.left + (LONG)_OI_CXEXT(pItem);

                SetWindowPos(pTVWnd->hWndEdit[1],
                             hTBSB,
                             rc.left,
                             rc.top,
                             rc.right - rc.left,
                             rc.bottom - rc.top + (LONG)_OI_CYEXTADD(pItem),
                             SWP_FRAMECHANGED | SWP_DRAWFRAME);

            } else {

                pTVWnd->chWndEdit = 1;
            }

            pTVWnd->cxEdit = (WORD)(rc.right - OrgL);
            pTVWnd->cxItem = (WORD)(rc.right - pTVWnd->ptCur.x);


            PostfixID    =
            RangeLID     =
            RangeHID     = 0;
            GSBUF_FLAGS |= GBF_PREFIX_OK;
        }
#endif
        if ((PostfixID) && (hCtrl = GetDlgItem(hDlg, PostfixID))) {

            GSBUF_RESET;

            if (!(pOptType->Flags & OPTTF_NOSPACE_BEFORE_POSTFIX)) {

                GSBUF_ADD_SPACE(1);
            }

            GSBUF_GETSTR(pOptParam[0].pData);

            SetWindowText(hCtrl, GSBUF_BUF);
            SHOWCTRL(hCtrl, TRUE, SW_SHOW);
        }

        for (i = 1; i <= 2; i++, RangeLID = RangeHID) {

            if ((RangeLID) && (hCtrl = GetDlgItem(hDlg, RangeLID))) {

                LPTSTR  pRangeText;

                GSBUF_RESET;

                if (pRangeText = pOptParam[i].pData) {

                    GSBUF_GETSTR(pRangeText);

                } else {

                    CurRange = Range[i - 1] * MulFactor;

                    GSBUF_ADDNUM(Range[i - 1] * MulFactor, TRUE);

                    if (!(pOptType->Flags & OPTTF_NOSPACE_BEFORE_POSTFIX)) {

                        GSBUF_ADD_SPACE(1);
                    }

                    GSBUF_GETSTR(pOptParam[0].pData);
                }

                SetWindowText(hCtrl, GSBUF_BUF);
                SHOWCTRL(hCtrl, TRUE, SW_SHOW);
            }
        }

        if (IsTB) {

            SendMessage(hTBSB,
                        TBM_SETRANGE,
                        (WPARAM)TRUE,
                        (LPARAM)MAKELONG((SHORT)Range[0], (SHORT)Range[1]));

            SendMessage(hTBSB,
                        TBM_SETPAGESIZE,
                        (WPARAM)0,
                        (LPARAM)pOptParam[2].lParam);

            CurRange = Range[1] - Range[0];

            if ((!(MulFactor = (LONG)pOptParam[2].lParam)) ||
                ((CurRange / MulFactor) > 25)) {

                MulFactor = CurRange / 25;
            }

            CPSUIINT(("Tick Freq set to %ld, Range=%ld", MulFactor, CurRange));

            SendMessage(hTBSB,
                        TBM_SETTICFREQ,
                        (WPARAM)MulFactor,
                        (LPARAM)NewPos);

        } else {

            SendMessage(hTBSB,
                        SBM_SETRANGE,
                        (WPARAM)(SHORT)Range[0],
                        (LPARAM)(SHORT)Range[1]);
        }
    }

    //
    // Set Static text
    //

    if (IsTB) {

        HCTRL_SETCTRLDATA(hTBSB, CTRLS_TRACKBAR, 0);
        SendMessage(hTBSB, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)NewPos);

    } else {

        HCTRL_SETCTRLDATA(hTBSB, CTRLS_HSCROLL, 0);
        SendMessage(hTBSB, SBM_SETPOS, (WPARAM)NewPos, (LPARAM)TRUE);
    }

    HCTRL_ST