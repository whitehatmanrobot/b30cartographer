e
    commTimeouts.ReadIntervalTimeout = 0;
    commTimeouts.ReadTotalTimeoutMultiplier = 0;
    commTimeouts.ReadTotalTimeoutConstant = 3000;
    commTimeouts.WriteTotalTimeoutMultiplier = 0;
    commTimeouts.WriteTotalTimeoutConstant = 3000;
    SetCommTimeouts (result, &commTimeouts);

    // let's set some comm state data
    if (GetCommState (result, &dcb)) {
        dcb.fBinary = 1;
        dcb.fParity = 1;
        dcb.ByteSize = 8;
        dcb.fOutxCtsFlow = 1;
        dcb.fTXContinueOnXoff = 1;
        dcb.fRtsControl = 2;
        dcb.fAbortOnError = 1;
        dcb.Parity = 0;
        dcb.BaudRate = g_DirectCableBaudRate?g_DirectCableBaudRate:CBR_115200;
        if (!SetCommState (result, &dcb)) {
            CloseHandle (result);
            result = INVALID_HANDLE_VALUE;
            return result;
        }
    } else {
        CloseHandle (result);
        result = INVALID_HANDLE_VALUE;
        return result;
    }

    return result;
}

#define ACK         0x16
#define NAK         0x15
#define SOH         0x01
#define EOT         0x04
#define BLOCKSIZE   1024

BOOL
pDCSendFileToHandle (
    IN      HANDLE DeviceHandle,
    IN      PCTSTR FileName,
    IN OUT  ULONGLONG *TotalImageWritten,
    IN      ULONGLONG TotalImageSize
    )
{
    HANDLE fileHandle = NULL;
    BOOL result = TRUE;
    BYTE buffer [4 + BLOCKSIZE];
    BYTE signal;
    BYTE currBlock = 0;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = FALSE;
    UINT index;
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;
    UINT elapsedTicks;
    UINT estimatedTime;
    UINT percent, percent100;
    UINT hour, minute, second;
    MIG_APPINFO appInfo;
    PCTSTR statusMsg;
    PCTSTR argArray[5];

    fileHandle = BfOpenReadFile (FileName);
    if (!fileHandle) {
        return FALSE;
    }

    if (!g_StartTicks) {
        g_StartTicks = GetTickCount ();
    }

    // finally let's start the protocol

    // We are going to listen for the NAK(15h) signal.
    // As soon as we get it we are going to send a 4 + BLOCKSIZE bytes block having:
    // 1 byte - SOH (01H)
    // 1 byte - block number
    // 1 byte - FF - block number
    // BLOCKSIZE bytes of data
    // 1 byte - checksum - sum of all BLOCKSIZE bytes of data
    // After the block is sent, we are going to wait for ACK(16h). If we don't get
    // it after timeout or if we get something else we are going to send the block again.

    // wait for NAK
    while ((!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
            (numRead != 1) ||
            (signal != NAK)
            ) &&
           (!IsmCheckCancel ())
           );

    repeat = FALSE;
    while (TRUE) {

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        if (!repeat) {
            // prepare the next block
            currBlock ++;
            if (currBlock == 0) {
                result = TRUE;
            }
            buffer [0] = SOH;
            buffer [1] = currBlock;
            buffer [2] = 0xFF - currBlock;
            if (!ReadFile (fileHandle, buffer + 3, BLOCKSIZE, &numRead, NULL) ||
                (numRead == 0)
                ) {
                // we are done with data, send the EOT signal
                signal = EOT;
                WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
                break;
            }

            if (TotalImageWritten) {
                *TotalImageWritten += numRead;
            }
            // compute the checksum
            buffer [sizeof (buffer) - 1] = 0;
            signal = 0;
            for (index = 0; index < sizeof (buffer) - 1; index ++) {
                signal += buffer [index];
            }
            buffer [sizeof (buffer) - 1] = signal;
        }

        // now send the block to the other side
        if (!WriteFile (DeviceHandle, buffer, sizeof (buffer), &numWritten, NULL) ||
            (numWritten != sizeof (buffer))
            ) {
            repeat = TRUE;
        } else {
            repeat = FALSE;
        }

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        if (repeat) {
            // we could not send the data last time
            // let's just wait for a NAK for 10 sec and then send it again
            ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL);
        } else {
            // we sent it OK. We need to wait for an ACK to come. If we timeout
            // or we get something else, we will repeat the block.
            if (!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
                (numRead != sizeof (signal)) ||
                (signal != ACK)
                ) {
                repeat = TRUE;
            }
            if (!repeat) {
                if (TotalImageWritten) {
                    // now update the progress bar
                    numerator = (LONGLONG) (*TotalImageWritten) * (LONGLONG) g_CompressedTicks;
                    divisor = (LONGLONG) TotalImageSize;
                    if (divisor) {
                        tick = numerator / divisor;
                    } else {
                        tick = 0;
                    }
                    delta = (UINT) tick - g_CompressedTicked;
                    if (delta) {
                        IsmTickProgressBar (g_CompressedSlice, delta);
                        g_CompressedTicked += delta;
                    }
                    // now update the estimated time and %
                    elapsedTicks = GetTickCount () - g_StartTicks;
                    estimatedTime = (UINT)(TotalImageSize * elapsedTicks / (*TotalImageWritten)) - elapsedTicks;
                    percent100 = (UINT)((*TotalImageWritten) * 10000 / TotalImageSize);
                    percent = percent100 / 100;
                    percent100 = percent100 - (percent * 100);
                    if (elapsedTicks > 45000) { // after about 45 seconds
                        // let's send the message to the app
                        hour = estimatedTime / 3600000;
                        minute = estimatedTime / 60000 - hour * 60;
                        second = estimatedTime / 1000 - hour * 3600 - minute * 60;

                        argArray[0] = (PCTSTR) (UINT_PTR) (percent);
                        argArray[1] = (PCTSTR) (UINT_PTR) (percent100);
                        argArray[2] = (PCTSTR) (UINT_PTR) (hour);
                        argArray[3] = (PCTSTR) (UINT_PTR) (minute);
                        argArray[4] = (PCTSTR) (UINT_PTR) (second);
                        statusMsg = ParseMessageID (MSG_TRANSFER_INFO, argArray);

                        if (statusMsg) {
                            ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
                            appInfo.Phase = MIG_TRANSPORT_PHASE;
                            appInfo.SubPhase = SUBPHASE_CABLETRANS;
                            appInfo.Text = statusMsg;
                            IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));
                            FreeStringResource (statusMsg);
                        }
                    }
                }
            }
        }
    }

    if (result) {
        // we are done here. However, let's listen one more timeout for a
        // potential NAK. If we get it, we'll repeat the EOT signal
        while (ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) &&
            (numRead == 1)
            ) {
            if (signal == NAK) {
                signal = EOT;
                WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
            }
        }
    }

    CloseHandle (fileHandle);

    return result;
}

BOOL
pDCSendFile (
    IN      PCTSTR ComPort,
    IN      PCTSTR FileName,
    IN OUT  ULONGLONG *TotalImageWritten,
    IN      ULONGLONG TotalImageSize
    )
{
    HANDLE deviceHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    deviceHandle = pDCOpenAndSetPort (ComPort);
    if ((!deviceHandle) || (deviceHandle == INVALID_HANDLE_VALUE)) {
        return result;
    }

    result = pDCSendFileToHandle (deviceHandle, FileName, TotalImageWritten, TotalImageSize);

    CloseHandle (deviceHandle);

    return result;
}

BOOL
pDCSendBlockToHandle (
    IN      HANDLE DeviceHandle,
    IN      PCBYTE Buffer
    )
{
    BOOL result = TRUE;
    BYTE buffer [4 + BLOCKSIZE];
    BYTE signal;
    BYTE currBlock = 0;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = FALSE;
    UINT index;

    // let's start the protocol

    // We are going to listen for the NAK(15h) signal.
    // As soon as we get it we are going to send a 4 + BLOCKSIZE bytes block having:
    // 1 byte - SOH (01H)
    // 1 byte - block number
    // 1 byte - FF - block number
    // BLOCKSIZE bytes of data
    // 1 byte - checksum - sum of all BLOCKSIZE bytes of data
    // After the block is sent, we are going to wait for ACK(16h). If we don't get
    // it after timeout or if we get something else we are going to send the block again.

    // wait for NAK
    while ((!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
            (numRead != 1) ||
            (signal != NAK)
            ) &&
           (!IsmCheckCancel ())
           );

    repeat = FALSE;
    while (TRUE) {

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        if (!repeat) {
            // prepare the next block
            currBlock ++;
            if (currBlock == 0) {
                result = TRUE;
            }
            buffer [0] = SOH;
            buffer [1] = currBlock;
            buffer [2] = 0xFF - currBlock;
            CopyMemory (buffer + 3, Buffer, BLOCKSIZE);

            // compute the checksum
            buffer [sizeof (buffer) - 1] = 0;
            signal = 0;
            for (index = 0; index < sizeof (buffer) - 1; index ++) {
                signal += buffer [index];
            }
            buffer [sizeof (buffer) - 1] = signal;
        }

        // now send the block to the other side
        if (!WriteFile (DeviceHandle, buffer, sizeof (buffer), &numWritten, NULL) ||
            (numWritten != sizeof (buffer))
            ) {
            repeat = TRUE;
        } else {
            repeat = FALSE;
        }

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        if (repeat) {
            // we could not send the data last time
            // let's just wait for a NAK for 10 sec and then send it again
            ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL);
        } else {
            // we sent it OK. We need to wait for an ACK to come. If we timeout
            // or we get something else, we will repeat the block.
            if (!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
                (numRead != sizeof (signal)) ||
                (signal != ACK)
                ) {
                repeat = TRUE;
            } else {
                // we are done with data, send the EOT signal
                signal = EOT;
                WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
                break;
            }
        }
    }

    if (result) {
        // we are done here. However, let's listen one more timeout for a
        // potential NAK. If we get it, we'll repeat the EOT signal
        while (ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) &&
            (numRead == 1)
            ) {
            if (signal == NAK) {
                signal = EOT;
                WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
            }
        }
    }

    return result;
}

BOOL
pDCSendBlock (
    IN      PCTSTR ComPort,
    IN      PCBYTE Buffer
    )
{
    HANDLE deviceHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    // Buffer must have BLOCKSIZE size

    deviceHandle = pDCOpenAndSetPort (ComPort);
    if ((!deviceHandle) || (deviceHandle == INVALID_HANDLE_VALUE)) {
        return result;
    }

    result = pDCSendBlockToHandle (deviceHandle, Buffer);

    CloseHandle (deviceHandle);

    return result;
}

BOOL
pDCReceiveFileFromHandle (
    IN      HANDLE DeviceHandle,
    IN      PCTSTR FileName,
    IN      LONGLONG FileSize,
    IN OUT  ULONGLONG *TotalImageRead,
    IN      ULONGLONG TotalImageSize
    )
{
    HANDLE fileHandle = NULL;
    BOOL result = TRUE;
    BYTE buffer [4 + BLOCKSIZE];
    BYTE signal;
    BYTE currBlock = 1;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = TRUE;
    UINT index;
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;
    UINT elapsedTicks;
    UINT estimatedTime;
    UINT percent, percent100;
    UINT hour, minute, second;
    MIG_APPINFO appInfo;
    PCTSTR statusMsg;
    PCTSTR argArray[5];

    fileHandle = BfCreateFile (FileName);
    if (!fileHandle) {
        return FALSE;
    }

    if (!g_StartTicks) {
        g_StartTicks = GetTickCount ();
    }

    // finally let's start the protocol

    // We are going to send an NAK(15h) signal.
    // After that we are going to listen for a block.
    // If we don't get the block in time, or the block is wrong size
    // or it has a wrong checksum we are going to send a NAK signal,
    // otherwise we are going to send an ACK signal
    // One exception. If the block size is 1 and the block is actually the
    // EOT signal it means we are done.

    while (TRUE) {

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        if (repeat) {
            // send the NAK
            signal = NAK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        } else {
            // send the ACK
            signal = ACK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        }

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        repeat = TRUE;
        // let's read the data block
        if (ReadFile (DeviceHandle, buffer, sizeof (buffer), &numRead, NULL)) {
            if ((numRead == 1) &&
                (buffer [0] == EOT)
                ) {
                // we are done
                break;
            }
            if (numRead == sizeof (buffer)) {
                // compute the checksum
                signal = 0;
                for (index = 0; index < sizeof (buffer) - 1; index ++) {
                    signal += buffer [index];
                }
                if (buffer [sizeof (buffer) - 1] == signal) {
                    repeat = FALSE;
                    // checksum is correct, let's see if this is the right block
                    if (currBlock < buffer [1]) {
                        // this is a major error, the sender is ahead of us,
                        // we have to fail
                        result = FALSE;
                        break;
                    }
                    if (currBlock == buffer [1]) {
                        if (FileSize > BLOCKSIZE) {
                            if ((!WriteFile (fileHandle, buffer + 3, BLOCKSIZE, &numWritten, NULL)) ||
                                (numWritten != BLOCKSIZE)
                                ) {
                                // Write failed. Let's get out of here
                                result = FALSE;
                                break;
                            }
                            if (TotalImageRead) {
                                *TotalImageRead += BLOCKSIZE;
                            }
                            FileSize -= BLOCKSIZE;
                        } else {
                            if ((!WriteFile (fileHandle, buffer + 3, (DWORD)FileSize, &numWritten, NULL)) ||
                                (numWritten != FileSize)
                                ) {
                                // Write failed. Let's get out of here
                                result = FALSE;
                                break;
                            }
                            if (TotalImageRead) {
                                *TotalImageRead += FileSize;
                            }
                            FileSize = 0;
                        }
                        if (TotalImageRead) {
                            // now update the progress bar
                            numerator = (LONGLONG) (*TotalImageRead) * (LONGLONG) g_DownloadTicks;
                            divisor = (LONGLONG) TotalImageSize;
                            if (divisor) {
                                tick = numerator / divisor;
                            } else {
                                tick = 0;
                            }
                            delta = (UINT) tick - g_DownloadTicked;
                            if (delta) {
                                IsmTickProgressBar (g_DownloadSlice, delta);
                                g_DownloadTicked += delta;
                            }
                            // now update the estimated time and %
                            elapsedTicks = GetTickCount () - g_StartTicks;
                            estimatedTime = (UINT)(TotalImageSize * elapsedTicks / (*TotalImageRead)) - elapsedTicks;
                            percent100 = (UINT)((*TotalImageRead) * 10000 / TotalImageSize);
                            percent = percent100 / 100;
                            percent100 = percent100 - (percent * 100);
                            if (elapsedTicks > 45000) { // after about 45 seconds
                                // let's send the message to the app
                                hour = estimatedTime / 3600000;
                                minute = estimatedTime / 60000 - hour * 60;
                                second = estimatedTime / 1000 - hour * 3600 - minute * 60;

                                argArray[0] = (PCTSTR) (UINT_PTR) (percent);
                                argArray[1] = (PCTSTR) (UINT_PTR) (percent100);
                                argArray[2] = (PCTSTR) (UINT_PTR) (hour);
                                argArray[3] = (PCTSTR) (UINT_PTR) (minute);
                                argArray[4] = (PCTSTR) (UINT_PTR) (second);
                                statusMsg = ParseMessageID (MSG_TRANSFER_INFO, argArray);

                                if (statusMsg) {
                                    ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
                                    appInfo.Phase = MIG_TRANSPORT_PHASE;
                                    appInfo.SubPhase = SUBPHASE_CABLETRANS;
                                    appInfo.Text = statusMsg;
                                    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));
                                    FreeStringResource (statusMsg);
                                }
                            }
                        }
                        currBlock ++;
                    }
                }
            }
        }
    }

    CloseHandle (fileHandle);

    return result;
}

BOOL
pDCReceiveFile (
    IN      PCTSTR ComPort,
    IN      PCTSTR FileName,
    IN      LONGLONG FileSize,
    IN OUT  ULONGLONG *TotalImageRead,
    IN      ULONGLONG TotalImageSize
    )
{
    HANDLE deviceHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    deviceHandle = pDCOpenAndSetPort (ComPort);
    if ((!deviceHandle) || (deviceHandle == INVALID_HANDLE_VALUE)) {
        return result;
    }

    result = pDCReceiveFileFromHandle (deviceHandle, FileName, FileSize, TotalImageRead, TotalImageSize);

    CloseHandle (deviceHandle);

    return result;
}

BOOL
pDCReceiveBlockFromHandle (
    IN      HANDLE DeviceHandle,
    OUT     PBYTE Buffer
    )
{
    BOOL result = TRUE;
    BYTE buffer [4 + BLOCKSIZE];
    BYTE signal;
    BYTE currBlock = 1;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = TRUE;
    UINT index;

    // finally let's start the protocol

    // We are going to send an NAK(15h) signal.
    // After that we are going to listen for a block.
    // If we don't get the block in time, or the block is wrong size
    // or it has a wrong checksum we are going to send a NAK signal,
    // otherwise we are going to send an ACK signal
    // One exception. If the block size is 1 and the block is actually the
    // EOT signal it means we are done.

    ZeroMemory (Buffer, BLOCKSIZE);

    while (TRUE) {

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        if (repeat) {
            // send the NAK
            signal = NAK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        } else {
            // send the ACK
            signal = ACK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        }

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        repeat = TRUE;
        // let's read the data block
        if (ReadFile (DeviceHandle, buffer, sizeof (buffer), &numRead, NULL)) {
            if ((numRead == 1) &&
                (buffer [0] == EOT)
                ) {
                // we are done
                break;
            }
            if (numRead == sizeof (buffer)) {
                // compute the checksum
                signal = 0;
                for (index = 0; index < sizeof (buffer) - 1; index ++) {
                    signal += buffer [index];
                }
                if (buffer [sizeof (buffer) - 1] == signal) {
                    repeat = FALSE;
                    // checksum is correct, let's see if this is the right block
                    if (currBlock < buffer [1]) {
                        // this is a major error, the sender is ahead of us,
                        // we have to fail
                        result = FALSE;
                        break;
                    }
                    if (currBlock == buffer [1]) {
                        CopyMemory (Buffer, buffer + 3, BLOCKSIZE);
                        currBlock ++;
                    }
                }
            }
        }
    }

    return result;
}

BOOL
pDCReceiveBlock (
    IN      PCTSTR ComPort,
    OUT     PBYTE Buffer
    )
{
    HANDLE deviceHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    // Buffer must have BLOCKSIZE size

    deviceHandle = pDCOpenAndSetPort (ComPort);
    if ((!deviceHandle) || (deviceHandle == INVALID_HANDLE_VALUE)) {
        return result;
    }

    result = pDCReceiveBlockFromHandle (deviceHandle, Buffer);

    CloseHandle (deviceHandle);

    return result;
}

BOOL
pDCWriteAllImages (
    VOID
    )
{
    MIG_APPINFO appInfo;
    PHEADER1 header1;
    PHEADER2 header2;
    BYTE buffer [BLOCKSIZE];
    ULONGLONG totalImageWritten = 0;
    ULONGLONG totalImageSize = 0;
    UINT numberOfFiles = 0;
    UINT imageIdx = 1;
    ULONGLONG imageSize = 0;
    PCTSTR imageFile;

    // let's get the total image size and the total number of bytes
    imageIdx = 1;
    while (TRUE) {
        imageFile = pDCGetImageFile (imageIdx);
        imageSize = BfGetFileSize (imageFile);
        if (imageSize == 0) {
            FreePathString (imageFile);
            break;
        }
        numberOfFiles ++;
        totalImageSize += imageSize;
        FreePathString (imageFile);
        imageIdx ++;
    }

    // let's prepare the initial header
    ZeroMemory (buffer, sizeof (buffer));
    header1 = (PHEADER1) buffer;
    header1->Signature = DIRECTTR_SIG;
    header1->NumberOfFiles = numberOfFiles;
    header1->TotalImageSize = totalImageSize;

    if (!pDCSendBlock (g_DirectCablePath, buffer)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
        return FALSE;
    }

    if (!pDCReceiveBlock (g_DirectCablePath, buffer)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
        return FALSE;
    }

    if (header1->Signature != DIRECTTR_SIG) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
        return FALSE;
    }

    if (header1->NumberOfFiles != numberOfFiles) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
        return FALSE;
    }

    if (header1->TotalImageSize != totalImageSize) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
        return FALSE;
    }

    ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
    appInfo.Phase = MIG_TRANSPORT_PHASE;
    appInfo.SubPhase = SUBPHASE_NETPREPARING;
    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

    imageIdx = 1;
    while (TRUE) {
        imageFile = pDCGetImageFile (imageIdx);
        imageSize = BfGetFileSize (imageFile);
        if (imageSize == 0) {
            FreePathString (imageFile);
            break;
        }
        // send info about the current file
        ZeroMemory (buffer, sizeof (buffer));
        header2 = (PHEADER2) buffer;
        header2->FileNumber = imageIdx;
        header2->FileSize = imageSize;

        if (!pDCSendBlock (g_DirectCablePath, buffer)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
            return FALSE;
        }

        if (!pDCReceiveBlock (g_DirectCablePath, buffer)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
            return FALSE;
        }

        if (header2->FileNumber != imageIdx) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
            return FALSE;
        }

        if (header2->FileSize != imageSize) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
            return FALSE;
        }

        // send the actual file
        if (!pDCSendFile (g_DirectCablePath, imageFile, &totalImageWritten, totalImageSize)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
            return FALSE;
        }

        FreePathString (imageFile);
        imageIdx ++;
    }

    return TRUE;
}

BOOL
WINAPI
DirectCableTransportSaveState (
    VOID
    )
{
    MIG_APPINFO appInfo;
    ERRUSER_EXTRADATA extraData;
    MIG_OBJECTWITHATTRIBUTE_ENUM objEnum;
    PCTSTR databaseFile = NULL;
    PCTSTR decoratedObject = NULL;
    MIG_CONTENT value;
    PMIG_CONTENT convValue;
    COMPRESS_HANDLE compressedHandle;
    INT_PTR appReply;
    BOOL okSave = FALSE;
    TRANSCOPY_ERROR transCopyError;
#ifdef DEBUG
    PCTSTR nativeObjectName;
#endif
    BOOL result = FALSE;

    g_DirectCablePlatform = PLATFORM_SOURCE;

    __try {

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_PREPARING;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        ZeroMemory (&compressedHandle, sizeof (COMPRESS_HANDLE));

        g_DirectCableTempPath = pDCCreateTemporaryDir ();

        if (!g_DirectCableTempPath) {
            extraData.Error = ERRUSER_ERROR_CANTCREATETEMPDIR;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        if (!CompressCreateHandle (g_DirectCableTempPath, S_TRANSPORT_IMG_FILE, 1, 0, &compressedHandle)) {
            extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        //
        // Enumerate all persistent objects
        //

        if (IsmEnumFirstPersistentObject (&objEnum)) {
            do {
                //
                // For each object to be saved, do the appropriate
                // data copy action
                //

                if (IsmCheckCancel()) {
                    __leave;
                }

#ifdef DEBUG
                nativeObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                DEBUGMSG ((DBG_DIRECT, "Transporting: %s", nativeObjectName));
                IsmReleaseMemory (nativeObjectName);
#endif

                okSave = FALSE;
                while (!okSave) {

                    if (!IsmAcquireObjectEx (
                            objEnum.ObjectTypeId,
                            objEnum.ObjectName,
                            &value,
                            CONTENTTYPE_ANY,
                            0
                            )) {

                        transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                        transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                        transCopyError.Error = GetLastError ();

                        if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                            appReply = APPRESPONSE_IGNORE;
                        } else {
                            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                            if ((appReply == APPRESPONSE_NONE) ||
                                (appReply == APPRESPONSE_FAIL)
                                ) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                IsmReleaseMemory (transCopyError.ObjectName);
                                extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                extraData.ObjectName = objEnum.ObjectName;
                                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                IsmAbortPersistentObjectEnum (&objEnum);
                                __leave;
                            }
                        }
                        if (appReply == APPRESPONSE_IGNORE) {
                            LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                            IsmReleaseMemory (transCopyError.ObjectName);
                            extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                            extraData.ErrorArea = ERRUSER_AREA_SAVE;
                            extraData.ObjectTypeId = objEnum.ObjectTypeId;
                            extraData.ObjectName = objEnum.ObjectName;
                            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                            break;
                        }
                        IsmReleaseMemory (transCopyError.ObjectName);
                        continue;
                    }
                    okSave = TRUE;
                }

                if (okSave) {

#ifdef UNICODE
                    convValue = &value;
#else
                    // now let's convert this object content to UNICODE
                    convValue = IsmConvertObjectContentToUnicode (objEnum.ObjectTypeId, objEnum.ObjectName, &value);
                    if (!convValue) {
                        convValue = &value;
                    }
#endif
                    decoratedObject = pDCBuildDecoratedObject (objEnum.ObjectTypeId, objEnum.ObjectName);

                    appInfo.Phase = MIG_TRANSPORT_PHASE;
                    appInfo.SubPhase = SUBPHASE_COMPRESSING;
                    appInfo.ObjectTypeId = (objEnum.ObjectTypeId & (~PLATFORM_MASK));
                    appInfo.ObjectName = objEnum.ObjectName;
                    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

                    if (convValue->ContentInFile) {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pDCSaveContentInFile (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue, &compressedHandle)) {
                                if (GetLastError () == ERROR_DISK_FULL) {
                                    // we just failed because we don't have enough space on the destination
                                    // path. Let's tell that to the user
                                    extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = 0;
                                    extraData.ObjectName = NULL;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    __leave;
                                }

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                    } else {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pDCSaveContentInMemory (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue)) {
                                if (GetLastError () == ERROR_DISK_FULL) {
                                    // we just failed because we don't have enough space on the destination
                                    // path. Let's tell that to the user
                                    extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = 0;
                                    extraData.ObjectName = NULL;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    __leave;
                                }

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                    }

#ifndef UNICODE
                    if (convValue != (&value)) {
                        IsmFreeConvertedObjectContent (objEnum.ObjectTypeId, convValue);
                    }
#endif
                    IsmReleaseObject (&value);

                    pDCDestroyDecoratedObject (decoratedObject);
                    decoratedObject = NULL;
                }

                IsmTickProgressBar (g_PersistentSlice, 1);

                if (IsmCheckCancel()) {
                    __leave;
                }

            } while (IsmEnumNextPersistentObject (&objEnum));

            IsmAbortPersistentObjectEnum (&objEnum);
        }

        if (IsmCheckCancel()) {
            __leave;
        }

        databaseFile = JoinPaths (g_DirectCableTempPath, S_TRANSPORT_DAT_FILE);

        if (!MemDbSave (databaseFile)) {
            extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        IsmTickProgressBar (g_DatabaseSlice, 1);

        if (IsmCheckCancel()) {
            __leave;
        }

        if (!pDCAddFileToImage (databaseFile, S_TRANSPORT_DAT_FILE, &compressedHandle)) {
            extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        IsmTickProgressBar (g_DatabaseSlice, 1);

        FreePathString (databaseFile);
        databaseFile = NULL;

        if (!CompressFlushAndCloseHandle (&compressedHandle)) {
            extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        IsmTickProgressBar (g_DatabaseSlice, 1);

        if (IsmCheckCancel()) {
            __leave;
        }

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_CONNECTING1;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        if (!pDCWriteAllImages ()) {
            extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        result = TRUE;

    }
    __finally {

        PushError ();

        CompressCleanupHandle (&compressedHandle);

        if (databaseFile) {
            FreePathString (databaseFile);
            databaseFile = NULL;
        }

        PopError ();
    }

    PushError ();

    pDCCleanupTempDir ();

    PopError ();

    return result;
}

BOOL
pDCReadAllImages (
    VOID
    )
{
    MIG_APPINFO appInfo;
    PHEADER1 header1;
    PHEADER2 header2;
    BYTE buffer [BLOCKSIZE];
    ULONGLONG totalImageSize = 0;
    ULONGLONG totalImageRead = 0;
    UINT numberOfFiles = 0;
    UINT imageIdx = 1;
    ULONGLONG imageSize = 0;
    PCTSTR imageFile;
    BOOL wrongVer = FALSE;

    // Let's get the initial header
    ZeroMemory (buffer, sizeof (buffer));
    if (!pDCReceiveBlock (g_DirectCablePath, buffer)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
        return FALSE;
    }

    header1 = (PHEADER1) buffer;
    if (header1->Signature != DIRECTTR_SIG) {
        wrongVer = TRUE;
    }

    header1->Signature = DIRECTTR_SIG;
    if (!pDCSendBlock (g_DirectCablePath, buffer)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
        return FALSE;
    }

    if (wrongVer) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
        return FALSE;
    }

    numberOfFiles = header1->NumberOfFiles;
    totalImageSize = header1->TotalImageSize;

    ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
    appInfo.Phase = MIG_TRANSPORT_PHASE;
    appInfo.SubPhase = SUBPHASE_NETPREPARING;
    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

    imageIdx = 1;
    while (imageIdx <= numberOfFiles) {
        imageFile = pDCGetImageFile (imageIdx);

        // receive info about the current file
        ZeroMemory (buffer, sizeof (buffer));
        header2 = (PHEADER2) buffer;

        if (!pDCReceiveBlock (g_DirectCablePath, buffer)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
            return FALSE;
        }

        if (header2->FileNumber != imageIdx) {
            wrongVer = TRUE;
        }

        header2->FileNumber = imageIdx;
        if (!pDCSendBlock (g_DirectCablePath, buffer)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
            return FALSE;
        }

        if (wrongVer) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
            return FALSE;
        }

        // receive the actual file
        if (!pDCReceiveFile (g_DirectCablePath, imageFile, header2->FileSize, &totalImageRead, totalImageSize)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
            return FALSE;
        }

        FreePathString (imageFile);
        imageIdx ++;
    }

    return TRUE;
}

PCTSTR
pDCGetNewFileName (
    IN      PCTSTR FileName
    )
{
    PCTSTR newFileName = NULL;
    PTSTR tempPtr1 = NULL;
    PCTSTR endStr1 = NULL;
    PCTSTR tempPtr2 = NULL;
    PCTSTR endStr2 = NULL;
    INT i;

    // let's modify the file to extract. The file name will
    // be split in 2 after the first 5 characters
    newFileName = DuplicatePathString (FileName, 1);
    if (!newFileName) {
        return NULL;
    }
    tempPtr1 = (PTSTR) GetFileNameFromPath (newFileName);
    if (!tempPtr1) {
        FreePathString (newFileName);
        return NULL;
    }
    endStr1 = GetEndOfString (newFileName);
    if (!endStr1) {
        FreePathString (newFileName);
        return NULL;
    }
    tempPtr2 = GetFileNameFromPath (FileName);
    if (!tempPtr2) {
        FreePathString (newFileName);
        return NULL;
    }
    endStr2 = GetEndOfString (FileName);
    if (!endStr2) {
        FreePathString (newFileName);
        return NULL;
    }
    for (i = 0; i < 5; i ++) {
        tempPtr1 = _tcsinc (tempPtr1);
        tempPtr2 = _tcsinc (tempPtr2);
    }

    if ((tempPtr1 < endStr1) &&
        (tempPtr2 < endStr2)
        ) {
        StringCopy (tempPtr1, TEXT("\\"));
        tempPtr1 = _tcsinc (tempPtr1);
        StringCopy (tempPtr1, tempPtr2);
    } else {
        FreePathString (newFileName);
        newFileName = NULL;
    }
    return newFileName;
}

BOOL
pDirectCableCallback (
    IN      PCTSTR FileToExtract,
    IN      LONGLONG FileSize,
    OUT     PBOOL ExtractFile,
    IN OUT  PCTSTR *NewFileName
    )
{
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;

    if (NewFileName) {
        *NewFileName = pDCGetNewFileName (FileToExtract);
    }

    g_FilesRead ++;
    // now update the progress bar
    numerator = (LONGLONG) g_FilesRead * (LONGLONG) g_UncompressTicks;
    divisor = (LONGLONG) g_TotalFiles;
    if (divisor) {
        tick = numerator / divisor;
    } else {
        tick = 0;
    }
    delta = (UINT) tick - g_UncompressTicked;
    if (delta) {
        IsmTickProgressBar (g_UncompressSlice, delta);
        g_UncompressTicked += delta;
    }

    if (ExtractFile) {
        *ExtractFile = TRUE;
    }

    return (!IsmCheckCancel());
}

BOOL
pDCUnpackAllFiles (
    VOID
    )
{
    COMPRESS_HANDLE compressedHandle;
    BOOL result = FALSE;

    if (CompressOpenHandle (g_DirectCableTempPath, S_TRANSPORT_IMG_FILE, 1, &compressedHandle)) {
        g_TotalFiles = compressedHandle.FilesStored;
        if (CompressExtractAllFiles (g_DirectCableTempPath, &compressedHandle, pDirectCableCallback)) {
            result = TRUE;
        }
        CompressCleanupHandle (&compressedHandle);
    }

    return result;
}

BOOL
WINAPI
DirectCableTransportBeginApply (
    VOID
    )
{
    MIG_APPINFO appInfo;
    ERRUSER_EXTRADATA extraData;
    PCTSTR imageFile = NULL;
    PCTSTR newImageFile = NULL;
    BOOL result = FALSE;

    g_DirectCablePlatform = PLATFORM_DESTINATION;

    ZeroMemory (&extraData, sizeof (ERRUSER_EXTRADATA));
    extraData.Error = ERRUSER_ERROR_UNKNOWN;

    ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
    appInfo.Phase = MIG_TRANSPORT_PHASE;
    appInfo.SubPhase = SUBPHASE_CONNECTING2;
    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

    __try {

        g_DirectCableTempPath = pDCCreateTemporaryDir ();

        if (!g_DirectCableTempPath) {
            extraData.Error = ERRUSER_ERROR_CANTCREATETEMPDIR;
            __leave;
        }

        if (!pDCReadAllImages ()) {
            if (GetLastError () == ERROR_DISK_FULL) {
                extraData.Error = ERRUSER_ERROR_DISKSPACE;
            } else {
                extraData.Error = ERRUSER_ERROR_CANTREADIMAGE;
            }
            __leave;
        }

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_UNCOMPRESSING;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        if (!pDCUnpackAllFiles ()) {
            extraData.Error = ERRUSER_ERROR_CANTUNPACKIMAGE;
            __leave;
        }

        newImageFile = pDCGetNewFileName (S_TRANSPORT_DAT_FILE);

        imageFile = JoinPaths (g_DirectCableTempPath, newImageFile?newImageFile:S_TRANSPORT_DAT_FILE);

        if (newImageFile) {
            FreePathString (newImageFile);
            newImageFile = NULL;
        }

        if (!MemDbLoad (imageFile)) {
            extraData.Error = ERRUSER_ERROR_CANTREADIMAGE;
            __leave;
        }

        result = TRUE;
    }
    __finally {
        if (imageFile) {
            FreePathString (imageFile);
            imageFile = NULL;
        }
    }

    if (!result) {
        extraData.ErrorArea = ERRUSER_AREA_LOAD;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
    }

    return result;
}

VOID
WINAPI
DirectCableTransportEndApply (
    VOID
    )
{
    MYASSERT (g_DirectCablePlatform == PLATFORM_DESTINATION);

    pDCCleanupTempDir ();
}

BOOL
WINAPI
DirectCableTransportAcquireObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,             CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    UINT value;
    PCBYTE memValue;
    UINT memValueSize;
    PCTSTR fileValue = NULL;
    PCTSTR newFileValue = NULL;
    BOOL valueInFile;
    KEYHANDLE keyHandle;
    PALLOCSTATE allocState;
    PCTSTR detailsKey = NULL;
    PBYTE details;
    UINT detailsSize;
    PCTSTR sourceFile;
    PCTSTR decoratedObject = NULL;
    HANDLE fileHandle;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    MYASSERT (g_DirectCablePlatform == PLATFORM_DESTINATION);
    MYASSERT ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE);

    decoratedObject = pDCBuildDecoratedObject (ObjectTypeId, ObjectName);

    allocState = (PALLOCSTATE) MemAllocZeroed (sizeof (ALLOCSTATE));

    if (MemDbGetValue (decoratedObject, &value)) {
        if (value == TRFLAG_FILE) {
            valueInFile = TRUE;
            keyHandle = MemDbGetSingleLinkage (decoratedObject, 0, 0);
            if (keyHandle) {
                fileValue = MemDbGetKeyFromHandle (keyHandle, 0);
                newFileValue = pDCGetNewFileName (fileValue);
                result = fileValue != NULL;
            } else {
                fileValue = NULL;
                result = TRUE;
            }
        } else if (value == TRFLAG_MEMORY) {
            valueInFile = FALSE;
            memValueSize = 0;
            memValue = MemDbGetUnorderedBlob (decoratedObject, 0, &memValueSize);
            result = TRUE;
        } else {
            LOG ((LOG_ERROR, (PCSTR) MSG_UNSUPPORTED_DATA, value));
            SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        }
        if (result) {
            result = FALSE;

            if (valueInFile) {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_FILE) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as a file and it's wanted as a file
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = TRUE;
                    if (fileValue) {
                        ObjectContent->FileContent.ContentPath = JoinPaths (g_DirectCableTempPath, newFileValue?newFileValue:fileValue);
                        ObjectContent->FileContent.ContentSize = BfGetFileSize (ObjectContent->FileContent.ContentPath);
                    } else {
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                    result = TRUE;
                } else {
                    // this is stored as a file and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    if (fileValue) {
                        sourceFile = JoinPaths (g_DirectCableTempPath, newFileValue?newFileValue:fileValue);
                        ObjectContent->MemoryContent.ContentSize = (UINT) BfGetFileSize (sourceFile);
                        ObjectContent->MemoryContent.ContentBytes = MapFileIntoMemory (
                                                                        sourceFile,
                                                                        &allocState->FileHandle,
                                                                        &allocState->MapHandle
                                                                        );
                        FreePathString (sourceFile);
                        result = (ObjectContent->MemoryContent.ContentBytes != NULL);
                    } else {
                        ObjectContent->MemoryContent.ContentSize = 0;
                        ObjectContent->MemoryContent.ContentBytes = NULL;
                        result = TRUE;
                    }
                }
                if (newFileValue) {
                    FreePathString (newFileValue);
                    newFileValue = NULL;
                }
                if (fileValue) {
                    MemDbReleaseMemory (fileValue);
                    fileValue = NULL;
                }
            } else {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_MEMORY) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as memory and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    ObjectContent->MemoryContent.ContentSize = memValueSize;
                    ObjectContent->MemoryContent.ContentBytes = memValue;
                    result = TRUE;
                } else {
                    // this is stored as memory and it's wanted as a file
                    if (memValue) {
                        if (IsmGetTempFile (allocState->TempFile, ARRAYSIZE(allocState->TempFile))) {
                            fileHandle = BfCreateFile (allocState->TempFile);
                            if (fileHandle) {
                                if (BfWriteFile (fileHandle, memValue, memValueSize)) {
                                    ObjectContent->ObjectTypeId = ObjectTypeId;
                                    ObjectContent->ContentInFile = TRUE;
                                    ObjectContent->FileContent.ContentSize = memValueSize;
                                    ObjectContent->FileContent.ContentPath = DuplicatePathString (allocState->TempFile, 0);
                                    result = TRUE;
                                }
                                CloseHandle (fileHandle);
                            }
                        }
                        MemDbReleaseMemory (memValue);
                    } else {
                        ObjectContent->ObjectTypeId = ObjectTypeId;
                        ObjectContent->ContentInFile = TRUE;
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                }
            }
        }
    } else {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
    }

    if (result) {
        //
        // Fill the details
        //

        detailsKey = JoinText (S_DETAILS_PREFIX, decoratedObject);

        details = MemDbGetUnorderedBlob (detailsKey, 0, &detailsSize);

        if (!details) {
            detailsSize = 0;
        }

        allocState->DetailsPtr = details;

        ObjectContent->Details.DetailsSize = detailsSize;
        ObjectContent->Details.DetailsData = details;

        FreeText (detailsKey);

        ObjectContent->TransHandle = allocState;
    }

    if (!result) {
        FreeAlloc (allocState);
    }

    FreePathString (decoratedObject);

    return result;
}

BOOL
WINAPI
DirectCableTransportReleaseObject (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PALLOCSTATE allocState;

    MYASSERT (g_DirectCablePlatform == PLATFORM_DESTINATION);

    allocState = (PALLOCSTATE) ObjectContent->TransHandle;

    if (ObjectContent->ContentInFile) {
        FreePathString (ObjectContent->FileContent.ContentPath);
        if (allocState && allocState->TempFile[0]) {
            DeleteFile (allocState->TempFile);
        }
    } else {
        if (allocState && allocState->FileHandle && allocState->MapHandle) {
            UnmapFile (
                ObjectContent->MemoryContent.ContentBytes,
                allocState->MapHandle,
                allocState->FileHandle
                );
        } else {
            MemDbReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
        }
    }

    if (allocState && allocState->DetailsPtr) {
        MemDbReleaseMemory (allocState->DetailsPtr);
    }

    FreeAlloc (allocState);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\inc\trans.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    trans.h

Abstract:

    Provides constants for interacting with the transport module.

    This is primarily used to pass transport messages to the app layer.

Author:

    Jim Schmidt (jimschm) 26-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// Includes
//

// None

#define DBG_FOO     "Foo"

//
// Strings
//

#define S_RELIABLE_STORAGE_TRANSPORT    TEXT("RELIABLE_STORAGE_TRANSPORT")
#define S_COMPRESSED_TRANSPORT          TEXT("COMPRESSED_TRANSPORT")
#define S_REMOVABLE_MEDIA_TRANSPORT     TEXT("REMOVABLE_MEDIA_TRANSPORT")
#define S_HOME_NETWORK_TRANSPORT        TEXT("HOME_NETWORK_TRANSPORT")
#define S_DIRECT_CABLE_TRANSPORT        TEXT("DIRECT_CABLE_TRANSPORT")

//
// Constants
//

#define TRANSPORT_ENVVAR_RMEDIA_DISKNR          TEXT("RemovableMediaTransport:NextDiskNumber")
#define TRANSPORT_ENVVAR_HOMENET_DESTINATIONS   TEXT("HomeNetDestinationNames")
#define TRANSPORT_ENVVAR_HOMENET_TAG            TEXT("HomeNetTag")

#define CAPABILITY_COMPRESSED               0x00000001
#define CAPABILITY_ENCRYPTED                0x00000002
#define CAPABILITY_AUTOMATED                0x00000004

//
// Macros
//

// None

//
// Types
//

typedef enum {
    RMEDIA_ERR_NOERROR = 0,
    RMEDIA_ERR_GENERALERROR,
    RMEDIA_ERR_WRONGMEDIA,
    RMEDIA_ERR_OLDMEDIA,
    RMEDIA_ERR_USEDMEDIA,
    RMEDIA_ERR_DISKFULL,
    RMEDIA_ERR_NOTREADY,
    RMEDIA_ERR_WRITEPROTECT,
    RMEDIA_ERR_CRITICAL,
} RMEDIA_ERR, *PRMEDIA_ERR;

typedef struct {
    RMEDIA_ERR LastError;
    DWORD MediaNumber;
    ULONGLONG TotalImageSize;
    ULONGLONG TotalImageWritten;
} RMEDIA_EXTRADATA, *PRMEDIA_EXTRADATA;

typedef struct {
    PCTSTR ObjectType;
    PCTSTR ObjectName;
    DWORD Error;
} TRANSCOPY_ERROR, *PTRANSCOPY_ERROR;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Public function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// ANSI/UNICODE macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\inc\modules.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    modules.h

Abstract:

    Base definitions for the Intermediate State Manager.

Author:

    Calin Negreanu (calinn) 15-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// Includes
//

#include "ism.h"

//
// Strings
//

// None

//
// Constants
//

// messages from 0x0001 to 0x000F are reserved by the engine
#define TRANSPORTMESSAGE_IMAGE_EXISTS           0x0010
#define TRANSPORTMESSAGE_IMAGE_LOCKED           0x0011
#define TRANSPORTMESSAGE_SIZE_SAVED             0x0012
#define TRANSPORTMESSAGE_RMEDIA_SAVE            0x0013
#define TRANSPORTMESSAGE_RMEDIA_LOAD            0x0014
#define TRANSPORTMESSAGE_MULTIPLE_DESTS         0x0015          // return TRUE if multiple dests are resolved
#define TRANSPORTMESSAGE_READY_TO_CONNECT       0x0016
#define TRANSPORTMESSAGE_SRC_COPY_ERROR         0x0017
#define TRANSPORTMESSAGE_OLD_STORAGE            0x0018
#define TRANSPORTMESSAGE_NET_DISPLAY_PASSWORD   0x0019
#define TRANSPORTMESSAGE_NET_GATHER_PASSWORD    0x001A
#define MODULEMESSAGE_DISPLAYERROR              0x001B
#define MODULEMESSAGE_DISPLAYWARNING            0x001C
#define MODULEMESSAGE_ASKQUESTION               0x001D

#define APPRESPONSE_NONE                    0
#define APPRESPONSE_SUCCESS                 1
#define APPRESPONSE_FAIL                    2
#define APPRESPONSE_IGNORE                  3

//
// Known attributes
//

#define S_ATTRIBUTE_FIXEDPATH           TEXT("FixedPath")
#define S_OBJECTTYPE_FILE               TEXT("File")
#define S_OBJECTTYPE_REGISTRY           TEXT("Registry")
#define S_ATTRIBUTE_V1                  TEXT("v1")
#define S_ATTRIBUTE_OSFILE              TEXT("OSFILE")
#define S_ATTRIBUTE_COPYIFRELEVANT      TEXT("CopyIfRelevant")
#define S_ATTRIBUTE_PARTITIONLOCK       TEXT("PartitionLock")

//
// Known properties
//

#define S_PROPERTY_FILEMOVE             TEXT("Move.FileMove")
#define S_PROPERTY_FILEMOVE_HINT        TEXT("Move.FileMove.Hint")

//
// known operations
//

#define S_OPERATION_MOVE                TEXT("Move.General")
#define S_OPERATION_ENHANCED_MOVE       TEXT("Move.Ex")
#define S_OPERATION_V1_FILEMOVEEX       TEXT("Move.V1FileMoveEx")
#define S_OPERATION_V1_FILEMOVE         TEXT("Move.V1FileMove")
#define S_OPERATION_ENHANCED_FILEMOVE   TEXT("Move.FileMoveEx")
#define S_OPERATION_PARTITION_MOVE      TEXT("Move.Partition")
#define S_OPERATION_DELETE              TEXT("Delete")
#define S_OPERATION_LNKMIG_FIXCONTENT   TEXT("Content.LnkMigFixContent")
#define S_OPERATION_DEFICON_FIXCONTENT  TEXT("Content.DefaultIcon")
#define S_OPERATION_DRIVEMAP_FIXCONTENT TEXT("Content.MappedDrive")
#define S_OPERATION_DESTADDOBJ          TEXT("Content.DestAddObject")
#define S_OPERATION_REG_AUTO_FILTER     TEXT("Content.RegAutoFilter")

//
// known environment groups
//

#define S_SYSENVVAR_GROUP               TEXT("SysEnvVar")

//
// v1 functionality attributes and environment variables
//

#define S_GLOBAL_INF_HANDLE             TEXT("GlobalInfHandle")
#define S_ENV_HKCU_V1                   TEXT("HKCU_V1")
#define S_ENV_HKCU_ON                   TEXT("HKCU_ON")
#define S_ENV_HKLM_ON                   TEXT("HKLM_ON")
#define S_ENV_ALL_FILES                 TEXT("FILES_ON")
#define S_INF_FILE_MULTISZ              TEXT("INF_FILES")
#define S_ENV_CREATE_USER               TEXT("CreateUser")
#define S_ENV_ICONLIB                   TEXT("IconLib")
#define S_ENV_SAVE_ICONLIB              TEXT("SaveIconLib")
#define S_ENV_DEST_DELREG               TEXT("DelDestReg")
#define S_ENV_DEST_DELREGEX             TEXT("DelDestRegEx")
#define S_ENV_DEST_RESTORE              TEXT("RestoreCallback")
#define S_ENV_SCRIPT_EXECUTE            TEXT("ScriptExecute")
#define S_ENV_DEST_ADDOBJECT            TEXT("DestAddObject")
#define S_ENV_DEST_CHECKDETECT          TEXT("DestCheckDetect")

//
// module-to-app environment variables
//

#define S_REQUIRE_DOMAIN_USER           TEXT("RequireDomainUser")

// component groups
#define COMPONENT_NAME                  5
#define COMPONENT_SUBCOMPONENT          4
#define COMPONENT_EXTENSION             3
#define COMPONENT_FILE                  2
#define COMPONENT_FOLDER                1

//
// strings shared between apps
//

#define S_INF_OBJECT_NAME               TEXT("inf")

//
// Macros
//

// None

//
// Types
//

//
// Types for errors to be presented to the user
//

typedef enum {
    ERRUSER_ERROR_UNKNOWN = 0,          // Unknown error
    ERRUSER_ERROR_NOTRANSPORTPATH,      // Transport path is not selected. Don't know where to write or where to read from
    ERRUSER_ERROR_TRANSPORTPATHBUSY,    // Transport path is in use. Cannot save there.
    ERRUSER_ERROR_CANTEMPTYDIR,         // USMT dir inside transport path could not be erased.
    ERRUSER_ERROR_ALREADYEXISTS,        // USMT dir inside transport path already exists. Cannot override.
    ERRUSER_ERROR_CANTCREATEDIR,        // USMT dir inside transport path could not be created.
    ERRUSER_ERROR_CANTCREATESTATUS,     // USMT status file inside transport path could not be created.
    ERRUSER_ERROR_CANTCREATETEMPDIR,    // Transport can't create temp dir to prepare for save.
    ERRUSER_ERROR_CANTCREATECABFILE,    // Transport can't create cabinet file to prepare for save.
    ERRUSER_ERROR_CANTSAVEOBJECT,       // Transport can't save a particular object
    ERRUSER_ERROR_CANTSAVEINTERNALDATA, // Transport can't save it's internal data
    ERRUSER_ERROR_CANTWRITETODESTPATH,  // Transport can't write to destination path
    ERRUSER_ERROR_TRANSPORTINVALIDIMAGE,// Transport image is invalid. Cannot read data.
    ERRUSER_ERROR_CANTOPENSTATUS,       // USMT status file inside transport path could not be opened.
    ERRUSER_ERROR_CANTREADIMAGE,        // Transport can't read the saved image. The image may be corrupt.
    ERRUSER_ERROR_CANTFINDDESTINATION,  // HomeNet transport can't find the destination machine
    ERRUSER_ERROR_CANTSENDTODEST,       // HomeNet transport can't send to the destination machine
    ERRUSER_ERROR_CANTFINDSOURCE,       // HomeNet transport can't find the source machine
    ERRUSER_ERROR_CANTRECEIVEFROMSOURCE,// HomeNet transport can't receive from the source machine
    ERRUSER_ERROR_INVALIDDATARECEIVED,  // HomeNet transport received invalid data from the source machine
    ERRUSER_ERROR_CANTUNPACKIMAGE,      // Transport can't unpack loaded image. This might be a disk space problem.
    ERRUSER_ERROR_CANTRESTOREOBJECT,    // Failed to restore some object on the destination machine.
    ERRUSER_ERROR_DISKSPACE,            // The user might not have enough disk space.
    ERRUSER_ERROR_NOENCRYPTION,         // There is no encryption available. HomeNet won't work.
    ERRUSER_WARNING_OUTLOOKRULES,       // The user must retouch their Outlook message rules.
    ERRUSER_WARNING_OERULES,            // The user must retouch their Outlook Express message rules.
} ERRUSER_ERROR, *PERRUSER_ERROR;

typedef enum {
    ERRUSER_AREA_UNKNOWN = 0,
    ERRUSER_AREA_INIT,
    ERRUSER_AREA_GATHER,
    ERRUSER_AREA_SAVE,
    ERRUSER_AREA_LOAD,
    ERRUSER_AREA_RESTORE,
} ERRUSER_AREA, *PERRUSER_AREA;

typedef struct {
    ERRUSER_ERROR Error;
    ERRUSER_AREA ErrorArea;
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;
} ERRUSER_EXTRADATA, *PERRUSER_EXTRADATA;

typedef struct {
    PSTR Key;
    UINT KeySize;
    HANDLE Event;
} PASSWORD_DATA, *PPASSWORD_DATA;

typedef struct {
    PCTSTR Question;
    UINT MessageStyle;
    INT WantedResult;
} QUESTION_DATA, *PQUESTION_DATA;

// These are the subphases for the transport phase. They are
// used to update the app about the transport modules status.
#define SUBPHASE_CONNECTING1    1
#define SUBPHASE_CONNECTING2    2
#define SUBPHASE_NETPREPARING   3
#define SUBPHASE_PREPARING      4
#define SUBPHASE_COMPRESSING    5
#define SUBPHASE_TRANSPORTING   6
#define SUBPHASE_MEDIAWRITING   7
#define SUBPHASE_FINISHING      8
#define SUBPHASE_CABLETRANS     9
#define SUBPHASE_UNCOMPRESSING  10

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Macro expansion definition
//

// None

//
// Public function declarations
//

// None

//
// ANSI/UNICODE macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\guitrans\homenetp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    homenetp.h

Abstract:

    Header file for functions shared in home network transport.

Author:

    Jim Schmidt (jimschm) 03-Jul-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "logmsg.h"

//
// Strings
//

#define S_TRANSPORT_DAT_FILE    TEXT("TRANSDB.DAT")
#define S_TRANSPORT_IMG_FILE    TEXT("IMG%05X.DAT")


//
// Constants
//

#define GLOBALKEY_SIZE  8

#define HOMENETTR_SIG   0x55534D32  //USM2

#define TRSTATUS_DIRTY  0x00000001
#define TRSTATUS_READY  0x00000002
#define TRSTATUS_LOCKED 0x00000003

#define TRFLAG_FILE     0x01
#define TRFLAG_MEMORY   0x02

#define MESSAGE_ERROR               0x0000
#define MESSAGE_FILE                0x0001
#define MESSAGE_DONE                0x0002
#define MESSAGE_KEEP_ALIVE          0x0003
#define MESSAGE_DATA                0x0004
#define MESSAGE_PASSWORDWRONG       0x0005
#define MESSAGE_PASSWORDOK          0x0006
#define MESSAGE_CANCEL              0x0007

#define MAX_SOCKADDR                (max(sizeof(SOCKADDR_IN),max(sizeof(SOCKADDR_IPX),sizeof(SOCKADDR_NB))))


//
// Macros
//

// None

//
// Types
//

#pragma pack(push,1)

typedef struct {
    WORD PacketNumber;
    WORD DataLength;
} DATAGRAM_PACKET, *PDATAGRAM_PACKET;

#pragma pack(pop)

typedef struct TAG_DATAGRAM_POOL_ITEM {
    struct TAG_DATAGRAM_POOL_ITEM *Next, *Prev;
    DATAGRAM_PACKET Header;
    PCBYTE PacketData;
    // PacketData follows
} DATAGRAM_POOL_ITEM, *PDATAGRAM_POOL_ITEM;

typedef struct {
    PMHANDLE Pool;
    PDATAGRAM_POOL_ITEM FirstItem;
    WORD SendSequenceNumber;
    WORD RecvSequenceNumber;
    UINT LastPacketNumber;
} DATAGRAM_POOL, *PDATAGRAM_POOL;

typedef struct {
    SOCKET Socket;
    BYTE LocalAddress[MAX_SOCKADDR];
    INT LocalAddressLen;
    BYTE RemoteAddress[MAX_SOCKADDR];
    INT RemoteAddressLen;
    INT Family;
    INT Protocol;
    DATAGRAM_POOL DatagramPool;
    BOOL Datagram;
    UINT LastSend;
    UINT KeepAliveSpacing;
} CONNECTIONSOCKET, *PCONNECTIONSOCKET;

typedef struct {
    BYTE LocalAddress[MAX_SOCKADDR];
    INT LocalAddressLen;
    BYTE RemoteAddress[MAX_SOCKADDR];
    INT RemoteAddressLen;
    INT Family;
    INT Protocol;
    BOOL Datagram;
    TCHAR DestinationName[MAX_COMPUTER_NAME];
} CONNECTADDRESS, *PCONNECTADDRESS;

typedef struct {
    UINT StructSize;
    DWORD Signature;
    UINT FileCount;
    LONGLONG TotalSize;
    TCHAR SourceName[MAX_COMPUTER_NAME];
} TRANSFERMETRICS, *PTRANSFERMETRICS;

//
// Globals
//

extern PCTSTR g_TransportTempDir;
extern PCTSTR g_StatusFile;
extern HANDLE g_StatusFileHandle;
extern UINT g_Platform;
extern TRANSFERMETRICS g_Metrics;
extern CONNECTIONSOCKET g_Connection;
extern BOOL g_CompressData;
extern HANDLE g_BackgroundThread;
extern HANDLE g_BackgroundThreadTerminate;
extern MIG_PROGRESSSLICEID g_DownloadSlice;
extern UINT g_DownloadTicks;
extern UINT g_DownloadSliceSize;
extern CHAR g_GlobalKey [GLOBALKEY_SIZE + 1];

//
// Macro expansion list
//

// None

//
// Public function prototypes
//

BOOL
FindDestination (
    OUT     PCONNECTADDRESS Address,
    IN      UINT Timeout,               OPTIONAL
    IN      BOOL IgnoreMultipleDests
    );

BOOL
TestConnection (
    IN      PCONNECTADDRESS Address
    );

BOOL
ConnectToDestination (
    IN      PCONNECTADDRESS Address,
    IN      PTRANSFERMETRICS Metrics,
    OUT     PCONNECTIONSOCKET Connection
    );

DWORD
SendMessageToDestination (
    IN      PCONNECTIONSOCKET Connection,
    IN      DWORD Message
    );

BOOL
SendFileToDestination (
    IN      PCONNECTIONSOCKET Connection,
    IN      PCTSTR LocalPath,                   OPTIONAL
    IN      PCTSTR DestSubPath                  OPTIONAL
    );

BOOL
SendDataToDestination (
    IN      PCONNECTIONSOCKET Connection,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

BOOL
ConnectToSource (
    OUT     PCONNECTIONSOCKET Connection,
    OUT     PTRANSFERMETRICS Metrics
    );

DWORD
ReceiveFromSource (
    IN      PCONNECTIONSOCKET Connection,
    IN      PCTSTR LocalFileRoot,
    OUT     PBYTE *Buffer,
    IN      UINT Timeout    OPTIONAL
    );

VOID
CloseConnection (
    IN      PCONNECTIONSOCKET Connection
    );


DWORD
GetTransportStatus (
    IN      PCTSTR TrJournal,
    OUT     PBOOL Compressed    OPTIONAL
    );

PCTSTR
BuildImageFileName (
    IN      UINT ImageIdx
    );

VOID
FreeImageFileName (
    IN      PCTSTR ImageFileName
    );

PCTSTR
CreateStorageDir (
    VOID
    );

PCTSTR
BuildDecoratedObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName
    );

VOID
DestroyDecoratedObject (
    IN      PCTSTR String
    );

PCTSTR
AllocStorageFileName (
    IN      PCTSTR FileName         OPTIONAL
    );

VOID
FreeStorageFileName (
    IN      PCTSTR NameToFree
    );

DWORD
WINAPI
DestinationBackgroundThread (
    PVOID DontCare
    );

//
// Macro expansion definition
//

// None

//
// ANSI/UNICODE macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\guitrans\guitrans.h ===
//
// Module entry points
//

// homenet
TRANSPORTINITIALIZE HomeNetTransportInitialize;
TRANSPORTQUERYCAPABILITIES HomeNetTransportQueryCapabilities;
TRANSPORTSETSTORAGE HomeNetTransportSetStorage;
TRANSPORTRESETSTORAGE HomeNetTransportResetStorage;
TRANSPORTTERMINATE HomeNetTransportTerminate;
TRANSPORTESTIMATEPROGRESSBAR HomeNetTransportEstimateProgressBar;
TRANSPORTSAVESTATE HomeNetTransportSaveState;
TRANSPORTBEGINAPPLY HomeNetTransportBeginApply;
TRANSPORTACQUIREOBJECT HomeNetTransportAcquireObject;
TRANSPORTRELEASEOBJECT HomeNetTransportReleaseObject;
TRANSPORTENDAPPLY HomeNetTransportEndApply;

// removable media
TRANSPORTINITIALIZE RmvMedTransportInitialize;
TRANSPORTQUERYCAPABILITIES RmvMedTransportQueryCapabilities;
TRANSPORTSETSTORAGE RmvMedTransportSetStorage;
TRANSPORTSAVESTATE RmvMedTransportSaveState;
TRANSPORTBEGINAPPLY RmvMedTransportBeginApply;
TRANSPORTACQUIREOBJECT RmvMedTransportAcquireObject;
TRANSPORTRELEASEOBJECT RmvMedTransportReleaseObject;
TRANSPORTENDAPPLY RmvMedTransportEndApply;
TRANSPORTTERMINATE RmvMedTransportTerminate;
TRANSPORTESTIMATEPROGRESSBAR RmvMedTransportEstimateProgressBar;

// direct cable
TRANSPORTINITIALIZE DirectCableTransportInitialize;
TRANSPORTQUERYCAPABILITIES DirectCableTransportQueryCapabilities;
TRANSPORTSETSTORAGE DirectCableTransportSetStorage;
TRANSPORTSAVESTATE DirectCableTransportSaveState;
TRANSPORTBEGINAPPLY DirectCableTransportBeginApply;
TRANSPORTACQUIREOBJECT DirectCableTransportAcquireObject;
TRANSPORTRELEASEOBJECT DirectCableTransportReleaseObject;
TRANSPORTENDAPPLY DirectCableTransportEndApply;
TRANSPORTTERMINATE DirectCableTransportTerminate;
TRANSPORTESTIMATEPROGRESSBAR DirectCableTransportEstimateProgressBar;

// opaque.c
TRANSPORTINITIALIZE OpaqueTransportInitialize;
TRANSPORTQUERYCAPABILITIES OpaqueTransportQueryCapabilities;
TRANSPORTSETSTORAGE OpaqueTransportSetStorage;
TRANSPORTSAVESTATE OpaqueTransportSaveState;
TRANSPORTBEGINAPPLY OpaqueTransportBeginApply;
TRANSPORTACQUIREOBJECT OpaqueTransportAcquireObject;
TRANSPORTRELEASEOBJECT OpaqueTransportReleaseObject;
TRANSPORTENDAPPLY OpaqueTransportEndApply;
TRANSPORTTERMINATE OpaqueTransportTerminate;
TRANSPORTESTIMATEPROGRESSBAR OpaqueTransportEstimateProgressBar;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\guitrans\netsource.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    source.c

Abstract:

    Implements the source side of the home networking transport

Author:

    Jim Schmidt (jimschm) 01-Jul-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include <winsock.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <wsnetbs.h>
#include "homenetp.h"

#define DBG_HOMENET   "HomeNet"

//
// Strings
//

#define S_TRANSPORT_DSK_FILE    TEXT("DSK%05X")
#define S_DETAILS_PREFIX        TEXT("details-")

//
// Constants
//

//
// Macros
//

// None

//
// Types
//

// none

//
// Globals
//

MIG_PROGRESSSLICEID g_PersistentSlice;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// none

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pSetTransportStatus (
    IN      HANDLE TrJournalHandle,
    IN      BOOL Compressed,
    IN      DWORD Status
    )
{
    DWORD signature = HOMENETTR_SIG;

    if (BfSetFilePointer (TrJournalHandle, 0)) {
        BfWriteFile (TrJournalHandle, (PBYTE)(&signature), sizeof (DWORD));
        BfWriteFile (TrJournalHandle, (PBYTE)(&Compressed), sizeof (BOOL));
        BfWriteFile (TrJournalHandle, (PBYTE)(&Status), sizeof (DWORD));
    }
    FlushFileBuffers (TrJournalHandle);
    return TRUE;
}


BOOL
pTransportFile (
    IN      PCTSTR LocalPath,
    IN      PCTSTR StoragePath
    )
{
    static UINT tcharsToSkip;
    BOOL b;

    if (!tcharsToSkip) {
        tcharsToSkip = TcharCount (g_TransportTempDir);
    }

    StoragePath += tcharsToSkip;
    MYASSERT (*StoragePath == TEXT('\\'));
    StoragePath++;

    b = SendFileToDestination (&g_Connection, LocalPath, StoragePath);

    DEBUGMSG_IF ((!b, DBG_ERROR, "Can't send %s to destination", LocalPath));

    return b;
}


BOOL
pHomeNetSaveDetails (
    IN      PCTSTR DecoratedObject,
    IN      PMIG_DETAILS Details
    )
{
    PCTSTR key;
    BOOL b = FALSE;

    if ((!Details) || (!Details->DetailsSize)) {
        return TRUE;
    }

    key = JoinText (S_DETAILS_PREFIX, DecoratedObject);

    if (key) {

        b = (MemDbSetUnorderedBlob (key, 0, Details->DetailsData, Details->DetailsSize) != 0);

        FreeText (key);
    }

    return b;
}

BOOL
pHomeNetAddFileToImage (
    IN      PCTSTR FileName,
    IN      PCTSTR CabName,
    IN OUT  CCABHANDLE CabHandle
    )
{
    return CabAddFileToCabinet (CabHandle, FileName, CabName);
}

BOOL
pHomeNetSaveContentInFile (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedFileName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content,
    IN OUT  CCABHANDLE CabHandle    OPTIONAL
    )
{
    BOOL result = FALSE;
    PCTSTR destPath = NULL;
    DWORD attributes = INVALID_ATTRIBUTES;

    MYASSERT (Content->ContentInFile);
    if (!Content->ContentInFile) {
        return FALSE;
    }

    //
    // Use sockets to move the file from local to storage.
    //

    __try {
        if (Content && (Content->Details.DetailsSize == sizeof (WIN32_FIND_DATAW)) && Content->Details.DetailsData) {
            attributes = ((PWIN32_FIND_DATAW)Content->Details.DetailsData)->dwFileAttributes;
        }
        if ((attributes != INVALID_ATTRIBUTES) && (attributes & FILE_ATTRIBUTE_DIRECTORY)) {

            // this must be a directory, let's just write the key
            // BUGBUG - what about zero-length files?

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

        } else {

            //
            // Get a temp file, assemble the src path, copy the file
            //

            destPath = AllocStorageFileName (NULL);
            if (!destPath) {
                DEBUGMSG ((DBG_ERROR, "Can't get storage path"));
                __leave;
            }

            if (CabHandle) {
                if (!pHomeNetAddFileToImage (
                        Content->FileContent.ContentPath,
                        GetFileNameFromPath (destPath),
                        CabHandle
                        )) {
                    __leave;
                }
            } else {
                if (!pTransportFile (Content->FileContent.ContentPath, destPath)) {
                    __leave;
                }
            }

            //
            // Keep track of where the file went
            //

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

            if (!MemDbAddSingleLinkage (DecoratedObject, GetFileNameFromPath (destPath), 0)) {
                __leave;
            }
        }

        //
        // Save details
        //

        result = pHomeNetSaveDetails (DecoratedObject, &(Content->Details));

    }
    __finally {
        FreeStorageFileName (destPath);
        INVALID_POINTER (destPath);
    }

    return result;
}

BOOL
pHomeNetSaveContentInMemory (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedObjectName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content
    )
{
    BOOL result = FALSE;

    MYASSERT (!Content->ContentInFile);
    if (Content->ContentInFile) {
        return FALSE;
    }

    MemDbSetValue (DecoratedObject, TRFLAG_MEMORY);

    if (Content->MemoryContent.ContentBytes && Content->MemoryContent.ContentSize) {

        MemDbSetUnorderedBlob (
            DecoratedObject,
            0,
            Content->MemoryContent.ContentBytes,
            Content->MemoryContent.ContentSize
            );
    }

    result = pHomeNetSaveDetails (DecoratedObject, &(Content->Details));

    return result;
}

BOOL
pHomeNetWriteAllImages (
    VOID
    )
{
    UINT imageIdx = 1;
    PCTSTR imageFile;
    BOOL result = FALSE;

    for (;;) {
        imageFile = BuildImageFileName (imageIdx);

        if (DoesFileExist (imageFile)) {
            if (!pTransportFile (imageFile, imageFile)) {
                break;
            }
        } else {
            result = TRUE;
            break;
        }

        FreeImageFileName (imageFile);
        imageIdx ++;
    }

    return result;
}

BOOL
pAskForPassword (
    OUT     PSTR Key,
    IN      UINT KeySize
    )
{
    INT_PTR appReply;
    PASSWORD_DATA passwordData;

    passwordData.Key = (PSTR)Key;
    passwordData.KeySize = KeySize;
    passwordData.Event = NULL;

    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_NET_GATHER_PASSWORD, (ULONG_PTR)&passwordData);

    return (appReply == APPRESPONSE_SUCCESS);
}

BOOL
pSaveAllState (
    IN      BOOL Compressed
    )
{
    MIG_APPINFO appInfo;
    MIG_CONTENT value;
    PMIG_CONTENT convValue;
    ULONGLONG size;
    MIG_OBJECTWITHATTRIBUTE_ENUM objEnum;
    PCTSTR ourDbFile = NULL;
    PCTSTR decoratedObject = NULL;
    ULONGLONG bytesSaved = 0;
    UINT lastTick = GetTickCount();
    UINT fraction;
    CCABHANDLE cabHandle = NULL;
    CONNECTADDRESS destination;
    DWORD nameSize;
    UINT fileCount;
    LONGLONG fileSize;
    UINT nextKeepAlive = lastTick + 60000;
    INT_PTR appReply;
    BOOL okSave = FALSE;
    TRANSCOPY_ERROR transCopyError;
    BOOL result = FALSE;
    PCTSTR statusMsg;
    PCTSTR argArray[2];
    ERRUSER_EXTRADATA extraData;
    UINT message;
    UINT numTry = 0;

    ZeroMemory (&g_Connection, sizeof (g_Connection));
    g_Connection.Socket = INVALID_SOCKET;

    ZeroMemory (&g_Metrics, sizeof (g_Metrics));
    g_Metrics.Signature = HOMENETTR_SIG;

    __try {

        nameSize = ARRAYSIZE(g_Metrics.SourceName);
        GetComputerName (g_Metrics.SourceName, &nameSize);

        if (Compressed) {

            ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
            appInfo.Phase = MIG_TRANSPORT_PHASE;
            appInfo.SubPhase = SUBPHASE_PREPARING;
            IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

            cabHandle = CabCreateCabinet (g_TransportTempDir, S_TRANSPORT_IMG_FILE, S_TRANSPORT_DSK_FILE, IsmGetTempFile, 0);
            if (!cabHandle) {
                extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        } else {

            ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
            appInfo.Phase = MIG_TRANSPORT_PHASE;
            appInfo.SubPhase = SUBPHASE_CONNECTING1;
            IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

            //
            // Connect to the destination
            //
            // NOTE: This is designed such that FindDestination can run in a background
            //       thread, allowing us to estimate the number of files at the same time
            //

            if (IsmEnumFirstPersistentObject (&objEnum)) {
                do {
                    okSave = FALSE;
                    while (!okSave) {

                        if (!IsmAcquireObjectEx (
                                objEnum.ObjectTypeId,
                                objEnum.ObjectName,
                                &value,
                                CONTENTTYPE_DETAILS_ONLY,
                                0
                                )) {

                            transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                            transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                            transCopyError.Error = GetLastError ();

                            if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                appReply = APPRESPONSE_IGNORE;
                            } else {
                                appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                if ((appReply == APPRESPONSE_NONE) ||
                                    (appReply == APPRESPONSE_FAIL)
                                    ) {
                                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    IsmAbortPersistentObjectEnum (&objEnum);
                                    __leave;
                                }
                            }
                            if (appReply == APPRESPONSE_IGNORE) {
                                LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                IsmReleaseMemory (transCopyError.ObjectName);
                                extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                extraData.ObjectName = objEnum.ObjectName;
                                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                break;
                            }
                            IsmReleaseMemory (transCopyError.ObjectName);
                            continue;
                        }
                        okSave = TRUE;
                    }

                    if (value.ContentInFile) {
                        g_Metrics.FileCount++;
                        g_Metrics.TotalSize += value.FileContent.ContentSize; // estimated
                    }
                } while (IsmEnumNextPersistentObject (&objEnum));
            }

            g_Metrics.FileCount++;        // our memdb

            if (!FindDestination (&destination, 60, FALSE)) {
                if (!IsmCheckCancel()) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_FIND_DESTINATION));
                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                }

                __leave;
            }

            if (!ConnectToDestination (&destination, &g_Metrics, &g_Connection)) {
                if (!IsmCheckCancel()) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                }
                __leave;
            }

            numTry = 0;

            do {

                // now we connected to the destination. Let's pop up a dialog asking the user to
                // type in the password that the destination has.
                if (!pAskForPassword (g_GlobalKey, 33)) {
                    // let's tell the destination computer that we are bailing out.
                    SendMessageToDestination (&g_Connection, MESSAGE_CANCEL);

                    // BUGBUG - better error message
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                    __leave;
                }

                if (!SendDataToDestination (&g_Connection, g_GlobalKey, SizeOfStringA (g_GlobalKey))) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                    __leave;
                }

                message = ReceiveFromSource (&g_Connection, NULL, NULL, 0);
                if (message == MESSAGE_PASSWORDWRONG) {
                    numTry ++;
                    if (numTry >= 3) {
                        // let's tell the destination computer that we are bailing out.
                        SendMessageToDestination (&g_Connection, MESSAGE_CANCEL);

                        // BUGBUG - better error message
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
                        extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                        extraData.ObjectTypeId = 0;
                        extraData.ObjectName = NULL;
                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                        __leave;
                    }
                }
            } while (message == MESSAGE_PASSWORDWRONG);

            if (message != MESSAGE_PASSWORDOK) {
                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
                extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        }

        //
        // Enumerate all objects with "save" attribute
        //

        if (IsmEnumFirstPersistentObject (&objEnum)) {
            do {
                //
                // Send keep-alive to connection every 30 seconds of idle time
                //

                if (!Compressed) {
                    if (GetTickCount() - g_Connection.LastSend > g_Connection.KeepAliveSpacing) {
                        SendMessageToDestination (&g_Connection, MESSAGE_KEEP_ALIVE);
                    }
                }

                //
                // For each object to be saved, do the appropriate
                // data copy action
                //

                okSave = FALSE;
                while (!okSave) {

                    if (!IsmAcquireObjectEx (
                            objEnum.ObjectTypeId,
                            objEnum.ObjectName,
                            &value,
                            CONTENTTYPE_ANY,
                            0
                            )) {

                        transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                        transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                        transCopyError.Error = GetLastError ();

                        if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                            appReply = APPRESPONSE_IGNORE;
                        } else {
                            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                            if ((appReply == APPRESPONSE_NONE) ||
                                (appReply == APPRESPONSE_FAIL)
                                ) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                IsmReleaseMemory (transCopyError.ObjectName);
                                extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                extraData.ObjectName = objEnum.ObjectName;
                                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                IsmAbortPersistentObjectEnum (&objEnum);
                                __leave;
                            }
                        }
                        if (appReply == APPRESPONSE_IGNORE) {
                            LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                            IsmReleaseMemory (transCopyError.ObjectName);
                            extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                            extraData.ErrorArea = ERRUSER_AREA_SAVE;
                            extraData.ObjectTypeId = objEnum.ObjectTypeId;
                            extraData.ObjectName = objEnum.ObjectName;
                            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                            break;
                        }
                        IsmReleaseMemory (transCopyError.ObjectName);
                        continue;
                    }
                    okSave = TRUE;
                }

                if (okSave) {

#ifdef UNICODE
                    convValue = &value;
#else
                    // now let's convert this object content to UNICODE
                    convValue = IsmConvertObjectContentToUnicode (objEnum.ObjectTypeId, objEnum.ObjectName, &value);
                    if (!convValue) {
                        convValue = &value;
                    }
#endif
                    decoratedObject = BuildDecoratedObject (objEnum.ObjectTypeId, objEnum.ObjectName);

                    ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
                    appInfo.Phase = MIG_TRANSPORT_PHASE;
                    if (Compressed) {
                        appInfo.SubPhase = SUBPHASE_COMPRESSING;
                    } else {
                        appInfo.SubPhase = SUBPHASE_TRANSPORTING;
                    }
                    appInfo.ObjectTypeId = (objEnum.ObjectTypeId & (~PLATFORM_MASK));
                    appInfo.ObjectName = objEnum.ObjectName;
                    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

                    if (convValue->ContentInFile) {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pHomeNetSaveContentInFile (
                                    objEnum.ObjectTypeId,
                                    objEnum.ObjectName,
                                    decoratedObject,
                                    convValue,
                                    cabHandle
                                    )) {

                                if (GetLastError () == ERROR_NETWORK_UNREACHABLE) {
                                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
                                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = 0;
                                    extraData.ObjectName = NULL;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    IsmAbortPersistentObjectEnum (&objEnum);
                                    __leave;
                                }

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                        size = convValue->FileContent.ContentSize;
                    } else {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pHomeNetSaveContentInMemory (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue)) {

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                        size = convValue->MemoryContent.ContentSize;
                    }

#ifndef UNICODE
                    if (convValue != (&value)) {
                        IsmFreeConvertedObjectContent (objEnum.ObjectTypeId, convValue);
                    }
#endif
                    IsmReleaseObject (&value);

                    DestroyDecoratedObject (decoratedObject);
                    decoratedObject = NULL;
                }

                IsmTickProgressBar (g_PersistentSlice, 1);

                //
                // Send bytes saved to app every 3 seconds
                //

                bytesSaved += size;

                if (GetTickCount() - lastTick > 3000) {

                    if (bytesSaved < 1048576) {

                        argArray[0] = (PCTSTR) (UINT_PTR) (bytesSaved / 1024);
                        statusMsg = ParseMessageID (MSG_SAVED_K, argArray);

                    } else if (bytesSaved < 8388608) {

                        fraction = (UINT) (bytesSaved / 10485);
                        argArray[0] = (PCTSTR) (UINT_PTR) (fraction / 100);
                        argArray[1] = (PCTSTR) (UINT_PTR) (fraction % 100);
                        statusMsg = ParseMessageID (MSG_SAVED_M, argArray);

                    } else if (bytesSaved < 1073741824) {

                        argArray[0] = (PCTSTR) (UINT_PTR) (bytesSaved / 1048576);
                        statusMsg = ParseMessageID (MSG_SAVED_M2, argArray);

                    } else {

                        fraction = (UINT) (bytesSaved / 10737418);
                        argArray[0] = (PCTSTR) (UINT_PTR) (fraction / 100);
                        argArray[1] = (PCTSTR) (UINT_PTR) (fraction % 100);
                        statusMsg = ParseMessageID (MSG_SAVED_G, argArray);
                    }

                    IsmSendMessageToApp (TRANSPORTMESSAGE_SIZE_SAVED, (ULONG_PTR) statusMsg);

                    FreeStringResource (statusMsg);
                    lastTick = GetTickCount();
                }

            } while (IsmEnumNextPersistentObject (&objEnum));
        }

        ourDbFile = AllocStorageFileName (S_TRANSPORT_DAT_FILE);
        if (!ourDbFile) {
            extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        DEBUGMSG ((DBG_HOMENET, "Saving memdb"));

        BfCreateDirectory (g_TransportTempDir);
        if (!MemDbSave (ourDbFile)) {
            DEBUGMSG ((DBG_ERROR, "Can't save our database to %s", ourDbFile));
            extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        if (Compressed) {
            if (!pHomeNetAddFileToImage (ourDbFile, S_TRANSPORT_DAT_FILE, cabHandle)) {
                extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
            if (!CabFlushAndCloseCabinetEx (cabHandle, NULL, NULL, &fileCount, &fileSize)) {
                extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }

            DEBUGMSG ((DBG_HOMENET, "Compression results: files=%u size=%u", fileCount, (UINT) fileSize));
            g_Metrics.FileCount += fileCount;
            g_Metrics.TotalSize += fileSize;

            ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
            appInfo.Phase = MIG_TRANSPORT_PHASE;
            appInfo.SubPhase = SUBPHASE_CONNECTING1;
            IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

            if (!FindDestination (&destination, 0, FALSE)) {
                if (!IsmCheckCancel()) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_FIND_DESTINATION));
                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                }
                __leave;
            }

            if (!ConnectToDestination (&destination, &g_Metrics, &g_Connection)) {
                if (!IsmCheckCancel()) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                }
                __leave;
            }

            ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
            appInfo.Phase = MIG_TRANSPORT_PHASE;
            appInfo.SubPhase = SUBPHASE_FINISHING;
            IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

            if (!pHomeNetWriteAllImages ()) {
                extraData.Error = ERRUSER_ERROR_CANTSENDTODEST;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        } else {
            ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
            appInfo.Phase = MIG_TRANSPORT_PHASE;
            appInfo.SubPhase = SUBPHASE_FINISHING;
            IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

            DEBUGMSG ((DBG_HOMENET, "Transporting memdb"));

            if (!pTransportFile (ourDbFile, ourDbFile)) {
                if (GetLastError () == ERROR_NETWORK_UNREACHABLE) {
                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                    __leave;
                } else {
                    extraData.Error = ERRUSER_ERROR_CANTSENDTODEST;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                    __leave;
                }
            }
        }

        DEBUGMSG ((DBG_HOMENET, "Transporting status file"));

        pSetTransportStatus (g_StatusFileHandle, g_CompressData, TRSTATUS_READY);
        CloseHandle (g_StatusFileHandle);
        g_StatusFileHandle = INVALID_HANDLE_VALUE;

        if (!pTransportFile (g_StatusFile, g_StatusFile)) {
            if (GetLastError () == ERROR_NETWORK_UNREACHABLE) {
                extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            } else {
                extraData.Error = ERRUSER_ERROR_CANTSENDTODEST;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        }

        DEBUGMSG ((DBG_HOMENET, "Done sending files"));

        SendMessageToDestination (&g_Connection, MESSAGE_DONE);
        if (MESSAGE_DONE != ReceiveFromSource (&g_Connection, NULL, NULL, 0)) {
            if (GetLastError() != WSAECONNRESET) {
                DEBUGMSG ((DBG_ERROR, "No acknowledgement from the destination"));
                extraData.Error = ERRUSER_ERROR_CANTSENDTODEST;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        }

        IsmSendMessageToApp (TRANSPORTMESSAGE_SIZE_SAVED, 0);
        result = TRUE;

    }
    __finally {

        PushError ();

        FreeStorageFileName (ourDbFile);
        INVALID_POINTER (ourDbFile);

        DestroyDecoratedObject (decoratedObject);
        INVALID_POINTER (decoratedObject);

        CloseConnection (&g_Connection);

        PopError ();
    }

    return result;
}


BOOL
WINAPI
HomeNetTransportSaveState (
    VOID
    )
{
    ERRUSER_EXTRADATA extraData;

    g_Platform = PLATFORM_SOURCE;

    ZeroMemory (&extraData, sizeof (ERRUSER_EXTRADATA));
    extraData.Error = ERRUSER_ERROR_UNKNOWN;

    g_StatusFileHandle = BfCreateFile (g_StatusFile);
    if (g_StatusFileHandle == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_NET_STATUS_FILE));
        extraData.Error = ERRUSER_ERROR_NOTRANSPORTPATH;
        extraData.ErrorArea = ERRUSER_AREA_SAVE;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
        return FALSE;
    }

    return pSaveAllState (g_CompressData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\guitrans\opaque.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    opaque.c

Abstract:

    Implements a basic secure server transport module

Author:

    Jim Schmidt (jimschm) 08-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include <compress.h>

#define DBG_OPAQUE   "OpaqueUnc"

//
// Strings
//

#define S_TRANSPORT_DIR         TEXT("USMT2.UNC")
#define S_TRANSPORT_DAT_FILE    TEXT("TRANSDB.DAT")
#define S_TRANSPORT_IMG_FILE    TEXT("IMG%05X.DAT")
#define S_TRANSPORT_STATUS_FILE TEXT("status")
#define S_FILEOBJECT_NAME       TEXT("File")
#define S_REGOBJECT_NAME        TEXT("Registry")
#define S_DATABASEOBJECT_NAME   TEXT("Database")
#define S_DETAILS_PREFIX        TEXT("details-")

//
// Constants
//
#define TRFLAG_FILE         0x01
#define TRFLAG_MEMORY       0x02
#define COPY_BUFFER_SIZE    32768
#define OPAQUETR_OLDSIG1    0x55534D31  //USM1
#define OPAQUETR_OLDSIG2    0x55534D32  //USM1
#define OPAQUETR_SIG        0x55534D33  //USM2

#define TRSTATUS_DIRTY      0x00000001
#define TRSTATUS_READY      0x00000002
#define TRSTATUS_LOCKED     0x00000003

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR TempFile [MAX_PATH];
    PCVOID AllocPtr;
    PCVOID DetailsPtr;
    HANDLE FileHandle;
    HANDLE MapHandle;
} ALLOCSTATE, *PALLOCSTATE;

//
// Globals
//

MIG_TRANSPORTSTORAGEID g_ReliableStorageId;
PCTSTR g_TransportPath = NULL;
PCTSTR g_TransportTempPath = NULL;
PCTSTR g_TransportStatus = NULL;
HANDLE g_TransportStatusHandle = NULL;
BOOL g_OtCompressData = FALSE;
BOOL g_OtOldFormat = FALSE;
UINT g_Platform;
MIG_PROGRESSSLICEID g_PersistentSlice;
MIG_PROGRESSSLICEID g_DatabaseSlice;
UINT g_CompressedTicks;
UINT g_CompressedTicked;
MIG_PROGRESSSLICEID g_CompressedSlice;
UINT g_UncompressTicks;
UINT g_UncompressTicked;
MIG_PROGRESSSLICEID g_UncompressSlice;
LONGLONG g_TotalFiles;
LONGLONG g_FilesRead;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

BOOL
pOtSaveAllState (
    IN      BOOL Compressed
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pSetOpaqueTransportStatus (
    IN      HANDLE TrJournalHandle,
    IN      BOOL Compressed,
    IN      DWORD Status
    )
{
    DWORD signature = OPAQUETR_SIG;
    BOOL result = FALSE;

    if (BfSetFilePointer (TrJournalHandle, 0)) {
        result = TRUE;
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&signature), sizeof (DWORD));
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&Compressed), sizeof (BOOL));
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&Status), sizeof (DWORD));
        result = result && FlushFileBuffers (TrJournalHandle);
    }
    return result;
}

DWORD
pGetOpaqueTransportStatus (
    IN      PCTSTR TrJournal,
    OUT     PBOOL Compressed,   OPTIONAL
    OUT     PBOOL OldStorage,   OPTIONAL
    IN      BOOL OpenReadOnly
    )
{
    HANDLE trJrnHandle;
    BOOL compressed = FALSE;
    DWORD signature = 0;
    DWORD fileSize = 0;
    DWORD result = 0;

    if (OldStorage) {
        *OldStorage = FALSE;
    }

    if (TrJournal && TrJournal [0]) {
        if (OpenReadOnly) {
            trJrnHandle = BfOpenReadFile (TrJournal);
        } else {
            trJrnHandle = BfOpenFile (TrJournal);
        }
        if (trJrnHandle) {
            if (BfSetFilePointer (trJrnHandle, 0)) {
                fileSize = GetFileSize (trJrnHandle, NULL);
                if (fileSize == (sizeof (BOOL) + sizeof (DWORD))) {
                    if (OldStorage) {
                        *OldStorage = TRUE;
                    }
                    if (BfReadFile (trJrnHandle, (PBYTE)(&compressed), sizeof (BOOL))) {
                        BfReadFile (trJrnHandle, (PBYTE)(&result), sizeof (DWORD));
                    }
                }
                if (fileSize == (sizeof (BOOL) + sizeof (DWORD) + sizeof (DWORD))) {
                    if (BfReadFile (trJrnHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                        if (signature == OPAQUETR_SIG) {
                            if (BfReadFile (trJrnHandle, (PBYTE)(&compressed), sizeof (BOOL))) {
                                BfReadFile (trJrnHandle, (PBYTE)(&result), sizeof (DWORD));
                            }
                        }
                        if ((signature == OPAQUETR_OLDSIG1) ||
                            (signature == OPAQUETR_OLDSIG2)
                            ) {
                            if (OldStorage) {
                                *OldStorage = TRUE;
                            }
                            if (BfReadFile (trJrnHandle, (PBYTE)(&compressed), sizeof (BOOL))) {
                                BfReadFile (trJrnHandle, (PBYTE)(&result), sizeof (DWORD));
                            }
                        }
                    }
                }
            }
            CloseHandle (trJrnHandle);
        } else {
            if (GetLastError () == ERROR_ACCESS_DENIED) {
                result = TRSTATUS_LOCKED;
            }
        }
    }
    if (Compressed) {
        *Compressed = compressed;
    }
    return result;
}

PCTSTR
pGetOpaqueImageFile (
    IN      PCTSTR BasePath,
    IN      UINT ImageIdx
    )
{
    TCHAR imageFileName [13];
    PCTSTR imageFile = NULL;
    HANDLE imageFileHandle = NULL;

    wsprintf (imageFileName, S_TRANSPORT_IMG_FILE, ImageIdx);
    return JoinPaths (BasePath, imageFileName);
}

PCTSTR
pGetRealTransportPath (
    VOID
    )
{
    return g_OtCompressData?g_TransportTempPath:g_TransportPath;
}

BOOL
WINAPI
OpaqueTransportInitialize (
    IN      PMIG_LOGCALLBACK LogCallback
    )
{
    //
    // Initialize globals
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    g_ReliableStorageId = IsmRegisterTransport (S_RELIABLE_STORAGE_TRANSPORT);

    return TRUE;
}

VOID
WINAPI
OpaqueTransportEstimateProgressBar (
    MIG_PLATFORMTYPEID PlatformTypeId
    )
{
    UINT ticks;
    PMIG_OBJECTCOUNT objectCount;

    if (PlatformTypeId == PLATFORM_SOURCE) {

        //
        // If saving, we know the number of ticks based on the count of the
        // persistent attribute.
        //

        objectCount = IsmGetObjectsStatistics (PLATFORM_SOURCE);

        if (objectCount) {
            ticks = objectCount->PersistentObjects;
        } else {
            ticks = 0;
        }

        g_PersistentSlice = IsmRegisterProgressSlice (ticks, max (1, ticks / 5));

        if (g_OtCompressData) {
            g_DatabaseSlice = IsmRegisterProgressSlice (3, 1);
        } else {
            g_DatabaseSlice = IsmRegisterProgressSlice (1, 1);
        }

    } else {
        if (g_OtCompressData) {
            g_UncompressTicked = 0;
            g_UncompressTicks = 1000;
            g_UncompressSlice = IsmRegisterProgressSlice (g_UncompressTicks, 180);
        } else {
            //
            // If restoring, we have almost no work to account for, since
            // we download from the secure server file-by-file.
            //

            DEBUGMSG ((DBG_VERBOSE, "Assuming transport download has no progress impact"));
        }
    }
}

BOOL
WINAPI
OpaqueTransportQueryCapabilities (
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    OUT     PMIG_TRANSPORTTYPE TransportType,
    OUT     PMIG_TRANSPORTCAPABILITIES Capabilities,
    OUT     PCTSTR *FriendlyDescription
    )
{
    if (TransportStorageId != g_ReliableStorageId) {
        return FALSE;
    }

    *TransportType = TRANSPORTTYPE_FULL;
    *Capabilities = CAPABILITY_COMPRESSED;
    *FriendlyDescription = TEXT("Local computer or another computer on the Network");
    return TRUE;
}

VOID
pOtCleanUpTempDir (
    VOID
    )
{
    if (g_TransportTempPath) {
        FiRemoveAllFilesInTree (g_TransportTempPath);
    }
}

PCTSTR
pOtCreateTemporaryDir (
    VOID
    )
{
    TCHAR tempFile[MAX_PATH];

    if (!IsmGetTempDirectory (tempFile, ARRAYSIZE(tempFile))) {
        return NULL;
    }
    return DuplicatePathString (tempFile, 0);
}

BOOL
WINAPI
OpaqueTransportSetStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL Valid,
    OUT     PBOOL ImageExists
    )
{
    PCTSTR lastDirPtr = NULL;
    PCTSTR transportPath = NULL;
    PCTSTR transportStatus = NULL;
    HANDLE transportStatusHandle = INVALID_HANDLE_VALUE;
    MIG_OBJECTSTRINGHANDLE encodedPath;
    DWORD status;
    BOOL result = FALSE;

    if (Valid) {
        *Valid = FALSE;
    }
    if (ImageExists) {
        *ImageExists = FALSE;
    }

    if (TransportStorageId == g_ReliableStorageId) {

        if ((!RequiredCapabilities) || (RequiredCapabilities == CAPABILITY_COMPRESSED)) {

            if (RequiredCapabilities == CAPABILITY_COMPRESSED) {
                g_OtCompressData = TRUE;
            } else {
                g_OtCompressData = FALSE;
            }

            // If this is the destination, let's check if the user included USMT2.UNC in
            // the path by mistake. If he did (the StoragePath ends in USMT2.UNC and
            // StoragePath has our transport status) we will accept it.
            if (Platform == PLATFORM_DESTINATION) {
                lastDirPtr = _tcsrchr (StoragePath, TEXT('\\'));
                if (lastDirPtr) {
                    lastDirPtr = _tcsinc (lastDirPtr);
                    if (lastDirPtr) {
                        if (StringIMatch (lastDirPtr, S_TRANSPORT_DIR)) {
                            transportPath = DuplicatePathString (StoragePath, 0);
                            transportStatus = JoinPaths (transportPath, S_TRANSPORT_STATUS_FILE);
                            if ((!DoesFileExist (transportPath)) ||
                                (pGetOpaqueTransportStatus (transportStatus, NULL, NULL, TRUE) != TRSTATUS_READY)
                                ) {
                                FreePathString (transportPath);
                                transportPath = NULL;
                                FreePathString (transportStatus);
                                transportStatus = NULL;
                            }
                        }
                    }
                }
            }

            if (!transportPath) {
                transportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR);
            }
            if (!transportStatus) {
                transportStatus = JoinPaths (transportPath, S_TRANSPORT_STATUS_FILE);
            }

            if (!DoesFileExist (transportPath)) {

                // we require UNC path or a full path (like c:\...)
                if (transportPath[0] == '\\' && transportPath[1] == '\\') {
                    // this is a UNC path
                    *Valid = TRUE;
                } else if (transportPath[1] == ':') {
                    // this is a normal full path
                    *Valid = TRUE;
                } else {
                    *Valid = FALSE;
                }

                if ((*Valid) && (Platform == PLATFORM_SOURCE)) {
                    // we need to actually try to create our transport directory and the status file
                    // After that we will remove them but this is just the way for us to validate the
                    // store

                    *Valid = FALSE;
                    if (BfCreateDirectory (transportPath)) {
                        transportStatusHandle = BfCreateFile (transportStatus);
                        if (transportStatusHandle) {
                            *Valid = TRUE;
                            CloseHandle (transportStatusHandle);
                        }
                        PushError ();
                        FiRemoveAllFilesInTree (transportPath);
                        PopError ();
                    }
                }

                *ImageExists = FALSE;

            } else {

                // we try to open this transport status file with Read/Write. If we
                // fail this is either because somebody has it opened or we don't
                // have access rights. In both cases we should get back TRSTATUS_LOCKED

                status = pGetOpaqueTransportStatus (transportStatus, NULL, NULL, TRUE);

                switch (status) {
                case TRSTATUS_LOCKED:
                    *ImageExists = TRUE;
                    *Valid = FALSE;
                    break;
                case TRSTATUS_READY:
                    *ImageExists = TRUE;
                    *Valid = TRUE;
                    break;
                case TRSTATUS_DIRTY:
                    *ImageExists = FALSE;
                    *Valid = TRUE;
                    break;
                default:
                    *ImageExists = FALSE;
                    *Valid = TRUE;
                }
            }

            result = TRUE;
        }
    }

    if (result && *Valid) {

        if (g_TransportPath) {
            FreePathString (g_TransportPath);
            g_TransportPath = NULL;
        }

        if (g_TransportStatus) {
            FreePathString (g_TransportStatus);
            g_TransportStatus = NULL;
        }

        if (transportPath) {
            g_TransportPath = transportPath;
        } else {
            g_TransportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR);
        }
        if (transportStatus) {
            g_TransportStatus = transportStatus;
        } else {
            g_TransportStatus = JoinPaths (g_TransportPath, S_TRANSPORT_STATUS_FILE);
        }

        encodedPath = IsmCreateSimpleObjectPattern (g_TransportPath, FALSE, NULL, FALSE);
        if (encodedPath) {
            IsmRegisterStaticExclusion (MIG_FILE_TYPE, encodedPath);
            IsmDestroyObjectHandle (encodedPath);
        }
    }

    return result;
}

BOOL
WINAPI
OpaqueTransportSaveState (
    VOID
    )
{
    MIG_APPINFO appInfo;
    ERRUSER_EXTRADATA extraData;
    DWORD status;
    BOOL result = FALSE;
    BOOL allowDelete = FALSE;

    ZeroMemory (&extraData, sizeof (ERRUSER_EXTRADATA));
    extraData.Error = ERRUSER_ERROR_UNKNOWN;

    __try {

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_PREPARING;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        if (!g_TransportPath) {
            DEBUGMSG ((DBG_ERROR, "Transport Path is not selected"));
            extraData.Error = ERRUSER_ERROR_NOTRANSPORTPATH;
            __leave;
        }

        if (DoesFileExist (g_TransportPath)) {

            status = pGetOpaqueTransportStatus (g_TransportStatus, NULL, NULL, FALSE);

            switch (status) {
            case TRSTATUS_LOCKED:
                SetLastError (ERROR_ACCESS_DENIED);
                LOG ((LOG_ERROR, (PCSTR) MSG_TRANSPORT_DIR_BUSY, g_TransportPath));
                extraData.Error = ERRUSER_ERROR_TRANSPORTPATHBUSY;
                __leave;
            case TRSTATUS_DIRTY:
                result = FiRemoveAllFilesInTree (g_TransportPath);
                if (!result) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_EMPTY_DIR, g_TransportPath));
                    extraData.Error = ERRUSER_ERROR_CANTEMPTYDIR;
                    __leave;
                }
                break;
            case TRSTATUS_READY:
            default:
                if (IsmSendMessageToApp (TRANSPORTMESSAGE_IMAGE_EXISTS, 0)) {
                    if (!FiRemoveAllFilesInTree (g_TransportPath)) {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_EMPTY_DIR, g_TransportPath));
                        extraData.Error = ERRUSER_ERROR_CANTEMPTYDIR;
                        __leave;
                    }
                } else {
                    LOG ((LOG_ERROR, (PCSTR) MSG_NOT_EMPTY, g_TransportPath));
                    SetLastError (ERROR_ALREADY_EXISTS);
                    extraData.Error = ERRUSER_ERROR_ALREADYEXISTS;
                    __leave;
                }
                break;
            }
        }

        allowDelete = TRUE;

        if (!BfCreateDirectory (g_TransportPath)) {
            PushError ();
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_DIR, g_TransportPath));
            PopError ();
            extraData.Error = ERRUSER_ERROR_CANTCREATEDIR;
            __leave;
        }

        g_TransportStatusHandle = BfCreateFile (g_TransportStatus);
        if (!g_TransportStatusHandle) {
            PushError ();
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_STATUS_FILE, g_TransportStatus));
            PopError ();
            extraData.Error = ERRUSER_ERROR_CANTCREATESTATUS;
            __leave;
        }

        result = pSetOpaqueTransportStatus (g_TransportStatusHandle, g_OtCompressData, TRSTATUS_DIRTY);
        if (!result) {
            PushError ();
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_STATUS_FILE, g_TransportStatus));
            PopError ();
            extraData.Error = ERRUSER_ERROR_CANTCREATESTATUS;
            __leave;
        }

        g_Platform = PLATFORM_SOURCE;
        result = pOtSaveAllState (g_OtCompressData);

        if (result) {
            result = result && pSetOpaqueTransportStatus (g_TransportStatusHandle, g_OtCompressData, TRSTATUS_READY);
        }

        result = result && FlushFileBuffers (g_TransportStatusHandle);
        result = result && CloseHandle (g_TransportStatusHandle);
        if (result) {
            g_TransportStatusHandle = NULL;
        }
    }
    __finally {
        PushError ();
        if (g_TransportStatusHandle) {
            // if we got here there was some error. Let's just close the handle
            CloseHandle (g_TransportStatusHandle);
        }
        if (allowDelete && (!result)) {
            FiRemoveAllFilesInTree (g_TransportPath);
        }
        PopError ();
    }

    PushError ();

    if (!result) {
        extraData.ErrorArea = ERRUSER_AREA_SAVE;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
    }

    PopError ();

    return result;
}

PCTSTR
pOpaqueGetNewFileName (
    IN      PCTSTR FileName
    )
{
    PCTSTR newFileName = NULL;
    PTSTR tempPtr1 = NULL;
    PCTSTR endStr1 = NULL;
    PCTSTR tempPtr2 = NULL;
    PCTSTR endStr2 = NULL;
    INT i;

    // let's modify the file to extract. The file name will
    // be split in 2 after the first 5 characters
    newFileName = DuplicatePathString (FileName, 1);
    if (!newFileName) {
        return NULL;
    }
    tempPtr1 = (PTSTR) GetFileNameFromPath (newFileName);
    if (!tempPtr1) {
        FreePathString (newFileName);
        return NULL;
    }
    endStr1 = GetEndOfString (newFileName);
    if (!endStr1) {
        FreePathString (newFileName);
        return NULL;
    }
    tempPtr2 = GetFileNameFromPath (FileName);
    if (!tempPtr2) {
        FreePathString (newFileName);
        return NULL;
    }
    endStr2 = GetEndOfString (FileName);
    if (!endStr2) {
        FreePathString (newFileName);
        return NULL;
    }
    for (i = 0; i < 5; i ++) {
        tempPtr1 = _tcsinc (tempPtr1);
        tempPtr2 = _tcsinc (tempPtr2);
    }

    if ((tempPtr1 < endStr1) &&
        (tempPtr2 < endStr2)
        ) {
        StringCopy (tempPtr1, TEXT("\\"));
        tempPtr1 = _tcsinc (tempPtr1);
        StringCopy (tempPtr1, tempPtr2);
    } else {
        FreePathString (newFileName);
        newFileName = NULL;
    }
    return newFileName;
}

BOOL
pOpaqueCallback (
    IN      PCTSTR FileToExtract,
    IN      LONGLONG FileSize,
    OUT     PBOOL ExtractFile,
    IN OUT  PCTSTR *NewFileName
    )
{
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;

    if (NewFileName) {
        *NewFileName = pOpaqueGetNewFileName (FileToExtract);
    }

    g_FilesRead ++;
    // now update the progress bar
    numerator = (LONGLONG) g_FilesRead * (LONGLONG) g_UncompressTicks;
    divisor = (LONGLONG) g_TotalFiles;
    if (divisor) {
        tick = numerator / divisor;
    } else {
        tick = 0;
    }
    delta = (UINT) tick - g_UncompressTicked;
    if (delta) {
        IsmTickProgressBar (g_UncompressSlice, delta);
        g_UncompressTicked += delta;
    }

    if (ExtractFile) {
        *ExtractFile = TRUE;
    }

    return (!IsmCheckCancel());
}

BOOL
pOtReadAllImages (
    VOID
    )
{
    COMPRESS_HANDLE compressedHandle;
    BOOL result = FALSE;

    if (CompressOpenHandle (g_TransportPath, S_TRANSPORT_IMG_FILE, 1, &compressedHandle)) {
        g_TotalFiles = compressedHandle.FilesStored;
        if (CompressExtractAllFiles (g_TransportTempPath, &compressedHandle, pOpaqueCallback)) {
            result = TRUE;
        }
        CompressCleanupHandle (&compressedHandle);
    }

    return result;
}

BOOL
WINAPI
OpaqueTransportBeginApply (
    VOID
    )
{
    ERRUSER_EXTRADATA extraData;
    DWORD status = 0;
    PCTSTR memDbFile;
    INT_PTR appReply;
    PCTSTR newTransDbFile = NULL;
    BOOL result = FALSE;

    g_Platform = PLATFORM_DESTINATION;

    ZeroMemory (&extraData, sizeof (ERRUSER_EXTRADATA));
    extraData.Error = ERRUSER_ERROR_UNKNOWN;

    __try {
        if (!g_TransportPath) {
            DEBUGMSG ((DBG_ERROR, "Transport Path is not selected"));
            extraData.Error = ERRUSER_ERROR_NOTRANSPORTPATH;
            __leave;
        }

        while (status != TRSTATUS_READY) {

            status = pGetOpaqueTransportStatus (g_TransportStatus, &g_OtCompressData, &g_OtOldFormat, TRUE);

            switch (status) {
            case TRSTATUS_LOCKED:
                if (!IsmSendMessageToApp (TRANSPORTMESSAGE_IMAGE_LOCKED, 0)) {
                    SetLastError (ERROR_ACCESS_DENIED);
                    LOG ((LOG_ERROR, (PCSTR) MSG_TRANSPORT_DIR_BUSY, g_TransportPath));
                    extraData.Error = ERRUSER_ERROR_TRANSPORTPATHBUSY;
                    __leave;
                }
                break;
            case TRSTATUS_DIRTY:
                SetLastError (ERROR_INVALID_DATA);
                LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_IMAGE, g_TransportPath));
                extraData.Error = ERRUSER_ERROR_TRANSPORTINVALIDIMAGE;
                __leave;
            case TRSTATUS_READY:
                break;
            default:
                SetLastError (ERROR_INVALID_DATA);
                LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_IMAGE, g_TransportPath));
                extraData.Error = ERRUSER_ERROR_TRANSPORTINVALIDIMAGE;
                __leave;
            }
        }

        if (g_OtOldFormat) {
            IsmSendMessageToApp (TRANSPORTMESSAGE_OLD_STORAGE, 0);
            SetLastError (ERROR_INVALID_DATA);
            LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_IMAGE, g_TransportPath));
            extraData.Error = ERRUSER_ERROR_TRANSPORTINVALIDIMAGE;
            __leave;
        }

        g_TransportStatusHandle = BfOpenReadFile (g_TransportStatus);
        if (!g_TransportStatusHandle) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_STATUS_FILE, g_TransportStatus));
            extraData.Error = ERRUSER_ERROR_CANTOPENSTATUS;
            __leave;
        }

        if (g_OtCompressData) {
            g_TransportTempPath = pOtCreateTemporaryDir ();

            if (!g_TransportTempPath) {
                CloseHandle (g_TransportStatusHandle);
                g_TransportStatusHandle = NULL;
                extraData.Error = ERRUSER_ERROR_CANTCREATETEMPDIR;
                __leave;
            }

            if (!pOtReadAllImages ()) {
                CloseHandle (g_TransportStatusHandle);
                g_TransportStatusHandle = NULL;
                extraData.Error = ERRUSER_ERROR_CANTUNPACKIMAGE;
                __leave;
            }
            CloseHandle (g_TransportStatusHandle);
            g_TransportStatusHandle = NULL;
        }

        newTransDbFile = pOpaqueGetNewFileName (S_TRANSPORT_DAT_FILE);

        memDbFile = JoinPaths (pGetRealTransportPath (), newTransDbFile?newTransDbFile:S_TRANSPORT_DAT_FILE);

        if (newTransDbFile) {
            FreePathString (newTransDbFile);
            newTransDbFile = NULL;
        }

        result = MemDbLoad (memDbFile);
        if (!result) {
            extraData.Error = ERRUSER_ERROR_CANTREADIMAGE;
        }
        FreePathString (memDbFile);
    }
    __finally {
    }

    if (!result) {
        extraData.ErrorArea = ERRUSER_AREA_LOAD;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
    }

    return result;
}

VOID
WINAPI
OpaqueTransportEndApply (
    VOID
    )
{
    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    if (g_OtCompressData) {
        pOtCleanUpTempDir ();
    } else {
        CloseHandle (g_TransportStatusHandle);
        g_TransportStatusHandle = NULL;
    }
}

VOID
WINAPI
OpaqueTransportTerminate (
    VOID
    )
{
    pOtCleanUpTempDir();

    if (g_TransportTempPath) {
        FreePathString (g_TransportTempPath);
        g_TransportTempPath = NULL;
    }
    if (g_TransportStatus) {
        FreePathString (g_TransportStatus);
        g_TransportStatus = NULL;
    }
    if (g_TransportPath) {
        FreePathString (g_TransportPath);
        g_TransportPath = NULL;
    }
}

static
VOID
pGetTempFileName (
    OUT     PTSTR Buffer
    )
{
    static fileIndex = 0;

    fileIndex ++;
    wsprintf (Buffer, TEXT("%08X.DAT"), fileIndex);
}

PCTSTR
pOpaqueAllocStorageFileName (
    IN      PCTSTR FileName         OPTIONAL
    )
{
    TCHAR buffer[32];

    if (FileName) {
        StringCopy (buffer, FileName);
    } else {
        pGetTempFileName (buffer);
    }

    return JoinPaths (g_TransportPath, buffer);
}

VOID
pFreeStorageFileName (
    IN      PCTSTR FileName
    )
{
    FreePathString (FileName);
}

BOOL
pOpaqueSaveDetails (
    IN      PCTSTR DecoratedObject,
    IN      PMIG_DETAILS Details
    )
{
    PCTSTR key;
    BOOL b = FALSE;

    if ((!Details) || (!Details->DetailsSize)) {
        return TRUE;
    }

    key = JoinText (S_DETAILS_PREFIX, DecoratedObject);

    if (key) {

        b = (MemDbSetUnorderedBlob (key, 0, Details->DetailsData, Details->DetailsSize) != 0);

        FreeText (key);
    }

    return b;
}

BOOL
pOtAddFileToImage (
    IN      PCTSTR FileName,
    IN      PCTSTR StoredName,
    IN OUT  PCOMPRESS_HANDLE CompressedHandle
    )
{
    return CompressAddFileToHandle (FileName, StoredName, CompressedHandle);
}

BOOL
pOtSaveContentInFile (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedFileName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content,
    IN OUT  PCOMPRESS_HANDLE CompressedHandle    OPTIONAL
    )
{
    BOOL result = FALSE;
    PCTSTR destPath = NULL;
    DWORD attributes = INVALID_ATTRIBUTES;

    MYASSERT (Content->ContentInFile);
    if (!Content->ContentInFile) {
        return FALSE;
    }

    //
    // Use the CopyFile API to move the file from local to storage.
    //

    __try {
        if (Content && (Content->Details.DetailsSize == sizeof (WIN32_FIND_DATAW)) && Content->Details.DetailsData) {
            attributes = ((PWIN32_FIND_DATAW)Content->Details.DetailsData)->dwFileAttributes;
        }
        if ((attributes != INVALID_ATTRIBUTES) && (attributes & FILE_ATTRIBUTE_DIRECTORY)) {

            // this must be a directory, let's just write the key

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

        } else {

            //
            // Get a temp file, assemble the src path, copy the file
            //

            destPath = pOpaqueAllocStorageFileName (NULL);
            if (!destPath) {
                __leave;
            }

            if (CompressedHandle) {
                if (!pOtAddFileToImage (Content->FileContent.ContentPath, GetFileNameFromPath (destPath), CompressedHandle)) {
                    __leave;
                }
            } else {
                if (!CopyFile (Content->FileContent.ContentPath, destPath, FALSE)) {
                    __leave;
                }
            }

            //
            // Keep track of where the file went
            //

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

            if (!MemDbAddSingleLinkage (DecoratedObject, GetFileNameFromPath (destPath), 0)) {
                __leave;
            }
        }

        //
        // Save details
        //

        result = pOpaqueSaveDetails (DecoratedObject, &(Content->Details));

    }
    __finally {
        pFreeStorageFileName (destPath);
        INVALID_POINTER (destPath);
    }

    return result;
}

BOOL
pOtSaveContentInMemory (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedObjectName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content
    )
{
    BOOL result = FALSE;

    MYASSERT (!Content->ContentInFile);
    if (Content->ContentInFile) {
        return FALSE;
    }

    MemDbSetValue (DecoratedObject, TRFLAG_MEMORY);

    if (Content->MemoryContent.ContentBytes && Content->MemoryContent.ContentSize) {

        MemDbSetUnorderedBlob (
            DecoratedObject,
            0,
            Content->MemoryContent.ContentBytes,
            Content->MemoryContent.ContentSize
            );
    }

    result = pOpaqueSaveDetails (DecoratedObject, &(Content->Details));

    return result;
}

PCTSTR
pOpaqueBuildDecoratedObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName
    )
{
    TCHAR prefix[32];

    wsprintf (prefix, TEXT("%u"), ObjectTypeId);

    return JoinPaths (prefix, ObjectName);
}

VOID
pOtDestroyDecoratedObject (
    IN      PCTSTR String
    )
{
    FreePathString (String);
}

BOOL
pOtSaveAllState (
    IN      BOOL Compressed
    )
{
    MIG_APPINFO appInfo;
    MIG_CONTENT value;
    PMIG_CONTENT convValue;
    ULONGLONG size;
    MIG_OBJECTWITHATTRIBUTE_ENUM objEnum;
    PCTSTR ourDbFile = NULL;
    PCTSTR decoratedObject = NULL;
    ULONGLONG bytesSaved = 0;
    UINT lastTick = GetTickCount();
    TCHAR text[64];
    UINT fraction;
    COMPRESS_HANDLE compressedHandle;
    INT_PTR appReply;
    BOOL okSave = FALSE;
    TRANSCOPY_ERROR transCopyError;
    ERRUSER_EXTRADATA extraData;
    BOOL result = FALSE;

    __try {

        ZeroMemory (&compressedHandle, sizeof (COMPRESS_HANDLE));

        if (Compressed) {
            g_TransportTempPath = pOtCreateTemporaryDir ();

            if (!g_TransportTempPath) {
                extraData.Error = ERRUSER_ERROR_CANTCREATETEMPDIR;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }

            if (!CompressCreateHandle (g_TransportPath, S_TRANSPORT_IMG_FILE, 1, 0, &compressedHandle)) {
                extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        }

        //
        // Enumerate all objects with "save" attribute
        //

        if (IsmEnumFirstPersistentObject (&objEnum)) {
            do {
                //
                // For each object to be saved, do the appropriate
                // data copy action
                //

                okSave = FALSE;
                while (!okSave) {

                    if (!IsmAcquireObjectEx (
                            objEnum.ObjectTypeId,
                            objEnum.ObjectName,
                            &value,
                            CONTENTTYPE_ANY,
                            0
                            )) {

                        transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                        transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                        transCopyError.Error = GetLastError ();

                        if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                            appReply = APPRESPONSE_IGNORE;
                        } else {
                            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                            if ((appReply == APPRESPONSE_NONE) ||
                                (appReply == APPRESPONSE_FAIL)
                                ) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                IsmReleaseMemory (transCopyError.ObjectName);
                                extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                extraData.ObjectName = objEnum.ObjectName;
                                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                IsmAbortPersistentObjectEnum (&objEnum);
                                __leave;
                            }
                        }
                        if (appReply == APPRESPONSE_IGNORE) {
                            LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                            IsmReleaseMemory (transCopyError.ObjectName);
                            extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                            extraData.ErrorArea = ERRUSER_AREA_SAVE;
                            extraData.ObjectTypeId = objEnum.ObjectTypeId;
                            extraData.ObjectName = objEnum.ObjectName;
                            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                            break;
                        }
                        IsmReleaseMemory (transCopyError.ObjectName);
                        continue;
                    }
                    okSave = TRUE;
                }

                if (okSave) {

#ifdef UNICODE
                    convValue = &value;
#else
                    // now let's convert this object content to UNICODE
                    convValue = IsmConvertObjectContentToUnicode (objEnum.ObjectTypeId, objEnum.ObjectName, &value);
                    if (!convValue) {
                        convValue = &value;
                    }
#endif
                    decoratedObject = pOpaqueBuildDecoratedObject (objEnum.ObjectTypeId, objEnum.ObjectName);

                    ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
                    appInfo.Phase = MIG_TRANSPORT_PHASE;
                    appInfo.SubPhase = SUBPHASE_COMPRESSING;
                    appInfo.ObjectTypeId = (objEnum.ObjectTypeId & (~PLATFORM_MASK));
                    appInfo.ObjectName = objEnum.ObjectName;
                    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

                    if (convValue->ContentInFile) {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pOtSaveContentInFile (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue, &compressedHandle)) {
                                if (GetLastError () == ERROR_DISK_FULL) {
                                    // we just failed because we don't have enough space on the destination
                                    // path. Let's tell that to the user
                                    extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = 0;
                                    extraData.ObjectName = NULL;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    __leave;
                                }

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                        size = convValue->FileContent.ContentSize;
                    } else {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pOtSaveContentInMemory (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue)) {
                                if (GetLastError () == ERROR_DISK_FULL) {
                                    // we just failed because we don't have enough space on the destination
                                    // path. Let's tell that to the user
                                    extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = 0;
                                    extraData.ObjectName = NULL;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    __leave;
                                }

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                        size = convValue->MemoryContent.ContentSize;
                    }

#ifndef UNICODE
                    if (convValue != (&value)) {
                        IsmFreeConvertedObjectContent (objEnum.ObjectTypeId, convValue);
                    }
#endif
                    IsmReleaseObject (&value);

                    pOtDestroyDecoratedObject (decoratedObject);
                    decoratedObject = NULL;
                }

                IsmTickProgressBar (g_PersistentSlice, 1);

                if (IsmCheckCancel()) {
                    __leave;
                }

                //
                // Send bytes saved to app every 3 seconds
                //

                bytesSaved += size;

                if (GetTickCount() - lastTick > 3000) {

                    if (bytesSaved < 1048576) {
                        wsprintf (text, TEXT("Saved: %u K"), (UINT) (bytesSaved / 1024));
                    } else if (bytesSaved < 8388608) {
                        fraction = (UINT) (bytesSaved / 10485);
                        wsprintf (text, TEXT("Saved: %u.%02u M"), fraction / 100, fraction % 100);
                    } else if (bytesSaved < 1073741824) {
                        wsprintf (text, TEXT("Saved: %u M"), (UINT) (bytesSaved / 1048576));
                    } else {
                        fraction = (UINT) (bytesSaved / 10737418);
                        wsprintf (text, TEXT("Saved: %u.%02u G"), fraction / 100, fraction % 100);
                    }

                    IsmSendMessageToApp (TRANSPORTMESSAGE_SIZE_SAVED, (ULONG_PTR) text);

                    lastTick = GetTickCount();
                }

            } while (IsmEnumNextPersistentObject (&objEnum));
        }

        if (IsmCheckCancel()) {
            __leave;
        }

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_FINISHING;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        if (Compressed) {
            ourDbFile = JoinPaths (g_TransportTempPath, S_TRANSPORT_DAT_FILE);
        } else {
            ourDbFile = pOpaqueAllocStorageFileName (S_TRANSPORT_DAT_FILE);
            if (!ourDbFile) {
                extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        }

        if (!MemDbSave (ourDbFile)) {
            extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        IsmTickProgressBar (g_DatabaseSlice, 1);

        if (Compressed) {
            if (IsmCheckCancel()) {
                __leave;
            }

            if (!pOtAddFileToImage (ourDbFile, S_TRANSPORT_DAT_FILE, &compressedHandle)) {
                extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }

            IsmTickProgressBar (g_DatabaseSlice, 1);

            if (IsmCheckCancel()) {
                __leave;
            }

            if (!CompressFlushAndCloseHandle (&compressedHandle)) {
                extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }

            IsmTickProgressBar (g_DatabaseSlice, 1);

            if (IsmCheckCancel()) {
                __leave;
            }
        }

        IsmSendMessageToApp (TRANSPORTMESSAGE_SIZE_SAVED, 0);
        result = TRUE;

    }
    __finally {
        PushError ();
        CompressCleanupHandle (&compressedHandle);

        pFreeStorageFileName (ourDbFile);
        INVALID_POINTER (ourDbFile);

        pOtDestroyDecoratedObject (decoratedObject);
        INVALID_POINTER (decoratedObject);

        if (g_OtCompressData && g_TransportTempPath) {
            pOtCleanUpTempDir ();
        }
        PopError ();
    }

    return result;
}

BOOL
WINAPI
OpaqueTransportAcquireObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,                 CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    UINT value;
    PCBYTE memValue;
    UINT memValueSize;
    PCTSTR fileValue = NULL;
    PCTSTR newFileValue = NULL;
    BOOL valueInFile;
    KEYHANDLE keyHandle;
    PALLOCSTATE allocState;
    PCTSTR detailsKey = NULL;
    PBYTE details;
    UINT detailsSize;
    PCTSTR sourceFile;
    PCTSTR decoratedObject = NULL;
    HANDLE fileHandle;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    MYASSERT (g_Platform == PLATFORM_DESTINATION);
    MYASSERT ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE);

    decoratedObject = pOpaqueBuildDecoratedObject (ObjectTypeId, ObjectName);

    allocState = (PALLOCSTATE) MemAllocZeroed (sizeof (ALLOCSTATE));

    if (MemDbGetValue (decoratedObject, &value)) {
        if (value == TRFLAG_FILE) {
            valueInFile = TRUE;
            keyHandle = MemDbGetSingleLinkage (decoratedObject, 0, 0);
            if (keyHandle) {
                fileValue = MemDbGetKeyFromHandle (keyHandle, 0);
                newFileValue = pOpaqueGetNewFileName (fileValue);
                result = fileValue != NULL;
            } else {
                fileValue = NULL;
                result = TRUE;
            }
        } else if (value == TRFLAG_MEMORY) {
            valueInFile = FALSE;
            memValueSize = 0;
            memValue = MemDbGetUnorderedBlob (decoratedObject, 0, &memValueSize);
            result = TRUE;
        } else {
            LOG ((LOG_ERROR, (PCSTR) MSG_UNSUPPORTED_DATA, value));
            SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        }
        if (result) {
            result = FALSE;

            if (valueInFile) {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_FILE) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as a file and it's wanted as a file
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = TRUE;
                    if (fileValue) {
                        ObjectContent->FileContent.ContentPath = JoinPaths (pGetRealTransportPath (), newFileValue?newFileValue:fileValue);
                        ObjectContent->FileContent.ContentSize = BfGetFileSize (ObjectContent->FileContent.ContentPath);
                    } else {
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                    result = TRUE;
                } else {
                    // this is stored as a file and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    if (fileValue) {
                        sourceFile = JoinPaths (pGetRealTransportPath (), newFileValue?newFileValue:fileValue);
                        ObjectContent->MemoryContent.ContentSize = (UINT) BfGetFileSize (sourceFile);
                        ObjectContent->MemoryContent.ContentBytes = MapFileIntoMemory (
                                                                        sourceFile,
                                                                        &allocState->FileHandle,
                                                                        &allocState->MapHandle
                                                                        );
                        FreePathString (sourceFile);
                        result = (ObjectContent->MemoryContent.ContentBytes != NULL);
                    } else {
                        ObjectContent->MemoryContent.ContentSize = 0;
                        ObjectContent->MemoryContent.ContentBytes = NULL;
                        result = TRUE;
                    }
                }
                if (newFileValue) {
                    FreePathString (newFileValue);
                    newFileValue = NULL;
                }
                if (fileValue) {
                    MemDbReleaseMemory (fileValue);
                    fileValue = NULL;
                }
            } else {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_MEMORY) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as memory and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    ObjectContent->MemoryContent.ContentSize = memValueSize;
                    ObjectContent->MemoryContent.ContentBytes = memValue;
                    result = TRUE;
                } else {
                    // this is stored as memory and it's wanted as a file
                    if (memValue) {
                        if (IsmGetTempFile (allocState->TempFile, ARRAYSIZE(allocState->TempFile))) {
                            fileHandle = BfCreateFile (allocState->TempFile);
                            if (fileHandle) {
                                if (BfWriteFile (fileHandle, memValue, memValueSize)) {
                                    ObjectContent->ObjectTypeId = ObjectTypeId;
                                    ObjectContent->ContentInFile = TRUE;
                                    ObjectContent->FileContent.ContentSize = memValueSize;
                                    ObjectContent->FileContent.ContentPath = DuplicatePathString (allocState->TempFile, 0);
                                    result = TRUE;
                                }
                                CloseHandle (fileHandle);
                            }
                        }
                        MemDbReleaseMemory (memValue);
                    } else {
                        ObjectContent->ObjectTypeId = ObjectTypeId;
                        ObjectContent->ContentInFile = TRUE;
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                }
            }
        }
    } else {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
    }

    if (result) {
        //
        // Fill the details
        //

        detailsKey = JoinText (S_DETAILS_PREFIX, decoratedObject);

        details = MemDbGetUnorderedBlob (detailsKey, 0, &detailsSize);

        if (!details) {
            detailsSize = 0;
        }

        allocState->DetailsPtr = details;

        ObjectContent->Details.DetailsSize = detailsSize;
        ObjectContent->Details.DetailsData = details;

        FreeText (detailsKey);

        ObjectContent->TransHandle = allocState;
    }

    if (!result) {
        FreeAlloc (allocState);
    }

    FreePathString (decoratedObject);

    return result;
}

BOOL
WINAPI
OpaqueTransportReleaseObject (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PALLOCSTATE allocState;

    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    allocState = (PALLOCSTATE) ObjectContent->TransHandle;

    if (ObjectContent->ContentInFile) {
        FreePathString (ObjectContent->FileContent.ContentPath);
        if (allocState && allocState->TempFile[0]) {
            DeleteFile (allocState->TempFile);
        }
    } else {
        if (allocState && allocState->FileHandle && allocState->MapHandle) {
            UnmapFile (
                ObjectContent->MemoryContent.ContentBytes,
                allocState->MapHandle,
                allocState->FileHandle
                );
        } else {
            MemDbReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
        }
    }

    if (allocState && allocState->DetailsPtr) {
        MemDbReleaseMemory (allocState->DetailsPtr);
    }

    FreeAlloc (allocState);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\guitrans\netcommon.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    common.c

Abstract:

    Implements functionality common to both the source and destination side

Author:

    Jim Schmidt (jimschm) 01-Jul-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include <winsock.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <wsnetbs.h>
#include "homenetp.h"

#define DBG_HOMENET   "HomeNet"

//
// Strings
//

#define S_TRANSPORT_DIR         TEXT("USMT2.HN")
#define S_TRANSPORT_STATUS_FILE TEXT("status")

//
// Constants
//

// none

//
// Macros
//

// None

//
// Types
//

// none

//
// Globals
//

MIG_TRANSPORTSTORAGEID g_TransportId;
PCTSTR g_TransportTempDir;
PCTSTR g_StatusFile;
HANDLE g_StatusFileHandle = INVALID_HANDLE_VALUE;
UINT g_Platform;
TRANSFERMETRICS g_Metrics;
CONNECTIONSOCKET g_Connection;
BOOL g_CompressData = FALSE;
MIG_PROGRESSSLICEID g_DatabaseSlice;
MIG_PROGRESSSLICEID g_PersistentSlice;
MIG_PROGRESSSLICEID g_DownloadSlice;
UINT g_DownloadTicks;
UINT g_DownloadSliceSize;
HANDLE g_BackgroundThread;
HANDLE g_BackgroundThreadTerminate;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// none

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
pStopBackgroundThread (
    VOID
    )
{
    if (g_BackgroundThread) {

        DEBUGMSG ((DBG_HOMENET, "Stopping background thread"));

        SetEvent (g_BackgroundThreadTerminate);
        WaitForSingleObject (g_BackgroundThread, INFINITE);

        CloseHandle (g_BackgroundThread);
        CloseHandle (g_BackgroundThreadTerminate);

        g_BackgroundThread = NULL;
        g_BackgroundThreadTerminate = NULL;
    }
}


BOOL
WINAPI
HomeNetTransportInitialize (
    IN      PMIG_LOGCALLBACK LogCallback
    )
{
    WSADATA startupData;
    INT result;

    //
    // Initialize globals
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    //
    // Start sockets
    //

    result = WSAStartup (0x0101, &startupData);

    //
    // Register transport
    //

    if (!result) {
        g_TransportId = IsmRegisterTransport (S_HOME_NETWORK_TRANSPORT);
        return TRUE;
    }

    return FALSE;
}


BOOL
WINAPI
HomeNetTransportQueryCapabilities (
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    OUT     PMIG_TRANSPORTTYPE TransportType,
    OUT     PMIG_TRANSPORTCAPABILITIES Capabilities,
    OUT     PCTSTR *FriendlyDescription
    )
{
    if (TransportStorageId != g_TransportId) {
        return FALSE;
    }

    *TransportType = TRANSPORTTYPE_FULL;
    *Capabilities = CAPABILITY_COMPRESSED|CAPABILITY_AUTOMATED;
    *FriendlyDescription = TEXT("Automatic network transfer");

    return TRUE;
}


VOID
WINAPI
HomeNetTransportEstimateProgressBar (
    MIG_PLATFORMTYPEID PlatformTypeId
    )
{
    UINT ticks;
    PMIG_OBJECTCOUNT objectCount;

    if (PlatformTypeId == PLATFORM_SOURCE) {

        //
        // If saving, we know the number of ticks based on the count of the
        // persistent attribute.
        //

        objectCount = IsmGetObjectsStatistics (PLATFORM_SOURCE);

        if (objectCount) {
            ticks = objectCount->PersistentObjects;
        } else {
            ticks = 0;
        }

        g_PersistentSlice = IsmRegisterProgressSlice (ticks, max (1, ticks / 5));

        ticks = 0;
        g_DatabaseSlice = IsmRegisterProgressSlice (ticks, ticks * 3);

    } else {
        //
        // When restoring, we don't know the progress until we connect. We need
        // to set up a scale.
        //

        g_DownloadTicks = 0;
        g_DownloadSliceSize = 1000;
        g_DownloadSlice = IsmRegisterProgressSlice (g_DownloadSliceSize, 360);
    }
}


VOID
pResetTempDir (
    VOID
    )
{
    FreePathString (g_TransportTempDir);
    g_TransportTempDir = NULL;

    if (g_StatusFileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle (g_StatusFileHandle);
        g_StatusFileHandle = INVALID_HANDLE_VALUE;
    }

    FreeStorageFileName (g_StatusFile);
    g_StatusFile = NULL;
}


DWORD
GetTransportStatus (
    IN      PCTSTR TrJournal,
    OUT     PBOOL Compressed    OPTIONAL
    )
{
    HANDLE trJrnHandle;
    BOOL compressed = FALSE;
    DWORD signature = 0;
    DWORD result = 0;

    if (TrJournal && TrJournal [0]) {
        trJrnHandle = BfOpenReadFile (TrJournal);
        if (trJrnHandle) {
            if (BfSetFilePointer (trJrnHandle, 0)) {
                if (BfReadFile (trJrnHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                    if (signature == HOMENETTR_SIG) {
                        if (BfReadFile (trJrnHandle, (PBYTE)(&compressed), sizeof (BOOL))) {
                            BfReadFile (trJrnHandle, (PBYTE)(&result), sizeof (DWORD));
                        }
                    }
                }
            }
            CloseHandle (trJrnHandle);
        } else {
            if (GetLastError () == ERROR_ACCESS_DENIED) {
                result = TRSTATUS_LOCKED;
            }
        }
    }
    if (Compressed) {
        *Compressed = compressed;
    }
    return result;
}


VOID
WINAPI
HomeNetTransportResetStorage (
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId
    )
{
    if (TransportStorageId == g_TransportId) {
        DEBUGMSG ((DBG_HOMENET, "Resetting transport"));

        pStopBackgroundThread();

        if (g_TransportTempDir) {
            pResetTempDir();
            MYASSERT (!g_TransportTempDir);
        }

        DEBUGMSG ((DBG_HOMENET, "Reset complete"));
    }
}


BOOL
WINAPI
HomeNetTransportSetStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL Valid,
    OUT     PBOOL ImageExists
    )

/*++

Routine Description:

  TransportSetStorage tells the transport to be prepared for a future IsmSave
  or IsmLoad, and provides the storage path and capabilities. The StoragePath
  tells the home networking transport where to save its temporary files
  during the transfer. This routine is called when IsmSetTransportStorage is
  called.

Arguments:

  Platform             - Specifies the platform of the transport. This is
                         potentially different than the current platform.
                         Also, it is never PLATFORM_CURRENT.
  TransportStorageId   - Specifies the desired storage ID. For this
                         transport, it will always be g_TransportId, unless
                         the caller passes in garbage.
  RequiredCapabilities - Specifies two optional flags: CAPABILITY_COMPRESSED
                         and CAPABILITY_AUTOMATED.
  StoragePath          - Specifies the path to the temporary directory, or
                         NULL to use the Windows temporary directory.
  Valid                - Receives TRUE if the transport storage ID is valid
                         and was selected, FALSE otherwise. NOTE: this is not
                         an optional parameter.
  ImageExists          - Receives TRUE if the platform is PLATFORM_DESTINATION,
                         FALSE if the platform is PLATFORM_SOURCE. The value is
                         undefined if Valid is FALSE.

Return Value:

  TRUE if the transport is ready for IsmSave or IsmLoad, FALSE otherwise.

--*/

{
    PCTSTR transportPath = NULL;
    MIG_OBJECTSTRINGHANDLE encodedPath;
    BOOL result = FALSE;
    DWORD attribs;
    TCHAR tempDir[MAX_TCHAR_PATH];
    BOOL startAutoDest = FALSE;
    CONNECTADDRESS connectAddress;
    BOOL capabilitiesValid = TRUE;

    if (!Valid || !ImageExists) {
        DEBUGMSG ((DBG_ERROR, "TransportSetStorage requires Valid and ImageExists params"));
        return FALSE;
    }

    *Valid = FALSE;
    *ImageExists = FALSE;

    if (TransportStorageId == g_TransportId) {

        //
        // Make sure we support the requested capabilities
        //

        if (RequiredCapabilities & (~(CAPABILITY_AUTOMATED|CAPABILITY_COMPRESSED))) {
            capabilitiesValid = FALSE;
        } else {
            DEBUGMSG ((DBG_HOMENET, "Accepting a TransportSetStorage request (capabilities: 0%Xh)", RequiredCapabilities));
        }

        if (capabilitiesValid) {

            //
            // Validate the inbound args, update the globals
            //

            if (RequiredCapabilities & CAPABILITY_COMPRESSED) {
                g_CompressData = TRUE;
            } else {
                g_CompressData = FALSE;
            }

            if (!StoragePath) {
                IsmGetTempStorage (tempDir, ARRAYSIZE(tempDir));
                StoragePath = tempDir;
            }

            MYASSERT (!g_TransportTempDir);

            //
            // Compute the transport storage directory, then make sure it is empty.
            // If Storage is NULL, then the storage directory is %temp%\usmtv2.hn
            //

            transportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR);

            attribs = GetFileAttributes (transportPath);

            if (attribs != INVALID_ATTRIBUTES) {
                SetFileAttributes (transportPath, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (transportPath);
                FiRemoveAllFilesInTree (transportPath);
            }

            //
            // Now esablish the temporary directory and put a status file in it
            // for restartability
            //

            attribs = GetFileAttributes (transportPath);

            if (attribs == INVALID_ATTRIBUTES) {

                if (BfCreateDirectory (transportPath)) {
                    *Valid = TRUE;

                    //
                    // it exists on the destination because we are going to download it;
                    // it does not exist on the source because we always overwrite it
                    //

                    *ImageExists = (Platform == PLATFORM_DESTINATION);

                    g_TransportTempDir = DuplicatePathString (transportPath, 0);
                    g_StatusFile = AllocStorageFileName (S_TRANSPORT_STATUS_FILE);

                    encodedPath = IsmCreateSimpleObjectPattern (g_TransportTempDir, FALSE, NULL, FALSE);
                    if (encodedPath) {
                        IsmRegisterStaticExclusion (MIG_FILE_TYPE, encodedPath);
                        IsmDestroyObjectHandle (encodedPath);
                    }
                }
            } else {
                *ImageExists = TRUE;
            }

            //
            // If CAPABILITY_AUTOMATED, start the process of looking for a connection now
            //

            if (*Valid && (RequiredCapabilities & CAPABILITY_AUTOMATED)) {

                if (Platform == PLATFORM_SOURCE) {
                    //
                    // Check for a destination
                    //

                    DEBUGMSG ((DBG_HOMENET, "Looking for destination broadcasts"));
                    *ImageExists = FindDestination (&connectAddress, 5, TRUE);
                    if (*ImageExists) {
                        *ImageExists = TestConnection (&connectAddress);
                    }

                } else {
                    //
                    // Launch background thread
                    //

                    DEBUGMSG ((DBG_HOMENET, "Launching background broadcast thread"));

                    if (!g_BackgroundThread) {
                        g_BackgroundThreadTerminate = CreateEvent (NULL, TRUE, FALSE, NULL);
                        g_BackgroundThread = StartThread (DestinationBackgroundThread, 0);
                    }
                }
            }

            result = TRUE;
        }
    }

    FreePathString (transportPath);
    return result;
}


VOID
WINAPI
HomeNetTransportTerminate (
    VOID
    )
{
    pStopBackgroundThread();

    //
    // Shut down sockets
    //

    WSACleanup();

    //
    // Clean up utils
    //

    if (g_TransportTempDir) {
        FiRemoveAllFilesInTree (g_TransportTempDir);
        pResetTempDir();
    }
}


PCTSTR
BuildDecoratedObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName
    )
{
    TCHAR prefix[32];

    wsprintf (prefix, TEXT("%u"), ObjectTypeId);

    return JoinPaths (prefix, ObjectName);
}

VOID
DestroyDecoratedObject (
    IN      PCTSTR String
    )
{
    FreePathString (String);
}


PCTSTR
AllocStorageFileName (
    IN      PCTSTR FileName         OPTIONAL
    )
{
    TCHAR buffer[32];
    static UINT sequencer = 0;

    if (FileName) {
        return JoinPaths (g_TransportTempDir, FileName);
    }

    sequencer++;
    wsprintf (buffer, TEXT("%08X.DAT"), sequencer);

    return JoinPaths (g_TransportTempDir, buffer);
}


VOID
FreeStorageFileName (
    IN      PCTSTR NameToFree
    )
{
    FreePathString (NameToFree);
}


PCTSTR
BuildImageFileName (
    IN      UINT ImageIdx
    )
{
    TCHAR imageFileName [13];
    PCTSTR imageFile = NULL;
    HANDLE imageFileHandle = NULL;

    wsprintf (imageFileName, S_TRANSPORT_IMG_FILE, ImageIdx);
    return JoinPaths (g_TransportTempDir, imageFileName);
}


VOID
FreeImageFileName (
    IN      PCTSTR ImageFileName
    )
{
    FreePathString (ImageFileName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\guitrans\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tmrmvmed.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\guitrans\removemed.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    removemed.c

Abstract:

    Implements a transport module that works with removable media

Author:

    Calin Negreanu (calinn) 24-Apr-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include <compress.h>

#define DBG_RMVMED    "RmvMed"

//
// Strings
//

#define S_TRANSPORT_DAT_FILE    TEXT("TRANSDB.DAT")
#define S_TRANSPORT_DEST_FILE   TEXT("USMT2IMG.DAT")
#define S_TRANSPORT_IMG_FILE    TEXT("IMG%05X.DAT")
#define S_UNCOMPRESSED_FILE     TEXT("TEMPFILE.DAT")
#define S_DETAILS_PREFIX        TEXT("details-")

//
// Constants
//
#define TRFLAG_FILE         0x01
#define TRFLAG_MEMORY       0x02
#define COPY_BUFFER_SIZE    32768
#define RMVMEDTR_OLDSIG1    0x55534D31  //USM1
#define RMVMEDTR_OLDSIG2    0x55534D32  //USM1
#define RMVMEDTR_SIG        0x55534D33  //USM2

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR TempFile [MAX_PATH];
    PCVOID AllocPtr;
    PCVOID DetailsPtr;
    HANDLE FileHandle;
    HANDLE MapHandle;
} ALLOCSTATE, *PALLOCSTATE;

typedef struct {
    DWORD Signature;
    DWORD LastImage;
    DWORD ImageNr;
    DWORD CheckSum;
    LONGLONG TotalImageSize;
} IMAGE_HEADER, *PIMAGE_HEADER;

//
// Globals
//

MIG_TRANSPORTSTORAGEID g_RemovableMediaId;
UINT g_RmvMedPlatform;
PCTSTR g_RemovableMediaPath = NULL;
PCTSTR g_RmvMedTempPath = NULL;
MIG_PROGRESSSLICEID g_PersistentSlice;
MIG_PROGRESSSLICEID g_DatabaseSlice;
UINT g_CompressedTicks;
UINT g_CompressedTicked;
MIG_PROGRESSSLICEID g_CompressedSlice;
UINT g_DownloadTicks;
UINT g_DownloadTicked;
MIG_PROGRESSSLICEID g_DownloadSlice;
UINT g_UncompressTicks;
UINT g_UncompressTicked;
MIG_PROGRESSSLICEID g_UncompressSlice;
LONGLONG g_TotalFiles;
LONGLONG g_FilesRead;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

VOID
pCleanupTempDir (
    VOID
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
WINAPI
RmvMedTransportInitialize (
    PMIG_LOGCALLBACK LogCallback
    )
{
    //
    // Initialize globals
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    g_RemovableMediaId = IsmRegisterTransport (S_REMOVABLE_MEDIA_TRANSPORT);

    return TRUE;
}

VOID
WINAPI
RmvMedTransportTerminate (
    VOID
    )
{
    pCleanupTempDir ();

    if (g_RmvMedTempPath) {
        FreePathString (g_RmvMedTempPath);
        g_RmvMedTempPath = NULL;
    }
    if (g_RemovableMediaPath) {
        FreePathString (g_RemovableMediaPath);
        g_RemovableMediaPath = NULL;
    }
}

VOID
WINAPI
RmvMedTransportEstimateProgressBar (
    MIG_PLATFORMTYPEID PlatformTypeId
    )
{
    UINT ticks;
    PMIG_OBJECTCOUNT objectCount;

    if (PlatformTypeId == PLATFORM_SOURCE) {

        //
        // If saving, we know the number of ticks based on the count of the
        // persistent attribute.
        //

        objectCount = IsmGetObjectsStatistics (PLATFORM_SOURCE);

        if (objectCount) {
            ticks = objectCount->PersistentObjects;
        } else {
            ticks = 0;
        }

        g_PersistentSlice = IsmRegisterProgressSlice (ticks, max (1, ticks / 5));

        g_DatabaseSlice = IsmRegisterProgressSlice (3, 1);

        g_CompressedTicks = ticks;

        g_CompressedSlice = IsmRegisterProgressSlice (g_CompressedTicks, max (1, g_CompressedTicks / 5));
    } else {
        g_DownloadTicked = 0;
        g_DownloadTicks = 1000;
        g_DownloadSlice = IsmRegisterProgressSlice (g_DownloadTicks, 180);
        g_UncompressTicked = 0;
        g_UncompressTicks = 1000;
        g_UncompressSlice = IsmRegisterProgressSlice (g_UncompressTicks, 180);
    }
}

BOOL
WINAPI
RmvMedTransportQueryCapabilities (
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    OUT     PMIG_TRANSPORTTYPE TransportType,
    OUT     PMIG_TRANSPORTCAPABILITIES Capabilities,
    OUT     PCTSTR *FriendlyDescription
    )
{
    if (TransportStorageId != g_RemovableMediaId) {
        return FALSE;
    }

    *TransportType = TRANSPORTTYPE_FULL;
    *Capabilities = CAPABILITY_COMPRESSED;
    *FriendlyDescription = TEXT("Span Media");
    return TRUE;
}

VOID
pCleanupTempDir (
    VOID
    )
{
    if (g_RmvMedTempPath) {
        FiRemoveAllFilesInTree (g_RmvMedTempPath);
    }
}

PCTSTR
pCreateTemporaryDir (
    VOID
    )
{
    TCHAR tempFile[MAX_PATH];

    if (!IsmGetTempDirectory (tempFile, ARRAYSIZE(tempFile))) {
        return NULL;
    }
    return DuplicatePathString (tempFile, 0);
}

BOOL
WINAPI
RmvMedTransportSetStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL Valid,
    OUT     PBOOL ImageExists
    )
{
    BOOL result = FALSE;

    if (Valid) {
        *Valid = FALSE;
    }
    if (ImageExists) {
        *ImageExists = FALSE;
    }

    if (TransportStorageId == g_RemovableMediaId) {

        if ((!RequiredCapabilities) || (RequiredCapabilities == CAPABILITY_COMPRESSED)) {

            if (g_RemovableMediaPath) {
                FreePathString (g_RemovableMediaPath);
                g_RemovableMediaPath = NULL;
            }
            g_RemovableMediaPath = DuplicatePathString (StoragePath, 0);

            if (Valid) {
                *Valid = TRUE;
            }

            if (ImageExists) {
                if (Platform == PLATFORM_SOURCE) {
                    *ImageExists = FALSE;
                } else {
                    *ImageExists = TRUE;
                }
            }

            result = TRUE;
        }
    }
    return result;
}

PCTSTR
pBuildDecoratedObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName
    )
{
    TCHAR prefix[32];

    wsprintf (prefix, TEXT("%u"), ObjectTypeId);

    return JoinPaths (prefix, ObjectName);
}

VOID
pDestroyDecoratedObject (
    IN      PCTSTR String
    )
{
    FreePathString (String);
}

BOOL
pSaveDetails (
    IN      PCTSTR DecoratedObject,
    IN      PMIG_DETAILS Details
    )
{
    PCTSTR key;
    BOOL b = FALSE;

    if ((!Details) || (!Details->DetailsSize)) {
        return TRUE;
    }

    key = JoinText (S_DETAILS_PREFIX, DecoratedObject);

    if (key) {

        b = (MemDbSetUnorderedBlob (key, 0, Details->DetailsData, Details->DetailsSize) != 0);

        FreeText (key);
    }

    return b;
}

PCTSTR
pAllocStorageFileName (
    VOID
    )
{
    static UINT fileIndex = 0;
    TCHAR buffer [32];

    fileIndex ++;
    wsprintf (buffer, TEXT("%08X.DAT"), fileIndex);

    return DuplicatePathString (buffer, 0);
}

BOOL
pSaveContentInMemory (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT ObjectValue
    )
{
    BOOL result = FALSE;

    MemDbSetValue (DecoratedObject, TRFLAG_MEMORY);

    if (ObjectValue->MemoryContent.ContentBytes && ObjectValue->MemoryContent.ContentSize) {

        MemDbSetUnorderedBlob (
            DecoratedObject,
            0,
            ObjectValue->MemoryContent.ContentBytes,
            ObjectValue->MemoryContent.ContentSize
            );
    }

    result = pSaveDetails (DecoratedObject, &ObjectValue->Details);

    return result;
}

BOOL
pAddFileToImage (
    IN      PCTSTR FileName,
    IN      PCTSTR StoredName,
    IN OUT  PCOMPRESS_HANDLE CompressedHandle
    )
{
    return CompressAddFileToHandle (FileName, StoredName, CompressedHandle);
}

BOOL
pSaveContentInFile (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedFileName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content,
    IN OUT  PCOMPRESS_HANDLE CompressedHandle
    )
{
    BOOL result = FALSE;
    PCTSTR destPath = NULL;
    DWORD attributes = INVALID_ATTRIBUTES;

    MYASSERT (Content->ContentInFile);
    if (!Content->ContentInFile) {
        return FALSE;
    }

    //
    // Use the CopyFile API to move the file from local to storage.
    //

    __try {
        if (Content && (Content->Details.DetailsSize == sizeof (WIN32_FIND_DATAW)) && Content->Details.DetailsData) {
            attributes = ((PWIN32_FIND_DATAW)Content->Details.DetailsData)->dwFileAttributes;
        }
        if ((attributes != INVALID_ATTRIBUTES) && (attributes & FILE_ATTRIBUTE_DIRECTORY)) {

            // this must be a directory, let's just write the key

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }
            result = TRUE;

        } else {

            //
            // Get a temp file, assemble the src path, copy the file
            //

            destPath = pAllocStorageFileName ();
            if (!destPath) {
                __leave;
            }

            if (!pAddFileToImage (Content->FileContent.ContentPath, destPath, CompressedHandle)) {
                __leave;
            }

            //
            // Keep track of where the file went
            //

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

            if (!MemDbAddSingleLinkage (DecoratedObject, destPath, 0)) {
                __leave;
            }

            FreePathString (destPath);
            destPath = NULL;
        }

        //
        // Save details
        //

        result = pSaveDetails (DecoratedObject, &(Content->Details));
    }
    __finally {
        if (destPath) {
            FreePathString (destPath);
            destPath = NULL;
        }
    }

    return result;
}

PCTSTR
pGetImageFile (
    IN      UINT ImageIdx
    )
{
    TCHAR imageFileName [13];
    PCTSTR imageFile = NULL;
    HANDLE imageFileHandle = NULL;

    wsprintf (imageFileName, S_TRANSPORT_IMG_FILE, ImageIdx);
    return JoinPaths (g_RmvMedTempPath, imageFileName);
}

BOOL
pIsOurMedia (
    IN      PCTSTR MediaFile,
    IN      DWORD CheckSum,
    IN      UINT MediaIdx
    )
{
    HANDLE mediaHandle = NULL;
    IMAGE_HEADER imageHeader;
    BOOL result = FALSE;

    mediaHandle = BfOpenReadFile (MediaFile);
    if (!mediaHandle) {
        return result;
    }

    if (BfReadFile (mediaHandle, (PBYTE)(&imageHeader), sizeof (imageHeader))) {
        if ((imageHeader.Signature == RMVMEDTR_SIG) &&
            (imageHeader.CheckSum == CheckSum) &&
            (imageHeader.ImageNr != MediaIdx)
            ) {
            result = TRUE;
        }
    }

    CloseHandle (mediaHandle);
    return result;
}

HANDLE
pLocalCreateFile (
    IN      PCTSTR FileName
    )
{
    HANDLE h;

    h = CreateFile (
            FileName,
            GENERIC_READ|GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_WRITE_THROUGH,
            NULL
            );

    if (h == INVALID_HANDLE_VALUE) {
        h = NULL;
    }

    return h;
}

BOOL
pWriteToMedia (
    IN      HANDLE MediaHandle,
    IN      PBYTE Data,
    IN      DWORD DataSize,
    IN      UINT MediaIdx,
    OUT     RMEDIA_ERR *Error
    )
{
    DWORD err;
    RMEDIA_EXTRADATA extraData;
    INT_PTR appReply;
    RMEDIA_ERR error = RMEDIA_ERR_NOERROR;

    if (!BfWriteFile (MediaHandle, Data, DataSize)) {
        error = RMEDIA_ERR_GENERALERROR;
        // let's see the error code
        err = GetLastError ();
        if (err == ERROR_DISK_FULL) {
            error = RMEDIA_ERR_DISKFULL;
        }
        if (err == ERROR_NOT_READY) {
            error = RMEDIA_ERR_NOTREADY;
        }
        if (Error) {
            *Error = error;
        }
        return FALSE;
    }
    if (Error) {
        *Error = RMEDIA_ERR_NOERROR;
    }
    return TRUE;
}

VOID
pWriteImageToMedia (
    IN      ULONGLONG TotalImageSize,
    IN      DWORD CheckSum,
    IN OUT  PUINT MediaIdx,
    IN OUT  PUINT ImageIdx,
    IN OUT  PULONGLONG ImagePtr,
    OUT     PULONGLONG TotalImageWritten,
    OUT     PRMEDIA_ERR Error,
    OUT     PBOOL Done
    )
{
    static ULONGLONG totalImageWritten = 0;
    ULONGLONG imageWrittenLast = totalImageWritten;
    PCTSTR imageFile = NULL;
    PCTSTR mediaFile = NULL;
    HANDLE imageHandle = NULL;
    HANDLE mediaHandle = NULL;
    IMAGE_HEADER imageHeader;
    UINT mediaIdx;
    UINT imageIdx;
    ULONGLONG imagePtr;
    ULONGLONG imageSize;
    RMEDIA_ERR error = RMEDIA_ERR_NOERROR;
    BOOL done = FALSE;
    PBYTE memImage = NULL;
    DWORD chunkSize;
    ULARGE_INTEGER thisMediaMaxSize;
    ULARGE_INTEGER dummy1, dummy2;
    FARPROC pGetDiskFreeSpaceEx;
    DWORD sectPerClust;
    DWORD bytesPerSect;
    DWORD freeClusters;
    DWORD totalClusters;
    DWORD err;
    BOOL deleteFile = FALSE;
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;

    mediaIdx = *MediaIdx;
    imageIdx = *ImageIdx;
    imagePtr = *ImagePtr;
    imageFile = pGetImageFile (imageIdx);
    imageSize = BfGetFileSize (imageFile);
    mediaFile = JoinPaths (g_RemovableMediaPath, S_TRANSPORT_DEST_FILE);

    __try {
        if (!DoesFileExist (imageFile)) {
            DEBUGMSG ((DBG_ERROR, "Image file does not exist: %s", imageFile));
            done = TRUE;
            __leave;
        }
        imageHandle = BfOpenReadFile (imageFile);
        if (!imageHandle) {
            DEBUGMSG ((DBG_ERROR, "Can't open image file %s", imageFile));
            error = RMEDIA_ERR_CRITICAL;
            done = TRUE;
            __leave;
        }
        if (!BfSetFilePointer (imageHandle, imagePtr)) {
            error = RMEDIA_ERR_CRITICAL;
            done = TRUE;
            __leave;
        }
        if (pIsOurMedia (mediaFile, CheckSum, mediaIdx)) {
            DEBUGMSG ((DBG_ERROR, "Cannot overwrite our own file %s", mediaFile));
            error = RMEDIA_ERR_USEDMEDIA;
            __leave;
        }
        mediaHandle = BfCreateFile (mediaFile);
        if (!mediaHandle) {
            error = RMEDIA_ERR_GENERALERROR;
            err = GetLastError ();
            if (err == ERROR_ACCESS_DENIED) {
                error = RMEDIA_ERR_WRONGMEDIA;
            }
            if (err == ERROR_WRITE_PROTECT) {
                error = RMEDIA_ERR_WRITEPROTECT;
            }
            if (err == ERROR_NOT_READY) {
                error = RMEDIA_ERR_NOTREADY;
            }
            DEBUGMSG ((DBG_ERROR, "Can't create media file %s", mediaFile));
            __leave;
        }

        deleteFile = TRUE;

        imageHeader.Signature = RMVMEDTR_SIG;
        imageHeader.LastImage = 0;
        imageHeader.ImageNr = mediaIdx;
        imageHeader.CheckSum = CheckSum;
        imageHeader.TotalImageSize = TotalImageSize;
        if (!pWriteToMedia (mediaHandle, (PBYTE)(&imageHeader), sizeof (imageHeader), mediaIdx, &error)) {
            DEBUGMSG ((DBG_ERROR, "Can't write header to media file %s", mediaFile));
            __leave;
        }
        memImage = HeapAlloc (g_hHeap, 0, COPY_BUFFER_SIZE);
        if (!memImage) {
            error = RMEDIA_ERR_CRITICAL;
            done = TRUE;
            __leave;
        }

        while (TRUE) {
            if (IsmCheckCancel()) {
                error = RMEDIA_ERR_CRITICAL;
                done = TRUE;
            }
            if (imagePtr == 0) {
                // let's write this image size to the file
                if (!pWriteToMedia (mediaHandle, (PBYTE)(&imageSize), sizeof (imageSize), mediaIdx, &error)) {
                    DEBUGMSG ((DBG_ERROR, "Can't write image size to media file %s", mediaFile));
                    __leave;
                }
            }

            while (imageSize > imagePtr) {
                if (IsmCheckCancel()) {
                    error = RMEDIA_ERR_CRITICAL;
                    done = TRUE;
                }
                chunkSize = COPY_BUFFER_SIZE;
                if ((ULONGLONG)chunkSize > (imageSize - imagePtr)) {
                    chunkSize = (DWORD)(imageSize - imagePtr);
                }
                if (!BfReadFile (imageHandle, memImage, chunkSize)) {
                    DEBUGMSG ((DBG_ERROR, "Can't read from image file %s", imageFile));
                    error = RMEDIA_ERR_CRITICAL;
                    done = TRUE;
                    __leave;
                }
                if (!pWriteToMedia (mediaHandle, memImage, chunkSize, mediaIdx, &error)) {
                    // write failed, let's see if we just ran out of space

                    if (error == RMEDIA_ERR_DISKFULL) {

                        // the disk is (almost) full
                        // we will make an attempt to use the remaining space
                        // either way we do not consider this an error
                        done = FALSE;
                        mediaIdx ++;

                        // Find out if GetDiskFreeSpaceEx is supported
#ifdef UNICODE
                        pGetDiskFreeSpaceEx = GetProcAddress( GetModuleHandle (TEXT("kernel32.dll")), "GetDiskFreeSpaceExW");
#else
                        pGetDiskFreeSpaceEx = GetProcAddress( GetModuleHandle (TEXT("kernel32.dll")), "GetDiskFreeSpaceExA");
#endif
                        if (pGetDiskFreeSpaceEx) {
                            if (!pGetDiskFreeSpaceEx (g_RemovableMediaPath, &dummy1, &dummy2, &thisMediaMaxSize)) {
                                DEBUGMSG ((DBG_WHOOPS, "Can't get media free space of %s using EX routine", g_RemovableMediaPath));
                                __leave;
                            }
                        } else {
                            if (GetDiskFreeSpace (g_RemovableMediaPath, &sectPerClust, &bytesPerSect, &freeClusters, &totalClusters)) {
                                thisMediaMaxSize.QuadPart = Int32x32To64 ((sectPerClust * bytesPerSect), freeClusters);
                            } else {
                                DEBUGMSG ((DBG_WHOOPS, "Can't get media free space of %s", g_RemovableMediaPath));
                                __leave;
                            }
                        }

                        // regardless of the outcome of the next write we don't want to report an error
                        error = 0;

                        if (thisMediaMaxSize.LowPart < chunkSize) {
                            if (thisMediaMaxSize.LowPart) {
                                // we attempt one more write with the
                                // available media disk size
                                if (!pWriteToMedia (mediaHandle, memImage, thisMediaMaxSize.LowPart, mediaIdx, &error)) {
                                    // this should have succeeded but...
                                    DEBUGMSG ((DBG_WHOOPS, "Can't write the remaining free bytes. Something is wrong with GetDiskFreeSpace %s", mediaFile));
                                    // regardless of the outcome of this write we don't want to report an error
                                    error = 0;
                                    __leave;
                                }

                                // let's adjust imagePtr
                                imagePtr += thisMediaMaxSize.LowPart;
                                totalImageWritten += thisMediaMaxSize.LowPart;
                            }
                        }
                    } else {
                        error = RMEDIA_ERR_GENERALERROR;
                    }
                    __leave;
                } else {
                    imagePtr += chunkSize;
                    totalImageWritten += chunkSize;
                }

                // now update the progress bar
                numerator = (LONGLONG) totalImageWritten * (LONGLONG) g_CompressedTicks;
                divisor = (LONGLONG) TotalImageSize;
                if (divisor) {
                    tick = numerator / divisor;
                } else {
                    tick = 0;
                }
                delta = (UINT) tick - g_CompressedTicked;
                if (delta) {
                    if (!IsmTickProgressBar (g_CompressedSlice, delta)) {
                        error = RMEDIA_ERR_CRITICAL;
                        done = TRUE;
                        __leave;
                    }
                    g_CompressedTicked += delta;
                }
            }
            // we just finished writing the image, let's see if there is some other image out there
            imageIdx ++;
            CloseHandle (imageHandle);
            imageHandle = NULL;
            FreePathString (imageFile);
            imageFile = pGetImageFile (imageIdx);
            if (!DoesFileExist (imageFile)) {
                imageSize = 0;
                imagePtr = 0;
                // let's go back and write that this is the last media
                if (!BfSetFilePointer (mediaHandle, 0)) {
                    DEBUGMSG ((DBG_ERROR, "Can't update media file %s", mediaFile));
                    error = RMEDIA_ERR_GENERALERROR;
                    __leave;
                }
                imageHeader.LastImage = 1;
                if (!pWriteToMedia (mediaHandle, (PBYTE)(&imageHeader), sizeof (imageHeader), mediaIdx, &error)) {
                    DEBUGMSG ((DBG_ERROR, "Can't update media file %s", mediaFile));
                    __leave;
                }
                done = TRUE;
                __leave;
            }
            imageSize = BfGetFileSize (imageFile);
            imagePtr = 0;
            imageHandle = BfOpenReadFile (imageFile);
            if (!imageHandle) {
                DEBUGMSG ((DBG_ERROR, "Can't open next image file %s", imageFile));
                error = RMEDIA_ERR_CRITICAL;
                done = TRUE;
                __leave;
            }
        }
    }
    __finally {

        if (mediaHandle) {
            if (error == RMEDIA_ERR_NOERROR) {
                if (!FlushFileBuffers (mediaHandle)) {
                    error = RMEDIA_ERR_GENERALERROR;
                    // let's see the error code
                    err = GetLastError ();
                    if (err == ERROR_NOT_READY) {
                        error = RMEDIA_ERR_NOTREADY;
                    }
                    done = FALSE;
                }
            }
            CloseHandle (mediaHandle);
            mediaHandle = NULL;
        }

        if ((error != RMEDIA_ERR_NOERROR) &&
            mediaFile &&
            deleteFile
            ) {
            DeleteFile (mediaFile);
        }

        if (memImage) {
            HeapFree (g_hHeap, 0, memImage);
            memImage = NULL;
        }

        if (imageHandle) {
            CloseHandle (imageHandle);
            imageHandle = NULL;
        }

        if (imageFile) {
            FreePathString (imageFile);
            imageFile = NULL;
        }

        if (mediaFile) {
            FreePathString (mediaFile);
            mediaFile = NULL;
        }
    }
    if (!error) {
        *MediaIdx = mediaIdx;
        *ImageIdx = imageIdx;
        *ImagePtr = imagePtr;
    } else {
        totalImageWritten = imageWrittenLast;
    }
    if (TotalImageWritten) {
        *TotalImageWritten = totalImageWritten;
    }
    *Error = error;
    *Done = done;
}

BOOL
pWriteAllImages (
    VOID
    )
{
    ULONGLONG totalImageSize = 0;
    ULONGLONG totalImageWritten = 0;
    ULONGLONG imageSize = 0;
    UINT mediaIdx = 1;
    UINT imageIdx = 1;
    ULONGLONG imagePtr = 0;
    PCTSTR imageFile;
    RMEDIA_ERR error = RMEDIA_ERR_NOERROR;
    BOOL done = FALSE;
    BOOL result = TRUE;
    BOOL diskFull = FALSE;
    INT_PTR appReply;
    INT r1,r2,r3;
    DWORD checkSum;
    RMEDIA_EXTRADATA extraData;

    // let's get the total image size for the progress bar
    imageIdx = 1;
    while (TRUE) {
        imageFile = pGetImageFile (imageIdx);
        imageSize = BfGetFileSize (imageFile);
        if (imageSize == 0) {
            FreePathString (imageFile);
            break;
        }
        totalImageSize += imageSize;
        FreePathString (imageFile);
        imageIdx ++;
    }
    imageIdx = 1;

    imageFile = pGetImageFile (imageIdx);

    srand( GetTickCount());
    r1 = rand();
    r2 = rand();
    r3 = rand();
    checkSum = r1 + r2 * 32768 + (r3 & 3) * 1073741824;
    FreePathString (imageFile);

    while (!done) {
        // send the proper message to the app

        extraData.LastError = error;
        extraData.MediaNumber = mediaIdx;
        extraData.TotalImageSize = totalImageSize;
        extraData.TotalImageWritten = totalImageWritten;
        appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_RMEDIA_SAVE, (ULONG_PTR)&extraData);

        if (!appReply) {
            //
            // user cancelled
            //
            done = TRUE;
            result = FALSE;
            continue;
        }

        // write this disk and loop until we finish
        pWriteImageToMedia (totalImageSize, checkSum, &mediaIdx, &imageIdx, &imagePtr, &totalImageWritten, &error, &done);

        if (done) {
            result = !error;
        }
    }
    return result;
}

BOOL
WINAPI
RmvMedTransportSaveState (
    VOID
    )
{
    MIG_APPINFO appInfo;
    ERRUSER_EXTRADATA extraData;
    MIG_OBJECTWITHATTRIBUTE_ENUM objEnum;
    PCTSTR databaseFile = NULL;
    PCTSTR decoratedObject = NULL;
    MIG_CONTENT value;
    PMIG_CONTENT convValue;
    COMPRESS_HANDLE compressedHandle;
    INT_PTR appReply;
    BOOL okSave = FALSE;
    TRANSCOPY_ERROR transCopyError;
#ifdef DEBUG
    PCTSTR nativeObjectName;
#endif
    BOOL result = FALSE;

    g_RmvMedPlatform = PLATFORM_SOURCE;

    __try {

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_PREPARING;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        ZeroMemory (&compressedHandle, sizeof (COMPRESS_HANDLE));

        g_RmvMedTempPath = pCreateTemporaryDir ();

        if (!g_RmvMedTempPath) {
            extraData.Error = ERRUSER_ERROR_CANTCREATETEMPDIR;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

#ifdef PRERELEASE
        {
            HINF debugInfHandle;
            INFSTRUCT context = INITINFSTRUCT_PMHANDLE;
            DWORD maxSize = 0;

            debugInfHandle = InfOpenInfFile (TEXT("c:\\debug.inf"));
            if (debugInfHandle && (debugInfHandle != INVALID_HANDLE_VALUE)) {
                if (InfFindFirstLine (
                        debugInfHandle,
                        TEXT("RemovableMedia"),
                        TEXT("LimitCabSize"),
                        &context
                        )
                    ) {
                    InfGetIntField (&context, 1, &maxSize);
                }
                InfCleanUpInfStruct (&context);
            }
            if (!CompressCreateHandle (g_RmvMedTempPath, S_TRANSPORT_IMG_FILE, 1, maxSize, &compressedHandle)) {
                extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        }
#else
        if (!CompressCreateHandle (g_RmvMedTempPath, S_TRANSPORT_IMG_FILE, 1, 0, &compressedHandle)) {
            extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }
#endif

        //
        // Enumerate all persistent objects
        //

        if (IsmEnumFirstPersistentObject (&objEnum)) {
            do {
                //
                // For each object to be saved, do the appropriate
                // data copy action
                //

                if (IsmCheckCancel()) {
                    __leave;
                }

#ifdef DEBUG
                nativeObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                DEBUGMSG ((DBG_RMVMED, "Transporting: %s", nativeObjectName));
                IsmReleaseMemory (nativeObjectName);
#endif

                okSave = FALSE;
                while (!okSave) {

                    if (!IsmAcquireObjectEx (
                            objEnum.ObjectTypeId,
                            objEnum.ObjectName,
                            &value,
                            CONTENTTYPE_ANY,
                            0
                            )) {

                        transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                        transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                        transCopyError.Error = GetLastError ();

                        if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                            appReply = APPRESPONSE_IGNORE;
                        } else {
                            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                            if ((appReply == APPRESPONSE_NONE) ||
                                (appReply == APPRESPONSE_FAIL)
                                ) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                IsmReleaseMemory (transCopyError.ObjectName);
                                extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                extraData.ObjectName = objEnum.ObjectName;
                                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                IsmAbortPersistentObjectEnum (&objEnum);
                                __leave;
                            }
                        }
                        if (appReply == APPRESPONSE_IGNORE) {
                            LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                            IsmReleaseMemory (transCopyError.ObjectName);
                            extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                            extraData.ErrorArea = ERRUSER_AREA_SAVE;
                            extraData.ObjectTypeId = objEnum.ObjectTypeId;
                            extraData.ObjectName = objEnum.ObjectName;
                            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                            break;
                        }
                        IsmReleaseMemory (transCopyError.ObjectName);
                        continue;
                    }
                    okSave = TRUE;
                }

                if (okSave) {

#ifdef UNICODE
                    convValue = &value;
#else
                    // now let's convert this object content to UNICODE
                    convValue = IsmConvertObjectContentToUnicode (objEnum.ObjectTypeId, objEnum.ObjectName, &value);
                    if (!convValue) {
                        convValue = &value;
                    }
#endif
                    decoratedObject = pBuildDecoratedObject (objEnum.ObjectTypeId, objEnum.ObjectName);

                    ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
                    appInfo.Phase = MIG_TRANSPORT_PHASE;
                    appInfo.SubPhase = SUBPHASE_COMPRESSING;
                    appInfo.ObjectTypeId = (objEnum.ObjectTypeId & (~PLATFORM_MASK));
                    appInfo.ObjectName = objEnum.ObjectName;
                    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

                    if (convValue->ContentInFile) {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pSaveContentInFile (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue, &compressedHandle)) {
                                if (GetLastError () == ERROR_DISK_FULL) {
                                    // we just failed because we don't have enough space on the destination
                                    // path. Let's tell that to the user
                                    extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = 0;
                                    extraData.ObjectName = NULL;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    __leave;
                                }

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                    } else {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pSaveContentInMemory (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue)) {
                                if (GetLastError () == ERROR_DISK_FULL) {
                                    // we just failed because we don't have enough space on the destination
                                    // path. Let's tell that to the user
                                    extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = 0;
                                    extraData.ObjectName = NULL;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    __leave;
                                }

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                    }

#ifndef UNICODE
                    if (convValue != (&value)) {
                        IsmFreeConvertedObjectContent (objEnum.ObjectTypeId, convValue);
                    }
#endif
                    IsmReleaseObject (&value);

                    pDestroyDecoratedObject (decoratedObject);
                    decoratedObject = NULL;
                }

                IsmTickProgressBar (g_PersistentSlice, 1);

                if (IsmCheckCancel()) {
                    __leave;
                }

            } while (IsmEnumNextPersistentObject (&objEnum));

            IsmAbortPersistentObjectEnum (&objEnum);
        }

        if (IsmCheckCancel()) {
            __leave;
        }

        databaseFile = JoinPaths (g_RmvMedTempPath, S_TRANSPORT_DAT_FILE);

        if (!MemDbSave (databaseFile)) {
            extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        IsmTickProgressBar (g_DatabaseSlice, 1);

        if (IsmCheckCancel()) {
            __leave;
        }

        if (!pAddFileToImage (databaseFile, S_TRANSPORT_DAT_FILE, &compressedHandle)) {
            extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        IsmTickProgressBar (g_DatabaseSlice, 1);

        FreePathString (databaseFile);
        databaseFile = NULL;

        if (!CompressFlushAndCloseHandle (&compressedHandle)) {
            extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        IsmTickProgressBar (g_DatabaseSlice, 1);

        if (IsmCheckCancel()) {
            __leave;
        }

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_MEDIAWRITING;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        if (!pWriteAllImages ()) {
            extraData.Error = ERRUSER_ERROR_CANTWRITETODESTPATH;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        result = TRUE;

    }
    __finally {

        PushError ();

        CompressCleanupHandle (&compressedHandle);

        if (databaseFile) {
            FreePathString (databaseFile);
            databaseFile = NULL;
        }

        PopError ();
    }

    PushError ();

    pCleanupTempDir ();

    PopError ();

    return result;
}

VOID
pReadImageFromMedia (
    IN      PDWORD CheckSum,
    IN OUT  PUINT MediaIdx,
    IN OUT  PUINT ImageIdx,
    IN OUT  PULONGLONG ImageRemaining,
    OUT     PRMEDIA_ERR Error,
    OUT     PBOOL Done
    )
{
    static ULONGLONG totalImageSize = 0;
    static ULONGLONG totalImageRead = 0;
    ULONGLONG imageReadLast = totalImageRead;
    PCTSTR imageFile = NULL;
    PCTSTR mediaFile = NULL;
    HANDLE imageHandle = NULL;
    HANDLE mediaHandle = NULL;
    IMAGE_HEADER imageHeader;
    DWORD checkSum;
    UINT mediaIdx;
    UINT imageIdx;
    ULONGLONG imageRemaining;
    ULONGLONG imageSize;
    RMEDIA_ERR error = RMEDIA_ERR_NOERROR;
    RMEDIA_EXTRADATA extraData;
    INT_PTR appReply;
    BOOL done = FALSE;
    PBYTE memImage = NULL;
    DWORD chunkSize;
    DWORD bytesRead;
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;
    DWORD err;

    checkSum = *CheckSum;
    mediaIdx = *MediaIdx;
    imageIdx = *ImageIdx;
    imageRemaining = *ImageRemaining;
    mediaFile = JoinPaths (g_RemovableMediaPath, S_TRANSPORT_DEST_FILE);

    __try {
        mediaHandle = BfOpenReadFile (mediaFile);
        if (!mediaHandle) {
            error = RMEDIA_ERR_WRONGMEDIA;
            err = GetLastError ();
            if (err == ERROR_NOT_READY) {
                error = RMEDIA_ERR_NOTREADY;
            }
            DEBUGMSG ((DBG_ERROR, "Can't create media file %s", mediaFile));
            __leave;
        }
        imageFile = pGetImageFile (imageIdx);
        if (DoesFileExist (imageFile)) {
            imageSize = BfGetFileSize (imageFile);
            imageHandle = BfOpenFile (imageFile);
        } else {
            imageSize = 0;
            imageHandle = BfCreateFile (imageFile);
        }
        if (!imageHandle) {
            error = RMEDIA_ERR_CRITICAL;
            done = TRUE;
            __leave;
        }
        if (!BfSetFilePointer (imageHandle, imageSize)) {
            error = RMEDIA_ERR_CRITICAL;
            done = TRUE;
            __leave;
        }
        if (!BfReadFile (mediaHandle, (PBYTE)(&imageHeader), sizeof (imageHeader))) {
            error = RMEDIA_ERR_WRONGMEDIA;
            err = GetLastError ();
            if (err == ERROR_NOT_READY) {
                error = RMEDIA_ERR_NOTREADY;
            }
            __leave;
        }
        if (imageHeader.Signature != RMVMEDTR_SIG) {
            if ((imageHeader.Signature != RMVMEDTR_OLDSIG1) &&
                (imageHeader.Signature != RMVMEDTR_OLDSIG2)
                ) {
                error = RMEDIA_ERR_WRONGMEDIA;
                __leave;
            }
            error = RMEDIA_ERR_OLDMEDIA;
            __leave;
        }
        if (imageHeader.ImageNr != mediaIdx) {
            error = RMEDIA_ERR_WRONGMEDIA;
            __leave;
        }
        if (checkSum) {
            if (checkSum != imageHeader.CheckSum) {
                error = RMEDIA_ERR_WRONGMEDIA;
                __leave;
            }
        } else {
            checkSum = imageHeader.CheckSum;
        }
        totalImageSize = imageHeader.TotalImageSize;
        memImage = HeapAlloc (g_hHeap, 0, COPY_BUFFER_SIZE);
        if (!memImage) {
            error = RMEDIA_ERR_CRITICAL;
            done = TRUE;
            __leave;
        }
        while (TRUE) {
            if (IsmCheckCancel()) {
                error = RMEDIA_ERR_CRITICAL;
                done = TRUE;
            }
            if (imageRemaining == 0) {
                // let's read this image size to the file
                if (!BfReadFile (mediaHandle, (PBYTE)(&imageRemaining), sizeof (imageRemaining))) {
                    error = RMEDIA_ERR_GENERALERROR;
                    err = GetLastError ();
                    if (err == ERROR_NOT_READY) {
                        error = RMEDIA_ERR_NOTREADY;
                    }
                    __leave;
                }
            }
            while (imageRemaining) {
                if (IsmCheckCancel()) {
                    error = RMEDIA_ERR_CRITICAL;
                    done = TRUE;
                }
                chunkSize = COPY_BUFFER_SIZE;
                if ((ULONGLONG)chunkSize > imageRemaining) {
                    chunkSize = (DWORD)(imageRemaining);
                }
                while (TRUE) {
                    if (!ReadFile (mediaHandle, memImage, chunkSize, &bytesRead, NULL)) {
                        // let's see the error code
                        err = GetLastError ();
                        if (err == ERROR_NOT_READY) {
                            error = RMEDIA_ERR_NOTREADY;
                            extraData.LastError = error;
                            extraData.MediaNumber = mediaIdx;
                            extraData.TotalImageSize = 0;
                            extraData.TotalImageWritten = 0;
                            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_RMEDIA_LOAD, (ULONG_PTR)&extraData);
                            if (!appReply) {
                                //
                                // user cancelled
                                //
                                error = RMEDIA_ERR_CRITICAL;
                                done = TRUE;
                                __leave;
                            } else {
                                error = RMEDIA_ERR_NOERROR;
                                continue;
                            }
                        }
                        // read failed, major problem, exiting
                        error = RMEDIA_ERR_GENERALERROR;
                        __leave;
                    } else {
                        break;
                    }
                }
                if (!BfWriteFile (imageHandle, memImage, bytesRead)) {
                    // major problem, exiting
                    error = RMEDIA_ERR_CRITICAL;
                    done = TRUE;
                    __leave;
                }
                imageRemaining -= bytesRead;
                totalImageRead += bytesRead;

                // now update the progress bar
                numerator = (LONGLONG) totalImageRead * (LONGLONG) g_DownloadTicks;
                divisor = (LONGLONG) totalImageSize;
                if (divisor) {
                    tick = numerator / divisor;
                } else {
                    tick = 0;
                }
                delta = (UINT) tick - g_DownloadTicked;
                if (delta) {
                    if (!IsmTickProgressBar (g_DownloadSlice, delta)) {
                        error = RMEDIA_ERR_CRITICAL;
                        done = TRUE;
                        __leave;
                    }
                    g_DownloadTicked += delta;
                }

                if (bytesRead != chunkSize) {
                    // our media image is done, let's get the new one
                    mediaIdx ++;
                    done = FALSE;
                    __leave;
                }
            }
            // we just finished reading the image, let's see if there is some other image out there
            // let's read this image size to the file
            if (!BfReadFile (mediaHandle, (PBYTE)(&imageRemaining), sizeof (imageRemaining))) {
                if (imageHeader.LastImage) {
                    done = TRUE;
                } else {
                    error = RMEDIA_ERR_GENERALERROR;
                    err = GetLastError ();
                    if (err == ERROR_NOT_READY) {
                        error = RMEDIA_ERR_NOTREADY;
                    }
                }
                __leave;
            }
            CloseHandle (imageHandle);
            FreePathString (imageFile);
            imageIdx ++;
            imageFile = pGetImageFile (imageIdx);
            imageHandle = BfCreateFile (imageFile);
            if (!imageHandle) {
                error = RMEDIA_ERR_CRITICAL;
                done = TRUE;
                __leave;
            }
        }
    }
    __finally {
        if (memImage) {
            HeapFree (g_hHeap, 0, memImage);
            memImage = NULL;
        }
        if (imageHandle) {
            CloseHandle (imageHandle);
            imageHandle = NULL;
        }
        if (imageFile) {
            FreePathString (imageFile);
            imageFile = NULL;
        }
        if (mediaHandle) {
            CloseHandle (mediaHandle);
            mediaHandle = NULL;
        }
        if (mediaFile) {
            FreePathString (mediaFile);
            mediaFile = NULL;
        }
    }
    if (!error) {
        *CheckSum = checkSum;
        *MediaIdx = mediaIdx;
        *ImageIdx = imageIdx;
        *ImageRemaining = imageRemaining;
    } else {
        totalImageRead = imageReadLast;
    }
    *Error = error;
    *Done = done;
}

BOOL
pReadAllImages (
    VOID
    )
{
    UINT mediaIdx = 1;
    UINT imageIdx = 1;
    ULONGLONG imageRemaining = 0;
    RMEDIA_ERR error = RMEDIA_ERR_NOERROR;
    BOOL done = FALSE;
    BOOL result = TRUE;
    INT_PTR appReply;
    DWORD checkSum = 0;
    RMEDIA_EXTRADATA extraData;

    while (!done) {

        // send the proper message to the app

        if (error == RMEDIA_ERR_OLDMEDIA) {
            PushError ();
            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_OLD_STORAGE, 0);
            PopError ();
        } else {
            extraData.LastError = error;
            extraData.MediaNumber = mediaIdx;
            extraData.TotalImageSize = 0;
            extraData.TotalImageWritten = 0;
            PushError ();
            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_RMEDIA_LOAD, (ULONG_PTR)&extraData);
            PopError ();
        }

        if (!appReply) {
            //
            // user cancelled
            //
            done = TRUE;
            result = FALSE;
            continue;
        }
        pReadImageFromMedia (&checkSum, &mediaIdx, &imageIdx, &imageRemaining, &error, &done);
        if (done) {
            result = !error;
        }
    }
    return result;
}

PCTSTR
pRmvMedGetNewFileName (
    IN      PCTSTR FileName
    )
{
    PCTSTR newFileName = NULL;
    PTSTR tempPtr1 = NULL;
    PCTSTR endStr1 = NULL;
    PCTSTR tempPtr2 = NULL;
    PCTSTR endStr2 = NULL;
    INT i;

    // let's modify the file to extract. The file name will
    // be split in 2 after the first 5 characters
    newFileName = DuplicatePathString (FileName, 1);
    if (!newFileName) {
        return NULL;
    }
    tempPtr1 = (PTSTR) GetFileNameFromPath (newFileName);
    if (!tempPtr1) {
        FreePathString (newFileName);
        return NULL;
    }
    endStr1 = GetEndOfString (newFileName);
    if (!endStr1) {
        FreePathString (newFileName);
        return NULL;
    }
    tempPtr2 = GetFileNameFromPath (FileName);
    if (!tempPtr2) {
        FreePathString (newFileName);
        return NULL;
    }
    endStr2 = GetEndOfString (FileName);
    if (!endStr2) {
        FreePathString (newFileName);
        return NULL;
    }
    for (i = 0; i < 5; i ++) {
        tempPtr1 = _tcsinc (tempPtr1);
        tempPtr2 = _tcsinc (tempPtr2);
    }

    if ((tempPtr1 < endStr1) &&
        (tempPtr2 < endStr2)
        ) {
        StringCopy (tempPtr1, TEXT("\\"));
        tempPtr1 = _tcsinc (tempPtr1);
        StringCopy (tempPtr1, tempPtr2);
    } else {
        FreePathString (newFileName);
        newFileName = NULL;
    }
    return newFileName;
}

BOOL
pRmvMedCallback (
    IN      PCTSTR FileToExtract,
    IN      LONGLONG FileSize,
    OUT     PBOOL ExtractFile,
    IN OUT  PCTSTR *NewFileName
    )
{
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;

    if (NewFileName) {
        *NewFileName = pRmvMedGetNewFileName (FileToExtract);
    }

    g_FilesRead ++;
    // now update the progress bar
    numerator = (LONGLONG) g_FilesRead * (LONGLONG) g_UncompressTicks;
    divisor = (LONGLONG) g_TotalFiles;
    if (divisor) {
        tick = numerator / divisor;
    } else {
        tick = 0;
    }
    delta = (UINT) tick - g_UncompressTicked;
    if (delta) {
        IsmTickProgressBar (g_UncompressSlice, delta);
        g_UncompressTicked += delta;
    }

    if (ExtractFile) {
        *ExtractFile = TRUE;
    }

    return (!IsmCheckCancel());
}

BOOL
pUnpackAllFiles (
    VOID
    )
{
    COMPRESS_HANDLE compressedHandle;
    BOOL result = FALSE;

    if (CompressOpenHandle (g_RmvMedTempPath, S_TRANSPORT_IMG_FILE, 1, &compressedHandle)) {
        g_TotalFiles = compressedHandle.FilesStored;
        if (CompressExtractAllFiles (g_RmvMedTempPath, &compressedHandle, pRmvMedCallback)) {
            result = TRUE;
        }
        CompressCleanupHandle (&compressedHandle);
    }

    return result;
}

BOOL
WINAPI
RmvMedTransportBeginApply (
    VOID
    )
{
    MIG_APPINFO appInfo;
    ERRUSER_EXTRADATA extraData;
    PCTSTR imageFile = NULL;
    PCTSTR newImageFile = NULL;
    BOOL result = FALSE;

    g_RmvMedPlatform = PLATFORM_DESTINATION;

    ZeroMemory (&extraData, sizeof (ERRUSER_EXTRADATA));
    extraData.Error = ERRUSER_ERROR_UNKNOWN;

    __try {

        g_RmvMedTempPath = pCreateTemporaryDir ();

        if (!g_RmvMedTempPath) {
            extraData.Error = ERRUSER_ERROR_CANTCREATETEMPDIR;
            __leave;
        }

        if (!pReadAllImages ()) {
            if (GetLastError () == ERROR_DISK_FULL) {
                extraData.Error = ERRUSER_ERROR_DISKSPACE;
            } else {
                extraData.Error = ERRUSER_ERROR_CANTREADIMAGE;
            }
            __leave;
        }

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_UNCOMPRESSING;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        if (!pUnpackAllFiles ()) {
            extraData.Error = ERRUSER_ERROR_CANTUNPACKIMAGE;
            __leave;
        }

        newImageFile = pRmvMedGetNewFileName (S_TRANSPORT_DAT_FILE);

        imageFile = JoinPaths (g_RmvMedTempPath, newImageFile?newImageFile:S_TRANSPORT_DAT_FILE);

        if (newImageFile) {
            FreePathString (newImageFile);
            newImageFile = NULL;
        }

        if (!MemDbLoad (imageFile)) {
            extraData.Error = ERRUSER_ERROR_CANTREADIMAGE;
            __leave;
        }

        result = TRUE;
    }
    __finally {
        if (imageFile) {
            FreePathString (imageFile);
            imageFile = NULL;
        }
    }

    if (!result) {
        extraData.ErrorArea = ERRUSER_AREA_LOAD;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
    }

    return result;
}

VOID
WINAPI
RmvMedTransportEndApply (
    VOID
    )
{
    MYASSERT (g_RmvMedPlatform == PLATFORM_DESTINATION);

    pCleanupTempDir ();
}

BOOL
WINAPI
RmvMedTransportAcquireObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,             CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    UINT value;
    PCBYTE memValue;
    UINT memValueSize;
    PCTSTR fileValue = NULL;
    PCTSTR newFileValue = NULL;
    BOOL valueInFile;
    KEYHANDLE keyHandle;
    PALLOCSTATE allocState;
    PCTSTR detailsKey = NULL;
    PBYTE details;
    UINT detailsSize;
    PCTSTR sourceFile;
    PCTSTR decoratedObject = NULL;
    HANDLE fileHandle;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    MYASSERT (g_RmvMedPlatform == PLATFORM_DESTINATION);
    MYASSERT ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE);

    decoratedObject = pBuildDecoratedObject (ObjectTypeId, ObjectName);

    allocState = (PALLOCSTATE) MemAllocZeroed (sizeof (ALLOCSTATE));

    if (MemDbGetValue (decoratedObject, &value)) {
        if (value == TRFLAG_FILE) {
            valueInFile = TRUE;
            keyHandle = MemDbGetSingleLinkage (decoratedObject, 0, 0);
            if (keyHandle) {
                fileValue = MemDbGetKeyFromHandle (keyHandle, 0);
                newFileValue = pRmvMedGetNewFileName (fileValue);
                result = fileValue != NULL;
            } else {
                fileValue = NULL;
                result = TRUE;
            }
        } else if (value == TRFLAG_MEMORY) {
            valueInFile = FALSE;
            memValueSize = 0;
            memValue = MemDbGetUnorderedBlob (decoratedObject, 0, &memValueSize);
            result = TRUE;
        } else {
            LOG ((LOG_ERROR, (PCSTR) MSG_UNSUPPORTED_DATA, value));
            SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        }
        if (result) {
            result = FALSE;

            if (valueInFile) {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_FILE) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as a file and it's wanted as a file
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = TRUE;
                    if (fileValue) {
                        ObjectContent->FileContent.ContentPath = JoinPaths (g_RmvMedTempPath, newFileValue?newFileValue:fileValue);
                        ObjectContent->FileContent.ContentSize = BfGetFileSize (ObjectContent->FileContent.ContentPath);
                    } else {
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                    result = TRUE;
                } else {
                    // this is stored as a file and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    if (fileValue) {
                        sourceFile = JoinPaths (g_RmvMedTempPath, newFileValue?newFileValue:fileValue);
                        ObjectContent->MemoryContent.ContentSize = (UINT) BfGetFileSize (sourceFile);
                        ObjectContent->MemoryContent.ContentBytes = MapFileIntoMemory (
                                                                        sourceFile,
                                                                        &allocState->FileHandle,
                                                                        &allocState->MapHandle
                                                                        );
                        FreePathString (sourceFile);
                        result = (ObjectContent->MemoryContent.ContentBytes != NULL);
                    } else {
                        ObjectContent->MemoryContent.ContentSize = 0;
                        ObjectContent->MemoryContent.ContentBytes = NULL;
                        result = TRUE;
                    }
                }
                if (newFileValue) {
                    FreePathString (newFileValue);
                    newFileValue = NULL;
                }
                if (fileValue) {
                    MemDbReleaseMemory (fileValue);
                    fileValue = NULL;
                }
            } else {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_MEMORY) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as memory and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    ObjectContent->MemoryContent.ContentSize = memValueSize;
                    ObjectContent->MemoryContent.ContentBytes = memValue;
                    result = TRUE;
                } else {
                    // this is stored as memory and it's wanted as a file
                    if (memValue) {
                        if (IsmGetTempFile (allocState->TempFile, ARRAYSIZE(allocState->TempFile))) {
                            fileHandle = BfCreateFile (allocState->TempFile);
                            if (fileHandle) {
                                if (BfWriteFile (fileHandle, memValue, memValueSize)) {
                                    ObjectContent->ObjectTypeId = ObjectTypeId;
                                    ObjectContent->ContentInFile = TRUE;
                                    ObjectContent->FileContent.ContentSize = memValueSize;
                                    ObjectContent->FileContent.ContentPath = DuplicatePathString (allocState->TempFile, 0);
                                    result = TRUE;
                                }
                                CloseHandle (fileHandle);
                            }
                        }
                        MemDbReleaseMemory (memValue);
                    } else {
                        ObjectContent->ObjectTypeId = ObjectTypeId;
                        ObjectContent->ContentInFile = TRUE;
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                }
            }
        }
    } else {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
    }

    if (result) {
        //
        // Fill the details
        //

        detailsKey = JoinText (S_DETAILS_PREFIX, decoratedObject);

        details = MemDbGetUnorderedBlob (detailsKey, 0, &detailsSize);

        if (!details) {
            detailsSize = 0;
        }

        allocState->DetailsPtr = details;

        ObjectContent->Details.DetailsSize = detailsSize;
        ObjectContent->Details.DetailsData = details;

        FreeText (detailsKey);

        ObjectContent->TransHandle = allocState;
    }

    if (!result) {
        FreeAlloc (allocState);
    }

    FreePathString (decoratedObject);

    return result;
}

BOOL
WINAPI
RmvMedTransportReleaseObject (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PALLOCSTATE allocState;

    MYASSERT (g_RmvMedPlatform == PLATFORM_DESTINATION);

    allocState = (PALLOCSTATE) ObjectContent->TransHandle;

    if (ObjectContent->ContentInFile) {
        FreePathString (ObjectContent->FileContent.ContentPath);
        if (allocState && allocState->TempFile[0]) {
            DeleteFile (allocState->TempFile);
        }
    } else {
        if (allocState && allocState->FileHandle && allocState->MapHandle) {
            UnmapFile (
                ObjectContent->MemoryContent.ContentBytes,
                allocState->MapHandle,
                allocState->FileHandle
                );
        } else {
            MemDbReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
        }
    }

    if (allocState && allocState->DetailsPtr) {
        MemDbReleaseMemory (allocState->DetailsPtr);
    }

    FreeAlloc (allocState);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\guitrans\sockets.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sockets.c

Abstract:

    Implements the network interface for the home net transport.

Author:

    Jim Schmidt (jimschm) 01-Jul-2000

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include <winsock2.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <wsnetbs.h>
#include <nb30.h>
#include <ws2tcpip.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmwksta.h>
#include "homenetp.h"

#define DBG_HOMENET                 "HomeNet"

//
// Strings
//

#define S_64CHARTAG     TEXT("usmt-v2@01234567890123456789012345678901234567890123456789012345")

//
// Constants
//

#define IDLE_TIMEOUT                45

#define TCPIP_BROADCAST_PORT        2048
#define IPX_BROADCAST_PORT          1150
#define NETBIOS_BROADCAST_PORT      0x50

#define TCPIP_CONNECT_PORT          2049
#define IPX_CONNECT_PORT            1151
#define NETBIOS_CONNECT_PORT        0x51

#define NAME_SIZE                       64
#define NAME_SIZE_PLUS_NUL              65
#define NAME_SIZE_PLUS_COMMA            65
#define NAME_SIZE_PLUS_COMMA_PLUS_NUL   66
#define MIN_MESSAGE_SIZE                (NAME_SIZE_PLUS_COMMA_PLUS_NUL + 2)

//
// Macros
//

// none

//
// Types
//

typedef INT (WSAIOCTL)(
                SOCKET s,
                DWORD IoControlCode,
                PVOID InBuffer,
                DWORD InBufferSize,
                PVOID OutBuffer,
                DWORD OutBufferSize,
                PDWORD BytesReturned,
                WSAOVERLAPPED *Overlapped,
                LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
                );
typedef WSAIOCTL *PWSAIOCTL;

typedef struct {
    SOCKET Socket;
    BYTE BroadcastAddress[MAX_SOCKADDR];
    INT AddressLen;
    INT Family;
    INT Protocol;
} BROADCASTSOCKET, *PBROADCASTSOCKET;

typedef struct {
    SOCKET Socket;
    INT Family;
    INT Protocol;
    BOOL Datagram;
} LISTENSOCKET, *PLISTENSOCKET;

typedef struct {
    PBROADCASTSOCKET BroadcastSockets;
    INT BroadcastCount;
    PLISTENSOCKET ListenSockets;
    INT ListenCount;
    CONNECTIONSOCKET ConnectionSocket;
    PGROWBUFFER AddressArray;
    UINT Timeout;
} BROADCASTARGS, *PBROADCASTARGS;

typedef NET_API_STATUS(WINAPI NETWKSTAGETINFO)(PWSTR, DWORD, PBYTE *);
typedef NETWKSTAGETINFO *PNETWKSTAGETINFO;

typedef NET_API_STATUS(WINAPI NETAPIBUFFERFREE)(PVOID);
typedef NETAPIBUFFERFREE *PNETAPIBUFFERFREE;

//
// Globals
//

HANDLE g_StopHandle;
HANDLE g_ConnectionDone;
CHAR g_GlobalKey [GLOBALKEY_SIZE + 1];

//
// Macro expansion list
//

// none

//
// Private function prototypes
//

// none

//
// Macro expansion definition
//

// none

//
// Code
//

PBROADCASTSOCKET
pOpenOneBroadcastSocket (
    IN OUT  PGROWBUFFER BroadcastSockets,
    IN      SOCKADDR *SockAddr,
    IN      INT SockAddrLen,
    IN      INT Family,
    IN      INT Protocol,
    IN      PCTSTR DebugText
    )

/*++

Routine Description:

  pOpenOneBroadcastSocket opens a socket for the specified
  family/protocol/address combination, sets the socket into SO_REUSEADDR and
  SO_BROADCAST mode, and puts the socket information in the array stored in
  the caller's grow buffer.

  The socket opened will be used for broadcast send or receive.

Arguments:

  BroadcastSockets - Specifies the grow buffer that holds the array of
                     BROADCASTSOCKET elements. Receives an additional entry
                     on success.
  SockAddr         - Specifies the protocol-specific socket address structure
                     (cast to SOCKADDR), giving the broadcast address.
  SockAddrLen      - Specifies the length of SockAddr, in bytes
  Family           - Specifies the protocol family (AF_IPX, AF_INET)
  Protocol         - Specifies the protocol (IPPROTO_UDP, NSPROTO_IPX, -lana)
  DebugText        - Specifies the protocol in text form for debug messages

Return Value:

  A pointer to the new BROADCASTSOCKET element allocated from BroadcastSockets,
  or NULL if the socket could not be opened.

  NOTE: BroadcastSockets->Buf will potentially change on success.  Do not rely
        on this address.

--*/

{
    PBROADCASTSOCKET broadcastSocket;
    BOOL b;

    broadcastSocket = (PBROADCASTSOCKET) GbGrow (BroadcastSockets, sizeof (BROADCASTSOCKET));
    broadcastSocket->Socket = socket (Family, SOCK_DGRAM, Protocol);

    if (broadcastSocket->Socket != INVALID_SOCKET) {

        b = TRUE;
        setsockopt (broadcastSocket->Socket, SOL_SOCKET, SO_BROADCAST, (PBYTE) &b, sizeof (b));
        setsockopt (broadcastSocket->Socket, SOL_SOCKET, SO_REUSEADDR, (PBYTE) &b, sizeof (b));

        if (bind (broadcastSocket->Socket, SockAddr, SockAddrLen)) {
            DEBUGMSG ((DBG_ERROR, "Can't bind to %s socket", DebugText));
            closesocket (broadcastSocket->Socket);
            broadcastSocket->Socket = INVALID_SOCKET;
        }
    }

    if (broadcastSocket->Socket == INVALID_SOCKET) {
        BroadcastSockets->End -= sizeof (BROADCASTSOCKET);
        broadcastSocket = NULL;
    } else {
        DEBUGMSG ((
            DBG_HOMENET,
            "%s is available for broadcast on socket %u",
            DebugText,
            (BroadcastSockets->End / sizeof (BROADCASTSOCKET)) - 1
            ));

        broadcastSocket->AddressLen = SockAddrLen;
        MYASSERT (SockAddrLen <= MAX_SOCKADDR);
        CopyMemory (broadcastSocket->BroadcastAddress, (PBYTE) SockAddr, SockAddrLen);
        broadcastSocket->Family = Family;
        broadcastSocket->Protocol = Protocol;
    }

    return broadcastSocket;
}


INT
pOpenBroadcastSockets (
    OUT     PGROWBUFFER BroadcastSockets
    )

/*++

Routine Description:

  pOpenBroadcastSockets opens a broadcast socket on each supported protocol.

Arguments:

  BroadcastSockets - Receives an array of BROADCASTSOCKET elements (one for
                     each protocol).  IMPORTANT: This parameter must be
                     zero-initialized by the caller.

Return Value:

  The number of elements in BroadcastSockets, or zero on failure.

--*/

{
    SOCKADDR_IPX ipxAddr;
    SOCKADDR_IN tcpipAddr;
    PBROADCASTSOCKET broadcastSocket;

    MYASSERT (!BroadcastSockets->Buf && !BroadcastSockets->End);

    //
    // Open sockets for broadcasts
    //

    // IPX
    ZeroMemory (&ipxAddr, sizeof (ipxAddr));
    ipxAddr.sa_family = AF_IPX;
    ipxAddr.sa_socket = IPX_BROADCAST_PORT;

    broadcastSocket = pOpenOneBroadcastSocket (
                            BroadcastSockets,
                            (SOCKADDR *) &ipxAddr,
                            sizeof (ipxAddr),
                            AF_IPX,
                            NSPROTO_IPX,
                            TEXT("IPX")
                            );
    if (broadcastSocket) {
        memset (ipxAddr.sa_nodenum, 0xFF, 6);
        CopyMemory (broadcastSocket->BroadcastAddress, &ipxAddr, sizeof (ipxAddr));
    }

    // TCP/IP
    ZeroMemory (&tcpipAddr, sizeof (tcpipAddr));
    tcpipAddr.sin_family = AF_INET;
    tcpipAddr.sin_addr.s_addr = htonl (INADDR_ANY);
    tcpipAddr.sin_port = TCPIP_BROADCAST_PORT;

    broadcastSocket = pOpenOneBroadcastSocket (
                            BroadcastSockets,
                            (SOCKADDR *) &tcpipAddr,
                            sizeof (tcpipAddr),
                            AF_INET,
                            IPPROTO_UDP,
                            TEXT("UDP")
                            );

    if (broadcastSocket) {
        tcpipAddr.sin_addr.s_addr = htonl (INADDR_BROADCAST);
        CopyMemory (broadcastSocket->BroadcastAddress, &tcpipAddr, sizeof (tcpipAddr));
    }

    return BroadcastSockets->End / sizeof (BROADCASTSOCKET);
}


PLISTENSOCKET
pOpenOneListenSocket (
    IN OUT  PGROWBUFFER ListenSockets,
    IN      SOCKADDR *SockAddr,
    IN      INT SockAddrLen,
    IN      INT Family,
    IN      BOOL Multicast,
    IN      INT Protocol,
    IN      PCTSTR DebugText
    )

/*++

Routine Description:

  pOpenOneListenSocket opens a socket for the specified
  family/protocol/address combination, sets the socket into SO_REUSEADDR mode,
  and puts the socket information in the array stored in the caller's grow
  buffer.  If Multicast is specified, then SO_BROADCAST is also set.
  Otherwise, the socket is set to listen for one connection.

  The socket opened will be used to accept connections.

Arguments:

  ListenSockets - Specifies the grow buffer that holds the array of
                  LISTENSOCKET elements. Receives an additional entry on
                  success.
  SockAddr      - Specifies the protocol-specific socket address structure
                  (cast to SOCKADDR), giving the local address for binding.
  SockAddrLen   - Specifies the length of SockAddr, in bytes
  Family        - Specifies the protocol family (AF_IPX, AF_INET)
  Multicast     - Specifies TRUE if the protocol family does not support
                  streaming sockets, but instead uses datagrams for all data
                  transfer. (NetBIOS for example is a multicast protocol.)

                  NOTE: UNSUPPORTED because NetBIOS is not implemented anymore

  Protocol      - Specifies the protocol (IPPROTO_UDP, NSPROTO_IPX, -lana)
  DebugText     - Specifies the protocol in text form for debug messages

Return Value:

  A pointer to the new LISTENSOCKET element allocated from ListenSockets, or
  NULL if the socket could not be opened.

  NOTE: ListenSockets->Buf will potentially change on success.  Do not rely on
        this address.

--*/

{
    PLISTENSOCKET listenSocket;
    BOOL b;

    listenSocket = (PLISTENSOCKET) GbGrow (ListenSockets, sizeof (LISTENSOCKET));
    listenSocket->Socket = socket (Family, Multicast ? SOCK_DGRAM : SOCK_STREAM, Protocol);
    listenSocket->Datagram = Multicast;
    listenSocket->Family = Family;
    listenSocket->Protocol = Protocol;

    if (listenSocket->Socket != INVALID_SOCKET) {

        b = TRUE;
        setsockopt (listenSocket->Socket, SOL_SOCKET, SO_REUSEADDR, (PBYTE) &b, sizeof (b));

        if (Multicast) {
            setsockopt (listenSocket->Socket, SOL_SOCKET, SO_BROADCAST, (PBYTE) &b, sizeof (b));
        }

        if (bind (listenSocket->Socket, SockAddr, SockAddrLen) ||
            (!Multicast && listen (listenSocket->Socket, 1))
            ) {
            DEBUGMSG ((DBG_ERROR, "Can't bind/listen to %s socket", DebugText));
            closesocket (listenSocket->Socket);
            listenSocket->Socket = INVALID_SOCKET;
        }
    }

    if (listenSocket->Socket == INVALID_SOCKET) {
        ListenSockets->End -= sizeof (LISTENSOCKET);
        listenSocket = NULL;
    } else {
        DEBUGMSG ((
            DBG_HOMENET,
            "%s is availble for connection on socket %u",
            DebugText,
            (ListenSockets->End / sizeof (LISTENSOCKET)) - 1
            ));
    }

    return listenSocket;
}


INT
pOpenListenSockets (
    OUT     PGROWBUFFER ListenSockets
    )

/*++

Routine Description:

  pOpenListenSockets opens a connection socket on each supported protocol.

Arguments:

  ListenSockets - Receives an array of LISTENSOCKET elements (one for each
                  protocol).  IMPORTANT: This parameter must be
                  zero-initialized by the caller.

Return Value:

  The number of elements in ListenSockets, or zero on failure.

--*/

{
    SOCKADDR_IPX ipxAddr;
    SOCKADDR_IN tcpipAddr;

    MYASSERT (!ListenSockets->Buf && !ListenSockets->End);

    //
    // Open sockets to accept inbound connections
    //

    // SPX
    ZeroMemory (&ipxAddr, sizeof (ipxAddr));
    ipxAddr.sa_family = AF_IPX;
    ipxAddr.sa_socket = IPX_CONNECT_PORT;

    pOpenOneListenSocket (
        ListenSockets,
        (SOCKADDR *) &ipxAddr,
        sizeof (ipxAddr),
        AF_IPX,
        FALSE,
        NSPROTO_SPX,
        TEXT("SPX")
        );

    // TCP/IP
    ZeroMemory (&tcpipAddr, sizeof (tcpipAddr));
    tcpipAddr.sin_family = AF_INET;
    tcpipAddr.sin_port = TCPIP_CONNECT_PORT;

    pOpenOneListenSocket (
        ListenSockets,
        (SOCKADDR *) &tcpipAddr,
        sizeof (tcpipAddr),
        AF_INET,
        FALSE,
        IPPROTO_TCP,
        TEXT("TCP")
        );

    return ListenSockets->End / sizeof (LISTENSOCKET);
}


PCTSTR
pGetNameFromMessage (
    IN      PCWSTR Message
    )

/*++

Routine Description:

  pGetNameFromMessage extracts the computer name from a broadcast.

Arguments:

  Message - Specifies the encoded message.

Return Value:

  The computer name encoded in the message, or NULL if the message is garbage.

--*/

{
    PCTSTR message = NULL;
    PCTSTR orgMessage = NULL;
    TCHAR sigStr [sizeof (TEXT("0xFFFFFFFF"))];
    DWORD signature = 0;
    PCTSTR p;
    PCTSTR name = NULL;
    INT len;
    CHARTYPE ch;
    PCTSTR tag = S_64CHARTAG;       // must be 64 chars
    TCHAR alternateTag[NAME_SIZE_PLUS_NUL];
    TCHAR prefix[NAME_SIZE_PLUS_COMMA_PLUS_NUL];
    PTSTR q, r;

#ifdef UNICODE
    orgMessage = Message;
#else
    orgMessage = ConvertWtoA (Message);
#endif

    if (!orgMessage) {
        return name;
    }

    message = orgMessage;

    __try {

        p = _tcschr (message, TEXT(','));
        if (!p) {
            DEBUGMSG ((DBG_HOMENET, "Invalid Signature"));
            __leave;
        }

        ZeroMemory (sigStr, sizeof (sigStr));
        CopyMemory (sigStr, message, min (sizeof (sigStr) - 1, ((UINT)(p - message)) * sizeof (TCHAR)));
        _stscanf (sigStr, TEXT("0x%08X"), &signature);
        if (signature != HOMENETTR_SIG) {
            DEBUGMSG ((DBG_HOMENET, "Signature does not match"));
            __leave;
        }

        message = _tcsinc (p);
        if (!message) {
            DEBUGMSG ((DBG_HOMENET, "Invalid Signature"));
            __leave;
        }

        if (IsmCopyEnvironmentString (PLATFORM_SOURCE, NULL, TRANSPORT_ENVVAR_HOMENET_TAG, alternateTag)) {

            q = GetEndOfString (alternateTag);
            r = alternateTag + NAME_SIZE;

            while (q < r) {
                *q++ = TEXT('@');
            }

            *r = 0;

            tag = alternateTag;
        }

        DEBUGMSG ((DBG_HOMENET, "Comparing our tag %s against message %s", tag, message));

        StringCopy (prefix, tag);
        StringCat (prefix, TEXT(","));

        if (StringIPrefix (message, prefix)) {

            p = message + NAME_SIZE_PLUS_COMMA;
            len = 0;

            while (*p) {

                ch = (CHARTYPE) _tcsnextc (p);
                p = _tcsinc (p);

                if (ch == TEXT(',')) {
                    break;
                }

                if (ch < TEXT('0') || ch > TEXT('9')) {
                    break;
                }

                len = len * 10 + (ch - TEXT('0'));
            }

            if (ch == TEXT(',') && len < MAX_COMPUTER_NAME) {

                name = p;

                while (*p && len) {
                    if (*p < 32) {
                        break;
                    }

                    p++;
                    len--;
                }

                if (len || *p) {
                    name = NULL;
                }
            }
        }
        ELSE_DEBUGMSG ((DBG_HOMENET, "TAG does not match"));
    }
    __finally {
#ifndef UNICODE
        if (orgMessage) {
            FreeConvertedStr (orgMessage);
            orgMessage = NULL;
        }
#endif
    }

    return name;
}


VOID
pTranslateBroadcastAddrToConnectAddr (
    IN      INT Family,
    IN OUT  PINT Protocol,
    IN OUT  PBOOL Datagram,
    IN OUT  SOCKADDR *SockAddr
    )

/*++

Routine Description:

  pTranslateBroadcastAddrToConnectAddr transforms a broadcast address into a
  connection address.  The broadcast address is typically obtained from a
  datagram response, and must be transformed before accepting a sequenced
  connection.

Arguments:

  Family   - Specifies the protocol family
  Protocol - Specifies the datagram protocol; receives the sequenced packet
             protocol if available
  Datagram - Specifies a pointer to FALSE, receives TRUE if the protocol does
             not support sequenced connections.
  SockAddr - Specifies the peer socket address. Receives the updated address
             (a different port is used for connections).

Return Value:

  None.

--*/

{
    SOCKADDR_IPX *ipxAddr;
    SOCKADDR_IN *tcpipAddr;

    switch (Family) {

    case AF_INET:
        *Protocol = IPPROTO_TCP;
        tcpipAddr = (SOCKADDR_IN *) SockAddr;
        tcpipAddr->sin_port = TCPIP_CONNECT_PORT;
        break;

    case AF_IPX:
        *Protocol = NSPROTO_SPX;
        ipxAddr = (SOCKADDR_IPX *) SockAddr;
        ipxAddr->sa_socket = IPX_CONNECT_PORT;
        break;

    }
}


VOID
pResetPort (
    IN      INT Family,
    IN OUT  SOCKADDR *SockAddr
    )

/*++

Routine Description:

  pResetPort sets the port to zero for TCP/IP, so that the system will pick
  an unused port for the local address.  This is used when connecting.

Arguments:

  Family   - Specifies the protocol family (such as AF_INET)
  SockAddr - Specifies the address to reset

Return Value:

  None.

--*/

{
    SOCKADDR_IN *tcpipAddr;

    switch (Family) {

    case AF_INET:
        tcpipAddr = (SOCKADDR_IN *) SockAddr;
        tcpipAddr->sin_port = 0;
        break;
    }
}


INT
pSourceBroadcast (
    IN OUT  PBROADCASTARGS Args
    )

/*++

Routine Description:

  pSourceBroadcast implements the name resolution mechanism for the source
  end of the connection. This involves checking for cancel, collecting
  inbound datagrams from all transports, and parsing the datagrams to obtain
  the server name.

Arguments:

  Args - Specifies a structure containing all of the parameters, such as
         the socket array and socket addresses.

Return Value:

  The number of server addresses collected, or 0 if the collection was
  cancelled.

--*/

{
    INT i;
    INT bytesIn;
    DWORD rc;
    WCHAR message[256];
    FD_SET set;
    TIMEVAL zero = {0,0};
    INT waitCycle = -1;
    BOOL result = FALSE;
    PCTSTR name;
    PCONNECTADDRESS address;
    PCONNECTADDRESS end;
    PBROADCASTSOCKET broadcastSocket;
    BYTE remoteAddr[MAX_SOCKADDR];
    INT remoteAddrLen;
    DWORD startTick = GetTickCount();

    for (;;) {
        //
        // Check cancel
        //

        if (g_StopHandle) {
            rc = WaitForSingleObject (g_StopHandle, 0);
        } else {
            rc = WAIT_FAILED;
        }

        if (rc == WAIT_OBJECT_0 || IsmCheckCancel()) {
            result = FALSE;
            break;
        }

        //
        // Check time to live
        //

        if (Args->Timeout) {
            if (((GetTickCount() - startTick) / 1000) >= Args->Timeout) {
                DEBUGMSG ((DBG_HOMENET, "Name search timed out"));
                break;
            }
        }

        if (waitCycle > -1) {
            waitCycle--;

            if (!waitCycle) {
                break;
            }
        }

        //
        // Check for a message
        //

        FD_ZERO (&set);
        for (i = 0 ; i < Args->BroadcastCount ; i++) {
            FD_SET (Args->BroadcastSockets[i].Socket, &set);
        }

        i = select (0, &set, NULL, NULL, &zero);

        if (i > 0) {

            for (i = 0 ; i < Args->BroadcastCount ; i++) {

                broadcastSocket = &Args->BroadcastSockets[i];

                if (FD_ISSET (broadcastSocket->Socket, &set)) {

                    remoteAddrLen = MAX_SOCKADDR;

                    bytesIn = recvfrom (
                                    broadcastSocket->Socket,
                                    (PSTR) message,
                                    254 * sizeof (WCHAR),
                                    0,
                                    (SOCKADDR *) remoteAddr,
                                    &remoteAddrLen
                                    );

                    if (bytesIn >= (MIN_MESSAGE_SIZE * sizeof (WCHAR))) {
                        message[bytesIn] = 0;
                        message[bytesIn + 1] = 0;

                        //
                        // Parse the inbound text.  It must be in the format of
                        //
                        //      <signature>,<tag>,<tchars>,<name>
                        //
                        // <tag> must be 64 characters, and is usmt-v2 by default
                        // (followed by fill numbers).
                        //

                        name = pGetNameFromMessage (message);

                        if (name) {

                            // once we receive something, wait 5 additional seconds for other inbound datagrams
                            if (waitCycle == -1) {
                                waitCycle = 20;
                            }

                            result = TRUE;

                            //
                            // Scan the address list for the name
                            //

                            address = (PCONNECTADDRESS) Args->AddressArray->Buf;
                            end = (PCONNECTADDRESS) (Args->AddressArray->Buf + Args->AddressArray->End);

                            while (address < end) {
                                if (StringIMatch (address->DestinationName, name)) {
                                    if (address->Family == broadcastSocket->Family) {
                                        break;
                                    }
                                }

                                address++;
                            }

                            if (address >= end) {
                                //
                                // New computer name; add to the address list
                                //

                                address = (PCONNECTADDRESS) GbGrow (Args->AddressArray, sizeof (CONNECTADDRESS));

                                address->RemoteAddressLen = remoteAddrLen;
                                CopyMemory (address->RemoteAddress, remoteAddr, remoteAddrLen);

                                address->LocalAddressLen = MAX_SOCKADDR;
                                if (getsockname (
                                        broadcastSocket->Socket,
                                        (SOCKADDR *) address->LocalAddress,
                                        &address->LocalAddressLen
                                        )) {
                                    address->LocalAddressLen = broadcastSocket->AddressLen;
                                    ZeroMemory (address->LocalAddress, broadcastSocket->AddressLen);
                                    DEBUGMSG ((DBG_HOMENET, "Failed to get local socket name; using nul name instead"));
                                }

                                address->Family = broadcastSocket->Family;
                                address->Protocol = broadcastSocket->Protocol;
                                address->Datagram = FALSE;

                                pTranslateBroadcastAddrToConnectAddr (
                                    address->Family,
                                    &address->Protocol,
                                    &address->Datagram,
                                    (SOCKADDR *) &address->RemoteAddress
                                    );

                                StringCopy (address->DestinationName, name);

                                DEBUGMSG ((DBG_HOMENET, "Destination found: %s (protocol %i)", name, address->Family));
                            }
                        }
                        ELSE_DEBUGMSGW ((DBG_HOMENET, "garbage found: %s", message));
                    }
                }
            }
        }

        Sleep (250);
    }

    return result ? Args->AddressArray->End / sizeof (CONNECTADDRESS) : 0;
}


BOOL
pIsAddrFromLocalSubnet (
    IN      SOCKET Socket,
    IN      INT Family,
    IN      SOCKADDR *Address,
    IN      INT AddressLength
    )
{
    SOCKADDR_IPX *ipxAddr;
    SOCKADDR_IN *tcpipAddr;
    BOOL result = TRUE;
    IPX_ADDRESS_DATA ipxLocalAddr;
    INT size;
    PWSAIOCTL wsaIoctlFn;
    HANDLE lib;
    INT rc;
    INTERFACE_INFO info[32];
    DWORD bytesRead;
    INT i;
    INT j;
    SOCKADDR_IN localAddr;
    PBYTE localNetPtr;
    PBYTE remoteNetPtr;
    PBYTE subnetMaskPtr;
    INT k;

    switch (Family) {

    case AF_INET:
        tcpipAddr = (SOCKADDR_IN *) Address;

        i = sizeof (localAddr);
        if (getsockname (Socket, (SOCKADDR *) &localAddr, &i)) {
            DEBUGMSG ((DBG_ERROR, "Can't get local socket addr"));
            break;
        }

        lib = LoadLibrary (TEXT("ws2_32.dll"));
        if (lib) {

            wsaIoctlFn = (PWSAIOCTL) GetProcAddress (lib, "WSAIoctl");

            if (wsaIoctlFn) {
                rc = wsaIoctlFn (
                        Socket,
                        SIO_GET_INTERFACE_LIST,
                        NULL,
                        0,
                        info,
                        sizeof (info),
                        &bytesRead,
                        NULL,
                        NULL
                        );

                if (rc != SOCKET_ERROR) {

                    j = (INT) (bytesRead / sizeof (INTERFACE_INFO));

                    for (i = 0 ; i < j ; i++) {

                        if (!memcmp (
                                &localAddr.sin_addr,
                                &info[i].iiAddress.AddressIn.sin_addr,
                                sizeof (struct in_addr)
                                )) {

                            localNetPtr = (PBYTE) &localAddr.sin_addr;
                            remoteNetPtr = (PBYTE) &info[i].iiAddress.AddressIn.sin_addr;
                            subnetMaskPtr = (PBYTE) &info[i].iiNetmask.AddressIn.sin_addr;

                            for (k = 0 ; k < sizeof (struct in_addr) ; k++) {
                                localNetPtr[k] &= subnetMaskPtr[k];
                                remoteNetPtr[k] &= subnetMaskPtr[k];

                                if (localNetPtr[k] != remoteNetPtr[k]) {
                                    break;
                                }
                            }

                            if (k < sizeof (struct in_addr)) {
                                LOG ((LOG_WARNING, (PCSTR) MSG_REFUSE_OUTSIDE_CONNECTION));
                            } else {
                                DEBUGMSG ((DBG_HOMENET, "Found interface on the same subnet!"));
                            }

                            break;
                        }
                    }
                }
                ELSE_DEBUGMSG ((DBG_ERROR, "WSAIoctl failed"));
            }
            ELSE_DEBUGMSG ((DBG_WARNING, "Can't load WSAIoctl"));

            FreeLibrary (lib);
        }
        ELSE_DEBUGMSG ((DBG_WARNING, "Can't load ws2_32.dll"));

        break;

    case AF_IPX:
        ipxAddr = (SOCKADDR_IPX *) Address;

        //
        // Compare the specified address against the local address of the socket
        //

        size = sizeof (ipxLocalAddr);

        if (!getsockopt (Socket, NSPROTO_IPX, IPX_GETNETINFO, (PBYTE) &ipxLocalAddr, &size)) {
            if (memcmp (ipxAddr->sa_netnum, ipxLocalAddr.netnum, 4)) {
                if (ipxAddr->sa_netnum[0] || ipxAddr->sa_netnum[1] ||
                    ipxAddr->sa_netnum[2] || ipxAddr->sa_netnum[3]
                    ) {

                    LOG ((LOG_WARNING, (PCSTR) MSG_REFUSE_OUTSIDE_CONNECTION_IPX));
                    result = FALSE;

                }
            }
        }

        break;

    }

    return result;
}


BOOL
pDestinationBroadcast (
    IN OUT  PBROADCASTARGS Args
    )

/*++

Routine Description:

  pDestinationBroadcast implements the name resolution mechanism for the
  destination end of the connection. This involves checking for cancel, and
  sending out regular datagrams to all transports to provide the server name.

  At the same time, listen connections are monitored, and the datagram traffic
  is stopped once one connection is accepted.

Arguments:

  Args - Specifies a structure containing all of the parameters, such as the
         socket array and socket addresses. Receives the connection address.

Return Value:

  TRUE if a connection was accepted, or FALSE if cancel was detected.

--*/

{
    INT i;
    DWORD rc;
    INT socketNum = 0;
    WCHAR message[256];
    TCHAR name[128];
    UINT size;
    FD_SET set;
    TIMEVAL zero = {0,0};
    PBROADCASTSOCKET broadcastSocket;
    BOOL result = FALSE;
    PCTSTR tag = S_64CHARTAG;       // must be 64 chars
    TCHAR alternateTag[NAME_SIZE_PLUS_NUL];
    PTSTR p, q;
    LINGER linger;

    size = MAX_COMPUTER_NAME;
    GetComputerName (name, &size);

    //
    // Get the tag that is registered in the environment
    //

    if (IsmCopyEnvironmentString (PLATFORM_DESTINATION, NULL, TRANSPORT_ENVVAR_HOMENET_TAG, alternateTag)) {

        p = GetEndOfString (alternateTag);
        q = alternateTag + NAME_SIZE;

        if (p) {
            while (p < q) {
                *p++ = TEXT('@');
            }
        }

        *q = 0;

        tag = alternateTag;
    }

    DEBUGMSG ((DBG_HOMENET, "Broadcasting using the following tag: %s", tag));

#ifdef UNICODE
    size = wsprintfW (message, L"0x%08X,%s,%u,%s", HOMENETTR_SIG, tag, TcharCount (name), name);
#else
    size = wsprintfW (message, L"0x%08X,%S,%u,%S", HOMENETTR_SIG, tag, TcharCount (name), name);
#endif
    size = (size + 1) * sizeof (WCHAR);

    for (;;) {
        //
        // Check cancel
        //

        if (g_StopHandle) {
            rc = WaitForSingleObject (g_StopHandle, 0);
        } else {
            rc = WAIT_FAILED;
        }

        if (rc == WAIT_OBJECT_0 || IsmCheckCancel()) {
            break;
        }

        if (g_BackgroundThreadTerminate) {
            rc = WaitForSingleObject (g_BackgroundThreadTerminate, 0);

            if (rc == WAIT_OBJECT_0) {
                break;
            }
        }

        //
        // Send out the message
        //

        broadcastSocket = &Args->BroadcastSockets[socketNum];

        i = sendto (
                broadcastSocket->Socket,
                (PSTR) message,
                size,
                0,
                (SOCKADDR *) broadcastSocket->BroadcastAddress,
                broadcastSocket->AddressLen
                );

        if (i == SOCKET_ERROR) {
            DEBUGMSG ((DBG_VERBOSE, "Error sending on socket %u: %u", socketNum, WSAGetLastError()));
        } else {
            Sleep (350);
            DEBUGMSG ((DBG_HOMENET, "Sent data on socket %u", socketNum));
        }

        socketNum++;
        if (socketNum >= Args->BroadcastCount) {
            socketNum = 0;
        }

        //
        // Check for an inbound connection
        //

        FD_ZERO (&set);
        for (i = 0 ; i < Args->ListenCount ; i++) {
            FD_SET (Args->ListenSockets[i].Socket, &set);
        }

        i = select (0, &set, NULL, NULL, &zero);

        if (i > 0) {
            DEBUGMSG ((DBG_HOMENET, "Connection request count = %i", i));
            for (i = 0 ; i < Args->ListenCount ; i++) {
                if (FD_ISSET (Args->ListenSockets[i].Socket, &set)) {

                    Args->ConnectionSocket.RemoteAddressLen = MAX_SOCKADDR;

                    if (!Args->ListenSockets[i].Datagram) {
                        Args->ConnectionSocket.Socket = accept (
                                                            Args->ListenSockets[i].Socket,
                                                            (SOCKADDR *) Args->ConnectionSocket.RemoteAddress,
                                                            &Args->ConnectionSocket.RemoteAddressLen
                                                            );

                        //
                        // Verify socket connection is on the subnet only
                        //

                        if (!pIsAddrFromLocalSubnet (
                                Args->ConnectionSocket.Socket,
                                Args->ListenSockets[i].Family,
                                (SOCKADDR *) Args->ConnectionSocket.RemoteAddress,
                                Args->ConnectionSocket.RemoteAddressLen
                                )) {

                            LOG ((LOG_WARNING, (PCSTR) MSG_OUTSIDE_OF_LOCAL_SUBNET));
                            closesocket (Args->ConnectionSocket.Socket);
                            Args->ConnectionSocket.Socket = INVALID_SOCKET;
                        } else {

                            linger.l_onoff = 1;
                            linger.l_linger = IDLE_TIMEOUT;

                            setsockopt (
                                Args->ConnectionSocket.Socket,
                                SOL_SOCKET,
                                SO_LINGER,
                                (PBYTE) &linger,
                                sizeof (linger)
                                );

                            DEBUGMSG ((DBG_HOMENET, "Connection requested"));
                        }

                    } else {

                        DEBUGMSG ((DBG_HOMENET, "Accepting datagram connection"));

                        if (DuplicateHandle (
                                GetCurrentProcess(),
                                (HANDLE) Args->ListenSockets[i].Socket,
                                GetCurrentProcess(),
                                (HANDLE *) &Args->ConnectionSocket.Socket,
                                0,
                                FALSE,
                                DUPLICATE_SAME_ACCESS
                                )) {

                            getpeername (
                                Args->ConnectionSocket.Socket,
                                (SOCKADDR *) Args->ConnectionSocket.RemoteAddress,
                                &Args->ConnectionSocket.RemoteAddressLen
                                );
                        } else {
                            DEBUGMSG ((DBG_ERROR, "Can't duplicate socket handle"));
                            Args->ConnectionSocket.Socket = INVALID_SOCKET;
                        }
                    }

                    if (Args->ConnectionSocket.Socket != INVALID_SOCKET) {

                        Args->ConnectionSocket.Family = Args->ListenSockets[i].Family;
                        Args->ConnectionSocket.Protocol = Args->ListenSockets[i].Protocol;

                        Args->ConnectionSocket.Datagram = Args->ListenSockets[i].Datagram;
                        ZeroMemory (&Args->ConnectionSocket.DatagramPool, sizeof (DATAGRAM_POOL));
                        if (Args->ConnectionSocket.Datagram) {
                            Args->ConnectionSocket.DatagramPool.Pool = PmCreatePool();
                            Args->ConnectionSocket.DatagramPool.LastPacketNumber = (UINT) -1;
                        }

                        Args->ConnectionSocket.LocalAddressLen = MAX_SOCKADDR;
                        if (getsockname (
                                Args->ConnectionSocket.Socket,
                                (SOCKADDR *) Args->ConnectionSocket.LocalAddress,
                                &Args->ConnectionSocket.LocalAddressLen
                                )) {
                            Args->ConnectionSocket.LocalAddressLen = broadcastSocket->AddressLen;
                            ZeroMemory (Args->ConnectionSocket.LocalAddress, broadcastSocket->AddressLen);
                            DEBUGMSG ((DBG_HOMENET, "Failed to get local socket name; using nul name instead"));
                        }

                        DEBUGMSG ((DBG_HOMENET, "Connection accepted"));

                        result = TRUE;
                        break;
                    } else {
                        DEBUGMSG ((DBG_ERROR, "select indicated connection, but accept failed"));
                    }
                }
            }

            if (result) {
                break;
            }
        }
    }

    return result;
}


BOOL
pGetDomainUserName (
    OUT     PTSTR UserNameBuf       // 65 char buffer
    )
{
    HKEY domainLogonKey;
    PDWORD data;
    BOOL result = TRUE;
    DWORD size;
    NET_API_STATUS rc;
    PWKSTA_INFO_102 buffer;
    HANDLE netApi32Lib;
    PNETWKSTAGETINFO netWkstaGetInfo;
    PNETAPIBUFFERFREE netApiBufferFree;
    BYTE sid[256];
    DWORD sidSize;
    WCHAR domain[256];
    DWORD domainSize;
    SID_NAME_USE use;

    if (!ISNT()) {
        //
        // Require the Log On To Domain setting to be checked
        //

        SetLastError (ERROR_SUCCESS);

        domainLogonKey = OpenRegKeyStr (TEXT("HKLM\\Network\\Logon"));
        if (!domainLogonKey) {
            DEBUGMSG ((DBG_HOMENET, "No HKLM\\Network\\Logon key"));
            return FALSE;
        }

        data = (PDWORD) GetRegValueBinary (domainLogonKey, TEXT("LMLogon"));
        if (!data) {
            DEBUGMSG ((DBG_HOMENET, "No LMLogon value"));
            result = FALSE;
        } else {

            if (!(*data)) {
                DEBUGMSG ((DBG_HOMENET, "Domain logon is not enabled"));
                result = FALSE;
            }

            FreeAlloc (data);
        }

        CloseRegKey (domainLogonKey);

    } else {
        //
        // Require domain membership
        //

        netApi32Lib = LoadLibrary (TEXT("netapi32.dll"));
        if (netApi32Lib) {
            netWkstaGetInfo = (PNETWKSTAGETINFO) GetProcAddress (netApi32Lib, "NetWkstaGetInfo");
            netApiBufferFree = (PNETAPIBUFFERFREE) GetProcAddress (netApi32Lib, "NetApiBufferFree");
        } else {
            netWkstaGetInfo = NULL;
            netApiBufferFree = NULL;
        }

        if (!netWkstaGetInfo || !netApiBufferFree) {
            DEBUGMSG ((DBG_HOMENET, "Can't get net wksta apis"));
            result = FALSE;
        } else {

            rc = netWkstaGetInfo (NULL, 102, (PBYTE *) &buffer);

            if (rc == NO_ERROR) {
                result = buffer->wki102_langroup && (buffer->wki102_langroup[0] != 0);
                if (result) {
                    DEBUGMSGW ((DBG_HOMENET, "Getting account type of %s", buffer->wki102_langroup));

                    sidSize = ARRAYSIZE(sid);
                    domainSize = ARRAYSIZE(domain);

                    result = LookupAccountNameW (
                                    NULL,
                                    buffer->wki102_langroup,
                                    sid,
                                    &sidSize,
                                    domain,
                                    &domainSize,
                                    &use
                                    );
                    DEBUGMSG ((DBG_HOMENET, "Account type result is %u (use=%u)", result, use));
                }
                ELSE_DEBUGMSG ((DBG_HOMENET, "No langroup specified"));

                netApiBufferFree (buffer);
            } else {
                DEBUGMSG ((DBG_HOMENET, "Can't get net wksta info"));
                result = FALSE;
            }
        }

        if (netApi32Lib) {
            FreeLibrary (netApi32Lib);
        }
    }

    //
    // Make sure a user name is specified
    //

    if (result) {
        size = NAME_SIZE_PLUS_NUL;
        if (!GetUserName (UserNameBuf, &size)) {
            result = FALSE;
        } else if (*UserNameBuf == 0) {
            result = FALSE;
        }

        if (result) {
            DEBUGMSG ((DBG_HOMENET, "Domain user: %s", UserNameBuf));
        } else {
            DEBUGMSG ((DBG_HOMENET, "Not on domain"));
        }
    }

    return result;
}


INT
pNameResolver (
    IN      MIG_PLATFORMTYPEID Platform,
    OUT     PGROWBUFFER AddressBuffer,
    IN      UINT SourceTimeout,
    OUT     PCONNECTIONSOCKET ConnectionSocket
    )

/*++

Routine Description:

  pNameResolver implements the name resolution protocol. The source side
  collects datagrams, looking for a destination to choose from. The
  destination side sends out broadcasts to announce themselves, and accepts a
  connection from the source.

  At the end of name resolution, an event is signaled. This is used for
  coordination with cancel.

Arguments:

  AddressBuffer - Receives the array of addresses that is used on the
                  source side to collect a list of destinations.
                  This buffer must be zero-initialized by the caller.
                  This argument is NULL on the destination side.

  SourceTimeout - Specifies the number of seconds to wait for a broadcast,
                  or zero to wait forever. The timeout only affects the
                  source side.

  ConnectionSocket - Receives the connection socket and address information
                     that is used on the destination side.  This argument
                     is NULL on the source side.

Return Value:

  Source Side: The number of addresses in AddressBuffer, or zero if an error
               occurred

  Destination Side: 1 indicating that ConnectionSocket is valid, or zero if
                    an error occurred.

--*/

{
    BROADCASTARGS args;
    INT i;
    INT result = 0;
    BOOL b;
    BOOL connected = FALSE;
    GROWBUFFER broadcastSockets = INIT_GROWBUFFER;
    GROWBUFFER listenSockets = INIT_GROWBUFFER;
    INT broadcastSocketCount;
    INT listenSocketCount = 0;
    BOOL destinationMode;
    TCHAR envTag[NAME_SIZE_PLUS_NUL];

    __try {
        //
        // If tag is not set, then force it to the user name if domains are enabled
        //

        if (!IsmCopyEnvironmentString (Platform, NULL, TRANSPORT_ENVVAR_HOMENET_TAG, envTag)) {
            if (pGetDomainUserName (envTag)) {
                IsmSetEnvironmentString (Platform, NULL, TRANSPORT_ENVVAR_HOMENET_TAG, envTag);
            }
        }

        if (!AddressBuffer && ConnectionSocket) {
            destinationMode = TRUE;
        } else if (AddressBuffer && !ConnectionSocket) {
            destinationMode = FALSE;
        } else {
            MYASSERT (FALSE);
            __leave;
        }

        //
        // In source mode, we collect datagrams sent by destinations on the network.  After
        // the first datagram is received, collection continues for 15 seconds.  At
        // that point, we have a list of socket addresses, protocol, and destination names.
        //
        // In destination mode, we send out periodic broadcasts, and we wait until a source
        // connects or the cancel event is signaled.
        //

        broadcastSocketCount = pOpenBroadcastSockets (&broadcastSockets);

        if (!broadcastSocketCount) {
            __leave;
        }

        if (destinationMode) {
            listenSocketCount = pOpenListenSockets (&listenSockets);

            if (!listenSocketCount) {
                DEBUGMSG ((DBG_ERROR, "Able to set up broadcast sockets but not connection sockets"));
                __leave;
            }
        }

        // call mode-specific routine
        ZeroMemory (&args, sizeof (args));

        args.AddressArray = AddressBuffer;
        args.BroadcastSockets = (PBROADCASTSOCKET) broadcastSockets.Buf;
        args.BroadcastCount = broadcastSocketCount;
        args.ListenSockets = (PLISTENSOCKET) listenSockets.Buf;
        args.ListenCount = listenSocketCount;
        args.Timeout = SourceTimeout;

        b = destinationMode ? pDestinationBroadcast (&args) : pSourceBroadcast (&args);

        //
        // Clean up all sockets
        //

        PushError();

        for (i = 0 ; i < args.BroadcastCount ; i++) {
            closesocket (args.BroadcastSockets[i].Socket);
        }

        if (destinationMode) {
            for (i = 0 ; i < args.ListenCount ; i++) {
                closesocket (args.ListenSockets[i].Socket);
            }
        }

        PopError();

        if (b) {
            if (destinationMode) {
                CopyMemory (ConnectionSocket, &args.ConnectionSocket, sizeof (CONNECTIONSOCKET));
                result = 1;
            } else {
                result = AddressBuffer->End / sizeof (CONNECTADDRESS);
            }
        }
    }
    __finally {
        PushError();

        GbFree (&broadcastSockets);
        GbFree (&listenSockets);
        if (g_ConnectionDone) {
            SetEvent (g_ConnectionDone);
        }

        PopError();
    }

    return result;
}


INT
pSendWithTimeout (
    IN      SOCKET Socket,
    IN      PCBYTE Data,
    IN      UINT DataLen,
    IN      INT Flags
    )
{
    FD_SET writeSet;
    FD_SET errorSet;
    TIMEVAL timeout = {1,0};
    UINT timeToLive = GetTickCount() + IDLE_TIMEOUT * 1000;
    INT result;

    //
    // Wait up to IDLE_TIMEOUT seconds for the socket to be sendable
    //

    do {

        FD_ZERO (&writeSet);
        FD_SET (Socket, &writeSet);
        FD_ZERO (&errorSet);
        FD_SET (Socket, &errorSet);

        //
        // Check the ISM cancel flag
        //

        if (IsmCheckCancel ()) {
            SetLastError (ERROR_CANCELLED);
            return SOCKET_ERROR;
        }

        //
        // Wait 1 second for the socket to be writable
        //

        result = select (0, NULL, &writeSet, &errorSet, &timeout);

        if (result) {
            if (FD_ISSET (Socket, &writeSet)) {
                return send (Socket, Data, DataLen, Flags);
            }

            LOG ((LOG_ERROR, (PCSTR) MSG_SOCKET_HAS_ERROR));
            return SOCKET_ERROR;
        }

    } while ((timeToLive - GetTickCount()) < IDLE_TIMEOUT * 1000);

    LOG ((LOG_ERROR, (PCSTR) MSG_SOCKET_SEND_TIMEOUT));
    return SOCKET_ERROR;
}


BOOL
pSendExactData (
    IN      SOCKET Socket,
    IN      PCBYTE Data,
    IN      UINT DataLen
    )

/*++

Routine Description:

  pSendExactData sends data to the specified socket.

  [TODO: need to support datagram mode]

Arguments:

  Socket  - Specifies the socket to send data to
  Data    - Specifies the data to send
  DataLen - Specifies the number of bytes in Data

Return Value:

  TRUE if the data was sent, FALSE otherwise.

--*/

{
    INT result;
    PCBYTE pos;
    UINT bytesLeft;
    UINT packetSize;

    bytesLeft = DataLen;
    pos = Data;

    while (bytesLeft) {
        if (IsmCheckCancel()) {
            return FALSE;
        }

        packetSize = min (1024, bytesLeft);
        result = pSendWithTimeout (Socket, pos, packetSize, 0);

        if (result > 0) {
            bytesLeft -= (UINT) result;
            pos += result;
        } else {
            if (GetLastError() == WSAENOBUFS) {
                Sleep (100);
            } else {
                return FALSE;
            }
        }
    }

    return bytesLeft == 0;
}


BOOL
pSendDatagramData (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,
    IN      PCBYTE Data,
    IN      UINT DataLen
    )

/*++

Routine Description:

  pSendDatagramData puts data on the wire in the form of small, numbered
  packets. The packets can potentially scatter and be received out of order,
  so the packets are numbered such that they can be reassembled properly.

  It is assumed that the datagram protocol is reliable (datagrams are not
  dropped), and that the underlying protocol implements the naggle algorithm
  to cache packets for efficiency.

Arguments:

  Socket       - Specifies the datagram socket to send data on
  DatagramPool - Specifies a structure that is used to track packets
  Data         - Specifies the data to send
  DataLen      - Specifies the length of the data to send

Return Value:

  TRUE if data was sent, FALSE otherwise

--*/

{
    PDATAGRAM_PACKET header;
    BYTE buffer[512];
    PBYTE dataPtr;
    UINT bytesSent = 0;
    UINT bytesToSend;

    header = (PDATAGRAM_PACKET) buffer;
    dataPtr = (PBYTE) (&header[1]);

    do {

        bytesToSend = DataLen - bytesSent;
        bytesToSend = min (bytesToSend, 256);

        header->PacketNumber = DatagramPool->SendSequenceNumber;
        DatagramPool->SendSequenceNumber++;
        header->DataLength = (WORD) bytesToSend;

        CopyMemory (dataPtr, Data, bytesToSend);

        if (!pSendExactData (
                Socket,
                (PBYTE) header,
                bytesToSend + sizeof (DATAGRAM_PACKET)
                )) {
            break;
        }

        Data += bytesToSend;
        bytesSent += bytesToSend;

    } while (bytesSent < DataLen);

    return bytesSent == DataLen;
}


BOOL
pSendData (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,        OPTIONAL
    IN      PCBYTE Data,
    IN      UINT DataLen
    )
{
    if (!DatagramPool) {
        return pSendExactData (Socket, Data, DataLen);
    }

    return pSendDatagramData (Socket, DatagramPool, Data, DataLen);
}


INT
pRecvWithTimeout (
    IN      SOCKET Socket,
    IN      PBYTE Data,
    IN      UINT DataLen,
    IN      INT Flags,
    IN      UINT Timeout    OPTIONAL
    )

/*++

Routine Description:

  pRecvWithTimeout implements a basic socket recv call with a IDLE_TIMEOUT second
  timeout and with a check for the ISM cancel flag.

Arguments:

  Socket - Specifies the socket to recv from

  Data - Specifies the data buffer

  DataLen - Specifies the length of data buffer

  Flags - Specifies zero for normal recv, or MSG_PEEK

Return Value:

  The number of bytes read, or SOCKET_ERROR.  GetLastError contains the reason
  for failure.

--*/

{
    FD_SET readSet;
    FD_SET errorSet;
    TIMEVAL timeout = {1,0};
    INT timeToLive;
    INT result;

    if (Timeout == 0) {
        Timeout = IDLE_TIMEOUT * 1000;
    }

    timeToLive = GetTickCount() + Timeout;

    //
    // Wait up to IDLE_TIMEOUT seconds for the socket to have data
    //

    do {
        FD_ZERO (&readSet);
        FD_SET (Socket, &readSet);
        FD_ZERO (&errorSet);
        FD_SET (Socket, &errorSet);

        //
        // Check the ISM cancel flag
        //

        if (IsmCheckCancel ()) {
            SetLastError (ERROR_CANCELLED);
            return SOCKET_ERROR;
        }

        //
        // Wait 1 second for the socket to be readable
        //

        result = select (0, &readSet, NULL, &errorSet, &timeout);

        if (result) {
            if (FD_ISSET (Socket, &readSet)) {
                result = recv (Socket, Data, DataLen, Flags);
                return result;
            }

            if (FD_ISSET (Socket, &errorSet)) {
                LOG ((LOG_ERROR, (PCSTR) MSG_SOCKET_HAS_ERROR));
                return SOCKET_ERROR;
            }

            DEBUGMSG ((DBG_HOMENET, "select returned %i but socket is not in readSet or errorSet", result));
        }

    } while ((timeToLive - GetTickCount()) < Timeout);

    LOG ((LOG_ERROR, (PCSTR) MSG_SOCKET_RECV_TIMEOUT));
    return SOCKET_ERROR;
}


PBYTE
pReceiveExactData (
    IN      SOCKET Socket,
    IN OUT  PGROWBUFFER Buffer,         OPTIONAL
    OUT     PBYTE AlternateBuffer,      OPTIONAL
    IN      UINT BytesToReceive,
    IN      UINT Timeout                OPTIONAL
    )

/*++

Routine Description:

  pReceiveExactData allocates a buffer from the caller-specified grow buffer,
  and receives data until the buffer is full, or until receive fails.

Arguments:

  Socket          - Specifies the socket to receive data on. The socket must
                    be in blocking mode.
  Buffer          - Specifies the buffer to allocate from; the end pointer is
                    reset to zero. Receives the data from the wire.
  AlternateBuffer - Specifies the buffer to put data into
  BytesToReceive  - Specifies the number of bytes to get from the socket. All
                    bytes must be read before this function returns.

Return Value:

  TRUE if the buffer was completed, or FALSE if receive failed.

  NOTE: Either Buffer or AlternateBuffer must be specified.  If both are
        specified, Buffer is used.


--*/

{
    PBYTE recvBuf;
    PBYTE bufPos;
    UINT bytesSoFar = 0;
    INT result;
    UINT readSize;

    if (Buffer) {
        Buffer->End = 0;
        recvBuf = GbGrow (Buffer, BytesToReceive);
    } else {
        recvBuf = AlternateBuffer;
    }

    bufPos = recvBuf;

    do {

        if (IsmCheckCancel()) {
            return FALSE;
        }

        readSize = BytesToReceive - bytesSoFar;
        result = pRecvWithTimeout (Socket, bufPos, readSize, 0, Timeout);

        if (!result) {
            // connection broken
            SetLastError (ERROR_CANCELLED);
            break;
        }

        if (result == SOCKET_ERROR) {
            DEBUGMSG ((DBG_ERROR, "Error reading from socket"));
            break;
        }

        bufPos += result;
        bytesSoFar += result;

    } while (bytesSoFar < BytesToReceive);

    MYASSERT (bytesSoFar <= BytesToReceive);

    return bytesSoFar == BytesToReceive ? recvBuf : NULL;
}


PBYTE
pReceiveDatagramData (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,
    IN OUT  PGROWBUFFER Buffer,         OPTIONAL
    OUT     PBYTE AlternateBuffer,      OPTIONAL
    IN      UINT BytesToReceive,
    IN      UINT Timeout                OPTIONAL
    )

/*++

Routine Description:

  pReceiveDatagramData checks the datagram queue for data, allocates a
  receive buffer, and fills the buffer with the data from the wire. If
  necessary, this function will fill the queue, until there is enough data to
  fill the caller's buffer.

Arguments:

  Socket          - Specifies the datagram socket
  DatagramPool    - Specifies the structure containing the receive pool and
                    other sequencing info
  Buffer          - Specifies the buffer to allocate from; the end pointer is
                    reset to zero. Receives the data from the wire.
  AlternateBuffer - Specifies the buffer to put data into
  BytesToReceive  - Specifies the number of bytes to get from the socket. All
                    bytes must be read before this function returns.

Return Value:

  TRUE if the buffer was completed, or FALSE if receive failed.

  NOTE: Either Buffer or AlternateBuffer must be specified.  If both are
        specified, Buffer is used.

--*/

{
    PDATAGRAM_POOL_ITEM itemHeader;
    PDATAGRAM_POOL_ITEM prevItem, nextItem;
    BYTE buffer[512];
    PBYTE dataPtr;
    PBYTE recvBuf;
    PBYTE bufPos;
    UINT bytesSoFar = 0;
    UINT bytesLeft;
    INT result;
    PDATAGRAM_POOL_ITEM item;
    UINT newPacketNum;
    UINT currentPacketNum;
    ULONG available;
    PBYTE bigBuf = NULL;
    PBYTE p;

    if (Buffer) {
        Buffer->End = 0;
        recvBuf = GbGrow (Buffer, BytesToReceive);
    } else {
        recvBuf = AlternateBuffer;
    }

    bufPos = recvBuf;

    itemHeader = (PDATAGRAM_POOL_ITEM) buffer;
    dataPtr = (PBYTE) (&itemHeader[1]);

    for (;;) {
        //
        // Take all available data out of the pool
        //

        item = DatagramPool->FirstItem;
        bytesLeft = BytesToReceive - bytesSoFar;

        while (item) {

            if (item->Header.PacketNumber == DatagramPool->RecvSequenceNumber) {
                //
                // Two cases:
                //
                // 1. Want entire packet
                // 2. Want partial packet
                //

                if (bytesLeft >= item->Header.DataLength) {
                    // entire packet
                    CopyMemory (bufPos, item->PacketData, item->Header.DataLength);

                    MYASSERT (!item->Prev);
                    if (item->Next) {
                        item->Next->Prev = NULL;
                    }
                    DatagramPool->FirstItem = item->Next;

                    bytesSoFar += item->Header.DataLength;
                    PmReleaseMemory (DatagramPool->Pool, item);

                    DatagramPool->RecvSequenceNumber++;

                } else {
                    // partial packet
                    CopyMemory (bufPos, item->PacketData, bytesLeft);

                    item->PacketData += bytesLeft;
                    item->Header.DataLength -= (WORD) bytesLeft;

                    bytesSoFar += bytesLeft;
                }

                if (BytesToReceive == bytesSoFar) {
                    return recvBuf;
                }
            }

            item = item->Next;
        }

        //
        // Data is not available in the pool. Receive one packet and then try again.
        //

        ioctlsocket (Socket, FIONREAD, &available);
        if (!available) {
            Sleep (100);
            continue;
        }

        bigBuf = PmGetMemory (DatagramPool->Pool, available);

        result = pRecvWithTimeout (Socket, bigBuf, available, 0, Timeout);

        if (result == INVALID_SOCKET) {
            DEBUGMSG ((DBG_ERROR, "Can't receive datagram"));
            break;
        }

        p = bigBuf;

        while (result > 0) {

            if (result < sizeof (DATAGRAM_PACKET)) {
                DEBUGMSG ((DBG_ERROR, "Datagram header is too small"));
                break;
            }

            CopyMemory (&itemHeader->Header, p, sizeof (DATAGRAM_PACKET));
            p += sizeof (DATAGRAM_PACKET);
            result -= sizeof (DATAGRAM_PACKET);

            if (itemHeader->Header.DataLength > 256) {
                DEBUGMSG ((DBG_ERROR, "Datagram contains garbage"));
                break;
            }

            if (result < itemHeader->Header.DataLength) {
                DEBUGMSG ((DBG_ERROR, "Datagram data is too small"));
                break;
            }

            CopyMemory (dataPtr, p, itemHeader->Header.DataLength);
            p += itemHeader->Header.DataLength;
            result -= itemHeader->Header.DataLength;

            if ((UINT) itemHeader->Header.PacketNumber == DatagramPool->LastPacketNumber) {
                continue;
            }

            DatagramPool->LastPacketNumber = itemHeader->Header.PacketNumber;

            //
            // Put the packet in the item linked list, sorted by packet number
            //

            item = (PDATAGRAM_POOL_ITEM) PmDuplicateMemory (
                                            DatagramPool->Pool,
                                            (PCBYTE) itemHeader,
                                            itemHeader->Header.DataLength + sizeof (DATAGRAM_POOL_ITEM)
                                            );

            item->PacketData = (PBYTE) (&item[1]);

            prevItem = NULL;
            nextItem = DatagramPool->FirstItem;

            while (nextItem) {

                //
                // Account for wrapping; assume a packet number difference no more
                // than 16383 out-of-sequence packets in the queue (about 4M of
                // data)
                //

                if (nextItem->Header.PacketNumber >= 49152 && item->Header.PacketNumber < 16384) {
                    newPacketNum = (UINT) item->Header.PacketNumber + 65536;
                    currentPacketNum = (UINT) nextItem->Header.PacketNumber;
                } else if (nextItem->Header.PacketNumber < 16384 && item->Header.PacketNumber >= 49152) {
                    newPacketNum = (UINT) item->Header.PacketNumber;
                    currentPacketNum = (UINT) nextItem->Header.PacketNumber + 65536;
                } else {
                    newPacketNum = (UINT) item->Header.PacketNumber;
                    currentPacketNum = (UINT) nextItem->Header.PacketNumber;
                }

                if (newPacketNum < currentPacketNum) {
                    break;
                }

                prevItem = nextItem;
                nextItem = nextItem->Next;
            }

            item->Next = nextItem;
            item->Prev = prevItem;

            if (!prevItem) {
                DatagramPool->FirstItem = item;
            }
        }

        PmReleaseMemory (DatagramPool->Pool, bigBuf);
    }

    return bytesSoFar == BytesToReceive ? recvBuf : NULL;
}


PBYTE
pReceiveData (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,    OPTIONAL
    IN OUT  PGROWBUFFER Buffer,             OPTIONAL
    OUT     PBYTE AlternateBuffer,          OPTIONAL
    IN      UINT BytesToReceive,
    IN      UINT Timeout                    OPTIONAL
    )
{
    if (!DatagramPool) {
        return pReceiveExactData (Socket, Buffer, AlternateBuffer, BytesToReceive, Timeout);
    }

    return pReceiveDatagramData (Socket, DatagramPool, Buffer, AlternateBuffer, BytesToReceive, Timeout);
}


BOOL
pSendFile (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,    OPTIONAL
    IN      PCTSTR LocalFileName,           OPTIONAL
    IN      PCTSTR DestFileName             OPTIONAL
    )

/*++

Routine Description:

  pSendFile sends a file on the wire.

Arguments:

  Socket        - Specifies the socket to send the file on
  DatagramPool  - Specifies the datagram pool for sockets that are connecitonless
  LocalFileName - Specifies the path to the local file
  DestFileName  - Specifies the subpath that is sent to the destination. The
                  destination uses the subpath to construct its corresponding
                  file name.

Return Value:

  TRUE if the file was sent, FALSE otherwise.

--*/

{
    PCWSTR destFileName = NULL;
    INT len;
    GROWBUFFER data = INIT_GROWBUFFER;
    BOOL result = FALSE;
    HANDLE file = NULL;
    LONGLONG fileSize;
    DWORD msg;

    HCRYPTPROV hProv = 0;
    HCRYPTKEY  hKey = 0;
    HCRYPTHASH hHash = 0;

    __try {

        //
        // Build the encrypt stuff
        //
        if ((!CryptAcquireContext (&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) ||
            (!CryptCreateHash (hProv, CALG_MD5, 0, 0, &hHash)) ||
            (!CryptHashData (hHash, (PBYTE)g_GlobalKey, ByteCountA (g_GlobalKey), 0)) ||
            (!CryptDeriveKey (hProv, CALG_RC4, hHash, CRYPT_EXPORTABLE, &hKey))
            ) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        //
        // Try to open the file
        //

        fileSize = BfGetFileSize (LocalFileName);

        file = BfOpenReadFile (LocalFileName);
        if (!file) {
            // nothing to do
            __leave;
        }

        //
        // Send the message "FILE"
        //

        msg = MESSAGE_FILE;
        if (!pSendData (Socket, DatagramPool, (PBYTE) &msg, sizeof (msg))) {
            SetLastError (ERROR_NETWORK_UNREACHABLE);
            DEBUGMSG ((DBG_ERROR, "Can't send MSG_FILE"));
            __leave;
        }

        //
        // If no file was specified, send length of zero
        //

        if (!LocalFileName || !DestFileName) {
            len = 0;
            if (!pSendData (Socket, DatagramPool, (PBYTE) &len, 4)) {
                SetLastError (ERROR_NETWORK_UNREACHABLE);
                DEBUGMSG ((DBG_ERROR, "Can't send nul file length"));
                __leave;
            }

            result = TRUE;
            __leave;
        }

        //
        // Send the file name and file size
        //

#ifdef UNICODE
        destFileName = DuplicatePathString (DestFileName, 0);
#else
        destFileName = ConvertAtoW (DestFileName);
#endif
        len = ByteCountW (destFileName);

        if (!pSendData (Socket, DatagramPool, (PBYTE) &len, 4)) {
            SetLastError (ERROR_NETWORK_UNREACHABLE);
            DEBUGMSG ((DBG_ERROR, "Can't send file length"));
            __leave;
        }

        // Encrypt the name of the file
        if (!CryptEncrypt(hKey, 0, TRUE, 0, (PBYTE)destFileName, &len, len)) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        if (!pSendData (Socket, DatagramPool, (PBYTE) destFileName, len)) {
            SetLastError (ERROR_NETWORK_UNREACHABLE);
            DEBUGMSG ((DBG_ERROR, "Can't send file name"));
            __leave;
        }

        if (!pSendData (Socket, DatagramPool, (PBYTE) &fileSize, 8)) {
            SetLastError (ERROR_NETWORK_UNREACHABLE);
            DEBUGMSG ((DBG_ERROR, "Can't send file size"));
            __leave;
        }

        //
        // Send the data 64K at a time
        //

        GbGrow (&data, 0x10000);

        while (fileSize) {
            if (fileSize > 0x10000) {

                len = 0x10000;

                if (!BfReadFile (file, data.Buf, len)) {
                    DEBUGMSG ((DBG_ERROR, "Can't read from file"));
                    __leave;
                }

                // Encrypt the buffer
                if (!CryptEncrypt(hKey, 0, FALSE, 0, data.Buf, &len, len)) {
                    SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
                    LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
                    __leave;
                }

                if (!pSendData (Socket, DatagramPool, data.Buf, len)) {
                    SetLastError (ERROR_NETWORK_UNREACHABLE);
                    DEBUGMSG ((DBG_ERROR, "Can't send file data"));
                    __leave;
                }

                fileSize -= 0x10000;
            } else {

                len = (INT)fileSize;

                if (!BfReadFile (file, data.Buf, (UINT) fileSize)) {
                    DEBUGMSG ((DBG_ERROR, "Can't read from file"));
                    __leave;
                }

                // Encrypt the buffer (last piece so set the last to TRUE)
                if (!CryptEncrypt(hKey, 0, TRUE, 0, data.Buf, &len, len)) {
                    SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
                    LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
                    __leave;
                }

                if (!pSendData (Socket, DatagramPool, data.Buf, (UINT) len)) {
                    SetLastError (ERROR_NETWORK_UNREACHABLE);
                    DEBUGMSG ((DBG_ERROR, "Can't send file data"));
                    __leave;
                }

                fileSize = 0;
            }
        }

        //
        // Done!
        //

        result = TRUE;
        DEBUGMSG ((DBG_HOMENET, "Sent %s", LocalFileName));
    }
    __finally {
        if (hKey) {
            CryptDestroyKey(hKey);
            hKey = 0;
        }
        if (hHash) {
            CryptDestroyHash(hHash);
            hHash = 0;
        }
        if (hProv) {
            CryptReleaseContext(hProv,0);
            hProv = 0;
        }
        GbFree (&data);
        if (file) {
            CloseHandle (file);
        }
        if (destFileName) {
#ifndef UNICODE
            FreeConvertedStr (destFileName);
#else
            FreePathString (destFileName);
#endif
            destFileName = NULL;
        }
    }

    return result;
}


BOOL
pReceiveFile (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,        OPTIONAL
    IN      PCTSTR LocalFileRoot,
    IN      UINT Timeout                        OPTIONAL
    )

/*++

Routine Description:

  pReceiveStreamFile obtains a file from the socket. The file is stored in
  g_StorageRoot. The subpath and file name is obtained from the data on the
  wire.

  NOTE: The caller must pull off the message DWORD before calling
        pReceiveStreamFile. This is unlike the send, which puts the message
        on the wire automatically.

Arguments:

  Socket - Specifies the socket to receive from.

  DatagramPool - Specifies the packet pool for a datagram-based socket

  LocalFileRoot - Specifies the local root path for the file

Return Value:

  TRUE if the file was received, FALSE otherwise.

--*/

{
    TCHAR fileName[MAX_PATH * 2];
    INT len;
    GROWBUFFER data = INIT_GROWBUFFER;
    BOOL result = FALSE;
    PTSTR p;
    HANDLE file = NULL;
    LONGLONG fileSize;

    HCRYPTPROV hProv = 0;
    HCRYPTKEY  hKey = 0;
    HCRYPTHASH hHash = 0;

    __try {

        //
        // Build the encrypt stuff
        //
        if ((!CryptAcquireContext (&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) ||
            (!CryptCreateHash (hProv, CALG_MD5, 0, 0, &hHash)) ||
            (!CryptHashData (hHash, (PBYTE)g_GlobalKey, ByteCountA (g_GlobalKey), 0)) ||
            (!CryptDeriveKey (hProv, CALG_RC4, hHash, CRYPT_EXPORTABLE, &hKey))
            ) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        //
        // Wait for file name
        //

        if (!pReceiveData (Socket, DatagramPool, &data, NULL, 4, Timeout)) {
            __leave;
        }

        len = *((PDWORD) data.Buf);

        if (!len) {
            result = TRUE;
            __leave;
        }

        if (len >= (MAX_PATH * sizeof (TCHAR))) {
            __leave;
        }

        if (!pReceiveData (Socket, DatagramPool, &data, NULL, len, Timeout)) {
            __leave;
        }

        // Decrypt the file name
        if (!CryptDecrypt(hKey, 0, TRUE, 0, data.Buf, &len)) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        StringCopy (fileName, LocalFileRoot);

        GbGrow (&data, sizeof (TCHAR) * 2);
        p = (PTSTR) data.Buf;
        p[len / sizeof (TCHAR)] = 0;
        p[(len / sizeof (TCHAR)) + 1] = 0;

        StringCopy (AppendWack (fileName), p);

        //
        // Get the file size
        //

        if (!pReceiveData (Socket, DatagramPool, &data, NULL, 8, Timeout)) {
            __leave;
        }

        fileSize = *((PLONGLONG) data.Buf);

        DEBUGMSG ((DBG_HOMENET, "Receiving %s", fileName));

        //
        // Create the file
        //

        file = BfCreateFile (fileName);
        if (file == INVALID_HANDLE_VALUE) {
            PushError ();
            DEBUGMSG ((DBG_ERROR, "Can't create %s", fileName));
            PopError ();
            __leave;
        }

        //
        // Fetch the data 64K at a time
        //

        while (fileSize) {
            if (fileSize > 0x10000) {

                if (!pReceiveData (Socket, DatagramPool, &data, NULL, 0x10000, Timeout)) {
                    __leave;
                }

                len = data.End;

                // Decrypt the file name
                if (!CryptDecrypt(hKey, 0, FALSE, 0, data.Buf, &len)) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
                    SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
                    __leave;
                }

                if (!BfWriteFile (file, data.Buf, len)) {
                    PushError ();
                    DEBUGMSG ((DBG_ERROR, "Can't write to file"));
                    PopError ();
                    __leave;
                }

                fileSize -= data.End;
            } else {

                if (!pReceiveData (Socket, DatagramPool, &data, NULL, (UINT) fileSize, Timeout)) {
                    __leave;
                }

                len = data.End;

                // Decrypt the file name
                if (!CryptDecrypt(hKey, 0, TRUE, 0, data.Buf, &len)) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
                    SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
                    __leave;
                }

                if (!BfWriteFile (file, data.Buf, len)) {
                    PushError ();
                    DEBUGMSG ((DBG_ERROR, "Can't write to file"));
                    PopError ();
                    __leave;
                }

                fileSize = 0;
            }
        }

        //
        // Done!
        //

        result = TRUE;
        DEBUGMSG ((DBG_HOMENET, "Received %s", fileName));

    }
    __finally {
        PushError ();
        if (hKey) {
            CryptDestroyKey(hKey);
            hKey = 0;
        }
        if (hHash) {
            CryptDestroyHash(hHash);
            hHash = 0;
        }
        if (hProv) {
            CryptReleaseContext(hProv,0);
            hProv = 0;
        }
        GbFree (&data);
        if (file) {
            CloseHandle (file);
            if (!result) {
                DeleteFile (fileName);
            }
        }
        PopError ();
    }

    return result;
}


BOOL
pSendEncryptedData (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,    OPTIONAL
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  pSendEncryptedFile sends a file on the wire.

Arguments:

  Socket        - Specifies the socket to send the file on
  DatagramPool  - Specifies the datagram pool for sockets that are connecitonless
  Data          - Buffer to be sent
  DataSize      - Size of data to be sent

Return Value:

  TRUE if the buffer was sent, FALSE otherwise.

--*/

{
    INT len;
    GROWBUFFER encData = INIT_GROWBUFFER;
    BOOL result = FALSE;
    DWORD msg;

    HCRYPTPROV hProv = 0;
    HCRYPTKEY  hKey = 0;
    HCRYPTHASH hHash = 0;

    __try {

        //
        // Build the encrypt stuff
        //
        if ((!CryptAcquireContext (&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) ||
            (!CryptCreateHash (hProv, CALG_MD5, 0, 0, &hHash)) ||
            (!CryptHashData (hHash, (PBYTE)g_GlobalKey, ByteCountA (g_GlobalKey), 0)) ||
            (!CryptDeriveKey (hProv, CALG_RC4, hHash, CRYPT_EXPORTABLE, &hKey))
            ) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        //
        // Send the message "DATA"
        //

        msg = MESSAGE_DATA;
        if (!pSendData (Socket, DatagramPool, (PBYTE) &msg, sizeof (msg))) {
            DEBUGMSG ((DBG_ERROR, "Can't send MSG_FILE"));
            __leave;
        }

        //
        // Send the size of data
        //
        if (!pSendData (Socket, DatagramPool, (PBYTE) &DataSize, 4)) {
            DEBUGMSG ((DBG_ERROR, "Can't send file length"));
            __leave;
        }

        //
        // Send the data
        //

        GbGrow (&encData, DataSize);
        CopyMemory (encData.Buf, Data, DataSize);
        // Encrypt the buffer
        if (!CryptEncrypt(hKey, 0, TRUE, 0, encData.Buf, &DataSize, DataSize)) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        if (!pSendData (Socket, DatagramPool, encData.Buf, DataSize)) {
            DEBUGMSG ((DBG_ERROR, "Can't send file data"));
            __leave;
        }

        //
        // Done!
        //

        result = TRUE;
    }
    __finally {
        if (hKey) {
            CryptDestroyKey(hKey);
            hKey = 0;
        }
        if (hHash) {
            CryptDestroyHash(hHash);
            hHash = 0;
        }
        if (hProv) {
            CryptReleaseContext(hProv,0);
            hProv = 0;
        }
        GbFree (&encData);
    }

    return result;
}


BOOL
pReceiveEncryptedData (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,        OPTIONAL
    IN      PBYTE *Buffer,
    IN      UINT Timeout                        OPTIONAL
    )

/*++

Routine Description:

  pReceiveEncryptedData obtains a buffer from the socket. The data is stored in
  Buffer.

  NOTE: The caller must pull off the message DWORD before calling
        pReceiveEncryptedData. This is unlike the send, which puts the message
        on the wire automatically.

Arguments:

  Socket - Specifies the socket to receive from.

  DatagramPool - Specifies the packet pool for a datagram-based socket

  Buffer - Specifies a pointer to a PBYTE

Return Value:

  TRUE if the file was received, FALSE otherwise.

--*/

{
    GROWBUFFER data = INIT_GROWBUFFER;
    DWORD dataSize;
    BOOL result = FALSE;

    HCRYPTPROV hProv = 0;
    HCRYPTKEY  hKey = 0;
    HCRYPTHASH hHash = 0;

    __try {

        //
        // Build the encrypt stuff
        //
        if ((!CryptAcquireContext (&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) ||
            (!CryptCreateHash (hProv, CALG_MD5, 0, 0, &hHash)) ||
            (!CryptHashData (hHash, (PBYTE)g_GlobalKey, ByteCountA (g_GlobalKey), 0)) ||
            (!CryptDeriveKey (hProv, CALG_RC4, hHash, CRYPT_EXPORTABLE, &hKey))
            ) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        //
        // Wait for file name
        //

        if (!pReceiveData (Socket, DatagramPool, &data, NULL, 4, Timeout)) {
            __leave;
        }

        dataSize = *((PDWORD) data.Buf);

        if (!dataSize) {
            result = TRUE;
            __leave;
        }

        if (!pReceiveData (Socket, DatagramPool, &data, NULL, dataSize, Timeout)) {
            __leave;
        }

        // Decrypt the content
        if (!CryptDecrypt(hKey, 0, TRUE, 0, data.Buf, &dataSize)) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        // Now allocate the result
        *Buffer = HeapAlloc (g_hHeap, 0, dataSize);
        if (*Buffer) {
            CopyMemory (*Buffer, data.Buf, dataSize);
            result = TRUE;
        }

    }
    __finally {
        if (hKey) {
            CryptDestroyKey(hKey);
            hKey = 0;
        }
        if (hHash) {
            CryptDestroyHash(hHash);
            hHash = 0;
        }
        if (hProv) {
            CryptReleaseContext(hProv,0);
            hProv = 0;
        }
        GbFree (&data);
    }

    return result;
}


BOOL
pSendMetrics (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,            OPTIONAL
    IN OUT  PTRANSFERMETRICS Metrics
    )

/*++

Routine Description:

  pSendMetrics sends transport data (such as the number of files or number of
  bytes to expect).  This is the first bit of information sent to the
  destination.

Arguments:

  Socket   - Specifies the socket to send the data to.

  DatagramPool - Specifies the structure for datagram mode

  Metrics  - Specifies a pointer to the metrics structure to send. The
             metrics structure member StructSize is updated before the struct
             is sent.

Return Value:

  TRUE if the metrics struct was sent, FALSE otherwise.

--*/

{
    Metrics->StructSize = sizeof (TRANSFERMETRICS);

    if (!pSendData (Socket, DatagramPool, (PBYTE) Metrics, sizeof (TRANSFERMETRICS))) {
        DEBUGMSG ((DBG_ERROR, "Failed to send data"));
        return FALSE;
    }

    return TRUE;
}


BOOL
pReceiveMetrics (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,        OPTIONAL
    OUT     PTRANSFERMETRICS Metrics
    )

/*++

Routine Description:

  pReceiveMetrics obtains a TRANSFERMETRICS structure from the wire. This is
  the first bit of information received by the destination. It provides the
  number of files, total number of file bytes, and other information.

Arguments:

  Socket  - Specifies the socket to receive data on.

  DatagramPool - Specifies the structure used for datagram data reception

  Metrics - Receives the metrics from the wire.

Return Value:

  TRUE if the metrics structure was received properly, FALSE otherwise.

--*/

{
    GROWBUFFER data = INIT_GROWBUFFER;
    BOOL result = FALSE;

    __try {
        if (!pReceiveData (Socket, DatagramPool, NULL, (PBYTE) Metrics, sizeof (TRANSFERMETRICS), 0)) {
            __leave;
        }

        if (Metrics->StructSize != sizeof (TRANSFERMETRICS)) {
            DEBUGMSG ((DBG_ERROR, "Invalid transfer metrics received"));
            __leave;
        }

        if (Metrics->Signature != HOMENETTR_SIG) {
            DEBUGMSG ((DBG_ERROR, "Invalid transfer signature received"));
            __leave;
        }

        result = TRUE;
    }
    __finally {
        GbFree (&data);
    }

    return result;
}


DWORD
pReceiveMessage (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,        OPTIONAL
    IN      UINT Timeout                        OPTIONAL
    )

/*++

Routine Description:

  pReceiveMessage obtains the next DWORD from the socket and returns it to
  the caller. This DWORD provides a message, indicating what action to
  take next.

Arguments:

  Socket  - Specifies the socket to receive data on

  DatagramPool - Specifies the structure used for datagram data reception

Return Value:

  The message, or 0 if no message is available.

--*/

{
    DWORD msg = 0;

    if (!pReceiveData (Socket, DatagramPool, NULL, (PBYTE) &msg, sizeof (DWORD), Timeout)) {
        msg = 0;
    }

    return msg;
}


BOOL
pConnectToDestination (
    IN      PCONNECTADDRESS Address,
    OUT     PCONNECTIONSOCKET Connection
    )
{
    BOOL result = FALSE;
    BOOL b;
    LINGER lingerStruct;

    CopyMemory (Connection->LocalAddress, Address->LocalAddress, Address->LocalAddressLen);
    Connection->LocalAddressLen = Address->LocalAddressLen;

    CopyMemory (Connection->RemoteAddress, Address->RemoteAddress, Address->RemoteAddressLen);
    Connection->RemoteAddressLen = Address->RemoteAddressLen;

    Connection->Socket = socket (
                            Address->Family,
                            Address->Datagram ? SOCK_DGRAM : SOCK_STREAM,
                            Address->Protocol
                            );

    if (Connection->Socket == INVALID_SOCKET) {
        DEBUGMSG ((DBG_ERROR, "Can't create socket for connection"));
        return FALSE;
    }

    __try {

        b = TRUE;
        setsockopt (Connection->Socket, SOL_SOCKET, SO_REUSEADDR, (PBYTE) &b, sizeof (b));

        b = TRUE;
        setsockopt (Connection->Socket, SOL_SOCKET, SO_KEEPALIVE, (PBYTE) &b, sizeof (b));

        lingerStruct.l_onoff = 1;
        lingerStruct.l_linger = 90;
        setsockopt (Connection->Socket, SOL_SOCKET, SO_LINGER, (PBYTE) &lingerStruct, sizeof (lingerStruct));

        pResetPort (Address->Family, (SOCKADDR *) Address->LocalAddress);

        if (bind (Connection->Socket, (SOCKADDR *) Address->LocalAddress, Address->LocalAddressLen)) {
            DEBUGMSG ((DBG_ERROR, "Failed to bind to connection socket"));
            __leave;
        }

        if (connect (Connection->Socket, (SOCKADDR *) Address->RemoteAddress, Address->RemoteAddressLen)) {
            DEBUGMSG ((DBG_ERROR, "Failed to connect to socket"));
            __leave;
        }

        Connection->Family = Address->Family;
        Connection->Protocol = Address->Protocol;

        Connection->Datagram = Address->Datagram;
        ZeroMemory (&Connection->DatagramPool, sizeof (DATAGRAM_POOL));
        if (Connection->Datagram) {
            Connection->DatagramPool.Pool = PmCreatePool();
            Connection->DatagramPool.LastPacketNumber = (UINT) -1;
        }

        result = TRUE;
    }
    __finally {
        if (!result && Connection->Socket != INVALID_SOCKET) {
            closesocket (Connection->Socket);
            Connection->Socket = INVALID_SOCKET;
        }
    }

    return result;
}


BOOL
FindDestination (
    OUT     PCONNECTADDRESS Address,
    IN      UINT Timeout,               OPTIONAL
    IN      BOOL IgnoreMultipleDests
    )

/*++

Routine Description:

  FindDestination invokes the name resolution algorithm to locate a
  destination. It selects the best transport to communicate on, and returns
  the address. The caller can use the return address to make a connection.

Arguments:

  Address - Receives the address of the destination

  Timeout - Specifies the number of seconds to wait for the first
            destination broadcast, or zero to wait forever.

  IgnoreMultipleDests - Specifies TRUE if multiple destinations should be
                        ignored (taking the first one as the connection),
                        or FALSE if a message should be passed to the UI
                        to resolve the conflict.

Return Value:

  TRUE if a destination was found, FALSE otherwise.

--*/

{
    GROWBUFFER destinationAddresses = INIT_GROWBUFFER;
    INT destinationCount;
    PCONNECTADDRESS addressArray;
    INT i;
    PCTSTR firstName;
    BOOL result = FALSE;
    GROWBUFFER destNames = INIT_GROWBUFFER;
    MULTISZ_ENUM e;
    BOOL duplicate;
    BOOL oneValid;
    ULONG_PTR response;

    __try {

        destinationCount = pNameResolver (PLATFORM_SOURCE, &destinationAddresses, Timeout, NULL);

        if (!destinationCount) {
            __leave;
        }

        addressArray = (PCONNECTADDRESS) destinationAddresses.Buf;

        //
        // Determine which address to use.  Rules are:
        //
        // 1. Must have only one destination to choose from
        // 2. Pick TCP/IP, then IPX. [, then NetBIOS -- no longer supported]
        //

        if (destinationCount > 1) {
            firstName = addressArray[0].DestinationName;

            for (i = 1 ; i < destinationCount ; i++) {
                if (!StringIMatch (firstName, addressArray[i].DestinationName)) {
                    break;
                }
            }

            if (i < destinationCount) {
                DEBUGMSG ((DBG_WARNING, "Multiple destinations found on the subnet"));

                //
                // put all destinations in an ISM environment variable, then call the
                // UI to allow it to resolve the conflict, and finally make sure
                // the one remaining destination is the only one used.
                //

                GbMultiSzAppend (&destNames, firstName);

                for (i = 1 ; i < destinationCount ; i++) {
                    if (EnumFirstMultiSz (&e, (PCTSTR) destNames.Buf)) {

                        duplicate = FALSE;

                        do {
                            if (StringIMatch (e.CurrentString, addressArray[i].DestinationName)) {
                                duplicate = TRUE;
                                break;
                            }
                        } while (EnumNextMultiSz (&e));
                    }

                    if (!duplicate) {
                        GbMultiSzAppend (&destNames, addressArray[i].DestinationName);
                    }
                }

                IsmSetEnvironmentMultiSz (
                    PLATFORM_DESTINATION,
                    NULL,
                    TRANSPORT_ENVVAR_HOMENET_DESTINATIONS,
                    (PCTSTR) destNames.Buf
                    );

                //
                // Tell the UI.  The UI must return TRUE and also update
                // TRANSPORT_ENVVAR_HOMENET_DESTINATIONS so that the selected
                // destination is the only member of the multi-sz.
                //

                if (!IgnoreMultipleDests) {
                    response = IsmSendMessageToApp (TRANSPORTMESSAGE_MULTIPLE_DESTS, 0);

                    if (IsmCheckCancel()) {
                        __leave;
                    }

                    if (!response) {
                        DEBUGMSG ((DBG_VERBOSE, "Multiple destinations were not resolved; can't continue"));
                        __leave;
                    }

                    if (!IsmGetEnvironmentMultiSz (
                            PLATFORM_DESTINATION,
                            NULL,
                            TRANSPORT_ENVVAR_HOMENET_DESTINATIONS,
                            (PTSTR) destNames.Buf,
                            destNames.End,
                            NULL
                            )) {
                        DEBUGMSG ((DBG_ERROR, "Can't get resolved destinations"));
                        __leave;
                    }
                }

                //
                // Reset all Family members for names not selected
                //

                oneValid = FALSE;

                for (i = 0 ; i < destinationCount ; i++) {
                    if (!StringIMatch (addressArray[i].DestinationName, (PCTSTR) destNames.Buf)) {
                        addressArray[i].Family = 0;
                    } else {
                        oneValid = TRUE;
                    }
                }

                if (!oneValid) {
                    DEBUGMSG ((DBG_ERROR, "Resolved destination does not exist"));
                    __leave;
                }
            }
        }

        //
        // Select the best protocol
        //

        for (i = 0 ; i < destinationCount ; i++) {
            if (addressArray[i].Family == AF_INET) {
                break;
            }
        }

        if (i == destinationCount) {
            for (i = 0 ; i < destinationCount ; i++) {
                if (addressArray[i].Family == AF_IPX) {
                    break;
                }
            }

            if (i == destinationCount) {
                for (i = 0 ; i < destinationCount ; i++) {
                    if (addressArray[i].Family == AF_NETBIOS) {
                        //break;
                    }
                }

                if (i == destinationCount) {
                    DEBUGMSG ((DBG_WHOOPS, "Connection is from unsupported protocol"));
                    __leave;
                }
            }
        }

        DEBUGMSG ((
            DBG_HOMENET,
            "Destination connection is %s (protocol %i)",
            addressArray[i].DestinationName,
            addressArray[i].Protocol
            ));

        CopyMemory (Address, &addressArray[i], sizeof (CONNECTADDRESS));
        result = TRUE;
    }
    __finally {
        PushError();

        GbFree (&destinationAddresses);
        GbFree (&destNames);

        PopError();
    }

    return result;
}


BOOL
TestConnection (
    IN      PCONNECTADDRESS Address
    )

/*++

Routine Description:

  TestConnection establishes a connection to the destination specified
  by Address. Will immediately disconnect since this was just a connection
  test.

Arguments:

  Address    - Specifies the address of the destination, as returned by
               FindDestination.

Return Value:

  TRUE if a connection could be established to the destination, FALSE otherwise.

--*/

{
    CONNECTIONSOCKET connection;
    BOOL result = FALSE;

    ZeroMemory (&connection, sizeof (CONNECTIONSOCKET));
    connection.Socket = INVALID_SOCKET;
    connection.KeepAliveSpacing = 30000;
    connection.LastSend = GetTickCount();

    __try {

        if (!pConnectToDestination (Address, &connection)) {
            __leave;
        }

        DEBUGMSG ((DBG_HOMENET, "TestConnection: Connected!"));

        result = TRUE;
    }
    __finally {
        if (connection.Socket != INVALID_SOCKET) {
            closesocket (connection.Socket);
            connection.Socket = INVALID_SOCKET;
        }

        if (connection.Datagram) {
            PmDestroyPool (connection.DatagramPool.Pool);
            connection.Datagram = FALSE;
        }
    }

    return result;
}


BOOL
ConnectToDestination (
    IN      PCONNECTADDRESS Address,
    IN      PTRANSFERMETRICS Metrics,
    OUT     PCONNECTIONSOCKET Connection
    )

/*++

Routine Description:

  ConnectToDestination establishes a connection to the destination specified
  by Address. Once connected, the Metrics structure is passed to the
  destination.  The caller receives the Connection structure for addtional
  communication.

Arguments:

  Address    - Specifies the address of the destination, as returned by
               FindDestination.
  Metrics    - Specifies the metrics structure that provides basic
               information such as the number of files to expect.
  Connection - Receives the connection to the destination, to be used in
               additional data transfer.

Return Value:

  TRUE if a connection was established to the destination, FALSE otherwise.

--*/

{
    BOOL result = FALSE;

    ZeroMemory (Connection, sizeof (CONNECTIONSOCKET));
    Connection->Socket = INVALID_SOCKET;
    Connection->KeepAliveSpacing = 30000;
    Connection->LastSend = GetTickCount();

    __try {

        if (!pConnectToDestination (Address, Connection)) {
            __leave;
        }

        DEBUGMSG ((DBG_HOMENET, "Connected!"));

        if (!pSendMetrics (
                Connection->Socket,
                Connection->Datagram ? &Connection->DatagramPool : NULL,
                Metrics
                )) {
            DEBUGMSG ((DBG_HOMENET, "Can't send metrics to destination"));
            __leave;
        }

        result = TRUE;
    }
    __finally {
        if (!result) {
            if (Connection->Socket != INVALID_SOCKET) {
                closesocket (Connection->Socket);
                Connection->Socket = INVALID_SOCKET;
            }
        }
    }

    return result;
}


DWORD
SendMessageToDestination (
    IN      PCONNECTIONSOCKET Connection,
    IN      DWORD Message
    )
{
    Connection->LastSend = GetTickCount();

    return pSendData (
                Connection->Socket,
                Connection->Datagram ? &Connection->DatagramPool : NULL,
                (PBYTE) &Message,
                sizeof (DWORD)
                );
}


BOOL
SendFileToDestination (
    IN      PCONNECTIONSOCKET Connection,
    IN      PCTSTR LocalPath,                   OPTIONAL
    IN      PCTSTR DestSubPath                  OPTIONAL
    )

/*++

Routine Description:

  SendFileToDestination sends a file to the connection specified.

  If LocalPath is NULL, then no file will be sent. This is used to skip files
  that cannot be accessed locally.

  If DestSubPath is NULL, then the file name in LocalPath will be used
  as DestSubPath.

Arguments:

  Connection  - Specifies the connection to send the file to, as returned by
                ConnectToDestination.
  LocalPath   - Specifies the local path of the file to send
  DestSubPath - Specifies the sub path to send to the destination (so it can
                reconstruct a path)

Return Value:

  TRUE if the file was sent, FALSE otherwise.

--*/

{
    if (LocalPath && !DestSubPath) {
        DestSubPath = GetFileNameFromPath (LocalPath);
    }

    return pSendFile (
                Connection->Socket,
                Connection->Datagram ? &Connection->DatagramPool : NULL,
                LocalPath,
                DestSubPath
                );
}


BOOL
SendDataToDestination (
    IN      PCONNECTIONSOCKET Connection,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  SendDataToDestination sends a buffer to the connection specified.

Arguments:

  Connection  - Specifies the connection to send the file to, as returned by
                ConnectToDestination.
  Data        - Specifies the buffer to send
  DataSize    - Specifies the data size

Return Value:

  TRUE if the file was sent, FALSE otherwise.

--*/

{
    return pSendEncryptedData (
                Connection->Socket,
                Connection->Datagram ? &Connection->DatagramPool : NULL,
                Data,
                DataSize
                );
}


VOID
CloseConnection (
    IN      PCONNECTIONSOCKET Connection
    )
{
    if (Connection->Socket != INVALID_SOCKET) {
        closesocket (Connection->Socket);
        Connection->Socket = INVALID_SOCKET;
    }

    if (Connection->Datagram) {
        PmDestroyPool (Connection->DatagramPool.Pool);
        Connection->Datagram = FALSE;
    }
}


BOOL
ConnectToSource (
    OUT     PCONNECTIONSOCKET Connection,
    OUT     PTRANSFERMETRICS Metrics
    )

/*++

Routine Description:

  ConnectToSource locates the source machine and accepts a connection from
  it. To locate the source machine, broadcast messages are sent out on all
  available transports. The source machine collects the broadcasts, then
  selects the best transport, and connects to the destination machine. After
  the connection completes, this function returns the connection to the
  caller.

Arguments:

  Connection - Receives the connection to the source machine. This connection
               structure is then used to obtain data from the source.

  Metrics - Recieves the metrics from the source machine, indicating what
            data is going to be sent.

Return Value:

  TRUE if a connection was accepted, FALSE otherwise.

--*/

{
    ZeroMemory (Connection, sizeof (CONNECTIONSOCKET));
    Connection->Socket = INVALID_SOCKET;

    for (;;) {

        if (!pNameResolver (PLATFORM_DESTINATION, NULL, 0, Connection)) {
            return FALSE;
        }

        if (pReceiveMetrics (
                Connection->Socket,
                Connection->Datagram ? &Connection->DatagramPool : NULL,
                Metrics
                )) {
            return TRUE;
        }

        CloseConnection (Connection);
    }

    return TRUE;
}

DWORD
ReceiveFromSource (
    IN      PCONNECTIONSOCKET Connection,
    IN      PCTSTR LocalFileRoot,
    OUT     PBYTE *Buffer,
    IN      UINT Timeout    OPTIONAL
    )

/*++

Routine Description:

  ReceiveFromSource obtains whatever data is being sent from the source. If the data
  is a file, the file is saved into the directory indicated by LocalFileRoot.
  If the data is encrypted buffer we will allocate Buffer and return the decrypted
  data there.

Arguments:

  Connection    - Specifies the connection to send the file to, as returned by
                  ConnectToDestination.
  LocalFileRoot - Specifies the root of the local path of the file to save. The
                  actual file name and optional subpath comes from the destination.
  Buffer        - Specifies the buffer to be allocated and filled with decrypted data.

Return Value:

  The message ID received, or 0 if no message was recieved.

--*/

{
    DWORD msg;
    BOOL retry;

    do {

        retry = FALSE;

        msg = pReceiveMessage (Connection->Socket, Connection->Datagram ? &Connection->DatagramPool : NULL, Timeout);
        DEBUGMSG ((DBG_HOMENET, "Message from source: %u", msg));

        switch (msg) {

        case MESSAGE_FILE:
            BfCreateDirectory (LocalFileRoot);
            if (!pReceiveFile (
                    Connection->Socket,
                    Connection->Datagram ? &Connection->DatagramPool : NULL,
                    LocalFileRoot,
                    Timeout
                    )) {
                msg = 0;
            }

            break;

        case MESSAGE_DATA:
            if (!pReceiveEncryptedData (
                    Connection->Socket,
                    Connection->Datagram ? &Connection->DatagramPool : NULL,
                    Buffer,
                    Timeout
                    )) {
                msg = 0;
            }

            break;

        case MESSAGE_KEEP_ALIVE:
            retry = TRUE;
            break;

        }
    } while (retry);

    return msg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\guitrans\sources.inc ===
!include ..\..\modules.mk

MINORCOMP=guitrans

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\entry.c          \
    ..\guitrans.rc      \
    ..\removemed.c      \
    ..\netcommon.c      \
    ..\netsource.c      \
    ..\netdest.c        \
    ..\sockets.c        \
    ..\opaque.c         \
    ..\direct.c         \
    ..\logmsg.mc        \


DLLENTRY=_DllMainCRTStartup
LINKER_FLAGS=$(LINKER_FLAGS) -SWAPRUN:CD -SWAPRUN:NET
SUBSYSTEM_VERSION=4.00

# extra libs
TARGETLIBS= $(TARGETLIBS)                           \
            $(COBRA_ROOT)\lib\$(O)\memdb.lib        \
            $(COBRA_ROOT)\lib\$(O)\file.lib         \
            $(COBRA_ROOT)\lib\$(O)\modimage.lib     \
            $(COBRA_ROOT)\lib\$(O)\compress.lib     \
            $(COBRA_ROOT)\lib\$(O)\cablib.lib       \
            $(COBRA_ROOT)\lib\$(O)\inf.lib          \
            $(COBRA_ROOT)\bin\$(O)\migism.lib       \
            $(COBRA_ROOT)\lib\$(O)\reg.lib          \
            $(SDK_LIB_PATH)\cabinet.lib \
            $(SDK_LIB_PATH)\wsock32.lib \

PRECOMPILED_INCLUDE=pch.h

DLLDEF=..\guitrans.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\guitrans\netdest.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dest.c

Abstract:

    Implements the destination side of the home networking transport

Author:

    Jim Schmidt (jimschm) 01-Jul-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include <winsock.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <wsnetbs.h>
#include "homenetp.h"

#define DBG_HOMENET   "HomeNet"

//
// Strings
//

#define S_DETAILS_PREFIX        TEXT("details-")

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR TempFile [MAX_PATH];
    PCVOID AllocPtr;
    PCVOID DetailsPtr;
    HANDLE FileHandle;
    HANDLE MapHandle;
} ALLOCSTATE, *PALLOCSTATE;

//
// Globals
//

BOOL g_ConnectionRequested;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// none

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pHomeNetReadAllImages (
    VOID
    )
{
    PCTSTR imageFile = NULL;
    UINT imageIdx = 1;
    OCABHANDLE cabHandle;
    BOOL result = TRUE;

    do {

        imageFile = BuildImageFileName (imageIdx);
        if (!DoesFileExist (imageFile)) {
            FreeImageFileName (imageFile);
            break;
        }

        cabHandle = CabOpenCabinet (imageFile);
        if (cabHandle) {
            if (!CabExtractAllFiles (cabHandle, g_TransportTempDir)) {
                result = FALSE;
            }
            CabCloseCabinet (cabHandle);
            DeleteFile (imageFile);
        } else {
            result = FALSE;
        }

        FreeImageFileName (imageFile);
        imageIdx ++;

    } while (result);

    return result;
}

BOOL
pGeneratePassword (
    OUT     PSTR Key,
    IN      UINT KeySize
    )
{
    // no ILOilo0 characters
    CHAR validChars[] = "ABCDEFGHJKMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz123456789";
    DWORD validCharsNr = TcharCountA (validChars);
    HCRYPTPROV hProv = 0;
    UINT i;

    if (!CryptAcquireContext (&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
        return FALSE;
    }

    CryptGenRandom (hProv, KeySize, (LPBYTE)Key);
    for (i=0; i<KeySize; i++) {
        Key[i] = validChars[Key[i] % validCharsNr];
    }

    if (hProv) {
        CryptReleaseContext (hProv, 0);
        hProv = 0;
    }

    return TRUE;
}

DWORD WINAPI
DisplayPasswordProc (
    LPVOID lpParameter   // thread data
    )
{
    PPASSWORD_DATA passwordData;

    passwordData = (PPASSWORD_DATA) lpParameter;

    IsmSendMessageToApp (TRANSPORTMESSAGE_NET_DISPLAY_PASSWORD, (ULONG_PTR)passwordData);

    if (passwordData) {
        IsmReleaseMemory (passwordData);
    }

    ExitThread (0);
}

HANDLE
pDisplayPassword (
    IN      PCSTR Key,
    IN      HANDLE Event
    )
{
    PPASSWORD_DATA passwordData;
    DWORD threadId;

    passwordData = IsmGetMemory (sizeof (PASSWORD_DATA));
    if (!passwordData) {
        return NULL;
    }

    ZeroMemory (passwordData, sizeof (PASSWORD_DATA));
    passwordData->Key = (PSTR)Key;
    passwordData->KeySize = 0;
    passwordData->Event = Event;

    return CreateThread (
                NULL,
                0,
                DisplayPasswordProc,
                (LPVOID)(passwordData),
                0,
                &threadId
                );
}

BOOL
WINAPI
HomeNetTransportBeginApply (
    VOID
    )
{
    ERRUSER_EXTRADATA extraData;
    DWORD status = 0;
    PCTSTR memDbFile;
    BOOL b = FALSE;
    DWORD msg;
    UINT fileNumber = 0;
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;
    HANDLE event = NULL;
    HANDLE thread = NULL;
    DWORD waitResult;
    PBYTE buffer;

    g_Platform = PLATFORM_DESTINATION;

    ZeroMemory (&extraData, sizeof (ERRUSER_EXTRADATA));
    extraData.Error = ERRUSER_ERROR_UNKNOWN;

    __try {
        //
        // Download the image
        //

        if (g_BackgroundThread) {
            WaitForSingleObject (g_BackgroundThread, INFINITE);
        } else {
            g_ConnectionRequested = ConnectToSource (&g_Connection, &g_Metrics);
        }

        if (!g_ConnectionRequested) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
            extraData.Error = ERRUSER_ERROR_CANTFINDSOURCE;
            __leave;
        }

        // now we connected to the source. Let's pop up a dialog showing a randomly generated
        // password and ask the user to type the password on the source machine.
        if (!pGeneratePassword (g_GlobalKey, GLOBALKEY_SIZE)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            extraData.Error = ERRUSER_ERROR_NOENCRYPTION;
            __leave;
        }

        event = CreateEvent (NULL, TRUE, FALSE, NULL);

        thread =  pDisplayPassword (g_GlobalKey, event);

        // Let's wait for the first message (should be MESSAGE_PASSWORD);
        do {
            msg = ReceiveFromSource (&g_Connection, NULL, &buffer, 1000);

            if (msg == MESSAGE_DATA) {
                if (buffer && StringMatchA (g_GlobalKey, buffer)) {
                    // This is it, the key is correct
                    SetEvent (event);
                    SendMessageToDestination (&g_Connection, MESSAGE_PASSWORDOK);
                } else {
                    msg = 0;
                    SendMessageToDestination (&g_Connection, MESSAGE_PASSWORDWRONG);
                }
                if (buffer) {
                    HeapFree (g_hHeap, 0, buffer);
                }
            }

            if (msg == MESSAGE_CANCEL) {
                // The source computer cancelled
                SetEvent (event);
            }

            waitResult = WaitForSingleObject (thread, 0);

        } while ((waitResult == WAIT_TIMEOUT) && (msg != MESSAGE_DATA) && (msg != MESSAGE_CANCEL));

        if (thread) {
            waitResult = WaitForSingleObject (thread, 5000);
            if (waitResult == WAIT_TIMEOUT) {
                TerminateThread (thread, 0);
            }
            CloseHandle (thread);
            thread = NULL;
        }

        if (event) {
            CloseHandle (event);
            event = NULL;
        }

        if (msg != MESSAGE_DATA) {
            // the user cancelled
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
            extraData.Error = ERRUSER_ERROR_CANTFINDSOURCE;
            __leave;
        }

        DEBUGMSG ((DBG_HOMENET, "Receiving from source"));

        do {
            msg = ReceiveFromSource (&g_Connection, g_TransportTempDir, NULL, 0);

            if (msg == MESSAGE_FILE) {
                //
                // Tick the progress bar
                //

                fileNumber++;

                numerator = (LONGLONG) fileNumber * (LONGLONG) g_DownloadSliceSize;
                divisor = (LONGLONG) g_Metrics.FileCount;
                if (divisor) {
                    tick = numerator / divisor;
                } else {
                    tick = 0;
                }

                delta = (UINT) tick - g_DownloadTicks;

                if (delta) {
                    IsmTickProgressBar (g_DownloadSlice, delta);
                }
            }

        } while (msg && msg != MESSAGE_DONE);

        if (msg != MESSAGE_DONE) {
            if (GetLastError () == ERROR_DISK_FULL) {
                // we just failed because we don't have enough space on the destination
                // path. Let's tell that to the user
                extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
            } else {
                extraData.Error = ERRUSER_ERROR_CANTRECEIVEFROMSOURCE;
            }
            PushError ();
            LOG ((LOG_ERROR, (PCSTR) MSG_TRANSFER_INCOMPLETE));
            CloseConnection (&g_Connection);
            PopError ();
            __leave;
        }

        SendMessageToDestination (&g_Connection, MESSAGE_DONE);

        DEBUGMSG ((DBG_HOMENET, "Image transfer finished"));

        //
        // Now process the image
        //

        status = GetTransportStatus (g_StatusFile, &g_CompressData);

        if (status != TRSTATUS_READY) {
            LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_DOWNLOAD));
            extraData.Error = ERRUSER_ERROR_INVALIDDATARECEIVED;
            __leave;
        }

        g_StatusFileHandle = BfOpenFile (g_StatusFile);
        if (g_StatusFileHandle == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_STATUS_FILE, g_StatusFile));
            extraData.Error = ERRUSER_ERROR_INVALIDDATARECEIVED;
            __leave;
        }

        if (g_CompressData) {
            b = pHomeNetReadAllImages ();
        } else {
            b = TRUE;
        }

        if (b) {
            memDbFile = AllocStorageFileName (S_TRANSPORT_DAT_FILE);
            b = MemDbLoad (memDbFile);
            FreeStorageFileName (memDbFile);
        }

        if (!b) {
            extraData.Error = ERRUSER_ERROR_CANTREADIMAGE;
        }
    }
    __finally {
    }

    if (!b) {
        PushError ();
        extraData.ErrorArea = ERRUSER_AREA_LOAD;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
        PopError ();
    }

    return b;
}


VOID
WINAPI
HomeNetTransportEndApply (
    VOID
    )
{
    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    CloseConnection (&g_Connection);
}


BOOL
WINAPI
HomeNetTransportAcquireObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,         CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    UINT value;
    PCBYTE memValue;
    UINT memValueSize;
    PCTSTR fileValue = NULL;
    BOOL valueInFile;
    KEYHANDLE keyHandle;
    PALLOCSTATE allocState;
    PCTSTR detailsKey = NULL;
    PBYTE details;
    UINT detailsSize;
    PCTSTR sourceFile;
    PCTSTR decoratedObject = NULL;
    HANDLE fileHandle;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    MYASSERT (g_Platform == PLATFORM_DESTINATION);
    MYASSERT ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE);

    decoratedObject = BuildDecoratedObject (ObjectTypeId, ObjectName);

    allocState = (PALLOCSTATE) MemAllocZeroed (sizeof (ALLOCSTATE));

    if (MemDbGetValue (decoratedObject, &value)) {
        if (value == TRFLAG_FILE) {
            valueInFile = TRUE;
            keyHandle = MemDbGetSingleLinkage (decoratedObject, 0, 0);
            if (keyHandle) {
                fileValue = MemDbGetKeyFromHandle (keyHandle, 0);
                result = fileValue != NULL;
            } else {
                fileValue = NULL;
                result = TRUE;
            }
        } else if (value == TRFLAG_MEMORY) {
            valueInFile = FALSE;
            memValueSize = 0;
            memValue = MemDbGetUnorderedBlob (decoratedObject, 0, &memValueSize);
            result = TRUE;
        } else {
            LOG ((LOG_ERROR, (PCSTR) MSG_UNSUPPORTED_DATA, value));
            SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        }
        if (result) {
            result = FALSE;

            if (valueInFile) {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_FILE) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as a file and it's wanted as a file
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = TRUE;
                    if (fileValue) {
                        ObjectContent->FileContent.ContentPath = AllocStorageFileName (fileValue);
                        ObjectContent->FileContent.ContentSize = BfGetFileSize (ObjectContent->FileContent.ContentPath);
                    } else {
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                    result = TRUE;
                } else {
                    // this is stored as a file and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    if (fileValue) {
                        sourceFile = AllocStorageFileName (fileValue);
                        ObjectContent->MemoryContent.ContentSize = (UINT) BfGetFileSize (sourceFile);
                        ObjectContent->MemoryContent.ContentBytes = MapFileIntoMemory (
                                                                        sourceFile,
                                                                        &allocState->FileHandle,
                                                                        &allocState->MapHandle
                                                                        );
                        FreeStorageFileName (sourceFile);
                        result = (ObjectContent->MemoryContent.ContentBytes != NULL);
                    } else {
                        ObjectContent->MemoryContent.ContentSize = 0;
                        ObjectContent->MemoryContent.ContentBytes = NULL;
                        result = TRUE;
                    }
                }
                MemDbReleaseMemory (fileValue);
            } else {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_MEMORY) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as memory and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    ObjectContent->MemoryContent.ContentSize = memValueSize;
                    ObjectContent->MemoryContent.ContentBytes = memValue;
                    result = TRUE;
                } else {
                    // this is stored as memory and it's wanted as a file
                    if (memValue) {
                        if (IsmGetTempFile (allocState->TempFile, ARRAYSIZE(allocState->TempFile))) {
                            fileHandle = BfCreateFile (allocState->TempFile);
                            if (fileHandle) {
                                if (BfWriteFile (fileHandle, memValue, memValueSize)) {
                                    ObjectContent->ObjectTypeId = ObjectTypeId;
                                    ObjectContent->ContentInFile = TRUE;
                                    ObjectContent->FileContent.ContentSize = memValueSize;
                                    ObjectContent->FileContent.ContentPath = DuplicatePathString (allocState->TempFile, 0);
                                    result = TRUE;
                                }
                                CloseHandle (fileHandle);
                            }
                        }
                        MemDbReleaseMemory (memValue);
                    } else {
                        ObjectContent->ObjectTypeId = ObjectTypeId;
                        ObjectContent->ContentInFile = TRUE;
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                }
            }
        }
    } else {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
    }

    if (result) {
        //
        // Fill the details
        //

        detailsKey = JoinText (S_DETAILS_PREFIX, decoratedObject);

        details = MemDbGetUnorderedBlob (detailsKey, 0, &detailsSize);

        if (!details) {
            detailsSize = 0;
        }

        allocState->DetailsPtr = details;

        ObjectContent->Details.DetailsSize = detailsSize;
        ObjectContent->Details.DetailsData = details;

        FreeText (detailsKey);

        ObjectContent->TransHandle = allocState;
    }

    if (!result) {
        FreeAlloc (allocState);
    }

    DestroyDecoratedObject (decoratedObject);

    return result;
}

BOOL
WINAPI
HomeNetTransportReleaseObject (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PALLOCSTATE allocState;

    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    allocState = (PALLOCSTATE) ObjectContent->TransHandle;

    if (ObjectContent->ContentInFile) {
        FreeStorageFileName (ObjectContent->FileContent.ContentPath);
        if (allocState && allocState->TempFile[0]) {
            DeleteFile (allocState->TempFile);
        }
    } else {
        if (allocState && allocState->FileHandle && allocState->MapHandle) {
            UnmapFile (
                ObjectContent->MemoryContent.ContentBytes,
                allocState->MapHandle,
                allocState->FileHandle
                );
        } else {
            MemDbReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
        }
    }

    if (allocState && allocState->DetailsPtr) {
        MemDbReleaseMemory (allocState->DetailsPtr);
    }

    FreeAlloc (allocState);

    return TRUE;
}


DWORD
WINAPI
DestinationBackgroundThread (
    PVOID DontCare
    )
{
    BOOL connect;
    ULONG_PTR result;

    DEBUGMSG ((DBG_HOMENET, "Destination background thread is running"));

    for (;;) {
        connect = ConnectToSource (&g_Connection, &g_Metrics);

        if (connect) {

            DEBUGMSG ((DBG_HOMENET, "Asking app if connection is acceptable"));

            result = IsmSendMessageToApp (TRANSPORTMESSAGE_READY_TO_CONNECT, (ULONG_PTR) g_Metrics.SourceName);

            if (result == APPRESPONSE_FAIL) {
                DEBUGMSG ((DBG_HOMENET, "App says NO!"));
                CloseConnection (&g_Connection);
                continue;
            }

            DEBUGMSG ((DBG_HOMENET, "App says YES!"));
        }

        break;
    }

    g_ConnectionRequested = connect;

    DEBUGMSG ((DBG_HOMENET, "Destination background thread is complete"));

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\guitrans\unicode\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "trans.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\guitrans\ansi\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "trans.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\csm.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    csm.c

Abstract:

    Implements the existing state analyze portion of the v1 module.
    The existing state module enumerates everything in the environment
    variables DelReg* and DelFile* (where * is a one-based number),
    and then sets the delete operation on everything that matches.

Author:

    Jim Schmidt (jimschm) 21-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

#define NORMAL_DRIVE_BUFFER_BYTES 50000000
#define SYSTEM_DRIVE_BUFFER_BYTES (NORMAL_DRIVE_BUFFER_BYTES + 50000000)

#define MAX_CONTENT_CHECK   0x100000

//
// Macros
//

// None

//
// Types
//

typedef struct {
    ULARGE_INTEGER FreeSpace;
    DWORD BytesPerCluster;
} DRIVE_INFO, *PDRIVE_INFO;

//
// Globals
//

MIG_OPERATIONID g_DeleteOp;
MIG_OPERATIONID g_PartMoveOp;
HASHTABLE g_PartitionSpaceTable;
HASHTABLE g_PartitionMatchTable;
HASHTABLE g_CollisionSrcTable;
HASHTABLE g_CollisionDestTable;
PMHANDLE g_UntrackedCsmPool;
TCHAR g_SystemDrive[_MAX_DRIVE + 1];

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

CSMINITIALIZE ScriptCsmInitialize;
CSMEXECUTE ScriptCsmExecute;

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
pPopulatePartitionTable (
    VOID
    )
{
    PCTSTR drive;
    DRIVE_INFO driveInfo;
    ULARGE_INTEGER whoCares;
    PTSTR driveList = NULL;
    DWORD driveListLen;
    DWORD sectPerClust, bytesPerSect, freeClusters, totalClusters;
    FARPROC pGetDiskFreeSpaceEx;
    BOOL validDrive;

    if (!GetEnvironmentVariable (TEXT("SYSTEMDRIVE"), g_SystemDrive, _MAX_DRIVE)) {
        StringCopyTcharCount (g_SystemDrive, TEXT("C:"), _MAX_DRIVE);
    }

    driveListLen = GetLogicalDriveStrings (0, driveList);

    driveList = AllocText (driveListLen + 1);
    if (!driveList) {
        return;
    }

    GetLogicalDriveStrings (driveListLen, driveList);

    drive = driveList;

    // Find out if GetDiskFreeSpaceEx is supported
#ifdef UNICODE
    pGetDiskFreeSpaceEx = GetProcAddress (GetModuleHandle (TEXT("kernel32.dll")), "GetDiskFreeSpaceExW");
#else
    pGetDiskFreeSpaceEx = GetProcAddress (GetModuleHandle (TEXT("kernel32.dll")), "GetDiskFreeSpaceExA");
#endif

    while (*drive) {
        validDrive = FALSE;

        if (GetDriveType (drive) == DRIVE_FIXED) {
            ZeroMemory (&driveInfo, sizeof (DRIVE_INFO));
            if (pGetDiskFreeSpaceEx) {
                if (pGetDiskFreeSpaceEx (drive, &driveInfo.FreeSpace, &whoCares, &whoCares)) {
                    validDrive = TRUE;
                    if (GetDiskFreeSpace (drive, &sectPerClust, &bytesPerSect, &freeClusters, &totalClusters)) {
                        driveInfo.BytesPerCluster = bytesPerSect * sectPerClust;
                        if (!driveInfo.BytesPerCluster) {
                            driveInfo.BytesPerCluster = 1;
                        }
                    }
                }
            } else  {
                if (GetDiskFreeSpace (drive, &sectPerClust, &bytesPerSect, &freeClusters, &totalClusters)) {
                    driveInfo.FreeSpace.QuadPart = Int32x32To64 ((sectPerClust * bytesPerSect), freeClusters);
                    driveInfo.BytesPerCluster = bytesPerSect * sectPerClust;
                    if (!driveInfo.BytesPerCluster) {
                        driveInfo.BytesPerCluster = 1;
                    }
                    validDrive = TRUE;
                }
            }
        }

        if (validDrive) {
            HtAddStringEx (g_PartitionSpaceTable, drive, &driveInfo, FALSE);
        }

        // Advance to the next drive in the drive list
        drive = _tcschr (drive, 0) + 1;
    }

    FreeText (driveList);

}


BOOL
pIsSystemDrive (
    IN      PCTSTR Drive
    )
{
    if (StringIMatchCharCount (g_SystemDrive, Drive, 2)) {
        return TRUE;
    }

    return FALSE;
}


BOOL
pReserveDiskSpace (
    IN      PCTSTR DestDrive,
    IN      ULARGE_INTEGER FileSize,
    IN      BOOL IgnoreBuffer
    )
{
    DRIVE_INFO driveInfo;
    ULARGE_INTEGER buffer;
    HASHITEM hashItem;
    BOOL success = FALSE;

    hashItem = HtFindStringEx (g_PartitionSpaceTable, DestDrive, &driveInfo, FALSE);
    if (hashItem) {
        // let's transform the FileSize so it is alligned to BytesPerCluster
        FileSize.QuadPart = ((FileSize.QuadPart + driveInfo.BytesPerCluster - 1) / driveInfo.BytesPerCluster) * driveInfo.BytesPerCluster;
        if (IgnoreBuffer) {
            if (pIsSystemDrive (DestDrive)) {
                buffer.QuadPart = NORMAL_DRIVE_BUFFER_BYTES;
            } else {
                buffer.QuadPart = 0;
            }
        } else {
            if (pIsSystemDrive (DestDrive)) {
                buffer.QuadPart = SYSTEM_DRIVE_BUFFER_BYTES;
            } else {
                buffer.QuadPart = NORMAL_DRIVE_BUFFER_BYTES;
            }
        }

        // Check for available space
        if (driveInfo.FreeSpace.QuadPart > buffer.QuadPart &&
            FileSize.QuadPart < driveInfo.FreeSpace.QuadPart - buffer.QuadPart) {

            // Subtract claimed disk space
            driveInfo.FreeSpace.QuadPart -= FileSize.QuadPart;
            HtSetStringData (g_PartitionSpaceTable, hashItem, &driveInfo);
            success = TRUE;
        }
    }
    return success;
}

BOOL
pValidatePartition (
    IN      MIG_OBJECTSTRINGHANDLE CurrentObjectName,
    IN      PCTSTR Destination
    )
{
    MIG_CONTENT srcContent;
    PWIN32_FIND_DATAW findData;
    TCHAR tmpDrive[_MAX_DRIVE + 1];
    ULARGE_INTEGER fileSize;
    UINT driveType;
    PTSTR fullDest;

    fullDest = DuplicatePathString (Destination, 1);
    AppendWack (fullDest);

    // Check with full Destination path for cases of UNC paths
    driveType = GetDriveType (fullDest);

    if (driveType == DRIVE_NO_ROOT_DIR) {
        // It thinks there is nothing mounted at that destination.  If the destination
        // looks like G:\files1 then it will give this error when G: is a valid mapped
        // drive.  So we'll check one more time with just "G:\"
        fullDest[3] = 0;
        driveType = GetDriveType (fullDest);
    }
    FreePathString (fullDest);

    if (driveType == DRIVE_REMOTE ||
        (Destination[0] == TEXT('\\') && Destination[1] == TEXT('\\'))
        ) {
        return TRUE;
    }

    if (driveType == DRIVE_FIXED) {

        // Acquire the object to get the filesize
        if (IsmAcquireObjectEx (
                g_FileType | PLATFORM_SOURCE,
                CurrentObjectName,
                &srcContent,
                CONTENTTYPE_DETAILS_ONLY,
                0
                )) {

            // Check to see if the desired destination has space
            findData = (PWIN32_FIND_DATAW)srcContent.Details.DetailsData;
            fileSize.LowPart = findData->nFileSizeLow;
            fileSize.HighPart = findData->nFileSizeHigh;

            tmpDrive[0] = Destination[0];
            tmpDrive[1] = Destination[1];
            tmpDrive[2] = TEXT('\\');
            tmpDrive[3] = 0;

            IsmReleaseObject (&srcContent);

            return (pReserveDiskSpace (tmpDrive, fileSize, FALSE));
        }
    }

    // Not a Fixed drive or Remote drive, so it's not a valid destination
    return FALSE;
}

BOOL
pFindValidPartition (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN OUT  PTSTR DestNode,
    IN      BOOL IgnoreBuffer     // must be FALSE except when called by itself
    )
{
    MIG_CONTENT srcContent;
    PWIN32_FIND_DATAW findData;
    PTSTR drivePtr;
    ULARGE_INTEGER fileSize;
    TCHAR tmpDrive[_MAX_DRIVE + 1];
    BOOL newDestFound = FALSE;
    PTSTR driveList = NULL;
    DWORD driveListLen;
    TCHAR destDrive;
    BOOL destChanged = FALSE;
    PCTSTR oldDestNode;
    BOOL result = TRUE;

    oldDestNode = DuplicatePathString (DestNode, 0);

    if (IsmAcquireObjectEx (
            g_FileType | PLATFORM_SOURCE,
            ObjectName,
            &srcContent,
            CONTENTTYPE_DETAILS_ONLY,
            0
            )) {

        // First check to see if we already matched up this file
        if (HtFindStringEx (g_PartitionMatchTable, ObjectName, &destDrive, FALSE)) {
            DestNode[0] = destDrive;
        } else {
            // Need a new destination for this file
            destChanged = TRUE;

            findData = (PWIN32_FIND_DATAW)srcContent.Details.DetailsData;
            fileSize.LowPart = findData->nFileSizeLow;
            fileSize.HighPart = findData->nFileSizeHigh;

            if (GetEnvironmentVariable (TEXT("SYSTEMDRIVE"), tmpDrive, _MAX_DRIVE)) {
                AppendWack (tmpDrive);
                if (pReserveDiskSpace (tmpDrive, fileSize, IgnoreBuffer)) {
                    newDestFound = TRUE;
                    DestNode[0] = tmpDrive[0];
                }
            }

            if (newDestFound == FALSE) {
                // Check drives in alphabetical order
                driveListLen = GetLogicalDriveStrings (0, driveList);
                driveList = AllocText (driveListLen + 1);
                GetLogicalDriveStrings (driveListLen, driveList);

                drivePtr = driveList;
                while (*drivePtr) {
                    if (pReserveDiskSpace (drivePtr, fileSize, IgnoreBuffer)) {
                        DestNode[0] = drivePtr[0];
                        newDestFound = TRUE;
                        break;
                    }

                    // Advance to the next drive in the drive list
                    drivePtr = _tcschr (drivePtr, 0) + 1;
                }

                FreeText (driveList);
            }

            if (newDestFound == FALSE) {
                if (IgnoreBuffer == FALSE) {
                    // We couldn't find space.  Look again, but override the buffer space

                    // NTRAID#NTBUG9-153274-2000/08/01-jimschm It will currently fill up the system drive first, which is not what we should do.

                    result = pFindValidPartition (ObjectName, DestNode, TRUE);
                } else {
                    // Okay it's hopeless.  Keep track of how badly we're out of space
                    LOG ((
                        LOG_ERROR,
                        (PCSTR) MSG_PARTMAP_DISKFULL,
                        IsmGetNativeObjectName (g_FileType, ObjectName)
                        ));
                    result = FALSE;
                }
            } else {
                if (destChanged == TRUE) {
                    LOG ((
                        LOG_WARNING,
                        (PCSTR) MSG_PARTMAP_FORCED_REMAP,
                        IsmGetNativeObjectName (g_FileType, ObjectName),
                        oldDestNode,
                        DestNode
                        ));
                }
            }
        }
        IsmReleaseObject (&srcContent);
    }

    FreePathString (oldDestNode);

    return result;
}

BOOL
WINAPI
ScriptCsmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    //
    // Get file and registry types
    //
    g_FileType = MIG_FILE_TYPE;
    g_RegType = MIG_REGISTRY_TYPE;

    //
    // Get operation types
    //
    g_DeleteOp = IsmRegisterOperation (S_OPERATION_DELETE, FALSE);
    g_PartMoveOp = IsmRegisterOperation (S_OPERATION_PARTITION_MOVE, TRUE);

    g_LockPartitionAttr = IsmRegisterAttribute (S_ATTRIBUTE_PARTITIONLOCK, FALSE);

    g_CollisionSrcTable = HtAllocWithData (sizeof (HASHITEM));
    g_CollisionDestTable = HtAllocWithData (sizeof (MIG_OBJECTSTRINGHANDLE));

    g_PartitionSpaceTable = HtAllocWithData (sizeof (DRIVE_INFO));
    g_PartitionMatchTable = HtAllocWithData (sizeof (TCHAR));

    pPopulatePartitionTable ();

    g_UntrackedCsmPool = PmCreatePool ();
    PmDisableTracking (g_UntrackedCsmPool);

    OE5RemapDefaultId();

    return TRUE;
}


VOID
WINAPI
ScriptCsmTerminate (
    VOID
    )
{
    HtFree (g_CollisionSrcTable);
    g_CollisionSrcTable = NULL;

    HtFree (g_CollisionDestTable);
    g_CollisionDestTable = NULL;

    HtFree (g_PartitionSpaceTable);
    g_PartitionSpaceTable = NULL;

    HtFree (g_PartitionMatchTable);
    g_PartitionMatchTable = NULL;

    PmDestroyPool (g_UntrackedCsmPool);
    g_UntrackedCsmPool = NULL;

}


BOOL
pExecuteDeleteEnum (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE Pattern
    )
{
    MIG_OBJECT_ENUM e;
    BOOL b = TRUE;

    if (IsmEnumFirstDestinationObject (&e, ObjectTypeId, Pattern)) {

        do {

            b = IsmSetOperationOnObject (
                    e.ObjectTypeId,
                    e.ObjectName,
                    g_DeleteOp,
                    NULL,
                    NULL
                    );

            if (!b) {
                IsmAbortObjectEnum (&e);
                break;
            }

        } while (IsmEnumNextObject (&e));
    }

    return b;
}

BOOL
pCompareFiles (
    IN      PCTSTR File1,
    IN      PCTSTR File2
    )
{
    HANDLE fileHandle1 = NULL;
    HANDLE fileHandle2 = NULL;
#define BUFFER_SIZE 4096
    BYTE buffer1[BUFFER_SIZE], buffer2[BUFFER_SIZE];
    BOOL result = FALSE;
    BOOL res1, res2;
    DWORD read1, read2;

    __try {
        fileHandle1 = BfOpenReadFile (File1);
        fileHandle2 = BfOpenReadFile (File2);

        if (fileHandle1 && fileHandle2) {
            while (TRUE) {
                if (IsmCheckCancel ()) {
                    result = FALSE;
                    break;
                }
                res1 = ReadFile (fileHandle1, buffer1, BUFFER_SIZE, &read1, NULL);
                res2 = ReadFile (fileHandle2, buffer2, BUFFER_SIZE, &read2, NULL);
                if (!res1 && !res2) {
                    result = TRUE;
                    break;
                }
                if (res1 && res2) {
                    if (read1 != read2) {
                        break;
                    }
                    if (read1 == 0) {
                        result = TRUE;
                        break;
                    }
                    if (!TestBuffer (buffer1, buffer2, read1)) {
                        break;
                    }
                } else {
                    break;
                }
            }
        }
    }
    __finally {
        if (fileHandle1) {
            CloseHandle (fileHandle1);
            fileHandle1 = NULL;
        }
        if (fileHandle2) {
            CloseHandle (fileHandle2);
            fileHandle2 = NULL;
        }
    }
    return result;
}

BOOL
pContentMatch (
    IN      PMIG_CONTENT SrcContent,
    IN      PMIG_CONTENT DestContent,
    OUT     PBOOL DifferentDetailsOnly
    )
{
    UINT index;
    PWIN32_FIND_DATAW find1, find2;
    BOOL result = FALSE;
    PUBINT src;
    PUBINT dest;
    UINT remainder;
    UINT count;
    DWORD allAttribs;
    DWORD extendedAttribs;

    *DifferentDetailsOnly = FALSE;

    if (SrcContent->Details.DetailsSize != DestContent->Details.DetailsSize) {
        return FALSE;
    }
    if (!SrcContent->Details.DetailsData || !DestContent->Details.DetailsData) {
        return FALSE;
    }

    find1 = (PWIN32_FIND_DATAW)SrcContent->Details.DetailsData;
    find2 = (PWIN32_FIND_DATAW)DestContent->Details.DetailsData;

    if (find1->nFileSizeHigh != find2->nFileSizeHigh) {
        return FALSE;
    }
    if (find1->nFileSizeLow != find2->nFileSizeLow) {
        return FALSE;
    }
    if (SrcContent->ContentInFile && DestContent->ContentInFile) {
        result = pCompareFiles (SrcContent->FileContent.ContentPath, DestContent->FileContent.ContentPath);
    }
    if (!SrcContent->ContentInFile && !DestContent->ContentInFile) {
        if (SrcContent->MemoryContent.ContentSize != DestContent->MemoryContent.ContentSize) {
            return FALSE;
        }
        if ((!SrcContent->MemoryContent.ContentBytes && DestContent->MemoryContent.ContentBytes) ||
            (SrcContent->MemoryContent.ContentBytes && !DestContent->MemoryContent.ContentBytes)
            ) {
            return FALSE;
        }

        //
        // Compare the content using the largest unsigned int available, then
        // compare any remaining bytes
        //

        index = 0;
        count = SrcContent->MemoryContent.ContentSize / sizeof (UBINT);
        remainder = SrcContent->MemoryContent.ContentSize % sizeof (UBINT);
        src = (PUBINT) SrcContent->MemoryContent.ContentBytes;
        dest = (PUBINT) DestContent->MemoryContent.ContentBytes;

        while (count) {
            if (*src++ != *dest++) {
                DEBUGMSG ((DBG_WARNING, "Content mismatch because UBINTs differ"));
                return FALSE;
            }

            count--;
        }

        for (index = 0 ; index < remainder ; index++) {
            if (((PBYTE) src)[index] != ((PBYTE) dest)[index]) {
                DEBUGMSG ((DBG_WARNING, "Content mismatch because bytes differ"));
                return FALSE;
            }
        }

        result = TRUE;
    }

    if (!result) {
        return FALSE;
    }

    //
    // At this point the files are the same. Now if the attributes are different, return
    // FALSE indicating that only the details differ.
    //

    *DifferentDetailsOnly = TRUE;

    if (find1->dwFileAttributes != find2->dwFileAttributes) {
        return FALSE;
    }
    if (find1->ftLastWriteTime.dwLowDateTime != find2->ftLastWriteTime.dwLowDateTime) {
        return FALSE;
    }
    if (find1->ftLastWriteTime.dwHighDateTime != find2->ftLastWriteTime.dwHighDateTime) {
        return FALSE;
    }

    *DifferentDetailsOnly = FALSE;
    return TRUE;
}

BOOL
pDoesDifferentFileExist (
    IN      MIG_OBJECTSTRINGHANDLE SrcName,
    IN      MIG_OBJECTSTRINGHANDLE DestName,
    IN      PCTSTR DestNativeName,
    OUT     PBOOL DifferentDetailsOnly
    )
{
    MIG_CONTENT srcContent;
    MIG_CONTENT destContent;
    WIN32_FIND_DATA findData;
    BOOL result = FALSE;

    if (!DoesFileExistEx (DestNativeName, &findData)) {
        return FALSE;
    }
    if (findData.nFileSizeHigh) {
        return TRUE;
    }

    if (IsmAcquireObject (
            g_FileType | PLATFORM_DESTINATION,
            DestName,
            &destContent
            )) {
        result = TRUE;
        if (IsmAcquireObject (
                g_FileType | PLATFORM_SOURCE,
                SrcName,
                &srcContent
                )) {
            result = !pContentMatch (&srcContent, &destContent, DifferentDetailsOnly);
            IsmReleaseObject (&srcContent);
        }
        IsmReleaseObject (&destContent);
    } else {
        result = DoesFileExist (DestNativeName);
    }
    return result;
}

BOOL
pIsFileDestCollision (
    IN      MIG_OBJECTSTRINGHANDLE CurrentObjectName,
    IN      MIG_OBJECTSTRINGHANDLE OriginalObjectName,
    IN      PCTSTR CurrentNativeName,
    IN      BOOL CompareDestFiles,
    IN      BOOL *OnlyDetailsDiffer
)
{
    if (HtFindString (g_CollisionDestTable, CurrentObjectName)) {
       return TRUE;
    }
    if (CompareDestFiles &&
        pDoesDifferentFileExist (OriginalObjectName,
                                 CurrentObjectName,
                                 CurrentNativeName,
                                 OnlyDetailsDiffer)) {
        if (*OnlyDetailsDiffer == FALSE) {
            return TRUE;
        }
    }
    return FALSE;
}


MIG_OBJECTSTRINGHANDLE
pCollideFile (
    IN      MIG_OBJECTID OriginalObjectId,
    IN      MIG_OBJECTSTRINGHANDLE OriginalObjectName,
    IN      PCTSTR NewNode,
    IN      PCTSTR NewLeaf,
    IN      BOOL CompareDestFiles
    )
{
    MIG_OBJECTSTRINGHANDLE result = NULL;
    HASHITEM hashItem;
    PCTSTR testNativeName;
    PCTSTR leafExt = NULL;
    TCHAR buff[MAX_TCHAR_PATH * 2];
    PTSTR openParen = NULL;
    PTSTR closeParen = NULL;
    PTSTR tmpLeaf = NULL;
    PTSTR testLeaf = NULL;
    PTSTR chr;
    BOOL onlyDetailsDiffer = FALSE;
    BOOL replaceOk = TRUE;
    UINT fileIndex = 0;
    MIG_PROPERTYDATAID propDataId;
    BOOL specialPattern = FALSE;
    PTSTR fileCollPattern = NULL;
    MIG_BLOBTYPE propDataType;
    UINT requiredSize;


    if (!HtFindStringEx (g_CollisionSrcTable, OriginalObjectName, (PVOID)(&hashItem), FALSE)) {

        // we don't have a spot just yet. Let's make one.
        result = IsmCreateObjectHandle (NewNode, NewLeaf);
        testNativeName = JoinPaths (NewNode, NewLeaf);

        if (pIsFileDestCollision(result,
                                 OriginalObjectName,
                                 testNativeName,
                                 CompareDestFiles,
                                 &onlyDetailsDiffer)) {

            tmpLeaf = AllocText (TcharCount (NewLeaf) + 1);

            leafExt = _tcsrchr (NewLeaf, TEXT('.'));
            if (leafExt) {
                StringCopyAB (tmpLeaf, NewLeaf, leafExt);
                leafExt = _tcsinc (leafExt);
            } else {
                StringCopy (tmpLeaf, NewLeaf);
            }

            // Let's check if we wanted some special pattern for this file
            propDataId = IsmGetPropertyFromObjectId (OriginalObjectId, g_FileCollPatternData);
            if (propDataId) {
                if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
                    if (propDataType == BLOBTYPE_STRING) {
                        fileCollPattern = IsmGetMemory (requiredSize);
                        if (fileCollPattern) {
                            if (IsmGetPropertyData (
                                        propDataId,
                                        (PBYTE)fileCollPattern,
                                        requiredSize,
                                        NULL,
                                        &propDataType)) {
                                specialPattern = TRUE;
                            }
                            if (!specialPattern) {
                                IsmReleaseMemory (fileCollPattern);
                                fileCollPattern = NULL;
                            }
                        }
                    }
                }
            }

            if (specialPattern) {
                //
                // Loop until we find a non-colliding destination, or a colliding
                // dest that differs only by attributes
                //

                do {
                    FreePathString (testNativeName);
                    IsmDestroyObjectHandle (result);
                    fileIndex ++;

                    wsprintf (buff, fileCollPattern, tmpLeaf, fileIndex, leafExt?leafExt:TEXT(""));

                    result = IsmCreateObjectHandle (NewNode, buff);
                    testNativeName = JoinPaths (NewNode, buff);
                } while (fileIndex && pIsFileDestCollision(
                                            result,
                                            OriginalObjectName,
                                            testNativeName,
                                            CompareDestFiles,
                                            &onlyDetailsDiffer));
                if (fileCollPattern) {
                    IsmReleaseMemory (fileCollPattern);
                    fileCollPattern = NULL;
                }

                if (!fileIndex) {
                    // The collision pattern was bogus and we looped until
                    // we ran out of indexes. Let's go with the default
                    // collision mechanism.
                    specialPattern = FALSE;
                }
            }
            if (!specialPattern) {
                // Check if the filename already has a (number) tacked on
                openParen = _tcsrchr (tmpLeaf, TEXT('('));
                closeParen = _tcsrchr (tmpLeaf, TEXT(')'));

                if (closeParen && openParen &&
                    closeParen > openParen &&
                    closeParen - openParen > 1) {

                    // Make sure it's purely numerical
                    for (chr = openParen+1; chr < closeParen; chr++) {
                       if (!_istdigit (*chr)) {
                           replaceOk = FALSE;
                           break;
                       }
                    }

                    if (replaceOk == TRUE) {
                        if (_stscanf (openParen, TEXT("(%d)"), &fileIndex)) {
                            *openParen = 0;
                        }
                    }
                }

                //
                // Loop until we find a non-colliding destination, or a colliding
                // dest that differs only by attributes
                //

                do {
                    FreePathString (testNativeName);
                    IsmDestroyObjectHandle (result);
                    FreeText (testLeaf);
                    fileIndex ++;

                    wsprintf (buff, TEXT("(%d)"), fileIndex);
                    testLeaf = AllocText (TcharCount (tmpLeaf) + TcharCount (buff) + 1);
                    StringCopy (testLeaf, tmpLeaf);
                    StringCat (testLeaf, buff);
                    if (leafExt) {
                        StringCat (testLeaf, TEXT("."));
                        StringCat (testLeaf, leafExt);
                    }

                    result = IsmCreateObjectHandle (NewNode, testLeaf);
                    testNativeName = JoinPaths (NewNode, testLeaf);
                } while (pIsFileDestCollision(result,
                                              OriginalObjectName,
                                              testNativeName,
                                              CompareDestFiles,
                                              &onlyDetailsDiffer));
            }

            FreeText (tmpLeaf);
        }

        if (onlyDetailsDiffer) {
            IsmAbandonObjectOnCollision (g_FileType | PLATFORM_DESTINATION, OriginalObjectName);
        }

        FreePathString (testNativeName);
        FreeText (testLeaf);

        //
        // Put new destination in the hash table and store the Ism handle, which will
        // be cleaned up at the end.
        //

        hashItem = HtAddStringEx (g_CollisionDestTable, result, &result, FALSE);
        HtAddStringEx (g_CollisionSrcTable, OriginalObjectName, &hashItem, FALSE);
    } else {
        //
        // Get the already computed collision destination.
        //

        HtCopyStringData (g_CollisionDestTable, hashItem, (PVOID)(&result));
    }

    return result;
}


MIG_OBJECTSTRINGHANDLE
pCollisionGetDestination (
    IN      MIG_OBJECTID OriginalObjectId,
    IN      MIG_OBJECTSTRINGHANDLE OriginalObjectName,
    IN      PCTSTR NewNode,
    IN      PCTSTR NewLeaf
    )
{
    MIG_OBJECTSTRINGHANDLE result = NULL;
    BOOL onlyDetailsDiffer = FALSE;

    // now we have the destination node. If this is actually a file
    // we need to check for collisions. For this we look if the
    // destination already has a file like this. After that we use
    // a table to reserve ourselves a spot.

    if (NewLeaf) {
        if (IsmIsObjectAbandonedOnCollision (g_FileType | PLATFORM_DESTINATION, OriginalObjectName)) {
            // we don't care about existing files on the destination machine.
            // However, some files that we just copy may collide with each other
            // so we have to check that.
            result = pCollideFile (OriginalObjectId, OriginalObjectName, NewNode, NewLeaf, FALSE);
        } else if (IsmIsObjectAbandonedOnCollision (g_FileType | PLATFORM_SOURCE, OriginalObjectName)) {
            // this will potentially collide with an existent file but then the source file
            // would not survive.
            result = IsmCreateObjectHandle (NewNode, NewLeaf);
        } else {
            result = pCollideFile (OriginalObjectId, OriginalObjectName, NewNode, NewLeaf, TRUE);

        }
    } else {
        result = IsmCreateObjectHandle (NewNode, NULL);
    }
    return result;
}


BOOL
pExecuteFixFilename (
    VOID
    )
{
    UINT ticks;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    MIG_PROGRESSSLICEID sliceId;
    PCTSTR destination = NULL;
    MIG_OBJECTSTRINGHANDLE destFilename;
    PTSTR node = NULL;
    PCTSTR leaf = NULL;
    MIG_BLOB opData;
    PMIG_OBJECTCOUNT objectCount;
    BOOL deleted;

    objectCount = IsmGetObjectsStatistics (g_FileType | PLATFORM_SOURCE);
    if (objectCount) {
        ticks = objectCount->TotalObjects;
    } else {
        ticks = 0;
    }

    sliceId = IsmRegisterProgressSlice (ticks, max (1, ticks / 5));

    // Enum source file objects
    enumPattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);  // *,*
    if (IsmEnumFirstSourceObject (&objectEnum, g_FileType, enumPattern)) {
        do {
            // Check if Apply
            if (IsmIsApplyObjectId (objectEnum.ObjectId)) {

                // Macro expansion, rule processing, etc
                destination = IsmFilterObject (objectEnum.ObjectTypeId,
                                               objectEnum.ObjectName,
                                               NULL,
                                               &deleted,
                                               NULL);

                if (deleted) {
                    continue;
                }

                if (!destination) {
                    destination = objectEnum.ObjectName;
                }

                IsmCreateObjectStringsFromHandle (destination, &node, &leaf);

                if (node && _tcslen (node) >= 2) {
                    if (IsValidFileSpec (node)) {
                        if (!pValidatePartition (objectEnum.ObjectName, node)) {
                            if (!IsmIsAttributeSetOnObjectId (objectEnum.ObjectId, g_LockPartitionAttr)) {
                                // Pick a new destination partition
                                pFindValidPartition (objectEnum.ObjectName, node, FALSE);
                            }
                        }
                    }
                }

                // We have selected a new partition, so now check for file collisions
                destFilename = pCollisionGetDestination (
                                    objectEnum.ObjectId,
                                    objectEnum.ObjectName,
                                    node,
                                    leaf
                                    );

                if (node) {
                    IsmDestroyObjectString (node);
                    node = NULL;
                }
                if (leaf) {
                    IsmDestroyObjectString (leaf);
                    leaf = NULL;
                }

                opData.Type = BLOBTYPE_STRING;
                opData.String = PmDuplicateString (g_UntrackedCsmPool, destFilename);
                IsmDestroyObjectHandle (destFilename);
                destFilename = NULL;

                // Set a custom operation that will fix the name
                IsmSetOperationOnObjectId (
                    objectEnum.ObjectId,
                    g_PartMoveOp,
                    (MIG_DATAHANDLE) 0,
                    &opData
                    );

                if (!IsmTickProgressBar (sliceId, 1)) {
                   IsmAbortObjectEnum (&objectEnum);
                   break;
                }

                if (destination != objectEnum.ObjectName) {
                    IsmDestroyObjectHandle (destination);
                }

            }
        } while (IsmEnumNextObject (&objectEnum));
    }

    IsmDestroyObjectHandle (enumPattern);
    INVALID_POINTER (enumPattern);

    return TRUE;
}


BOOL
WINAPI
ScriptCsmExecute (
    VOID
    )
{
    UINT u;
    TCHAR string[32];
    TCHAR pattern[MAX_TCHAR_PATH];

    //
    // Enumerate the environment variables DelReg* and DelFile*,
    // then enumerate all physical objects represented by the
    // pattern, and finally, mark the objects with delete operations.
    //

    u = 1;
    for (;;) {
        wsprintf (string, TEXT("DelReg%u"), u);
        u++;

        if (IsmGetEnvironmentString (
                PLATFORM_SOURCE,
                NULL,
                string,
                pattern,
                ARRAYSIZE(pattern),
                NULL
                )) {

            if (!pExecuteDeleteEnum (g_RegType, (MIG_OBJECTSTRINGHANDLE) pattern)) {
                return FALSE;
            }
        } else {
            break;
        }
    }

    u = 1;
    for (;;) {
        wsprintf (string, TEXT("DelFile%u"), u);
        u++;

        if (IsmGetEnvironmentString (
                PLATFORM_SOURCE,
                NULL,
                string,
                pattern,
                ARRAYSIZE(pattern),
                NULL
                )) {

            if (!pExecuteDeleteEnum (g_FileType, (MIG_OBJECTSTRINGHANDLE) pattern)) {
                return FALSE;
            }
        } else {
            break;
        }
    }

    pExecuteFixFilename ();

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\attrib.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    attrib.c

Abstract:

    Implements the v1 script application attributes.

Author:

    Jim Schmidt (jimschm) 08-Jun-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_ATTRIB      "Attrib"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct _MIGDB_ATTRIB {
    INT AttribIndex;
    UINT ArgCount;
    PCTSTR Arguments;
    BOOL NotOperator;
    struct _MIGDB_ATTRIB *Next;
} MIGDB_ATTRIB, *PMIGDB_ATTRIB;

typedef BOOL(ATTRIBUTE_FUNCTION)(PCTSTR ArgMultiSz, PATTRIB_DATA Content);
typedef ATTRIBUTE_FUNCTION *PATTRIBUTE_FUNCTION;

typedef struct {
    PCTSTR AttributeName;
    PATTRIBUTE_FUNCTION Function;
    UINT RequiredArgs;
} ATTRIBUTE_FUNCTION_ITEM, *PATTRIBUTE_FUNCTION_ITEM;


//
// Globals
//

extern BOOL g_VcmMode;  // in sgmqueue.c

//
// Macro expansion list
//

#define ATTRIBUTE_LIST                                          \
    DEFMAC(EXISTS, pExists, 0)                                  \
    DEFMAC(SAMEOBJECTNAME, pSameObjectName, 1)                  \
    DEFMAC(SAMEOBJECTCONTENT, pSameObjectContent, 2)            \
    DEFMAC(ISREGFLAGSET, pIsRegFlagSet, 1)                      \
    DEFMAC(MATCHES, pMatches, 1)                                \
    DEFMAC(SET_PERSIST_FLAG, pSetPersistFlag, 0)                \
    DEFMAC(NOTEMPTY, pNotEmpty, 0)                              \
    DEFMAC(VERSION, pVersion, 2)                                \

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

#define DEFMAC(name,fn,req_args)    ATTRIBUTE_FUNCTION fn;

ATTRIBUTE_LIST

#undef DEFMAC

#define DEFMAC(name,fn,req_args)    TEXT(#name), fn, req_args,

ATTRIBUTE_FUNCTION_ITEM g_FnList[] = {

    ATTRIBUTE_LIST /* , */
    NULL, NULL, 0
};



//
// Code
//

#define STATE_ATTRNAME  1
#define STATE_ATTRARG   2

INT
pGetAttribIndex (
    IN      PCTSTR AttribName
    )

/*++

Routine Description:

  This routine returns the index in attribute functions array for a specified
  attribute.

Arguments:

  AttribName - Attribute name

Return value:

  -1 - no such attribute in attribute table

--*/

{
    INT attribIndex;
    INT rc = 0;
    PTSTR attrEnd = NULL;
    TCHAR savedChar = 0;

    attrEnd = (PTSTR) SkipSpaceR (AttribName, GetEndOfString (AttribName));
    if (attrEnd != NULL) {
        attrEnd = _tcsinc (attrEnd);
        savedChar = attrEnd [0];
        attrEnd [0] = 0;
    }
    __try {
        for (attribIndex = 0 ; g_FnList[attribIndex].AttributeName ; attribIndex++) {
            if (StringIMatch (g_FnList[attribIndex].AttributeName, AttribName)) {
                break;
            }
        }

        if (!g_FnList[attribIndex].AttributeName) {
            attribIndex = -1;
            LOG ((LOG_ERROR, (PCSTR) MSG_DETECT_ATTRIB_NOT_FOUND, AttribName));
        }

        rc = attribIndex;
    }
    __finally {
        if (attrEnd != NULL) {
            attrEnd [0] = savedChar;
        }
    }

    return rc;
}


UINT
pGetReqArgCount (
    IN      INT AttributeIndex
    )
{
    if (AttributeIndex < 0 || AttributeIndex > ARRAYSIZE(g_FnList)) {
        return 0;
    }

    return g_FnList[AttributeIndex].RequiredArgs;
}


BOOL
pValidateArg (
    IN OUT  PMIGDB_ATTRIB AttribStruct
    )
{
    //
    // Validate all AttribStruct members
    //

    MYASSERT (AttribStruct);

    if (AttribStruct->ArgCount != pGetReqArgCount (AttribStruct->AttribIndex)) {
        AttribStruct->AttribIndex = -1;
        return FALSE;
    }

    return TRUE;
}


PMIGDB_ATTRIB
pLoadAttribData (
    IN      PMHANDLE Pool,
    IN      PCTSTR MultiSzStr
    )

/*++

Routine Description:

  This routine creates a list of MIGDB_ATTRIBs from a multisz.

Arguments:

  Pool - Specifies a pool that temporary structures and the return value
         will be allocated from

  MultiSzStr - Specifies the multisz to be processed. The multi-sz must
               be in the form of ATTRIB or ATTRIB(arg[,arg,...])

Return value:

  MIGDB_ATTRIB nodes

--*/

{
    MULTISZ_ENUM multiSzEnum;
    PMIGDB_ATTRIB result  = NULL;
    PMIGDB_ATTRIB tmpAttr = NULL;
    INT state = STATE_ATTRNAME;
    PTSTR currStrPtr = NULL;
    PTSTR currArgPtr = NULL;
    PTSTR endArgPtr  = NULL;
    TCHAR savedChar  = 0;
    GROWBUFFER argList = INIT_GROWBUFFER;

    if (EnumFirstMultiSz (&multiSzEnum, MultiSzStr)) {

        do {
            currStrPtr = (PTSTR) SkipSpace (multiSzEnum.CurrentString);

            if (state == STATE_ATTRNAME) {
                tmpAttr = (PMIGDB_ATTRIB) PmGetMemory (Pool, sizeof (MIGDB_ATTRIB));

                ZeroMemory (tmpAttr, sizeof (MIGDB_ATTRIB));

                if (_tcsnextc (currStrPtr) == TEXT('!')) {
                    currStrPtr = _tcsinc (currStrPtr);
                    currStrPtr = (PTSTR) SkipSpace (currStrPtr);
                    tmpAttr->NotOperator = TRUE;
                }

                currArgPtr = _tcschr (currStrPtr, TEXT('('));

                if (currArgPtr) {
                    endArgPtr = _tcsdec (currStrPtr, currArgPtr);
                    if (endArgPtr) {
                        endArgPtr = (PTSTR) SkipSpaceR (currStrPtr, endArgPtr);
                        endArgPtr = _tcsinc (endArgPtr);
                    }
                    else {
                        endArgPtr = currStrPtr;
                    }

                    savedChar = *endArgPtr;
                    *endArgPtr = 0;
                    tmpAttr->AttribIndex = pGetAttribIndex (currStrPtr);
                    *endArgPtr = savedChar;
                    currStrPtr = _tcsinc (currArgPtr);
                    state = STATE_ATTRARG;
                }
                else {
                    // this attribute has no arguments.
                    tmpAttr->AttribIndex = pGetAttribIndex (currStrPtr);
                    tmpAttr->Next = result;
                    result = tmpAttr;

                    pValidateArg (result);
                    continue;
                }
            }

            if (state == STATE_ATTRARG) {
                currStrPtr = (PTSTR) SkipSpace (currStrPtr);
                endArgPtr = _tcsrchr (currStrPtr, TEXT(')'));
                if (endArgPtr && endArgPtr[1] == 0) {
                    endArgPtr = _tcsdec (currStrPtr, endArgPtr);
                    if (endArgPtr) {
                        endArgPtr = (PTSTR) SkipSpaceR (currStrPtr, endArgPtr);
                        endArgPtr = _tcsinc (endArgPtr);
                    }
                    else {
                        endArgPtr = currStrPtr;
                    }
                    savedChar = *endArgPtr;
                    *endArgPtr = 0;
                } else {
                    endArgPtr = NULL;
                }

                GbMultiSzAppend (&argList, currStrPtr);

                tmpAttr->ArgCount++;

                if (endArgPtr) {
                    *endArgPtr = savedChar;
                    tmpAttr->Arguments = PmDuplicateMultiSz (Pool, (PTSTR) argList.Buf);
                    GbFree (&argList);
                    state = STATE_ATTRNAME;
                    tmpAttr->Next = result;
                    result = tmpAttr;

                    pValidateArg (result);
                }
            }

        } while (EnumNextMultiSz (&multiSzEnum));
    }

    return result;
}


BOOL
TestAttributes (
    IN      PMHANDLE WorkPool,
    IN      PCTSTR ArgumentMultiSz,
    IN      PATTRIB_DATA AttribData
    )

/*++

Routine Description:

  TestAttributes executes the attribute functions specified in the
  ArgumentMultiSz parameter. Each argument is tested until they all succeed
  or until one fails.

Arguments:

  WorkPool        - Specifies a pool handle for fast allocations
  ArgumentMultiSz - Specifies the multi-sz that contains argument
                    specifications
  AttribData      - Specifies the object name, script specifications and
                    object content

Return Value:

  TRUE if all attributes pass (or if zero attributes were specified), FALSE
  otherwise.

--*/

{
    PMIGDB_ATTRIB attrib;
    PMIGDB_ATTRIB tmpAttrib;
    BOOL result = TRUE;

    attrib = pLoadAttribData (WorkPool, ArgumentMultiSz);
    tmpAttrib = attrib;

    while (result && attrib) {
        if (attrib->AttribIndex < 0 || attrib->AttribIndex >= ARRAYSIZE(g_FnList)) {
            DEBUGMSG ((DBG_WHOOPS, "Invalid attribute index %i", attrib->AttribIndex));
            result = FALSE;
        } else {

            result = g_FnList[attrib->AttribIndex].Function (attrib->Arguments, AttribData);

            if (attrib->NotOperator) {
                result = !result;
            }
        }

        attrib = attrib->Next;
    }

    // now free the attribute list
    attrib = tmpAttrib;
    while (attrib) {
        tmpAttrib = attrib->Next;
        if (attrib->Arguments) {
            PmReleaseMemory (WorkPool, attrib->Arguments);
        }
        PmReleaseMemory (WorkPool, attrib);
        attrib = tmpAttrib;
    }

    return result;
}


//
// Attribute functions (see ATTRIBUTE_LIST)
//

BOOL
pExists (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    return (Data->ReturnString != NULL);
}

BOOL
pSameObjectName (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    return (StringIMatch (FunctionArguments, Data->ScriptSpecifiedObject));
}

BOOL
pSameObjectContent (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    PCTSTR scriptObjectType = NULL;
    PCTSTR scriptObjectName = NULL;
    ATTRIB_DATA attribData;
    BOOL result = FALSE;

    scriptObjectType = FunctionArguments;
    scriptObjectName = GetEndOfString (FunctionArguments);
    if (scriptObjectName) {
        scriptObjectName ++;
    }

    if (!scriptObjectType || !scriptObjectName) {
        return FALSE;
    }

    ZeroMemory (&attribData, sizeof (ATTRIB_DATA));
    attribData.ScriptSpecifiedType = scriptObjectType;
    attribData.ScriptSpecifiedObject = scriptObjectName;
    attribData.ApplicationName = Data->ApplicationName;

    if (!AllocScriptType (&attribData)) {
        return FALSE;
    }

    // let's persist the object in VCM mode so we can look at it later
    if (g_VcmMode && attribData.ObjectName) {
        if (IsmDoesObjectExist (attribData.ObjectTypeId, attribData.ObjectName)) {
            IsmMakePersistentObject (attribData.ObjectTypeId, attribData.ObjectName);
        }
    }

    if (Data->ObjectContent && attribData.ObjectContent) {
        if (Data->ObjectContent->ObjectTypeId == attribData.ObjectContent->ObjectTypeId) {
            if (Data->ObjectContent->Details.DetailsSize == attribData.ObjectContent->Details.DetailsSize) {
                if (!Data->ObjectContent->Details.DetailsSize ||
                    TestBuffer (
                        Data->ObjectContent->Details.DetailsData,
                        attribData.ObjectContent->Details.DetailsData,
                        Data->ObjectContent->Details.DetailsSize
                        )
                    ) {
                    if (Data->ObjectContent->ContentInFile == attribData.ObjectContent->ContentInFile) {
                        if (Data->ObjectContent->ContentInFile) {
                            if (StringIMatch (
                                    Data->ObjectContent->FileContent.ContentPath,
                                    attribData.ObjectContent->FileContent.ContentPath
                                    )
                                ) {
                                result = TRUE;
                            }
                        } else {
                            if (Data->ObjectContent->MemoryContent.ContentSize == attribData.ObjectContent->MemoryContent.ContentSize) {
                                if (!Data->ObjectContent->MemoryContent.ContentSize ||
                                    TestBuffer (
                                        Data->ObjectContent->MemoryContent.ContentBytes,
                                        attribData.ObjectContent->MemoryContent.ContentBytes,
                                        Data->ObjectContent->MemoryContent.ContentSize
                                        )
                                    ) {
                                    result = TRUE;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    FreeScriptType (&attribData);

    return result;
}

BOOL
pIsRegFlagSet (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    DWORD inValue;
    DWORD value;

    if (!Data) {
        return FALSE;
    }
    if (!FunctionArguments) {
        return FALSE;
    }
    if (!Data->ObjectContent) {
        return FALSE;
    }
    if ((Data->ObjectContent->ObjectTypeId & ~PLATFORM_MASK) != MIG_REGISTRY_TYPE) {
        return FALSE;
    }
    if (Data->ObjectContent->Details.DetailsSize != sizeof (DWORD)) {
        return FALSE;
    }
    if ((*((PDWORD)(Data->ObjectContent->Details.DetailsData)) != REG_DWORD) &&
        (*((PDWORD)(Data->ObjectContent->Details.DetailsData)) != REG_SZ)
        ) {
        return FALSE;
    }
    if (Data->ObjectContent->ContentInFile) {
        return FALSE;
    }
    if (Data->ObjectContent->MemoryContent.ContentSize == 0) {
        return FALSE;
    }
    if (Data->ObjectContent->MemoryContent.ContentBytes == NULL) {
        return FALSE;
    }
    if (*((PDWORD)(Data->ObjectContent->Details.DetailsData)) == REG_DWORD) {
        inValue = *((PDWORD)(Data->ObjectContent->MemoryContent.ContentBytes));
    } else {
        _stscanf ((PCTSTR)Data->ObjectContent->MemoryContent.ContentBytes, TEXT("%ld"), &inValue);
    }
    _stscanf (FunctionArguments, TEXT("%lx"), &value);
    if (!(inValue & value)) {
        return FALSE;
    }
    return TRUE;
}

BOOL
pMatches (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    if (!Data->ReturnString) {
        return FALSE;
    }

    return (StringIMatch (FunctionArguments, Data->ReturnString));
}

BOOL
pSetPersistFlag (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    if (IsmDoesObjectExist (Data->ObjectTypeId, Data->ObjectName)) {
        IsmMakePersistentObject (Data->ObjectTypeId, Data->ObjectName);
    }

    return TRUE;
}

BOOL
pNotEmpty (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    if (!Data->ReturnString) {
        return FALSE;
    }

    return (Data->ReturnString[0] != 0);
}

BOOL
pVersion (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    PCTSTR versionStr = NULL;
    PCTSTR versionValue = NULL;
    ATTRIB_DATA attribData;
    BOOL result = FALSE;

    versionStr = FunctionArguments;
    if (!versionStr) {
        return FALSE;
    }

    versionValue = GetEndOfString (FunctionArguments);
    if (!versionValue) {
        return FALSE;
    }
    versionValue ++;

    if (!Data) {
        return FALSE;
    }
    if (!Data->ReturnString) {
        return FALSE;
    }

    ZeroMemory (&attribData, sizeof (ATTRIB_DATA));
    attribData.ScriptSpecifiedType = TEXT("File");
    attribData.ScriptSpecifiedObject = Data->ReturnString;
    attribData.ApplicationName = Data->ApplicationName;

    if (!AllocScriptType (&attribData)) {
        return FALSE;
    }

    // let's persist the object in VCM mode so we can look at it later
    if (g_VcmMode && attribData.ObjectName) {
        if (IsmDoesObjectExist (attribData.ObjectTypeId, attribData.ObjectName)) {
            IsmMakePersistentObject (attribData.ObjectTypeId, attribData.ObjectName);
        }
    }

    if (attribData.ObjectContent &&
        attribData.ObjectContent->ContentInFile &&
        attribData.ObjectContent->FileContent.ContentPath
        ) {
        result = VrCheckFileVersion (attribData.ObjectContent->FileContent.ContentPath, versionStr, versionValue);
    }

    FreeScriptType (&attribData);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\entry.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    entry.c

Abstract:

    Implements the DLL entry point that provides all Cobra module entry points
    to the engine.

Author:

    Jim Schmidt (jimschm) 11-Aug-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "v1p.h"


typedef struct {
    PCTSTR Name;
    TYPE_ENTRYPOINTS EntryPoints;
} ETM_TABLE, *PETM_TABLE;

typedef struct {
    PCTSTR Name;
    VIRTUAL_COMPUTER_ENTRYPOINTS EntryPoints;
} VCM_TABLE, *PVCM_TABLE;

typedef struct {
    PCTSTR Name;
    SOURCE_ENTRYPOINTS EntryPoints;
} SOURCE_TABLE, *PSOURCE_TABLE;

typedef struct {
    PCTSTR Name;
    DESTINATION_ENTRYPOINTS EntryPoints;
} DESTINATION_TABLE, *PDESTINATION_TABLE;


//
// Add an entry for each ETM module in the DLL
//

ETM_TABLE g_EtmEntryPoints[] = {
    {   TEXT("SCRIPT"), ISM_VERSION,
        ScriptEtmInitialize, ScriptEtmParse, ScriptEtmTerminate, NULL
    },

    {NULL}
};

//
// Add an entry for each VCM module in the DLL
//

VCM_TABLE g_VcmEntryPoints[] = {
    {   TEXT("SCRIPT"), ISM_VERSION,
        ScriptVcmInitialize, ScriptVcmParse, ScriptVcmQueueEnumeration, NULL, ScriptTerminate
    },

    {NULL}
};

//
// Add an entry for each source module in the DLL
//

SOURCE_TABLE g_SourceEntryPoints[] = {
    {   TEXT("SCRIPT"), ISM_VERSION,
        ScriptSgmInitialize, ScriptSgmParse, ScriptSgmQueueEnumeration, NULL, (PSGMTERMINATE) ScriptTerminate,
        NULL, NULL, NULL, NULL
    },

    {NULL}
};

//
// Add an entry for each destination module in the DLL
//

DESTINATION_TABLE g_DestinationEntryPoints[] = {
    {   TEXT("SCRIPT"), ISM_VERSION,
        ScriptDgmInitialize, ScriptDgmQueueEnumeration, NULL, NULL,
        NULL, NULL, NULL, NULL,
        ScriptCsmInitialize, ScriptCsmExecute, NULL, ScriptCsmTerminate,
        ScriptOpmInitialize, ScriptOpmTerminate
    },

    {NULL}
};


EXPORT
BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        g_hInst = hInstance;
    }

    return TRUE;
}


BOOL
WINAPI
pFindModule (
    IN      PCTSTR ModuleId,
    OUT     PVOID IsmBuffer,
    IN      PCTSTR *TableEntry,
    IN      UINT StructureSize
    )
{

    while (*TableEntry) {
        if (StringIMatch (*TableEntry, ModuleId)) {
            CopyMemory (
                IsmBuffer,
                (PBYTE) (TableEntry + 1),
                StructureSize
                );
            return TRUE;
        }

        TableEntry = (PCTSTR *) ((PBYTE) (TableEntry + 1) + StructureSize);
    }

    return FALSE;
}



EXPORT
BOOL
WINAPI
TypeModule (
    IN      PCTSTR ModuleId,
    IN OUT  PTYPE_ENTRYPOINTS TypeEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) TypeEntryPoints,
                (PCTSTR *) g_EtmEntryPoints,
                sizeof (TYPE_ENTRYPOINTS)
                );
}


EXPORT
BOOL
WINAPI
VirtualComputerModule (
    IN      PCTSTR ModuleId,
    IN OUT  PVIRTUAL_COMPUTER_ENTRYPOINTS VirtualComputerEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) VirtualComputerEntryPoints,
                (PCTSTR *) g_VcmEntryPoints,
                sizeof (VIRTUAL_COMPUTER_ENTRYPOINTS)
                );
}


EXPORT
BOOL
WINAPI
SourceModule (
    IN      PCTSTR ModuleId,
    IN OUT  PSOURCE_ENTRYPOINTS SourceEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) SourceEntryPoints,
                (PCTSTR *) g_SourceEntryPoints,
                sizeof (SOURCE_ENTRYPOINTS)
                );
}


EXPORT
BOOL
WINAPI
DestinationModule (
    IN      PCTSTR ModuleId,
    IN OUT  PDESTINATION_ENTRYPOINTS DestinationEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) DestinationEntryPoints,
                (PCTSTR *) g_DestinationEntryPoints,
                sizeof (DESTINATION_ENTRYPOINTS)
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\app.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    app.c

Abstract:

    Implements a set of functions to manage data for an application section.

Author:

    Jim Schmidt (jimschm) 05-Jun-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_FOO     "Foo"

//
// Strings
//

// None

//
// Constants
//

#define MAX_EXPANDED_STRING         4096

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_AppPool;
extern BOOL g_VcmMode;  // in sgmqueue.c
GROWLIST g_SectionStack = INIT_GROWLIST;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

BOOL
pParseAppEnvSection (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF InfFile,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    );

//
// Macro expansion definition
//

// None

//
// Code
//


VOID
InitAppModule (
    VOID
    )
{
    g_AppPool = PmCreateNamedPool ("v1 App");
}


VOID
TerminateAppModule (
    VOID
    )
{
    PmDestroyPool (g_AppPool);
    INVALID_POINTER (g_AppPool);
}


UINT
pSafeTcharCount (
    IN      PCTSTR String
    )
{
    if (String) {
        return TcharCount (String);
    }

    return 0;
}


PCTSTR
GetMostSpecificSection (
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfFile,
    IN      PCTSTR BaseSection
    )
{
    PTSTR specificSection;
    MIG_OSVERSIONINFO versionInfo;
    UINT tchars;

    if (!IsmGetOsVersionInfo (PLATFORM_SOURCE, &versionInfo)) {
        return NULL;
    }

    tchars = TcharCount (BaseSection) + 1;
    tchars += pSafeTcharCount (versionInfo.OsTypeName) + 1;
    tchars += pSafeTcharCount (versionInfo.OsMajorVersionName) + 1;
    tchars += pSafeTcharCount (versionInfo.OsMinorVersionName) + 1;

    specificSection = AllocText (tchars);

    if (versionInfo.OsTypeName &&
        versionInfo.OsMajorVersionName &&
        versionInfo.OsMinorVersionName
        ) {
        wsprintf (
            specificSection,
            TEXT("%s.%s.%s.%s"),
            BaseSection,
            versionInfo.OsTypeName,
            versionInfo.OsMajorVersionName,
            versionInfo.OsMinorVersionName
            );

        if (InfFindFirstLine (InfFile, specificSection, NULL, InfStruct)) {
            return specificSection;
        }
    }

    if (versionInfo.OsTypeName &&
        versionInfo.OsMajorVersionName
        ) {
        wsprintf (
            specificSection,
            TEXT("%s.%s.%s"),
            BaseSection,
            versionInfo.OsTypeName,
            versionInfo.OsMajorVersionName
            );

        if (InfFindFirstLine (InfFile, specificSection, NULL, InfStruct)) {
            return specificSection;
        }
    }

    if (versionInfo.OsTypeName) {
        wsprintf (
            specificSection,
            TEXT("%s.%s"),
            BaseSection,
            versionInfo.OsTypeName
            );

        if (InfFindFirstLine (InfFile, specificSection, NULL, InfStruct)) {
            return specificSection;
        }
    }

    FreeText (specificSection);
    return NULL;
}


BOOL
pCheckForRecursion (
    IN      PCTSTR Section
    )
{
    UINT count;
    UINT u;


    count = GlGetSize (&g_SectionStack);
    for (u = 0 ; u < count ; u++) {
        if (StringIMatch (GlGetString (&g_SectionStack, u), Section)) {
            return TRUE;
        }
    }

    return FALSE;
}


VOID
pPushSection (
    IN      PCTSTR Section
    )
{
    GlAppendString (&g_SectionStack, Section);
}


VOID
pPopSection (
    IN      PCTSTR Section
    )
{
    UINT u;

    u = GlGetSize (&g_SectionStack);

    while (u > 0) {
        u--;

        if (StringIMatch (GlGetString (&g_SectionStack, u), Section)) {
            GlDeleteItem (&g_SectionStack, u);
            return;
        }
    }

    MYASSERT (FALSE);
}

UINT
pGetDisplayTypeFromString (
    IN      PCTSTR String
    )
{
    if (!String) {
        return 0;
    }

    if (StringIMatch (String, TEXT("EXT"))) {
        return COMPONENT_EXTENSION;
    }

    if (StringIMatch (String, TEXT("FILE"))) {
        return COMPONENT_FILE;
    }

    if (StringIMatch (String, TEXT("DIR"))) {
        return COMPONENT_FOLDER;
    }

    return 0;
}


BOOL
pAddFilesAndFoldersComponent (
    IN      PCTSTR ComponentString,         OPTIONAL
    IN      PCTSTR TypeString,
    IN      PCTSTR MultiSz,
    IN      UINT MasterGroup,
    IN OUT  PBOOL MarkAsPreferred
    )
{
    MULTISZ_ENUM e;
    TCHAR expandBuffer[MAX_PATH];
    UINT displayType;

    displayType = pGetDisplayTypeFromString (TypeString);
    if (!displayType) {
        LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_FNF_TYPE, TypeString));
        return TRUE;
    }

    if (EnumFirstMultiSz (&e, MultiSz)) {
        do {

            //
            // Expand e.CurrentString
            //

            MappingSearchAndReplaceEx (
                g_EnvMap,
                e.CurrentString,
                expandBuffer,
                0,
                NULL,
                ARRAYSIZE(expandBuffer),
                0,
                NULL,
                NULL
                );

            //
            // Add component
            //

            IsmAddComponentAlias (
                ComponentString,
                MasterGroup,
                expandBuffer,
                displayType,
                FALSE
                );

            if (ComponentString && *MarkAsPreferred) {
                IsmSelectPreferredAlias (ComponentString, expandBuffer, displayType);
                *MarkAsPreferred = FALSE;
            }


        } while (EnumNextMultiSz (&e));

    } else {
        LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_FNF_SPEC, TypeString));
    }

    return TRUE;
}


BOOL
pAddFilesAndFoldersSection (
    IN      HINF InfFile,
    IN      PCTSTR Section,
    IN      UINT MasterGroup,
    IN      BOOL GroupAllUnderSection,
    IN      PBOOL MarkAsPreferred
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR type;
    PCTSTR multiSz;
    BOOL result = TRUE;
    PCTSTR decoratedSection = NULL;

    if (GroupAllUnderSection) {
        decoratedSection = JoinText (TEXT("$"), Section);
    }

    if (InfFindFirstLine (InfFile, Section, NULL, &is)) {
        do {

            InfResetInfStruct (&is);

            type = InfGetStringField (&is, 1);
            multiSz = InfGetMultiSzField (&is, 2);

            result = pAddFilesAndFoldersComponent (
                            decoratedSection,
                            type,
                            multiSz,
                            MasterGroup,
                            MarkAsPreferred
                            );

        } while (result && InfFindNextLine (&is));
    }

    InfCleanUpInfStruct (&is);
    FreeText (decoratedSection);

    if (!result) {
        LOG ((LOG_ERROR, (PCSTR) MSG_SECTION_ERROR, Section));
    }

    return result;
}


BOOL
pAddFilesAndFoldersComponentOrSection (
    IN      HINF InfFile,
    IN      PCTSTR ComponentString,         OPTIONAL
    IN      PCTSTR TypeString,
    IN      PCTSTR MultiSz,
    IN      UINT MasterGroup,
    IN      PBOOL MarkAsPreferred
    )
{
    MULTISZ_ENUM e;
    BOOL result = TRUE;

    if (StringIMatch (TypeString, TEXT("Section"))) {
        if (EnumFirstMultiSz (&e, MultiSz)) {
            do {
                result = pAddFilesAndFoldersSection (InfFile, e.CurrentString, MasterGroup, TRUE, MarkAsPreferred);

            } while (result && EnumNextMultiSz (&e));
        }
    } else {
        result = pAddFilesAndFoldersComponent (ComponentString, TypeString, MultiSz, MasterGroup, MarkAsPreferred);
    }

    return result;
}


BOOL
AddAppSpecificEnvVar (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR AppTag,
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableData             OPTIONAL
    )
{
    TCHAR destBuffer[MAX_TCHAR_PATH * 4];
    PMAPSTRUCT mapArray[1];
    UINT mapCount = 0;
    BOOL updated;
    PTSTR buffer;
    PTSTR p;
    PTSTR q;
    BOOL ignoreLastPercent = FALSE;
    PCTSTR undefText;

    //
    // Verify VariableName is legal
    //

    if (_tcsnextc (VariableName) == TEXT('%')) {
        VariableName++;
        ignoreLastPercent = TRUE;
    }

    if (*VariableName == 0) {
        LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_APP_ENV_VAR));
        return FALSE;
    }

    //
    // Transfer VariableName into %<VariableName>%
    //

    buffer = AllocText (SizeOfString (VariableName) + 2);
    MYASSERT (buffer);
    if (!buffer) {
        return FALSE;
    }

    p = buffer;

    *p++ = TEXT('%');
    *p = 0;
    p = StringCat (p, VariableName);

    if (ignoreLastPercent) {
        q = _tcsdec (buffer, p);
        if (q) {
            if (_tcsnextc (q) == TEXT('%')) {
                p = q;
            }
        }
    }

    *p++ = TEXT('%');
    *p = 0;

    //
    // Add %<VariableName>% -> VariableData to string mapping table
    //

    if (VariableData) {

        if (Platform == PLATFORM_SOURCE) {
            // let's see if this already exists
            mapArray[mapCount] = g_EnvMap;
            updated = MappingMultiTableSearchAndReplaceEx (
                            mapArray,
                            mapCount + 1,
                            buffer,
                            destBuffer,
                            0,
                            NULL,
                            ARRAYSIZE (destBuffer),
                            STRMAP_COMPLETE_MATCH_ONLY,
                            NULL,
                            NULL
                            );
            if (updated) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DUPLICATE_ENV_VAR, buffer));
            }
            IsmSetEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, VariableName, VariableData);
            AddStringMappingPair (g_EnvMap, buffer, VariableData);
        } else {
            MYASSERT (Platform == PLATFORM_DESTINATION);
            // let's see if this already exists
            mapArray[mapCount] = g_DestEnvMap;
            updated = MappingMultiTableSearchAndReplaceEx (
                            mapArray,
                            mapCount + 1,
                            buffer,
                            destBuffer,
                            0,
                            NULL,
                            ARRAYSIZE (destBuffer),
                            STRMAP_COMPLETE_MATCH_ONLY,
                            NULL,
                            NULL
                            );
            if (updated) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DUPLICATE_ENV_VAR, buffer));
            }
            AddRemappingEnvVar (g_DestEnvMap, g_FileNodeFilterMap, NULL, VariableName, VariableData);
        }

    } else {
        LOG ((LOG_INFORMATION, (PCSTR) MSG_UNDEF_APP_VAR, buffer));

        undefText = JoinTextEx (NULL, TEXT("--> "), TEXT(" <--"), buffer, 0, NULL);

        AddStringMappingPair (g_UndefMap, buffer, undefText);

        FreeText (undefText);
    }

    FreeText (buffer);
    return TRUE;
}


BOOL
AppCheckAndLogUndefVariables (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Application,
    IN      PCTSTR UnexpandedString
    )
{
    TCHAR buffer[MAX_TCHAR_PATH * 4];
    PMAPSTRUCT mapArray[1];
    UINT mapCount = 0;
    BOOL updated;

    mapArray[mapCount] = g_UndefMap;

    updated = MappingMultiTableSearchAndReplaceEx (
                    mapArray,
                    mapCount + 1,
                    UnexpandedString,
                    buffer,
                    0,
                    NULL,
                    ARRAYSIZE(buffer),
                    0,
                    NULL,
                    NULL
                    );

    if (updated) {
        if (buffer [0]) {
            LOG ((LOG_INFORMATION, (PCSTR) MSG_UNDEF_BUT_GOOD_VAR, buffer));
        }
    } else {
        if (buffer [0]) {
            LOG ((LOG_INFORMATION, (PCSTR) MSG_ENV_VAR_COULD_BE_BAD, buffer));
        }
    }

    return updated;
}



BOOL
AppSearchAndReplace (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Application,
    IN      PCTSTR UnexpandedString,
    OUT     PTSTR ExpandedString,
    IN      UINT ExpandedStringTchars
    )
{
    PMAPSTRUCT mapArray[1];
    UINT mapCount = 0;
    BOOL updated;
    PCTSTR newString = NULL;
    PCTSTR percent;
    PCTSTR endPercent;
    PCTSTR equals;
    BOOL result = TRUE;

    //
    // Let's expand the incoming string by using the source machine defined environment variables.
    //
    newString = IsmExpandEnvironmentString (Platform, S_SYSENVVAR_GROUP, UnexpandedString, NULL);

    if (Platform == PLATFORM_SOURCE) {
        mapArray[mapCount] = g_EnvMap;
    } else {
        MYASSERT (Platform == PLATFORM_DESTINATION);
        mapArray[mapCount] = g_DestEnvMap;
    }

    updated = MappingMultiTableSearchAndReplaceEx (
                    mapArray,
                    mapCount + 1,
                    newString,
                    ExpandedString,
                    0,
                    NULL,
                    ExpandedStringTchars,
                    0,
                    NULL,
                    NULL
                    );

    if (newString) {
        IsmReleaseMemory (newString);
        newString = NULL;
    }

    //
    // Alert the user to an unexpanded environment variable
    //

    if (!updated) {
        percent = ExpandedString;

        do {
            percent = _tcschr (percent, TEXT('%'));

            if (percent) {
                percent = _tcsinc (percent);
                endPercent = _tcschr (percent, TEXT('%'));

                if (endPercent > percent) {

                    equals = percent;
                    while (equals < endPercent) {
                        if (_tcsnextc (equals) == TEXT('=')) {
                            break;
                        }

                        equals = _tcsinc (equals);
                    }

                    if (equals >= endPercent) {
                        result = FALSE;
                        break;
                    }
                }
            }

        } while (percent && endPercent);
    }

    return result;
}

BOOL
pGetDataFromObjectSpec (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Application,
    IN      PCTSTR InfObjectType,
    IN      PCTSTR InfObjectName,
    IN      PCTSTR ArgumentMultiSz,         OPTIONAL
    OUT     PTSTR OutContentBuffer,         OPTIONAL
    IN      UINT OutContentBufferTchars,
    OUT     PBOOL TestResults               OPTIONAL
    )
{
    ATTRIB_DATA attribData;
    BOOL test;

    MYASSERT (Application);
    MYASSERT (InfObjectType);
    MYASSERT (InfObjectName);

    ZeroMemory (&attribData, sizeof (ATTRIB_DATA));
    attribData.Platform = Platform;
    attribData.ScriptSpecifiedType = InfObjectType;
    attribData.ScriptSpecifiedObject = InfObjectName;
    attribData.ApplicationName = Application;

    if (AllocScriptType (&attribData)) {
        if (g_VcmMode && attribData.ObjectName) {
            if (IsmDoesObjectExist (attribData.ObjectTypeId, attribData.ObjectName)) {
                IsmMakePersistentObject (attribData.ObjectTypeId, attribData.ObjectName);
            }
        }

        if (attribData.ReturnString) {
            if (OutContentBuffer) {
                StringCopyTcharCount (
                    OutContentBuffer,
                    attribData.ReturnString,
                    OutContentBufferTchars
                    );
            }
        }
        if (TestResults) {
            if (ArgumentMultiSz) {
                test = TestAttributes (g_AppPool, ArgumentMultiSz, &attribData);
            } else {
                test = (attribData.ReturnString != NULL);
            }

            *TestResults = test;
        }
        FreeScriptType (&attribData);
    } else {
        return FALSE;
    }
    return TRUE;
}

VOID
pAddPlatformEnvVar (
    IN      HINF InfFile,
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Application,
    IN      PCTSTR Section,
    IN      PCTSTR Variable,
    IN      PCTSTR Type,
    IN      PCTSTR Data,
    IN      PCTSTR ArgMultiSz,
    IN      PINFSTRUCT InfStruct
    )
{
    BOOL exists;
    BOOL validString;
    PCTSTR p;
    PCTSTR end;
    TCHAR variableData[MAX_PATH + 1];
    PCTSTR varDataLong = NULL;

    ZeroMemory (&variableData, sizeof (variableData));

    //
    // Variable data is specified in the object represented by <data>
    //

    if (!pGetDataFromObjectSpec (
            Platform,
            Application,
            Type,
            Data,
            ArgMultiSz,
            variableData,
            ARRAYSIZE(variableData) - 1,
            &exists
            )) {

        switch (GetLastError()) {

        case ERROR_INVALID_DATA:
            LOG ((
                LOG_WARNING,
                (PCSTR) MSG_DETECT_DATA_OBJECT_IS_BAD,
                Data,
                Variable
                ));
            InfLogContext (LOG_WARNING, InfFile, InfStruct);
            break;

        case ERROR_INVALID_DATATYPE:
            LOG ((
                LOG_ERROR,
                (PCSTR) MSG_DETECT_DATA_TYPE_IS_BAD,
                Type,
                Variable
                ));
            InfLogContext (LOG_ERROR, InfFile, InfStruct);
            break;
        }
    } else {
        validString = FALSE;

        if (exists) {

            p = variableData;
            end = variableData + MAX_PATH;

            while (p < end) {
                if (_tcsnextc (p) < 32) {
                    break;
                }

                p = _tcsinc (p);
            }

            if (*p == 0 && p < end && p > variableData) {
                validString = TRUE;
            }
        }

        if (validString) {
            if (IsValidFileSpec (variableData)) {
                varDataLong = BfGetLongFileName (variableData);
            } else {
                varDataLong = variableData;
            }
        }

        if (!validString && exists) {
            LOG ((LOG_INFORMATION, (PCSTR) MSG_DATA_IS_NOT_A_STRING, Variable));
        } else {
            LOG_IF ((
                validString,
                LOG_INFORMATION,
                (PCSTR) MSG_APP_ENV_DEF_INFO,
                Variable,
                Type,
                Data,
                variableData
                ));

            LOG_IF ((
                !validString,
                LOG_INFORMATION,
                (PCSTR) MSG_NUL_APP_ENV_DEF_INFO,
                Variable,
                Type,
                Data
                ));

            AddAppSpecificEnvVar (
                Platform,
                Application,
                Variable,
                validString ? varDataLong : NULL
                );

        }

        if (varDataLong && (varDataLong != variableData)) {
            FreePathString (varDataLong);
            varDataLong = NULL;
        }
    }
}


PCTSTR
pProcessArgEnvironmentVars (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Application,
    IN      PCTSTR Args,
    IN      BOOL MultiSz,
    OUT     PGROWBUFFER UpdatedData
    )
{
    MULTISZ_ENUM e;
    TCHAR buffer[MAX_EXPANDED_STRING];

    UpdatedData->End = 0;

    if (MultiSz) {
        if (EnumFirstMultiSz (&e, Args)) {

            do {

                AppSearchAndReplace (
                    Platform,
                    Application,
                    e.CurrentString,
                    buffer,
                    MAX_EXPANDED_STRING
                    );

                GbMultiSzAppend (UpdatedData, buffer);

            } while (EnumNextMultiSz (&e));
        }
    } else {
        AppSearchAndReplace (
            Platform,
            Application,
            Args,
            buffer,
            MAX_EXPANDED_STRING
            );

        GbMultiSzAppend (UpdatedData, buffer);
    }

    return (PCTSTR) UpdatedData->Buf;
}


BOOL
pParseAppEnvSectionWorker (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfFile,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    )
{
    BOOL result = FALSE;
    PCTSTR variable;
    PCTSTR type;
    PCTSTR data;
    PCTSTR args;
    PCTSTR updatedData;
    PCTSTR updatedArgs;
    PTSTR lastChar;
    GROWBUFFER dataBuf = INIT_GROWBUFFER;
    GROWBUFFER argBuf = INIT_GROWBUFFER;

    //
    // Section must not be on the stack
    //

    if (pCheckForRecursion (Section)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_ENV_SECTION_RECURSION, Section));
        // Assume success
        return TRUE;
    }

    //
    // Format is
    //
    // <variable> = <type>, <data> [, <arguments>]
    //
    // <type> specifies one of the supported parse types (see parse.c),
    //        or "Text" when <data> is arbitrary text
    //
    // <data> is specific to <type>
    //
    // <arguments> specify qualifiers.  If they evaluate to FALSE, then
    //             the variable is not set.
    //

    __try {
        if (InfFindFirstLine (InfFile, Section, NULL, InfStruct)) {
            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                InfResetInfStruct (InfStruct);

                variable = InfGetStringField (InfStruct, 0);
                type = InfGetStringField (InfStruct, 1);

                if (variable && StringIMatch (variable, TEXT("ProcessSection"))) {
                    if (type && *type) {
                        pPushSection (Section);
                        result = pParseAppEnvSection (Platform, InfFile, Application, type);
                        pPopSection (Section);

                        if (!result) {
                            __leave;
                        }
                    }
                }

                data = InfGetStringField (InfStruct, 2);
                args = InfGetMultiSzField (InfStruct, 3);

                if (variable) {
                    //
                    // Remove %s from the variable name
                    //

                    if (_tcsnextc (variable) == TEXT('%')) {
                        lastChar = _tcsdec2 (variable, GetEndOfString (variable));

                        if (lastChar > variable && _tcsnextc (lastChar) == TEXT('%')) {
                            variable = _tcsinc (variable);
                            *lastChar = 0;
                        }
                    }
                }

                if (!variable || !(*variable) || !type || !(*type) || !data) {
                    LOG ((LOG_WARNING, (PCSTR) MSG_GARBAGE_LINE_IN_INF, Section));
                    InfLogContext (LOG_WARNING, InfFile, InfStruct);
                    continue;
                }

                //
                // Update all environment variables in data and args
                //

                updatedData = pProcessArgEnvironmentVars (
                                    Platform,
                                    Application,
                                    data,
                                    FALSE,
                                    &dataBuf
                                    );

                if (args && *args) {
                    updatedArgs = pProcessArgEnvironmentVars (
                                        Platform,
                                        Application,
                                        args,
                                        TRUE,
                                        &argBuf
                                        );
                } else {
                    updatedArgs = NULL;
                }

                //
                // Add the app-specific environment variables.  If we are
                // on the destination, add both a source and destination
                // value (as they might be different).
                //

                pAddPlatformEnvVar (
                    InfFile,
                    Platform,
                    Application,
                    Section,
                    variable,
                    type,
                    updatedData,
                    updatedArgs,
                    InfStruct
                    );

            } while (InfFindNextLine (InfStruct));
        }

        result = TRUE;

    }
    __finally {
        GbFree (&dataBuf);
        GbFree (&argBuf);
    }

    return result;
}


BOOL
pParseAppEnvSection (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF InfFile,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    )
{
    PCTSTR osSpecificSection;
    BOOL b;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;

    b = pParseAppEnvSectionWorker (Platform, &is, InfFile, Application, Section);

    if (b) {
        osSpecificSection = GetMostSpecificSection (&is, InfFile, Section);
        if (osSpecificSection) {
            b = pParseAppEnvSectionWorker (Platform, &is, InfFile, Application, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    InfCleanUpInfStruct (&is);
    return b;
}


BOOL
pParseAppDetectSectionPart (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfFile,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    )
{
    BOOL result = TRUE;
    PCTSTR type;
    PCTSTR data;
    PCTSTR args;
    GROWBUFFER dataBuf = INIT_GROWBUFFER;
    GROWBUFFER argBuf = INIT_GROWBUFFER;
    PCTSTR updatedData;
    PCTSTR updatedArgs;
    PTSTR buffer;
    BOOL test;

    //
    // Section must not be on the stack
    //

    if (pCheckForRecursion (Section)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_DETECT_SECTION_RECURSION, Section));
        // Assume successful detection
        return TRUE;
    }

    //
    // Format is
    //
    // <type>, <data> [, <arguments>]
    //
    // <type> specifies one of the supported parse types (see parse.c),
    //        and may include environment variables specified in the
    //        app's [App.Environment] section.
    //
    // <data> is specific to <type>.  If <data> begins with a !, then the
    //        existence of the object fails the detect test
    //
    // <arguments> specify qualifiers
    //

    __try {

        buffer = AllocText (MAX_EXPANDED_STRING);      // arbitrary big text buffer

        if (InfFindFirstLine (InfFile, Section, NULL, InfStruct)) {

            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                InfResetInfStruct (InfStruct);

                //
                // Obtain the line data
                //

                type = InfGetStringField (InfStruct, 0);

                if (type && StringIMatch (type, TEXT("ProcessSection"))) {
                    data = InfGetStringField (InfStruct, 1);
                    if (data && *data) {
                        pPushSection (Section);
                        result = ParseAppDetectSection (Platform, InfFile, Application, data);
                        pPopSection (Section);
                        continue;
                    }
                }

                type = InfGetStringField (InfStruct, 1);
                data = InfGetStringField (InfStruct, 2);
                args = InfGetMultiSzField (InfStruct, 3);

                if (!type || !data) {
                    LOG ((LOG_WARNING, (PCSTR) MSG_GARBAGE_LINE_IN_INF, Section));
                    InfLogContext (LOG_WARNING, InfFile, InfStruct);
                    continue;
                }

                //
                // Update all environment variables in data and args
                //

                updatedData = pProcessArgEnvironmentVars (
                                    PLATFORM_SOURCE,
                                    Application,
                                    data,
                                    FALSE,
                                    &dataBuf
                                    );

                if (args && *args) {
                    updatedArgs = pProcessArgEnvironmentVars (
                                        PLATFORM_SOURCE,
                                        Application,
                                        args,
                                        TRUE,
                                        &argBuf
                                        );
                } else {
                    updatedArgs = NULL;
                }

                //
                // Now try to obtain the data
                //

                if (pGetDataFromObjectSpec (
                        Platform,
                        Application,
                        type,
                        updatedData,
                        updatedArgs,
                        NULL,
                        0,
                        &test
                        )) {

                    if (test) {
                        LOG ((LOG_INFORMATION, (PCSTR) MSG_DETECT_INFO, type, updatedData));
                    } else {
                        LOG ((LOG_INFORMATION, (PCSTR) MSG_NOT_DETECT_INFO, type, updatedData));
                        result = FALSE;
                        break;
                    }
                } else {
                    result = FALSE;
                    break;
                }

            } while (result && InfFindNextLine (InfStruct));
        }
    }
    __finally {
        FreeText (buffer);
        GbFree (&dataBuf);
        GbFree (&argBuf);
    }

    return result;
}


BOOL
pParseOsAppDetectSection (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfFile,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    )
{
    PCTSTR osSpecificSection;
    BOOL b;

    b = pParseAppDetectSectionPart (Platform, InfStruct, InfFile, Application, Section);

    if (b) {
        osSpecificSection = GetMostSpecificSection (InfStruct, InfFile, Section);
        if (osSpecificSection) {
            b = pParseAppDetectSectionPart (Platform, InfStruct, InfFile, Application, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    return b;
}


BOOL
ParseAppDetectSection (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF InfFile,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    TCHAR number[32];
    PCTSTR orSection;
    UINT count;
    BOOL orSectionProcessed = FALSE;
    BOOL detected = FALSE;
    BOOL done = FALSE;

    //
    // Process all "or" sections
    //

    count = 0;

    do {

        count++;
        wsprintf (number, TEXT(".%u"), count);

        orSection = JoinText (Section, number);

        if (orSection) {

            if (InfFindFirstLine (InfFile, orSection, NULL, &is)) {

                orSectionProcessed = TRUE;

                if (pParseOsAppDetectSection (Platform, &is, InfFile, Application, orSection)) {
                    detected = TRUE;
                    done = TRUE;
                }

            } else {
                done = TRUE;
            }

            FreeText (orSection);
            INVALID_POINTER (orSection);

        } else {
            done = TRUE;
        }

    } while (!done);

    //
    // If no "or" sections, process Section itself
    //

    if (!orSectionProcessed) {

        detected = pParseOsAppDetectSection (Platform, &is, InfFile, Application, Section);
    }

    InfCleanUpInfStruct (&is);

    return detected;
}


BOOL
pDoesAppSectionExists (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF InfFile,
    IN      PCTSTR Application
    )
{
    PCTSTR osSpecificSection;
    BOOL b;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;

    b = InfFindFirstLine (InfFile, Application, NULL, &is);

    if (!b) {
        osSpecificSection = GetMostSpecificSection (&is, InfFile, Application);

        if (osSpecificSection) {
            b = TRUE;
            FreeText (osSpecificSection);
        }
    }

    InfCleanUpInfStruct (&is);
    return b;
}

BOOL
pParseOneDestInstruction (
    IN      HINF InfHandle,
    IN      PCTSTR Type,
    IN      PCTSTR SectionMultiSz,
    IN      PINFSTRUCT InfStruct,
    IN      PCTSTR Application          OPTIONAL
    )
{
    MULTISZ_ENUM e;
    BOOL result = TRUE;

    //
    // First thing: look for nested sections
    //
    if (StringIMatch (Type, TEXT("ProcessSection"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {
            do {
                result = result & ParseOneApplication (
                                    PLATFORM_DESTINATION,
                                    InfHandle,
                                    Application,
                                    FALSE,
                                    0,
                                    e.CurrentString,
                                    NULL,
                                    NULL,
                                    NULL
                                    );
            } while (EnumNextMultiSz (&e));
        }
        return result;
    }

    return TRUE;
}

BOOL
pParseDestInfInstructionsWorker (
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfHandle,
    IN      PCTSTR Application,     OPTIONAL
    IN      PCTSTR Section
    )
{
    PCTSTR type;
    PCTSTR sections;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    BOOL result = TRUE;

    if (InfFindFirstLine (InfHandle, Section, NULL, InfStruct)) {
        do {

            if (IsmCheckCancel()) {
                result = FALSE;
                break;
            }

            InfResetInfStruct (InfStruct);

            type = InfGetStringField (InfStruct, 0);
            sections = InfGetMultiSzField (InfStruct, 1);

            if (!type || !sections) {
                LOG ((LOG_WARNING, (PCSTR) MSG_BAD_INF_LINE, Section));
                InfLogContext (LOG_WARNING, InfHandle, InfStruct);
                continue;
            }

            result = pParseOneDestInstruction (InfHandle, type, sections, InfStruct, Application);

        } while (result && InfFindNextLine (InfStruct));
    }

    InfCleanUpInfStruct (InfStruct);

    GbFree (&multiSz);

    return result;
}

BOOL
ParseDestInfInstructions (
    IN      HINF InfHandle,
    IN      PCTSTR Application,     OPTIONAL
    IN      PCTSTR Section
    )
{
    PCTSTR osSpecificSection;
    BOOL b;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PTSTR instrSection;

    b = pParseDestInfInstructionsWorker (&is, InfHandle, Application, Section);

    if (b) {
        osSpecificSection = GetMostSpecificSection (&is, InfHandle, Section);

        if (osSpecificSection) {
            b = pParseDestInfInstructionsWorker (&is, InfHandle, Application, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    InfCleanUpInfStruct (&is);

    return b;
}

BOOL
ParseOneApplication (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      BOOL PreParse,
    IN      UINT MasterGroup,
    IN      PCTSTR Application,
    IN      PCTSTR LocSection,
    IN      PCTSTR AliasType,
    IN      PCTSTR MultiSz
    )
{
    PCTSTR appSection = NULL;
    BOOL detected = FALSE;
    PCTSTR appEnvVar;
    PCTSTR decoratedSection;
    BOOL componentized = FALSE;
    BOOL executeSection = FALSE;
    BOOL markAsPreferred;

    __try {
        if (LocSection || AliasType) {
            componentized = TRUE;
        } else {
            componentized = FALSE;
        }

        if (!Application) {
            __leave;
        }

        decoratedSection = JoinText (TEXT("$"), Application);

        if (Platform == PLATFORM_SOURCE) {

            //
            // locSection exists for all applications we want to send to
            // the UI for approval. PreParse builds the list of apps we
            // send to the UI. Only do detection if this is PreParsing
            // localized apps, or not preparsing non-localized apps
            //

            if ((PreParse && componentized) ||
                (!PreParse && !componentized)
                ) {

                appSection = JoinText (Application, TEXT(".Environment"));
                if (!pParseAppEnvSection (PLATFORM_SOURCE, Inf, Application, appSection)) {
                    __leave;
                }
                FreeText (appSection);
                appSection = NULL;
                GlFree (&g_SectionStack);

                appSection = JoinText (Application, TEXT(".Detect"));
                detected = ParseAppDetectSection (Platform, Inf, Application, appSection);
                FreeText (appSection);
                appSection = NULL;
                GlFree (&g_SectionStack);

                if (!detected && pDoesAppSectionExists (Platform, Inf, Application)) {
                    detected = TRUE;
                } else if (!detected) {
                    LOG ((LOG_INFORMATION, (PCSTR) MSG_APP_NOT_DETECT_INFO, Application));
                } else {
                    LOG ((LOG_INFORMATION, (PCSTR) MSG_APP_DETECT_INFO, Application));
                    appEnvVar = JoinTextEx (NULL, Section, Application, TEXT("."), 0, NULL);
                    IsmSetEnvironmentFlag (PLATFORM_SOURCE, NULL, appEnvVar);
                    FreeText (appEnvVar);
                }

                if (componentized && detected) {

                    //
                    // we should put it in the selection list
                    //

                    if (LocSection) {
                        IsmAddComponentAlias (
                            decoratedSection,
                            MasterGroup,
                            LocSection,
                            COMPONENT_NAME,
                            FALSE
                            );

                        IsmSelectPreferredAlias (decoratedSection, LocSection, COMPONENT_NAME);
                    }

                    if (AliasType) {
                        markAsPreferred = (LocSection == NULL);
                        pAddFilesAndFoldersComponentOrSection (
                            Inf,
                            decoratedSection,
                            AliasType,
                            MultiSz,
                            MasterGroup,
                            &markAsPreferred
                            );
                    }
                }
                executeSection = (!PreParse) && detected;
            } else {
                executeSection = (!PreParse) && IsmIsComponentSelected (decoratedSection, 0);
            }

            // Now actually load the application instructions if it's not preparsing
            if (executeSection) {

                appSection = DuplicateText (Application);
                if (!ParseInfInstructions (Inf, Application, appSection)) {
                    __leave;
                }
                FreeText (appSection);
                appSection = NULL;
                appEnvVar = JoinTextEx (NULL, Section, Application, TEXT("."), 0, NULL);
                if (IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, appEnvVar)) {
                    appSection = JoinText (Application, TEXT(".Instructions"));
                    if (!ParseInfInstructions (Inf, Application, appSection)) {
                        __leave;
                    }
                    FreeText (appSection);
                    appSection = NULL;
                }
                FreeText (appEnvVar);
            } else {
                if (!PreParse) {
                    appEnvVar = JoinTextEx (NULL, Section, Application, TEXT("."), 0, NULL);
                    IsmDeleteEnvironmentVariable (PLATFORM_SOURCE, NULL, appEnvVar);
                    FreeText (appEnvVar);
                }
            }
        } else {
            MYASSERT (Platform == PLATFORM_DESTINATION);

            appSection = JoinText (Application, TEXT(".Environment"));
            if (!pParseAppEnvSection (PLATFORM_DESTINATION, Inf, Application, appSection)) {
                __leave;
            }
            FreeText (appSection);
            appSection = NULL;
            GlFree (&g_SectionStack);

            appEnvVar = JoinTextEx (NULL, Section, Application, TEXT("."), 0, NULL);
            if (IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, appEnvVar)) {
                appSection = DuplicateText (Application);
                if (!ParseDestInfInstructions (Inf, Application, appSection)) {
                    __leave;
                }
                FreeText (appSection);
                appSection = NULL;
                appSection = JoinText (Application, TEXT(".Instructions"));
                if (!ParseDestInfInstructions (Inf, Application, appSection)) {
                    __leave;
                }
                FreeText (appSection);
                appSection = NULL;
            }
            FreeText (appEnvVar);
        }

        FreeText (decoratedSection);
        decoratedSection = NULL;
    }
    __finally {
        if (appSection) {
            FreeText (appSection);
            appSection = NULL;
        }
        GlFree (&g_SectionStack);
    }

    return TRUE;
}

BOOL
ParseApplications (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      BOOL PreParse,
    IN      UINT MasterGroup
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR application;
    BOOL result = FALSE;
    PCTSTR locSection;
    PCTSTR aliasType;
    PCTSTR multiSz;

    __try {
        if (InfFindFirstLine (Inf, Section, NULL, &is)) {
            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                InfResetInfStruct (&is);

                application = InfGetStringField (&is, 1);
                locSection = InfGetStringField (&is, 2);
                aliasType = InfGetStringField (&is, 3);
                multiSz = InfGetMultiSzField (&is, 4);

                if (application && !application[0]) {
                    application = NULL;
                }

                if (locSection && !locSection[0]) {
                    locSection = NULL;
                }

                if (aliasType && !aliasType[0]) {
                    aliasType = NULL;
                }

                if (multiSz && !multiSz[0]) {
                    multiSz = NULL;
                }

                if (!aliasType || !multiSz) {
                    aliasType = NULL;
                    multiSz = NULL;
                }

                ParseOneApplication (
                    Platform,
                    Inf,
                    Section,
                    PreParse,
                    MasterGroup,
                    application,
                    locSection,
                    aliasType,
                    multiSz
                    );

            } while (InfFindNextLine (&is));

        }

        result = TRUE;

    } __finally {
        InfCleanUpInfStruct (&is);
    }

    return result;
}

BOOL
ProcessFilesAndFolders (
    IN      HINF InfHandle,
    IN      PCTSTR Section,
    IN      BOOL PreParse
    )
{
    BOOL b = TRUE;
    BOOL markAsPreferred = TRUE;

    if (PreParse) {
        b = pAddFilesAndFoldersSection (InfHandle, Section, MASTERGROUP_FILES_AND_FOLDERS, FALSE, &markAsPreferred);
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\opm.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    opm.c

Abstract:

    Implements the data apply portion of scanstate v1 compatiblity.

Author:

    Jim Schmidt (jimschm) 12-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"
#include <sddl.h>

#define DBG_V1  "v1"

//
// Strings
//

#define S_RENAMEEX_START_CHAR TEXT('<')
#define S_RENAMEEX_END_CHAR   TEXT('>')

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

MIG_OPERATIONID g_V1MoveExOp;
MIG_OPERATIONID g_V1MoveOp;
MIG_OPERATIONID g_GeneralMoveOp;
MIG_OPERATIONID g_DeleteOp;
MIG_OPERATIONID g_RenameEx;
MIG_OPERATIONID g_PartMoveOp;
PMAPSTRUCT g_RegNodeFilterMap;
PMAPSTRUCT g_RegLeafFilterMap;
PMAPSTRUCT g_FileNodeFilterMap;
PMAPSTRUCT g_FileLeafFilterMap;
PMAPSTRUCT g_DestEnvMap;
HASHTABLE g_RegCollisionDestTable;
HASHTABLE g_RegCollisionSrcTable;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

OPMINITIALIZE ScriptOpmInitialize;
OPMFILTERCALLBACK FilterV1MoveEx;
OPMFILTERCALLBACK FilterV1Move;
OPMFILTERCALLBACK FilterMove;
OPMAPPLYCALLBACK DoRegAutoFilter;
OPMFILTERCALLBACK FilterRegAutoFilter;
OPMFILTERCALLBACK FilterFileAutoFilter;
OPMFILTERCALLBACK FilterDelete;
OPMAPPLYCALLBACK DoFixDefaultIcon;
OPMFILTERCALLBACK FilterRenameExFilter;
OPMFILTERCALLBACK FilterPartitionMove;
OPMAPPLYCALLBACK DoDestAddObject;

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pParseInfForRemapEnvVar (
    IN      HINF InfHandle
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR envVar;
    PTSTR envValue;
    UINT sizeNeeded;
    BOOL result = FALSE;

    __try {

        // on all systems, process "Delete Destination Settings"
        if (InfFindFirstLine (InfHandle, TEXT("RemapEnvVar"), NULL, &is)) {
            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                envVar = InfGetStringField (&is, 1);

                if (!envVar) {
                    LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_REG_SPEC));
                    continue;
                }

                if (!IsmGetEnvironmentString (
                        PLATFORM_DESTINATION,
                        S_SYSENVVAR_GROUP,
                        envVar,
                        NULL,
                        0,
                        &sizeNeeded
                        )) {
                    continue;
                }

                envValue = AllocPathString (sizeNeeded);

                if (!IsmGetEnvironmentString (
                        PLATFORM_DESTINATION,
                        S_SYSENVVAR_GROUP,
                        envVar,
                        envValue,
                        sizeNeeded,
                        NULL
                        )) {
                    FreePathString (envValue);
                    continue;
                }

                AddRemappingEnvVar (g_DestEnvMap, g_FileNodeFilterMap, NULL, envVar, envValue);

                FreePathString (envValue);
                envValue = NULL;

            } while (InfFindNextLine (&is));
        }

        result = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (&is);
    }

    return result;
}

BOOL
pParseRemapEnvVar (
    VOID
    )
{
    PTSTR multiSz = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_TYPE dataType;
    BOOL result = TRUE;

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {
        if (!pParseInfForRemapEnvVar (infHandle)) {
            result = FALSE;
        }
    } else {

        if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, NULL, 0, &sizeNeeded, NULL)) {
            return TRUE;        // no INF files specified
        }

        __try {
            multiSz = AllocText (sizeNeeded);
            if (!multiSz) {
                result = FALSE;
                __leave;
            }

            if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, (PBYTE) multiSz, sizeNeeded, NULL, NULL)) {
                result = FALSE;
                __leave;
            }

            if (EnumFirstMultiSz (&e, multiSz)) {

                do {
                    infHandle = InfOpenInfFile (e.CurrentString);
                    if (infHandle != INVALID_HANDLE_VALUE) {
                        if (!pParseInfForRemapEnvVar (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            result = FALSE;
                            __leave;
                        }

                        InfCloseInfFile (infHandle);
                        infHandle = INVALID_HANDLE_VALUE;
                    } else {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_INF, e.CurrentString));
                    }
                } while (EnumNextMultiSz (&e));

            }
        }
        __finally {
            if (multiSz) {
                FreeText (multiSz);
                multiSz = NULL;
            }
        }
    }

    return result;
}

VOID
pOutlookClearConvKeys (
    VOID
    )
{
    MIG_CONTENT objectContent;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern = NULL;

    // This registry tree was needed only for conversion data.  We don't want to
    // write them to the destination, so clear the apply attribute on each item.

    if ((IsmIsComponentSelected (S_OUTLOOK9798_COMPONENT, 0) &&
         IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OUTLOOK9798_APPDETECT)) ||
        (IsmIsComponentSelected (S_OFFICE_COMPONENT, 0) &&
         IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OFFICE9798_APPDETECT))) {

        enumPattern = IsmCreateSimpleObjectPattern (
                          TEXT("HKLM\\Software\\Microsoft\\MS Setup (ACME)\\Table Files"),
                          TRUE,
                          NULL,
                          TRUE);

        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
            do {
               IsmClearApplyOnObject (g_RegType | PLATFORM_SOURCE, objectEnum.ObjectName);
            } while (IsmEnumNextObject (&objectEnum));
        }
        IsmDestroyObjectHandle (enumPattern);
    }
}

BOOL
WINAPI
ScriptOpmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    //
    // Get file and registry types
    //
    g_FileType = MIG_FILE_TYPE;
    g_RegType = MIG_REGISTRY_TYPE;

    //
    // Get attribute and operation types
    //
    g_V1MoveExOp = IsmRegisterOperation (S_OPERATION_V1_FILEMOVEEX, TRUE);
    g_V1MoveOp = IsmRegisterOperation (S_OPERATION_V1_FILEMOVE, TRUE);
    g_GeneralMoveOp = IsmRegisterOperation (S_OPERATION_MOVE, FALSE);
    g_DeleteOp = IsmRegisterOperation (S_OPERATION_DELETE, FALSE);
    g_DefaultIconOp = IsmRegisterOperation (S_OPERATION_DEFICON_FIXCONTENT, FALSE);
    g_DefaultIconData = IsmRegisterProperty (S_V1PROP_ICONDATA, FALSE);
    g_FileCollPatternData = IsmRegisterProperty (S_V1PROP_FILECOLLPATTERN, FALSE);
    g_RenameExOp = IsmRegisterOperation (S_OPERATION_ENHANCED_MOVE, FALSE);
    g_PartMoveOp = IsmRegisterOperation (S_OPERATION_PARTITION_MOVE, TRUE);
    g_DestAddObject = IsmRegisterOperation (S_OPERATION_DESTADDOBJ, FALSE);
    g_RegAutoFilterOp = IsmRegisterOperation (S_OPERATION_REG_AUTO_FILTER, FALSE);

    //
    // Register operation callbacks
    //

    // FYI: Filter callbacks adjust the name of the object
    //      Apply callbacks adjust the content of the object

    // global operation callbacks
    IsmRegisterGlobalApplyCallback (g_RegType | PLATFORM_SOURCE, TEXT("AutoFilter"), DoRegAutoFilter);
    IsmRegisterGlobalFilterCallback (g_RegType | PLATFORM_SOURCE, TEXT("AutoFilter"), FilterRegAutoFilter, TRUE, FALSE);
    IsmRegisterGlobalFilterCallback (g_FileType | PLATFORM_SOURCE, TEXT("AutoFilter"), FilterFileAutoFilter, TRUE, TRUE);

    // operation-specific callbacks
    IsmRegisterOperationFilterCallback (g_V1MoveExOp, FilterV1MoveEx, TRUE, TRUE, FALSE);
    IsmRegisterOperationFilterCallback (g_V1MoveOp, FilterV1Move, TRUE, TRUE, FALSE);
    IsmRegisterOperationFilterCallback (g_GeneralMoveOp, FilterMove, TRUE, TRUE, FALSE);
    IsmRegisterOperationFilterCallback (g_DeleteOp, FilterDelete, FALSE, TRUE, FALSE);
    IsmRegisterOperationApplyCallback (g_DefaultIconOp, DoFixDefaultIcon, TRUE);
    IsmRegisterOperationFilterCallback (g_RenameExOp, FilterRenameExFilter, TRUE, TRUE, FALSE);
    IsmRegisterOperationFilterCallback (g_PartMoveOp, FilterPartitionMove, TRUE, TRUE, FALSE);
    IsmRegisterOperationApplyCallback (g_DestAddObject, DoDestAddObject, TRUE);
    IsmRegisterOperationApplyCallback (g_RegAutoFilterOp, DoRegAutoFilter, TRUE);

    //
    // Call special conversion entry point
    //
    InitSpecialConversion (PLATFORM_DESTINATION);
    InitSpecialRename (PLATFORM_DESTINATION);

    g_RegNodeFilterMap = CreateStringMapping();

    g_FileNodeFilterMap = CreateStringMapping();

    g_DestEnvMap = CreateStringMapping();

    SetIsmEnvironmentFromPhysicalMachine (g_DestEnvMap, FALSE, NULL);
    SetIsmEnvironmentFromPhysicalMachine (g_FileNodeFilterMap, TRUE, NULL);

    pParseRemapEnvVar ();

    g_RegLeafFilterMap = CreateStringMapping();

    g_FileLeafFilterMap = CreateStringMapping();

    if ((!g_EnvMap) || (!g_RevEnvMap) || (!g_UndefMap)) {
        g_EnvMap = CreateStringMapping();
        g_UndefMap = CreateStringMapping();
        g_RevEnvMap = CreateStringMapping();
        SetIsmEnvironmentFromVirtualMachine (g_EnvMap, g_RevEnvMap, g_UndefMap);
    }

    g_RegCollisionDestTable = HtAllocWithData (sizeof (MIG_OBJECTSTRINGHANDLE));
    g_RegCollisionSrcTable = HtAllocWithData (sizeof (HASHITEM));

    InitRestoreCallback (PLATFORM_DESTINATION);

    pOutlookClearConvKeys();

    return TRUE;
}


BOOL
pDoesDifferentRegExist (
    IN      MIG_OBJECTSTRINGHANDLE DestName
    )
{
    BOOL result = FALSE;
    MIG_CONTENT content;

    if (IsmAcquireObject (g_RegType|PLATFORM_DESTINATION, DestName, &content)) {
        IsmReleaseObject (&content);
        result = TRUE;
    } else if (HtFindString (g_RegCollisionDestTable, DestName)) {
        result = TRUE;
    }

    return result;
}


BOOL
WINAPI
FilterV1MoveEx (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR orgSrcNode = NULL;
    PCTSTR orgSrcLeaf = NULL;
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PCTSTR destNode = NULL;
    PCTSTR destLeaf = NULL;
    PCTSTR newDestNode = NULL;
    PCTSTR destNodePtr = NULL;
    // NTRAID#NTBUG9-153274-2000/08/01-jimschm Static buffer size
    TCHAR expDestNode[MAX_PATH * 4];
    TCHAR expDestLeaf[MAX_PATH * 4];
    CHARTYPE ch;
    MIG_OBJECTSTRINGHANDLE destHandle;

    __try {

        //
        // For v1 compatibility, we support only a transformation from
        // original source to inf-specified destination.  Chaining of
        // operations is not allowed (these are restrictions caused by the
        // existing INF syntax).
        //

        if (!DestinationOperationData) {
            DEBUGMSG ((DBG_ERROR, "Missing dest data in FilterV1MoveEx"));
            __leave;
        }

        if ((InputData->CurrentObject.ObjectTypeId & (~PLATFORM_MASK)) != g_FileType) {
            DEBUGMSG ((DBG_ERROR, "Unexpected object type in FilterV1MoveEx"));
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (
                DestinationOperationData->String,
                &destNode,
                &destLeaf
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split dest object in FilterV1MoveEx"));
            __leave;
        }

        MYASSERT (destNode);

        if (!destNode) {
            DEBUGMSG ((DBG_ERROR, "Destination spec must be a node"));
            __leave;
        }

        //
        // Split the source object into node and leaf
        //

        if (!IsmCreateObjectStringsFromHandle (
                InputData->CurrentObject.ObjectName,
                &srcNode,
                &srcLeaf
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split v1 src object in FilterV1MoveEx"));
            __leave;
        }

        if (!srcNode) {
            MYASSERT (FALSE);
            __leave;
        }

        //
        // If not a local path, do not process
        //

        if (!_istalpha ((CHARTYPE) _tcsnextc (srcNode)) ||
            _tcsnextc (srcNode + 1) != TEXT(':')
            ) {
            DEBUGMSG ((DBG_WARNING, "Ignoring %s\\%s because it does not have a drive spec", srcNode, srcLeaf));
            __leave;
        }

        ch = (CHARTYPE) _tcsnextc (srcNode + 2);

        if (ch && ch != TEXT('\\')) {
            DEBUGMSG ((DBG_WARNING, "Ignoring %s\\%s because it does not have a drive spec (2)", srcNode, srcLeaf));
            __leave;
        }

        // let's see if the current name has something in common
        // with SourceOperationData->String. If so, get the extra part
        // and add it to the destNode

        //
        // Split the original rule source object into node and leaf
        //
        if (SourceOperationData) {

            if (IsmCreateObjectStringsFromHandle (
                    SourceOperationData->String,
                    &orgSrcNode,
                    &orgSrcLeaf
                    )) {
                if (orgSrcNode) {
                    if (StringIPrefix (srcNode, orgSrcNode)) {
                        destNodePtr = srcNode + TcharCount (orgSrcNode);
                        if (destNodePtr && *destNodePtr) {
                            if (_tcsnextc (destNodePtr) == TEXT('\\')) {
                                destNodePtr = _tcsinc (destNodePtr);
                            }
                            if (destNodePtr) {
                                newDestNode = JoinPaths (destNode, destNodePtr);
                            }
                        }
                    }
                }
            }
        }

        if (!newDestNode) {
            newDestNode = destNode;
        }

        //
        // Expand the destination
        //
        MappingSearchAndReplaceEx (
            g_DestEnvMap,
            newDestNode,
            expDestNode,
            0,
            NULL,
            MAX_PATH,
            STRMAP_FIRST_CHAR_MUST_MATCH,
            NULL,
            NULL
            );

        if (destLeaf) {
            MappingSearchAndReplaceEx (
                g_DestEnvMap,
                destLeaf,
                expDestLeaf,
                0,
                NULL,
                MAX_PATH,
                STRMAP_FIRST_CHAR_MUST_MATCH,
                NULL,
                NULL
                );
        }

        if (destLeaf) {
            destHandle = IsmCreateObjectHandle (expDestNode, expDestLeaf);
        } else {
            destHandle = IsmCreateObjectHandle (expDestNode, srcLeaf);
        }

        if (destHandle) {
            OutputData->NewObject.ObjectName = destHandle;
        }
    }
    __finally {
        if (newDestNode && (newDestNode != destNode)) {
            FreePathString (newDestNode);
            newDestNode = NULL;
        }
        IsmDestroyObjectString (orgSrcNode);
        IsmDestroyObjectString (orgSrcLeaf);
        IsmDestroyObjectString (destNode);
        IsmDestroyObjectString (destLeaf);
        IsmDestroyObjectString (srcNode);
        IsmDestroyObjectString (srcLeaf);
    }

    return TRUE;
}


BOOL
WINAPI
FilterV1Move (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR destNode = NULL;
    // NTRAID#NTBUG9-153274-2000/08/01-jimschm Static buffer size
    TCHAR expDest[MAX_PATH * 4];
    PCTSTR destLeaf = NULL;
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PCTSTR pathStart;
    // NTRAID#NTBUG9-153274-2000/08/01-jimschm Static buffer size
    TCHAR pathCopy[MAX_PATH * 4];
    PCTSTR newDestNode = NULL;
    PCTSTR newerDestNode = NULL;
    PCTSTR subPath;
    BOOL b;
    CHARTYPE ch;
    MIG_OBJECTSTRINGHANDLE destHandle;

    __try {

        //
        // For v1 compatibility, we support only a transformation from
        // original source to inf-specified destination.  Chaining of
        // operations is not allowed (these are restrictions caused by the
        // existing INF syntax).
        //

        if (!DestinationOperationData) {
            DEBUGMSG ((DBG_ERROR, "Missing dest data in FilterV1Move"));
            __leave;
        }

        if ((InputData->CurrentObject.ObjectTypeId & (~PLATFORM_MASK)) != g_FileType) {
            DEBUGMSG ((DBG_ERROR, "Unexpected object type in FilterV1Move"));
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (
                DestinationOperationData->String,
                &destNode,
                &destLeaf
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split dest object in FilterV1Move"));
            __leave;
        }

        MYASSERT (destNode);

        if (!destNode) {
            DEBUGMSG ((DBG_ERROR, "Destination spec must be a node"));
            __leave;
        }

        if (destLeaf) {
            DEBUGMSG ((DBG_WARNING, "Dest leaf specification %s (in %s) ignored", destLeaf, destNode));
        }

        //
        // Find the longest CSIDL inside InputData.  Take that as the base directory,
        // and take the rest as the subdirectory.
        //

        if (!IsmCreateObjectStringsFromHandle (
                InputData->CurrentObject.ObjectName,
                &srcNode,
                &srcLeaf
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split v1 src object in FilterV1Move"));
            __leave;
        }

        if (!srcNode) {
            MYASSERT (FALSE);
            __leave;
        }

        //
        // If not a local path, do not process
        //

        if (!_istalpha ((CHARTYPE) _tcsnextc (srcNode)) ||
            _tcsnextc (srcNode + 1) != TEXT(':')
            ) {
            DEBUGMSG ((DBG_WARNING, "Ignoring %s\\%s because it does not have a drive spec", srcNode, srcLeaf));
            __leave;
        }

        ch = (CHARTYPE) _tcsnextc (srcNode + 2);

        if (ch && ch != TEXT('\\')) {
            DEBUGMSG ((DBG_WARNING, "Ignoring %s\\%s because it does not have a drive spec (2)", srcNode, srcLeaf));
            __leave;
        }

        //
        // Expand the destination
        //
        b = MappingSearchAndReplaceEx (
                g_DestEnvMap,
                destNode,
                expDest,
                0,
                NULL,
                MAX_PATH,
                STRMAP_FIRST_CHAR_MUST_MATCH,
                NULL,
                NULL
                );

        //
        // Skip over the drive spec
        //

        pathStart = srcNode;

        //
        // Find the longest CSIDL by using the reverse mapping table. This takes
        // our full path spec in pathStart and encodes it with an environment
        // variable.
        //

        b = MappingSearchAndReplaceEx (
                g_RevEnvMap,
                pathStart,
                pathCopy,
                0,
                NULL,
                ARRAYSIZE(pathCopy),
                STRMAP_FIRST_CHAR_MUST_MATCH|
                    STRMAP_RETURN_AFTER_FIRST_REPLACE|
                    STRMAP_REQUIRE_WACK_OR_NUL,
                NULL,
                &subPath
                );

#ifdef DEBUG
        if (!b) {
            TCHAR debugBuf[MAX_PATH];

            if (MappingSearchAndReplaceEx (
                    g_RevEnvMap,
                    pathStart,
                    debugBuf,
                    0,
                    NULL,
                    ARRAYSIZE(debugBuf),
                    STRMAP_FIRST_CHAR_MUST_MATCH|STRMAP_RETURN_AFTER_FIRST_REPLACE,
                    NULL,
                    NULL
                    )) {
                DEBUGMSG ((DBG_WARNING, "Ignoring conversion: %s -> %s", pathStart, debugBuf));
            }
        }
#endif

        if (!b) {
            subPath = pathStart + (UINT) (ch ? 3 : 2);
            *pathCopy = 0;
        } else {
            if (*subPath) {
                MYASSERT (_tcsnextc (subPath) == TEXT('\\'));

                *(PTSTR) subPath = 0;
                subPath++;
            }
        }

        //
        // pathCopy gives us the base, with CSIDL_ environment variables (might be an empty string)
        // subPath gives us the subdir (might also be an empty string)
        //
        // append subPath to the destination node
        //

        if (*subPath) {
            newDestNode = JoinPaths (expDest, subPath);
        } else {
            newDestNode = expDest;
        }

        destHandle = IsmCreateObjectHandle (newDestNode, srcLeaf);

        if (destHandle) {
            OutputData->NewObject.ObjectName = destHandle;
        }
    }
    __finally {
        IsmDestroyObjectString (destNode);
        IsmDestroyObjectString (destLeaf);
        IsmDestroyObjectString (srcNode);
        IsmDestroyObjectString (srcLeaf);

        if (newDestNode != expDest) {
            FreePathString (newDestNode);
        }
    }

    return TRUE;
}


BOOL
WINAPI
FilterMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PCTSTR baseNode = NULL;
    PCTSTR baseLeaf = NULL;
    PCTSTR destNode = NULL;
    PCTSTR destLeaf = NULL;
    PCTSTR node;
    PCTSTR leaf;
    UINT baseNodeLen;

    __try {
        //
        // Take InputData, break it into node & leaf, take DestinationOperationData,
        // do the same, then replace InputData's node & leaf as appropriate.
        //

        if (!SourceOperationData) {
            DEBUGMSG ((DBG_ERROR, "Missing source data in general move operation"));
            __leave;
        }

        if (!DestinationOperationData) {
            DEBUGMSG ((DBG_ERROR, "Missing destination data in general move operation"));
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (
                InputData->CurrentObject.ObjectName,
                &srcNode,
                &srcLeaf
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split src object in general move operation"));
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (
                SourceOperationData->String,
                &baseNode,
                &baseLeaf
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split src object in general move operation"));
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (
                DestinationOperationData->String,
                &destNode,
                &destLeaf
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split dest object in general move operation"));
            __leave;
        }

        baseNodeLen = TcharCount (baseNode);
        node = NULL;
        leaf = NULL;
        if (StringIMatchTcharCount (srcNode, baseNode, baseNodeLen)) {
            if (srcNode [baseNodeLen]) {
                node = JoinPaths (destNode, &(srcNode [baseNodeLen]));
            } else {
                node = DuplicatePathString (destNode, 0);
            }
            if (!baseLeaf && !destLeaf) {
                leaf = srcLeaf;
            } else if (baseLeaf && srcLeaf && StringIMatch (srcLeaf, baseLeaf)) {
                leaf = destLeaf?destLeaf:baseLeaf;
            } else if (!baseLeaf && destLeaf) {
                if (srcLeaf) {
                    leaf = destLeaf;
                }
            } else {
                FreePathString (node);
                node = NULL;
            }
        }

        if (node) {
            OutputData->NewObject.ObjectName = IsmCreateObjectHandle (node, leaf);
            FreePathString (node);
            node = NULL;
        }
    }
    __finally {
        IsmDestroyObjectString (srcNode);
        IsmDestroyObjectString (srcLeaf);
        IsmDestroyObjectString (baseNode);
        IsmDestroyObjectString (baseLeaf);
        IsmDestroyObjectString (destNode);
        IsmDestroyObjectString (destLeaf);
    }

    return TRUE;
}


BOOL
WINAPI
FilterDelete (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    //
    // Mark the output data as deleted.  That will be sufficient to
    // cause the object to be deleted (even if it was also marked as
    // "save")
    //

    OutputData->Deleted = TRUE;

    return TRUE;
}


BOOL
WINAPI
FilterRegAutoFilter (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    // NTRAID#NTBUG9-153275-2000/08/01-jimschm Static buffer size
    TCHAR newNode[MAX_PATH * 4];
    TCHAR newLeaf[MAX_PATH * 4];
    BOOL change = FALSE;

    //
    // Filter the object name
    //

    IsmCreateObjectStringsFromHandle (
        InputData->CurrentObject.ObjectName,
        &node,
        &leaf
        );

    if (node) {
        if (MappingSearchAndReplaceEx (
                g_RegNodeFilterMap,         // map handle
                node,                       // source string
                newNode,                    // dest buffer
                0,                          // source string bytes (0=unspecified)
                NULL,                       // dest bytes required
                ARRAYSIZE(newNode),         // dest buffer size
                0,                          // flags
                NULL,                       // extra data value
                NULL                        // end of string
                )) {
            IsmDestroyObjectString (node);
            node = newNode;
            change = TRUE;
        }
    }

    if (leaf) {
        if (MappingSearchAndReplaceEx (
                g_RegLeafFilterMap,
                leaf,
                newLeaf,
                0,
                NULL,
                ARRAYSIZE(newLeaf),
                0,
                NULL,
                NULL
                )) {
            IsmDestroyObjectString (leaf);
            leaf = newLeaf;
            change = TRUE;
        }
    }

    if (change) {
        OutputData->NewObject.ObjectName = IsmCreateObjectHandle (node, leaf);
    }

    if (node != newNode) {
        IsmDestroyObjectString (node);
    }

    if (leaf != newLeaf) {
        IsmDestroyObjectString (leaf);
    }

    return TRUE;
}

BOOL
pOpmFindFile (
    IN      PCTSTR FileName
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    PTSTR node, leaf, leafPtr;
    BOOL result = FALSE;

    objectName = IsmCreateObjectHandle (FileName, NULL);
    if (objectName) {
        if (IsmGetObjectIdFromName (MIG_FILE_TYPE | PLATFORM_SOURCE, objectName, TRUE) != 0) {
            result = TRUE;
        }
        IsmDestroyObjectHandle (objectName);
    }
    if (!result) {
        node = DuplicateText (FileName);
        leaf = _tcsrchr (node, TEXT('\\'));
        if (leaf) {
            leafPtr = (PTSTR) leaf;
            leaf = _tcsinc (leaf);
            *leafPtr = 0;
            objectName = IsmCreateObjectHandle (node, leaf);
            if (objectName) {
                if (IsmGetObjectIdFromName (MIG_FILE_TYPE | PLATFORM_SOURCE, objectName, TRUE) != 0) {
                    result = TRUE;
                }
                IsmDestroyObjectHandle (objectName);
            }
            *leafPtr = TEXT('\\');
        }
        FreeText (node);
    }

    return result;
}

BOOL
pOpmSearchPath (
    IN      PCTSTR FileName,
    IN      DWORD BufferLength,
    OUT     PTSTR Buffer
    )
{
    return FALSE;
}

MIG_OBJECTSTRINGHANDLE
pSimpleTryHandle (
    IN      PCTSTR FullPath
    )
{
    PCTSTR buffer;
    PTSTR leafPtr, leaf;
    MIG_OBJECTSTRINGHANDLE source = NULL;
    MIG_OBJECTSTRINGHANDLE result = NULL;
    PTSTR workingPath;
    PCTSTR sanitizedPath;
    BOOL orgDeleted = FALSE;
    BOOL orgReplaced = FALSE;
    PCTSTR saved = NULL;

    sanitizedPath = SanitizePath (FullPath);
    if (!sanitizedPath) {
        return NULL;
    }

    source = IsmCreateObjectHandle (sanitizedPath, NULL);
    if (source) {
        result = IsmFilterObject (
                    g_FileType | PLATFORM_SOURCE,
                    source,
                    NULL,
                    &orgDeleted,
                    &orgReplaced
                    );
        // we do not want replaced directories
        // since they can be false hits
        if (orgDeleted && orgReplaced) {
            if (result) {
                saved = result;
                result = NULL;
            }
        }
        if (!result && !orgDeleted) {
            result = source;
        } else {
            IsmDestroyObjectHandle (source);
            source = NULL;
        }
    }

    if (result) {
        goto exit;
    }

    buffer = DuplicatePathString (sanitizedPath, 0);

    leaf = _tcsrchr (buffer, TEXT('\\'));

    if (leaf) {
        leafPtr = leaf;
        leaf = _tcsinc (leaf);
        *leafPtr = 0;
        source = IsmCreateObjectHandle (buffer, leaf);
        *leafPtr = TEXT('\\');
    }

    FreePathString (buffer);

    if (source) {
        result = IsmFilterObject (
                        g_FileType | PLATFORM_SOURCE,
                        source,
                        NULL,
                        &orgDeleted,
                        &orgReplaced
                        );
        if (!result && !orgDeleted) {
            result = source;
        } else {
            if (!result) {
                result = saved;
            }
            IsmDestroyObjectHandle (source);
            source = NULL;
        }
    }

    if (result != saved) {
        IsmDestroyObjectHandle (saved);
        saved = NULL;
    }

exit:
    FreePathString (sanitizedPath);
    return result;
}

MIG_OBJECTSTRINGHANDLE
pTryHandle (
    IN      PCTSTR FullPath,
    IN      PCTSTR Hint,
    OUT     PCTSTR *TrimmedResult
    )
{
    PATH_ENUM pathEnum;
    PCTSTR newPath;
    MIG_OBJECTSTRINGHANDLE result = NULL;
    PCTSTR nativeName = NULL;
    PCTSTR lastSegPtr;

    if (TrimmedResult) {
        *TrimmedResult = NULL;
    }

    result = pSimpleTryHandle (FullPath);
    if (result || (!Hint)) {
        return result;
    }
    if (EnumFirstPathEx (&pathEnum, Hint, NULL, NULL, FALSE)) {
        do {
            newPath = JoinPaths (pathEnum.PtrCurrPath, FullPath);
            result = pSimpleTryHandle (newPath);
            if (result) {
                AbortPathEnum (&pathEnum);
                FreePathString (newPath);
                // now, if the initial FullPath did not have any wack in it
                // we will take the last segment of the result and put it
                // in TrimmedResult
                if (TrimmedResult && (!_tcschr (FullPath, TEXT('\\')))) {
                    nativeName = IsmGetNativeObjectName (g_FileType, result);
                    if (nativeName) {
                        lastSegPtr = _tcsrchr (nativeName, TEXT('\\'));
                        if (lastSegPtr) {
                            lastSegPtr = _tcsinc (lastSegPtr);
                            if (lastSegPtr) {
                                *TrimmedResult = DuplicatePathString (lastSegPtr, 0);
                            }
                        }
                    }
                }
                return result;
            }
            FreePathString (newPath);
        } while (EnumNextPath (&pathEnum));
    }
    AbortPathEnum (&pathEnum);
    return NULL;
}

BOOL
WINAPI
DoRegAutoFilter (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR leafPtr = NULL;
    PDWORD valueType;
    MIG_OBJECTSTRINGHANDLE source;
    MIG_OBJECTSTRINGHANDLE destination;
    PCTSTR leaf;
    TCHAR expandBuffer[4096];
    TCHAR hintBuffer[4096];
    PTSTR buffer;
    GROWBUFFER result = INIT_GROWBUFFER;
    GROWBUFFER cmdLineBuffer = INIT_GROWBUFFER;
    PCMDLINE cmdLine;
    UINT u;
    PCTSTR data, p, end;
    PCTSTR nativeDest;
    PCTSTR newData, oldData;
    BOOL parsable;
    BOOL replaced = FALSE;
    BOOL orgDeleted = FALSE;
    BOOL orgReplaced = FALSE;
    PCTSTR trimmedResult = NULL;
    BOOL newContent = TRUE;
    PCTSTR destResult = NULL;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {

        parsable = FALSE;
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);
        if (valueType) {
            if (*valueType == REG_EXPAND_SZ ||
                *valueType == REG_SZ
                ) {

                parsable = TRUE;
            }
        } else {
            parsable = IsmIsObjectHandleNodeOnly (SrcObjectName);
        }

        if (parsable) {

            data = (PTSTR) CurrentContent->MemoryContent.ContentBytes;
            end = (PCTSTR) (CurrentContent->MemoryContent.ContentBytes + CurrentContent->MemoryContent.ContentSize);

            while (data < end) {
                if (*data == 0) {
                    break;
                }

                data = _tcsinc (data);
            }

            if (data >= end) {
                parsable = FALSE;
            }
        }

        if (parsable) {

            data = (PTSTR) CurrentContent->MemoryContent.ContentBytes;

            if ((*valueType == REG_EXPAND_SZ) ||
                (*valueType == REG_SZ)
                ) {
                //
                // Expand the data
                //

                MappingSearchAndReplaceEx (
                    g_EnvMap,
                    data,
                    expandBuffer,
                    0,
                    NULL,
                    ARRAYSIZE(expandBuffer),
                    0,
                    NULL,
                    NULL
                    );

                data = expandBuffer;
            }

            *hintBuffer = 0;
            if (DestinationOperationData &&
                (DestinationOperationData->Type == BLOBTYPE_STRING) &&
                (DestinationOperationData->String)
                ) {
                MappingSearchAndReplaceEx (
                    g_EnvMap,
                    DestinationOperationData->String,
                    hintBuffer,
                    0,
                    NULL,
                    ARRAYSIZE(hintBuffer),
                    0,
                    NULL,
                    NULL
                    );
            }

            destination = pTryHandle (data, *hintBuffer?hintBuffer:NULL, &trimmedResult);

            if (destination) {
                replaced = TRUE;
                if (trimmedResult) {
                    GbAppendString (&result, trimmedResult);
                    FreePathString (trimmedResult);
                } else {
                    nativeDest = IsmGetNativeObjectName (g_FileType, destination);
                    GbAppendString (&result, nativeDest);
                    IsmReleaseMemory (nativeDest);
                }
            }

            // finally, if we failed we are going to assume it's a command line
            if (!replaced) {
                newData = DuplicatePathString (data, 0);
                cmdLine = ParseCmdLineEx (data, NULL, &pOpmFindFile, &pOpmSearchPath, &cmdLineBuffer);
                if (cmdLine) {

                    //
                    // Find the file referenced in the list or command line
                    //
                    for (u = 0 ; u < cmdLine->ArgCount ; u++) {
                        p = cmdLine->Args[u].CleanedUpArg;

                        // first we try it as is

                        destination = pTryHandle (p, *hintBuffer?hintBuffer:NULL, &trimmedResult);

                        // maybe we have something like /m:c:\foo.txt
                        // we need to go forward until we find a sequence of
                        // <alpha>:\<something>
                        if (!destination && p[0] && p[1]) {

                            while (p[2]) {
                                if (_istalpha ((CHARTYPE) _tcsnextc (p)) &&
                                    p[1] == TEXT(':') &&
                                    p[2] == TEXT('\\')
                                    ) {

                                    destination = pTryHandle (p, *hintBuffer?hintBuffer:NULL, &trimmedResult);

                                    if (destination) {
                                        break;
                                    }
                                }
                                p ++;
                            }
                        }
                        if (destination) {
                            replaced = TRUE;
                            if (trimmedResult) {
                                oldData = StringSearchAndReplace (newData, p, trimmedResult);
                                if (oldData) {
                                    FreePathString (newData);
                                    newData = oldData;
                                }
                                FreePathString (trimmedResult);
                            } else {
                                nativeDest = IsmGetNativeObjectName (g_FileType, destination);
                                oldData = StringSearchAndReplace (newData, p, nativeDest);
                                if (oldData) {
                                    FreePathString (newData);
                                    newData = oldData;
                                }
                                IsmReleaseMemory (nativeDest);
                            }
                            IsmDestroyObjectHandle (destination);
                            destination = NULL;
                        }
                    }
                }
                GbFree (&cmdLineBuffer);
                if (!replaced) {
                    if (newData) {
                        FreePathString (newData);
                    }
                } else {
                    if (newData) {
                        GbAppendString (&result, newData);
                        FreePathString (newData);
                    }
                }
            }

            if (destination) {
                IsmDestroyObjectHandle (destination);
                destination = NULL;
            }

            if (replaced && result.Buf) {
                // looks like we have new content
                // Let's do one more check. If this is a REG_EXPAND_SZ we will do our best to
                // keep the stuff unexpanded. So if the source string expanded on the destination
                // machine is the same as the destination string we won't do anything.
                newContent = TRUE;
                if (*valueType == REG_EXPAND_SZ) {
                    destResult = IsmExpandEnvironmentString (
                                    PLATFORM_DESTINATION,
                                    S_SYSENVVAR_GROUP,
                                    (PCTSTR) CurrentContent->MemoryContent.ContentBytes,
                                    NULL
                                    );
                    if (destResult && StringIMatch (destResult, (PCTSTR)result.Buf)) {
                        newContent = FALSE;
                    }
                    if (destResult) {
                        IsmReleaseMemory (destResult);
                        destResult = NULL;
                    }
                }
                if (newContent) {
                    NewContent->MemoryContent.ContentSize = SizeOfString ((PCTSTR)result.Buf);
                    NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                    CopyMemory ((PTSTR)NewContent->MemoryContent.ContentBytes, result.Buf, NewContent->MemoryContent.ContentSize);
                }
            }

            GbFree (&result);
        }
    }

    return TRUE;
}


BOOL
WINAPI
DoFixDefaultIcon (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_PROPERTYDATAID propDataId;
    MIG_BLOBTYPE propDataType;
    UINT requiredSize;
    PDWORD valueType;
    PICON_GROUP iconGroup = NULL;
    ICON_SGROUP iconSGroup = {0, NULL};
    PTSTR iconLibPath = NULL;
    INT iconNumber = 0;
    PTSTR dataCopy;

    if (CurrentContent->ContentInFile) {
        return TRUE;
    }
    valueType = (PDWORD)(CurrentContent->Details.DetailsData);
    if (*valueType != REG_SZ && *valueType != REG_EXPAND_SZ) {
        return TRUE;
    }
    // let's see if we have our property attached
    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_DefaultIconData);
    if (!propDataId) {
        return TRUE;
    }
    if (!IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
        return TRUE;
    }
    iconSGroup.DataSize = requiredSize;
    iconSGroup.Data = IsmGetMemory (requiredSize);
    if (!IsmGetPropertyData (propDataId, (PBYTE)iconSGroup.Data, requiredSize, NULL, &propDataType)) {
        IsmReleaseMemory (iconSGroup.Data);
        return TRUE;
    }
    if (!iconSGroup.DataSize) {
        IsmReleaseMemory (iconSGroup.Data);
        return TRUE;
    }
    iconGroup = IcoDeSerializeIconGroup (&iconSGroup);
    if (!iconGroup) {
        IsmReleaseMemory (iconSGroup.Data);
        return TRUE;
    }
    if (IsmGetEnvironmentString (
            PLATFORM_DESTINATION,
            NULL,
            S_ENV_ICONLIB,
            NULL,
            0,
            &requiredSize
            )) {
        iconLibPath = IsmGetMemory (requiredSize);
        if (IsmGetEnvironmentString (
                PLATFORM_DESTINATION,
                NULL,
                S_ENV_ICONLIB,
                iconLibPath,
                requiredSize,
                NULL
                )) {
            if (IcoWriteIconGroupToPeFile (iconLibPath, iconGroup, NULL, &iconNumber)) {
                // finally we wrote the icon, fix the content and tell scanstate that
                // we iconlib was used
                dataCopy = IsmGetMemory (SizeOfString (iconLibPath) + sizeof (TCHAR) + 20 * sizeof (TCHAR));
                wsprintf (dataCopy, TEXT("%s,%d"), iconLibPath, iconNumber);
                NewContent->MemoryContent.ContentSize = SizeOfString (dataCopy);
                NewContent->MemoryContent.ContentBytes = (PBYTE) dataCopy;
                IsmSetEnvironmentFlag (PLATFORM_DESTINATION, NULL, S_ENV_SAVE_ICONLIB);
            }
        }
        IsmReleaseMemory (iconLibPath);
    }
    IcoReleaseIconGroup (iconGroup);
    IsmReleaseMemory (iconSGroup.Data);

    return TRUE;
}


BOOL
WINAPI
FilterFileAutoFilter (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR node, nodeWack;
    PCTSTR leaf;
    // NTRAID#NTBUG9-153275-2000/08/01-jimschm Static buffer size
    TCHAR newNode[MAX_PATH * 4];
    TCHAR newLeaf[MAX_PATH * 4];
    BOOL changed = FALSE;

    if (InputData &&
        InputData->OriginalObject.ObjectName &&
        InputData->CurrentObject.ObjectName &&
        (InputData->OriginalObject.ObjectName != InputData->CurrentObject.ObjectName)
        ) {
        // this was already modified. Let's not touch it.
        return TRUE;
    }

    //
    // Filter the object name
    //

    IsmCreateObjectStringsFromHandle (
        InputData->CurrentObject.ObjectName,
        &node,
        &leaf
        );

    if (NoRestoreObject && leaf) {
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
        return TRUE;
    }

    if (node) {
        if (MappingSearchAndReplaceEx (
                g_FileNodeFilterMap,        // map handle
                node,                       // source string
                newNode,                    // dest buffer
                0,                          // source string bytes (0=unspecified)
                NULL,                       // dest bytes required
                ARRAYSIZE(newNode),         // dest buffer size
                0,                          // flags
                NULL,                       // extra data value
                NULL                        // end of string
                )) {
            IsmDestroyObjectString (node);
            node = newNode;
            changed = TRUE;
        } else {
            nodeWack = JoinPaths (node, TEXT(""));
            if (MappingSearchAndReplaceEx (
                    g_FileNodeFilterMap,        // map handle
                    nodeWack,                   // source string
                    newNode,                    // dest buffer
                    0,                          // source string bytes (0=unspecified)
                    NULL,                       // dest bytes required
                    ARRAYSIZE(newNode),         // dest buffer size
                    0,                          // flags
                    NULL,                       // extra data value
                    NULL                        // end of string
                    )) {
                IsmDestroyObjectString (node);
                node = newNode;
                changed = TRUE;
            }
            FreePathString (nodeWack);
            nodeWack = NULL;
        }
    }

    if (leaf) {
        if (MappingSearchAndReplaceEx (
                g_FileLeafFilterMap,
                leaf,
                newLeaf,
                0,
                NULL,
                ARRAYSIZE(newLeaf),
                0,
                NULL,
                NULL
                )) {
            IsmDestroyObjectString (leaf);
            leaf = newLeaf;
            changed = TRUE;
        }
    }

    if (changed) {
        OutputData->NewObject.ObjectName = IsmCreateObjectHandle (node, leaf);
    }
    OutputData->Replaced = NoRestoreObject;

    if (node != newNode) {
        IsmDestroyObjectString (node);
    }

    if (leaf != newLeaf) {
        IsmDestroyObjectString (leaf);
    }

    return TRUE;
}


PCTSTR
pProcessRenameExMacro (
    IN     PCTSTR Node,
    IN     PCTSTR Leaf,      OPTIONAL
    IN     BOOL ZeroBase
    )
{
    PCTSTR workingStr;
    PTSTR macroStartPtr = NULL;
    PTSTR macroEndPtr = NULL;
    PTSTR macroCopy = NULL;
    DWORD macroLength = 0;
    PTSTR macroParsePtr = NULL;
    TCHAR macroReplacement[MAX_PATH];
    MIG_OBJECTSTRINGHANDLE testHandle = NULL;

    TCHAR regReplacement[MAX_PATH];
    UINT index;
    PCTSTR newString;

    // If Leaf is supplied, we are working only on the Leaf
    workingStr = Leaf ? Leaf : Node;

    // Extract macro
    macroStartPtr = _tcschr (workingStr, S_RENAMEEX_START_CHAR);
    if (macroStartPtr) {
        macroEndPtr = _tcschr (macroStartPtr + 1, S_RENAMEEX_END_CHAR);
    }
    if (macroEndPtr) {
        macroCopy = DuplicateText (macroStartPtr + 1);
        macroCopy[macroEndPtr-macroStartPtr-1] = 0;
    }

    if (macroCopy) {
        // Build a possible destination
        if (ZeroBase) {
            index = 0;
        } else {
            index = 1;
        }

        do {
            IsmDestroyObjectHandle (testHandle);

            _stprintf (macroReplacement, macroCopy, index);
            StringCopyByteCount (regReplacement, workingStr, (HALF_PTR) ((macroStartPtr - workingStr + 1) * sizeof (TCHAR)));
            StringCat (regReplacement, macroReplacement);
            StringCat (regReplacement, macroEndPtr + 1);
            if (Leaf) {
                testHandle = IsmCreateObjectHandle (Node, regReplacement);
            } else {
                testHandle = IsmCreateObjectHandle (regReplacement, NULL);
            }
            index++;
        } while (pDoesDifferentRegExist (testHandle) ||
                 HtFindString (g_RegCollisionDestTable, testHandle));

        IsmDestroyObjectHandle (testHandle);
        FreeText (macroCopy);

        newString = DuplicateText (regReplacement);
    } else {
        newString = DuplicateText (workingStr);
    }

    return newString;
}

BOOL
WINAPI
FilterRenameExFilter (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR doNode = NULL;
    PCTSTR doLeaf = NULL;
    PCTSTR destNode = NULL;
    PCTSTR newNode = NULL;
    PCTSTR rootNode;
    PCTSTR destLeaf = NULL;
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    // NTRAID#NTBUG9-153274-2000/08/01-jimschm Static buffer size
    TCHAR newSrcNode[MAX_PATH * 4];
    TCHAR newSrcLeaf[MAX_PATH * 4];
    HASHITEM hashItem;
    MIG_OBJECTSTRINGHANDLE storeHandle;
    MIG_OBJECTSTRINGHANDLE testHandle;
    MIG_OBJECTSTRINGHANDLE nodeHandle;
    PTSTR ptr = NULL;
    PTSTR ptr2;
    PTSTR workingStr;
    BOOL fFoundMatch = FALSE;
    BOOL zeroBase;


    IsmCreateObjectStringsFromHandle (
        InputData->CurrentObject.ObjectName,
        &srcNode,
        &srcLeaf
        );

    if (srcNode) {
        if (MappingSearchAndReplaceEx (
                g_RegNodeFilterMap,
                srcNode,
                newSrcNode,
                0,
                NULL,
                ARRAYSIZE(newSrcNode),
                0,
                NULL,
                NULL
                )) {
            IsmDestroyObjectString (srcNode);
            srcNode = newSrcNode;
        }
    }

    if (srcLeaf) {
        if (MappingSearchAndReplaceEx (
                g_RegLeafFilterMap,
                srcLeaf,
                newSrcLeaf,
                0,
                NULL,
                ARRAYSIZE(newSrcLeaf),
                0,
                NULL,
                NULL
                )) {
            IsmDestroyObjectString (srcLeaf);
            srcLeaf = newSrcLeaf;
        }
    }

    if (HtFindStringEx (g_RegCollisionSrcTable, InputData->OriginalObject.ObjectName, (PVOID)(&hashItem), FALSE)) {
        // We've already renamed this object

        HtCopyStringData (g_RegCollisionDestTable, hashItem, (PVOID)(&testHandle));
        IsmCreateObjectStringsFromHandle (testHandle, &destNode, &destLeaf);

        // Do not free testHandle here because it is a pointer into the hash table data

        OutputData->NewObject.ObjectName = IsmCreateObjectHandle (destNode, destLeaf);
        IsmDestroyObjectString (destNode);
        IsmDestroyObjectString (destLeaf);
        destNode;
        destLeaf = NULL;
    } else {
        // We've never seen this object yet

        IsmCreateObjectStringsFromHandle (DestinationOperationData->String, &doNode, &doLeaf);

        // Pick a new node

        // First check to see if this object's node has already been processed
        workingStr = DuplicateText(srcNode);
        if (workingStr) {
            do {
                nodeHandle = IsmCreateObjectHandle (workingStr, NULL);
                if (HtFindStringEx (g_RegCollisionSrcTable, nodeHandle, (PVOID)(&hashItem), FALSE)) {

                    HtCopyStringData (g_RegCollisionDestTable, hashItem, (PVOID)(&testHandle));
                    IsmCreateObjectStringsFromHandle (testHandle, &rootNode, NULL);
                    // Do not free testHandle here because it is a pointer into the hash table data

                    if (ptr) {
                        // if ptr is valid it means we found a match for a subkey
                        *ptr = TEXT('\\');
                        newNode = JoinText(rootNode, ptr);
                    } else {
                        // if ptr is NULL, we found a match for the full keyname
                        newNode = DuplicateText(rootNode);
                    }
                    IsmDestroyObjectString(rootNode);
                    fFoundMatch = TRUE;
                } else {
                    ptr2 = ptr;
                    ptr = (PTSTR)FindLastWack (workingStr);
                    if (ptr2) {
                        *ptr2 = TEXT('\\');
                    }
                    if (ptr) {
                        *ptr = 0;
                    }
                }
                IsmDestroyObjectHandle(nodeHandle);
            } while (FALSE == fFoundMatch && ptr);
            FreeText(workingStr);
        }

        zeroBase = (SourceOperationData &&
                    SourceOperationData->Type == BLOBTYPE_BINARY &&
                    SourceOperationData->BinarySize == sizeof(PCBYTE) &&
                    (BOOL)SourceOperationData->BinaryData == TRUE);

        if (FALSE == fFoundMatch) {
            // Nope, let's process the node
            destNode = pProcessRenameExMacro (doNode, NULL, zeroBase);
            newNode = DuplicateText(destNode);
            IsmDestroyObjectHandle(destNode);
        }

        // Now process the leaf, if the original object had a leaf
        if (srcLeaf) {
            if (doLeaf) {
                destLeaf = pProcessRenameExMacro (newNode, doLeaf, zeroBase);
                IsmDestroyObjectString (doLeaf);
            }
        }
        IsmDestroyObjectString (doNode);

        // Add this in the collision table
        testHandle = IsmCreateObjectHandle (newNode, destLeaf ? destLeaf : srcLeaf);
        storeHandle = DuplicateText (testHandle);
        hashItem = HtAddStringEx (g_RegCollisionDestTable, storeHandle, &storeHandle, FALSE);
        HtAddStringEx (g_RegCollisionSrcTable, InputData->OriginalObject.ObjectName, &hashItem, FALSE);

        // Update the output
        OutputData->NewObject.ObjectName = testHandle;
    }

    if (srcNode != NULL) {
        IsmDestroyObjectString (srcNode);
    }
    if (srcLeaf != NULL) {
        IsmDestroyObjectString (srcLeaf);
    }
    if (destLeaf != NULL) {
        IsmDestroyObjectString (destLeaf);
    }
    if (newNode != NULL) {
        FreeText(newNode);
    }

    return TRUE;
}

BOOL
WINAPI
FilterPartitionMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;

    IsmCreateObjectStringsFromHandle (DestinationOperationData->String, &node, &leaf);

    OutputData->NewObject.ObjectName = IsmCreateObjectHandle (node, leaf);

    IsmDestroyObjectString (node);
    IsmDestroyObjectString (leaf);

    return TRUE;
}

BOOL
WINAPI
DoDestAddObject (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PMIG_CONTENT finalContent;

    if (DestinationOperationData == NULL) {
        return TRUE;
    }
    if (DestinationOperationData->Type != BLOBTYPE_BINARY) {
        return TRUE;
    }
    if (DestinationOperationData->BinarySize != sizeof (MIG_CONTENT)) {
        return TRUE;
    }

    finalContent = (PMIG_CONTENT) DestinationOperationData->BinaryData;
    CopyMemory (NewContent, finalContent, sizeof (MIG_CONTENT));

    return TRUE;
}

VOID
OEWarning (
    VOID
    )
{
    ERRUSER_EXTRADATA extraData;

    if (TRUE == g_OERulesMigrated) {
        // Send warning to app
        extraData.Error = ERRUSER_WARNING_OERULES;
        extraData.ErrorArea = ERRUSER_AREA_RESTORE;
        extraData.ObjectTypeId = 0;
        extraData.ObjectName = NULL;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));

        // Add to log
        LOG ((LOG_WARNING, (PCSTR) MSG_OE_RULES));
    }
}



VOID
OutlookWarning (
    VOID
    )
{
    PCTSTR expandedPath;
    MIG_OBJECT_ENUM objectEnum;
    PCTSTR enumPattern;
    ERRUSER_EXTRADATA extraData;

    expandedPath = IsmExpandEnvironmentString (PLATFORM_SOURCE,
                                               S_SYSENVVAR_GROUP,
                                               TEXT("%CSIDL_APPDATA%\\Microsoft\\Outlook"),
                                               NULL);
    if (expandedPath) {
        enumPattern = IsmCreateSimpleObjectPattern (expandedPath, FALSE, TEXT("*.rwz"), TRUE);
        if (enumPattern) {
            if (IsmEnumFirstSourceObject (&objectEnum, g_FileType, enumPattern)) {
                // Send warning to app
                extraData.Error = ERRUSER_WARNING_OUTLOOKRULES;
                extraData.ErrorArea = ERRUSER_AREA_RESTORE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));

                // Add to log
                LOG ((LOG_WARNING, (PCSTR) MSG_OUTLOOK_RULES));

                IsmAbortObjectEnum (&objectEnum);
            }
            IsmDestroyObjectHandle (enumPattern);
        }
        IsmReleaseMemory (expandedPath);
    }

}

VOID
WINAPI
ScriptOpmTerminate (
    VOID
    )
{
    //
    //  Temporary place to trigger setting refresh/upgrade
    //

    if (!IsmCheckCancel()) {
        OEFixLastUser();
        WABMerge();
        OE4MergeStoreFolder();
        OE5MergeStoreFolders();
        OEWarning();
        OutlookWarning();
    }

    TerminateRestoreCallback ();
    TerminateSpecialRename();
    TerminateSpecialConversion();

    // LEAK: need to loop through table and FreeText the extra data
    HtFree (g_RegCollisionDestTable);
    g_RegCollisionDestTable = NULL;

    HtFree (g_RegCollisionSrcTable);
    g_RegCollisionSrcTable = NULL;

    DestroyStringMapping (g_RegNodeFilterMap);
    g_RegNodeFilterMap = NULL;

    DestroyStringMapping (g_RegLeafFilterMap);
    g_RegLeafFilterMap = NULL;

    DestroyStringMapping (g_FileNodeFilterMap);
    g_FileNodeFilterMap = NULL;

    DestroyStringMapping (g_FileLeafFilterMap);
    g_FileLeafFilterMap = NULL;

    DestroyStringMapping (g_DestEnvMap);
    g_DestEnvMap = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\oeutils.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    oe.c

Abstract:

    Implements Outlook Express utilities

Author:

    Jay Thaler (jthaler) 05-Apr-2001

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"
#include <wab.h>
#include <sddl.h>
#include <rpcdce.h>
#define COBJMACROS
#include <msoeimp.h>

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

#define OETEMPDIR TEXT("%CSIDL_LOCAL_APPDATA%\\Identities\\USMTTMP")
#define DEFAULTWAB TEXT("default.wab")

//
// Macros
//

#define IF_NULLEND(x) if (NULL==x) { goto end; }

//
// Types
//

typedef IMailImport * (STDMETHODCALLTYPE OECREATE)(
    LPCSTR pszSrcDir
    );
typedef OECREATE FAR *LPOECREATE;

typedef HRESULT (STDMETHODCALLTYPE IMPORTSTORE)(
    IMailImport *pMailImport,
    GUID *pDestUUID,
    LPCSTR pszDestDir
    );
typedef IMPORTSTORE FAR *LPIMPORTSTORE;

typedef HRESULT (STDMETHODCALLTYPE IMPORTNEWS)(
    LPCSTR pszSrcDir,
    GUID *pDestUUID,
    LPCSTR pszDestDir
    );
typedef IMPORTNEWS FAR *LPIMPORTNEWS;

//
// Globals
//

PTSTR g_DestAssociatedId = NULL;
HMODULE g_msoedll = NULL;
HMODULE g_oemiglib = NULL;
BOOL g_CoInit = FALSE;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pUuidFromBracketedString (
    PCTSTR InStr,
    UUID *Uuid
    )
{
    PTSTR strippedStr = NULL;
    TCHAR *p;
    BOOL retval = FALSE;

    if (!InStr || !Uuid)
    {
        return FALSE;
    }

    if (*InStr == TEXT('{')) {
        strippedStr = DuplicateText(_tcsinc(InStr));
        p = _tcsrchr (strippedStr, TEXT('}'));
        if (p) {
            *p = 0;
        }
    } else {
        strippedStr = DuplicateText(InStr);
    }

    if (strippedStr) {
       if (RPC_S_OK == UuidFromString(strippedStr, Uuid)) {
           retval = TRUE;
       }
       FreeText(strippedStr);
    }

    return retval;
}

MIG_OBJECTSTRINGHANDLE
pBuildStoreRootKeyForId (
    PCTSTR Identity
    )
{
    MIG_OBJECTSTRINGHANDLE objectName = NULL;
    PTSTR tmpStr;

    tmpStr = AllocText (CharCount(TEXT("HKCU\\Identities\\")) +
                        CharCount(Identity) +
                        CharCount(TEXT("\\Software\\Microsoft\\Outlook Express\\5.0")) + 1);
    if (tmpStr) {
        StringCopy(tmpStr, TEXT("HKCU\\Identities\\"));
        StringCat(tmpStr, Identity);
        StringCat(tmpStr, TEXT("\\Software\\Microsoft\\Outlook Express\\5.0"));
        objectName = IsmCreateObjectHandle (tmpStr, TEXT("Store Root"));
        FreeText (tmpStr);
        tmpStr = NULL;
    }

    return objectName;
}


PTSTR
pGetDestStoreRootForId (
    PCTSTR Identity
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    PTSTR retval = NULL;
    PTSTR tmpStr;
    PCTSTR destStore;

    objectName = pBuildStoreRootKeyForId (Identity);
    if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION,
                          objectName,
                          &objectContent)) {
        if (IsValidRegSz(&objectContent)) {
            destStore = IsmExpandEnvironmentString (PLATFORM_DESTINATION,
                                                    S_SYSENVVAR_GROUP,
                                                    (PCTSTR)objectContent.MemoryContent.ContentBytes,
                                                    NULL);
            if (destStore) {
                retval = DuplicateText(destStore);
                IsmReleaseMemory(destStore);
            }
        }
        IsmReleaseObject (&objectContent);
    }
    IsmDestroyObjectHandle(objectName);

    return retval;
}

VOID
WABMerge (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE filteredName = NULL;
    MIG_OBJECTSTRINGHANDLE objectName = NULL;
    MIG_OBJECTSTRINGHANDLE destObjectName;
    MIG_OBJECTSTRINGHANDLE lpWABObjectName = NULL;
    MIG_CONTENT objectContent;
    PCTSTR srcFile = NULL;
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PTSTR destFile = NULL;
    PCTSTR wabKey = NULL;
    PCTSTR wabPath = NULL;
    PCTSTR destPath;
    HANDLE lib;
    LPWABOPEN lpfnWABOpen = NULL;
    LPWABOBJECT lpWABObject;
    LPADRBOOK lpAdrBookWAB;
    WAB_PARAM wabParams;
    WABIMPORTPARAM wabImportParam;
    HRESULT hr;
    PCTSTR srcIdentity;
    PCTSTR destIdentity;
    PCTSTR destNode;
    BOOL fNewOE = FALSE;

    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        (IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE4_APPDETECT) ||
         IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT))) {
        //
        // Get the source WAB filename
        //
        lpWABObjectName = IsmCreateObjectHandle (TEXT("HKCU\\Software\\Microsoft\\WAB\\WAB4\\Wab File Name"), TEXT(""));
        if (IsmAcquireObject (g_RegType | PLATFORM_SOURCE,
                              lpWABObjectName,
                              &objectContent)) {
            if (IsValidRegSz (&objectContent)) {
                objectName = TurnFileStringIntoHandle ((PCTSTR)objectContent.MemoryContent.ContentBytes,
                                                       PFF_NO_PATTERNS_ALLOWED);
                filteredName = IsmFilterObject (g_FileType | PLATFORM_SOURCE,
                                                objectName,
                                                NULL,
                                                NULL,
                                                NULL);
                if (filteredName) {
                    IsmCreateObjectStringsFromHandle (filteredName, &srcNode, &srcLeaf);
                    IsmDestroyObjectHandle (filteredName);
                } else {
                    IsmCreateObjectStringsFromHandle (objectName, &srcNode, &srcLeaf);
                }
                srcFile = JoinPaths (srcNode, srcLeaf);

                IsmDestroyObjectString (srcNode);
                IsmDestroyObjectString (srcLeaf);
                IsmDestroyObjectHandle (objectName);
            }
            IsmReleaseObject (&objectContent);
        }

        //
        // Get the dest WAB filename
        //
        if (srcFile) {
            if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION,
                                  lpWABObjectName,
                                  &objectContent)) {
                if (IsValidRegSz (&objectContent)) {
                    destFile = DuplicateText ((PCTSTR)objectContent.MemoryContent.ContentBytes);
                }
                IsmReleaseObject (&objectContent);
            }
        }

        if (destFile) {
            // If we are upgrading from an old WAB version, and the destination does not have
            // a new WAB already, then we need to supply a new filename to WABOpen
            if (StringIMatch (srcFile, destFile)) {
                fNewOE = TRUE;

                destPath = IsmExpandEnvironmentString (
                    PLATFORM_DESTINATION,
                    S_SYSENVVAR_GROUP,
                    TEXT("%UserProfile%\\Application Data\\Microsoft\\Address Book\\"),
                    NULL);

                FreeText (destFile);
                destFile = AllocText (TcharCount(destPath) + TcharCount(DEFAULTWAB) + 1);
                StringCopy (destFile, destPath);
                StringCat (destFile, DEFAULTWAB);

                if StringIMatch (srcFile, destFile) {
//                    Crud!  Now what?
                }
                if (!DoesFileExist (destPath)) {
                    BfCreateDirectory (destPath);
                }

                IsmReleaseMemory (destPath);

                // Set HKCU\Software\Microsoft\WAB\WAB4\Wab File Name [] = destFile
                ZeroMemory (&objectContent, sizeof(MIG_CONTENT));
                objectContent.ObjectTypeId = g_RegType;
                objectContent.Details.DetailsSize = sizeof(DWORD);
                objectContent.Details.DetailsData = IsmGetMemory (sizeof(DWORD));
                *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                objectContent.MemoryContent.ContentSize = SizeOfString (destFile);
                objectContent.MemoryContent.ContentBytes = IsmGetMemory (objectContent.MemoryContent.ContentSize);
                CopyMemory ((PVOID)objectContent.MemoryContent.ContentBytes,
                            destFile,
                            objectContent.MemoryContent.ContentSize);

                objectName = IsmCreateObjectHandle(TEXT("HKCU\\Software\\Microsoft\\WAB\\WAB4\\Wab File Name"),
                                                   TEXT(""));
                if (objectName) {
                    IsmReplacePhysicalObject (g_RegType, objectName, &objectContent);
                    IsmDestroyObjectHandle (objectName);
                }
                IsmReleaseMemory (objectContent.MemoryContent.ContentBytes);
                IsmReleaseMemory (objectContent.Details.DetailsData);
            }
        }

        if (destFile) {
            // Get the WAB32.DLL location
            wabKey = JoinPaths (TEXT("HKLM"), WAB_DLL_PATH_KEY);
            objectName = IsmCreateObjectHandle (wabKey, TEXT(""));
            FreePathString (wabKey);
            if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION,
                                  objectName,
                                  &objectContent)) {
                if (IsValidRegSz (&objectContent)) {
                    wabPath = DuplicateText ((PCTSTR)objectContent.MemoryContent.ContentBytes);
                }
                IsmReleaseObject (&objectContent);
            }
            IsmDestroyObjectHandle (objectName);
        }

        if (wabPath) {
            // Loadlibrary the DLL
            lib = LoadLibrary (wabPath);
            if (lib) {

                // Open the destination WAB
                lpfnWABOpen = (LPWABOPEN) GetProcAddress (lib, "WABOpen");
                if (lpfnWABOpen) {
                    ZeroMemory (&wabParams, sizeof (WAB_PARAM));
                    wabParams.cbSize = sizeof (WAB_PARAM);
                    if (!fNewOE) {
                        wabParams.ulFlags = WAB_ENABLE_PROFILES | MAPI_UNICODE;
                    }
#ifdef UNICODE
                    wabParams.szFileName = (PSTR) ConvertWtoA (destFile);
#else
                    wabParams.szFileName = (PSTR) destFile;
#endif
                    hr = lpfnWABOpen (&lpAdrBookWAB, &lpWABObject, &wabParams, 0);
#ifdef UNICODE
                    FreeConvertedStr (wabParams.szFileName);
#endif
                    if (hr == S_OK) {

                        // Import the source WAB
                        ZeroMemory (&wabImportParam, sizeof (WABIMPORTPARAM));
                        wabImportParam.cbSize = sizeof (WABIMPORTPARAM);
                        wabImportParam.lpAdrBook = lpAdrBookWAB;
#ifdef UNICODE
                        wabImportParam.lpszFileName = (PSTR) ConvertWtoA (srcFile);
#else
                        wabImportParam.lpszFileName = (PSTR) srcFile;
#endif
                        hr = lpWABObject->lpVtbl->Import (lpWABObject, (LPSTR)&wabImportParam);
#ifdef UNICODE
                    FreeConvertedStr (wabImportParam.lpszFileName);
#endif
                        if (hr == S_OK) {
                            if (!StringIMatch (srcFile, destFile)) {
                                // Delete the source WAB
                                DeleteFile (srcFile);
                            }
                        } else {
                            // Log a message that the user must manually import the WAB
                            LOG ((LOG_WARNING, (PCSTR) MSG_WAB_MERGE_FAILED, srcFile));
                        }

                        lpWABObject->lpVtbl->Release (lpWABObject);
                        lpAdrBookWAB->lpVtbl->Release (lpAdrBookWAB);
                    }
                }
                FreeLibrary (lib);
            }
        }

        if (srcFile) {
            FreePathString (srcFile);
        }
        if (destFile) {
            FreeText (destFile);
        }
        if (wabPath) {
            FreeText (wabPath);
        }
        if (lpWABObjectName) {
            IsmDestroyObjectHandle (lpWABObjectName);
        }
    }
}

PCTSTR
pBuildDefaultStoreRoot (
    IN      PCTSTR Guid,
    IN      BOOL GuidHasBrackets
    )
{
    PTSTR storeRoot = NULL;
    UINT charCount;

    // output should be "%UserProfile%\Local Settings\Application Data\Identities\{guid}\Microsoft\Outlook Express"

#define STOREBEGIN TEXT("%UserProfile%\\Local Settings\\Application Data\\Identities\\")
#define STOREEND   TEXT("\\Microsoft\\Outlook Express")


    storeRoot = AllocText(TcharCount(STOREBEGIN) +
                          TcharCount(Guid) +
                          TcharCount(STOREEND) +
                          (GuidHasBrackets ? 1 : 3));
    StringCopy (storeRoot, STOREBEGIN);
    if (FALSE == GuidHasBrackets) {
        StringCat (storeRoot, TEXT("{"));
    }
    StringCat (storeRoot, Guid);
    if (FALSE == GuidHasBrackets) {
        StringCat (storeRoot, TEXT("}"));
    }
    StringCat (storeRoot, STOREEND);

    return storeRoot;
}

BOOL
pOE5Import (
    IN     PCTSTR SourceDir,
    IN     PCTSTR DestDir,
    IN     PCTSTR DestIdentity
    )
{
    UUID uid;
    BOOL result = FALSE;
    PSTR szSrcPath;
    PSTR szDestPath;

    MIG_CONTENT dllObjectContent;
    MIG_OBJECTSTRINGHANDLE dllObjectName = NULL;
    PCTSTR dllExpPath = NULL;
    PTSTR dllTmpPath = NULL;
    IMailImport *mailImport = NULL;
    static LPOECREATE lpfnOE5SimpleCreate = NULL;
    static LPIMPORTSTORE lpfnImportMailStoreToGUID = NULL;
    static LPIMPORTNEWS lpfnImportNewsListToGUID = NULL;

    if (g_msoedll == NULL) {
        CoInitialize(NULL);
        g_CoInit = TRUE;

        dllObjectName = IsmCreateObjectHandle (TEXT("HKLM\\Software\\Microsoft\\Outlook Express"),
                                               TEXT("InstallRoot"));
        if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION,
                              dllObjectName,
                              &dllObjectContent)) {
            // dllObjectContent should be "%ProgramFiles%\\Outlook Express"

            if (IsValidRegSz (&dllObjectContent)) {
                dllExpPath = IsmExpandEnvironmentString(PLATFORM_DESTINATION,
                                                        S_SYSENVVAR_GROUP,
                                                        (PCTSTR)dllObjectContent.MemoryContent.ContentBytes,
                                                        NULL);
            }
            if (dllExpPath) {

                dllTmpPath = JoinPaths (dllExpPath, TEXT("oemiglib.dll"));
                if (dllTmpPath) {
                    g_oemiglib = LoadLibrary(dllTmpPath);
                    FreePathString (dllTmpPath);
                }

                dllTmpPath = JoinPaths (dllExpPath, TEXT("msoe.dll"));
                if (dllTmpPath) {
                    g_msoedll = LoadLibrary(dllTmpPath);
                    FreePathString (dllTmpPath);
                }

                IsmReleaseMemory (dllExpPath);
            }
            IsmReleaseObject (&dllObjectContent);
        }
        IsmDestroyObjectHandle (dllObjectName);

        if (g_msoedll && g_oemiglib) {
            lpfnOE5SimpleCreate = (LPOECREATE) GetProcAddress (g_oemiglib, "OE5SimpleCreate");
            lpfnImportMailStoreToGUID = (LPIMPORTSTORE) GetProcAddress (g_msoedll, "ImportMailStoreToGUID");
            lpfnImportNewsListToGUID = (LPIMPORTNEWS) GetProcAddress (g_msoedll, "ImportNewsListToGUID");
        }
    }

    if (DestDir) {
        if (lpfnOE5SimpleCreate &&
            lpfnImportMailStoreToGUID &&
            lpfnImportNewsListToGUID) {

            // Convert to GUID *
            if (pUuidFromBracketedString(DestIdentity, &uid)) {
#ifdef UNICODE
                szSrcPath = (PSTR) ConvertWtoA (SourceDir);
                szDestPath = (PSTR) ConvertWtoA (DestDir);
#else
                szSrcPath = (PSTR) SourceDir;
                szDestPath = (PSTR) DestDir;
#endif
                mailImport = lpfnOE5SimpleCreate(szSrcPath);

                if (mailImport) {
                    lpfnImportMailStoreToGUID(mailImport, &uid, szDestPath);
                    IMailImport_Release(mailImport);
                    mailImport = NULL;
                    result = TRUE;
                }

                lpfnImportNewsListToGUID (szSrcPath, &uid, szDestPath);
#ifdef UNICODE
                FreeConvertedStr (szSrcPath);
                FreeConvertedStr (szDestPath);
#endif
            }
        }
        if (SourceDir && DestDir) {
            // Copy source folder to dest folder, but never overwrite
            if (!DoesFileExist (DestDir)) {
                BfCreateDirectory (DestDir);
            }
            FiCopyAllFilesInTreeEx(SourceDir, DestDir, TRUE);
        }
    }

    return result;
}

//////////////////////////////////////////////////////////////////////////////////////
// OE5MergeStorefolders
// This cycles through every store folder and decides whether to just copy it to the
// destination or merge into an existing store folder in the destination
VOID
OE5MergeStoreFolders (
    VOID
    )
{
    TCHAR szGuid[37];
    MIG_OBJECTSTRINGHANDLE objectName = NULL;
    MIG_OBJECTSTRINGHANDLE filteredName = NULL;
    MIG_CONTENT objectContent;
    MIG_CONTENT destObjectContent;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    PTSTR srcStoreRoot = NULL;
    PCTSTR destStoreRoot = NULL;
    PCTSTR destFolderFile = NULL;
    PTSTR node;
    PTSTR leaf;
    PTSTR junk;
    PCTSTR expandedName = NULL;
    BOOL fImport;


    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT)) {

        // Enumerate each source Store Folder
        enumPattern = IsmCreateSimpleObjectPattern (
                          TEXT("HKCU\\Identities"),
                          TRUE,
                          TEXT("Store Root"),
                          FALSE);
        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
           do {
               fImport = FALSE;

               IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
               if (leaf && *leaf) {
                   if (IsmAcquireObject (g_RegType | PLATFORM_SOURCE, objectEnum.ObjectName, &objectContent)) {
                       if (IsValidRegSz (&objectContent)) {
                           expandedName = IsmExpandEnvironmentString (
                               PLATFORM_SOURCE,
                               S_SYSENVVAR_GROUP,
                               (PCTSTR)objectContent.MemoryContent.ContentBytes,
                               NULL);
                       }
                       if (expandedName) {
                           objectName = IsmCreateObjectHandle(expandedName, NULL);
                           IsmReleaseMemory (expandedName);
                           expandedName = NULL;
                       }

                       if (objectName) {
                           filteredName = IsmFilterObject (g_FileType | PLATFORM_SOURCE,
                                                            objectName,
                                                            NULL,
                                                            NULL,
                                                            NULL);

                           if (filteredName) {
                               IsmCreateObjectStringsFromHandle (filteredName, &srcStoreRoot, &junk);
                               // srcStoreRoot is now the source directory

                               IsmDestroyObjectHandle (filteredName);
                               filteredName = NULL;
                           } else {
                               IsmCreateObjectStringsFromHandle(objectName, &srcStoreRoot, &junk);
                           }

                           if (junk) {
                               IsmDestroyObjectString (junk);
                               junk = NULL;
                           }

                           IsmDestroyObjectHandle (objectName);
                           objectName = NULL;
                       }

                       // Now check to see if the dest Store Root previously existed
                       if (srcStoreRoot) {
                           filteredName = IsmFilterObject (g_RegType | PLATFORM_SOURCE,
                                                           objectEnum.ObjectName,
                                                           NULL,
                                                           NULL,
                                                           NULL);

                           // Extract GUID out of destination object name
                           _stscanf(filteredName ? filteredName : objectEnum.ObjectName,
                                    TEXT("%*[^{]{%[^}]"),
                                    szGuid);
                           // szGuid is now the destination identity guid, minus the {}

                           if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION,
                                                 filteredName ? filteredName : objectEnum.ObjectName,
                                                 &destObjectContent)) {
                               if (IsValidRegSz (&destObjectContent)) {
                                   destStoreRoot = IsmExpandEnvironmentString (
                                       PLATFORM_DESTINATION,
                                       S_SYSENVVAR_GROUP,
                                       (PCTSTR)destObjectContent.MemoryContent.ContentBytes,
                                       NULL);
                               }
                               if (destStoreRoot) {
                                   destFolderFile = JoinPaths(destStoreRoot, TEXT("folders.dbx"));
                               }
                               if (destFolderFile) {
                                   if ((!StringIMatch(srcStoreRoot, destStoreRoot)) &&
                                       (DoesFileExist(destFolderFile))) {
                                       fImport = TRUE;
                                   }
                                   FreePathString(destFolderFile);
                               }
                               IsmReleaseObject (&destObjectContent);
                           }
                       }

                       if (szGuid[0]) {
                           if (!fImport) {
                               // This is a FIRST migration, so set the dest store root to default
                               IsmReleaseMemory(destStoreRoot);
                               destStoreRoot = pBuildDefaultStoreRoot(szGuid, FALSE);

                               // Set [StoreRoot] = destStoreRoot
                               ZeroMemory (&destObjectContent, sizeof(MIG_CONTENT));
                               destObjectContent.ObjectTypeId = g_RegType;
                               destObjectContent.Details.DetailsSize = sizeof(DWORD);
                               destObjectContent.Details.DetailsData = IsmGetMemory (sizeof(DWORD));
                               *((PDWORD)destObjectContent.Details.DetailsData) = REG_EXPAND_SZ;
                               destObjectContent.MemoryContent.ContentSize = SizeOfString (destStoreRoot);
                               destObjectContent.MemoryContent.ContentBytes = (PBYTE)destStoreRoot;

                               IsmReplacePhysicalObject (g_RegType, 
                                                         filteredName ? filteredName : objectEnum.ObjectName, 
                                                         &destObjectContent);
                               IsmDestroyObjectHandle (objectName);

                               // expand environment on destStoreRoot
                               FreeText(destStoreRoot);

                               destStoreRoot = IsmExpandEnvironmentString (
                                   PLATFORM_DESTINATION,
                                   S_SYSENVVAR_GROUP,
                                   (PCTSTR)destObjectContent.MemoryContent.ContentBytes,
                                   NULL);

                               // Cleanup the objectContent we allocated
                               IsmReleaseMemory (destObjectContent.Details.DetailsData);
                           }

                           if (srcStoreRoot && destStoreRoot) {
                               if (!DoesFileExist (destStoreRoot)) {
                                   BfCreateDirectory (destStoreRoot);
                               }
                               pOE5Import(srcStoreRoot, destStoreRoot, szGuid);
                           }
                       }


                       if (filteredName) {
                           IsmDestroyObjectHandle(filteredName);
                           filteredName = NULL;
                       }

                       if (destStoreRoot) {
                           IsmReleaseMemory(destStoreRoot);
                           destStoreRoot = NULL;
                       }

                       if (srcStoreRoot) {
                           IsmDestroyObjectString (srcStoreRoot);
                           srcStoreRoot = NULL;
                       }

                       IsmReleaseObject (&objectContent);
                   }
                   IsmDestroyObjectString (leaf);
               }
               IsmDestroyObjectString (node);
           } while (IsmEnumNextObject (&objectEnum));

           // Remove temp folder
           expandedName = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, OETEMPDIR, NULL);
           if (expandedName) {
               FiRemoveAllFilesInTree (expandedName);
               IsmReleaseMemory (expandedName);
           } else {
               FiRemoveAllFilesInTree (OETEMPDIR);
           }
        }
        IsmDestroyObjectHandle (enumPattern);
    }
}

VOID
OE4MergeStoreFolder (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE regKey;
    MIG_OBJECTSTRINGHANDLE objectName = NULL;
    MIG_OBJECTSTRINGHANDLE filteredName;
    MIG_CONTENT objectContent;
    HANDLE h;
    PCTSTR srcStorePath = NULL;
    PCTSTR expPath = NULL;
    PTSTR destIdentity = NULL;
    PTSTR tmpStr = NULL;
    PTSTR tmpNode = NULL;
    PTSTR cmdLine = NULL;
    PCTSTR sid = NULL;
    DWORD exitCode;
    DWORD cmdLen;
    TCHAR tmpDir[MAX_PATH];
    PCTSTR destDir = NULL;

    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE4_APPDETECT)) {

        objectName = IsmCreateObjectHandle (TEXT("HKLM\\Software\\Microsoft\\Outlook Express"),
                                            TEXT("InstallRoot"));
        if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION,
                              objectName,
                              &objectContent)) {

            // objectContent should be "%ProgramFiles%\\Outlook Express"

            if (IsValidRegSz (&objectContent)) {
                tmpStr = JoinPaths (objectContent.MemoryContent.ContentBytes, TEXT("oemig50.exe"));

                // tmpStr should be "%ProgramFiles%\\OutlookExpress\\oemig50.exe"
                expPath = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, tmpStr, NULL);

                FreePathString (tmpStr);
            }
            IsmReleaseObject (&objectContent);
        }
        IsmDestroyObjectHandle (objectName);

        // Get the dest identity
        if (expPath) {
            destIdentity = OEGetDefaultId (PLATFORM_DESTINATION);
        }

        // Now get the source's Store Root
        if (destIdentity) {
            objectName = IsmCreateObjectHandle (TEXT("HKCU\\Software\\Microsoft\\Outlook Express"),
                                                TEXT("Store Root"));
            if (IsmAcquireObject (g_RegType | PLATFORM_SOURCE,
                                  objectName,
                                  &objectContent)) {
                if (IsValidRegSz (&objectContent)) {
                    IsmDestroyObjectHandle (objectName);
                    objectName = IsmCreateObjectHandle ((PCTSTR) objectContent.MemoryContent.ContentBytes,
                                                        NULL);
                    filteredName = IsmFilterObject (g_FileType | PLATFORM_SOURCE,
                                                    objectName,
                                                    NULL,
                                                    NULL,
                                                    NULL);
                    if (filteredName) {
                        IsmCreateObjectStringsFromHandle (filteredName, &srcStorePath, NULL);
                        IsmDestroyObjectHandle (filteredName);
                    } else {
                        IsmCreateObjectStringsFromHandle (objectName, &srcStorePath, NULL);
                    }
                }
                IsmReleaseObject (&objectContent);
            }
            IsmDestroyObjectHandle (objectName);
        }

        // Now grab a temporary place to stuff the upgraded files
        IsmGetTempDirectory(tmpDir, ARRAYSIZE(tmpDir));

        // Call the external upgrade exe
        if (srcStorePath != NULL &&
            expPath != NULL) {


            sid = IsmGetCurrentSidString();

            cmdLen =  TcharCount(expPath) + TcharCount(srcStorePath) + TcharCount(tmpDir) + 35;
            if (sid) {
                cmdLen += TcharCount(sid) + 6;
            }
            cmdLine = AllocText (cmdLen);
            StringCopy (cmdLine, expPath);
            StringCat (cmdLine, TEXT(" /type:V1+V4-V5 /src:"));  // 21
            StringCat (cmdLine, srcStorePath);
            StringCat (cmdLine, TEXT(" /dst:"));                 // 6
            StringCat (cmdLine, tmpDir);
            StringCat (cmdLine, TEXT(" /quiet"));                // 7
            if (sid) {
                StringCat (cmdLine, TEXT(" /key:"));             // (6)
                StringCat (cmdLine, sid);
            }

            LOG ((LOG_INFORMATION, (PCSTR) MSG_SPAWNING_PROCESS_INFO, cmdLine));

            h = StartProcess (cmdLine);
            if (h != NULL) {
                WaitForSingleObject (h, INFINITE);
                if (GetExitCodeProcess (h, &exitCode)) {
                    if ((exitCode != STILL_ACTIVE) && ((exitCode & 0xFFFF) != 800 )) {
                        LOG ((LOG_ERROR, (PCSTR)MSG_OE4_UPGRADE_FAILED));
                    }
                }
                CloseHandle (h);

                FreeText (cmdLine);

                // Cleanup the source store
                FiRemoveAllFilesInTree (srcStorePath);
            }

            destDir = pGetDestStoreRootForId(destIdentity);
            if (destDir) {
                if (!DoesFileExist (destDir)) {
                    // Just copy into to the dest dir
                    BfCreateDirectory (destDir);
                    FiCopyAllFilesInTreeEx(tmpDir, destDir, TRUE);
                } else {
                    // Now do an OE5 Import from tmpDir to destIdentity
                    pOE5Import(tmpDir, destDir, destIdentity);
                }
                FreeText(destDir);
            }
            FiRemoveAllFilesInTree (tmpDir);

            // Set [StoreMigratedV5] = 1
            // Set [ConvertedToDBX] = 1
            tmpStr = JoinText(TEXT("HKCU\\Identities\\"), destIdentity);
            if (tmpStr) {
                tmpNode = JoinText(tmpStr, TEXT("\\Software\\Microsoft\\Outlook Express\\5.0"));
                if (tmpNode) {
                    CreateDwordRegObject (tmpNode, TEXT("StoreMigratedV5"), 1);
                    CreateDwordRegObject (tmpNode, TEXT("ConvertedToDBX"), 1);
                    FreeText(tmpNode);
                }

                FreeText(tmpStr);
            }
        }

        if (destIdentity) {
            FreeText(destIdentity);
        }
        if (sid) {
            IsmReleaseMemory (sid);
        }
        if (expPath) {
            IsmReleaseMemory (expPath);
        }
        if (srcStorePath) {
            IsmDestroyObjectString (srcStorePath);
        }
    }
}

BOOL
OEIAMAssociateId (
    IN      PTSTR SrcId
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_OBJECTTYPEID objectTypeId;
    MIG_CONTENT objectContent;
    PTSTR srcStr;
    TCHAR *p;
    UUID srcUUID;
    RPC_STATUS status;
    BOOL retval = FALSE;
    DWORD regType = REG_BINARY;

    if (pUuidFromBracketedString (SrcId, &srcUUID)) {
        // Create [AssociatedID] = Uuid

        objectTypeId = g_RegType | PLATFORM_DESTINATION;

        ZeroMemory(&objectContent, sizeof(MIG_CONTENT));

        objectContent.ContentInFile = FALSE;
        objectContent.MemoryContent.ContentSize = sizeof(UUID);
        objectContent.MemoryContent.ContentBytes = IsmGetMemory(sizeof(UUID));
        CopyMemory ((PVOID)objectContent.MemoryContent.ContentBytes, &srcUUID, sizeof(UUID));
        objectContent.Details.DetailsData = &regType;

        objectName = IsmCreateObjectHandle (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager\\Accounts"),
                                            TEXT("AssociatedID"));
        if (objectName) {
            retval = IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
            IsmDestroyObjectHandle (objectName);
            g_DestAssociatedId = DuplicateText(SrcId);
        }

        IsmReleaseMemory (objectContent.MemoryContent.ContentBytes);
    }
    return retval;
}

BOOL
OEIsIdentityAssociated (
    IN      PTSTR IdStr
    )
{
    BOOL associated = FALSE;

    if (!g_DestAssociatedId) {
        g_DestAssociatedId = OEGetAssociatedId(PLATFORM_DESTINATION);
    }

    if (g_DestAssociatedId) {
        associated = StringIMatch(IdStr, g_DestAssociatedId);
    } else {
        // Apparently there is no associated ID.  Let's claim it.
        OEIAMAssociateId(IdStr);
        associated = TRUE;
    }
    return associated;
}

PTSTR
OEGetRemappedId(
    IN      PCTSTR IdStr
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_OBJECTSTRINGHANDLE filteredName;
    PTSTR tmpName;
    PTSTR node;
    PTSTR leaf;
    PTSTR result = NULL;
    TCHAR *p;

    tmpName = JoinText(TEXT("HKCU\\Identities\\"), IdStr);
    if (tmpName) {
        objectName = IsmCreateObjectHandle(tmpName, NULL);
        if (objectName) {
            filteredName = IsmFilterObject(g_RegType | PLATFORM_SOURCE,
                                           objectName,
                                           NULL,
                                           NULL,
                                           NULL);
            if (filteredName) {
                IsmCreateObjectStringsFromHandle (filteredName, &node, &leaf);
                if (node) {
                    p = (PTSTR)FindLastWack(node);
                    if (p) {
                        result = DuplicateText(_tcsinc(p));
                    }
                    IsmDestroyObjectString(node);
                }
                if (leaf) {
                    IsmDestroyObjectString (leaf);
                }
                IsmDestroyObjectHandle(filteredName);
            } else {
                result = DuplicateText(IdStr);
            }
            IsmDestroyObjectHandle (objectName);
        }
        FreeText(tmpName);
    }
    return result;
}

PTSTR
OEGetDefaultId (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    PTSTR retval = NULL;


    objectName = IsmCreateObjectHandle (TEXT("HKCU\\Identities"),
                                        TEXT("Default User ID"));
    if (objectName) {
        if (IsmAcquireObject ( g_RegType | Platform, objectName, &objectContent)) {
            if (IsValidRegSz(&objectContent)) {
                retval = DuplicateText((PTSTR)objectContent.MemoryContent.ContentBytes);
            }
            IsmReleaseObject (&objectContent);
        }
        IsmDestroyObjectHandle (objectName);
    }
    return retval;
}

PTSTR
OEGetAssociatedId (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    PTSTR uuidStr;
    PTSTR retval = NULL;

    objectName = IsmCreateObjectHandle (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager\\Accounts"),
                                        TEXT("AssociatedID"));
    if (objectName) {
        if (IsmAcquireObject ( g_RegType | Platform, objectName, &objectContent)) {
            if (IsValidRegType(&objectContent, REG_BINARY)) {
                if (RPC_S_OK == UuidToString ((UUID *)objectContent.MemoryContent.ContentBytes, &uuidStr)) {
                   retval = AllocText(CharCount(uuidStr) + 3);
                   if (retval) {
                       StringCopy(retval, TEXT("{"));
                       StringCat(retval, uuidStr);
                       StringCat(retval, TEXT("}"));
                   }
                   RpcStringFree(&uuidStr);
                }
            }
            IsmReleaseObject (&objectContent);
        }
        IsmDestroyObjectHandle (objectName);
    }

    return retval;
}

VOID
OETerminate (
    VOID
    )
{
    if (g_DestAssociatedId) {
        FreeText(g_DestAssociatedId);
    }
    if (g_msoedll) {
        FreeLibrary(g_msoedll);
        g_msoedll = NULL;
    }
    if (g_oemiglib) {
        FreeLibrary(g_oemiglib);
        g_oemiglib = NULL;
    }
    if (g_CoInit) {
        CoUninitialize();
        g_CoInit = FALSE;
    }

}

pRenameRegTreePattern (
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      PCMIG_BLOB SrcBlob,
    IN      PCMIG_BLOB DestBlob,
    IN      BOOL ReplaceOld
)
{
    MIG_OBJECT_ENUM objectEnum;

    if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, Pattern)) {
        if (!g_RenameOp) {
            g_RenameOp = IsmRegisterOperation (S_OPERATION_MOVE, FALSE);
        }

        do {
            // Set operation on all source objects in this ID
            if (ReplaceOld) {
                IsmClearOperationOnObject(g_RegType | PLATFORM_SOURCE,
                                          objectEnum.ObjectName,
                                          g_RenameOp);
            }
            IsmSetOperationOnObject(g_RegType | PLATFORM_SOURCE,
                                    objectEnum.ObjectName,
                                    g_RenameOp,
                                    SrcBlob,
                                    DestBlob);
        } while (IsmEnumNextObject(&objectEnum));
    }
}

pRenameRegTree (
    IN      PCTSTR SrcIdName,
    IN      PCTSTR DestIdName,
    IN      BOOL ReplaceOld
)
{
    MIG_BLOB srcBlob;
    MIG_BLOB destBlob;
    MIG_OBJECTSTRINGHANDLE pattern;


    srcBlob.Type = BLOBTYPE_STRING;
    srcBlob.String = IsmCreateObjectHandle(SrcIdName, NULL);
    if (srcBlob.String) {
        destBlob.Type = BLOBTYPE_STRING;
        destBlob.String = IsmCreateObjectHandle(DestIdName, NULL);
        if (destBlob.String) {

            // Recursive
            pattern = IsmCreateSimpleObjectPattern(SrcIdName, TRUE, NULL, TRUE);
            if (pattern) {
                pRenameRegTreePattern(pattern, &srcBlob, &destBlob, ReplaceOld);
                IsmDestroyObjectHandle(pattern);
            }

            // Now for the node's values
            pattern = IsmCreateSimpleObjectPattern(SrcIdName, FALSE, NULL, TRUE);
            if (pattern) {
                pRenameRegTreePattern(pattern, &srcBlob, &destBlob, ReplaceOld);
                IsmDestroyObjectHandle(pattern);
            }

            // Now for only the node itself
            pattern = IsmCreateSimpleObjectPattern(SrcIdName, FALSE, NULL, FALSE);
            if (pattern) {
                pRenameRegTreePattern(pattern, &srcBlob, &destBlob, ReplaceOld);
                IsmDestroyObjectHandle(pattern);
            }
            IsmDestroyObjectHandle(destBlob.String);
        }
        IsmDestroyObjectHandle(srcBlob.String);
    }
}

BOOL
pClearApply (
    IN      PCTSTR Node,
    IN      PCTSTR Leaf
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    BOOL result = FALSE;

    objectName = IsmCreateObjectHandle(Node, Leaf);
    if (objectName) {
        IsmClearApplyOnObject((g_RegType & (~PLATFORM_MASK)) | PLATFORM_SOURCE, objectName);
        IsmDestroyObjectHandle (objectName);
        result = TRUE;
    }

    return result;
}

BOOL
OE5RemapDefaultId (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE destObjectName;
    MIG_OBJECTSTRINGHANDLE pattern;
    MIG_CONTENT destIdObjectContent;
    PTSTR idName;
    PTSTR destIdName;
    PTSTR srcDefaultId;
    PTSTR destDefaultId;
    MIG_OBJECT_ENUM objectEnum;

    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT)) {

        srcDefaultId = OEGetDefaultId(PLATFORM_SOURCE);
        if (srcDefaultId) {
            destDefaultId = OEGetDefaultId(PLATFORM_DESTINATION);
            if (destDefaultId) {
                if (!StringIMatch (srcDefaultId, destDefaultId)) {
                    // different default IDs
                    idName = JoinText(TEXT("HKCU\\Identities\\"), srcDefaultId);
                    if (idName) {
                        destObjectName = IsmCreateObjectHandle(idName, NULL);
                        if (IsmAcquireObject(
                            g_RegType | PLATFORM_DESTINATION,
                            destObjectName,
                            &destIdObjectContent)) {

                            // The source ID already exists on the dest.. do nothing extra
                            IsmReleaseObject(&destIdObjectContent);
                        } else {
                            // Remap this identity into destination default
                            destIdName = JoinText(TEXT("HKCU\\Identities\\"),
                                                  destDefaultId);
                            if (destIdName) {
                                pRenameRegTree(idName, destIdName, TRUE);
                                FreeText(destIdName);
                            }
                            pClearApply(TEXT("HKCU\\Identities"), TEXT("Default User ID"));
                            pClearApply(TEXT("HKCU\\Identities"), TEXT("Last User ID"));
                            pClearApply(TEXT("HKCU\\Identities"), TEXT("Last Username"));

                            // ForceDestReg the top level Identities values
                            pattern = IsmCreateSimpleObjectPattern(idName, FALSE, NULL, TRUE);
                            if (pattern) {
                                if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, pattern)) {
                                    do {
                                        IsmClearApplyOnObject(
                                            (g_RegType & (~PLATFORM_MASK)) | PLATFORM_SOURCE,
                                            objectEnum.ObjectName);
                                    } while (IsmEnumNextObject(&objectEnum));
                                }
                                IsmDestroyObjectHandle(pattern);
                            }
                        }
                        IsmDestroyObjectHandle(destObjectName);
                        FreeText(idName);
                    }
                }
                FreeText(destDefaultId);
            }
            FreeText(srcDefaultId);
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////
// pOE5RemapRules
// This adds a renregfn rule for \ConvertOE5MailRules to
//     HKCU\Identities\{*}\Software\Microsoft\Outlook Express\5.0\Rules\Mail\*
// ditto for News rules
// Also for Block Senders\Mail\Criteria\* and News
BOOL
pOE5RemapRules (
    VOID
    )
{
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    MIG_OBJECTSTRINGHANDLE subPattern;
    PTSTR tmpNode;
    PTSTR node;
    PTSTR leaf;

    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT)) {

        // Find HKCU\Identities\{*}\Software\Microsoft\Outlook Express\5.0\Rules\Mail\*
        // First enum each identity
        enumPattern = IsmCreateSimpleObjectPattern (TEXT("HKCU\\Identities"), TRUE,
                                                    TEXT("User ID"), FALSE);
        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
           do {
               IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
               if (node && leaf) {
                   // Enum the Rules keys under this identity
                   tmpNode = JoinText(node, TEXT("\\Software\\Microsoft\\Outlook Express\\5.0\\Rules\\Mail"));
                   if (tmpNode) {
                       subPattern = IsmCreateSimpleObjectPattern (tmpNode, TRUE, NULL, TRUE);
                       if (subPattern) {
                           AddSpecialRenameRule (subPattern, TEXT("\\ConvertOE5MailRules"));
                           IsmDestroyObjectHandle(subPattern);
                       }
                       FreeText(tmpNode);
                   }
                   tmpNode = JoinText(node, TEXT("\\Software\\Microsoft\\Outlook Express\\5.0\\Rules\\News"));
                   if (tmpNode) {
                       subPattern = IsmCreateSimpleObjectPattern (tmpNode, TRUE, NULL, TRUE);
                       if (subPattern) {
                           AddSpecialRenameRule (subPattern, TEXT("\\ConvertOE5NewsRules"));
                           IsmDestroyObjectHandle(subPattern);
                       }
                       FreeText(tmpNode);
                   }
                   tmpNode = JoinText(
                       node,
                       TEXT("\\Software\\Microsoft\\Outlook Express\\5.0\\Block Senders\\Mail\\Criteria")
                       );
                   if (tmpNode) {
                       subPattern = IsmCreateSimpleObjectPattern (tmpNode, TRUE, NULL, TRUE);
                       if (subPattern) {
                           AddSpecialRenameRule (subPattern, TEXT("\\ConvertOE5Block"));
                           IsmDestroyObjectHandle(subPattern);
                       }
                       FreeText(tmpNode);
                   }
                   tmpNode = JoinText(
                       node,
                       TEXT("\\Software\\Microsoft\\Outlook Express\\5.0\\Block Senders\\News\\Criteria")
                       );
                   if (tmpNode) {
                       subPattern = IsmCreateSimpleObjectPattern (tmpNode, TRUE, NULL, TRUE);
                       if (subPattern) {
                           AddSpecialRenameRule (subPattern, TEXT("\\ConvertOE5Block"));
                           IsmDestroyObjectHandle(subPattern);
                       }
                       FreeText(tmpNode);
                   }
               }
               IsmDestroyObjectString(node);
               if (leaf) {
                   IsmDestroyObjectString(leaf);
               }
           } while (IsmEnumNextObject (&objectEnum));
        }
        IsmDestroyObjectHandle (enumPattern);
    }
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// pOE5RemapAccounts
// This adds a renregfn rule for \ConvertOE5IdIAM to
//     HKCU\Identities\{*}\Software\Microsoft\Internet Account Manager\*
BOOL
pOE5RemapAccounts (
    VOID
    )
{
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    MIG_OBJECTSTRINGHANDLE subPattern;
    PTSTR tmpNode;
    PTSTR node;
    PTSTR leaf;

    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT)) {

        // Find HKCU\Identities\{*}\Software\Microsoft\Internet Account Manger\*
        // First enum each identity
        enumPattern = IsmCreateSimpleObjectPattern (TEXT("HKCU\\Identities"), TRUE,
                                                    TEXT("User ID"), FALSE);
        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
           do {
               IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
               if (node && leaf) {
                   // Enum the IAM keys under this identity
                   tmpNode = JoinText(node, TEXT("\\Software\\Microsoft\\Internet Account Manager"));
                   if (tmpNode) {
                       subPattern = IsmCreateSimpleObjectPattern (tmpNode, TRUE, NULL, TRUE);
                       if (subPattern) {
                           AddSpecialRenameRule (subPattern, TEXT("\\ConvertOE5IdIAM"));
                           IsmDestroyObjectHandle(subPattern);
                       }
                       FreeText(tmpNode);
                   }
               }
               IsmDestroyObjectString(node);
               if (leaf) {
                   IsmDestroyObjectString(leaf);
               }
           } while (IsmEnumNextObject (&objectEnum));
        }
        IsmDestroyObjectHandle (enumPattern);
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////
// OECreateFirstIdentity
// This is used to create the very first identity for a user that we just created
PTSTR
OECreateFirstIdentity (
    VOID
    )
{
    PTSTR destID = NULL;
    PTSTR uuidStr;
    UUID uuid;
    RPC_STATUS result;
    MIG_OBJECTSTRINGHANDLE objectName = NULL;
    MIG_CONTENT objectContent;
    PTSTR node;
    PCTSTR defaultStore;

    result = UuidCreate (&uuid);
    if (result == RPC_S_OK || result == RPC_S_UUID_LOCAL_ONLY) {
        result = UuidToString (&uuid, &uuidStr);
        if (result == RPC_S_OK) {
            destID = AllocText (CharCount (uuidStr) + 3);
            wsprintf (destID, TEXT("{%s}"), uuidStr);
            RpcStringFree (&uuidStr);
        }
    }
    if (destID) {
        // Create [Default User ID] = &destID
        ZeroMemory (&objectContent, sizeof(MIG_CONTENT));
        objectContent.ObjectTypeId = g_RegType;
        objectContent.Details.DetailsSize = sizeof(DWORD);
        objectContent.Details.DetailsData = IsmGetMemory (sizeof(DWORD));
        *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
        objectContent.MemoryContent.ContentSize = SizeOfString (destID);
        objectContent.MemoryContent.ContentBytes = IsmGetMemory (objectContent.MemoryContent.ContentSize);
        CopyMemory ((PVOID)objectContent.MemoryContent.ContentBytes, destID, objectContent.MemoryContent.ContentSize);

        objectName = IsmCreateObjectHandle(TEXT("HKCU\\Identities"), TEXT("Default User ID"));
        if (objectName) {
            IsmReplacePhysicalObject (g_RegType, objectName, &objectContent);
            IsmDestroyObjectHandle (objectName);
            objectName = NULL;
        }

        // Set [Last User ID] = &destID
        objectName = IsmCreateObjectHandle(TEXT("HKCU\\Identities"), TEXT("Last User ID"));
        if (objectName) {
            IsmReplacePhysicalObject (g_RegType, objectName, &objectContent);
            IsmDestroyObjectHandle (objectName);
            objectName = NULL;
        }
        // Create [User ID] = &destID
        node = AllocText (17 + CharCount (destID));
        if (node) {
            wsprintf (node, TEXT("HKCU\\Identities\\%s"), destID);
            objectName = IsmCreateObjectHandle(node,  TEXT("User ID"));
            FreeText (node);
        }
        if (objectName) {
            IsmReplacePhysicalObject (g_RegType, objectName, &objectContent);
            IsmDestroyObjectHandle (objectName);
            objectName = NULL;
        }

        IsmReleaseMemory (objectContent.MemoryContent.ContentBytes);

        // Set [Store Root] = %UserProfile%\Local Settings\Application Data\Identities\&destID\Microsoft\Outlook Express
        defaultStore = pBuildDefaultStoreRoot(destID, TRUE);
        if (defaultStore) {
            objectContent.MemoryContent.ContentBytes = (PCBYTE)defaultStore;
            objectContent.MemoryContent.ContentSize = SizeOfString(defaultStore);
            *((PDWORD)objectContent.Details.DetailsData) = REG_EXPAND_SZ;

            node = AllocText (56 + CharCount (destID));
            if (node) {
                wsprintf (node, TEXT("HKCU\\Identities\\%s\\Software\\Microsoft\\Outlook Express\\5.0"), destID);
                objectName = IsmCreateObjectHandle(node, TEXT("Store Root"));
                FreeText (node);
            }
            if (objectName) {
                IsmReplacePhysicalObject (g_RegType, objectName, &objectContent);
                IsmDestroyObjectHandle (objectName);
            }
            FreeText(defaultStore);
        }
        IsmReleaseMemory (objectContent.Details.DetailsData);

        OEIAMAssociateId (destID);
    }

    return destID;
}


//////////////////////////////////////////////////////////////////////////////////////
// OEInitializeIdentity
// This is used to initialize a destination identity that has been created but never used.
BOOL
OEInitializeIdentity (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE storeRootKey = NULL;
    MIG_CONTENT objectContent;
    PCTSTR defaultId;
    PCTSTR defaultStoreRoot;
    BOOL reinit = TRUE;

    defaultId = OEGetDefaultId (PLATFORM_DESTINATION);
    if (defaultId) {
        storeRootKey = pBuildStoreRootKeyForId (defaultId);
        if (storeRootKey) {
            if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION, storeRootKey, &objectContent)) {
                if (IsValidRegSz(&objectContent)) {
                    reinit = FALSE;
                }
                IsmReleaseObject (&objectContent);
            }

            if (reinit) {
                defaultStoreRoot = pBuildDefaultStoreRoot (defaultId, TRUE);
                if (defaultStoreRoot) {
                    ZeroMemory (&objectContent, sizeof(MIG_CONTENT));
                    objectContent.ObjectTypeId = g_RegType;
                    objectContent.Details.DetailsSize = sizeof(DWORD);
                    objectContent.Details.DetailsData = IsmGetMemory (sizeof(DWORD));
                    *((PDWORD)objectContent.Details.DetailsData) = REG_EXPAND_SZ;
                    objectContent.MemoryContent.ContentSize = SizeOfString (defaultStoreRoot);
                    objectContent.MemoryContent.ContentBytes = (PBYTE)defaultStoreRoot;

                    IsmReplacePhysicalObject (g_RegType, storeRootKey, &objectContent);

                    IsmReleaseMemory (objectContent.Details.DetailsData);
                    FreeText(defaultStoreRoot);
                }
            }
            IsmDestroyObjectHandle(storeRootKey);
        }
        FreeText(defaultId);
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////
// pOE5RemapStores
// This is used to set a special RegFolder rule for the OE5 [Store Root] values
// The rule will redirect all store folders into a temporary directory.  Later,
// OE5MergeStorefolders will decide whether to copy or merge them into the proper
// location on the destination
BOOL
pOE5RemapStores (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE enumPattern;
    MIG_OBJECT_ENUM objectEnum;
    PTSTR node;
    PTSTR leaf;
    TCHAR tmpDir[MAX_PATH];
    BOOL result = FALSE;
    ACTION_STRUCT actionStruct;
    DWORD index = 0;

    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT)) {

        // Find HKCU\Identities\* [Store Root]
        // First enum each identity
        enumPattern = IsmCreateSimpleObjectPattern (TEXT("HKCU\\Identities"), TRUE,
                                                    TEXT("Store Root"), FALSE);
        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
           do {
               IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
               if (node && leaf) {
                   // Regfolder the rule with a destination to a unique TEMP directory
                   // Grab a temporary place to copy the mail store
                   wsprintf(tmpDir, TEXT("%s\\%03x"), OETEMPDIR, index++);

                   ZeroMemory(&actionStruct, sizeof(ACTION_STRUCT));
                   actionStruct.ObjectBase = objectEnum.ObjectName;
                   actionStruct.AddnlDest = TurnFileStringIntoHandle (
                                tmpDir,
                                PFF_COMPUTE_BASE|
                                    PFF_NO_SUBDIR_PATTERN|
                                    PFF_NO_PATTERNS_ALLOWED|
                                    PFF_NO_LEAF_AT_ALL
                                );
                   result = AddRule (g_RegType,
                                     objectEnum.ObjectName,
                                     objectEnum.ObjectName,
                                     ACTIONGROUP_REGFOLDER,
                                     ACTION_PERSIST_PATH_IN_DATA,
                                     &actionStruct);
               }
               IsmDestroyObjectString(node);
               if (leaf) {
                   IsmDestroyObjectString(leaf);
               }
           } while (IsmEnumNextObject (&objectEnum));
        }
        IsmDestroyObjectHandle (enumPattern);
    }
    return result;
}

BOOL
OEAddComplexRules (
    VOID
    )
{
    pOE5RemapRules();
    pOE5RemapAccounts();
    pOE5RemapStores();
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////
// OEFixLastUser
// If for some reason the [Last User ID] value is set to zeroes or does not exist,
// we'll copy in the [Default User ID] value.  If we dont do this, we'll get a popup
// asking the user to select an identity, which would be really bad.
BOOL
OEFixLastUser (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    MIG_OBJECTSTRINGHANDLE defName;
    MIG_CONTENT defContent;
    BOOL fFix = FALSE;

    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        (IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE4_APPDETECT) ||
         IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT))) {

        objectName = IsmCreateObjectHandle (TEXT("HKCU\\Identities"), TEXT("Last User ID"));
        if (objectName) {
            if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION, objectName, &objectContent)) {
                if (IsValidRegSz(&objectContent) &&
                    StringMatch((PCTSTR)objectContent.MemoryContent.ContentBytes,
                                TEXT("{00000000-0000-0000-0000-000000000000}"))) {
                    fFix = TRUE;
                }
                IsmReleaseObject (&objectContent);
            } else {
                fFix = TRUE;
            }

            if (fFix) {
                defName = IsmCreateObjectHandle (TEXT("HKCU\\Identities"), TEXT("Default User ID"));
                if (defName) {
                    if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION, defName, &defContent)) {
                        if (IsValidRegSz (&defContent)) {
                            IsmReplacePhysicalObject (g_RegType, objectName, &defContent);
                        }
                        IsmReleaseObject (&defContent);
                    }
                    IsmDestroyObjectHandle (defName);
                }
            }
            IsmDestroyObjectHandle (objectName);
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\dgm.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dgm.c

Abstract:

    Implements the initialization/termination code for the data gather portion
    of scanstate v1 compatiblity.

Author:

    Calin Negreanu (calinn) 16-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

MIG_OPERATIONID g_DestAddObject;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

DGMINITIALIZE ScriptDgmInitialize;
DGMQUEUEENUMERATION ScriptDgmQueueEnumeration;

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
WINAPI
ScriptDgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    TCHAR userName[256];
    TCHAR domainName[256];

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    if (IsmIsEnvironmentFlagSet (PLATFORM_DESTINATION, NULL, S_ENV_CREATE_USER)) {

        if (!IsmGetEnvironmentString (
                PLATFORM_SOURCE,
                S_SYSENVVAR_GROUP,
                TEXT("USERNAME"),
                userName,
                sizeof (userName),
                NULL
                )) {
            IsmSetCancel();
            SetLastError (ERROR_INVALID_DATA);
            LOG ((LOG_ERROR, (PCSTR) MSG_USER_REQUIRED));
            return FALSE;
        }

        if (!IsmGetEnvironmentString (
                PLATFORM_SOURCE,
                S_SYSENVVAR_GROUP,
                TEXT("USERDOMAIN"),
                domainName,
                sizeof (domainName),
                NULL
                )) {
            IsmSetCancel();
            SetLastError (ERROR_INVALID_DOMAINNAME);
            LOG ((LOG_ERROR, (PCSTR) MSG_DOMAIN_REQUIRED));
            return FALSE;
        }

        LOG ((LOG_INFORMATION, (PCSTR) MSG_PROFILE_CREATE_INFO, domainName, userName));

        if (!IsmCreateUser (userName, domainName)) {
            IsmSetCancel();
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
pParseDestinationDetect (
    IN      HINF InfHandle
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    BOOL result = FALSE;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    GROWBUFFER appList = INIT_GROWBUFFER;
    PCTSTR displayName = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    PCTSTR appSection = NULL;
    BOOL detected = FALSE;
    BOOL appFound = FALSE;
    QUESTION_DATA questionData;
    ULONG_PTR appResult;
    PCTSTR loadedStr = NULL;

    __try {

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_CHECKDETECT,
                NULL,
                0,
                &sizeNeeded
                )) {
            result = TRUE;
            __leave;
        }

        if (!GbGrow (&multiSz, sizeNeeded)) {
            __leave;
        }

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_CHECKDETECT,
                (PTSTR) multiSz.Buf,
                multiSz.End,
                NULL
                )) {
            __leave;
        }

        loadedStr = GetStringResource (MSG_INSTALL_APPS1);
        if (loadedStr) {
            GbAppendString (&appList, loadedStr);
            FreeStringResource (loadedStr);
            loadedStr = NULL;
        }
        GbAppendString (&appList, TEXT("\n\n"));

        if (EnumFirstMultiSz (&e, (PCTSTR) multiSz.Buf)) {

            do {

                // e.CurrentString is the actual section that we need to execute
                // we are going to append a .DETECT to it though

                appSection = JoinText (e.CurrentString, TEXT(".Detect"));
                detected = ParseAppDetectSection (PLATFORM_DESTINATION, InfHandle, e.CurrentString, appSection);
                if (!detected) {
                    // let's try to find the display name for this app
                    if (InfFindFirstLine (InfHandle, TEXT("Strings"), e.CurrentString, &is)) {
                        displayName = InfGetStringField (&is, 1);
                    }
                    if (!displayName) {
                        displayName = e.CurrentString;
                    }
                    if (displayName) {
                        appFound = TRUE;
                        GbAppendString (&appList, TEXT("- "));
                        GbAppendString (&appList, displayName);
                        GbAppendString (&appList, TEXT("\n"));
                        LOG ((LOG_WARNING, (PCSTR) MSG_APP_NOT_DETECTED, displayName));
                    }
                }
                FreeText (appSection);
                appSection = NULL;
                GlFree (&g_SectionStack);

            } while (EnumNextMultiSz (&e));
        }

        result = TRUE;
    }
    __finally {

        GbFree (&multiSz);
        InfCleanUpInfStruct (&is);

    }

    // now, if we have something in our app list, we will send it to the wizard, so he can
    // prompt the user about it.
    if (appFound) {
        GbAppendString (&appList, TEXT("\n"));
        loadedStr = GetStringResource (MSG_INSTALL_APPS2);
        if (loadedStr) {
            GbAppendString (&appList, loadedStr);
            FreeStringResource (loadedStr);
            loadedStr = NULL;
        }
        GbAppendString (&appList, TEXT("\n"));

        // we have some applications that were not detected. Let's tell the wizard about them
        ZeroMemory (&questionData, sizeof (QUESTION_DATA));
        questionData.Question = (PCTSTR)appList.Buf;
        questionData.MessageStyle = MB_ICONWARNING | MB_OKCANCEL;
        questionData.WantedResult = IDOK;
        appResult = IsmSendMessageToApp (MODULEMESSAGE_ASKQUESTION, (ULONG_PTR)(&questionData));
        if (appResult != APPRESPONSE_SUCCESS) {
            // the user cancelled
            IsmSetCancel ();
        }
    }

    GbFree (&appList);

    return result;
}

UINT
pSuppressDestinationSettings (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    IsmMakeApplyObject (
        Data->ObjectTypeId,
        Data->ObjectName
        );
    IsmSetOperationOnObject (
        Data->ObjectTypeId,
        Data->ObjectName,
        g_DeleteOp,
        NULL,
        NULL
        );
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
pParseInfForExclude (
    IN      HINF InfHandle
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR pattern;
    ENCODEDSTRHANDLE srcHandle = NULL;
    ENCODEDSTRHANDLE srcBase = NULL;
    BOOL result = FALSE;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    BOOL hadLeaf = FALSE;

    __try {

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_DELREG,
                NULL,
                0,
                &sizeNeeded
                )) {
            result = TRUE;
            __leave;
        }

        if (!GbGrow (&multiSz, sizeNeeded)) {
            __leave;
        }

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_DELREG,
                (PTSTR) multiSz.Buf,
                multiSz.End,
                NULL
                )) {
            __leave;
        }

        if (EnumFirstMultiSz (&e, (PCTSTR) multiSz.Buf)) {

            do {

                // on all systems, process "DestDelRegEx"
                if (InfFindFirstLine (InfHandle, e.CurrentString, NULL, &is)) {
                    do {

                        if (IsmCheckCancel()) {
                            __leave;
                        }

                        pattern = InfGetStringField (&is, 0);

                        if (!pattern) {
                            LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_REG_SPEC));
                            continue;
                        }

                        srcHandle = TurnRegStringIntoHandle (pattern, TRUE, &hadLeaf);
                        if (!srcHandle) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, pattern));
                            continue;
                        }

                        if (!hadLeaf) {
                            srcBase = TurnRegStringIntoHandle (pattern, FALSE, NULL);
                            if (!srcBase) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, pattern));
                                continue;
                            }

                            IsmQueueEnumeration (
                                g_RegType,
                                srcBase,
                                pSuppressDestinationSettings,
                                0,
                                NULL
                                );
                        }

                        IsmQueueEnumeration (
                            g_RegType,
                            srcHandle,
                            pSuppressDestinationSettings,
                            0,
                            NULL
                            );
                        IsmDestroyObjectHandle (srcHandle);
                        srcHandle = NULL;

                    } while (InfFindNextLine (&is));
                }
            } while (EnumNextMultiSz (&e));
        }

        result = TRUE;
    }
    __finally {

        GbFree (&multiSz);
        InfCleanUpInfStruct (&is);

    }

    return result;
}

BOOL
pParseInfForExcludeEx (
    IN      HINF InfHandle
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR srcNode;
    PCTSTR srcLeaf;
    ENCODEDSTRHANDLE srcHandle = NULL;
    ENCODEDSTRHANDLE srcBase = NULL;
    BOOL result = FALSE;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    BOOL hadLeaf = FALSE;

    __try {

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_DELREGEX,
                NULL,
                0,
                &sizeNeeded
                )) {
            result = TRUE;
            __leave;
        }

        if (!GbGrow (&multiSz, sizeNeeded)) {
            __leave;
        }

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_DELREGEX,
                (PTSTR) multiSz.Buf,
                multiSz.End,
                NULL
                )) {
            __leave;
        }

        if (EnumFirstMultiSz (&e, (PCTSTR) multiSz.Buf)) {

            do {

                // on all systems, process "DestDelReg"
                if (InfFindFirstLine (InfHandle, e.CurrentString, NULL, &is)) {
                    do {

                        if (IsmCheckCancel()) {
                            __leave;
                        }

                        srcNode = InfGetStringField (&is, 1);
                        srcLeaf = InfGetStringField (&is, 2);

                        if (!srcNode && !srcLeaf) {
                            LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_REG_SPEC));
                            continue;
                        }

                        // Validate rule
                        if (!StringIMatchTcharCount (srcNode, S_HKLM, ARRAYSIZE(S_HKLM) - 1) &&
                            !StringIMatchTcharCount (srcNode, S_HKR, ARRAYSIZE(S_HKR) - 1) &&
                            !StringIMatchTcharCount (srcNode, S_HKCC, ARRAYSIZE(S_HKCC) - 1)
                            ) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_REGROOT, srcNode));
                            __leave;
                        }

                        srcHandle = CreatePatternFromNodeLeaf (srcNode, srcLeaf);
                        if (!srcHandle) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, srcNode));
                            __leave;
                        }

                        if (!hadLeaf) {
                            srcBase = MakeRegExBase (srcNode, srcLeaf);
                            if (!srcBase) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, srcNode));
                                continue;
                            }

                            IsmQueueEnumeration (
                                g_RegType,
                                srcBase,
                                pSuppressDestinationSettings,
                                0,
                                NULL
                                );
                        }

                        IsmQueueEnumeration (
                            g_RegType,
                            srcHandle,
                            pSuppressDestinationSettings,
                            0,
                            NULL
                            );
                        IsmDestroyObjectHandle (srcHandle);
                        srcHandle = NULL;

                    } while (InfFindNextLine (&is));
                }
            } while (EnumNextMultiSz (&e));
        }

        result = TRUE;
    }
    __finally {

        GbFree (&multiSz);
        InfCleanUpInfStruct (&is);

    }

    return result;
}

BOOL
pParseInfForDestAdd (
    IN      HINF InfHandle
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR objectTypeName;
    UINT objectPriority;
    MIG_OBJECTTYPEID objectTypeId;
    PCTSTR objectMultiSz;
    MIG_CONTENT objectContent;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_OBJECTID objectId;
    MIG_CONTENT existentContent;
    MIG_BLOB blob;
    MIG_DATAHANDLE dataHandle;
    BOOL added = FALSE;
    BOOL result = FALSE;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    MULTISZ_ENUM e;
    UINT sizeNeeded;

    __try {

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_ADDOBJECT,
                NULL,
                0,
                &sizeNeeded
                )) {
            result = TRUE;
            __leave;
        }

        if (!GbGrow (&multiSz, sizeNeeded)) {
            __leave;
        }

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_ADDOBJECT,
                (PTSTR) multiSz.Buf,
                multiSz.End,
                NULL
                )) {
            __leave;
        }

        if (EnumFirstMultiSz (&e, (PCTSTR) multiSz.Buf)) {

            do {

                // on all systems, process "DestAddObject"
                if (InfFindFirstLine (InfHandle, e.CurrentString, NULL, &is)) {
                    do {

                        if (IsmCheckCancel()) {
                            __leave;
                        }

                        objectTypeName = InfGetStringField (&is, 1);
                        if (!InfGetIntField (&is, 2, &objectPriority)) {
                            objectPriority = 0;
                        }

                        if (objectTypeName) {
                            objectTypeId = IsmGetObjectTypeId (objectTypeName);
                            if (objectTypeId) {
                                // let's read the object multi-sz
                                objectMultiSz = InfGetMultiSzField (&is, 3);

                                if (objectMultiSz) {
                                    if (IsmConvertMultiSzToObject (
                                            objectTypeId,
                                            objectMultiSz,
                                            &objectName,
                                            &objectContent
                                            )) {
                                        // finally we have the object
                                        // We need to:
                                        // 1. Verify that the destination object does not exist
                                        // 2. Add the destination object handle in ISMs database
                                        // 3. Set an operation on the object passing the objectContent
                                        //    as data

                                        added = FALSE;

                                        if (IsmAcquireObject (
                                                objectTypeId | PLATFORM_DESTINATION,
                                                objectName,
                                                &existentContent
                                                )) {
                                            if (objectPriority) {
                                                objectId = IsmGetObjectIdFromName (
                                                                objectTypeId | PLATFORM_DESTINATION,
                                                                objectName,
                                                                TRUE
                                                                );
                                                if (objectId) {
                                                    blob.Type = BLOBTYPE_BINARY;
                                                    blob.BinarySize = sizeof (objectContent);
                                                    blob.BinaryData = (PBYTE) &objectContent;
                                                    dataHandle = IsmRegisterOperationData (&blob);
                                                    if (dataHandle) {
                                                        IsmMakeApplyObjectId (objectId);
                                                        IsmSetOperationOnObjectId2 (
                                                            objectId,
                                                            g_DestAddObject,
                                                            0,
                                                            dataHandle
                                                            );
                                                        added = TRUE;
                                                    }
                                                }
                                            } else {
                                                IsmReleaseObject (&existentContent);
                                            }
                                        } else {
                                            objectId = IsmGetObjectIdFromName (
                                                            objectTypeId | PLATFORM_DESTINATION,
                                                            objectName,
                                                            FALSE
                                                            );
                                            if (objectId) {
                                                blob.Type = BLOBTYPE_BINARY;
                                                blob.BinarySize = sizeof (objectContent);
                                                blob.BinaryData = (PBYTE) &objectContent;
                                                dataHandle = IsmRegisterOperationData (&blob);
                                                if (dataHandle) {
                                                    IsmMakeApplyObjectId (objectId);
                                                    IsmSetOperationOnObjectId2 (
                                                        objectId,
                                                        g_DestAddObject,
                                                        0,
                                                        dataHandle
                                                        );
                                                    added = TRUE;
                                                }
                                            }
                                        }
                                        if (!added) {
                                            IsmDestroyObjectHandle (objectName);
                                            if (objectContent.ContentInFile) {
                                                if (objectContent.FileContent.ContentPath) {
                                                    IsmReleaseMemory (objectContent.FileContent.ContentPath);
                                                }
                                            } else {
                                                if (objectContent.MemoryContent.ContentBytes) {
                                                    IsmReleaseMemory (objectContent.MemoryContent.ContentBytes);
                                                }
                                            }
                                            if (objectContent.Details.DetailsData) {
                                                IsmReleaseMemory (objectContent.Details.DetailsData);
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    } while (InfFindNextLine (&is));
                }
            } while (EnumNextMultiSz (&e));
        }

        result = TRUE;
    }
    __finally {

        GbFree (&multiSz);
        InfCleanUpInfStruct (&is);

    }

    return result;
}

BOOL
pParseInfForExecute (
    IN      HINF InfHandle
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR time;
    PCTSTR currString;
    UINT index;
    BOOL result = FALSE;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    GROWBUFFER funcStr = INIT_GROWBUFFER;
    MULTISZ_ENUM e;
    UINT sizeNeeded;

    __try {

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_SCRIPT_EXECUTE,
                NULL,
                0,
                &sizeNeeded
                )) {
            result = TRUE;
            __leave;
        }

        if (!GbGrow (&multiSz, sizeNeeded)) {
            __leave;
        }

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_SCRIPT_EXECUTE,
                (PTSTR) multiSz.Buf,
                multiSz.End,
                NULL
                )) {
            __leave;
        }

        if (EnumFirstMultiSz (&e, (PCTSTR) multiSz.Buf)) {

            do {

                if (InfFindFirstLine (InfHandle, e.CurrentString, NULL, &is)) {
                    do {

                        if (IsmCheckCancel()) {
                            __leave;
                        }

                        time = InfGetStringField (&is, 0);

                        if (!time) {
                            continue;
                        }

                        index = 1;
                        funcStr.End = 0;
                        while (currString = InfGetStringField (&is, index)) {
                            GbMultiSzAppend (&funcStr, currString);
                            index ++;
                        }

                        if (funcStr.End) {
                            GbMultiSzAppend (&funcStr, TEXT(""));
                            if (StringIMatch (time, TEXT("PreProcess"))) {
                                IsmExecuteFunction (MIG_EXECUTE_PREPROCESS, (PCTSTR)funcStr.Buf);
                            }
                            if (StringIMatch (time, TEXT("Refresh"))) {
                                IsmExecuteFunction (MIG_EXECUTE_REFRESH, (PCTSTR)funcStr.Buf);
                            }
                            if (StringIMatch (time, TEXT("PostProcess"))) {
                                IsmExecuteFunction (MIG_EXECUTE_POSTPROCESS, (PCTSTR)funcStr.Buf);
                            }
                        }

                    } while (InfFindNextLine (&is));
                }
            } while (EnumNextMultiSz (&e));
        }

        result = TRUE;
    }
    __finally {

        GbFree (&multiSz);
        GbFree (&funcStr);
        InfCleanUpInfStruct (&is);

    }

    return result;
}

BOOL
pParseDestinationEnvironment (
    IN      HINF InfHandle
    )
{
    BOOL result = TRUE;

    if (InfHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Process the application sections
    //

    if (!ParseApplications (PLATFORM_DESTINATION, InfHandle, TEXT("Applications"), FALSE, MASTERGROUP_APP)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_APP_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    //
    // Process system settings
    //

    if (!ParseApplications (PLATFORM_DESTINATION, InfHandle, TEXT("System Settings"), FALSE, MASTERGROUP_SYSTEM)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_SYSTEM_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    //
    // Process user settings
    //

    if (!ParseApplications (PLATFORM_DESTINATION, InfHandle, TEXT("User Settings"), FALSE, MASTERGROUP_USER)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_USER_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    //
    // Process the administrator script sections
    //

    if (!ParseApplications (PLATFORM_DESTINATION, InfHandle, TEXT("Administrator Scripts"), FALSE, MASTERGROUP_SCRIPT)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_SCRIPT_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
ScriptDgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    PTSTR multiSz = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_TYPE dataType;
    BOOL result = TRUE;

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {
        if (!pParseDestinationEnvironment (infHandle)) {
            result = FALSE;
        }
        if (!pParseDestinationDetect (infHandle)) {
            result = FALSE;
        }
        if (!pParseInfForExclude (infHandle)) {
            result = FALSE;
        }
        if (!pParseInfForExcludeEx (infHandle)) {
            result = FALSE;
        }
        if (!pParseInfForExecute (infHandle)) {
            result = FALSE;
        }
        if (!pParseInfForDestAdd (infHandle)) {
            result = FALSE;
        }
    } else {

        if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, NULL, 0, &sizeNeeded, NULL)) {
            return TRUE;        // no INF files specified
        }

        __try {
            multiSz = AllocText (sizeNeeded);
            if (!multiSz) {
                result = FALSE;
                __leave;
            }

            if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, (PBYTE) multiSz, sizeNeeded, NULL, NULL)) {
                result = FALSE;
                __leave;
            }

            if (EnumFirstMultiSz (&e, multiSz)) {

                do {
                    infHandle = InfOpenInfFile (e.CurrentString);
                    if (infHandle != INVALID_HANDLE_VALUE) {
                        if (!pParseDestinationEnvironment (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            result = FALSE;
                            __leave;
                        }
                        if (!pParseDestinationDetect (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            result = FALSE;
                            __leave;
                        }
                        if (!pParseInfForExclude (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            result = FALSE;
                            __leave;
                        }
                        if (!pParseInfForExcludeEx (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            result = FALSE;
                            __leave;
                        }
                        if (!pParseInfForExecute (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            result = FALSE;
                            __leave;
                        }
                        if (!pParseInfForDestAdd (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            result = FALSE;
                            __leave;
                        }

                        InfCloseInfFile (infHandle);
                        infHandle = INVALID_HANDLE_VALUE;
                    } else {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_INF, e.CurrentString));
                    }
                } while (EnumNextMultiSz (&e));

            }
        }
        __finally {
            if (multiSz) {
                FreeText (multiSz);
                multiSz = NULL;
            }
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\etm.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    etm.c

Abstract:

    Implements the code for the ETM part of the script module

Author:

    Calin Negreanu (calinn) 13-Sep-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

HASHTABLE g_ObjectsTable;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

BOOL
pAddObjectToTable (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    );

//
// Macro expansion definition
//

// None

//
// Code
//

#define S_LOCATIONS TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations")

BOOL
pTranslateLocations (
    VOID
    )
{
    INFSTRUCT context = INITINFSTRUCT_PMHANDLE;
    HINF hInf = NULL;
    TCHAR windir [MAX_PATH] = TEXT("");
    TCHAR locationStr [] = TEXT("Location9999999999");
    PCTSTR infPath = NULL;
    INT totalLocations = 0;
    INT currentLocation = 0;
    INT currLocInt = 0;
    PCTSTR currLocStr = NULL;
    PCTSTR currLocReg = NULL;
    MIG_OBJECTTYPEID objectTypeId;
    MIG_CONTENT objectContent;
    MIG_OBJECTSTRINGHANDLE objectName;

    GetWindowsDirectory (windir, MAX_PATH);
    infPath = JoinPaths (windir, TEXT("TELEPHON.INI"));
    if (infPath) {
        hInf = InfOpenInfFile (infPath);
        if (hInf != INVALID_HANDLE_VALUE) {
            if (InfFindFirstLine (hInf, TEXT("Locations"), TEXT("Locations"), &context)) {
                if (InfGetIntField (&context, 1, &totalLocations)) {
                    if (totalLocations > 0) {
                        objectTypeId = MIG_REGISTRY_TYPE;
                        ZeroMemory (&objectContent, sizeof (MIG_CONTENT));
                        objectContent.ObjectTypeId = objectTypeId;
                        objectContent.ContentInFile = FALSE;

                        objectName = IsmCreateObjectHandle (S_LOCATIONS, TEXT("DisableCallWaiting"));
                        objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                        if (objectContent.Details.DetailsData) {
                            objectContent.Details.DetailsSize = sizeof (DWORD);
                            *((PDWORD)objectContent.Details.DetailsData) = REG_BINARY;
                            objectContent.MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                            if (objectContent.MemoryContent.ContentBytes) {
                                objectContent.MemoryContent.ContentSize = sizeof (DWORD);
                                *((PDWORD)objectContent.MemoryContent.ContentBytes) = 3;
                                pAddObjectToTable (objectTypeId, objectName, &objectContent);
                            }
                        }

                        objectName = IsmCreateObjectHandle (S_LOCATIONS, TEXT("DisableCallWaiting0"));
                        objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                        if (objectContent.Details.DetailsData) {
                            objectContent.Details.DetailsSize = sizeof (DWORD);
                            *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                            objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (TEXT("*70,")));
                            if (objectContent.MemoryContent.ContentBytes) {
                                objectContent.MemoryContent.ContentSize = SizeOfString (TEXT("*70,"));
                                CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, TEXT("*70,"), objectContent.MemoryContent.ContentSize);
                                pAddObjectToTable (objectTypeId, objectName, &objectContent);
                            }
                        }

                        objectName = IsmCreateObjectHandle (S_LOCATIONS, TEXT("DisableCallWaiting1"));
                        objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                        if (objectContent.Details.DetailsData) {
                            objectContent.Details.DetailsSize = sizeof (DWORD);
                            *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                            objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (TEXT("70#,")));
                            if (objectContent.MemoryContent.ContentBytes) {
                                objectContent.MemoryContent.ContentSize = SizeOfString (TEXT("70#,"));
                                CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, TEXT("70#,"), objectContent.MemoryContent.ContentSize);
                                pAddObjectToTable (objectTypeId, objectName, &objectContent);
                            }
                        }

                        objectName = IsmCreateObjectHandle (S_LOCATIONS, TEXT("DisableCallWaiting2"));
                        objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                        if (objectContent.Details.DetailsData) {
                            objectContent.Details.DetailsSize = sizeof (DWORD);
                            *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                            objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (TEXT("1170,")));
                            if (objectContent.MemoryContent.ContentBytes) {
                                objectContent.MemoryContent.ContentSize = SizeOfString (TEXT("1170,"));
                                CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, TEXT("1170,"), objectContent.MemoryContent.ContentSize);
                                pAddObjectToTable (objectTypeId, objectName, &objectContent);
                            }
                        }

                        objectName = IsmCreateObjectHandle (S_LOCATIONS, TEXT("NextID"));
                        objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                        if (objectContent.Details.DetailsData) {
                            objectContent.Details.DetailsSize = sizeof (DWORD);
                            *((PDWORD)objectContent.Details.DetailsData) = REG_DWORD;
                            objectContent.MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                            if (objectContent.MemoryContent.ContentBytes) {
                                objectContent.MemoryContent.ContentSize = sizeof (DWORD);
                                *((PDWORD)objectContent.MemoryContent.ContentBytes) = totalLocations + 1;
                                pAddObjectToTable (objectTypeId, objectName, &objectContent);
                            }
                        }

                        objectName = IsmCreateObjectHandle (S_LOCATIONS, TEXT("NumEntries"));
                        objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                        if (objectContent.Details.DetailsData) {
                            objectContent.Details.DetailsSize = sizeof (DWORD);
                            *((PDWORD)objectContent.Details.DetailsData) = REG_DWORD;
                            objectContent.MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                            if (objectContent.MemoryContent.ContentBytes) {
                                objectContent.MemoryContent.ContentSize = sizeof (DWORD);
                                *((PDWORD)objectContent.MemoryContent.ContentBytes) = totalLocations;
                                pAddObjectToTable (objectTypeId, objectName, &objectContent);
                            }
                        }

                        currentLocation = 0;
                        if (InfFindFirstLine (hInf, TEXT("Locations"), TEXT("CurrentLocation"), &context)) {
                            if (InfGetIntField (&context, 1, &currentLocation)) {
                            }
                        }

                        while (totalLocations) {
                            wsprintf (locationStr, TEXT("Location%d"), totalLocations - 1);
                            if (InfFindFirstLine (hInf, TEXT("Locations"), locationStr, &context)) {
                                wsprintf (locationStr, TEXT("Location%d"), totalLocations);
                                // let's read all the items for this location
                                currLocInt = 0;
                                InfGetIntField (&context, 1, &currLocInt);
                                if (currLocInt == currentLocation) {
                                    // this is the current location, let's write that
                                    objectName = IsmCreateObjectHandle (S_LOCATIONS, TEXT("CurrentID"));
                                    objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.Details.DetailsData) {
                                        objectContent.Details.DetailsSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.Details.DetailsData) = REG_DWORD;
                                        objectContent.MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                                        if (objectContent.MemoryContent.ContentBytes) {
                                            objectContent.MemoryContent.ContentSize = sizeof (DWORD);
                                            *((PDWORD)objectContent.MemoryContent.ContentBytes) = currLocInt + 1;
                                            pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                        }
                                    }
                                }

                                currLocReg = JoinPaths (S_LOCATIONS, locationStr);

                                objectName = IsmCreateObjectHandle (currLocReg, NULL);
                                objectContent.Details.DetailsData = NULL;
                                objectContent.Details.DetailsSize = 0;
                                objectContent.MemoryContent.ContentBytes = NULL;
                                objectContent.MemoryContent.ContentSize = 0;
                                pAddObjectToTable (objectTypeId, objectName, &objectContent);

                                /*
                                objectName = IsmCreateObjectHandle (currLocReg, TEXT("ID"));
                                objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                if (objectContent.Details.DetailsData) {
                                    objectContent.Details.DetailsSize = sizeof (DWORD);
                                    *((PDWORD)objectContent.Details.DetailsData) = REG_DWORD;
                                    objectContent.MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.MemoryContent.ContentBytes) {
                                        objectContent.MemoryContent.ContentSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.MemoryContent.ContentBytes) = currLocInt;
                                        pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                    }
                                }
                                */

                                currLocStr = InfGetStringField (&context, 2);
                                if (!currLocStr) {
                                    currLocStr = locationStr;
                                }
                                objectName = IsmCreateObjectHandle (currLocReg, TEXT("Name"));
                                objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                if (objectContent.Details.DetailsData) {
                                    objectContent.Details.DetailsSize = sizeof (DWORD);
                                    *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                                    objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (currLocStr));
                                    if (objectContent.MemoryContent.ContentBytes) {
                                        objectContent.MemoryContent.ContentSize = SizeOfString (currLocStr);
                                        CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, currLocStr, objectContent.MemoryContent.ContentSize);
                                        pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                    }
                                }

                                currLocStr = InfGetStringField (&context, 3);
                                if (currLocStr) {
                                    objectName = IsmCreateObjectHandle (currLocReg, TEXT("OutsideAccess"));
                                    objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.Details.DetailsData) {
                                        objectContent.Details.DetailsSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                                        objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (currLocStr));
                                        if (objectContent.MemoryContent.ContentBytes) {
                                            objectContent.MemoryContent.ContentSize = SizeOfString (currLocStr);
                                            CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, currLocStr, objectContent.MemoryContent.ContentSize);
                                            pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                        }
                                    }
                                }

                                currLocStr = InfGetStringField (&context, 4);
                                if (currLocStr) {
                                    objectName = IsmCreateObjectHandle (currLocReg, TEXT("LongDistanceAccess"));
                                    objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.Details.DetailsData) {
                                        objectContent.Details.DetailsSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                                        objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (currLocStr));
                                        if (objectContent.MemoryContent.ContentBytes) {
                                            objectContent.MemoryContent.ContentSize = SizeOfString (currLocStr);
                                            CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, currLocStr, objectContent.MemoryContent.ContentSize);
                                            pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                        }
                                    }
                                }

                                currLocStr = InfGetStringField (&context, 5);
                                if (currLocStr) {
                                    objectName = IsmCreateObjectHandle (currLocReg, TEXT("AreaCode"));
                                    objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.Details.DetailsData) {
                                        objectContent.Details.DetailsSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                                        objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (currLocStr));
                                        if (objectContent.MemoryContent.ContentBytes) {
                                            objectContent.MemoryContent.ContentSize = SizeOfString (currLocStr);
                                            CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, currLocStr, objectContent.MemoryContent.ContentSize);
                                            pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                        }
                                    }
                                }

                                currLocInt = 1;
                                InfGetIntField (&context, 6, &currLocInt);
                                objectName = IsmCreateObjectHandle (currLocReg, TEXT("Country"));
                                objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                if (objectContent.Details.DetailsData) {
                                    objectContent.Details.DetailsSize = sizeof (DWORD);
                                    *((PDWORD)objectContent.Details.DetailsData) = REG_DWORD;
                                    objectContent.MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.MemoryContent.ContentBytes) {
                                        objectContent.MemoryContent.ContentSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.MemoryContent.ContentBytes) = currLocInt;
                                        pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                    }
                                }

                                currLocInt = 1;
                                InfGetIntField (&context, 11, &currLocInt);
                                objectName = IsmCreateObjectHandle (currLocReg, TEXT("Flags"));
                                objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                if (objectContent.Details.DetailsData) {
                                    objectContent.Details.DetailsSize = sizeof (DWORD);
                                    *((PDWORD)objectContent.Details.DetailsData) = REG_DWORD;
                                    objectContent.MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.MemoryContent.ContentBytes) {
                                        objectContent.MemoryContent.ContentSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.MemoryContent.ContentBytes) = (!currLocInt)?0x00000005:0x00000004;
                                        pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                    }
                                }

                                currLocStr = InfGetStringField (&context, 12);
                                if (currLocStr) {
                                    objectName = IsmCreateObjectHandle (currLocReg, TEXT("DisableCallWaiting"));
                                    objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.Details.DetailsData) {
                                        objectContent.Details.DetailsSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                                        objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (currLocStr));
                                        if (objectContent.MemoryContent.ContentBytes) {
                                            objectContent.MemoryContent.ContentSize = SizeOfString (currLocStr);
                                            CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, currLocStr, objectContent.MemoryContent.ContentSize);
                                            pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                        }
                                    }
                                }

                                FreePathString (currLocReg);
                                currLocReg = NULL;
                            }
                            totalLocations --;
                        }
                    }
                }
            }
        }
    }
    return TRUE;
}

BOOL
WINAPI
ScriptEtmInitialize (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    MIG_OSVERSIONINFO versionInfo;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    g_ObjectsTable = HtAllocWithData (sizeof (MIG_CONTENT));
    if (!g_ObjectsTable) {
        return FALSE;
    }
    // Now let's look if we need to translate the Telephony locations settings.
    // On Win95 these settings are in %windir%\TELEPHONY.INI and they need to be
    // moved in HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations key.
    if (IsmGetRealPlatform () == PLATFORM_SOURCE) {
        ZeroMemory (&versionInfo, sizeof (MIG_OSVERSIONINFO));
        if (IsmGetOsVersionInfo (PLATFORM_SOURCE, &versionInfo)) {
            if ((versionInfo.OsType == OSTYPE_WINDOWS9X) &&
                ((versionInfo.OsMajorVersion == OSMAJOR_WIN95) ||
                 (versionInfo.OsMajorVersion == OSMAJOR_WIN95OSR2)
                 )
                ) {
                // we are on a Win95 Gold system
                pTranslateLocations ();
            }
        }
    }
    return TRUE;
}

BOOL
WINAPI
AcquireScriptObject (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit,
    OUT     PMIG_CONTENT *NewObjectContent,         CALLER_INITIALIZED OPTIONAL
    IN      BOOL ReleaseContent,
    IN      ULONG_PTR Arg
    )
{
    PMIG_CONTENT objectContent;
    BOOL result = FALSE;

    __try {
        objectContent = IsmGetMemory (sizeof (MIG_CONTENT));
        if (HtFindStringEx (g_ObjectsTable, ObjectName, objectContent, FALSE)) {
            if ((ContentType == CONTENTTYPE_FILE) &&
                (!objectContent->ContentInFile)
                ) {
                DEBUGMSG ((DBG_ERROR, "Script added object content cannot be saved to a file: %s", ObjectName));
                __leave;
            }
            if ((ContentType == CONTENTTYPE_MEMORY) &&
                (objectContent->ContentInFile)
                ) {
                DEBUGMSG ((DBG_ERROR, "Script added object content cannot be saved to memory: %s", ObjectName));
                __leave;
            }
            *NewObjectContent = objectContent;
            objectContent->EtmHandle = objectContent;
            result = TRUE;
        }
    }
    __finally {
        if (!result && objectContent) {
            IsmReleaseMemory (objectContent);
            objectContent = NULL;
        }
    }
    return result;
}

VOID
WINAPI
ReleaseScriptObject (
    IN      PMIG_CONTENT ObjectContent
    )
{
    if (ObjectContent) {
        IsmReleaseMemory (ObjectContent->EtmHandle);
    }
}

BOOL
WINAPI
ScriptAddObject (
    IN OUT  PMIG_TYPEOBJECTENUM ObjectEnum,
    IN      MIG_OBJECTSTRINGHANDLE Pattern,     // NULL if Abort is TRUE
    IN      MIG_PARSEDPATTERN ParsedPattern,    // NULL if Abort is TRUE
    IN      ULONG_PTR Arg,
    IN      BOOL Abort
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    BOOL enumDone = FALSE;
    PCTSTR p;
    BOOL result = FALSE;

    if (Abort) {

        IsmDestroyObjectString (ObjectEnum->ObjectNode);
        ObjectEnum->ObjectNode = NULL;
        IsmDestroyObjectString (ObjectEnum->ObjectLeaf);
        ObjectEnum->ObjectLeaf = NULL;
        IsmReleaseMemory (ObjectEnum->NativeObjectName);
        ObjectEnum->NativeObjectName = NULL;
        result = TRUE;

    } else {

        enumDone = (ObjectEnum->EtmHandle == 1);

        if (enumDone) {

            IsmDestroyObjectString (ObjectEnum->ObjectNode);
            ObjectEnum->ObjectNode = NULL;
            IsmDestroyObjectString (ObjectEnum->ObjectLeaf);
            ObjectEnum->ObjectLeaf = NULL;
            IsmReleaseMemory (ObjectEnum->NativeObjectName);
            ObjectEnum->NativeObjectName = NULL;
            ObjectEnum->EtmHandle = 0;
            result = FALSE;

        } else {

            objectName = (MIG_OBJECTSTRINGHANDLE) Arg;

            if (HtFindStringEx (g_ObjectsTable, objectName, &objectContent, FALSE)) {

                if (IsmParsedPatternMatch (ParsedPattern, objectContent.ObjectTypeId, objectName)) {

                    ObjectEnum->ObjectName = objectName;

                    //
                    // Fill in node, leaf and details
                    //
                    IsmDestroyObjectString (ObjectEnum->ObjectNode);
                    IsmDestroyObjectString (ObjectEnum->ObjectLeaf);
                    IsmReleaseMemory (ObjectEnum->NativeObjectName);

                    IsmCreateObjectStringsFromHandle (
                        ObjectEnum->ObjectName,
                        &ObjectEnum->ObjectNode,
                        &ObjectEnum->ObjectLeaf
                        );

                    ObjectEnum->Level = 0;

                    if (ObjectEnum->ObjectNode) {
                        p = _tcschr (ObjectEnum->ObjectNode, TEXT('\\'));
                        while (p) {
                            ObjectEnum->Level++;
                            p = _tcschr (p + 1, TEXT('\\'));
                        }
                    }

                    if (ObjectEnum->ObjectLeaf) {
                        ObjectEnum->Level ++;
                    }

                    ObjectEnum->SubLevel = 0;

                    if (ObjectEnum->ObjectLeaf) {
                        ObjectEnum->IsNode = FALSE;
                        ObjectEnum->IsLeaf = TRUE;
                    } else {
                        ObjectEnum->IsNode = TRUE;
                        ObjectEnum->IsLeaf = FALSE;
                    }

                    ObjectEnum->Details.DetailsSize = objectContent.Details.DetailsSize;
                    ObjectEnum->Details.DetailsData = objectContent.Details.DetailsData;

                    //
                    // Rely on base type to get the native object name
                    //

                    ObjectEnum->NativeObjectName = IsmGetNativeObjectName (
                                                        ObjectEnum->ObjectTypeId,
                                                        ObjectEnum->ObjectName
                                                        );
                    result = TRUE;

                    ObjectEnum->EtmHandle = 1;
                }
            }
        }
    }
    return result;
}

BOOL
pAddObjectToTable (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    BOOL b = TRUE;
    HtAddStringEx (g_ObjectsTable, ObjectName, ObjectContent, FALSE);
    b = b && IsmProhibitPhysicalEnum (
                ObjectTypeId,
                ObjectName,
                NULL,
                0,
                NULL
                );
    b = b && IsmAddToPhysicalEnum (
                ObjectTypeId,
                ObjectName,
                ScriptAddObject,
                (ULONG_PTR)ObjectName
                );
    b = b && IsmRegisterPhysicalAcquireHook (
                ObjectTypeId,
                ObjectName,
                AcquireScriptObject,
                ReleaseScriptObject,
                0,
                NULL
                );
    return b;
}

BOOL
pDoesObjectExist (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    MIG_CONTENT objectContent;
    BOOL result = FALSE;

    if (IsmAcquireObject (ObjectTypeId, ObjectName, &objectContent)) {
        IsmReleaseObject (&objectContent);
        result = TRUE;
    }

    return result;
}

BOOL
pParseEtmInfSection (
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfHandle,
    IN      PCTSTR Section
    )
{
    PCTSTR objectTypeName;
    MIG_OBJECTTYPEID objectTypeId;
    PCTSTR objectMultiSz;
    MIG_CONTENT objectContent;
    MIG_OBJECTSTRINGHANDLE objectName;
    BOOL result = TRUE;
    BOOL b = TRUE;
    UINT force = 0;

    if (InfHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    __try {
        if (InfFindFirstLine (InfHandle, Section, NULL, InfStruct)) {
            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                InfResetInfStruct (InfStruct);

                objectTypeName = InfGetStringField (InfStruct, 1);

                if (objectTypeName) {
                    objectTypeId = IsmGetObjectTypeId (objectTypeName);
                    if (objectTypeId) {

                        if (!InfGetIntField (InfStruct, 2, &force)) {
                            force = 0;
                        }

                        // let's read the object multi-sz
                        objectMultiSz = InfGetMultiSzField (InfStruct, 3);

                        if (objectMultiSz) {
                            if (IsmConvertMultiSzToObject (
                                    objectTypeId,
                                    objectMultiSz,
                                    &objectName,
                                    &objectContent
                                    )) {
                                // finally we have an object
                                // if force==0 we need to see if this object already exists
                                if ((force == 1) || (!pDoesObjectExist (objectTypeId, objectName))) {
                                    // save it in our hash table and
                                    // call the appropriate hooks
                                    pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                } else {
                                    if ((objectContent.Details.DetailsSize) &&
                                        (objectContent.Details.DetailsData)
                                        ) {
                                        IsmReleaseMemory (objectContent.Details.DetailsData);
                                    }
                                    if (objectContent.ContentInFile) {
                                        if (objectContent.FileContent.ContentPath) {
                                            IsmReleaseMemory (objectContent.FileContent.ContentPath);
                                        }
                                    } else {
                                        if ((objectContent.MemoryContent.ContentSize) &&
                                            (objectContent.MemoryContent.ContentBytes)
                                            ) {
                                            IsmReleaseMemory (objectContent.MemoryContent.ContentBytes);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

            } while (InfFindNextLine (InfStruct));
        }
        result = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (InfStruct);
    }
    return result;
}

BOOL
pParseEtmIniInfSection (
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfHandle,
    IN      PCTSTR Section
    )
{
    PCTSTR iniFile;
    PCTSTR iniFileExp = NULL;
    PCTSTR iniSection;
    PCTSTR iniValue;
    PCTSTR iniRegKey;
    PCTSTR iniRegValue;
    TCHAR iniItem [MAX_TCHAR_PATH];
    MIG_OBJECTTYPEID objectTypeId;
    MIG_CONTENT objectContent;
    MIG_OBJECTSTRINGHANDLE objectName;
    BOOL result = TRUE;
    BOOL b = TRUE;

    if (InfHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    __try {
        if (InfFindFirstLine (InfHandle, Section, NULL, InfStruct)) {
            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                InfResetInfStruct (InfStruct);

                iniFile = InfGetStringField (InfStruct, 1);
                if (!iniFile || !iniFile[0]) {
                    __leave;
                }

                iniFileExp = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, iniFile, NULL);
                if (!iniFileExp || !iniFileExp[0]) {
                    __leave;
                }

                iniSection = InfGetStringField (InfStruct, 2);
                if (!iniSection || !iniSection[0]) {
                    __leave;
                }

                iniValue = InfGetStringField (InfStruct, 3);
                if (!iniValue || !iniValue[0]) {
                    __leave;
                }

                iniRegKey = InfGetStringField (InfStruct, 4);
                if (!iniRegKey || !iniRegKey[0]) {
                    __leave;
                }

                iniRegValue = InfGetStringField (InfStruct, 5);
                if (!iniRegValue || !iniRegValue[0]) {
                    __leave;
                }

                // let's get the INI item
                GetPrivateProfileString (iniSection, iniValue, TEXT(""), iniItem, MAX_TCHAR_PATH, iniFileExp);
                if (!iniItem[0]) {
                    __leave;
                }

                objectTypeId = MIG_REGISTRY_TYPE;

                objectName = IsmCreateObjectHandle (iniRegKey, iniRegValue);

                ZeroMemory (&objectContent, sizeof (MIG_CONTENT));
                objectContent.ObjectTypeId = objectTypeId;
                objectContent.ContentInFile = FALSE;
                objectContent.MemoryContent.ContentSize = SizeOfString (iniItem);
                objectContent.MemoryContent.ContentBytes = IsmGetMemory (objectContent.MemoryContent.ContentSize);
                CopyMemory ((PBYTE)objectContent.MemoryContent.ContentBytes, iniItem, objectContent.MemoryContent.ContentSize);
                objectContent.Details.DetailsSize = sizeof (DWORD);
                objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;

                // finally we have an object
                // save it in our hash table and
                // call the appropriate hooks
                b = b && pAddObjectToTable (objectTypeId, objectName, &objectContent);

                if (iniFileExp) {
                    IsmReleaseMemory (iniFileExp);
                    iniFileExp = NULL;
                }

            } while (InfFindNextLine (InfStruct));
        }
        result = TRUE;
    }
    __finally {
        if (iniFileExp) {
            IsmReleaseMemory (iniFileExp);
            iniFileExp = NULL;
        }
        InfCleanUpInfStruct (InfStruct);
    }
    return result;
}

BOOL
pParseEtmInf (
    IN      HINF InfHandle
    )
{
    PCTSTR osSpecificSection;
    BOOL b;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;

    b = pParseEtmInfSection (&is, InfHandle, TEXT("AddObject"));

    if (b) {
        osSpecificSection = GetMostSpecificSection (&is, InfHandle, TEXT("AddObject"));

        if (osSpecificSection) {
            b = pParseEtmInfSection (&is, InfHandle, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    b = pParseEtmIniInfSection (&is, InfHandle, TEXT("AddIniRegObject"));

    if (b) {
        osSpecificSection = GetMostSpecificSection (&is, InfHandle, TEXT("AddIniRegObject"));

        if (osSpecificSection) {
            b = pParseEtmIniInfSection (&is, InfHandle, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    return b;
}

BOOL
WINAPI
ScriptEtmParse (
    IN      PVOID Reserved
    )
{
    PTSTR multiSz = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_TYPE dataType;
    BOOL result = FALSE;

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {

        if (pParseEtmInf (infHandle)) {
            result = TRUE;
        }

        InfNameHandle (infHandle, NULL, FALSE);

    } else {

        if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, NULL, 0, &sizeNeeded, NULL)) {
            return TRUE;        // no INF files specified
        }

        __try {
            multiSz = AllocText (sizeNeeded);
            if (!multiSz) {
                __leave;
            }

            if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, (PBYTE) multiSz, sizeNeeded, NULL, NULL)) {
                __leave;
            }

            if (EnumFirstMultiSz (&e, multiSz)) {

                do {

                    infHandle = InfOpenInfFile (e.CurrentString);
                    if (infHandle != INVALID_HANDLE_VALUE) {
                        if (!pParseEtmInf (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            __leave;
                        }
                    } else {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_INF, e.CurrentString));
                    }
                    InfCloseInfFile (infHandle);
                    infHandle = INVALID_HANDLE_VALUE;
                } while (EnumNextMultiSz (&e));

            }

            result = TRUE;
        }
        __finally {
            if (multiSz) {
                FreeText (multiSz);
                multiSz = NULL;
            }
        }
    }
    return result;
}

VOID
WINAPI
ScriptEtmTerminate (
    VOID
    )
{
    HASHTABLE_ENUM e;
    PMIG_CONTENT objectContent;

    if (g_ObjectsTable) {
        // enumerate the table and release all memory
        if (EnumFirstHashTableString (&e, g_ObjectsTable)) {
            do {
                objectContent = (PMIG_CONTENT) e.ExtraData;
                if ((objectContent->Details.DetailsSize) &&
                    (objectContent->Details.DetailsData)
                    ) {
                    IsmReleaseMemory (objectContent->Details.DetailsData);
                }
                if (objectContent->ContentInFile) {
                    if (objectContent->FileContent.ContentPath) {
                        IsmReleaseMemory (objectContent->FileContent.ContentPath);
                    }
                } else {
                    if ((objectContent->MemoryContent.ContentSize) &&
                        (objectContent->MemoryContent.ContentBytes)
                        ) {
                        IsmReleaseMemory (objectContent->MemoryContent.ContentBytes);
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_ObjectsTable);
        g_ObjectsTable = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by v1.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\regconv.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    regconv.c

Abstract:

    Implements registry special conversion.

Author:

    Calin Negreanu (calinn) 5-May-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"
#include <wingdip.h>
#include <shlobjp.h>
#include <shlwapi.h>


//
// Strings
//

#define DBG_CONVERSION  "SpecialConversion"

//
// Constants
//

#define COLOR_MENU              4
#define COLOR_HIGHLIGHT         13
#define COLOR_BTNFACE           15
#define COLOR_BUTTONALTFACE     25
#define COLOR_HOTLIGHT          26
#define COLOR_GRADIENTACTIVECAPTION 27
#define COLOR_GRADIENTINACTIVECAPTION 28
#define COLOR_MENUHILIGHT       29
#define COLOR_MENUBAR           30

#define DISPLAY_BITMASK     0x00161E2F
#define MOUSE_BITMASK       0x0001E000

//
// Macros
//

#define pGetDestDwordValue(Key,Value) pGetDwordValue(Key, Value, PLATFORM_DESTINATION)
#define pGetSrcDwordValue(Key,Value) pGetDwordValue(Key, Value, PLATFORM_SOURCE)

//
// Types
//

typedef struct {
    SHORT lfHeight;
    SHORT lfWidth;
    SHORT lfEscapement;
    SHORT lfOrientation;
    SHORT lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    char lfFaceName[LF_FACESIZE];
} SHORT_LOGFONT, *PSHORT_LOGFONT;

//
// NT uses only UNICODE structures, and pads the members
// to 32-bit boundaries.
//

#define COLOR_MAX_V1 25
#define COLOR_MAX_V2 25
#define COLOR_MAX_V3 25
#define COLOR_MAX_V4 29
#define COLOR_MAX_NT 29     // this is a modified version 2 format, similar to 4

typedef struct {
    SHORT version;              // 2 for NT UNICODE
    WORD  wDummy;               // for alignment
    NONCLIENTMETRICSW ncm;
    LOGFONTW lfIconTitle;
    COLORREF rgb[COLOR_MAX_NT];
} SCHEMEDATA_NT, *PSCHEMEDATA_NT;

//
// Win95 uses NONCLIENTMETRICSA which has LOGFONTA members,
// but it uses a 16-bit LOGFONT as well.
//

#pragma pack(push)
#pragma pack(1)

typedef struct {
    SHORT version;              // 1 for Win95 ANSI
    NONCLIENTMETRICSA ncm;
    SHORT_LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX_V1];
} SCHEMEDATA_V1, *PSCHEMEDATA_V1;

typedef struct {
    SHORT version;              // 1 for Win95 ANSI

    NONCLIENTMETRICSA ncm;
    SHORT_LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX_V4];
} SCHEMEDATA_V1A, *PSCHEMEDATA_V1A;

typedef struct {
    SHORT version;              // 2 for WinNT UNICODE with reduced color table
    WORD Dummy;
    NONCLIENTMETRICSW ncm;
    LOGFONTW lfIconTitle;
    COLORREF rgb[COLOR_MAX_V2];
} SCHEMEDATA_V2, *PSCHEMEDATA_V2;

typedef struct {
    SHORT version;              // 3 for Win98 ANSI, 4 for portable format
    WORD Dummy;
    NONCLIENTMETRICSA ncm;
    LOGFONTA lfIconTitle;
    COLORREF rgb[COLOR_MAX_V3];
} SCHEMEDATA_V3, *PSCHEMEDATA_V3;

typedef struct {
    SHORT version;              // 4 for Win32 format (whatever that means)
    WORD Dummy;
    NONCLIENTMETRICSA ncm;
    LOGFONTA lfIconTitle;
    COLORREF rgb[COLOR_MAX_V4];
} SCHEMEDATA_V4, *PSCHEMEDATA_V4;

#pragma pack(pop)

typedef struct
{
    UINT cbSize;
    SHELLSTATE ss;
} REGSHELLSTATE, *PREGSHELLSTATE;

//
// Globals
//

MIG_OPERATIONID g_ConvertToDwordOp;
MIG_OPERATIONID g_ConvertToStringOp;
DWORD g_IdentityCount = 0;
HASHTABLE g_IdentityDestTable;

//
// Macro expansion list
//

#define CONVERSION_FUNCTIONS        \
        DEFMAC(CONVERTTODWORD,          NULL,   EDIT.ConvertToDword,            pConvertToDwordCallback         )  \
        DEFMAC(CONVERTTOSTRING,         NULL,   EDIT.ConvertToString,           pConvertToStringCallback        )  \
        DEFMAC(CONVERTLOGFONT,          NULL,   EDIT.ConvertLogFont,            pConvertLogFontCallback         )  \
        DEFMAC(ANTIALIAS,               NULL,   EDIT.AntiAlias,                 pAntiAliasCallback              )  \
        DEFMAC(FIXACTIVEDESKTOP,        NULL,   EDIT.FixActiveDesktop,          pFixActiveDesktopCallback       )  \
        DEFMAC(CONVERTRECENTDOCSMRU,    NULL,   EDIT.ConvertRecentDocsMRU,      pConvertRecentDocsMRUCallback   )  \
        DEFMAC(CONVERTAPPEARANCESCHEME, NULL,   EDIT.ConvertAppearanceScheme,   pConvertAppearanceSchemeCallback)  \
        DEFMAC(CONVERTSCNSAVER,         NULL,   EDIT.ConvertScnSaver,           pConvertScnSaver                )  \
        DEFMAC(CONVERTOE4IAMACCTNAME,   NULL,   EDIT.ConvertOE4IAMAcctName,     pConvertOE4IAMAcctName          )  \
        DEFMAC(CONVERTOE5IAMACCTNAME,   NULL,   EDIT.ConvertOE5IAMAcctName,     pConvertOE5IAMAcctName          )  \
        DEFMAC(CONVERTIAMACCTNAME,      NULL,   EDIT.ConvertIAMAcctName,        pConvertIAMAcctName             )  \
        DEFMAC(CONVERTOMIACCOUNTNAME,   NULL,   EDIT.ConvertOMIAccountName,     pConvertOMIAccountName          )  \
        DEFMAC(CONVERTIDENTITYCOUNT,    NULL,   EDIT.ConvertIdentityCount,      pConvertIdentityCount           )  \
        DEFMAC(CONVERTIDENTITYINDEX,    NULL,   EDIT.ConvertIdentityIndex,      pConvertIdentityIndex           )  \
        DEFMAC(CONVERTIDENTITYUSERNAME, NULL,   EDIT.ConvertIdentityUsername,   pConvertIdentityUsername        )  \
        DEFMAC(CONVERTIDENTITYGUID,     NULL,   EDIT.ConvertIdentityGuid,       pConvertIdentityGuid            )  \
        DEFMAC(CONVERTSETDWORDTRUE,     NULL,   EDIT.ConvertSetDwordTrue,       pConvertSetDwordTrue            )  \
        DEFMAC(CONVERTSETDWORDFALSE,    NULL,   EDIT.ConvertSetDwordFalse,      pConvertSetDwordFalse           )  \
        DEFMAC(CONVERTPSTBLOB,          NULL,   EDIT.ConvertPSTBlob,            pConvertPSTBlob                 )  \
        DEFMAC(CONVERTOFFICELANGID,     NULL,   EDIT.ConvertOfficeLangId,       pConvertOfficeLangId            )  \
        DEFMAC(CONVERTOUTLOOKLANGID,    NULL,   EDIT.ConvertOutlookLangId,      pConvertOutlookLangId           )  \
        DEFMAC(CONVERTACCESSLANGID,     NULL,   EDIT.ConvertAccessLangId,       pConvertAccessLangId            )  \
        DEFMAC(CONVERTEXCELLANGID,      NULL,   EDIT.ConvertExcelLangId,        pConvertExcelLangId             )  \
        DEFMAC(CONVERTFRONTPAGELANGID,  NULL,   EDIT.ConvertFrontPageLangId,    pConvertFrontPageLangId         )  \
        DEFMAC(CONVERTPOWERPOINTLANGID, NULL,   EDIT.ConvertPowerPointLangId,   pConvertPowerPointLangId        )  \
        DEFMAC(CONVERTPUBLISHERLANGID,  NULL,   EDIT.ConvertPublisherLangId,    pConvertPublisherLangId         )  \
        DEFMAC(CONVERTWORDLANGID,       NULL,   EDIT.ConvertWordLangId,         pConvertWordLangId              )  \
        DEFMAC(CONVERTOFFICE2000LANGID, NULL,   EDIT.ConvertOffice2000LangId,   pConvertOffice2000LangId        )  \
        DEFMAC(MIGRATESOUNDSYSTRAY,     NULL,   EDIT.MigrateSoundSysTray,       pMigrateSoundSysTray            )  \
        DEFMAC(MIGRATEAPPEARANCEUPM,    NULL,   EDIT.MigrateAppearanceUPM,      pMigrateAppearanceUPM           )  \
        DEFMAC(MIGRATEMOUSEUPM,         NULL,   EDIT.MigrateMouseUPM,           pMigrateMouseUPM                )  \
        DEFMAC(MIGRATEOFFLINESYSTRAY,   NULL,   EDIT.MigrateOfflineSysTray,     pMigrateOfflineSysTray          )  \
        DEFMAC(MIGRATEDISPLAYSS,        NULL,   EDIT.MigrateDisplaySS,          pMigrateDisplaySS               )  \
        DEFMAC(MIGRATEDISPLAYCS,        NULL,   EDIT.MigrateDisplayCS,          pMigrateDisplayCS               )  \
        DEFMAC(MIGRATETASKBARSSPRESERVE,NULL,   EDIT.MigrateTaskBarSSPreserve,  pMigrateTaskBarSSPreserve       )  \
        DEFMAC(MIGRATETASKBARSSFORCE,   NULL,   EDIT.MigrateTaskBarSSForce,     pMigrateTaskBarSSForce          )  \
        DEFMAC(CONVERTSHOWIEONDESKTOP,  NULL,   EDIT.ConvertShowIEOnDesktop,    pConvertShowIEOnDesktop         )  \
        DEFMAC(MIGRATEACTIVEDESKTOP,    NULL,   EDIT.MigrateActiveDesktop,      pMigrateActiveDesktop           )  \


//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

//
// Declare special conversion operation apply callback functions
//
#define DEFMAC(ifn,ec,opn,opc) OPMAPPLYCALLBACK opc;
CONVERSION_FUNCTIONS
#undef DEFMAC

//
// This is the structure used for handling action functions
//
typedef struct {
    PCTSTR InfFunctionName;
    PSGMENUMERATIONCALLBACK EnumerationCallback;
    PCTSTR OperationName;
    MIG_OPERATIONID OperationId;
    POPMAPPLYCALLBACK OperationCallback;
} CONVERSION_STRUCT, *PCONVERSION_STRUCT;

//
// Declare a global array of conversion functions
//
#define DEFMAC(ifn,ec,opn,opc) {TEXT("\\")TEXT(#ifn),ec,TEXT(#opn),0,opc},
static CONVERSION_STRUCT g_ConversionFunctions[] = {
                              CONVERSION_FUNCTIONS
                              {NULL, NULL, NULL, 0, NULL}
                              };
#undef DEFMAC

//
// Code
//

BOOL
IsValidRegSz(
    IN      PCMIG_CONTENT ObjectContent
    )
{
    return ((!ObjectContent->ContentInFile) &&
            (ObjectContent->MemoryContent.ContentSize) &&
            (ObjectContent->MemoryContent.ContentBytes) &&
            (ObjectContent->Details.DetailsSize == sizeof (DWORD)) &&
            (ObjectContent->Details.DetailsData) &&
            ((*((PDWORD)ObjectContent->Details.DetailsData) == REG_SZ) ||
             (*((PDWORD)ObjectContent->Details.DetailsData) == REG_EXPAND_SZ)));
}

BOOL
IsValidRegType (
    IN      PCMIG_CONTENT CurrentContent,
    IN      DWORD RegType
    )
{
    return ((!CurrentContent->ContentInFile) &&
            (CurrentContent->Details.DetailsSize == sizeof (DWORD)) &&
            (CurrentContent->Details.DetailsData) &&
            (*((PDWORD)CurrentContent->Details.DetailsData) == RegType) &&
            (CurrentContent->MemoryContent.ContentSize) &&
            (CurrentContent->MemoryContent.ContentBytes));
}

DWORD
pGetDwordValue (
    IN      PTSTR Key,
    IN      PTSTR Value,
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    DWORD value = 0;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;

    objectName = IsmCreateObjectHandle (Key, Value);

    if (IsmAcquireObject (g_RegType | Platform, objectName, &objectContent)) {
        if (IsValidRegType(&objectContent, REG_DWORD)) {
            value = *(DWORD *)objectContent.MemoryContent.ContentBytes;
        }
        IsmReleaseObject (&objectContent);
    }
    IsmDestroyObjectHandle (objectName);

    return value;
}

VOID
pSetDwordValue (
    OUT     PMIG_CONTENT NewContent,
    IN      DWORD Value
    )
{
    NewContent->Details.DetailsSize = sizeof(DWORD);
    NewContent->Details.DetailsData = IsmGetMemory (sizeof (DWORD));
    *((PDWORD)NewContent->Details.DetailsData) = REG_DWORD;
    NewContent->MemoryContent.ContentSize = sizeof (DWORD);
    NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof(DWORD));
    *((PDWORD)NewContent->MemoryContent.ContentBytes) = Value;
}


UINT
pDefaultEnumerationCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    PCONVERSION_STRUCT p = (PCONVERSION_STRUCT)CallerArg;

    if (Data->IsLeaf) {
        IsmSetOperationOnObject (Data->ObjectTypeId, Data->ObjectName, p->OperationId, NULL, NULL);
    }
    return CALLBACK_ENUM_CONTINUE;
}

PCONVERSION_STRUCT
pGetConversionStruct (
    IN      PCTSTR FunctionName
    )
{
    PCONVERSION_STRUCT p = g_ConversionFunctions;
    INT i = 0;
    while (p->InfFunctionName != NULL) {
        if (StringIMatch (p->InfFunctionName, FunctionName)) {
            return p;
        }
        p++;
        i++;
    }
    return NULL;
}

VOID
InitSpecialConversion (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    PCONVERSION_STRUCT p = g_ConversionFunctions;

    while (p->InfFunctionName) {
        p->OperationId = IsmRegisterOperation (p->OperationName, FALSE);
        if (Platform == PLATFORM_DESTINATION) {
            IsmRegisterOperationApplyCallback (p->OperationId, p->OperationCallback, TRUE);
        }
        p++;
    }

    g_IdentityDestTable = HtAllocWithData (sizeof (PTSTR));

    if (Platform == PLATFORM_DESTINATION) {
        // Read the starting Identity count
        g_IdentityCount = pGetDestDwordValue (TEXT("HKCU\\Identities"), TEXT("Identity Ordinal"));
    }
}

VOID
TerminateSpecialConversion (
    VOID
    )
{
    HtFree (g_IdentityDestTable);
    g_IdentityDestTable = NULL;

    OETerminate();
}

BOOL
pProcessDataConversionSection (
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfHandle,
    IN      PCTSTR Section
    )
{
    PCTSTR pattern;
    ENCODEDSTRHANDLE encodedPattern = NULL;
    PCTSTR functionName;
    PCONVERSION_STRUCT functionStruct = NULL;
    BOOL result = FALSE;

    __try {
        if (InfFindFirstLine (InfHandle, Section, NULL, InfStruct)) {
            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                pattern = InfGetStringField (InfStruct, 0);

                if (!pattern) {
                    continue;
                }
                encodedPattern = TurnRegStringIntoHandle (pattern, TRUE, NULL);

                functionName = InfGetStringField (InfStruct, 1);

                if (functionName) {

                    functionStruct = pGetConversionStruct (functionName);

                    if (functionStruct) {
                        IsmHookEnumeration (
                            MIG_REGISTRY_TYPE,
                            encodedPattern,
                            functionStruct->EnumerationCallback?
                                functionStruct->EnumerationCallback:
                                pDefaultEnumerationCallback,
                            (ULONG_PTR)functionStruct,
                            functionStruct->InfFunctionName
                            );

                    } else {
                        LOG ((
                            LOG_ERROR,
                            (PCSTR) MSG_DATA_CONVERSION_BAD_FN,
                            functionName,
                            pattern
                            ));
                    }
                } else {
                    LOG ((LOG_ERROR, (PCSTR) MSG_DATA_CONVERSION_NO_FN, pattern));
                }

                IsmDestroyObjectHandle (encodedPattern);
                encodedPattern = NULL;
            } while (InfFindNextLine (InfStruct));
        }

        result = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (InfStruct);
    }

    return result;
}

BOOL
DoRegistrySpecialConversion (
    IN      HINF InfHandle,
    IN      PCTSTR Section
    )
{
    PCTSTR osSpecificSection;
    BOOL b;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;

    b = pProcessDataConversionSection (&is, InfHandle, Section);

    if (b) {
        osSpecificSection = GetMostSpecificSection (&is, InfHandle, Section);

        if (osSpecificSection) {
            b = pProcessDataConversionSection (&is, InfHandle, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    InfCleanUpInfStruct (&is);
    return b;
}

BOOL
DoesDestRegExist (
    IN      MIG_OBJECTSTRINGHANDLE DestName,
    IN      DWORD RegType
    )
{
    BOOL result = FALSE;
    MIG_CONTENT content;

    if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION, DestName, &content)) {
        if (IsValidRegType(&content, RegType)) {
            result = TRUE;
        }
        IsmReleaseObject (&content);
    }

    return result;
}

BOOL
WINAPI
pConvertToDwordCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    DWORD value = 0;
    BOOL converted = FALSE;
    PDWORD valueType;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_SZ) {
            converted = TRUE;
            if (CurrentContent->MemoryContent.ContentSize > 0) {
                value = _tcstoul ((PCTSTR)CurrentContent->MemoryContent.ContentBytes, NULL, 10);
            }
        } else if (*valueType == REG_BINARY ||
                   *valueType == REG_NONE ||
                   *valueType == REG_DWORD
                   ) {
            if (CurrentContent->MemoryContent.ContentSize == sizeof (DWORD)) {
                converted = TRUE;
                value = *((PDWORD)CurrentContent->MemoryContent.ContentBytes);
            }
        }
        if (converted) {
            pSetDwordValue (NewContent, value);
        }
    }

    return TRUE;
}

BOOL
WINAPI
pConvertToStringCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR result = NULL;
    PTSTR resultPtr;
    UINT i;
    BOOL converted = FALSE;
    UINT convertedSize = 0;
    PDWORD valueType;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_DWORD) {

            MYASSERT (CurrentContent->MemoryContent.ContentSize == sizeof (DWORD));

            if (CurrentContent->MemoryContent.ContentSize == sizeof (DWORD)) {

                converted = TRUE;
                convertedSize = 11 * sizeof (TCHAR); // DWORD takes no more than 11 characters
                result = IsmGetMemory (convertedSize);
                if (result) {
                    wsprintf (result, TEXT("%lu"), *((PDWORD)CurrentContent->MemoryContent.ContentBytes));
                    convertedSize = SizeOfString (result);
                }
            }

        } else if (*valueType == REG_BINARY) {

            converted = TRUE;
            convertedSize = (CurrentContent->MemoryContent.ContentSize?(CurrentContent->MemoryContent.ContentSize * 3):1) * sizeof (TCHAR);
            result = IsmGetMemory (convertedSize);
            if (result) {
                resultPtr = result;
                *resultPtr = 0;
                for (i = 0; i < CurrentContent->MemoryContent.ContentSize; i++) {
                    wsprintf (resultPtr, TEXT("%02X"), CurrentContent->MemoryContent.ContentBytes[i]);
                    resultPtr = GetEndOfString (resultPtr);
                    if (i < CurrentContent->MemoryContent.ContentSize - 1) {
                        _tcscat (resultPtr, TEXT(" "));
                        resultPtr = GetEndOfString (resultPtr);
                    }
                }
                convertedSize = SizeOfString (result);
            }
        }
        if (converted && convertedSize && result) {
            NewContent->Details.DetailsSize = sizeof (DWORD);
            NewContent->Details.DetailsData = IsmGetMemory (NewContent->Details.DetailsSize);
            *((PDWORD)NewContent->Details.DetailsData) = REG_SZ;
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = (PCBYTE) result;
        }
    }

    return TRUE;
}

VOID
pConvertShortLogFontWorker (
    PLOGFONTW plfDest,
    PSHORT_LOGFONT plfSrc
    )
{
    PCWSTR faceName;

    if (plfSrc->lfHeight > 0) {
        plfDest->lfHeight = 0xFFFFFFFF - plfSrc->lfHeight - ((plfSrc->lfHeight + 1) / 3) + 1;
    } else {
        plfDest->lfHeight = plfSrc->lfHeight;
    }
    plfDest->lfWidth = plfSrc->lfWidth;
    plfDest->lfEscapement = plfSrc->lfEscapement;
    plfDest->lfOrientation = plfSrc->lfOrientation;
    plfDest->lfWeight = plfSrc->lfWeight;
    plfDest->lfItalic = plfSrc->lfItalic;
    plfDest->lfUnderline = plfSrc->lfUnderline;
    plfDest->lfStrikeOut = plfSrc->lfStrikeOut;
    plfDest->lfCharSet = plfSrc->lfCharSet;
    plfDest->lfOutPrecision = plfSrc->lfOutPrecision;
    plfDest->lfClipPrecision = plfSrc->lfClipPrecision;
    plfDest->lfQuality = plfSrc->lfQuality;
    plfDest->lfPitchAndFamily = plfSrc->lfPitchAndFamily;\
    faceName = ConvertAtoW (plfSrc->lfFaceName);
    StringCopyByteCountW (plfDest->lfFaceName, faceName, sizeof (plfDest->lfFaceName));
    FreeConvertedStr (faceName);
}

VOID
pConvertLogFontWorker (
    PLOGFONTW plfDest,
    PLOGFONTA plfSrc
    )
{
    PCWSTR faceName;

    if (plfSrc->lfHeight > 0) {
        plfDest->lfHeight = 0xFFFFFFFF - plfSrc->lfHeight + 1 + ((plfSrc->lfHeight + 1) / 3);
    } else {
        plfDest->lfHeight = plfSrc->lfHeight;
    }
    plfDest->lfWidth = plfSrc->lfWidth;
    plfDest->lfEscapement = plfSrc->lfEscapement;
    plfDest->lfOrientation = plfSrc->lfOrientation;
    plfDest->lfWeight = plfSrc->lfWeight;
    plfDest->lfItalic = plfSrc->lfItalic;
    plfDest->lfUnderline = plfSrc->lfUnderline;
    plfDest->lfStrikeOut = plfSrc->lfStrikeOut;
    plfDest->lfCharSet = plfSrc->lfCharSet;
    plfDest->lfOutPrecision = plfSrc->lfOutPrecision;
    plfDest->lfClipPrecision = plfSrc->lfClipPrecision;
    plfDest->lfQuality = plfSrc->lfQuality;
    plfDest->lfPitchAndFamily = plfSrc->lfPitchAndFamily;\
    faceName = ConvertAtoW (plfSrc->lfFaceName);
    StringCopyByteCountW (plfDest->lfFaceName, faceName, sizeof (plfDest->lfFaceName));
    FreeConvertedStr (faceName);
}

VOID
pCopyLogFontWorker (
    PLOGFONTW plfDest,
    PLOGFONTW plfSrc
    )
{
    PCWSTR faceName;

    plfDest->lfHeight = plfSrc->lfHeight;
    plfDest->lfWidth = plfSrc->lfWidth;
    plfDest->lfEscapement = plfSrc->lfEscapement;
    plfDest->lfOrientation = plfSrc->lfOrientation;
    plfDest->lfWeight = plfSrc->lfWeight;
    plfDest->lfItalic = plfSrc->lfItalic;
    plfDest->lfUnderline = plfSrc->lfUnderline;
    plfDest->lfStrikeOut = plfSrc->lfStrikeOut;
    plfDest->lfCharSet = plfSrc->lfCharSet;
    plfDest->lfOutPrecision = plfSrc->lfOutPrecision;
    plfDest->lfClipPrecision = plfSrc->lfClipPrecision;
    plfDest->lfQuality = plfSrc->lfQuality;
    plfDest->lfPitchAndFamily = plfSrc->lfPitchAndFamily;\
    StringCopyByteCountW (plfDest->lfFaceName, plfSrc->lfFaceName, sizeof (plfDest->lfFaceName));
}

BOOL
WINAPI
pConvertLogFontCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    BOOL converted = FALSE;
    UINT convertedSize = 0;
    PLOGFONTW logFont = NULL;
    PDWORD valueType;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_BINARY) {

            if (CurrentContent->MemoryContent.ContentSize == sizeof (SHORT_LOGFONT)) {

                converted = TRUE;
                convertedSize = sizeof (LOGFONTW);
                logFont = (PLOGFONTW) IsmGetMemory (convertedSize);
                ZeroMemory (logFont, sizeof (LOGFONTW));
                pConvertShortLogFontWorker (logFont, (PSHORT_LOGFONT)CurrentContent->MemoryContent.ContentBytes);
            }

            if (CurrentContent->MemoryContent.ContentSize == sizeof (LOGFONTA)) {

                converted = TRUE;
                convertedSize = sizeof (LOGFONTW);
                logFont = (PLOGFONTW) IsmGetMemory (convertedSize);
                ZeroMemory (logFont, sizeof (LOGFONTW));
                pConvertLogFontWorker (logFont, (PLOGFONTA)CurrentContent->MemoryContent.ContentBytes);
            }
        }

        if (converted && convertedSize && logFont) {
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = (PBYTE)logFont;
        }
    }

    return TRUE;
}

VOID
pConvertNonClientMetrics (
    OUT     NONCLIENTMETRICSW *Dest,
    IN      NONCLIENTMETRICSA *Src
    )
{
    Dest->cbSize = sizeof (NONCLIENTMETRICSW);
    Dest->iBorderWidth = Src->iBorderWidth;
    Dest->iScrollWidth = Src->iScrollWidth;
    Dest->iScrollHeight = Src->iScrollHeight;
    Dest->iCaptionWidth = Src->iCaptionWidth;
    Dest->iCaptionHeight = Src->iCaptionHeight;
    Dest->iSmCaptionWidth = Src->iSmCaptionWidth;
    Dest->iSmCaptionHeight = Src->iSmCaptionHeight;
    Dest->iMenuWidth = Src->iMenuWidth;
    Dest->iMenuHeight = Src->iMenuHeight;

    pConvertLogFontWorker (&Dest->lfCaptionFont, &Src->lfCaptionFont);
    pConvertLogFontWorker (&Dest->lfSmCaptionFont, &Src->lfSmCaptionFont);
    pConvertLogFontWorker (&Dest->lfMenuFont, &Src->lfMenuFont);
    pConvertLogFontWorker (&Dest->lfStatusFont, &Src->lfStatusFont);
    pConvertLogFontWorker (&Dest->lfMessageFont, &Src->lfMessageFont);
}

VOID
pCopyNonClientMetrics (
    OUT     NONCLIENTMETRICSW *Dest,
    IN      NONCLIENTMETRICSW *Src
    )
{
    Dest->cbSize = sizeof (NONCLIENTMETRICSW);
    Dest->iBorderWidth = Src->iBorderWidth;
    Dest->iScrollWidth = Src->iScrollWidth;
    Dest->iScrollHeight = Src->iScrollHeight;
    Dest->iCaptionWidth = Src->iCaptionWidth;
    Dest->iCaptionHeight = Src->iCaptionHeight;
    Dest->iSmCaptionWidth = Src->iSmCaptionWidth;
    Dest->iSmCaptionHeight = Src->iSmCaptionHeight;
    Dest->iMenuWidth = Src->iMenuWidth;
    Dest->iMenuHeight = Src->iMenuHeight;

    pCopyLogFontWorker (&Dest->lfCaptionFont, &Src->lfCaptionFont);
    pCopyLogFontWorker (&Dest->lfSmCaptionFont, &Src->lfSmCaptionFont);
    pCopyLogFontWorker (&Dest->lfMenuFont, &Src->lfMenuFont);
    pCopyLogFontWorker (&Dest->lfStatusFont, &Src->lfStatusFont);
    pCopyLogFontWorker (&Dest->lfMessageFont, &Src->lfMessageFont);
}

#define S_SCHEMELOCATION    TEXT("HKCU\\Control Panel\\Appearance\\New Schemes")
#define S_SCHEMECURRENT     TEXT("HKCU\\Control Panel\\Appearance")
#define S_SCHEMELOCATIONT1  TEXT("HKCU\\Control Panel\\Appearance\\New Schemes\\Current Settings SaveAll\\Sizes\\0")
#define S_SCHEMELOCATIONT2  TEXT("HKCU\\Control Panel\\Appearance\\New Schemes\\Current Settings SaveNoVisualStyle\\Sizes\\0")
#define S_SCHEMECOLORS      TEXT("HKCU\\Control Panel\\Colors")
#define S_SCHEMEMETRICS     TEXT("HKCU\\Control Panel\\Desktop\\WindowMetrics")

BOOL
pFindWhistlerScheme (
    IN      PCTSTR SchemeName,
    OUT     PUINT SchemeNr,
    OUT     PUINT SchemeSize
    )
{
    BOOL result = FALSE;
    HKEY rootKey = NULL;
    HKEY schemeKey = NULL;
    HKEY sizeKey = NULL;
    HKEY currSizeKey = NULL;
    TCHAR schemeNrStr [MAX_PATH + 1];
    TCHAR schemeSizeStr [MAX_PATH + 1];
    PCTSTR subKeyStr = NULL;
    DWORD index = 0, index1 = 0;
    INT maxScheme = -1;
    INT currScheme = 0;
    LONG err, err1, err2;
    DWORD valueType = 0;
    DWORD valueDataSize = 0;
    PTSTR valueData = NULL;

    *SchemeNr = 0;
    *SchemeSize = 0;

    rootKey = OpenRegKeyStr (S_SCHEMELOCATION);
    if (rootKey) {
        index = 0;
        err = ERROR_SUCCESS;
        while (err == ERROR_SUCCESS) {
            err = RegEnumKey (rootKey, index, schemeNrStr, MAX_PATH + 1);
            if (err == ERROR_SUCCESS) {
                currScheme = _ttoi (schemeNrStr);
                if (currScheme > maxScheme) {
                    maxScheme = currScheme;
                }
                subKeyStr = JoinPaths (schemeNrStr, TEXT("Sizes"));
                if (subKeyStr) {
                    sizeKey = OpenRegKey (rootKey, subKeyStr);
                    if (sizeKey) {
                        index1 = 0;
                        err1 = ERROR_SUCCESS;
                        while (err1 == ERROR_SUCCESS) {
                            err1 = RegEnumKey (sizeKey, index1, schemeSizeStr, MAX_PATH + 1);
                            if (err1 == ERROR_SUCCESS) {
                                currSizeKey = OpenRegKey (sizeKey, schemeSizeStr);
                                if (currSizeKey) {
                                    err2 = RegQueryValueEx (
                                                currSizeKey,
                                                TEXT("LegacyName"),
                                                NULL,
                                                &valueType,
                                                NULL,
                                                &valueDataSize
                                                );
                                    if (((err2 == ERROR_SUCCESS) || (err2 == ERROR_MORE_DATA)) &&
                                        ((valueType == REG_SZ) || (valueType == REG_EXPAND_SZ)) &&
                                        valueDataSize
                                        ) {
                                        valueData = (PTSTR) IsmGetMemory (valueDataSize);
                                        err2 = RegQueryValueEx (
                                                    currSizeKey,
                                                    TEXT("LegacyName"),
                                                    NULL,
                                                    &valueType,
                                                    (PBYTE) valueData,
                                                    &valueDataSize
                                                    );
                                        if ((err2 == ERROR_SUCCESS) &&
                                            (StringIMatch (valueData, SchemeName))
                                            ) {
                                            *SchemeNr = _ttoi (schemeNrStr);
                                            *SchemeSize = _ttoi (schemeSizeStr);
                                            IsmReleaseMemory (valueData);
                                            valueData = NULL;
                                            CloseRegKey (currSizeKey);
                                            currSizeKey = NULL;
                                            CloseRegKey (sizeKey);
                                            sizeKey = NULL;
                                            FreePathString (subKeyStr);
                                            subKeyStr = NULL;
                                            result = TRUE;
                                            break;
                                        }
                                        IsmReleaseMemory (valueData);
                                        valueData = NULL;
                                    }
                                    CloseRegKey (currSizeKey);
                                    currSizeKey = NULL;
                                }
                            }
                            index1 ++;
                        }
                        if (result) {
                            break;
                        }
                        CloseRegKey (sizeKey);
                        sizeKey = NULL;
                    }
                    FreePathString (subKeyStr);
                    subKeyStr = NULL;
                }
                index ++;
            }
        }
        CloseRegKey (rootKey);
        rootKey = NULL;
    }

    if (!result) {
        *SchemeNr = maxScheme + 1;
    }

    return result;
}

DWORD
pConvertColor (
    IN      PCTSTR ColorStr
    )
{
    DWORD color = 0;
    PBYTE colorPtr;
    UINT index = 0;

    colorPtr = (PBYTE)&color;

    while (ColorStr && *ColorStr) {

        if (index >= 3) {
            return FALSE;
        }

        *colorPtr = (BYTE) _tcstoul ((PTSTR)ColorStr, &((PTSTR)ColorStr), 10);

        if (*ColorStr) {
            if (_tcsnextc (ColorStr) != ' ') {
                return FALSE;
            }

            ColorStr = _tcsinc (ColorStr);
        }

        colorPtr++;
        index++;
    }
    return color;
}

BOOL
pBuildSchemeColor (
    IN      PCTSTR SchemeDest,
    IN      PCTSTR SrcColorName,
    IN      PCTSTR AltSrcColorName,
    IN      PCTSTR AltSrcColorStr,
    IN      PCTSTR DestColorName
    )
{
    MIG_OBJECTTYPEID srcTypeId;
    MIG_OBJECTSTRINGHANDLE srcName;
    MIG_CONTENT srcContent;
    MIG_OBJECTTYPEID destTypeId;
    MIG_OBJECTSTRINGHANDLE destName;
    MIG_CONTENT destContent;
    DWORD color;
    DWORD valueType;
    BOOL needExtraColor = FALSE;
    PCTSTR extraColorStr = NULL;

    srcTypeId = MIG_REGISTRY_TYPE | PLATFORM_SOURCE;
    destTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;

    ZeroMemory (&destContent, sizeof (MIG_CONTENT));
    destContent.ObjectTypeId = destTypeId;
    destContent.ContentInFile = FALSE;
    destContent.Details.DetailsSize = sizeof (DWORD);
    destContent.Details.DetailsData = &valueType;

    valueType = REG_DWORD;
    destContent.MemoryContent.ContentSize = sizeof (DWORD);
    destContent.MemoryContent.ContentBytes = (PBYTE) (&color);

    srcName = IsmCreateObjectHandle (S_SCHEMECOLORS, SrcColorName);
    if (IsmAcquireObject (srcTypeId, srcName, &srcContent)) {
        if (IsValidRegSz(&srcContent)) {
            color = pConvertColor ((PCTSTR) srcContent.MemoryContent.ContentBytes);

            destName = IsmCreateObjectHandle (SchemeDest, DestColorName);
            IsmReplacePhysicalObject (destTypeId, destName, &destContent);
            IsmDestroyObjectHandle (destName);
            destName = NULL;
        }
        IsmReleaseObject (&srcContent);
    } else if (AltSrcColorName) {
        IsmDestroyObjectHandle (srcName);
        srcName = NULL;
        srcName = IsmCreateObjectHandle (S_SCHEMECOLORS, AltSrcColorName);
        if (IsmAcquireObject (srcTypeId, srcName, &srcContent)) {
            if (IsValidRegSz(&srcContent)) {
                color = pConvertColor ((PCTSTR) srcContent.MemoryContent.ContentBytes);

                destName = IsmCreateObjectHandle (SchemeDest, DestColorName);
                IsmReplacePhysicalObject (destTypeId, destName, &destContent);
                IsmDestroyObjectHandle (destName);
                destName = NULL;
                needExtraColor = TRUE;
                extraColorStr = DuplicatePathString ((PCTSTR) srcContent.MemoryContent.ContentBytes, 0);
            }
            IsmReleaseObject (&srcContent);
        }
    } else if (AltSrcColorStr) {
        color = pConvertColor (AltSrcColorStr);

        destName = IsmCreateObjectHandle (SchemeDest, DestColorName);
        IsmReplacePhysicalObject (destTypeId, destName, &destContent);
        IsmDestroyObjectHandle (destName);
        destName = NULL;
        needExtraColor = TRUE;
        extraColorStr = DuplicatePathString (AltSrcColorStr, 0);
    }
    IsmDestroyObjectHandle (srcName);
    srcName = NULL;

    if (needExtraColor) {
        if (extraColorStr) {
            valueType = REG_SZ;
            destContent.MemoryContent.ContentSize = SizeOfString (extraColorStr);
            destContent.MemoryContent.ContentBytes = (PBYTE) extraColorStr;
            destName = IsmCreateObjectHandle (S_SCHEMECOLORS, SrcColorName);
            IsmReplacePhysicalObject (destTypeId, destName, &destContent);
            IsmDestroyObjectHandle (destName);
            destName = NULL;
            FreePathString (extraColorStr);
            extraColorStr = NULL;
        }
    }

    return TRUE;
}

LONGLONG
pConvertSize (
    IN      PCTSTR SizeStr
    )
{
    INT size = 0;

    size = _tcstoul ((PTSTR)SizeStr, &((PTSTR)SizeStr), 10);
    size = -(size);
    size /= 15;

    return size;
}

BOOL
pBuildSchemeSize (
    IN      PCTSTR SchemeDest,
    IN      PCTSTR SrcSizeName,
    IN      PCTSTR DestSizeName
    )
{
    MIG_OBJECTTYPEID srcTypeId;
    MIG_OBJECTSTRINGHANDLE srcName;
    MIG_CONTENT srcContent;
    MIG_OBJECTTYPEID destTypeId;
    MIG_OBJECTSTRINGHANDLE destName;
    MIG_CONTENT destContent;
    LONGLONG size;
    DWORD valueType;

    srcTypeId = MIG_REGISTRY_TYPE | PLATFORM_SOURCE;
    destTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;

    ZeroMemory (&destContent, sizeof (MIG_CONTENT));
    destContent.ObjectTypeId = destTypeId;
    destContent.ContentInFile = FALSE;
    destContent.Details.DetailsSize = sizeof (DWORD);
    destContent.Details.DetailsData = &valueType;

    valueType = REG_QWORD;
    destContent.MemoryContent.ContentSize = sizeof (LONGLONG);
    destContent.MemoryContent.ContentBytes = (PBYTE) (&size);

    srcName = IsmCreateObjectHandle (S_SCHEMEMETRICS, SrcSizeName);
    if (IsmAcquireObject (srcTypeId, srcName, &srcContent)) {
        if (IsValidRegSz(&srcContent)) {
            size = pConvertSize ((PCTSTR) srcContent.MemoryContent.ContentBytes);

            destName = IsmCreateObjectHandle (SchemeDest, DestSizeName);
            IsmReplacePhysicalObject (destTypeId, destName, &destContent);
            IsmDestroyObjectHandle (destName);
            destName = NULL;
        }
        IsmReleaseObject (&srcContent);
    }
    IsmDestroyObjectHandle (srcName);
    srcName = NULL;

    return TRUE;
}

BOOL
pBuildSchemeFont (
    IN      PCTSTR SchemeDest,
    IN      PCTSTR SrcSizeName,
    IN      PCTSTR DestSizeName
    )
{
    MIG_OBJECTTYPEID srcTypeId;
    MIG_OBJECTSTRINGHANDLE srcName;
    MIG_CONTENT srcContent;
    MIG_OBJECTTYPEID destTypeId;
    MIG_OBJECTSTRINGHANDLE destName;
    MIG_CONTENT destContent;
    LOGFONTW destFont;
    DWORD valueType;

    srcTypeId = MIG_REGISTRY_TYPE | PLATFORM_SOURCE;
    destTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;

    ZeroMemory (&destContent, sizeof (MIG_CONTENT));
    destContent.ObjectTypeId = destTypeId;
    destContent.ContentInFile = FALSE;
    destContent.Details.DetailsSize = sizeof (DWORD);
    destContent.Details.DetailsData = &valueType;

    ZeroMemory (&destFont, sizeof (LOGFONTW));

    valueType = REG_BINARY;
    destContent.MemoryContent.ContentSize = sizeof (LOGFONTW);
    destContent.MemoryContent.ContentBytes = (PBYTE) (&destFont);

    srcName = IsmCreateObjectHandle (S_SCHEMEMETRICS, SrcSizeName);
    if (IsmAcquireObject (srcTypeId, srcName, &srcContent)) {
        if (IsValidRegType (&srcContent, REG_BINARY)) {
            if (srcContent.MemoryContent.ContentSize == sizeof (SHORT_LOGFONT)) {
                pConvertShortLogFontWorker (&destFont, (PSHORT_LOGFONT) srcContent.MemoryContent.ContentBytes);
            } else if (srcContent.MemoryContent.ContentSize == sizeof (LOGFONTA)) {
                pConvertLogFontWorker (&destFont, (PLOGFONTA) srcContent.MemoryContent.ContentBytes);
            } else {
                CopyMemory (&destFont, srcContent.MemoryContent.ContentBytes, sizeof (LOGFONTW));
            }

            destName = IsmCreateObjectHandle (SchemeDest, DestSizeName);
            IsmReplacePhysicalObject (destTypeId, destName, &destContent);
            IsmDestroyObjectHandle (destName);
            destName = NULL;
        }
        IsmReleaseObject (&srcContent);
    }
    IsmDestroyObjectHandle (srcName);
    srcName = NULL;

    return TRUE;
}

BOOL
pBuildTempScheme (
    IN      PCTSTR SchemeDest
    )
{
    MIG_OBJECTTYPEID srcTypeId;
    MIG_OBJECTSTRINGHANDLE srcName;
    MIG_CONTENT srcContent;
    MIG_OBJECTTYPEID destTypeId;
    MIG_OBJECTSTRINGHANDLE destName;
    MIG_CONTENT destContent;
    DWORD value;
    DWORD valueType;

    srcTypeId = MIG_REGISTRY_TYPE | PLATFORM_SOURCE;
    destTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;

    ZeroMemory (&destContent, sizeof (MIG_CONTENT));
    destContent.ObjectTypeId = destTypeId;
    destContent.ContentInFile = FALSE;
    destContent.Details.DetailsSize = sizeof (DWORD);
    destContent.Details.DetailsData = &valueType;

    // first we build the Color #<nr> values

    pBuildSchemeColor (SchemeDest, TEXT("Scrollbar"), NULL, NULL, TEXT("Color #0"));
    pBuildSchemeColor (SchemeDest, TEXT("Background"), NULL, NULL, TEXT("Color #1"));
    pBuildSchemeColor (SchemeDest, TEXT("ActiveTitle"), NULL, NULL, TEXT("Color #2"));
    pBuildSchemeColor (SchemeDest, TEXT("InactiveTitle"), NULL, NULL, TEXT("Color #3"));
    pBuildSchemeColor (SchemeDest, TEXT("Menu"), NULL, NULL, TEXT("Color #4"));
    pBuildSchemeColor (SchemeDest, TEXT("Window"), NULL, NULL, TEXT("Color #5"));
    pBuildSchemeColor (SchemeDest, TEXT("WindowFrame"), NULL, NULL, TEXT("Color #6"));
    pBuildSchemeColor (SchemeDest, TEXT("MenuText"), NULL, NULL, TEXT("Color #7"));
    pBuildSchemeColor (SchemeDest, TEXT("WindowText"), NULL, NULL, TEXT("Color #8"));
    pBuildSchemeColor (SchemeDest, TEXT("TitleText"), NULL, NULL, TEXT("Color #9"));
    pBuildSchemeColor (SchemeDest, TEXT("ActiveBorder"), NULL, NULL, TEXT("Color #10"));
    pBuildSchemeColor (SchemeDest, TEXT("InactiveBorder"), NULL, NULL, TEXT("Color #11"));
    pBuildSchemeColor (SchemeDest, TEXT("AppWorkSpace"), NULL, NULL, TEXT("Color #12"));
    pBuildSchemeColor (SchemeDest, TEXT("Hilight"), NULL, NULL, TEXT("Color #13"));
    pBuildSchemeColor (SchemeDest, TEXT("HilightText"), NULL, NULL, TEXT("Color #14"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonFace"), NULL, NULL, TEXT("Color #15"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonShadow"), NULL, NULL, TEXT("Color #16"));
    pBuildSchemeColor (SchemeDest, TEXT("GrayText"), NULL, NULL, TEXT("Color #17"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonText"), NULL, NULL, TEXT("Color #18"));
    pBuildSchemeColor (SchemeDest, TEXT("InactiveTitleText"), NULL, NULL, TEXT("Color #19"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonHilight"), NULL, NULL, TEXT("Color #20"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonDkShadow"), NULL, NULL, TEXT("Color #21"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonLight"), NULL, NULL, TEXT("Color #22"));
    pBuildSchemeColor (SchemeDest, TEXT("InfoText"), NULL, NULL, TEXT("Color #23"));
    pBuildSchemeColor (SchemeDest, TEXT("InfoWindow"), NULL, NULL, TEXT("Color #24"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonAlternateFace"), NULL, TEXT("180 180 180"), TEXT("Color #25"));
    pBuildSchemeColor (SchemeDest, TEXT("HotTrackingColor"), NULL, TEXT("0 0 255"), TEXT("Color #26"));
    pBuildSchemeColor (SchemeDest, TEXT("GradientActiveTitle"), NULL, TEXT("16 132 208"), TEXT("Color #27"));
    pBuildSchemeColor (SchemeDest, TEXT("GradientInactiveTitle"), NULL, TEXT("181 181 181"), TEXT("Color #28"));
    pBuildSchemeColor (SchemeDest, TEXT("MenuHilight"), TEXT("Hilight"), NULL, TEXT("Color #29"));
    pBuildSchemeColor (SchemeDest, TEXT("MenuBar"), TEXT("Menu"), NULL, TEXT("Color #30"));

    // now we build the Size #<nr> values

    pBuildSchemeSize (SchemeDest, TEXT("BorderWidth"), TEXT("Size #0"));
    pBuildSchemeSize (SchemeDest, TEXT("ScrollWidth"), TEXT("Size #1"));
    pBuildSchemeSize (SchemeDest, TEXT("ScrollHeight"), TEXT("Size #2"));
    pBuildSchemeSize (SchemeDest, TEXT("CaptionWidth"), TEXT("Size #3"));
    pBuildSchemeSize (SchemeDest, TEXT("CaptionHeight"), TEXT("Size #4"));
    pBuildSchemeSize (SchemeDest, TEXT("SmCaptionWidth"), TEXT("Size #5"));
    pBuildSchemeSize (SchemeDest, TEXT("SmCaptionHeight"), TEXT("Size #6"));
    pBuildSchemeSize (SchemeDest, TEXT("MenuWidth"), TEXT("Size #7"));
    pBuildSchemeSize (SchemeDest, TEXT("MenuHeight"), TEXT("Size #8"));

    // finally build the Font #<nr> values

    pBuildSchemeFont (SchemeDest, TEXT("CaptionFont"), TEXT("Font #0"));
    pBuildSchemeFont (SchemeDest, TEXT("SmCaptionFont"), TEXT("Font #1"));
    pBuildSchemeFont (SchemeDest, TEXT("MenuFont"), TEXT("Font #2"));
    pBuildSchemeFont (SchemeDest, TEXT("IconFont"), TEXT("Font #3"));
    pBuildSchemeFont (SchemeDest, TEXT("StatusFont"), TEXT("Font #4"));
    pBuildSchemeFont (SchemeDest, TEXT("MessageFont"), TEXT("Font #5"));

    value = 0;
    valueType = REG_DWORD;
    destContent.MemoryContent.ContentSize = sizeof (DWORD);
    destContent.MemoryContent.ContentBytes = (PBYTE) (&value);
    destName = IsmCreateObjectHandle (SchemeDest, TEXT("Contrast"));
    IsmReplacePhysicalObject (destTypeId, destName, &destContent);
    IsmDestroyObjectHandle (destName);
    destName = NULL;
    destName = IsmCreateObjectHandle (SchemeDest, TEXT("Flat Menus"));
    IsmReplacePhysicalObject (destTypeId, destName, &destContent);
    IsmDestroyObjectHandle (destName);
    destName = NULL;
    return TRUE;
}

BOOL
pUpdateSchemeData (
    IN      PCTSTR SchemeName,
    IN      UINT SchemeNr,
    IN      UINT SchemeSize
    )
{
    static BOOL firstTime = TRUE;
    BOOL current = FALSE;
    MIG_OBJECTTYPEID objectTypeId;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    TCHAR schemeNrStr [20];
    TCHAR schemeSizeStr [20];
    PCTSTR keyStr = NULL;
    DWORD valueType = REG_SZ;
    BOOL noCurrent = FALSE;

    // first let's see if this is the current scheme
    objectTypeId = MIG_REGISTRY_TYPE | PLATFORM_SOURCE;
    objectName = IsmCreateObjectHandle (S_SCHEMECURRENT, TEXT("Current"));
    if (IsmAcquireObject (objectTypeId, objectName, &objectContent)) {
        current = ((IsValidRegSz(&objectContent)) &&
                   (StringIMatch (SchemeName, (PCTSTR) objectContent.MemoryContent.ContentBytes))
                   );
        noCurrent = ((IsValidRegSz(&objectContent)) &&
                     (StringIMatch (TEXT(""), (PCTSTR) objectContent.MemoryContent.ContentBytes))
                     );
        IsmReleaseObject (&objectContent);
    } else {
        noCurrent = TRUE;
    }
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    if (noCurrent) {
        // we did not have a current scheme, so we had only a temporary scheme
        // First time when we encounter this we will attempt to fix it.
        if (firstTime) {
            // we will build HKR\Control Panel\Appearance\New Schemes\Current Settings SaveAll and
            // HKR\Control Panel\Appearance\New Schemes\Current Settings SaveNoVisualStyle from
            // HKR\Control Panel\Colors and HKR\Control Panel\Desktop\WindowMetrics

            // We need to be carefull since we are reading source machine information and we need to
            // convert it (especially font blobs).

            pBuildTempScheme (S_SCHEMELOCATIONT1);
            pBuildTempScheme (S_SCHEMELOCATIONT2);

            firstTime = FALSE;
        }
    }

    if (!current) {
        return TRUE;
    }

    objectTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;

    ZeroMemory (&objectContent, sizeof (MIG_CONTENT));
    objectContent.ObjectTypeId = objectTypeId;
    objectContent.ContentInFile = FALSE;
    objectContent.MemoryContent.ContentSize = SizeOfString (SchemeName);
    objectContent.MemoryContent.ContentBytes = (PBYTE) SchemeName;
    objectContent.Details.DetailsSize = sizeof (DWORD);
    objectContent.Details.DetailsData = &valueType;

    objectName = IsmCreateObjectHandle (S_SCHEMECURRENT, TEXT("Current"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectName = IsmCreateObjectHandle (S_SCHEMECURRENT, TEXT("NewCurrent"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    _ultot (SchemeNr, schemeNrStr, 10);
    objectContent.MemoryContent.ContentSize = SizeOfString (schemeNrStr);
    objectContent.MemoryContent.ContentBytes = (PBYTE) schemeNrStr;
    objectName = IsmCreateObjectHandle (S_SCHEMELOCATION, TEXT("SelectedStyle"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    keyStr = JoinPaths (S_SCHEMELOCATION, schemeNrStr);
    _ultot (SchemeSize, schemeSizeStr, 10);
    objectContent.MemoryContent.ContentSize = SizeOfString (schemeSizeStr);
    objectContent.MemoryContent.ContentBytes = (PBYTE) schemeSizeStr;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("SelectedSize"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;
    FreePathString (keyStr);
    keyStr = NULL;

    // finally we need to copy the current scheme into
    // HKR\Control Panel\Appearance\New Schemes\Current Settings SaveAll and
    // HKR\Control Panel\Appearance\New Schemes\Current Settings SaveNoVisualStyle
    pBuildTempScheme (S_SCHEMELOCATIONT1);
    pBuildTempScheme (S_SCHEMELOCATIONT2);

    return TRUE;
}

BOOL
pCreateWhistlerScheme (
    IN      PCTSTR SchemeName,
    IN      PSCHEMEDATA_NT SchemeData,
    IN      UINT SchemeNr
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    DWORD valueType = 0;
    TCHAR schemeNrStr [20];
    TCHAR valueName [20];
    TCHAR normalStr [] = TEXT("Normal");
    PCTSTR keyStr = NULL;
    DWORD value = 0;
    DWORD index = 0;
    ULONGLONG qvalue = 0;

    objectTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;
    ZeroMemory (&objectContent, sizeof (MIG_CONTENT));
    objectContent.ObjectTypeId = objectTypeId;
    objectContent.ContentInFile = FALSE;
    objectContent.Details.DetailsSize = sizeof (DWORD);
    objectContent.Details.DetailsData = &valueType;

    _ultot (SchemeNr, schemeNrStr, 10);

    keyStr = JoinPathsInPoolEx ((NULL, S_SCHEMELOCATION, schemeNrStr, NULL));
    valueType = REG_SZ;
    objectContent.MemoryContent.ContentSize = SizeOfString (SchemeName);
    objectContent.MemoryContent.ContentBytes = (PBYTE) SchemeName;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("DisplayName"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    FreePathString (keyStr);
    keyStr = NULL;

    keyStr = JoinPathsInPoolEx ((NULL, S_SCHEMELOCATION, schemeNrStr, TEXT("Sizes\\0"), NULL));

    valueType = REG_SZ;

    objectContent.MemoryContent.ContentSize = SizeOfString (normalStr);
    objectContent.MemoryContent.ContentBytes = (PBYTE) normalStr;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("DisplayName"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentSize = SizeOfString (SchemeName);
    objectContent.MemoryContent.ContentBytes = (PBYTE) SchemeName;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("LegacyName"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    value = 0;
    valueType = REG_DWORD;
    objectContent.MemoryContent.ContentSize = sizeof (DWORD);
    objectContent.MemoryContent.ContentBytes = (PBYTE) (&value);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Contrast"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Flat Menus"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    // write Color #<nr> values
    objectContent.MemoryContent.ContentSize = sizeof (DWORD);
    objectContent.MemoryContent.ContentBytes = (PBYTE) (&value);
    for (index = 0; index < COLOR_MAX_NT; index ++) {
        value = SchemeData->rgb [index];
        wsprintf (valueName, TEXT("Color #%u"), index);
        objectName = IsmCreateObjectHandle (keyStr, valueName);
        IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
        IsmDestroyObjectHandle (objectName);
        objectName = NULL;
    }
    value = SchemeData->rgb [COLOR_HIGHLIGHT];
    wsprintf (valueName, TEXT("Color #%u"), COLOR_MENUHILIGHT);
    objectName = IsmCreateObjectHandle (keyStr, valueName);
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;
    value = SchemeData->rgb [COLOR_MENU];
    wsprintf (valueName, TEXT("Color #%u"), COLOR_MAX_NT + 1);
    objectName = IsmCreateObjectHandle (keyStr, valueName);
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    // now, let's write the sizes
    valueType = REG_QWORD;
    objectContent.MemoryContent.ContentSize = sizeof (ULONGLONG);
    objectContent.MemoryContent.ContentBytes = (PBYTE) (&qvalue);

    qvalue = SchemeData->ncm.iBorderWidth;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #0"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iScrollWidth;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #1"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iScrollHeight;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #2"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iCaptionWidth;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #3"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iCaptionHeight;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #4"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iSmCaptionWidth;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #5"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iSmCaptionHeight;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #6"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iMenuWidth;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #7"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iMenuHeight;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #8"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    // finally, let's write the fonts
    valueType = REG_BINARY;
    objectContent.MemoryContent.ContentSize = sizeof (LOGFONTW);

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->ncm.lfCaptionFont);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #0"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->ncm.lfSmCaptionFont);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #1"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->ncm.lfMenuFont);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #2"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->lfIconTitle);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #3"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->ncm.lfStatusFont);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #4"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->ncm.lfMessageFont);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #5"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    FreePathString (keyStr);
    keyStr = NULL;

    return TRUE;
}

BOOL
pDoesNewSchemeKeyExist (
    VOID
    )
{
    BOOL result = FALSE;
    HKEY rootKey = NULL;

    rootKey = OpenRegKeyStr (S_SCHEMELOCATION);

    result = rootKey != NULL;

    if (rootKey) {
        CloseRegKey (rootKey);
    }

    return result;
}

BOOL
WINAPI
pConvertAppearanceSchemeCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    BOOL converted = FALSE;
    UINT convertedSize = 0;
    PBYTE result = NULL;
    PDWORD valueType;
    SCHEMEDATA_NT sd_nt;
    PSCHEMEDATA_V1 psd_v1;
    PSCHEMEDATA_V2 psd_v2;
    PSCHEMEDATA_V3 psd_v3;
    PSCHEMEDATA_V4 psd_v4;
    PSCHEMEDATA_V1A psd_v1a;
    BOOL Copy3dValues = FALSE;
    PCTSTR node = NULL, leaf = NULL;
    UINT schemeNr = 0;
    UINT schemeSize = 0;

    //
    // Filter the data for any references to %windir%
    //

    ZeroMemory (&sd_nt, sizeof (SCHEMEDATA_NT));

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_BINARY) {
            if (CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V1) ||
                CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V2) ||
                CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V3) ||
                CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V4) ||
                CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V1A)
                ) {
                psd_v1 = (PSCHEMEDATA_V1)CurrentContent->MemoryContent.ContentBytes;
                if (psd_v1->version == 1 ||
                    psd_v1->version == 2 ||
                    psd_v1->version == 3 ||
                    psd_v1->version == 4
                    ) {
                    //
                    // this is a valid scheme and it has a supported version
                    //
                    //
                    // Convert the structure
                    //

                    if (psd_v1->version == 1) {
                        sd_nt.version = 2;
                        pConvertNonClientMetrics (&sd_nt.ncm, &psd_v1->ncm);
                        pConvertShortLogFontWorker (&sd_nt.lfIconTitle, &psd_v1->lfIconTitle);

                        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
                        CopyMemory (
                            &sd_nt.rgb,
                            &psd_v1->rgb,
                            min (sizeof (psd_v1->rgb), sizeof (sd_nt.rgb))
                            );

                        Copy3dValues = TRUE;

                    } else if (psd_v1->version == 3 && CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V1A)) {

                        psd_v1a = (PSCHEMEDATA_V1A) psd_v1;

                        sd_nt.version = 2;
                        pConvertNonClientMetrics (&sd_nt.ncm, &psd_v1a->ncm);
                        pConvertShortLogFontWorker (&sd_nt.lfIconTitle, &psd_v1a->lfIconTitle);

                        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
                        CopyMemory (
                            &sd_nt.rgb,
                            &psd_v1a->rgb,
                            min (sizeof (psd_v1a->rgb), sizeof (sd_nt.rgb))
                            );

                        Copy3dValues = TRUE;

                    } else if (psd_v1->version == 2 && CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V2)) {

                        psd_v2 = (PSCHEMEDATA_V2) psd_v1;

                        sd_nt.version = 2;
                        pCopyNonClientMetrics (&sd_nt.ncm, &psd_v2->ncm);
                        pCopyLogFontWorker (&sd_nt.lfIconTitle, &psd_v2->lfIconTitle);

                        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
                        CopyMemory (
                            &sd_nt.rgb,
                            &psd_v2->rgb,
                            min (sizeof (psd_v2->rgb), sizeof (sd_nt.rgb))
                            );

                        Copy3dValues = TRUE;

                    } else if (psd_v1->version == 3 && CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V3)) {
                        psd_v3 = (PSCHEMEDATA_V3) psd_v1;

                        sd_nt.version = 2;
                        pConvertNonClientMetrics (&sd_nt.ncm, &psd_v3->ncm);
                        pConvertLogFontWorker (&sd_nt.lfIconTitle, &psd_v3->lfIconTitle);

                        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
                        CopyMemory (
                            &sd_nt.rgb,
                            &psd_v3->rgb,
                            min (sizeof (psd_v3->rgb), sizeof (sd_nt.rgb))
                            );

                        Copy3dValues = TRUE;

                    } else if (psd_v1->version == 4) {
                        psd_v4 = (PSCHEMEDATA_V4) psd_v1;

                        sd_nt.version = 2;
                        pConvertNonClientMetrics (&sd_nt.ncm, &psd_v4->ncm);
                        pConvertLogFontWorker (&sd_nt.lfIconTitle, &psd_v4->lfIconTitle);

                        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
                        CopyMemory (
                            &sd_nt.rgb,
                            &psd_v4->rgb,
                            min (sizeof (psd_v4->rgb), sizeof (sd_nt.rgb))
                            );
                    }

                    if (Copy3dValues) {
                        //
                        // Make sure the NT structure has values for 3D colors
                        //

                        sd_nt.rgb[COLOR_BUTTONALTFACE] = sd_nt.rgb[COLOR_BTNFACE];
                        sd_nt.rgb[COLOR_HOTLIGHT] = sd_nt.rgb[COLOR_ACTIVECAPTION];
                        sd_nt.rgb[COLOR_GRADIENTACTIVECAPTION] = sd_nt.rgb[COLOR_ACTIVECAPTION];
                        sd_nt.rgb[COLOR_GRADIENTINACTIVECAPTION] = sd_nt.rgb[COLOR_INACTIVECAPTION];
                    }
                    converted = TRUE;
                    convertedSize = sizeof (sd_nt);
                    result = IsmGetMemory (convertedSize);
                    CopyMemory (result, &sd_nt, convertedSize);
                }
            }
        }

        if (converted && convertedSize && result) {
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = result;

        }

        if ((*valueType == REG_BINARY) &&
            (converted || (CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_NT))) &&
            (pDoesNewSchemeKeyExist ())
            ) {
            // now we need to do some extra work
            // Each scheme must be converted to the new Whistler format

            // First we look to see if the scheme that we just processed exists in new Whistler format
            // For this we enumerate the HKR\Control Panel\Appearance\New Schemes
            // and try to find the valuename "Legacy Name" that matches the value name of this scheme
            // If we find it, we only update HKR\Control Panel\Appearance [Current],
            // HKR\Control Panel\Appearance [NewCurrent], HKR\Control Panel\Appearance\New Schemes [SelectedStyle]
            // and HKR\Control Panel\Appearance\New Schemes\<Scheme Number> [SelectedSize].
            // If not, we create a new Whistler scheme and update the above 4 value names.

            if (IsmCreateObjectStringsFromHandle (SrcObjectName, &node, &leaf)) {
                if (leaf) {
                    if (pFindWhistlerScheme (leaf, &schemeNr, &schemeSize)) {
                        pUpdateSchemeData (leaf, schemeNr, schemeSize);
                    } else {
                        if (pCreateWhistlerScheme (
                                leaf,
                                converted?
                                    (PSCHEMEDATA_NT)NewContent->MemoryContent.ContentBytes:
                                    (PSCHEMEDATA_NT)CurrentContent->MemoryContent.ContentBytes,
                                schemeNr
                                )) {
                            pUpdateSchemeData (leaf, schemeNr, 0);
                        }
                    }
                }
                IsmDestroyObjectString (node);
                IsmDestroyObjectString (leaf);
            }
        }

    }

    return TRUE;
}

BOOL
WINAPI
pAntiAliasCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    DWORD value = 0;
    BOOL converted = FALSE;
    PTSTR result = NULL;
    UINT convertedSize = 0;
    PDWORD valueType;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_SZ) {

            if (CurrentContent->MemoryContent.ContentSize > 0) {
                value = _tcstoul ((PCTSTR)CurrentContent->MemoryContent.ContentBytes, NULL, 10);
            }
            if (value > 0) {
                converted = TRUE;
                convertedSize = 11 * sizeof (TCHAR); // DWORD takes no more than 11 characters
                result = IsmGetMemory (convertedSize);
                wsprintf (result, TEXT("%d"), FE_AA_ON);
            }
        }

        if (converted && convertedSize && result) {
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = (PCBYTE) result;
        }
    }

    return TRUE;
}

BOOL
pBufferMatch (
    IN      PCBYTE Buffer1,
    IN      PCBYTE Buffer2,
    IN      UINT Size
    )
{
    UINT i;

    for (i = 0; i < Size; i ++) {
        if (Buffer1 [i] != Buffer2 [i]) {
            return FALSE;
        }
    }
    return TRUE;
}

BOOL
WINAPI
pFixActiveDesktopCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    #define badBufferSize   16
    #define goodBufferSize  28
    const BYTE badBuffer[badBufferSize] =
                {0x10, 0x00, 0x00, 0x00,
                 0x01, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00};
    const BYTE goodBuffer[goodBufferSize] =
                {0x1C, 0x00, 0x00, 0x00,
                 0x20, 0x08, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00,
                 0x0A, 0x00, 0x00, 0x00};
    BOOL converted = FALSE;
    PBYTE result = NULL;
    UINT convertedSize = 0;
    PDWORD valueType;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_BINARY) {

            if (CurrentContent->MemoryContent.ContentSize == badBufferSize) {
                if (pBufferMatch (CurrentContent->MemoryContent.ContentBytes, badBuffer, badBufferSize)) {
                    converted = TRUE;
                    convertedSize = goodBufferSize;
                    result = IsmGetMemory (convertedSize);
                    CopyMemory (result, goodBuffer, convertedSize);
                }
            }
        }

        if (converted && convertedSize && result) {
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = result;
        }
    }

    return TRUE;
}

BOOL
WINAPI
pConvertRecentDocsMRUCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    BOOL converted = FALSE;
    PBYTE result = NULL;
    UINT convertedSize = 0;
    PDWORD valueType;
    PCSTR str, structPtr;
    PCWSTR strW;
    UINT size, sizeW;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType == REG_BINARY) && (CurrentContent->MemoryContent.ContentSize)) {
            // The content of this is a NULL terminated string followed by some binary data.
            // We need to convert the string to unicode and add the existent
            // binary data
            str = (PCSTR)CurrentContent->MemoryContent.ContentBytes;
            __try {
                structPtr = GetEndOfStringA (str);
                structPtr = _mbsinc (structPtr);
                if (structPtr && (structPtr > str)) {
                    size = CurrentContent->MemoryContent.ContentSize - (UINT)(structPtr - str);
                    if (size == sizeof (WORD) + *((PWORD)structPtr)) {
                        converted = TRUE;
                        strW = ConvertAtoW (str);
                        sizeW = SizeOfStringW (strW);
                        convertedSize = sizeW + size;
                        result = IsmGetMemory (convertedSize);
                        CopyMemory (result, strW, sizeW);
                        CopyMemory (result + sizeW, structPtr, size);
                        FreeConvertedStr (strW);
                    }
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                // the structure was not well formed
                converted = FALSE;
                if (result) {
                    IsmReleaseMemory (result);
                }
            }
        }

        if (converted && convertedSize && result) {
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = result;
        }
    }

    return TRUE;
}

PCTSTR
pFindNewScreenSaver (
    IN      PCTSTR OldScreenSaver
    )
{
    PTSTR multiSz = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_TYPE dataType;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR newScrName;
    PCTSTR result = NULL;

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {

        if (InfFindFirstLine (infHandle, TEXT("SCR Rename"), OldScreenSaver, &is)) {

            newScrName = InfGetStringField (&is, 1);
            if (newScrName) {
                result = DuplicatePathString (newScrName, 0);
            }
        }

        InfNameHandle (infHandle, NULL, FALSE);

    } else {

        if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, NULL, 0, &sizeNeeded, NULL)) {
            result = DuplicatePathString (OldScreenSaver, 0);
            return result;
        }

        __try {
            multiSz = AllocText (sizeNeeded);

            if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, (PBYTE) multiSz, sizeNeeded, NULL, NULL)) {
                __leave;
            }

            if (EnumFirstMultiSz (&e, multiSz)) {

                do {

                    infHandle = InfOpenInfFile (e.CurrentString);
                    if (infHandle != INVALID_HANDLE_VALUE) {

                        if (InfFindFirstLine (infHandle, TEXT("SCR Rename"), OldScreenSaver, &is)) {

                            newScrName = InfGetStringField (&is, 1);
                            if (newScrName) {
                                result = DuplicatePathString (newScrName, 0);
                                InfCloseInfFile (infHandle);
                                infHandle = INVALID_HANDLE_VALUE;
                                __leave;
                            }
                        }
                    } else {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_INF, e.CurrentString));
                    }
                    InfCloseInfFile (infHandle);
                    infHandle = INVALID_HANDLE_VALUE;
                } while (EnumNextMultiSz (&e));

            }
        }
        __finally {
            FreeText (multiSz);
        }
    }

    InfResetInfStruct (&is);

    if (!result) {
        result = DuplicatePathString (OldScreenSaver, 0);
    }
    return result;
}

BOOL
pIsEmptyStr (
    IN      PCTSTR String
    )
{
    if (String) {
        String = SkipSpace (String);
        if (String) {
            if (*String) {
                return FALSE;
            }
        }
    }
    return TRUE;
}

BOOL
WINAPI
pConvertScnSaver (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PDWORD valueType;
    PCTSTR exePath = NULL;
    PTSTR exeName = NULL;
    PCTSTR exeNativeName = NULL;
    PCTSTR newExeName = NULL;
    PCTSTR expExePath = NULL;
    MIG_OBJECTSTRINGHANDLE sourceObjectName = NULL;
    MIG_OBJECTSTRINGHANDLE destObjectName = NULL;
    MIG_CONTENT destContent;
    MIG_OBJECTTYPEID destObjectTypeId;
    BOOL deleted;
    BOOL replaced;
    BOOL migrateSrcReg = FALSE;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_SZ) {

            //
            // Extract the source screen saver path from the reg value data
            //

            if (pIsEmptyStr ((PCTSTR) CurrentContent->MemoryContent.ContentBytes)) {
                migrateSrcReg = TRUE;
            } else {
                // first we try to see if the source SCR exists on the destination
                // we have two steps :
                // 1. Filter the source and see if the destination exists
                // 2. Filter the source path, append the source file and see if the destination exists
                exePath = (PCTSTR) (CurrentContent->MemoryContent.ContentBytes);
                if (exePath) {
                    expExePath = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, exePath, NULL);
                    exeName = (PTSTR) FindLastWack (expExePath?expExePath:exePath);
                }

                if (exeName) {
                    *exeName++ = 0;

                    sourceObjectName = IsmCreateObjectHandle (expExePath?expExePath:exePath, exeName);

                    destObjectName = IsmFilterObject(
                                            MIG_FILE_TYPE | PLATFORM_SOURCE,
                                            sourceObjectName,
                                            &destObjectTypeId,
                                            &deleted,
                                            &replaced
                                            );

                    migrateSrcReg = !deleted || replaced;

                    if (migrateSrcReg) {

                        migrateSrcReg = FALSE;

                        exeNativeName = IsmGetNativeObjectName (MIG_FILE_TYPE, destObjectName?destObjectName:sourceObjectName);

                        if (exeNativeName) {
                            NewContent->MemoryContent.ContentSize = SizeOfString (exeNativeName);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            StringCopy ((PTSTR)NewContent->MemoryContent.ContentBytes, exeNativeName);
                            migrateSrcReg = TRUE;
                            IsmReleaseMemory (exeNativeName);
                        }

                        if (sourceObjectName) {
                            IsmDestroyObjectHandle (sourceObjectName);
                            sourceObjectName = NULL;
                        }

                        if (destObjectName) {
                            IsmDestroyObjectHandle (destObjectName);
                            destObjectName = NULL;
                        }
                    } else {

                        if (sourceObjectName) {
                            IsmDestroyObjectHandle (sourceObjectName);
                            sourceObjectName = NULL;
                        }

                        if (destObjectName) {
                            IsmDestroyObjectHandle (destObjectName);
                            destObjectName = NULL;
                        }

                        sourceObjectName = IsmCreateObjectHandle (expExePath?expExePath:exePath, NULL);

                        destObjectName = IsmFilterObject(
                                                MIG_FILE_TYPE | PLATFORM_SOURCE,
                                                sourceObjectName,
                                                &destObjectTypeId,
                                                &deleted,
                                                &replaced
                                                );

                        migrateSrcReg = !deleted || replaced;

                        if (migrateSrcReg) {

                            migrateSrcReg = FALSE;

                            //
                            // get the equivalent SCR file from the INF
                            //
                            newExeName = pFindNewScreenSaver (exeName);

                            if (newExeName) {

                                exeNativeName = IsmGetNativeObjectName (MIG_FILE_TYPE, destObjectName?destObjectName:sourceObjectName);

                                if (destObjectName) {
                                    IsmDestroyObjectHandle (destObjectName);
                                    destObjectName = NULL;
                                }

                                if (exeNativeName) {

                                    destObjectName = IsmCreateObjectHandle (exeNativeName, newExeName);
                                    IsmReleaseMemory (exeNativeName);

                                    if (IsmAcquireObject (MIG_FILE_TYPE | PLATFORM_DESTINATION, destObjectName, &destContent)) {
                                        IsmReleaseObject (&destContent);
                                        exeNativeName = IsmGetNativeObjectName (MIG_FILE_TYPE, destObjectName);
                                        if (exeNativeName) {
                                            NewContent->MemoryContent.ContentSize = SizeOfString (exeNativeName);
                                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                                            StringCopy ((PTSTR)NewContent->MemoryContent.ContentBytes, exeNativeName);
                                            migrateSrcReg = TRUE;
                                            IsmReleaseMemory (exeNativeName);
                                        }
                                    }

                                }
                                FreePathString (newExeName);
                            }
                        }

                        if (sourceObjectName) {
                            IsmDestroyObjectHandle (sourceObjectName);
                            sourceObjectName = NULL;
                        }

                        if (destObjectName) {
                            IsmDestroyObjectHandle (destObjectName);
                            destObjectName = NULL;
                        }
                    }
                }

                if (expExePath) {
                    IsmReleaseMemory (expExePath);
                    expExePath = NULL;
                }

            }

            //
            // If we should migrate the entry, then just leave everything
            // alone. If not, then we need to put the destination value in the
            // outbound content.
            //

            if (!migrateSrcReg) {
                MYASSERT (!(SrcObjectTypeId & PLATFORM_DESTINATION));

                destObjectName = IsmFilterObject(
                                        SrcObjectTypeId | PLATFORM_SOURCE,
                                        SrcObjectName,
                                        &destObjectTypeId,
                                        &deleted,
                                        NULL
                                        );

                if (!deleted) {

                    destObjectTypeId = SrcObjectTypeId & ~(PLATFORM_MASK);
                    destObjectTypeId |= PLATFORM_DESTINATION;

                    if (IsmAcquireObject (destObjectTypeId, destObjectName?destObjectName:SrcObjectName, &destContent)) {
                        NewContent->MemoryContent.ContentSize = destContent.MemoryContent.ContentSize;
                        NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                        CopyMemory ((PBYTE)NewContent->MemoryContent.ContentBytes, destContent.MemoryContent.ContentBytes, NewContent->MemoryContent.ContentSize);
                        IsmReleaseObject (&destContent);
                    }
                }

                IsmDestroyObjectHandle (destObjectName);
                INVALID_POINTER (destObjectName);
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pConvertIdentityCount(
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_CONTENT objectContent;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    MIG_OBJECTSTRINGHANDLE filteredName;
    DWORD value = 0;
    PTSTR node;
    PTSTR leaf;
    MIG_OBJECTTYPEID destObjectTypeId;
    BOOL deleted;
    BOOL replaced;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {

        // Read the current Identity count
        value = pGetDestDwordValue (TEXT("HKCU\\Identities"), TEXT("Identity Ordinal"));

        // Add the number of new source identities
        enumPattern = IsmCreateSimpleObjectPattern (
                          TEXT("HKCU\\Identities"),
                          TRUE,
                          TEXT("Username"),
                          FALSE);
        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
           do {
               if (IsmIsApplyObjectId (objectEnum.ObjectId)) {
                   IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
                   if (leaf && *leaf) {
                       // Check if we created this identity on the dest
                       filteredName = IsmFilterObject (g_RegType | PLATFORM_SOURCE,
                                                       objectEnum.ObjectName,
                                                       &destObjectTypeId,
                                                       &deleted,
                                                       &replaced);
                       if (filteredName) {
                           if (DoesDestRegExist(filteredName, REG_SZ) == FALSE) {
                               value++;
                           }
                           IsmDestroyObjectHandle(filteredName);
                       } else if (DoesDestRegExist(objectEnum.ObjectName, REG_SZ) == FALSE) {
                           value++;
                       }
                   }
                   IsmDestroyObjectString (node);
                   IsmDestroyObjectString (leaf);
               }
           } while (IsmEnumNextObject (&objectEnum));
        }
        IsmDestroyObjectHandle (enumPattern);

        // Update the value with the new Identity count
        pSetDwordValue (NewContent, value);
    }
    return TRUE;
}

BOOL
WINAPI
pConvertIdentityIndex(
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR node = NULL;
    PTSTR leaf = NULL;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {
        IsmCreateObjectStringsFromHandle (SrcObjectName, &node, &leaf);
        if (node && !StringMatch(node, TEXT("HKCU\\Identities"))) {
            // Only set this identity's index if this is new on the dest
            if (DoesDestRegExist(SrcObjectName, REG_DWORD)) {
                IsmClearApplyOnObject((g_RegType & (~PLATFORM_MASK)) | PLATFORM_SOURCE, SrcObjectName);
            } else {
                pSetDwordValue (NewContent, g_IdentityCount);
                g_IdentityCount++;
            }
        }
        IsmDestroyObjectString(node);
        IsmDestroyObjectString(leaf);
    }
    return TRUE;
}


BOOL
pIsIdentityCollision (
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCTSTR OriginalUsername
    )
{
    MIG_CONTENT objectContent;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    BOOL retval = FALSE;

    // Check if this already exists
    if (HtFindString (g_IdentityDestTable, OriginalUsername)) {
        return TRUE;
    }

    // Check for collisions on Destination
    enumPattern = IsmCreateSimpleObjectPattern (TEXT("HKCU\\Identities"),
                                                TRUE,
                                                TEXT("Username"),
                                                FALSE);
    if (IsmEnumFirstDestinationObject (&objectEnum, g_RegType, enumPattern)) {
       do {
           // don't collide with same identity on destination
           if (!StringIMatch (SrcObjectName, objectEnum.ObjectName)) {
               if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION, objectEnum.ObjectName, &objectContent)) {
                   if (IsValidRegSz(&objectContent)) {
                       if (StringIMatch (OriginalUsername, (PCTSTR) objectContent.MemoryContent.ContentBytes)) {
                           retval = TRUE;
                           IsmReleaseObject (&objectContent);
                           IsmAbortObjectEnum (&objectEnum);
                           break;
                       }
                   }
                   IsmReleaseObject (&objectContent);
               }
           }
       } while (IsmEnumNextObject (&objectEnum));
    }

    IsmDestroyObjectHandle (enumPattern);

    return retval;
}

PTSTR
pCollideIdentityUsername (
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCTSTR OriginalUsername
    )
{
    PTSTR username = NULL;
    PTSTR tmpName;
    PTSTR testName = NULL;
    PTSTR openParen = NULL;
    PTSTR closeParen = NULL;
    PTSTR chr;
    TCHAR buff[20];
    UINT index = 1;
    BOOL replaceOk = TRUE;

    if (pIsIdentityCollision (SrcObjectName, OriginalUsername)) {
        tmpName = DuplicateText (OriginalUsername);

        // Check if name already has a (number) tacked on
        openParen = _tcsrchr (tmpName, TEXT('('));
        closeParen = _tcsrchr (tmpName, TEXT(')'));

        if (closeParen && openParen &&
            closeParen > openParen &&
            closeParen - openParen > 1) {
            // Make sure it's purely numerical
            for (chr = openParen+1; chr < closeParen; chr++) {
                if (!_istdigit (*chr)) {
                    replaceOk = FALSE;
                    break;
                }
            }
            if (replaceOk == TRUE) {
                if (_stscanf (openParen, TEXT("(%d)"), &index)) {
                    *openParen = 0;
                }
            }
        }

        // Loop until we find a non-colliding name
        do {
            IsmReleaseMemory (username);
            index++;

            wsprintf (buff, TEXT("(%d)"), index);
            username = IsmGetMemory (ByteCount (OriginalUsername) + ByteCount (buff) + 1);
            StringCopy (username, tmpName);
            StringCat (username, buff);
        } while (pIsIdentityCollision (SrcObjectName, username));

        FreeText (tmpName);

        // Put the new name in the hash tables
        HtAddStringEx (g_IdentityDestTable, username, &username, FALSE);
    } else {
        username = IsmGetMemory (ByteCount (OriginalUsername) + 1);
        StringCopy (username, OriginalUsername);
    }

    return username;
}

BOOL
WINAPI
pConvertIdentityGuid (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR newId;
    if (IsValidRegSz (CurrentContent)) {
        newId = OEGetRemappedId ((PCTSTR)CurrentContent->MemoryContent.ContentBytes);

        if (newId) {
            NewContent->Details.DetailsSize = sizeof(DWORD);
            NewContent->Details.DetailsData = IsmGetMemory (sizeof (DWORD));
            *((PDWORD)NewContent->Details.DetailsData) = REG_SZ;
            NewContent->MemoryContent.ContentSize = ByteCount (newId) + 1;
            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
            StringCopy ((PTSTR)NewContent->MemoryContent.ContentBytes, newId);
            FreeText(newId);
        }
    }
    return TRUE;
}

BOOL
WINAPI
pConvertIdentityUsername (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    if (IsValidRegSz (OriginalContent)) {
        // Update the value with a potentially new username
        NewContent->Details.DetailsSize = sizeof(DWORD);
        NewContent->Details.DetailsData = IsmGetMemory (sizeof (DWORD));
        *((PDWORD)NewContent->Details.DetailsData) = REG_SZ;

        NewContent->MemoryContent.ContentBytes = (PBYTE) pCollideIdentityUsername (SrcObjectName, (PCTSTR) OriginalContent->MemoryContent.ContentBytes);
        NewContent->MemoryContent.ContentSize = ByteCount ((PCTSTR) NewContent->MemoryContent.ContentBytes) + 1;
    }
    return TRUE;
}

BOOL
WINAPI
pConvertSetDwordTrue (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    if (IsValidRegType (OriginalContent, REG_DWORD)) {
        pSetDwordValue (NewContent, 1);
    }
    return TRUE;
}

BOOL
WINAPI
pConvertSetDwordFalse (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    if (IsValidRegType (OriginalContent, REG_DWORD)) {
        pSetDwordValue (NewContent, 0);
    }
    return TRUE;
}

BOOL
WINAPI
pConvertPSTBlob (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR originalStr = NULL;
    PCSTR finalStr = NULL;
    PTSTR joinedStr = NULL;
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    MIG_OBJECTSTRINGHANDLE filteredName = NULL;
    MIG_OBJECTSTRINGHANDLE srcName = NULL;
    MIG_OBJECTTYPEID destObjectTypeId;
    BOOL deleted;
    BOOL replaced;
    TCHAR *p = NULL;
    char *ptr;
    HALF_PTR oldSize;
    PCBYTE blob;

    if (IsValidRegType(OriginalContent, REG_BINARY)) {
        // Find the NULL before the PST filename
        blob = OriginalContent->MemoryContent.ContentBytes;
        ptr = (char *)(ULONG_PTR)((PBYTE)blob + OriginalContent->MemoryContent.ContentSize - 2);

        while ((ptr > blob) &&  (*ptr != 0)) {
            ptr--;
        }
        if (ptr <= blob) {
            // couldn't find it.. this isn't a PSTBlob
            return TRUE;
        }

        ptr++;

        oldSize = (HALF_PTR)(ptr - blob);
#ifdef UNICODE
        originalStr = ConvertAtoW(ptr);
#else
        originalStr = DuplicateText(ptr);
#endif

        if (originalStr) {
            p = (PTSTR)FindLastWack(originalStr);
            if (p) {
                *p = 0;
                srcName = IsmCreateObjectHandle (originalStr, p+1);

                if (srcName) {
                    filteredName = IsmFilterObject(MIG_FILE_TYPE | PLATFORM_SOURCE,
                                                   srcName,
                                                   &destObjectTypeId,
                                                   &deleted,
                                                   &replaced);
                    if (filteredName) {
                        IsmCreateObjectStringsFromHandle (filteredName, &node, &leaf);
                        IsmDestroyObjectHandle (filteredName);

                        joinedStr = JoinPaths (node, leaf);
                        if (joinedStr) {
#ifdef UNICODE
                            finalStr = ConvertWtoA(joinedStr);
#else
                            finalStr = DuplicateText(joinedStr);
#endif
                            FreePathString (joinedStr);
                        }
                        IsmDestroyObjectString (node);
                        IsmDestroyObjectString (leaf);
                    }
                    IsmDestroyObjectHandle (srcName);
                }
            }
#ifdef UNICODE
            FreeConvertedStr (originalStr);
#else
            FreeText(originalStr);
#endif
        }

        if (finalStr) {
            NewContent->Details.DetailsSize = sizeof(DWORD);
            NewContent->Details.DetailsData = IsmGetMemory (sizeof (DWORD));
            *((PDWORD)NewContent->Details.DetailsData) = REG_BINARY;
            NewContent->MemoryContent.ContentSize = oldSize + ByteCountA(finalStr) + 1;
            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
            CopyMemory ((PVOID)NewContent->MemoryContent.ContentBytes,
                        OriginalContent->MemoryContent.ContentBytes,
                        oldSize);
            CopyMemory ((PVOID)(NewContent->MemoryContent.ContentBytes + oldSize),
                        finalStr,
                        NewContent->MemoryContent.ContentSize);

#ifdef UNICODE
            FreeConvertedStr (finalStr);
#else
            FreeText(finalStr);
#endif
        }
    }

    return TRUE;
}

DWORD
pCountSourceSubKeys (
    IN      PTSTR RootKey
    )
{
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    DWORD value = 0;

    enumPattern = IsmCreateSimpleObjectPattern (RootKey,  TRUE, NULL, FALSE);
    if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
       do {
           if (IsmIsApplyObjectId (objectEnum.ObjectId)) {
               value++;
           }
       } while (IsmEnumNextObject (&objectEnum));
    }
    IsmDestroyObjectHandle (enumPattern);

    // We enumerated the root key too, which we don't want to count
    value--;

    return value;
}

BOOL
WINAPI
pConvertIAMAcctName (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTSTRINGHANDLE filteredName = NULL;
    MIG_CONTENT objectContent;
    PTSTR subKey;
    DWORD value = 1;
    PTSTR node;
    PTSTR leaf;
    MIG_OBJECTTYPEID destObjectTypeId;
    BOOL deleted;
    BOOL replaced;

    // Only increment the base account count
    if (StrStrI(SrcObjectName, TEXT("\\Accounts\\"))) {
        return TRUE;
    }

    // Get the destination value where we are writing to
    filteredName = IsmFilterObject(g_RegType | PLATFORM_SOURCE,
                                   SrcObjectName,
                                   &destObjectTypeId,
                                   &deleted,
                                   &replaced);
    if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION,
                          filteredName ? filteredName : SrcObjectName,
                          &objectContent)) {
        if (IsValidRegType(&objectContent, REG_DWORD)) {
            value = *objectContent.MemoryContent.ContentBytes;
            if (value == 0) {
                value = 1;
            }
        }
        IsmReleaseObject (&objectContent);
    }

    if (filteredName) {
        IsmDestroyObjectHandle (filteredName);
    }

    // Now increment the value by the number of accounts we are writing from the source
    IsmCreateObjectStringsFromHandle (SrcObjectName, &node, &leaf);
    if (node) {
        subKey = JoinText(node, TEXT("\\Accounts"));
        if (subKey) {
            value += pCountSourceSubKeys (subKey);
            pSetDwordValue (NewContent, value);
            FreeText(subKey);
        }
        IsmDestroyObjectString(node);
    }
    if (leaf) {
        IsmDestroyObjectString(leaf);
    }

    return TRUE;
}

BOOL
WINAPI
pConvertOE5IAMAcctName (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    DWORD value = 1;
    PTSTR srcIdentity;
    PTSTR tmpText;
    PTSTR tmpNode;
    PTSTR newIdentity = NULL;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {

        // Starting value is always in this location

        // Extract the source's associated ID.
        srcIdentity = OEGetAssociatedId (PLATFORM_SOURCE);
        if (srcIdentity) {
            newIdentity = OEGetRemappedId(srcIdentity);
            if (newIdentity) {
                if (OEIsIdentityAssociated(newIdentity)) {

                    // Migrating IAM to IAM
                    value = pGetDestDwordValue (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager"),
                                                TEXT("Account Name"));
                    if (value == 0) {
                        value = 1;
                    }
                } else {

                    // Migrating IAM to ID
                    tmpText = JoinText(TEXT("HKCU\\Identities\\"),
                                       newIdentity);
                    if (tmpText) {
                        tmpNode = JoinText(tmpText,
                                           TEXT("\\Software\\Microsoft\\Internet Account Manager"));
                        if (tmpNode) {
                            value = pGetDestDwordValue (tmpNode, TEXT("Account Name"));
                            if (value == 0) {
                                value = 1;
                            }
                            FreeText(tmpNode);
                        }
                        FreeText(tmpText);
                    }
                }
                FreeText(newIdentity);
            }
            FreeText(srcIdentity);
        }
        value += pCountSourceSubKeys (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager\\Accounts"));
        pSetDwordValue (NewContent, value);
    }

    return TRUE;
}

BOOL
WINAPI
pConvertOE4IAMAcctName (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR tmpName = NULL;
    PTSTR defaultId = NULL;
    DWORD value = 0;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {
        // Check if destination has Default ID.  If so, we're going to merge into that Identity.
        defaultId = OEGetDefaultId(PLATFORM_DESTINATION);
        if (defaultId) {
            tmpName = AllocText (61 + CharCount(defaultId));
            StringCopy (tmpName, TEXT("HKCU\\Identities\\"));  // 16
            StringCat (tmpName, defaultId);
            StringCat (tmpName, TEXT("\\Software\\Microsoft\\Internet Account Manager"));  // 44
            FreeText(defaultId);
        }

        // First try to get the AccountName from the identity key
        if (tmpName != NULL) {
            value = pGetDestDwordValue (tmpName, TEXT("Account Name"));
        }

        // If not there, look in the common key
        if (tmpName == NULL || value == 0) {
            value = pGetDestDwordValue (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager"),
                                        TEXT("Account Name"));
        }
        if (value == 0) {
            value = 1;
        }
        value += pCountSourceSubKeys (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager\\Accounts"));

        pSetDwordValue (NewContent, value);
    }

    if (tmpName != NULL) {
        FreeText (tmpName);
    }

    return TRUE;
}



BOOL
WINAPI
pConvertOMIAccountName (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_CONTENT objectContent;
    DWORD value;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {
        value = pGetDestDwordValue (TEXT("HKCU\\Software\\Microsoft\\Office\\Outlook\\OMI Account Manager"),
                                    TEXT("Account Name"));
        value += pCountSourceSubKeys (TEXT("HKCU\\Software\\Microsoft\\Office\\Outlook\\OMI Account Manager\\Accounts"));
        pSetDwordValue (NewContent, value);
    }
    return TRUE;
}

BOOL
pConvertLangId (
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCTSTR OfficeApp
    )
{
    MIG_CONTENT objectContent;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    PTSTR node;
    PTSTR leaf;
    DWORD value;
    DWORD result = 0;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {
        enumPattern = IsmCreateSimpleObjectPattern (
                          TEXT("HKLM\\Software\\Microsoft\\MS Setup (ACME)\\Table Files"),
                          TRUE,
                          NULL,
                          TRUE);

        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
            do {
                IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
                if (leaf && *leaf) {
                    if (_tcsnicmp(leaf, TEXT("MS Office"), 9) == 0 ||
                        _tcsnicmp(leaf, OfficeApp, CharCount(OfficeApp)) == 0) {

                        result = _stscanf(leaf, TEXT("%*[^\\(](%d)"), &value);
                        // In Office installs, the Outlook entry may not have the (1033) piece,
                        // so we MUST check the result
                    }
                }
                IsmDestroyObjectString (node);
                IsmDestroyObjectString (leaf);

                if (result) {
                    IsmAbortObjectEnum (&objectEnum);
                    break;
                }
            } while (IsmEnumNextObject (&objectEnum));
        }
        IsmDestroyObjectHandle (enumPattern);

        if (result) {
            pSetDwordValue (NewContent, value);
        }
    }
    return TRUE;
}

BOOL
WINAPI
pConvertOfficeLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("MS Office"));
    return TRUE;
}

BOOL
WINAPI
pConvertOutlookLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft Outlook"));
    return TRUE;
}

BOOL
WINAPI
pConvertAccessLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft Access"));
    return TRUE;
}

BOOL
WINAPI
pConvertExcelLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft Excel"));
    return TRUE;
}

BOOL
WINAPI
pConvertFrontPageLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft FrontPage"));
    return TRUE;
}

BOOL
WINAPI
pConvertPowerPointLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft PowerPoint"));
    return TRUE;
}

BOOL
WINAPI
pConvertPublisherLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft Publisher"));
    return TRUE;
}

BOOL
WINAPI
pConvertWordLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft Word"));
    return TRUE;
}

BOOL
WINAPI
pConvertOffice2000LangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    DWORD value;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {
        value = pGetSrcDwordValue (TEXT("HKCU\\Software\\Microsoft\\Office\\9.0\\Common\\LanguageResources"),
                                   TEXT("EXEMode"));
        pSetDwordValue (NewContent, value);
    }
    return TRUE;
}

BOOL
WINAPI
pMigrateSoundSysTray (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_DWORD) &&
            (*valueType2 == REG_DWORD)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just move the "Show volume control" bit.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if (IsValidRegType(&destContent, REG_DWORD)) {
                            NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                            *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)destContent.MemoryContent.ContentBytes);
                            if (*((PDWORD)OriginalContent->MemoryContent.ContentBytes) & 0x00000004) {
                                *((PDWORD)NewContent->MemoryContent.ContentBytes) |= 0x00000004;
                            }
                        }

                        IsmReleaseObject (&destContent);
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                // just transfer the "Show volume control" bit.
                if (*((PDWORD)OriginalContent->MemoryContent.ContentBytes) & 0x00000004) {
                    NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                    NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                    *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) | 0x00000004;
                }
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateAppearanceUPM (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    DWORD tempValue;

    if (IsValidRegType (OriginalContent, REG_BINARY) &&
        IsValidRegType (CurrentContent, REG_BINARY)) {

        // if the object was not changed yet we need to read the destination object and then
        // just move the appropriate bits.

        if ((!CurrentContent->MemoryContent.ContentBytes) ||
            (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
            ) {
            // find out the destination object and read it
            newObjectName = IsmFilterObject (
                                SrcObjectTypeId,
                                SrcObjectName,
                                &newObjectTypeId,
                                &deleted,
                                &replaced
                                );
            if ((!deleted || replaced) &&
                ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                ) {

                if (IsmAcquireObject (
                        (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                        newObjectName?newObjectName:SrcObjectName,
                        &destContent
                        )) {

                    if (IsValidRegType(&destContent, REG_BINARY)) {
                        NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                        NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) = (*((PDWORD)destContent.MemoryContent.ContentBytes)) &~ DISPLAY_BITMASK;
                        tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & DISPLAY_BITMASK);
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
                    }

                    IsmReleaseObject (&destContent);
                }

                if (newObjectName) {
                    IsmDestroyObjectHandle (newObjectName);
                    newObjectName = NULL;
                }
            }
        } else {
            // just transfer the appropriate bits.
            NewContent->MemoryContent.ContentSize = sizeof (DWORD);
            NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
            *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) &~ DISPLAY_BITMASK;
            tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & DISPLAY_BITMASK);
            *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateMouseUPM (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    DWORD tempValue;

    if (IsValidRegType (OriginalContent, REG_BINARY) &&
        IsValidRegType (CurrentContent, REG_BINARY)) {

        // if the object was not changed yet we need to read the destination object and then
        // just move the appropriate bits.

        if ((!CurrentContent->MemoryContent.ContentBytes) ||
            (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
            ) {
            // find out the destination object and read it
            newObjectName = IsmFilterObject (
                                SrcObjectTypeId,
                                SrcObjectName,
                                &newObjectTypeId,
                                &deleted,
                                &replaced
                                );
            if ((!deleted || replaced) &&
                ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                ) {

                if (IsmAcquireObject (
                        (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                        newObjectName?newObjectName:SrcObjectName,
                        &destContent
                        )) {

                    if (IsValidRegType (&destContent, REG_BINARY)) {
                        NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                        NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) = (*((PDWORD)destContent.MemoryContent.ContentBytes)) &~ MOUSE_BITMASK;
                        tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & MOUSE_BITMASK);
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
                    }

                    IsmReleaseObject (&destContent);
                }

                if (newObjectName) {
                    IsmDestroyObjectHandle (newObjectName);
                    newObjectName = NULL;
                }
            }
        } else {
            // just transfer the appropriate bits.
            NewContent->MemoryContent.ContentSize = sizeof (DWORD);
            NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
            *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) &~ MOUSE_BITMASK;
            tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & MOUSE_BITMASK);
            *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateOfflineSysTray (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_DWORD) &&
            (*valueType2 == REG_DWORD)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just move the "Enable offline folders" bit.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if (IsValidRegType (&destContent, REG_DWORD)) {
                            NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                            *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)destContent.MemoryContent.ContentBytes);
                            if (*((PDWORD)OriginalContent->MemoryContent.ContentBytes) & 0x00000008) {
                                *((PDWORD)NewContent->MemoryContent.ContentBytes) |= 0x00000008;
                            } else {
                                *((PDWORD)NewContent->MemoryContent.ContentBytes) &= (~0x00000008);
                            }
                        }

                        IsmReleaseObject (&destContent);
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                // just transfer the "Enable offline folders" bit.
                NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                if (*((PDWORD)OriginalContent->MemoryContent.ContentBytes) & 0x00000008) {
                    *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) | 0x00000008;
                } else {
                    *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) & (~0x00000008);
                }
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateTaskBarSS (
    IN      BOOL Force,
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    BYTE defShellState [sizeof (REGSHELLSTATE)] =
        {0x24, 0x00, 0x00, 0x00,
         0x20, 0x28, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x01, 0x00, 0x00, 0x00,
         0x0D, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x02, 0x00, 0x00, 0x00};
    PREGSHELLSTATE shellState1 = NULL, shellState2 = NULL;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_BINARY) &&
            (*valueType2 == REG_BINARY)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just transfer the "fStartPanelOn" setting if present.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if ((IsValidRegType (&destContent, REG_BINARY)) &&
                            (destContent.MemoryContent.ContentSize == sizeof (REGSHELLSTATE))
                            ) {
                            NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                destContent.MemoryContent.ContentBytes,
                                NewContent->MemoryContent.ContentSize
                                );
                            if (Force) {
                                shellState2 = (REGSHELLSTATE *)NewContent->MemoryContent.ContentBytes;
                                shellState2->ss.fStartPanelOn = FALSE;
                            } else {
                                if (OriginalContent->MemoryContent.ContentSize == sizeof (REGSHELLSTATE)) {
                                    shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                                    if (shellState1->ss.version == SHELLSTATEVERSION) {
                                        shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                                        shellState2->ss.fStartPanelOn = shellState1->ss.fStartPanelOn;
                                    }
                                }
                            }
                        }

                        IsmReleaseObject (&destContent);
                    } else {
                        if (Force) {
                            NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                defShellState,
                                NewContent->MemoryContent.ContentSize
                                );
                            shellState2 = (REGSHELLSTATE *)NewContent->MemoryContent.ContentBytes;
                            shellState2->ss.fStartPanelOn = FALSE;
                        }
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                if (Force) {
                    NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                    NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                    CopyMemory (
                        (PBYTE)NewContent->MemoryContent.ContentBytes,
                        CurrentContent->MemoryContent.ContentBytes,
                        NewContent->MemoryContent.ContentSize
                        );
                    shellState2 = (REGSHELLSTATE *)NewContent->MemoryContent.ContentBytes;
                    shellState2->ss.fStartPanelOn = FALSE;
                } else {
                    // just transfer the "fStartPanelOn" setting if present.
                    if ((OriginalContent->MemoryContent.ContentSize == sizeof (REGSHELLSTATE)) &&
                        (CurrentContent->MemoryContent.ContentSize == sizeof (REGSHELLSTATE))
                        ) {
                        shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                        if (shellState1->ss.version == SHELLSTATEVERSION) {
                            NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                CurrentContent->MemoryContent.ContentBytes,
                                NewContent->MemoryContent.ContentSize
                                );
                            shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                            shellState2->ss.fStartPanelOn = shellState1->ss.fStartPanelOn;
                        }
                    }
                }
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateTaskBarSSPreserve (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    return pMigrateTaskBarSS (
                FALSE,
                SrcObjectTypeId,
                SrcObjectName,
                OriginalContent,
                CurrentContent,
                NewContent,
                SourceOperationData,
                DestinationOperationData
                );
}

BOOL
WINAPI
pMigrateTaskBarSSForce (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    return pMigrateTaskBarSS (
                TRUE,
                SrcObjectTypeId,
                SrcObjectName,
                OriginalContent,
                CurrentContent,
                NewContent,
                SourceOperationData,
                DestinationOperationData
                );
}

BOOL
WINAPI
pConvertShowIEOnDesktop (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    BOOL dontShowIE = FALSE;
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    MIG_CONTENT destContent;
    BOOL deleted = TRUE, replaced = FALSE;

    if (IsValidRegType(CurrentContent, REG_DWORD)) {
        dontShowIE = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) & 0x00100000;

        // find out the destination object and read it
        newObjectName = IsmFilterObject (
                            SrcObjectTypeId,
                            SrcObjectName,
                            &newObjectTypeId,
                            &deleted,
                            &replaced
                            );
        if ((!deleted || replaced) &&
            ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
            ) {

            if (IsmAcquireObject (
                    (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                    newObjectName?newObjectName:SrcObjectName,
                    &destContent
                    )) {

                if (IsValidRegType(&destContent, REG_DWORD)) {
                    NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                    NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                    CopyMemory (
                        (PBYTE)NewContent->MemoryContent.ContentBytes,
                        destContent.MemoryContent.ContentBytes,
                        NewContent->MemoryContent.ContentSize
                        );

                    if (dontShowIE) {
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) |= 0x00100000;
                    } else {
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) &= 0xFFEFFFFF;
                    }
                }

                IsmReleaseObject (&destContent);
            }

            if (newObjectName) {
                IsmDestroyObjectHandle (newObjectName);
                newObjectName = NULL;
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateActiveDesktop (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    PREGSHELLSTATE shellState1 = NULL, shellState2 = NULL;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_BINARY) &&
            (*valueType2 == REG_BINARY)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just transfer the meaningfull settings.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if ((IsValidRegType(&destContent, REG_BINARY)) &&
                            (destContent.MemoryContent.ContentSize == sizeof (REGSHELLSTATE))
                            ) {
                            NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                destContent.MemoryContent.ContentBytes,
                                NewContent->MemoryContent.ContentSize
                                );
                            if (OriginalContent->MemoryContent.ContentSize >= sizeof(UINT)+sizeof(SHELLSTATE_SIZE_WIN95)) {
                                shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                                shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                                shellState2->ss.fDesktopHTML= shellState1->ss.fDesktopHTML;
                            }
                        }

                        IsmReleaseObject (&destContent);
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                // just transfer the meaningfull settings.
                if (OriginalContent->MemoryContent.ContentSize >= sizeof(UINT)+sizeof(SHELLSTATE_SIZE_WIN95)) {
                    shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                    shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                    shellState2->ss.fDesktopHTML = shellState1->ss.fDesktopHTML;
                }
            }
        }
    }

    return TRUE;
}

BOOL
CreateDwordRegObject (
    IN      PCTSTR KeyStr,
    IN      PCTSTR ValueName,
    IN      DWORD Value
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    DWORD regType = REG_DWORD;
    BOOL result = FALSE;

    objectTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;
    objectName = IsmCreateObjectHandle (KeyStr, ValueName);
    ZeroMemory (&objectContent, sizeof (MIG_CONTENT));
    objectContent.ContentInFile = FALSE;
    objectContent.MemoryContent.ContentSize = sizeof (DWORD);
    objectContent.MemoryContent.ContentBytes = (PBYTE)&Value;
    objectContent.Details.DetailsSize = sizeof (DWORD);
    objectContent.Details.DetailsData = &regType;
    result = IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    return result;
}

BOOL
WINAPI
pMigrateDisplaySS (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    PREGSHELLSTATE shellState1 = NULL, shellState2 = NULL;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_BINARY) &&
            (*valueType2 == REG_BINARY)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just transfer the meaningfull settings.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if ((IsValidRegType(&destContent, REG_BINARY)) &&
                            (destContent.MemoryContent.ContentSize == sizeof (REGSHELLSTATE))
                            ) {
                            NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                destContent.MemoryContent.ContentBytes,
                                NewContent->MemoryContent.ContentSize
                                );
                            if (OriginalContent->MemoryContent.ContentSize == sizeof(UINT)+SHELLSTATE_SIZE_WIN95) {
                                shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                                CreateDwordRegObject (
                                    TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                                    TEXT("Hidden"),
                                    shellState1->ss.fShowAllObjects?0x00000001:0x00000002
                                    );
                                CreateDwordRegObject (
                                    TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                                    TEXT("HideFileExt"),
                                    shellState1->ss.fShowExtensions?0x00000000:0x00000001
                                    );
                                // on really old SHELLSTATE the "Show compressed folders" flag is in the place of fShowSysFiles
                                CreateDwordRegObject (
                                    TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                                    TEXT("ShowCompColor"),
                                    shellState1->ss.fShowSysFiles?0x00000001:0x00000000
                                    );
                            }
                            if (OriginalContent->MemoryContent.ContentSize >= sizeof(UINT)+sizeof(SHELLSTATE_SIZE_WIN95)) {
                                shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                                shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                                // If fWebView is not ON on the source system, fDoubleClickInWebView can have random
                                // values.
                                if (shellState1->ss.fWebView) {
                                    shellState2->ss.fDoubleClickInWebView = shellState1->ss.fDoubleClickInWebView;
                                } else {
                                    shellState2->ss.fDoubleClickInWebView = TRUE;
                                }
                            }
                        }

                        IsmReleaseObject (&destContent);
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                // just transfer the meaningfull settings.
                if (OriginalContent->MemoryContent.ContentSize == sizeof(UINT)+SHELLSTATE_SIZE_WIN95) {
                    shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                    CreateDwordRegObject (
                        TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                        TEXT("Hidden"),
                        shellState1->ss.fShowAllObjects?0x00000001:0x00000002
                        );
                    CreateDwordRegObject (
                        TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                        TEXT("HideFileExt"),
                        shellState1->ss.fShowExtensions?0x00000000:0x00000001
                        );
                    // on really old SHELLSTATE the "Show compressed folders" flag is in the place of fShowSysFiles
                    CreateDwordRegObject (
                        TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                        TEXT("ShowCompColor"),
                        shellState1->ss.fShowSysFiles?0x00000001:0x00000000
                        );
                }
                if (OriginalContent->MemoryContent.ContentSize == sizeof(UINT)+sizeof(SHELLSTATE)) {
                    shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                    shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                    // If fWebView is not ON on the source system, fDoubleClickInWebView can have random
                    // values.
                    if (shellState1->ss.fWebView) {
                        shellState2->ss.fDoubleClickInWebView = shellState1->ss.fDoubleClickInWebView;
                    } else {
                        shellState2->ss.fDoubleClickInWebView = TRUE;
                    }
                }
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateDisplayCS (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    LPCABINETSTATE cabState1 = NULL, cabState2 = NULL;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_BINARY) &&
            (*valueType2 == REG_BINARY)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just transfer the meaningfull settings.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if ((IsValidRegType (&destContent, REG_BINARY)) &&
                            (destContent.MemoryContent.ContentSize == sizeof (CABINETSTATE))
                            ) {
                            NewContent->MemoryContent.ContentSize = sizeof (CABINETSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                destContent.MemoryContent.ContentBytes,
                                NewContent->MemoryContent.ContentSize
                                );

                            if (OriginalContent->MemoryContent.ContentSize == sizeof(CABINETSTATE)) {
                                cabState1 = (LPCABINETSTATE)OriginalContent->MemoryContent.ContentBytes;
                                cabState2 = (LPCABINETSTATE)NewContent->MemoryContent.ContentBytes;
                                if (cabState1->nVersion >= 2) {
                                    CopyMemory (
                                        (PBYTE)NewContent->MemoryContent.ContentBytes,
                                        OriginalContent->MemoryContent.ContentBytes,
                                        NewContent->MemoryContent.ContentSize
                                        );
                                } else {
                                    CreateDwordRegObject (
                                        TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CabinetState"),
                                        TEXT("FullPath"),
                                        cabState1->fFullPathTitle?0x00000001:0x00000000
                                        );
                                    cabState2->fNewWindowMode = cabState1->fNewWindowMode;
                                }
                            }
                        }

                        IsmReleaseObject (&destContent);
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                // just transfer the meaningfull settings.
                if (OriginalContent->MemoryContent.ContentSize == sizeof(CABINETSTATE)) {
                    cabState1 = (LPCABINETSTATE)OriginalContent->MemoryContent.ContentBytes;
                    cabState2 = (LPCABINETSTATE)NewContent->MemoryContent.ContentBytes;
                    if (cabState1->nVersion < 2) {
                        CreateDwordRegObject (
                            TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CabinetState"),
                            TEXT("FullPath"),
                            cabState1->fFullPathTitle?0x00000001:0x00000000
                            );
                        cabState2->fNewWindowMode = cabState1->fNewWindowMode;
                    }
                }
            }
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\rules.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    rules.c

Abstract:

    Implements the "rule" algorithm that scores script patterns and keeps them
    in reverse-sorted order.

Author:

    Jim Schmidt (jimschm) 12-May-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct _TAG_RULE {
    PCTSTR ObjectBase;
    MIG_OBJECTSTRINGHANDLE ObjectPattern;
    POBSPARSEDPATTERN ParsedPattern;
    UINT Score;
    ACTIONGROUP ActionGroup;
    DWORD ActionFlags;
    ACTION_STRUCT ActionStruct;
    struct _TAG_RULE *NextRule;
} RULE, *PRULE;

typedef struct _TAG_CHAR_NODE {
    PRULE RuleList;
    WORD Char;
    WORD Flags;
    struct _TAG_CHAR_NODE *NextLevel;
    struct _TAG_CHAR_NODE *NextPeer;
} CHAR_NODE, *PCHAR_NODE;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    PRULE RuleList;
    PCHAR_NODE FirstLevel;
} TYPE_RULE, *PTYPE_RULE;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    TYPE_RULE TypeRule;
} TYPETORULE, *PTYPETORULE;

//
// Globals
//

GROWBUFFER g_TypeToIncRule  = INIT_GROWBUFFER;
GROWBUFFER g_TypeToPriRule  = INIT_GROWBUFFER;
GROWBUFFER g_TypeToCollRule = INIT_GROWBUFFER;
GROWBUFFER g_TypeRuleList   = INIT_GROWBUFFER;
PMHANDLE g_RulePool;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pAddRuleToTypeRule (
    IN      PTYPE_RULE TypeRule,
    IN      PRULE Rule
    )
{
    PCHAR_NODE node, currNode, prevNode;
    PTSTR objectBase;
    PCTSTR p;
    WORD w;
    BOOL found;

    if (Rule->ObjectBase) {
        currNode = TypeRule->FirstLevel;
        prevNode = currNode;
        objectBase = DuplicatePathString (Rule->ObjectBase, 0);
        CharLower (objectBase);
        p = objectBase;
        while (*p) {
            w = (WORD) _tcsnextc (p);
            p = _tcsinc (p);
            if (currNode) {
                if (currNode->Char == w) {
                    if (!*p) {
                        Rule->NextRule = currNode->RuleList;
                        currNode->RuleList = Rule;
                    }
                    prevNode = currNode;
                    currNode = currNode->NextLevel;
                } else {
                    found = FALSE;
                    while (!found && currNode->NextPeer) {
                        if (currNode->NextPeer->Char == w) {
                            if (!*p) {
                                Rule->NextRule = currNode->NextPeer->RuleList;
                                currNode->NextPeer->RuleList = Rule;
                            }
                            prevNode = currNode->NextPeer;
                            currNode = prevNode->NextLevel;
                            found = TRUE;
                            break;
                        }
                        currNode = currNode->NextPeer;
                    }
                    if (!found) {
                        node = PmGetMemory (g_RulePool, sizeof (CHAR_NODE));
                        ZeroMemory (node, sizeof (CHAR_NODE));
                        if (!*p) {
                            node->RuleList = Rule;
                        }
                        node->Char = w;
                        node->NextPeer = currNode->NextPeer;
                        currNode->NextPeer = node;
                        prevNode = node;
                        currNode = node->NextLevel;
                    }
                }
            } else {
                node = PmGetMemory (g_RulePool, sizeof (CHAR_NODE));
                ZeroMemory (node, sizeof (CHAR_NODE));
                if (!*p) {
                    node->RuleList = Rule;
                }
                node->Char = w;
                if (prevNode) {
                    prevNode->NextLevel = node;
                } else {
                    TypeRule->FirstLevel = node;
                }
                prevNode = node;
                currNode = prevNode->NextLevel;
            }
        }
        FreePathString (objectBase);
    } else {
        Rule->NextRule = TypeRule->RuleList;
        TypeRule->RuleList = Rule;
    }
    return TRUE;
}

UINT
pComputeSubScore (
    IN      BOOL ExcludeLastPatSeg,
    IN      PCTSTR String,
    IN      UINT WildcardScore,
    IN      UINT FixedCharScore,
    IN      UINT WackScoreBeforeWildcard,
    IN      UINT WackScoreAfterWildcard
    )
{
    PCTSTR p;
    BOOL skipExtendedPattern;
    UINT score = 0;
    BOOL patternEncountered = FALSE;
    CHARTYPE ch;
    UINT state = 0;
    UINT delScore = 0;

    for (p = String ; *p ; p = _tcsinc (p)) {

        skipExtendedPattern = FALSE;

        switch (_tcsnextc (p)) {

        case TEXT('*'):
            if (state == 1) {
                state = 2;
            }
            if (state == 2) {
                delScore += WildcardScore;
            }
            score += WildcardScore;
            skipExtendedPattern = TRUE;
            patternEncountered = TRUE;
            break;

        case TEXT('?'):
            if (state == 1) {
                state = 2;
            }
            if (state == 2) {
                delScore += WildcardScore;
            }
            score += WildcardScore;
            skipExtendedPattern = TRUE;
            patternEncountered = TRUE;
            break;

        case TEXT('\\'):
            state = 1;
            if (patternEncountered) {
                score += WackScoreAfterWildcard;
                delScore = WackScoreAfterWildcard;
            } else {
                score += WackScoreBeforeWildcard;
                delScore = WackScoreBeforeWildcard;
            }
            break;

        case TEXT(':'):
            //
            // Special case: if just a drive spec with no wacks,
            //               add the wack score
            //

            if (p[1] == 0) {
                score += WackScoreBeforeWildcard;
                break;
            }

            // fall through
        default:
            state = 0;
            delScore = 0;
            score += FixedCharScore;
            break;
        }

        if (skipExtendedPattern) {
            if (_tcsnextc (_tcsinc (p)) == TEXT('[')) {
                do {
                    p = _tcsinc (p);

                    ch = (CHARTYPE) _tcsnextc (p);
                    if (ch == TEXT('^')) {
                        p++;
                    }

                } while (ch != TEXT(']'));
            }
        }
    }

    if (ExcludeLastPatSeg) {
        if (score > delScore) {
            score -= delScore;
            if (delScore && score > 0) {
                score -= 1;
            }
        } else {
            score = 0;
        }
    }

    return score;
}

UINT
pComputeScore (
    IN      MIG_OBJECTSTRINGHANDLE EncodedString
    )
{
    PCTSTR node;
    PCTSTR leaf;
    UINT score = 0;

    IsmCreateObjectStringsFromHandle (EncodedString, &node, &leaf);

    if (node) {
        score += 1000 * pComputeSubScore (TRUE, node, 0, 10, 1000, 500);
    }

    if (leaf) {
        score += pComputeSubScore (FALSE, leaf, 0, 10, 0, 0);
    }

    IsmDestroyObjectString (node);
    IsmDestroyObjectString (leaf);

    return score;
}

PTYPE_RULE
pGetListForType (
    IN      PGROWBUFFER TypeToRule,
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPE_RULE pos;
    PTYPE_RULE end;

    ObjectTypeId &= ~(PLATFORM_MASK);

    pos = (PTYPE_RULE) TypeToRule->Buf;
    end = (PTYPE_RULE) (TypeToRule->Buf + TypeToRule->End);

    while (pos < end) {
        if (pos->ObjectTypeId == ObjectTypeId) {
            return pos;
        }
        pos++;
    }

    pos = (PTYPE_RULE) GbGrow (TypeToRule, sizeof (TYPE_RULE));

    ZeroMemory (pos, sizeof (TYPE_RULE));
    pos->ObjectTypeId = ObjectTypeId;

    return pos;
}

VOID
InitRules (
    VOID
    )
{
    g_RulePool = PmCreateNamedPoolEx ("Rule Data", 32768);
    PmDisableTracking (g_RulePool);
}

VOID
TerminateRules (
    VOID
    )
{
    GbFree (&g_TypeToIncRule);
    GbFree (&g_TypeToPriRule);
    GbFree (&g_TypeToCollRule);
    GbFree (&g_TypeRuleList);

    PmEmptyPool (g_RulePool);
    PmDestroyPool (g_RulePool);
    INVALID_POINTER (g_RulePool);
}

UINT
pGetActionWeight (
    IN      ACTIONGROUP ActionGroup
    )
{
    switch (ActionGroup) {
    case ACTIONGROUP_DEFAULTPRIORITY:
        return ACTIONWEIGHT_DEFAULTPRIORITY;
    case ACTIONGROUP_SPECIFICPRIORITY:
        return ACTIONWEIGHT_SPECIFICPRIORITY;
    case ACTIONGROUP_EXCLUDE:
        return ACTIONWEIGHT_EXCLUDE;
    case ACTIONGROUP_EXCLUDEEX:
        return ACTIONWEIGHT_EXCLUDEEX;
    case ACTIONGROUP_INCLUDE:
        return ACTIONWEIGHT_INCLUDE;
    case ACTIONGROUP_INCLUDEEX:
        return ACTIONWEIGHT_INCLUDEEX;
    case ACTIONGROUP_RENAME:
        return ACTIONWEIGHT_RENAME;
    case ACTIONGROUP_RENAMEEX:
        return ACTIONWEIGHT_RENAMEEX;
    case ACTIONGROUP_INCLUDERELEVANT:
        return ACTIONWEIGHT_INCLUDERELEVANT;
    case ACTIONGROUP_INCLUDERELEVANTEX:
        return ACTIONWEIGHT_INCLUDERELEVANTEX;
    case ACTIONGROUP_RENAMERELEVANT:
        return ACTIONWEIGHT_RENAMERELEVANT;
    case ACTIONGROUP_RENAMERELEVANTEX:
        return ACTIONWEIGHT_RENAMERELEVANTEX;
    case ACTIONGROUP_REGFILE:
        return ACTIONWEIGHT_REGFILE;
    case ACTIONGROUP_REGFILEEX:
        return ACTIONWEIGHT_REGFILEEX;
    case ACTIONGROUP_REGFOLDER:
        return ACTIONWEIGHT_REGFOLDER;
    case ACTIONGROUP_REGFOLDEREX:
        return ACTIONWEIGHT_REGFOLDEREX;
    case ACTIONGROUP_REGICON:
        return ACTIONWEIGHT_REGICON;
    case ACTIONGROUP_REGICONEX:
        return ACTIONWEIGHT_REGICONEX;
    case ACTIONGROUP_DELREGKEY:
        return ACTIONWEIGHT_DELREGKEY;
    default:
        return 0;
    }
}

BOOL
AddRuleEx (
    IN      MIG_OBJECTTYPEID Type,
    IN      MIG_OBJECTSTRINGHANDLE ObjectBase,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      PACTION_STRUCT ActionStruct,            OPTIONAL
    IN      RULEGROUP RuleGroup
    )
{
    PTYPE_RULE typeRule;
    MIG_SEGMENTS nodeSegment;
    MIG_SEGMENTS leafSegment;
    PCTSTR ourEncodedString;
    PCTSTR node;
    PCTSTR leaf;
    PRULE rule;
    PGROWBUFFER ruleStruct;

    switch (RuleGroup) {

    case RULEGROUP_NORMAL:
        ruleStruct = &g_TypeToIncRule;
        break;

    case RULEGROUP_PRIORITY:
        ruleStruct = &g_TypeToPriRule;
        break;

    case RULEGROUP_COLLPATTERN:
        ruleStruct = &g_TypeToCollRule;
        break;
    }

    typeRule = pGetListForType (ruleStruct, Type);
    if (!typeRule) {
        return FALSE;
    }

    //
    // Make sure both node an leaf are specified
    //

    IsmCreateObjectStringsFromHandleEx (ObjectPattern, &node, &leaf, TRUE);

    nodeSegment.Segment = node ? node : TEXT("*");
    nodeSegment.IsPattern = TRUE;

    leafSegment.Segment = leaf ? leaf : TEXT("*");
    leafSegment.IsPattern = TRUE;

    ourEncodedString = IsmCreateObjectPattern (
                            &nodeSegment,
                            1,
                            &leafSegment,
                            1
                            );

    IsmDestroyObjectString (node);
    IsmDestroyObjectString (leaf);

    //
    // Insert the rule based on score
    //
    rule = PmGetMemory (g_RulePool, sizeof (RULE));
    ZeroMemory (rule, sizeof (RULE));
    if (ObjectBase) {
        IsmCreateObjectStringsFromHandle (ObjectBase, &node, &leaf);
        if (node) {
            rule->ObjectBase = PmDuplicateString (g_RulePool, node);
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    rule->ObjectPattern = PmDuplicateString (g_RulePool, ourEncodedString);
    rule->ParsedPattern = ObsCreateParsedPatternEx (g_RulePool, ourEncodedString, FALSE);

    MYASSERT (rule->ParsedPattern);
    if (rule->ParsedPattern) {
        rule->Score = pComputeScore (ourEncodedString);
        rule->Score = rule->Score * 10 + pGetActionWeight (ActionGroup);
        rule->ActionGroup = ActionGroup;
        rule->ActionFlags = ActionFlags;
        if (ActionStruct) {
            if (ActionStruct->ObjectBase) {
                rule->ActionStruct.ObjectBase = PmDuplicateString (g_RulePool, ActionStruct->ObjectBase);
            }
            if (ActionStruct->ObjectDest) {
                rule->ActionStruct.ObjectDest = PmDuplicateString (g_RulePool, ActionStruct->ObjectDest);
            }
            if (ActionStruct->AddnlDest) {
                rule->ActionStruct.AddnlDest = PmDuplicateString (g_RulePool, ActionStruct->AddnlDest);
            }
            if (ActionStruct->ObjectHint) {
                rule->ActionStruct.ObjectHint = PmDuplicateString (g_RulePool, ActionStruct->ObjectHint);
            }
        }

        pAddRuleToTypeRule (typeRule, rule);
    } else {
        IsmCreateObjectStringsFromHandleEx (ourEncodedString, &node, &leaf, TRUE);
        LOG ((LOG_ERROR, (PCSTR) MSG_OBJECT_SPEC_ERROR, node, leaf));
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    IsmDestroyObjectHandle (ourEncodedString);

    return TRUE;
}

BOOL
QueryRuleEx (
    IN      MIG_OBJECTTYPEID Type,
    IN      MIG_OBJECTSTRINGHANDLE EncodedString,
    IN      PCTSTR ObjectNode,
    OUT     PACTIONGROUP ActionGroup,
    OUT     PDWORD ActionFlags,
    OUT     PACTION_STRUCT ActionStruct,                OPTIONAL
    IN      RULEGROUP RuleGroup
    )
{
    PTYPE_RULE typeRule;
    PCHAR_NODE charNode;
    PTSTR objectBase;
    PCTSTR p;
    WORD w;
    PRULE rule;
    PRULE foundRule;
    UINT maxScore;
    ACTIONGROUP initialAction = ACTIONGROUP_NONE;
    DWORD matchingFlags = 0;
    PGROWBUFFER ruleStruct;

    switch (RuleGroup) {

    case RULEGROUP_NORMAL:
        ruleStruct = &g_TypeToIncRule;
        break;

    case RULEGROUP_PRIORITY:
        ruleStruct = &g_TypeToPriRule;
        break;

    case RULEGROUP_COLLPATTERN:
        ruleStruct = &g_TypeToCollRule;
        break;
    }

    if (ActionStruct) {
        ZeroMemory (ActionStruct, sizeof (ACTION_STRUCT));
    }

    typeRule = pGetListForType (ruleStruct, Type);
    if (!typeRule) {
        return FALSE;
    }

    //
    // Let's walk the structure finding all possible rules and put them in a grow buffer
    // Later we'll examine the rules one by one. Note that the root rules always qualify
    //
    if (ObjectNode) {
        objectBase = DuplicatePathString (ObjectNode, 0);
        CharLower (objectBase);
    }
    g_TypeRuleList.End = 0;
    p = objectBase;
    if (p) {
        w = (WORD) _tcsnextc (p);
        charNode = typeRule->FirstLevel;
        while (charNode && *p) {
            if (charNode->Char == w) {
                if (charNode->RuleList) {
                    CopyMemory (GbGrow (&g_TypeRuleList, sizeof (PRULE)), &(charNode->RuleList), sizeof (PRULE));
                }
                charNode = charNode->NextLevel;
                p = _tcsinc (p);
                w = (WORD) _tcsnextc (p);
            } else {
                charNode = charNode->NextPeer;
            }
        }
    }
    maxScore = 0;
    foundRule = NULL;
    while (g_TypeRuleList.End) {
        CopyMemory (&rule, &(g_TypeRuleList.Buf[g_TypeRuleList.End - sizeof (PRULE)]), sizeof (PRULE));
        while (rule) {
            if (maxScore <= rule->Score) {
                if (IsmParsedPatternMatch ((MIG_PARSEDPATTERN)rule->ParsedPattern, Type, EncodedString)) {
                    if (foundRule && (maxScore == rule->Score)) {
                        if (initialAction == rule->ActionGroup) {
                            matchingFlags |= rule->ActionFlags;
                        }
                    } else {
                        foundRule = rule;
                        initialAction = foundRule->ActionGroup;
                        matchingFlags = foundRule->ActionFlags;
                        maxScore = rule->Score;
                    }
                }
            }
            rule = rule->NextRule;
        }
        g_TypeRuleList.End -= sizeof (PRULE);
    }
    rule = typeRule->RuleList;
    while (rule) {
        if (maxScore <= rule->Score) {
            if (IsmParsedPatternMatch ((MIG_PARSEDPATTERN)rule->ParsedPattern, Type, EncodedString)) {
                if (foundRule && (maxScore == rule->Score)) {
                    if (initialAction == rule->ActionGroup) {
                        matchingFlags |= rule->ActionFlags;
                    }
                } else {
                    foundRule = rule;
                    initialAction = foundRule->ActionGroup;
                    matchingFlags = foundRule->ActionFlags;
                    maxScore = rule->Score;
                }
            }
        }
        rule = rule->NextRule;
    }

    if (foundRule) {
        *ActionGroup = initialAction;
        *ActionFlags = matchingFlags;
        if (ActionStruct && (!ActionStruct->ObjectBase) && (foundRule->ActionStruct.ObjectBase)) {
            ActionStruct->ObjectBase = foundRule->ActionStruct.ObjectBase;
        }
        if (ActionStruct && (!ActionStruct->ObjectDest) && (foundRule->ActionStruct.ObjectDest)) {
            ActionStruct->ObjectDest = foundRule->ActionStruct.ObjectDest;
        }
        if (ActionStruct && (!ActionStruct->AddnlDest) && (foundRule->ActionStruct.AddnlDest)) {
            ActionStruct->AddnlDest = foundRule->ActionStruct.AddnlDest;
        }
        if (ActionStruct && (!ActionStruct->ObjectHint) && (foundRule->ActionStruct.ObjectHint)) {
            ActionStruct->ObjectHint = foundRule->ActionStruct.ObjectHint;
        }
    }

    FreePathString (objectBase);

    return (foundRule != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\restore.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    restore.c

Abstract:

    Implements object restore callbacks

Author:

    Calin Negreanu (calinn) 21-Nov-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_RESTORE  "RestoreCallbacks"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef BOOL(WINAPI SCRIPTRESTOREFUNCTION)(
                        IN      MIG_OBJECTTYPEID ObjectTypeId,
                        IN      MIG_OBJECTID ObjectId,
                        IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                        IN      PCTSTR MultiSzData
                        );
typedef SCRIPTRESTOREFUNCTION *PSCRIPTRESTOREFUNCTION;

//
// This is the structure used for handling restore callback functions
//
typedef struct {
    PCTSTR InfFunctionName;
    PSCRIPTRESTOREFUNCTION RestoreCallback;
} RESTORE_STRUCT, *PRESTORE_STRUCT;

typedef struct _RESTOREDATA_STRUCT{
    POBSPARSEDPATTERN ParsedPattern;
    PCTSTR RestoreArgs;
    PRESTORE_STRUCT RestoreStruct;
    struct _RESTOREDATA_STRUCT *Next;
} RESTOREDATA_STRUCT, *PRESTOREDATA_STRUCT;

//
// Globals
//

PRESTOREDATA_STRUCT g_RestoreData = NULL;
PMHANDLE g_RestorePool;

//
// Macro expansion list
//

#define RESTORE_FUNCTIONS        \
        DEFMAC(NEVER,           pNever          )  \
        DEFMAC(SAMEREGVALUE,    pSameRegValue   )  \
        DEFMAC(EXISTSINHKLM,    pExistsInHKLM   )  \

//
// Private function prototypes
//

MIG_RESTORECALLBACK pRestoreCallback;

//
// Macro expansion definition
//

//
// Declare special conversion operation apply callback functions
//
#define DEFMAC(ifn,fn) SCRIPTRESTOREFUNCTION fn;
RESTORE_FUNCTIONS
#undef DEFMAC

//
// Declare a global array of conversion functions
//
#define DEFMAC(ifn,fn) {TEXT("\\")TEXT(#ifn),fn},
static RESTORE_STRUCT g_RestoreFunctions[] = {
                              RESTORE_FUNCTIONS
                              {NULL, NULL}
                              };
#undef DEFMAC

//
// Code
//


PRESTORE_STRUCT
pGetRestoreStruct (
    IN      PCTSTR FunctionName
    )
{
    PRESTORE_STRUCT p = g_RestoreFunctions;
    INT i = 0;
    while (p->InfFunctionName != NULL) {
        if (StringIMatch (p->InfFunctionName, FunctionName)) {
            return p;
        }
        p++;
        i++;
    }
    return NULL;
}

BOOL
pParseRestoreInf (
    IN      HINF InfHandle
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR pattern;
    PCTSTR fnName;
    PCTSTR fnArgs;
    ENCODEDSTRHANDLE srcHandle = NULL;
    BOOL result = FALSE;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    PRESTOREDATA_STRUCT restoreData;

    __try {

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_RESTORE,
                NULL,
                0,
                &sizeNeeded
                )) {
            result = TRUE;
            __leave;
        }

        if (!GbGrow (&multiSz, sizeNeeded)) {
            __leave;
        }

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_RESTORE,
                (PTSTR) multiSz.Buf,
                multiSz.End,
                NULL
                )) {
            __leave;
        }

        if (EnumFirstMultiSz (&e, (PCTSTR) multiSz.Buf)) {

            do {

                if (InfFindFirstLine (InfHandle, e.CurrentString, NULL, &is)) {
                    do {

                        if (IsmCheckCancel()) {
                            __leave;
                        }

                        pattern = InfGetStringField (&is, 0);

                        if (!pattern) {
                            LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_REG_SPEC));
                            continue;
                        }

                        srcHandle = TurnRegStringIntoHandle (pattern, TRUE, NULL);
                        if (!srcHandle) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, pattern));
                            continue;
                        }

                        fnName = InfGetStringField (&is, 1);
                        if (!fnName) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, pattern));
                            IsmDestroyObjectHandle (srcHandle);
                            srcHandle = NULL;
                            continue;
                        }

                        fnArgs = InfGetMultiSzField (&is, 2);

                        restoreData = PmGetMemory (g_RestorePool, sizeof (RESTOREDATA_STRUCT));
                        ZeroMemory (restoreData, sizeof (RESTOREDATA_STRUCT));
                        restoreData->ParsedPattern = ObsCreateParsedPatternEx (g_RestorePool, srcHandle, FALSE);
                        if (fnArgs) {
                            restoreData->RestoreArgs = PmDuplicateMultiSz (g_RestorePool, fnArgs);
                        }
                        if (fnName) {
                            restoreData->RestoreStruct = pGetRestoreStruct (fnName);
                        }
                        restoreData->Next = g_RestoreData;
                        g_RestoreData = restoreData;

                        IsmDestroyObjectHandle (srcHandle);
                        srcHandle = NULL;

                    } while (InfFindNextLine (&is));
                }
            } while (EnumNextMultiSz (&e));
        }

        result = TRUE;
    }
    __finally {

        GbFree (&multiSz);
        InfCleanUpInfStruct (&is);

    }

    return result;
}

BOOL
InitRestoreCallback (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    PTSTR multiSz = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_TYPE dataType;
    BOOL result = FALSE;

    g_RestorePool = PmCreateNamedPoolEx ("Restore Callback Data", 32768);
    PmDisableTracking (g_RestorePool);

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {

        if (pParseRestoreInf (infHandle)) {
            result = TRUE;
        }

        InfNameHandle (infHandle, NULL, FALSE);

    } else {

        if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, NULL, 0, &sizeNeeded, NULL)) {
            return TRUE;        // no INF files specified
        }

        __try {
            multiSz = AllocText (sizeNeeded);
            if (!multiSz) {
                __leave;
            }

            if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, (PBYTE) multiSz, sizeNeeded, NULL, NULL)) {
                __leave;
            }

            if (EnumFirstMultiSz (&e, multiSz)) {

                do {

                    infHandle = InfOpenInfFile (e.CurrentString);
                    if (infHandle != INVALID_HANDLE_VALUE) {
                        if (!pParseRestoreInf (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            __leave;
                        }
                    } else {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_INF, e.CurrentString));
                    }
                    InfCloseInfFile (infHandle);
                    infHandle = INVALID_HANDLE_VALUE;
                } while (EnumNextMultiSz (&e));

            }

            result = TRUE;
        }
        __finally {
            if (multiSz) {
                FreeText (multiSz);
                multiSz = NULL;
            }
        }
    }

    IsmRegisterRestoreCallback (pRestoreCallback);

    return result;
}

VOID
TerminateRestoreCallback (
    VOID
    )
{
    if (g_RestorePool) {
        PmEmptyPool (g_RestorePool);
        PmDestroyPool (g_RestorePool);
        g_RestorePool = NULL;
    }
}

BOOL
pRestoreCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    BOOL result = TRUE;
    PRESTOREDATA_STRUCT p = g_RestoreData;

    if (ObjectTypeId & MIG_REGISTRY_TYPE) {
        while (p) {
            if (p->ParsedPattern) {
                if (IsmParsedPatternMatch ((MIG_PARSEDPATTERN)p->ParsedPattern, MIG_REGISTRY_TYPE, ObjectName)) {
                    if (p->RestoreStruct) {
                        if (p->RestoreStruct->RestoreCallback) {
                            if (!p->RestoreStruct->RestoreCallback (
                                                        ObjectTypeId,
                                                        ObjectId,
                                                        ObjectName,
                                                        p->RestoreArgs
                                                        )) {
                                result = FALSE;
                                break;
                            }
                        }
                    }
                }
            }
            p = p->Next;
        }
    }

    return result;
}

BOOL
pIsSameContent (
    IN      PMIG_CONTENT ContentSrc,
    IN      PMIG_CONTENT ContentDest
    )
{
    INT value1 = 0;
    INT value2 = 0;

    if (ContentSrc->ContentInFile) {
        return FALSE;
    }

    if (ContentDest->ContentInFile) {
        return FALSE;
    }

    if (ContentSrc->Details.DetailsSize != ContentDest->Details.DetailsSize) {
        return FALSE;
    }

    if (!TestBuffer (
            ContentSrc->Details.DetailsData,
            ContentDest->Details.DetailsData,
            ContentSrc->Details.DetailsSize
            )) {
        return FALSE;
    }

    if ((ContentSrc->MemoryContent.ContentSize == 0) &&
        (ContentDest->MemoryContent.ContentSize == 0)
        ) {
        // no content, just return TRUE
        return TRUE;
    }

    if ((ContentSrc->MemoryContent.ContentSize == ContentDest->MemoryContent.ContentSize) &&
        TestBuffer (
            ContentSrc->MemoryContent.ContentBytes,
            ContentDest->MemoryContent.ContentBytes,
            ContentSrc->MemoryContent.ContentSize
            )) {
        // same exact content
        return TRUE;
    }

    // we have an extra case, if the source and dest are strings but they are actually numbers
    // we will get the numbers and compare them
    if ((ContentSrc->Details.DetailsSize == sizeof (DWORD)) &&
        (ContentSrc->Details.DetailsData) &&
        (ContentDest->Details.DetailsData) &&
        ((*(PDWORD)ContentSrc->Details.DetailsData == REG_SZ) ||
         (*(PDWORD)ContentSrc->Details.DetailsData == REG_EXPAND_SZ)
         ) &&
        ((*(PDWORD)ContentDest->Details.DetailsData == REG_SZ) ||
         (*(PDWORD)ContentDest->Details.DetailsData == REG_EXPAND_SZ)
         ) &&
        (ContentSrc->MemoryContent.ContentBytes) &&
        (ContentDest->MemoryContent.ContentBytes)
        ) {
        value1 = _ttoi ((PCTSTR)ContentSrc->MemoryContent.ContentBytes);
        value2 = _ttoi ((PCTSTR)ContentDest->MemoryContent.ContentBytes);
        if ((value1 != 0) &&
            (value2 != 0) &&
            (value1 == value2)
            ) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
pSameRegValue (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR MultiSzData
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    BOOL hadLeaf = FALSE;
    BOOL existsSrc = FALSE;
    MIG_CONTENT contentSrc;
    BOOL existsDest = FALSE;
    MIG_CONTENT contentDest;
    BOOL result = TRUE;

    if (MultiSzData) {

        objectName = TurnRegStringIntoHandle (MultiSzData, FALSE, &hadLeaf);

        if (objectName) {

            existsSrc = IsmAcquireObjectEx (
                            MIG_REGISTRY_TYPE | PLATFORM_SOURCE,
                            objectName,
                            &contentSrc,
                            CONTENTTYPE_MEMORY,
                            0
                            );
            existsDest = IsmAcquireObjectEx (
                            MIG_REGISTRY_TYPE | PLATFORM_DESTINATION,
                            objectName,
                            &contentDest,
                            CONTENTTYPE_MEMORY,
                            0
                            );

            result = (existsSrc && existsDest) || (!existsSrc && !existsDest);

            if (hadLeaf && result && existsSrc && existsDest) {

                result = pIsSameContent (&contentSrc, &contentDest);

            }

            if (existsSrc) {
                IsmReleaseObject (&contentSrc);
            }
            if (existsDest) {
                IsmReleaseObject (&contentDest);
            }
        }
    }

    return result;
}

BOOL
pNever (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR MultiSzData
    )
{
    return FALSE;
}

BOOL
pExistsInHKLM (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR MultiSzData
    )
{
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PCTSTR node, leaf, nodePtr, newNode;
    MIG_CONTENT content;
    BOOL result = TRUE;

    if (ObjectTypeId == (MIG_REGISTRY_TYPE | PLATFORM_SOURCE)) {
        if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

            if (node && StringIPrefix (node, TEXT("HKCU\\"))) {
                nodePtr = node + ARRAYSIZE (TEXT("HKCU"));
                newNode = JoinPathsInPoolEx ((
                                NULL,
                                TEXT("HKLM"),
                                MultiSzData?MultiSzData:nodePtr,
                                MultiSzData?nodePtr:NULL,
                                NULL
                                ));
                newObjectName = IsmCreateObjectHandle (newNode, leaf);
                if (newObjectName) {
                    result = !IsmAcquireObjectEx (
                                MIG_REGISTRY_TYPE | PLATFORM_DESTINATION,
                                newObjectName,
                                &content,
                                CONTENTTYPE_MEMORY,
                                0
                                );
                    if (!result) {
                        IsmReleaseObject (&content);
                    }
                    IsmDestroyObjectHandle (newObjectName);
                }
                FreePathString (newNode);
            }

            IsmDestroyObjectString (node);
            IsmDestroyObjectString (leaf);
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\parse.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    parse.c

Abstract:

    Implements parsing of script entries.

Author:

    Jim Schmidt (jimschm) 02-Jun-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef BOOL (SCRIPTTYPE_ALLOC_FN)(
                IN OUT      PATTRIB_DATA AttribData     CALLER_INITIALIZED
                );
typedef SCRIPTTYPE_ALLOC_FN *PSCRIPTTYPE_ALLOC_FN;

typedef BOOL (SCRIPTTYPE_FREE_FN)(
                IN          PATTRIB_DATA AttribData     ZEROED
                );
typedef SCRIPTTYPE_FREE_FN *PSCRIPTTYPE_FREE_FN;

typedef struct {
    PCTSTR Tag;
    PSCRIPTTYPE_ALLOC_FN AllocFunction;
    PSCRIPTTYPE_FREE_FN FreeFunction;
} TAG_TO_SCRIPTTYPEFN, *PTAG_TO_SCRIPTTYPEFN;

//
// Globals
//

// None

//
// Macro expansion list
//

#define SCRIPT_TYPES                                                                \
    DEFMAC(Registry,    pAllocRegistryScriptType,       pFreeIsmObjectScriptType)   \
    DEFMAC(File,        pAllocFileScriptType,           pFreeIsmObjectScriptType)   \
    DEFMAC(Directory,   pAllocDirectoryScriptType,      pFreeIsmObjectScriptType)   \
    DEFMAC(Text,        pAllocTextScriptType,           pFreeTextScriptType)        \
    DEFMAC(System,      pAllocSystemScriptType,         pFreeSystemScriptType)      \
    DEFMAC(INIFile,     pAllocIniFileScriptType,        pFreeIniFileScriptType)     \

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

#define DEFMAC(tag,fnA,fnF)         SCRIPTTYPE_ALLOC_FN fnA; SCRIPTTYPE_FREE_FN fnF;

SCRIPT_TYPES

#undef DEFMAC


#define DEFMAC(tag,fnA,fnF)         {TEXT(#tag),fnA,fnF},

TAG_TO_SCRIPTTYPEFN g_TagToScriptTypeFn[] = {
    SCRIPT_TYPES
    {NULL, NULL, NULL}
};

#undef DEFMAC

//
// Code
//

MIG_OBJECTSTRINGHANDLE
MakeRegExBase (
    IN      PCTSTR Node,
    IN      PCTSTR Leaf
    )
{
    MIG_OBJECTSTRINGHANDLE objectBase = NULL;
    PTSTR ptr;
    PTSTR nodeCopy = NULL;
    PCTSTR nodeBase = NULL;
    BOOL useLeaf = FALSE;


    if (Node) {
        ptr = _tcschr (Node, TEXT('\\'));
        if (!ptr) {
            return NULL;
        }

        if (StringIPrefix (Node, TEXT("HKR\\"))) {
            nodeCopy = JoinText (TEXT("HKCU"), ptr);
        } else {
            nodeCopy = DuplicateText (Node);
        }

        if (nodeCopy) {
            nodeBase = GetPatternBase (nodeCopy);

            if (nodeBase) {
                if (Leaf && !_tcschr (Leaf, TEXT('*'))) {
                    useLeaf = TRUE;
                }
                objectBase = IsmCreateObjectHandle (nodeBase, useLeaf ? Leaf : NULL);
                FreePathString (nodeBase);
            }
            FreeText (nodeCopy);
        }
    }

    return objectBase;
}

MIG_OBJECTSTRINGHANDLE
CreatePatternFromNodeLeaf (
    IN      PCTSTR Node,
    IN      PCTSTR Leaf
    )
{
    MIG_OBJECTSTRINGHANDLE pattern;
    MIG_SEGMENTS nodeSegment;
    MIG_SEGMENTS leafSegment;
    PTSTR fixedNode = NULL;

    if (Node &&
        (StringIMatch (Node, S_HKR) ||
         StringIMatchTcharCount (Node, TEXT("HKR\\"), 4)
         )
        ) {
        fixedNode = JoinText (S_HKCU, Node + 3);
        nodeSegment.Segment = fixedNode;
    } else {
        nodeSegment.Segment = Node;
    }

    nodeSegment.IsPattern = TRUE;
    leafSegment.Segment = Leaf;
    leafSegment.IsPattern = TRUE;

    pattern  = IsmCreateObjectPattern (&nodeSegment, Node ? 1 : 0, &leafSegment, Leaf ? 1 : 0);

    FreeText (fixedNode);

    if (!pattern) {
        LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD_NODE_AND_LEAF, Node, Leaf));
    }
    return pattern;
}

MIG_OBJECTSTRINGHANDLE
TurnRegStringIntoHandle (
    IN      PCTSTR String,
    IN      BOOL Pattern,
    OUT     PBOOL HadLeaf           OPTIONAL
    )

/*++

Routine Description:

  TurnRegStringIntoHandle converts the script's reg syntax into a cobra
  object.

Arguments:

  String  - Specifies the registry key and value in the script syntax.
            The string must be in the following format:

            <root>\<key>\* [<value>]

            Each part is optional.

            <root> specifies HKCU, HKR, HKLM or HKCC.

            <key> specifies a subkey (such as Software\Microsoft\Windows)

            * specifies all subkeys. If <value> is not specified, then all
                values and subvalues are also included.

            <value> specifies a specific value name


  Pattern - Specifies TRUE if the registry string can contain a pattern, or
            FALSE if it cannot.

  HadLeaf - Receives TRUE if String contains a leaf specification, FALSE
            otherwise

Return Value:

  A handle to a cobra object string, or NULL if parsing failed.

--*/

{
    PTSTR strCopy;
    PTSTR p;
    PTSTR value = NULL;
    PTSTR valueEnd;
    PTSTR key;
    PTSTR keyEnd;
    BOOL tree = FALSE;
    MIG_SEGMENTS nodeSegment[2];
    UINT nodeCount;
    MIG_SEGMENTS leafSegment;
    UINT leafCount;
    MIG_OBJECTSTRINGHANDLE handle;
    BOOL noSubKeys;
    BOOL noWildcardLeaf;
    PCTSTR fixedKey = NULL;

    MYASSERT (String);
    if (!String) {
        return NULL;
    }

    if (Pattern) {
        noSubKeys = FALSE;
        noWildcardLeaf = FALSE;
    } else {
        noSubKeys = TRUE;
        noWildcardLeaf = TRUE;
    }

    //
    // Inbound syntax is key\* [value]
    //

    strCopy = DuplicateText (String);
    if (!strCopy) {
        return NULL;
    }

    key = (PTSTR) SkipSpace (strCopy);
    if (!key) {
        FreeText (strCopy);
        return NULL;
    }

    if (*key == TEXT('[')) {
        //
        // This is a value-only case
        //

        value = _tcsinc (key);
        key = NULL;

    } else {
        //
        // This is a key-value case, or key-only case
        //

        p = _tcschr (key, TEXT('['));

        if (p) {
            //
            // Save start of value
            //
            value = _tcsinc (p);
        } else {
            //
            // No value
            //
            p = GetEndOfString (key);
        }

        keyEnd = p;

        //
        // Find the true end of the key
        //

        p = _tcsdec2 (key, p);
        MYASSERT (p);           // assert this is not a value-only case
        p = (PTSTR) SkipSpaceR (key, p);

        if (p) {
            keyEnd = _tcsinc (p);
        }

        //
        // Test for \* at the end
        //

        p = _tcsdec2 (key, keyEnd);
        MYASSERT (p);

        if (p && _tcsnextc (p) == TEXT('*')) {
            p = _tcsdec2 (key, p);
            if (p && _tcsnextc (p) == TEXT('\\')) {
                keyEnd = p;
                tree = (noSubKeys == FALSE);
            }
        }

        //
        // Trim the key
        //

        *keyEnd = 0;
    }

    //
    // Parse the value
    //

    if (value) {
        value = (PTSTR) SkipSpace (value);
        valueEnd = _tcschr (value, TEXT(']'));

        if (!valueEnd) {
            LOG ((LOG_ERROR, (PCSTR) MSG_INF_SYNTAX_ERROR, String));
            value = NULL;
        } else {
            //
            // Trim the space at the end of value
            //

            p = _tcsdec2 (value, valueEnd);
            if (p) {
                p = (PTSTR) SkipSpaceR (value, p);
                if (p) {
                    valueEnd = _tcsinc (p);
                }
            }

            *valueEnd = 0;
        }
    }

    //
    // Create parsed pattern. Start with the node.
    //

    nodeSegment[0].Segment = key;
    nodeSegment[0].IsPattern = FALSE;

    nodeSegment[1].Segment = TEXT("\\*");
    nodeSegment[1].IsPattern = TRUE;

    if (tree) {
        nodeCount = 2;
    } else {
        nodeCount = 1;
    }

    //
    // compute the leaf
    //

    if (value) {
        leafSegment.Segment = value;
        leafSegment.IsPattern = FALSE;
    } else {
        leafSegment.Segment = TEXT("*");
        leafSegment.IsPattern = TRUE;
    }

    if (noWildcardLeaf && !value) {
        leafCount = 0;
    } else {
        leafCount = 1;
    }

    if (nodeCount && key &&
        (StringIMatch (key, S_HKR) ||
         StringIMatchTcharCount (key, TEXT("HKR\\"), 4)
         )
        ) {
        fixedKey = JoinText (S_HKCU, key + 3);
        nodeSegment[0].Segment = fixedKey;
    }

    handle = IsmCreateObjectPattern (
                    nodeSegment,
                    nodeCount,
                    leafCount?&leafSegment:NULL,
                    leafCount
                    );

    FreeText (strCopy);
    FreeText (fixedKey);

    if (HadLeaf) {
        *HadLeaf = (value != NULL);
    }

    return handle;
}


PTSTR
pCopyToDest (
    IN      PTSTR Destination,          OPTIONAL
    IN      CHARTYPE Char,
    IN      PUINT CharNr
    )
{
    UINT len = 1;

#ifdef UNICODE

    if (Destination) {
        *Destination++ = Char;
    }

    (*CharNr) ++;
    return Destination;

#else

    if (IsCharLeadByte ((INT) Char)) {
        len ++;
    }

    if (Destination) {
        CopyMemory (Destination, &Char, len);
        Destination += len;
    }

    (*CharNr) += len;
    return Destination;

#endif

}


// 1->? (if node, no \ or ., if leaf, no .), 2->* (if node, no \ or ., if leaf, no .) 3->* (no \) 4->* (unlimited)
UINT
pGetMode (
    IN      PCTSTR Source,
    IN      BOOL NodePattern,
    IN      BOOL PatternAfterWack,
    IN      BOOL FirstChar
    )
{
    UINT ch;
    BOOL end = FALSE;
    UINT mode = 0;

    ch = _tcsnextc (Source);

    while (ch) {

        switch (ch) {

        case TEXT('?'):
            if (mode < 1) {
                mode = 1;
            }
            break;

        case TEXT('*'):
            if (NodePattern) {
                if (mode < 3) {
                    mode = 3;
                }
            } else {
                if (mode < 4) {
                    mode = 4;
                }
            }
            break;

        case TEXT('\\'):
            if (NodePattern) {
                if (mode < 2) {
                    mode = 2;
                }
            }
            end = TRUE;
            break;

        case TEXT('.'):
            if (mode < 2) {
                mode = 2;
            }
            end = TRUE;
            break;

        default:
            end = TRUE;
        }

        if (end) {
            break;
        }

        Source = _tcsinc (Source);
        ch = _tcsnextc (Source);
    }

    if (!ch) {
        if ((PatternAfterWack || NodePattern) && (mode == 3)) {
            mode = 4;
        }

        if (mode < 2) {
            mode = 2;
        }
    }

    if (FirstChar && (mode == 3)) {
        mode = 4;
    }

    return mode;
}


BOOL
pCopyPatternEx (
    IN      UINT Mode,
    IN      PCTSTR *Source,
    IN      PTSTR *Destination,
    IN      PUINT CharNr,
    IN      BOOL NodePattern
    )
{
    CHARTYPE ch;
    BOOL end = FALSE;
    INT numChars = 0;
    UINT chars;
    TCHAR buffer [MAX_PATH] = TEXT("");

    ch = (CHARTYPE) _tcsnextc (*Source);

    while (ch) {

        switch (ch) {

        case TEXT('*'):
            if (Mode == 1) {
                end = TRUE;
                break;
            }

            numChars = -1;
            break;

        case TEXT('?'):
            if (numChars >= 0) {
                numChars ++;
            }

            break;

        default:
            end = TRUE;
            break;
        }

        if (end) {
            break;
        }

        *Source = _tcsinc (*Source);
        ch = (CHARTYPE) _tcsnextc (*Source);
    }

    // 1->? (if node, no \ or ., if leaf, no .), 2->* (if node, no \ or ., if leaf, no .) 3->* (no \) 4->* (unlimited)
    switch (Mode) {

    case 1:
        if (NodePattern) {
            if (numChars > 0) {
                wsprintf (buffer, TEXT("?[%d:!(\\,.)]"), numChars);
            } else {
                wsprintf (buffer, TEXT("?[!(\\,.)]"));
            }
        } else {
            if (numChars > 0) {
                wsprintf (buffer, TEXT("?[%d:!(.)]"), numChars);
            } else {
                wsprintf (buffer, TEXT("?[!(.)]"));
            }
        }
        break;

    case 2:
        if (NodePattern) {
            if (numChars > 0) {
                wsprintf (buffer, TEXT("*[%d:!(\\,.)]"), numChars);
            } else {
                wsprintf (buffer, TEXT("*[!(\\,.)]"));
            }
        } else {
            if (numChars > 0) {
                wsprintf (buffer, TEXT("*[%d:!(.)]"), numChars);
            } else {
                wsprintf (buffer, TEXT("*[!(.)]"));
            }
        }
        break;

    case 3:
        if (numChars > 0) {
            wsprintf (buffer, TEXT("*[%d:!(\\)]"), numChars);
        } else {
            wsprintf (buffer, TEXT("*[!(\\)]"));
        }
        break;

    case 4:
        if (numChars > 0) {
            wsprintf (buffer, TEXT("*[%d:]"), numChars);
        } else {
            wsprintf (buffer, TEXT("*[]"));
        }
        break;

    default:
        MYASSERT (FALSE);
    }

    chars = TcharCount (buffer);
    if (CharNr) {
        *CharNr += chars;
    }

    if (Destination && *Destination) {
        StringCopy (*Destination, buffer);
        *Destination += chars;
    }

    return TRUE;
}


BOOL
pCopyPattern (
    IN      PCTSTR *Source,
    IN      PTSTR *Destination,
    IN      PUINT CharNr,
    IN      BOOL NodePattern,
    IN      BOOL PatternAfterWack,
    IN      BOOL FirstChar
    )
{
    // 1->? (if node, no \ or ., if leaf, no .), 2->* (if node, no \ or ., if leaf, no .) 3->* (no \) 4->* (unlimited)
    UINT mode = 0;
    PTSTR result = NULL;

    mode = pGetMode (*Source, NodePattern, PatternAfterWack, FirstChar);

    return pCopyPatternEx (mode, Source, Destination, CharNr, NodePattern);
}


BOOL
pFixPattern (
    IN      PCTSTR Source,
    OUT     PTSTR Destination,          OPTIONAL
    OUT     PUINT DestinationChars,     OPTIONAL
    IN      BOOL PatternsNotAllowed,
    IN      BOOL TruncateAtPattern,
    IN      BOOL NodePattern
    )
{
    UINT chars = 1;
    UINT lastChars = 0;
    PTSTR lastWack = NULL;
    BOOL end = FALSE;
    BOOL result = TRUE;
    BOOL patternAfterWack = FALSE;
    BOOL firstChar = TRUE;
    CHARTYPE ch;

    if (Destination) {
        *Destination = 0;
    }

    ch = (CHARTYPE) _tcsnextc (Source);
    while (ch) {

        switch (ch) {
        case TEXT('*'):
        case TEXT('?'):
            if (TruncateAtPattern) {
                if (lastWack) {
                    *lastWack = 0;
                    chars = lastChars;
                }
                end = TRUE;
            } else if (PatternsNotAllowed) {
                result = FALSE;
                Destination = pCopyToDest (Destination, TEXT('^'), &chars);
                Destination = pCopyToDest (Destination, ch, &chars);
                Source = _tcsinc (Source);
            } else {
                if (lastWack && (_tcsinc (lastWack) == Destination)) {
                    patternAfterWack = TRUE;
                } else {
                    patternAfterWack = FALSE;
                }
                pCopyPattern (&Source, Destination?&Destination:NULL, &chars, NodePattern, patternAfterWack, firstChar);
            }
            break;

        case TEXT('\020'):
        case TEXT('<'):
        case TEXT('>'):
        case TEXT(','):
        case TEXT('^'):
            Destination = pCopyToDest (Destination, TEXT('^'), &chars);
            Destination = pCopyToDest (Destination, ch, &chars);
            Source = _tcsinc (Source);
            break;

        case TEXT('\\'):
            if (NodePattern) {
                lastWack = Destination;
                lastChars = chars;
            }

            Destination = pCopyToDest (Destination, ch, &chars);
            Source = _tcsinc (Source);
            break;

        case TEXT('.'):
            if (!NodePattern) {
                lastWack = Destination;
                lastChars = chars;
            }

            Destination = pCopyToDest (Destination, ch, &chars);
            Source = _tcsinc (Source);
            break;

        default:
            Destination = pCopyToDest (Destination, ch, &chars);
            Source = _tcsinc (Source);
            break;
        }

        firstChar = FALSE;

        if (end) {
            break;
        }

        ch = (CHARTYPE) _tcsnextc (Source);
    }

    if (Destination) {
        *Destination = 0;
    }

    if (DestinationChars) {
        *DestinationChars = chars;
    }

    return result;
}


MIG_OBJECTSTRINGHANDLE
TurnFileStringIntoHandle (
    IN      PCTSTR String,
    IN      DWORD Flags
    )

/*++

Routine Description:

  TurnFileStringIntoHandle converts a file specification from the script
  syntax into a cobra object.

Arguments:

  String - Specifies the file string in the script syntax.
           The string must be in the following format:

           <directory>\<file>

           Both parts are optional. The Flags member indicates how String
           is parsed.

  Flags  - Specifies zero or more of the following flags:

                PFF_NO_PATTERNS_ALLOWED - String cannot contain any wildcard
                                          characters.

                PFF_COMPUTE_BASE - Returns the directory portion of the string,
                                   and truncates the directory at the first
                                   wildcard if necessary.  Truncation is done
                                   at the backslashes only.

                PFF_NO_SUBDIR_PATTERN - Do not include a trailing \*, even if
                                        it was specified in String.

                PFF_NO_LEAF_PATTERN - Do not include a * for the leaf when
                                      String does not contain a file name.
                                      If a file name is specified, include it.

                PFF_PATTERN_IS_DIR - String does not specify a file name.  It
                                     is a directory only. The leaf portion of
                                     the object string will be a *.

                PFF_NO_LEAF_AT_ALL - Will return an object string that has a
                                     node only, and no leaf specified at all.


Return Value:

  A cobra object handle, or NULL if conversion failed.

--*/

{
    PTSTR p;
    PTSTR fileCopy = NULL;
    MIG_SEGMENTS nodeSegment[2];
    MIG_SEGMENTS leafSegment;
    MIG_OBJECTSTRINGHANDLE result = NULL;
    BOOL tree = FALSE;
    PTSTR file = NULL;
    UINT nodeCount;
    UINT leafCount;
    UINT charsInPattern;
    BOOL noPatternsAllowed;
    BOOL computeBaseNode;
    BOOL noSubDirPattern;
    BOOL noLeafPattern;
    BOOL forceLeafToStar;
    PCTSTR node;
    PCTSTR leaf = NULL;
    PTSTR fixedNode = NULL;
    PTSTR fixedLeaf = NULL;
    PTSTR tempCopy;
    BOOL patternError = FALSE;

    noPatternsAllowed = (Flags & PFF_NO_PATTERNS_ALLOWED) == PFF_NO_PATTERNS_ALLOWED;
    computeBaseNode = (Flags & PFF_COMPUTE_BASE) == PFF_COMPUTE_BASE;
    noSubDirPattern = (Flags & PFF_NO_SUBDIR_PATTERN) == PFF_NO_SUBDIR_PATTERN;
    noLeafPattern = (Flags & PFF_NO_LEAF_PATTERN) == PFF_NO_LEAF_PATTERN;
    forceLeafToStar = (Flags & PFF_PATTERN_IS_DIR) == PFF_PATTERN_IS_DIR;

    //
    // Divide pattern into node and leaf
    //

    tempCopy = DuplicateText (SkipSpace (String));
    p = (PTSTR) SkipSpaceR (tempCopy, NULL);
    if (p) {
        p = _tcsinc (p);
        *p = 0;
    }

    node = tempCopy;

    if (!forceLeafToStar) {
        p = (PTSTR) FindLastWack (tempCopy);

        if (p) {

            leaf = SkipSpace (p + 1);
            *p = 0;

            p = (PTSTR) SkipSpaceR (tempCopy, NULL);
            if (p) {
                p = _tcsinc (p);
                *p = 0;
            }

        } else {
            if (!_tcschr (tempCopy, TEXT(':'))) {
                node = NULL;
                leaf = tempCopy;
            }
        }
    }

    //
    // Convert all ? wildcard chars to be compatibile with NT's file system
    // Escape all [ characters that follow wildcards
    //

    if (node) {

        p = (PTSTR) GetEndOfString (node);
        p = _tcsdec2 (node, p);

        if (p) {
            if (_tcsnextc (p) == TEXT('*')) {
                tree = TRUE;

                p = _tcsdec2 (node, p);
                if (p && _tcsnextc (p) == TEXT('\\')) {
                    *p = 0;
                } else {
                    tree = FALSE;
                }
            }
        }

        if (!pFixPattern (
                node,
                NULL,
                &charsInPattern,
                noPatternsAllowed,
                computeBaseNode,
                TRUE
                )) {
            patternError = TRUE;
        }

        if (charsInPattern) {
            fixedNode = AllocText (charsInPattern + 1);

            pFixPattern (
                node,
                fixedNode,
                NULL,
                noPatternsAllowed,
                computeBaseNode,
                TRUE
                );
        }
    }

    if (leaf && !computeBaseNode) {

        if (!pFixPattern (
                leaf,
                NULL,
                &charsInPattern,
                noPatternsAllowed,
                FALSE,
                FALSE
                )) {
            patternError = TRUE;
        }

        if (charsInPattern) {
            fixedLeaf = AllocText (charsInPattern + 1);

            pFixPattern (
                leaf,
                fixedLeaf,
                NULL,
                noPatternsAllowed,
                FALSE,
                FALSE
                );
        }
    }

    FreeText (tempCopy);
    INVALID_POINTER (tempCopy);

    //
    // Create the pattern string. Start by preparing the node segments.
    //

    nodeSegment[0].Segment = fixedNode;
    nodeSegment[0].IsPattern = TRUE;            // normally FALSE, but because the pattern charset is
                                                // exclusive of the valid filename charset, we allow
                                                // patterns to be in the node

    nodeSegment[1].Segment = TEXT("\\*");
    nodeSegment[1].IsPattern = TRUE;

    if (!fixedNode) {
        nodeCount = 0;
    } else if (!tree || noSubDirPattern || noPatternsAllowed) {
        nodeCount = 1;      // just the node, not its subnodes
    } else {
        nodeCount = 2;      // the node and its subnodes
    }

    //
    // Prepare the leaf segments. We want all leaves, a specific leaf, or
    // no leaf at all.
    //

    leafSegment.Segment = fixedLeaf;
    leafSegment.IsPattern = TRUE;
    leafCount = 1;

    MYASSERT (!forceLeafToStar || !fixedLeaf);

    if (!fixedLeaf) {
        if (noLeafPattern || noPatternsAllowed) {
            leafCount = 0;
        } else {
            leafSegment.Segment = TEXT("*");
        }
    }

    if (nodeCount || leafCount) {

        if ((fixedNode && *fixedNode) || (fixedLeaf && *fixedLeaf)) {
            result = IsmCreateObjectPattern (
                            nodeCount ? nodeSegment : NULL,
                            nodeCount,
                            leafCount ? &leafSegment : NULL,
                            leafCount
                            );
        }
    }

    FreeText (fixedNode);
    FreeText (fixedLeaf);

    return result;
}

BOOL
pAllocRegistryScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    TCHAR expandBuffer[4096];
    MIG_CONTENT objectContent;
    DWORD type;
    DWORD size;
    MULTISZ_ENUM multiSzEnum;
    PTSTR ptr;

    if (!AttribData) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // verify that we have some registry
    if (!AttribData->ScriptSpecifiedObject) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // try to create encoded string
    AttribData->ObjectTypeId = g_RegType;
    AttribData->ObjectName = TurnRegStringIntoHandle (
                                AttribData->ScriptSpecifiedObject,
                                FALSE,
                                NULL
                                );

    if (!AttribData->ObjectName) {
        if (GetLastError() == ERROR_SUCCESS) {
            SetLastError (ERROR_INVALID_DATA);
        }
        return FALSE;
    }

    // try to acqure the object
    if (IsmAcquireObject (
            AttribData->ObjectTypeId,
            AttribData->ObjectName,
            &objectContent
            )) {

        AttribData->ObjectContent = IsmGetMemory (sizeof (MIG_CONTENT));
        CopyMemory (AttribData->ObjectContent, &objectContent, sizeof (MIG_CONTENT));

        // finally, we want to prepare the return string
        if (!AttribData->ObjectContent->ContentInFile &&
            (AttribData->ObjectContent->Details.DetailsSize == sizeof (DWORD)) &&
            AttribData->ObjectContent->MemoryContent.ContentBytes
            ) {

            type = *((PDWORD) AttribData->ObjectContent->Details.DetailsData);

            switch (type) {
            case REG_SZ:
                size = SizeOfString ((PCTSTR) AttribData->ObjectContent->MemoryContent.ContentBytes);
                AttribData->ReturnString = (PCTSTR) IsmGetMemory (size);
                StringCopy (
                    (PTSTR) AttribData->ReturnString,
                    (PCTSTR) AttribData->ObjectContent->MemoryContent.ContentBytes
                    );
                break;
            case REG_EXPAND_SZ:
                // we need to expand the content. This will be the return string
                AttribData->ReturnString = IsmExpandEnvironmentString (
                                                AttribData->Platform,
                                                S_SYSENVVAR_GROUP,
                                                (PCTSTR) AttribData->ObjectContent->MemoryContent.ContentBytes,
                                                NULL
                                                );
                if (!AttribData->ReturnString) {
                    AttribData->ReturnString = IsmDuplicateString ((PCTSTR) AttribData->ObjectContent->MemoryContent.ContentBytes);
                }
                break;
            case REG_MULTI_SZ:
                size = SizeOfMultiSz ((PCTSTR) AttribData->ObjectContent->MemoryContent.ContentBytes);
                AttribData->ReturnString = (PCTSTR) IsmGetMemory (size);
                ((PTSTR)AttribData->ReturnString) [0] = 0;
                if (EnumFirstMultiSz (&multiSzEnum, (PCTSTR) AttribData->ObjectContent->MemoryContent.ContentBytes)) {
                    do {
                        StringCat (
                            (PTSTR)AttribData->ReturnString,
                            multiSzEnum.CurrentString
                            );
                        StringCat (
                            (PTSTR)AttribData->ReturnString,
                            TEXT(";")
                            );
                    } while (EnumNextMultiSz (&multiSzEnum));
                }
                break;
            case REG_DWORD:
            case REG_DWORD_BIG_ENDIAN:
                AttribData->ReturnString = (PCTSTR) IsmGetMemory ((sizeof (DWORD) * 2 + 3) * sizeof (TCHAR));
                wsprintf (
                    (PTSTR) AttribData->ReturnString,
                    TEXT("0x%08X"),
                    *((PDWORD) AttribData->ObjectContent->MemoryContent.ContentBytes)
                    );
                break;
            default:
                AttribData->ReturnString = (PCTSTR) IsmGetMemory ((AttribData->ObjectContent->
                                                        MemoryContent.ContentSize * 3 *
                                                        sizeof (TCHAR)) + sizeof (TCHAR)
                                                        );
                ptr = (PTSTR) AttribData->ReturnString;
                *ptr = 0;
                size = 0;
                while (size < AttribData->ObjectContent->MemoryContent.ContentSize) {
                    wsprintf (ptr, TEXT("%02X"), *(AttribData->ObjectContent->MemoryContent.ContentBytes + size));
                    size ++;
                    ptr = GetEndOfString (ptr);
                    if (size < AttribData->ObjectContent->MemoryContent.ContentSize) {
                        StringCopy (ptr, TEXT(","));
                        ptr = GetEndOfString (ptr);
                    }
                }
            }
        } else if (IsmIsObjectHandleNodeOnly (AttribData->ObjectName)) {
            //
            // Node only case
            //

            AttribData->ReturnString = (PCTSTR) IsmGetMemory (sizeof (TCHAR));
            ptr = (PTSTR) AttribData->ReturnString;
            *ptr = 0;
        }
    }

    return TRUE;
}

BOOL
pAllocFileScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    MIG_CONTENT objectContent;
    PCTSTR sanitizedPath;

    if (!AttribData) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // verify that we have some registry
    if (!AttribData->ScriptSpecifiedObject) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    sanitizedPath = SanitizePath (AttribData->ScriptSpecifiedObject);

    // try to create encoded string
    AttribData->ObjectTypeId = g_FileType;
    AttribData->ObjectName = TurnFileStringIntoHandle (
                                sanitizedPath,
                                PFF_NO_LEAF_PATTERN
                                );

    if (!AttribData->ObjectName) {
        FreePathString (sanitizedPath);
        if (GetLastError() == ERROR_SUCCESS) {
            SetLastError (ERROR_INVALID_DATA);
        }
        return FALSE;
    }

    // try to acqure the object
    if (IsmAcquireObject (
            AttribData->ObjectTypeId,
            AttribData->ObjectName,
            &objectContent
            )) {

        AttribData->ObjectContent = IsmGetMemory (sizeof (MIG_CONTENT));
        CopyMemory (AttribData->ObjectContent, &objectContent, sizeof (MIG_CONTENT));

        AttribData->ReturnString = IsmGetMemory (SizeOfString (sanitizedPath));
        StringCopy ((PTSTR) AttribData->ReturnString, sanitizedPath);
    }

    FreePathString (sanitizedPath);

    return TRUE;
}

BOOL
pAllocDirectoryScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    MIG_CONTENT objectContent;
    PCTSTR sanitizedPath;

    if (!AttribData) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // verify that we have some registry
    if (!AttribData->ScriptSpecifiedObject) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    sanitizedPath = SanitizePath (AttribData->ScriptSpecifiedObject);

	if (!sanitizedPath) {
        SetLastError (ERROR_INVALID_DATA);
		return FALSE;
	}

    // try to create encoded string
    AttribData->ObjectTypeId = g_FileType;
    AttribData->ObjectName = TurnFileStringIntoHandle (
                                            sanitizedPath,
                                            PFF_PATTERN_IS_DIR | PFF_NO_LEAF_AT_ALL
                                            );

    if (!AttribData->ObjectName) {
        FreePathString (sanitizedPath);
        if (GetLastError() == ERROR_SUCCESS) {
            SetLastError (ERROR_INVALID_DATA);
        }
        return FALSE;
    }

    // try to acqure the object
    if (IsmAcquireObject (
            AttribData->ObjectTypeId,
            AttribData->ObjectName,
            &objectContent
            )) {

        AttribData->ObjectContent = IsmGetMemory (sizeof (MIG_CONTENT));
        CopyMemory (AttribData->ObjectContent, &objectContent, sizeof (MIG_CONTENT));

        AttribData->ReturnString = IsmGetMemory (SizeOfString (sanitizedPath));
        StringCopy ((PTSTR) AttribData->ReturnString, sanitizedPath);
    }

    FreePathString (sanitizedPath);

    return TRUE;
}

BOOL
pFreeIsmObjectScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    if (AttribData->ReturnString) {
        IsmReleaseMemory (AttribData->ReturnString);
        AttribData->ReturnString = NULL;
    }
    AttribData->ObjectTypeId = 0;
    if (AttribData->ObjectName) {
        IsmDestroyObjectHandle (AttribData->ObjectName);
        AttribData->ObjectName = NULL;
    }
    if (AttribData->ObjectContent) {
        IsmReleaseObject (AttribData->ObjectContent);
        IsmReleaseMemory (AttribData->ObjectContent);
        AttribData->ObjectContent = NULL;
    }
    return TRUE;
}

BOOL
pAllocTextScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    if (!AttribData) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // verify that we have some registry
    if (!AttribData->ScriptSpecifiedObject) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    AttribData->ReturnString = IsmGetMemory (SizeOfString (AttribData->ScriptSpecifiedObject));
    StringCopy ((PTSTR) AttribData->ReturnString, AttribData->ScriptSpecifiedObject);

    return TRUE;
}

BOOL
pFreeTextScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    if (AttribData->ReturnString) {
        IsmReleaseMemory (AttribData->ReturnString);
        AttribData->ReturnString = NULL;
    }
    return TRUE;
}

BOOL
pAllocSystemScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    PTSTR specificSection = NULL;
    MIG_OSVERSIONINFO versionInfo;
    UINT tchars;
    BOOL detected = FALSE;

    if (!AttribData) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // verify that we have some registry
    if (!AttribData->ScriptSpecifiedObject) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    if (!IsmGetOsVersionInfo (PLATFORM_SOURCE, &versionInfo)) {
        return FALSE;
    }

    tchars = 1;
    if (versionInfo.OsTypeName) {
        tchars += TcharCount (versionInfo.OsTypeName) + 1;
    }
    if (versionInfo.OsMajorVersionName) {
        tchars += TcharCount (versionInfo.OsMajorVersionName) + 1;
    }
    if (versionInfo.OsMinorVersionName) {
        tchars += TcharCount (versionInfo.OsMinorVersionName);
    }

    specificSection = AllocText (tchars);
    if (!specificSection) {
        return FALSE;
    }

    if (!detected && versionInfo.OsTypeName) {

        wsprintf (
            specificSection,
            TEXT("%s"),
            versionInfo.OsTypeName
            );
        if (StringIMatch (AttribData->ScriptSpecifiedObject, specificSection)) {
            detected = TRUE;
        }

        if (!detected && versionInfo.OsMajorVersionName) {

            wsprintf (
                specificSection,
                TEXT("%s.%s"),
                versionInfo.OsTypeName,
                versionInfo.OsMajorVersionName
                );
            if (StringIMatch (AttribData->ScriptSpecifiedObject, specificSection)) {
                detected = TRUE;
            }

            if (!detected && versionInfo.OsMinorVersionName) {
                wsprintf (
                    specificSection,
                    TEXT("%s.%s.%s"),
                    versionInfo.OsTypeName,
                    versionInfo.OsMajorVersionName,
                    versionInfo.OsMinorVersionName
                    );
                if (StringIMatch (AttribData->ScriptSpecifiedObject, specificSection)) {
                    detected = TRUE;
                }
            }
        }
    }

    if (detected) {
        AttribData->ReturnString = IsmGetMemory (SizeOfString (AttribData->ScriptSpecifiedObject));
        StringCopy ((PTSTR) AttribData->ReturnString, AttribData->ScriptSpecifiedObject);
    }

    FreeText (specificSection);
    specificSection = NULL;

    return TRUE;
}

BOOL
pFreeSystemScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    if (AttribData->ReturnString) {
        IsmReleaseMemory (AttribData->ReturnString);
        AttribData->ReturnString = NULL;
    }
    return TRUE;
}

BOOL
pAllocIniFileScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    PTSTR fileName = NULL;
    PTSTR sectName = NULL;
    PTSTR keyName  = NULL;
    PTSTR charPtr  = NULL;
    PTSTR result   = NULL;
    DWORD allocatedChars;
    DWORD chars;

    if (!AttribData) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // verify that we have something specified
    if (!AttribData->ScriptSpecifiedObject) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // Now, let's extract the INI file name, section and key
    fileName = DuplicatePathString (AttribData->ScriptSpecifiedObject, 0);
    if (!fileName) {
        return FALSE;
    }

    charPtr = _tcschr (fileName, TEXT('/'));
    if (charPtr) {
        sectName = _tcsinc (charPtr);
        *charPtr = 0;
        if (sectName) {
            charPtr = _tcschr (sectName, TEXT('/'));
            if (charPtr) {
                keyName = _tcsinc (charPtr);
                *charPtr = 0;
            }
        }
    }

    result = NULL;
    allocatedChars = 256;
    do {
        if (result) {
            FreePathString (result);
        }
        allocatedChars *= 2;
        result = AllocPathString (allocatedChars);
        if (!result) {
            return FALSE;
        }
        chars = GetPrivateProfileString (
                    sectName,
                    keyName,
                    TEXT(""),
                    result,
                    allocatedChars,
                    fileName
                    );
    } while (chars >= allocatedChars - 1);

    if (chars) {
        AttribData->ReturnString = IsmGetMemory (SizeOfString (result));
        StringCopy ((PTSTR) AttribData->ReturnString, result);
        FreePathString (result);
        result = NULL;
        return TRUE;
    }
    FreePathString (result);
    result = NULL;
    FreePathString (fileName);
    fileName = NULL;
    return FALSE;
}

BOOL
pFreeIniFileScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    if (AttribData->ReturnString) {
        IsmReleaseMemory (AttribData->ReturnString);
        AttribData->ReturnString = NULL;
    }
    return TRUE;
}

BOOL
AllocScriptType (
    IN OUT      PATTRIB_DATA AttribData     CALLER_INITIALIZED
    )
{
    PTAG_TO_SCRIPTTYPEFN scriptFn = g_TagToScriptTypeFn;

    while (scriptFn->Tag) {
        if (StringIMatch (scriptFn->Tag, AttribData->ScriptSpecifiedType)) {
            break;
        }
        scriptFn ++;
    }
    if (scriptFn->Tag) {
        return (scriptFn->AllocFunction (AttribData));
    } else {
        return FALSE;
    }
}

BOOL
FreeScriptType (
    IN          PATTRIB_DATA AttribData     ZEROED
    )
{
    PTAG_TO_SCRIPTTYPEFN scriptFn = g_TagToScriptTypeFn;

    while (scriptFn->Tag) {
        if (StringIMatch (scriptFn->Tag, AttribData->ScriptSpecifiedType)) {
            break;
        }
        scriptFn ++;
    }
    if (scriptFn->Tag) {
        return (scriptFn->FreeFunction (AttribData));
    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\sgmcallback.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sgmcallback.c

Abstract:

    Implements the callbacks that are queued in sgmqueue.c.

Author:

    Jim Schmidt (jimschm) 12-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_SCRIPT  "Script"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

MIG_OBJECTSTRINGHANDLE
pSimpleTryHandle (
    IN      PCTSTR FullPath,
    IN      BOOL Recursive
    )
{
    DWORD attribs;
    PCTSTR buffer;
    PTSTR leafPtr, leaf;
    MIG_OBJECTSTRINGHANDLE result = NULL;
    MIG_OBJECTSTRINGHANDLE longResult = NULL;
    PTSTR workingPath;
    PCTSTR sanitizedPath;
    PCTSTR longPath;
    PCTSTR objNode = NULL, objLeaf = NULL;

    sanitizedPath = SanitizePath (FullPath);
    if (!sanitizedPath) {
        return NULL;
    }

    if (IsmGetRealPlatform () == PLATFORM_SOURCE) {
        attribs = GetFileAttributes (sanitizedPath);
    } else {
        attribs = INVALID_ATTRIBUTES;
    }

    if (attribs != INVALID_ATTRIBUTES) {

        longPath = BfGetLongFileName (sanitizedPath);
        if (!longPath) {
            longPath = sanitizedPath;
        }
        if (attribs & FILE_ATTRIBUTE_DIRECTORY) {
            if (Recursive) {
                workingPath = DuplicatePathString (longPath, 0);
                RemoveWackAtEnd (workingPath);
                result = IsmCreateSimpleObjectPattern (workingPath, TRUE, NULL, TRUE);
                FreePathString (workingPath);
            } else {
                result = IsmCreateObjectHandle (longPath, NULL);
            }
        } else {

            buffer = DuplicatePathString (longPath, 0);

            leaf = _tcsrchr (buffer, TEXT('\\'));

            if (leaf) {
                leafPtr = leaf;
                leaf = _tcsinc (leaf);
                *leafPtr = 0;
                result = IsmCreateObjectHandle (buffer, leaf);
            }

            FreePathString (buffer);
        }
        if (longPath != sanitizedPath) {
            FreePathString (longPath);
            longPath = NULL;
        }

    } else {

        result = IsmCreateObjectHandle (sanitizedPath, NULL);
        if (result) {

            longResult = IsmGetLongName (MIG_FILE_TYPE, result);
            if (!longResult) {
                longResult = result;
            }

            if (IsmGetObjectIdFromName (g_FileType, longResult, TRUE)) {
                if (Recursive) {
                    if (IsmCreateObjectStringsFromHandle (longResult, &objNode, &objLeaf)) {
                        if (longResult != result) {
                            IsmDestroyObjectHandle (longResult);
                            longResult = NULL;
                        }
                        IsmDestroyObjectHandle (result);
                        result = IsmCreateSimpleObjectPattern (objNode, TRUE, NULL, TRUE);
                        IsmDestroyObjectString (objNode);
                        IsmDestroyObjectString (objLeaf);
                    }
                }
                return result;
            } else {
                if (longResult != result) {
                    IsmDestroyObjectHandle (longResult);
                    longResult = NULL;
                }
                IsmDestroyObjectHandle (result);
                result = NULL;
            }
        }

        if (!result) {
            buffer = DuplicatePathString (sanitizedPath, 0);

            leaf = _tcsrchr (buffer, TEXT('\\'));

            if (leaf) {
                leafPtr = leaf;
                leaf = _tcsinc (leaf);
                *leafPtr = 0;
                result = IsmCreateObjectHandle (buffer, leaf);
            }

            if (result) {

                longResult = IsmGetLongName (MIG_FILE_TYPE, result);
                if (!longResult) {
                    longResult = result;
                }

                if (!IsmGetObjectIdFromName (g_FileType, longResult, TRUE)) {
                    if (longResult != result) {
                        IsmDestroyObjectHandle (longResult);
                        longResult = NULL;
                    }
                    IsmDestroyObjectHandle (result);
                    result = NULL;
                }
            }

            if (result != longResult) {
                IsmDestroyObjectHandle (result);
                result = longResult;
            }

            FreePathString (buffer);
        }
    }

    FreePathString (sanitizedPath);

    return result;
}

MIG_OBJECTSTRINGHANDLE
pTryHandle (
    IN      PCTSTR FullPath,
    IN      PCTSTR Hint,
    IN      BOOL Recursive,
    OUT     PBOOL HintUsed      OPTIONAL
    )
{
    PATH_ENUM pathEnum;
    PCTSTR newPath;
    MIG_OBJECTSTRINGHANDLE result = NULL;

    if (HintUsed) {
        *HintUsed = FALSE;
    }

    if (!(*FullPath)) {
        // nothing to do, not even the hint can help us
        return NULL;
    }

    result = pSimpleTryHandle (FullPath, Recursive);
    if (result || (!Hint)) {
        return result;
    }
    if (EnumFirstPathEx (&pathEnum, Hint, NULL, NULL, FALSE)) {
        do {
            newPath = JoinPaths (pathEnum.PtrCurrPath, FullPath);
            result = pSimpleTryHandle (newPath, Recursive);
            if (result) {
                AbortPathEnum (&pathEnum);
                FreePathString (newPath);
                if (HintUsed) {
                    *HintUsed = TRUE;
                }
                return result;
            }
            FreePathString (newPath);
        } while (EnumNextPath (&pathEnum));
    }
    AbortPathEnum (&pathEnum);
    return NULL;
}

BOOL
pOurFindFile (
    IN      PCTSTR FileName
    )
{
    DWORD attribs;
    PCTSTR buffer;
    PTSTR leafPtr, leaf;
    PTSTR workingPath;
    PCTSTR sanitizedPath;
    MIG_OBJECTSTRINGHANDLE test = NULL;
    BOOL result = FALSE;

    sanitizedPath = SanitizePath (FileName);

    if (IsmGetRealPlatform () == PLATFORM_SOURCE) {
        attribs = GetFileAttributes (sanitizedPath);
    } else {
        attribs = INVALID_ATTRIBUTES;
    }

    if (attribs != INVALID_ATTRIBUTES) {

        result = TRUE;

    } else {

        test = IsmCreateObjectHandle (sanitizedPath, NULL);

        if (IsmGetObjectIdFromName (g_FileType, test, TRUE)) {
            result = TRUE;
        }

        IsmDestroyObjectHandle (test);
        test = NULL;

        if (!result) {

            buffer = DuplicatePathString (sanitizedPath, 0);

            leaf = _tcsrchr (buffer, TEXT('\\'));

            if (leaf) {
                leafPtr = leaf;
                leaf = _tcsinc (leaf);
                *leafPtr = 0;
                test = IsmCreateObjectHandle (buffer, leaf);
            }

            if (test) {
                if (IsmGetObjectIdFromName (g_FileType, test, TRUE)) {
                    result = TRUE;
                }
                IsmDestroyObjectHandle (test);
                test = NULL;
            }

            FreePathString (buffer);
        }
    }

    FreePathString (sanitizedPath);

    return result;
}

BOOL
pOurSearchPath (
    IN      PCTSTR FileName,
    IN      DWORD BufferLength,
    OUT     PTSTR Buffer
    )
{
    TCHAR pathEnv[] = TEXT("%system%;%system16%;%windir%;%path%");
    PCTSTR pathExp = NULL;
    PCTSTR fileName = NULL;
    PATH_ENUM pathEnum;
    BOOL result = FALSE;

    pathExp = IsmExpandEnvironmentString (
                    PLATFORM_SOURCE,
                    S_SYSENVVAR_GROUP,
                    pathEnv,
                    NULL
                    );
    if (pathExp) {
        if (EnumFirstPathEx (&pathEnum, pathExp, NULL, NULL, FALSE)) {
            do {
                fileName = JoinPaths (pathEnum.PtrCurrPath, FileName);
                result = pOurFindFile (fileName);
                if (result) {
                    StringCopyTcharCount (Buffer, fileName, BufferLength);
                    FreePathString (fileName);
                    AbortPathEnum (&pathEnum);
                    break;
                }
                FreePathString (fileName);
            } while (EnumNextPath (&pathEnum));
        }

        IsmReleaseMemory (pathExp);
        pathExp = NULL;
    }
    return result;
}

PCTSTR
pGetObjectNameForDebug (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    static TCHAR debugBuffer[2048];
    PCTSTR node, leaf;

    IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf);

    if (node && leaf) {
        wsprintf (debugBuffer, TEXT("[Node:%s Leaf:%s]"), node, leaf);
    } else if (node) {
        wsprintf (debugBuffer, TEXT("[Node:%s]"), node);
    } else if (leaf) {
        wsprintf (debugBuffer, TEXT("[Leaf:%s]"), leaf);
    } else {
        StringCopy (debugBuffer, TEXT("[nul]"));
    }

    return debugBuffer;
}

VOID
pSaveObjectAndFileItReferences (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PACTION_STRUCT RegActionStruct,
    IN      BOOL VcmMode,
    IN      BOOL Recursive
    )
{
    MIG_CONTENT content;
    GROWBUFFER cmdLineBuffer = INIT_GROWBUFFER;
    PCMDLINE cmdLine;
    PTSTR pathData;
    PCTSTR p;
    PCTSTR end;
    PCTSTR expandPath = NULL;
    PCTSTR expandHint = NULL;
    UINT u;
    BOOL foundFile = FALSE;
    PDWORD valueType;
    MIG_OBJECTSTRINGHANDLE handle;
    MIG_OBJECTSTRINGHANDLE nodeHandle;
    BOOL parsable;
    BOOL firstPass = TRUE;
    ACTION_STRUCT actionStruct;
    DWORD actionFlags;
    BOOL hintUsed = FALSE;
    MIG_BLOB blob;

    //
    // Obtain the object data
    //

    if (IsmAcquireObjectEx (ObjectTypeId, ObjectName, &content, CONTENTTYPE_MEMORY, 4096)) {

        //
        // Parse the data for a file
        //

        pathData = (PTSTR) content.MemoryContent.ContentBytes;

        parsable = FALSE;

        if ((ObjectTypeId & (~PLATFORM_MASK)) == g_RegType) {
            valueType = (PDWORD)(content.Details.DetailsData);

            if (valueType) {
                if (*valueType == REG_EXPAND_SZ ||
                    *valueType == REG_SZ
                    ) {

                    parsable = TRUE;
                }
            } else {
                MYASSERT (IsmIsObjectHandleNodeOnly (ObjectName));
            }
        }

        if (parsable) {

            p = pathData;
            end = (PCTSTR) (content.MemoryContent.ContentBytes + content.MemoryContent.ContentSize);

            while (p < end) {
                if (*p == 0) {
                    break;
                }

                p = _tcsinc (p);
            }

            if (p >= end) {
                pathData = NULL;
            }

        } else {
            pathData = NULL;
        }


        if (pathData) {
            if ((*valueType == REG_EXPAND_SZ) ||
                (*valueType == REG_SZ)
                ) {
                //
                // Expand the data
                //

                expandPath = IsmExpandEnvironmentString (
                    PLATFORM_SOURCE,
                    S_SYSENVVAR_GROUP,
                    pathData,
                    NULL
                    );
                pathData = (PTSTR)expandPath;
            }

            if (RegActionStruct && RegActionStruct->ObjectHint) {
                expandHint = IsmExpandEnvironmentString (
                    PLATFORM_SOURCE,
                    S_SYSENVVAR_GROUP,
                    RegActionStruct->ObjectHint,
                    NULL
                    );
            }

            // first we try it as is
            handle = pTryHandle (pathData, expandHint, Recursive, &hintUsed);

            if (handle) {

                ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));
                actionStruct.ObjectBase = handle;
                actionFlags = ACTION_PERSIST;

                if (RegActionStruct) {
                    actionStruct.ObjectDest = RegActionStruct->AddnlDest;
                }

                if (Recursive) {
                    nodeHandle = IsmCreateObjectHandle (pathData, NULL);
                    AddRule (
                        g_FileType,
                        nodeHandle,
                        handle,
                        ACTIONGROUP_REGFOLDER,
                        actionFlags,
                        &actionStruct
                        );
                    IsmQueueEnumeration (
                        g_FileType,
                        nodeHandle,
                        VcmMode ? GatherVirtualComputer : PrepareActions,
                        0,
                        NULL
                        );
                    IsmDestroyObjectHandle (nodeHandle);
                } else {
                    AddRule (
                        g_FileType,
                        handle,
                        handle,
                        ACTIONGROUP_REGFILE,
                        actionFlags,
                        &actionStruct
                        );
                }

                IsmQueueEnumeration (
                    g_FileType,
                    handle,
                    VcmMode ? GatherVirtualComputer : PrepareActions,
                    0,
                    NULL
                    );

                foundFile = TRUE;

                IsmDestroyObjectHandle (handle);

                if (hintUsed && expandHint) {
                    // we need to add extra data for the content fix operation
                    blob.Type = BLOBTYPE_STRING;
                    blob.String = expandHint;
                    IsmSetOperationOnObject (
                        ObjectTypeId,
                        ObjectName,
                        g_RegAutoFilterOp,
                        NULL,
                        &blob
                        );
                }

            } else {

                cmdLine = ParseCmdLineEx (pathData, NULL, pOurFindFile, pOurSearchPath, &cmdLineBuffer);

                if (cmdLine) {

                    //
                    // Find the file referenced in the list or command line
                    //
                    for (u = 0 ; u < cmdLine->ArgCount ; u++) {

                        p = cmdLine->Args[u].CleanedUpArg;

                        // first we try it as is
                        handle = pTryHandle (p, expandHint, Recursive, &hintUsed);

                        if (handle) {

                            ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));
                            actionStruct.ObjectBase = handle;
                            actionFlags = ACTION_PERSIST;

                            if (RegActionStruct) {
                                actionStruct.ObjectDest = RegActionStruct->AddnlDest;
                            }

                            AddRule (
                                g_FileType,
                                handle,
                                handle,
                                ACTIONGROUP_REGFILE,
                                actionFlags,
                                &actionStruct
                                );

                            IsmQueueEnumeration (
                                g_FileType,
                                handle,
                                VcmMode ? GatherVirtualComputer : PrepareActions,
                                0,
                                NULL
                                );

                            foundFile = TRUE;

                            IsmDestroyObjectHandle (handle);

                            if (hintUsed && expandHint) {
                                // we need to add extra data for the content fix operation
                                blob.Type = BLOBTYPE_STRING;
                                blob.String = expandHint;
                                IsmSetOperationOnObject (
                                    ObjectTypeId,
                                    ObjectName,
                                    g_RegAutoFilterOp,
                                    NULL,
                                    &blob
                                    );
                            }

                        } else {

                            // maybe we have something like /m:c:\foo.txt
                            // we need to go forward until we find a sequence of
                            // <alpha>:\<something>
                            if (p[0] && p[1]) {

                                while (p[2]) {

                                    if (_istalpha ((CHARTYPE) _tcsnextc (p)) &&
                                        p[1] == TEXT(':') &&
                                        p[2] == TEXT('\\')
                                        ) {

                                        handle = pTryHandle (p, expandHint, Recursive, &hintUsed);

                                        if (handle) {

                                            ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));
                                            actionStruct.ObjectBase = handle;
                                            actionFlags = ACTION_PERSIST;
                                            if (RegActionStruct) {
                                                actionStruct.ObjectDest = RegActionStruct->AddnlDest;
                                            }
                                            AddRule (
                                                g_FileType,
                                                handle,
                                                handle,
                                                ACTIONGROUP_REGFILE,
                                                actionFlags,
                                                &actionStruct
                                                );
                                            IsmQueueEnumeration (
                                                g_FileType,
                                                handle,
                                                VcmMode ? GatherVirtualComputer : PrepareActions,
                                                0,
                                                NULL
                                                );
                                            foundFile = TRUE;

                                            IsmDestroyObjectHandle (handle);

                                            if (hintUsed && expandHint) {
                                                // we need to add extra data for the content fix operation
                                                blob.Type = BLOBTYPE_STRING;
                                                blob.String = expandHint;
                                                IsmSetOperationOnObject (
                                                    ObjectTypeId,
                                                    ObjectName,
                                                    g_RegAutoFilterOp,
                                                    NULL,
                                                    &blob
                                                    );
                                            }

                                            break;
                                        }
                                    }
                                    p ++;
                                }
                            }
                        }
                    }
                }
            }
        }

        //
        // We persist the registry object at all times
        //
        if (VcmMode) {
            IsmMakePersistentObject (ObjectTypeId, ObjectName);
        } else {
            IsmMakeApplyObject (ObjectTypeId, ObjectName);
        }
        if (!foundFile && !expandHint && pathData && _tcschr (pathData, TEXT('.')) && !_tcschr (pathData, TEXT('\\'))) {
            // we assume that the value is a file name by itself
            // If we are in VcmMode we are going to persist this
            // key and all files that have the name equal with
            // the value of this key
            if (VcmMode && pathData) {
                handle = IsmCreateSimpleObjectPattern (NULL, FALSE, pathData, FALSE);
                AddRule (
                    g_FileType,
                    handle,
                    handle,
                    ACTIONGROUP_REGFILE,
                    ACTION_PERSIST,
                    NULL
                    );

                DEBUGMSG ((
                    DBG_SCRIPT,
                    "RegFile %s triggered enumeration of entire file system because of %s",
                    pGetObjectNameForDebug (ObjectName),
                    pathData
                    ));

                QueueAllFiles();
                IsmHookEnumeration (
                    g_FileType,
                    handle,
                    GatherVirtualComputer,
                    0,
                    NULL
                    );
                IsmDestroyObjectHandle (handle);
            }
        }
        IsmReleaseObject (&content);

        if (expandPath) {
           IsmReleaseMemory (expandPath);
           expandPath = NULL;
        }
        if (expandHint) {
           IsmReleaseMemory (expandHint);
           expandHint = NULL;
        }
    }
    GbFree (&cmdLineBuffer);
}

VOID
pSaveObjectAndIconItReferences (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PACTION_STRUCT RegActionStruct,
    IN      BOOL VcmMode
    )
{
    MIG_CONTENT content;
    GROWBUFFER cmdLineBuffer = INIT_GROWBUFFER;
    PCMDLINE cmdLine;
    PTSTR pathData;
    BOOL parsable;
    PDWORD valueType;
    PCTSTR p;
    PCTSTR end;
    PCTSTR expandPath = NULL;
    PCTSTR expandHint = NULL;
    MIG_OBJECTSTRINGHANDLE handle;
    BOOL foundFile = FALSE;
    INT iconNumber = 0;
    PICON_GROUP iconGroup = NULL;
    ICON_SGROUP iconSGroup;
    PCTSTR iconResId = NULL;
    MIG_CONTENT iconContent;
    MIG_BLOB migBlob;

    //
    // Obtain the object data
    //

    if (IsmAcquireObjectEx (ObjectTypeId, ObjectName, &content, CONTENTTYPE_MEMORY, 4096)) {

        //
        // Parse the data for a file
        //

        pathData = (PTSTR) content.MemoryContent.ContentBytes;

        parsable = FALSE;

        if ((ObjectTypeId & (~PLATFORM_MASK)) == g_RegType) {
            valueType = (PDWORD)(content.Details.DetailsData);

            if (valueType) {
                if (*valueType == REG_EXPAND_SZ ||
                    *valueType == REG_SZ
                    ) {

                    parsable = TRUE;
                }
            } else {
                MYASSERT (IsmIsObjectHandleNodeOnly (ObjectName));
            }
        }

        if (parsable) {

            p = pathData;
            end = (PCTSTR) (content.MemoryContent.ContentBytes + content.MemoryContent.ContentSize);

            while (p < end) {
                if (*p == 0) {
                    break;
                }

                p = _tcsinc (p);
            }

            if (p >= end) {
                pathData = NULL;
            }

        } else {
            pathData = NULL;
        }


        if (pathData) {
            if ((*valueType == REG_EXPAND_SZ) ||
                (*valueType == REG_SZ)
                ) {
                //
                // Expand the data
                //
                expandPath = IsmExpandEnvironmentString (
                    PLATFORM_SOURCE,
                    S_SYSENVVAR_GROUP,
                    pathData,
                    NULL
                    );
                pathData = (PTSTR)expandPath;
            }

            if (RegActionStruct && RegActionStruct->ObjectHint) {
                expandHint = IsmExpandEnvironmentString (
                    PLATFORM_SOURCE,
                    S_SYSENVVAR_GROUP,
                    RegActionStruct->ObjectHint,
                    NULL
                    );
            }

            cmdLine = ParseCmdLineEx (pathData, TEXT(","), pOurFindFile, pOurSearchPath, &cmdLineBuffer);

            if (cmdLine) {
                // we only expect two args, the icon file name and the icon number
                if (cmdLine->ArgCount <= 2) {

                    p = cmdLine->Args[0].CleanedUpArg;

                    handle = pTryHandle (p, expandHint, FALSE, NULL);

                    if (handle) {

                        if (VcmMode) {
                            // we are just going to persist the object so we can look at it later
                            IsmMakePersistentObject (g_FileType, handle);
                        } else {
                            iconNumber = 0;
                            if (cmdLine->ArgCount == 2) {
                                // get the icon number
                                iconNumber = _ttoi (cmdLine->Args[1].CleanedUpArg);
                            }

                            // now acquire the object and extract the icon
                            if (IsmAcquireObjectEx (
                                    MIG_FILE_TYPE,
                                    handle,
                                    &iconContent,
                                    CONTENTTYPE_FILE,
                                    0
                                    )) {
                                if (iconNumber >= 0) {
                                    iconGroup = IcoExtractIconGroupByIndexFromFile (
                                                    iconContent.FileContent.ContentPath,
                                                    iconNumber,
                                                    NULL
                                                    );
                                } else {
                                    iconResId = (PCTSTR) (LONG_PTR) (-iconNumber);
                                    iconGroup = IcoExtractIconGroupFromFile (
                                                    iconContent.FileContent.ContentPath,
                                                    iconResId,
                                                    NULL
                                                    );
                                }
                                if (iconGroup) {
                                    if (IcoSerializeIconGroup (iconGroup, &iconSGroup)) {
                                        // save the icon data as a property
                                        migBlob.Type = BLOBTYPE_BINARY;
                                        migBlob.BinaryData = (PCBYTE)(iconSGroup.Data);
                                        migBlob.BinarySize = iconSGroup.DataSize;
                                        IsmAddPropertyToObject (ObjectTypeId, ObjectName, g_DefaultIconData, &migBlob);
                                        IcoReleaseIconSGroup (&iconSGroup);

                                        // now add the appropriate operation
                                        IsmSetOperationOnObject (
                                            ObjectTypeId,
                                            ObjectName,
                                            g_DefaultIconOp,
                                            NULL,
                                            NULL
                                            );

                                        foundFile = TRUE;
                                    }
                                    IcoReleaseIconGroup (iconGroup);
                                }
                                IsmReleaseObject (&iconContent);
                            }
                        }

                        IsmDestroyObjectHandle (handle);
                    }
                }
            }
            GbFree (&cmdLineBuffer);

            if (expandPath) {
                IsmReleaseMemory (expandPath);
                expandPath = NULL;
            }
            if (expandHint) {
                IsmReleaseMemory (expandHint);
                expandHint = NULL;
            }
        }

        //
        // We persist the registry object at all times
        //
        if (VcmMode) {
            IsmMakePersistentObject (ObjectTypeId, ObjectName);
        } else {
            if (foundFile) {
                IsmMakeApplyObject (ObjectTypeId, ObjectName);
            }
        }
        IsmReleaseObject (&content);
    }
}

UINT
GatherVirtualComputer (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    ACTIONGROUP actionGroup;
    DWORD actionFlags;
    BOOL match;
    PCTSTR encodedNodeOnly;
    ACTION_STRUCT actionStruct;
    MIG_OBJECTID objectId = 0;

    //
    // Obtain the best rule for this object
    //

    match = QueryRule (
                Data->ObjectTypeId,
                Data->ObjectName,
                Data->ObjectNode,
                &actionGroup,
                &actionFlags,
                &actionStruct
                );

    if (!match && !Data->ObjectLeaf) {
        //
        // If this is a node only, try matching with an empty leaf
        //

        encodedNodeOnly = IsmCreateObjectHandle (Data->ObjectNode, TEXT(""));
        match = QueryRule (
                    Data->ObjectTypeId,
                    encodedNodeOnly,
                    Data->ObjectNode,
                    &actionGroup,
                    &actionFlags,
                    &actionStruct
                    );

        IsmDestroyObjectHandle (encodedNodeOnly);
    }

    if (match) {
        //
        // Mark all objects necessary for the rule to be processed.  We
        // will do the rule's action(s) on the right side.
        //

        if ((actionGroup == ACTIONGROUP_INCLUDE) ||
            (actionGroup == ACTIONGROUP_INCLUDEEX) ||
            (actionGroup == ACTIONGROUP_RENAME) ||
            (actionGroup == ACTIONGROUP_RENAMEEX) ||
            (actionGroup == ACTIONGROUP_INCLUDERELEVANT) ||
            (actionGroup == ACTIONGROUP_INCLUDERELEVANTEX) ||
            (actionGroup == ACTIONGROUP_RENAMERELEVANT) ||
            (actionGroup == ACTIONGROUP_RENAMERELEVANTEX) ||
            (actionGroup == ACTIONGROUP_REGFILE) ||
            (actionGroup == ACTIONGROUP_REGFILEEX) ||
            (actionGroup == ACTIONGROUP_REGFOLDER) ||
            (actionGroup == ACTIONGROUP_REGFOLDEREX) ||
            (actionGroup == ACTIONGROUP_REGICON) ||
            (actionGroup == ACTIONGROUP_REGICONEX)
            ) {

            objectId = IsmGetObjectIdFromName (Data->ObjectTypeId, Data->ObjectName, FALSE);

            if (objectId) {

                if (actionFlags & ACTION_PERSIST) {
                    if (!IsmIsAttributeSetOnObjectId (objectId, g_OsFileAttribute)) {
                        IsmMakePersistentObjectId (objectId);
                    }
                }

                if ((actionGroup == ACTIONGROUP_INCLUDERELEVANT) ||
                    (actionGroup == ACTIONGROUP_RENAMERELEVANT)
                    ) {
                    IsmSetAttributeOnObjectId (objectId, g_CopyIfRelevantAttr);
                }

                if (actionFlags & ACTION_PERSIST_PATH_IN_DATA) {
                    pSaveObjectAndFileItReferences (Data->ObjectTypeId, Data->ObjectName, &actionStruct, TRUE, actionGroup == ACTIONGROUP_REGFOLDER);
                }
                if (actionFlags & ACTION_PERSIST_ICON_IN_DATA) {
                    pSaveObjectAndIconItReferences (Data->ObjectTypeId, Data->ObjectName, &actionStruct, TRUE);
                }
            }
        }
    }

    return CALLBACK_ENUM_CONTINUE;
}


MIG_DATAHANDLE
pGetDataHandleForSrc (
    IN      PCTSTR RenameSrc
    )
{
    MIG_DATAHANDLE dataHandle;
    MIG_BLOB blob;

    //
    // First check hash table to see if we have an ID
    //

    if (!HtFindStringEx (g_RenameSrcTable, RenameSrc, &dataHandle, FALSE)) {
        blob.Type = BLOBTYPE_STRING;
        blob.String = RenameSrc;
        dataHandle = IsmRegisterOperationData (&blob);

        HtAddStringEx (g_RenameSrcTable, RenameSrc, &dataHandle, FALSE);
    }

    return dataHandle;
}


MIG_DATAHANDLE
pGetDataHandleForDest (
    IN      PCTSTR RenameDest
    )
{
    MIG_DATAHANDLE dataHandle;
    MIG_BLOB blob;

    //
    // First check hash table to see if we have an ID
    //

    if (!HtFindStringEx (g_RenameDestTable, RenameDest, &dataHandle, FALSE)) {
        blob.Type = BLOBTYPE_STRING;
        blob.String = RenameDest;
        dataHandle = IsmRegisterOperationData (&blob);

        HtAddStringEx (g_RenameDestTable, RenameDest, &dataHandle, FALSE);
    }

    return dataHandle;
}


UINT
PrepareActions (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    ACTIONGROUP actionGroup;
    DWORD actionFlags;
    BOOL match;
    PCTSTR encodedNodeOnly;
    MIG_DATAHANDLE srcDataHandle;
    MIG_DATAHANDLE destDataHandle;
    ACTION_STRUCT actionStruct;
    MIG_OBJECTID objectId = 0;

    //
    // Obtain the best rule for this object
    //

    match = QueryRule (
                Data->ObjectTypeId,
                Data->ObjectName,
                Data->ObjectNode,
                &actionGroup,
                &actionFlags,
                &actionStruct
                );

    if (!match && !Data->ObjectLeaf) {
        //
        // If this is a node only, try matching with an empty leaf
        //

        encodedNodeOnly = IsmCreateObjectHandle (Data->ObjectNode, TEXT(""));
        match = QueryRule (
                    Data->ObjectTypeId,
                    encodedNodeOnly,
                    Data->ObjectNode,
                    &actionGroup,
                    &actionFlags,
                    &actionStruct
                    );

        IsmDestroyObjectHandle (encodedNodeOnly);
    }

    if (match) {
        //
        // Mark the objects for the designated operations.
        //

        if ((actionGroup == ACTIONGROUP_INCLUDE) ||
            (actionGroup == ACTIONGROUP_INCLUDEEX) ||
            (actionGroup == ACTIONGROUP_RENAME) ||
            (actionGroup == ACTIONGROUP_RENAMEEX) ||
            (actionGroup == ACTIONGROUP_INCLUDERELEVANT) ||
            (actionGroup == ACTIONGROUP_INCLUDERELEVANTEX) ||
            (actionGroup == ACTIONGROUP_RENAMERELEVANT) ||
            (actionGroup == ACTIONGROUP_RENAMERELEVANTEX) ||
            (actionGroup == ACTIONGROUP_REGFILE) ||
            (actionGroup == ACTIONGROUP_REGFILEEX) ||
            (actionGroup == ACTIONGROUP_REGFOLDER) ||
            (actionGroup == ACTIONGROUP_REGFOLDEREX) ||
            (actionGroup == ACTIONGROUP_REGICON) ||
            (actionGroup == ACTIONGROUP_REGICONEX)
            ) {

            objectId = IsmGetObjectIdFromName (Data->ObjectTypeId, Data->ObjectName, FALSE);

            if (objectId) {

                if (actionFlags & ACTION_PERSIST) {
                    if (!IsmIsAttributeSetOnObjectId (objectId, g_OsFileAttribute)) {
                        IsmMakeApplyObjectId (objectId);
                    }
                }

                if ((actionGroup == ACTIONGROUP_INCLUDERELEVANT) ||
                    (actionGroup == ACTIONGROUP_RENAMERELEVANT)
                    ) {
                    IsmSetAttributeOnObjectId (objectId, g_CopyIfRelevantAttr);
                }

                if (actionFlags & ACTION_PERSIST_PATH_IN_DATA) {
                    pSaveObjectAndFileItReferences (Data->ObjectTypeId, Data->ObjectName, &actionStruct, FALSE, actionGroup == ACTIONGROUP_REGFOLDER);
                }
                if (actionFlags & ACTION_PERSIST_ICON_IN_DATA) {
                    pSaveObjectAndIconItReferences (Data->ObjectTypeId, Data->ObjectName, &actionStruct, FALSE);
                }
            }
        }
        if ((actionGroup == ACTIONGROUP_RENAME) ||
            (actionGroup == ACTIONGROUP_RENAMEEX) ||
            (actionGroup == ACTIONGROUP_RENAMERELEVANT) ||
            (actionGroup == ACTIONGROUP_RENAMERELEVANTEX) ||
            (actionGroup == ACTIONGROUP_REGFILE) ||
            (actionGroup == ACTIONGROUP_REGFILEEX) ||
            (actionGroup == ACTIONGROUP_REGFOLDER) ||
            (actionGroup == ACTIONGROUP_REGFOLDEREX) ||
            (actionGroup == ACTIONGROUP_REGICON) ||
            (actionGroup == ACTIONGROUP_REGICONEX)
            ) {
            if (actionStruct.ObjectDest) {

                if (actionStruct.ObjectBase) {
                    srcDataHandle = pGetDataHandleForSrc (actionStruct.ObjectBase);
                } else {
                    srcDataHandle = 0;
                }

                destDataHandle = pGetDataHandleForDest (actionStruct.ObjectDest);

                if (!objectId) {
                    objectId = IsmGetObjectIdFromName (Data->ObjectTypeId, Data->ObjectName, FALSE);
                }

                if (objectId) {

                    if ((Data->ObjectTypeId & (~PLATFORM_MASK)) == g_FileType) {
                        if ((actionGroup == ACTIONGROUP_RENAMERELEVANTEX) ||
                            (actionGroup == ACTIONGROUP_RENAMEEX)
                            ) {
                            IsmSetOperationOnObjectId2 (
                                objectId,
                                g_RenameFileExOp,
                                srcDataHandle,
                                destDataHandle
                                );
                        } else {
                            IsmSetOperationOnObjectId2 (
                                objectId,
                                g_RenameFileOp,
                                srcDataHandle,
                                destDataHandle
                                );
                        }
                    } else {
                        IsmSetOperationOnObjectId2 (
                            objectId,
                            (actionGroup == ACTIONGROUP_RENAMEEX ? g_RenameExOp : g_RenameOp),
                            srcDataHandle,
                            destDataHandle
                            );
                    }
                }
            }
        }
    }

    return CALLBACK_ENUM_CONTINUE;
}


UINT
NulCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    return CALLBACK_ENUM_CONTINUE;
}


UINT
ObjectPriority (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    ACTIONGROUP actionGroup;
    DWORD actionFlags;
    BOOL match;

    match = QueryRuleEx (
                Data->ObjectTypeId,
                Data->ObjectName,
                Data->ObjectNode,
                &actionGroup,
                &actionFlags,
                NULL,
                RULEGROUP_PRIORITY
                );

    if (match) {
        MYASSERT ((actionFlags == ACTION_PRIORITYSRC) || (actionFlags == ACTION_PRIORITYDEST));
        if (actionFlags == ACTION_PRIORITYSRC) {
            IsmClearAbandonObjectOnCollision (
                (Data->ObjectTypeId & (~PLATFORM_MASK)) | PLATFORM_SOURCE,
                Data->ObjectName
                );
            IsmAbandonObjectOnCollision (
                (Data->ObjectTypeId & (~PLATFORM_MASK)) | PLATFORM_DESTINATION,
                Data->ObjectName
                );
        } else {
            IsmAbandonObjectOnCollision (
                (Data->ObjectTypeId & (~PLATFORM_MASK)) | PLATFORM_SOURCE,
                Data->ObjectName
                );
            IsmClearAbandonObjectOnCollision (
                (Data->ObjectTypeId & (~PLATFORM_MASK)) | PLATFORM_DESTINATION,
                Data->ObjectName
                );
        }
    }
    return CALLBACK_ENUM_CONTINUE;
}

UINT
FileCollPattern (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    ACTIONGROUP actionGroup;
    DWORD actionFlags;
    ACTION_STRUCT actionStruct;
    BOOL match;
    MIG_BLOB migBlob;

    match = QueryRuleEx (
                Data->ObjectTypeId,
                Data->ObjectName,
                Data->ObjectNode,
                &actionGroup,
                &actionFlags,
                &actionStruct,
                RULEGROUP_COLLPATTERN
                );

    if (match && (!(IsmIsObjectHandleNodeOnly (Data->ObjectName)))) {
        // Let's set a property on this file (we don't need this for nodes)
        migBlob.Type = BLOBTYPE_STRING;
        migBlob.String = actionStruct.ObjectHint;
        IsmAddPropertyToObject (Data->ObjectTypeId, Data->ObjectName, g_FileCollPatternData, &migBlob);
    }
    return CALLBACK_ENUM_CONTINUE;
}

UINT
LockPartition (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    IsmSetAttributeOnObject (Data->ObjectTypeId, Data->ObjectName, g_LockPartitionAttr);

    return CALLBACK_ENUM_CONTINUE;
}

UINT
ExcludeKeyIfValueExists (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;

    // This function is only called for each registry key/value pair that
    // indicates we want to cause the exclusion of the entire key.

    IsmCreateObjectStringsFromHandle (Data->ObjectName, &srcNode, &srcLeaf);

    // This is also called for all keys (not including a value) so we need
    // to make sure a value is passed in

    if (srcLeaf && *srcLeaf) {
        // Exclude the srcNode
        HtAddString (g_DePersistTable, srcNode);
    }
    IsmDestroyObjectString (srcNode);
    IsmDestroyObjectString (srcLeaf);

    return CALLBACK_ENUM_CONTINUE;
}

BOOL
PostDelregKeyCallback (
    VOID
    )
{
    static BOOL called = FALSE;

    HASHTABLE_ENUM hashData;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE pattern;

    if (called) {
        return TRUE;
    }

    // Enumerate all Excluded keys
    if (EnumFirstHashTableString (&hashData, g_DePersistTable)) {
        do {
            // Remove Persistence on the key
            pattern = IsmCreateObjectHandle (hashData.String, NULL);
            IsmClearPersistenceOnObject (g_RegType, pattern);
            IsmDestroyObjectHandle (pattern);

            // Enumerate each value in this key
            pattern = IsmCreateSimpleObjectPattern (hashData.String, TRUE, NULL, TRUE);
            if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, pattern)) {
                do {
                    // Remove Persistence on each value
                    IsmClearPersistenceOnObject (objectEnum.ObjectTypeId, objectEnum.ObjectName);
                } while (IsmEnumNextObject (&objectEnum));
            }
            IsmDestroyObjectHandle (pattern);

        } while (EnumNextHashTableString (&hashData));
    }

    HtFree (g_DePersistTable);
    g_DePersistTable = NULL;

    called = TRUE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\sgminit.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sgminit.c

Abstract:

    Implements the initialization/termination code for the data gather portion
    of scanstate v1 compatiblity.

Author:

    Jim Schmidt (jimschm) 12-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

PMAPSTRUCT g_EnvMap;
PMAPSTRUCT g_UndefMap;
PMAPSTRUCT g_RevEnvMap;
HASHTABLE g_RenameSrcTable;
HASHTABLE g_RenameDestTable;
HASHTABLE g_DePersistTable;
PMHANDLE g_V1Pool;
MIG_OBJECTTYPEID g_FileType;
MIG_OBJECTTYPEID g_RegType;
MIG_ATTRIBUTEID g_OsFileAttribute;
MIG_ATTRIBUTEID g_CopyIfRelevantAttr;
MIG_ATTRIBUTEID g_LockPartitionAttr;

//
// Macro expansion list
//



//
// Private function prototypes
//

VCMINITIALIZE ScriptVcmInitialize;
SGMINITIALIZE ScriptSgmInitialize;

BOOL
pParseAllInfs (
    VOID
    );

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
pPrepareIsmEnvironment (
    VOID
    )
{
    if (IsmGetRealPlatform() == PLATFORM_SOURCE) {
        SetIsmEnvironmentFromPhysicalMachine (g_EnvMap, FALSE, g_UndefMap);
    } else {
        SetIsmEnvironmentFromVirtualMachine (g_EnvMap, g_RevEnvMap, g_UndefMap);
    }
}


BOOL
pInitGlobals (
    IN      PMIG_LOGCALLBACK LogCallback
    )
{
    BOOL result;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    g_V1Pool = PmCreateNamedPool ("v1 sgm");
    g_EnvMap = CreateStringMapping();
    g_UndefMap = CreateStringMapping();
    g_RevEnvMap = CreateStringMapping();

    g_FileType = MIG_FILE_TYPE;
    g_RegType = MIG_REGISTRY_TYPE;

    result = g_V1Pool && g_EnvMap && g_UndefMap && g_RevEnvMap;

    if (!result) {
        DEBUGMSG ((DBG_ERROR, "Unable to initialize gather module globals"));\
    }

    return result;
}


BOOL
pCommonInit (
    IN      PVOID Reserved,
    IN      BOOL VcmMode
    )
{
    g_OsFileAttribute = IsmRegisterAttribute (S_ATTRIBUTE_OSFILE, FALSE);
    g_CopyIfRelevantAttr = IsmRegisterAttribute (S_ATTRIBUTE_COPYIFRELEVANT, FALSE);
    g_LockPartitionAttr = IsmRegisterAttribute (S_ATTRIBUTE_PARTITIONLOCK, FALSE);

    g_DePersistTable = HtAlloc ();

    InitRules();

    //
    // Call special conversion entry point
    //
    InitSpecialConversion (PLATFORM_SOURCE);
    InitSpecialRename (PLATFORM_SOURCE);

    //
    // Save shell folder environment
    //

    pPrepareIsmEnvironment();

    return TRUE;
}


BOOL
pGetDomainUserName (
    OUT     PCTSTR *Domain,
    OUT     PCTSTR *User
    )
{
    TCHAR userName[256];
    TCHAR domainName[256];
    DWORD size;
    HANDLE token = NULL;
    BOOL b;
    PTOKEN_USER tokenInfo = NULL;
    BOOL result = FALSE;
    DWORD domainSize;
    SID_NAME_USE dontCare;
    MIG_OBJECTSTRINGHANDLE regObject;
    MIG_CONTENT regContent;

    *Domain = NULL;
    *User = NULL;

    //
    // Assert that this is the source platform. We access the system directly.
    //

    MYASSERT (IsmGetRealPlatform() == PLATFORM_SOURCE);

    __try {

        if (ISWIN9X()) {

            size = ARRAYSIZE(userName);
            if (!GetUserName (userName, &size)) {
                LOG ((LOG_WARNING, (PCSTR) MSG_CANT_GET_USERNAME));
                __leave;
            }

            *User = DuplicateText (userName);

            regObject = IsmCreateObjectHandle (
                            TEXT("HKLM\\System\\CurrentControlSet\\Services\\MSNP32\\NetworkProvider"),
                            TEXT("AuthenticatingAgent")
                            );

            if (IsmAcquireObject (g_RegType, regObject, &regContent)) {
                if (!regContent.ContentInFile &&
                    regContent.MemoryContent.ContentBytes &&
                    regContent.Details.DetailsSize == sizeof (DWORD) &&
                    *((PDWORD) regContent.Details.DetailsData) == REG_SZ
                    ) {
                    *Domain = DuplicateText ((PCTSTR) regContent.MemoryContent.ContentBytes);
                }

                IsmReleaseObject (&regContent);
            }

            IsmDestroyObjectHandle (regObject);

        } else {
            if (!OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &token)) {
                LOG ((LOG_WARNING, (PCSTR) MSG_PROCESS_TOKEN_ERROR));
                __leave;
            }

            size = 0;

            GetTokenInformation (
                token,
                TokenUser,  // sdk enum value
                NULL,
                0,
                &size
                );

            if (size) {
                tokenInfo = (PTOKEN_USER) MemAllocUninit (size);

                b = GetTokenInformation (
                        token,
                        TokenUser,
                        tokenInfo,
                        size,
                        &size
                        );
            } else {
                b = FALSE;
            }

            if (!b) {
                LOG ((LOG_WARNING, (PCSTR) MSG_PROCESS_TOKEN_INFO_ERROR));
                __leave;
            }

            size = ARRAYSIZE (userName);
            domainSize = ARRAYSIZE (domainName);

            b = LookupAccountSid (
                    NULL,
                    tokenInfo->User.Sid,
                    userName,
                    &size,
                    domainName,
                    &domainSize,
                    &dontCare
                    );

            if (!b) {
                LOG ((LOG_WARNING, (PCSTR) MSG_SECURITY_ID_LOOKUP_ERROR));
                __leave;
            }

            *User = DuplicateText (userName);

            if (*domainName) {
                *Domain = DuplicateText (domainName);
            }
        }

        result = TRUE;

    }
    __finally {
        if (tokenInfo) {
            FreeAlloc (tokenInfo);
        }

        if (token) {
            CloseHandle (token);
        }
    }

    return result;
}


BOOL
WINAPI
ScriptSgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    TCHAR userName[256];
    TCHAR domainName[256];
    PCTSTR srcUserName;
    PCTSTR srcDomainName;

    if (!pInitGlobals (LogCallback)) {
        return FALSE;
    }

    g_RenameSrcTable = HtAllocWithData (sizeof (MIG_DATAHANDLE));
    g_RenameDestTable = HtAllocWithData (sizeof (MIG_DATAHANDLE));

    if (IsmGetRealPlatform() == PLATFORM_DESTINATION) {

        IsmGetTransportVariable (PLATFORM_SOURCE, S_USER_SECTION, S_USER_INFKEY, userName, sizeof (userName));

        if (!IsmGetTransportVariable (PLATFORM_SOURCE, S_USER_SECTION, S_DOMAIN_INFKEY, domainName, sizeof (domainName))) {
            if (IsmIsEnvironmentFlagSet (PLATFORM_DESTINATION, NULL, S_REQUIRE_DOMAIN_USER)) {
                //
                // NOTE: We could create the user account for the non-domain case.
                //

                IsmSetCancel();
                SetLastError (ERROR_INVALID_DOMAINNAME);
                LOG ((LOG_ERROR, (PCSTR) MSG_DOMAIN_REQUIRED));
                return FALSE;
            }
        } else {
            IsmSetEnvironmentString (
                PLATFORM_SOURCE,
                S_SYSENVVAR_GROUP,
                TEXT("USERDOMAIN"),
                domainName
                );
            AddStringMappingPair (g_EnvMap, TEXT("%DOMAINNAME%"), domainName);
        }

        IsmSetEnvironmentString (
            PLATFORM_SOURCE,
            S_SYSENVVAR_GROUP,
            TEXT("USERNAME"),
            userName
            );
        AddStringMappingPair (g_EnvMap, TEXT("%USERNAME%"), userName);

    } else {

        if (!pGetDomainUserName (&srcDomainName, &srcUserName)) {
            if (IsmIsEnvironmentFlagSet (PLATFORM_DESTINATION, NULL, S_REQUIRE_DOMAIN_USER)) {
                return FALSE;
            }
        } else {

            IsmSetTransportVariable (PLATFORM_SOURCE, S_USER_SECTION, S_USER_INFKEY, srcUserName);
            IsmSetEnvironmentString (
                PLATFORM_SOURCE,
                S_SYSENVVAR_GROUP,
                TEXT("USERNAME"),
                srcUserName
                );
            AddStringMappingPair (g_EnvMap, TEXT("%USERNAME%"), srcUserName);

            if (srcDomainName) {
                IsmSetTransportVariable (PLATFORM_SOURCE, S_USER_SECTION, S_DOMAIN_INFKEY, srcDomainName);
                IsmSetEnvironmentString (
                    PLATFORM_SOURCE,
                    S_SYSENVVAR_GROUP,
                    TEXT("USERDOMAIN"),
                    srcDomainName
                    );
                AddStringMappingPair (g_EnvMap, TEXT("%DOMAINNAME%"), srcDomainName);
            }

            FreeText (srcUserName);
            FreeText (srcDomainName);
        }
    }

    //
    // Parse the script and do the rest of the business
    //

    return pCommonInit (Reserved, FALSE);
}


VOID
pSaveRegDword (
    IN      PCTSTR InfKeyName,
    IN      PCTSTR Key,
    IN      PCTSTR Value
    )
{
    TCHAR buffer[32];
    MIG_OBJECTSTRINGHANDLE regObject;
    MIG_CONTENT regContent;

    regObject = IsmCreateObjectHandle (Key, Value);

    if (IsmAcquireObject (g_RegType, regObject, &regContent)) {
        if (!regContent.ContentInFile &&
            regContent.MemoryContent.ContentBytes &&
            regContent.Details.DetailsSize == sizeof (DWORD) &&
            *((PDWORD) regContent.Details.DetailsData) == REG_DWORD
            ) {
            wsprintf (buffer, TEXT("0x%08X"), *((PDWORD) regContent.MemoryContent.ContentBytes));
            IsmSetTransportVariable (PLATFORM_SOURCE, S_SOURCE_MACHINE_SECTION, InfKeyName, buffer);
        }

        IsmReleaseObject (&regContent);
    }

    IsmDestroyObjectHandle (regObject);
}


VOID
pSaveRegSz (
    IN      PCTSTR InfKeyName,
    IN      PCTSTR Key,
    IN      PCTSTR Value
    )
{
    MIG_OBJECTSTRINGHANDLE regObject;
    MIG_CONTENT regContent;

    regObject = IsmCreateObjectHandle (Key, Value);

    if (IsmAcquireObject (g_RegType, regObject, &regContent)) {
        if (!regContent.ContentInFile &&
            regContent.MemoryContent.ContentBytes &&
            regContent.Details.DetailsSize == sizeof (DWORD) &&
            *((PDWORD) regContent.Details.DetailsData) == REG_SZ
            ) {
            IsmSetTransportVariable (
                PLATFORM_SOURCE,
                S_SOURCE_MACHINE_SECTION,
                InfKeyName,
                (PCTSTR) regContent.MemoryContent.ContentBytes
                );
        }

        IsmReleaseObject (&regContent);
    }

    IsmDestroyObjectHandle (regObject);
}


BOOL
WINAPI
ScriptVcmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    TCHAR buffer[256];
    DWORD d;
    PCTSTR domainName;
    PCTSTR userName;

    if (!pInitGlobals (LogCallback)) {
        return FALSE;
    }

    //
    // Save all the basic settings via the transport string interface
    //

    // version
    d = GetVersion();
    wsprintf (buffer, TEXT("0x%08x"), d);
    IsmSetTransportVariable (PLATFORM_SOURCE, S_SOURCE_MACHINE_SECTION, S_VERSION_INFKEY, buffer);

    // code page
    d = (DWORD) GetACP();
    wsprintf (buffer, TEXT("0x%08x"), d);
    IsmSetTransportVariable (PLATFORM_SOURCE, S_SOURCE_MACHINE_SECTION, S_ACP_INFKEY, buffer);

    //
    // MACRO EXPANSION LIST -- generate the code necessary to save the settings
    //                         described in the macro expansion list in v1p.h
    //

#define DEFMAC(infname,key,value)   pSaveRegDword(TEXT(infname),TEXT(key),TEXT(value));

    STANDARD_DWORD_SETTINGS

#undef DEFMAC

#define DEFMAC(infname,key,value)   pSaveRegSz(TEXT(infname),TEXT(key),TEXT(value));

    STANDARD_STRING_SETTINGS

    if (ISWIN9X()) {
        STANDARD_STRING_SETTINGS_9X
    } else {
        STANDARD_STRING_SETTINGS_NT
    }

#undef DEFMAC

    //
    // Save the current user
    //

    if (!pGetDomainUserName (&domainName, &userName)) {
        return FALSE;
    }

    IsmSetTransportVariable (PLATFORM_SOURCE, S_USER_SECTION, S_USER_INFKEY, userName);
    IsmSetEnvironmentString (
        PLATFORM_SOURCE,
        S_SYSENVVAR_GROUP,
        TEXT("USERNAME"),
        userName
        );
    AddStringMappingPair (g_EnvMap, TEXT("%USERNAME%"), userName);

    if (domainName) {
        IsmSetTransportVariable (PLATFORM_SOURCE, S_USER_SECTION, S_DOMAIN_INFKEY, domainName);
        IsmSetEnvironmentString (
            PLATFORM_SOURCE,
            S_SYSENVVAR_GROUP,
            TEXT("USERDOMAIN"),
            domainName
            );
        AddStringMappingPair (g_EnvMap, TEXT("%DOMAINNAME%"), domainName);
    }

    FreeText (userName);
    FreeText (domainName);

    //
    // Parse the script and do the rest of the business
    //

    return pCommonInit (Reserved, TRUE);
}


VOID
WINAPI
ScriptTerminate (
    VOID
    )
{
    HtFree (g_RenameSrcTable);
    g_RenameSrcTable = NULL;

    HtFree (g_RenameDestTable);
    g_RenameDestTable = NULL;

    HtFree (g_DePersistTable);
    g_DePersistTable = NULL;

    TerminateRestoreCallback ();
    TerminateSpecialRename();
    TerminateSpecialConversion();
    TerminateRules();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\sources.inc ===
!include ..\..\modules.mk

MINORCOMP=script

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\entry.c          \
    ..\v1.c             \
    ..\sgminit.c        \
    ..\sgmqueue.c       \
    ..\sgmcallback.c    \
    ..\sgmutil.c        \
    ..\script.rc        \
    ..\dgm.c            \
    ..\csm.c            \
    ..\opm.c            \
    ..\regconv.c        \
    ..\restore.c        \
    ..\rules.c          \
    ..\parse.c          \
    ..\app.c            \
    ..\attrib.c         \
    ..\etm.c            \
    ..\logmsg.mc        \
    ..\renregfn.c       \
    ..\oeutils.c        \

DLLENTRY=_DllMainCRTStartup
LINKER_FLAGS=$(LINKER_FLAGS) -SWAPRUN:CD -SWAPRUN:NET
SUBSYSTEM_VERSION=4.00

# extra libs
TARGETLIBS= $(TARGETLIBS)                           \
            $(COBRA_ROOT)\lib\$(O)\memdb.lib        \
            $(COBRA_ROOT)\lib\$(O)\reg.lib          \
            $(COBRA_ROOT)\lib\$(O)\inf.lib          \
            $(COBRA_ROOT)\bin\$(O)\migism.lib       \
            $(COBRA_ROOT)\lib\$(O)\file.lib         \
            $(COBRA_ROOT)\lib\$(O)\icons.lib        \
            $(COBRA_ROOT)\lib\$(O)\modimage.lib     \
            $(COBRA_ROOT)\lib\$(O)\version.lib      \
            $(SDK_LIB_PATH)\rpcrt4.lib              \
            $(SDK_LIB_PATH)\shlwapi.lib             \

PRECOMPILED_INCLUDE=pch.h

DLLDEF=..\script.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\ansi\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\sgmqueue.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sgmqueue.c

Abstract:

    Parses the v1 script, builds rules and queues enumeration callbacks.

Author:

    Jim Schmidt (jimschm) 12-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v2app.h"
#include "v1p.h"

#define DBG_SCRIPT  "Script"

//
// Strings
//

// None

//
// Constants
//

// none

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

MIG_OPERATIONID g_RenameFileExOp;
MIG_OPERATIONID g_RenameFileOp;
MIG_OPERATIONID g_RenameExOp;
MIG_OPERATIONID g_RenameOp;
BOOL g_VcmMode;
BOOL g_PreParse;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

VCMPARSE ScriptVcmParse;
VCMQUEUEENUMERATION ScriptVcmQueueEnumeration;
SGMPARSE ScriptSgmParse;
SGMQUEUEENUMERATION ScriptSgmQueueEnumeration;

BOOL
pSelectFilesAndFolders (
    VOID
    );

BOOL
pParseAllInfs (
    IN      BOOL PreParse
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pCommonQueueEnumeration (
    IN      BOOL PreParse
    )
{
    MIG_OBJECTSTRINGHANDLE objectHandle;
    ACTION_STRUCT actionStruct;
    BOOL b = FALSE;

    //
    // INF-based inclusion/exclusion mechanism.  We are called first to pre-parse
    // the INF (to allow the UI to alter the results).  Then we are called to
    // queue the enumeration.
    //

    if (PreParse) {
        g_RenameFileExOp = IsmRegisterOperation (S_OPERATION_V1_FILEMOVEEX, TRUE);
        g_RenameFileOp = IsmRegisterOperation (S_OPERATION_V1_FILEMOVE, TRUE);
        g_RenameOp = IsmRegisterOperation (S_OPERATION_MOVE, FALSE);
        g_DefaultIconOp = IsmRegisterOperation (S_OPERATION_DEFICON_FIXCONTENT, FALSE);
        g_DefaultIconData = IsmRegisterProperty (S_V1PROP_ICONDATA, FALSE);
        g_FileCollPatternData = IsmRegisterProperty (S_V1PROP_FILECOLLPATTERN, FALSE);
        g_RenameExOp = IsmRegisterOperation (S_OPERATION_ENHANCED_MOVE, FALSE);
        g_RegAutoFilterOp = IsmRegisterOperation (S_OPERATION_REG_AUTO_FILTER, FALSE);

        return pParseAllInfs (TRUE);
    }

    //
    // Now queue enumeration
    //

    MYASSERT (g_RenameFileExOp);
    MYASSERT (g_RenameFileOp);
    MYASSERT (g_RenameOp);
    MYASSERT (g_RegAutoFilterOp);

    //
    // From the sgm point of view, the v1 tool supports the following:
    //
    // - Optional transfer of the entire HKCU
    // - Optional transfer of the entire HKLM
    // - Optional transfer of all files except for OS files
    // - INF-based inclusion/exclusion mechanism
    // - Specialized migration of certain settings (RAS, printers)
    //
    // This SGM implements this functionality set.
    //

    __try {

        //
        // Component-based inclusion mechanism
        //

        if (!pSelectFilesAndFolders ()) {
            __leave;
        }

        //
        // INF-based inclusion/exclusion mechanism
        //

        if (!pParseAllInfs (FALSE)) {
            __leave;
        }

        //
        // If the /u was specified at the command line we want to suck and apply all HKR
        // like if we had a rule in the script: AddReg=HKR\*
        //
        if (IsmIsEnvironmentFlagSet (IsmGetRealPlatform(), NULL, S_ENV_HKCU_V1)) {

            ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));

            objectHandle = TurnRegStringIntoHandle (TEXT("HKCU\\*"), TRUE, NULL);
            MYASSERT (objectHandle);

            actionStruct.ObjectBase = TurnRegStringIntoHandle (TEXT("HKCU\\*"), FALSE, NULL);
            MYASSERT (actionStruct.ObjectBase);

            //
            // Add this rule
            //

            if (AddRule (
                    g_RegType,
                    actionStruct.ObjectBase,
                    objectHandle,
                    ACTIONGROUP_INCLUDE,
                    ACTION_PERSIST,
                    &actionStruct
                    )) {

                AddRuleEx (
                    g_RegType,
                    actionStruct.ObjectBase,
                    objectHandle,
                    ACTIONGROUP_DEFAULTPRIORITY,
                    ACTION_PRIORITYDEST,
                    NULL,
                    RULEGROUP_PRIORITY
                    );

                IsmHookEnumeration (
                    g_RegType,
                    objectHandle,
                    ObjectPriority,
                    0,
                    NULL
                    );

                //
                // Queue enumeration for include patterns
                //

                IsmQueueEnumeration (
                    g_RegType,
                    objectHandle,
                    g_VcmMode ? GatherVirtualComputer : PrepareActions,
                    0,
                    NULL
                    );
            }
            IsmDestroyObjectHandle (objectHandle);
        }

        b = TRUE;

    }
    __finally {
    }

    return b;
}


VOID
QueueAllFiles (
    VOID
    )
{
    static BOOL done = FALSE;
    MIG_OBJECTSTRINGHANDLE objectHandle;
    MIG_SEGMENTS nodeSeg[2];

    if (done) {
        return;
    }

    done = TRUE;

    nodeSeg[0].Segment = TEXT("*");
    nodeSeg[0].IsPattern = TRUE ;

    objectHandle = IsmCreateObjectPattern (nodeSeg, 1, ALL_PATTERN, 0);

    IsmQueueEnumeration (g_FileType, objectHandle, NulCallback, 0, NULL);
    IsmDestroyObjectHandle (objectHandle);
}


VOID
pQueueAllReg (
    VOID
    )
{
    static BOOL done = FALSE;
    MIG_OBJECTSTRINGHANDLE objectHandle;
    MIG_SEGMENTS nodeSeg[2];
    MIG_PLATFORMTYPEID platform = IsmGetRealPlatform();

    if (done) {
        return;
    }

    done = TRUE;

    //
    // Optional transfer of entire HKCU
    //

    if (IsmIsEnvironmentFlagSet (platform, NULL, S_ENV_HKCU_ON)) {

        nodeSeg[0].Segment = TEXT("HKCU\\");
        nodeSeg[0].IsPattern = FALSE;

        nodeSeg[1].Segment = TEXT("*");
        nodeSeg[1].IsPattern = TRUE;

        objectHandle = IsmCreateObjectPattern (nodeSeg, 2, ALL_PATTERN, 0);
        IsmQueueEnumeration (g_RegType, objectHandle, NulCallback, 0, NULL);
        IsmDestroyObjectHandle (objectHandle);
    }

    //
    // Optional transfer of entire HKLM
    //

    if (IsmIsEnvironmentFlagSet (platform, NULL, S_ENV_HKLM_ON)) {

        nodeSeg[0].Segment = TEXT("HKLM\\");
        nodeSeg[0].IsPattern = FALSE;

        nodeSeg[1].Segment = TEXT("*");
        nodeSeg[1].IsPattern = TRUE;

        objectHandle = IsmCreateObjectPattern (nodeSeg, 2, ALL_PATTERN, 0);
        IsmQueueEnumeration (g_RegType, objectHandle, NulCallback, 0, NULL);
        IsmDestroyObjectHandle (objectHandle);
    }

}


BOOL
WINAPI
ScriptSgmParse (
    IN      PVOID Reserved
    )
{
    return pCommonQueueEnumeration (TRUE);
}


BOOL
WINAPI
ScriptSgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    BOOL result;

    result = pCommonQueueEnumeration (FALSE);
    OEAddComplexRules();

    return result;
}


BOOL
WINAPI
ScriptVcmParse (
    IN      PVOID Reserved
    )
{
    g_VcmMode = TRUE;
    return pCommonQueueEnumeration (TRUE);
}


BOOL
WINAPI
ScriptVcmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    g_VcmMode = TRUE;
    return pCommonQueueEnumeration (FALSE);
}


PCTSTR
pFixDestination (
    IN      PCTSTR Source,
    IN      PCTSTR Destination
    )
{
    PTSTR result = (PTSTR)Source;
    PTSTR tempPtr;
    PTSTR sKey;
    PTSTR sSubKey;
    PTSTR sValueName;
    PTSTR dKey;
    PTSTR dSubKey;
    PTSTR dValueName;
    UINT size;
    BOOL sTree = FALSE;

    sKey = DuplicatePathString (Source, 0);
    sValueName = _tcschr (sKey, TEXT('['));
    if (sValueName) {
        tempPtr = _tcschr (sValueName, TEXT(']'));
        if (tempPtr) {
            *tempPtr = 0;
        }
        tempPtr = sValueName;
        sValueName = _tcsinc (sValueName);
        *tempPtr = 0;
        tempPtr = _tcsdec2 (sKey, tempPtr);
        if (tempPtr) {
            if (_tcsnextc (tempPtr) == TEXT('\\')) {
                *tempPtr = 0;
            }
            if (_tcsnextc (tempPtr) == TEXT(' ')) {
                *tempPtr = 0;
            }
        }
    }
    sSubKey = _tcsrchr (sKey, TEXT('\\'));
    if (sSubKey) {
        tempPtr = _tcsinc (sSubKey);
        if (_tcsnextc (tempPtr) == TEXT('*')) {
            *sSubKey = 0;
            sTree = TRUE;
        }
    }
    sSubKey = _tcsrchr (sKey, TEXT('\\'));
    if (sSubKey) {
        tempPtr = sSubKey;
        sSubKey = _tcsinc (sSubKey);
        *tempPtr = 0;
    }

    dKey = DuplicatePathString (Destination, 0);
    dValueName = _tcschr (dKey, TEXT('['));
    if (dValueName) {
        tempPtr = _tcschr (dValueName, TEXT(']'));
        if (tempPtr) {
            *tempPtr = 0;
        }
        tempPtr = dValueName;
        dValueName = _tcsinc (dValueName);
        *tempPtr = 0;
        tempPtr = _tcsdec2 (dKey, tempPtr);
        if (tempPtr) {
            if (_tcsnextc (tempPtr) == TEXT('\\')) {
                *tempPtr = 0;
            }
            if (_tcsnextc (tempPtr) == TEXT(' ')) {
                *tempPtr = 0;
            }
        }
    }
    dSubKey = _tcsrchr (dKey, TEXT('\\'));
    if (dSubKey) {
        tempPtr = _tcsinc (dSubKey);
        if (_tcsnextc (tempPtr) == TEXT('*')) {
            *dSubKey = 0;
        }
    }
    dSubKey = _tcsrchr (dKey, TEXT('\\'));
    if (dSubKey) {
        tempPtr = dSubKey;
        dSubKey = _tcsinc (dSubKey);
        *tempPtr = 0;
    }
    if (!dSubKey) {
        dSubKey = dKey;
        dKey = NULL;
    }

    size = 0;

    if (dKey && *dKey) {
        size += TcharCount (dKey) + 1;
    } else if (sKey && *sKey) {
        size += TcharCount (sKey) + 1;
    }

    if (dSubKey && *dSubKey) {
        size += TcharCount (dSubKey) + 1;
    } else if (sSubKey && *sSubKey) {
        size += TcharCount (sSubKey) + 1;
    }

    if (dValueName && *dValueName) {
        size += TcharCount (dValueName) + ARRAYSIZE(TEXT(" []")) - 1;
    } else if (sValueName && *sValueName) {
        size += TcharCount (sValueName) + ARRAYSIZE(TEXT(" []")) - 1;
    }

    if (sTree) {
        size += ARRAYSIZE(TEXT("\\*")) - 1;
    }
    size += 1;

    result = AllocPathString (size);
    *result = 0;

    if (dKey && *dKey) {
        StringCat (result, dKey);
    } else if (sKey && *sKey) {
        StringCat (result, sKey);
    }

    if (dSubKey && *dSubKey) {
        StringCat (result, TEXT("\\"));
        StringCat (result, dSubKey);
    } else if (sSubKey && *sSubKey) {
        StringCat (result, TEXT("\\"));
        StringCat (result, sSubKey);
    }

    if (sTree) {
        StringCat (result, TEXT("\\*"));
    }

    if (dValueName && *dValueName) {
        StringCat (result, TEXT(" ["));
        StringCat (result, dValueName);
        StringCat (result, TEXT("]"));
    } else if (sValueName && *sValueName) {
        StringCat (result, TEXT(" ["));
        StringCat (result, sValueName);
        StringCat (result, TEXT("]"));
    }

    if (sKey) {
        FreePathString (sKey);
    }

    if (dKey) {
        FreePathString (dKey);
    } else if (dSubKey) {
        FreePathString (dSubKey);
    }

    return result;
}

BOOL
pParseRegEx1 (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      PCTSTR Application          OPTIONAL
    )
{
    // This function handles RenregEx and RegFileEx rules only

    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PTSTR srcNode;
    PTSTR srcLeaf;
    PTSTR destNode;
    PTSTR destLeaf;
    BOOL result = FALSE;
    MIG_OBJECTSTRINGHANDLE srcPattern = NULL;
    MIG_OBJECTSTRINGHANDLE destPattern = NULL;
    MIG_OBJECTSTRINGHANDLE objectBase = NULL;
    ACTION_STRUCT actionStruct;
    PCTSTR filesDest;
    PCTSTR newDest = NULL;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {
            if (IsmCheckCancel()) {
                break;
            }

            __try {
                ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));

                srcNode = InfGetStringField (&is, 1);
                srcLeaf = InfGetStringField (&is, 2);
                if (!srcNode && !srcLeaf) {
                    LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_RENREGEX));
                    __leave;
                }

                srcPattern = CreatePatternFromNodeLeaf (srcNode, srcLeaf);
                if (!srcPattern) {
                    __leave;
                }

                actionStruct.ObjectBase = srcPattern;

                objectBase = MakeRegExBase (srcNode, srcLeaf);

                destNode = InfGetStringField (&is, 3);
                destLeaf = InfGetStringField (&is, 4);

                destPattern = CreatePatternFromNodeLeaf (destNode, destLeaf);

                if (destPattern) {
                    actionStruct.ObjectDest = destPattern;
                } else {
                    LOG ((
                        LOG_ERROR,
                        (PCSTR) MSG_REG_SPEC_BAD_DEST,
                        srcNode ? srcNode : TEXT(""),
                        srcLeaf ? srcLeaf : TEXT(""),
                        destNode ? destNode : TEXT(""),
                        destLeaf ? destLeaf : TEXT("")
                        ));

                    __leave;
                }

                if (ActionGroup == ACTIONGROUP_REGFILEEX &&
                    ActionFlags & ACTION_PERSIST_PATH_IN_DATA) {

                    filesDest = InfGetStringField (&is, 5);

                    if (filesDest && *filesDest) {
                        newDest = SanitizePath (filesDest);

                        if (newDest) {
                            actionStruct.AddnlDest = TurnFileStringIntoHandle (
                                                            newDest,
                                                            PFF_COMPUTE_BASE|
                                                                PFF_NO_SUBDIR_PATTERN|
                                                                PFF_NO_PATTERNS_ALLOWED|
                                                                PFF_NO_LEAF_AT_ALL
                                                            );
                            FreePathString (newDest);
                            newDest = NULL;
                        }

                        if (!actionStruct.AddnlDest) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD_DEST, filesDest));
                        }
                    }

                    actionStruct.ObjectHint = InfGetStringField (&is, 6);
                    if (actionStruct.ObjectHint && !(*actionStruct.ObjectHint)) {
                        actionStruct.ObjectHint = NULL;
                    }
                }

                if (!AddRule (
                        g_RegType,
                        objectBase,
                        srcPattern,
                        ACTIONGROUP_RENAMEEX,
                        ActionFlags,
                        &actionStruct
                        )) {
                    DEBUGMSG ((DBG_ERROR, "Error processing registry rules"));
                    __leave;
                }
                AddRuleEx (
                    g_RegType,
                    objectBase,
                    srcPattern,
                    ACTIONGROUP_DEFAULTPRIORITY,
                    ACTION_PRIORITYSRC,
                    NULL,
                    RULEGROUP_PRIORITY
                    );

                IsmHookEnumeration (
                    g_RegType,
                    srcPattern,
                    ObjectPriority,
                    0,
                    NULL
                    );


                if (IsmIsObjectHandleLeafOnly (srcPattern)) {
                    pQueueAllReg();
                    IsmHookEnumeration (
                        g_RegType,
                        srcPattern,
                        g_VcmMode ? GatherVirtualComputer : PrepareActions,
                        0,
                        NULL
                        );
                } else {
                    if (actionStruct.ObjectBase) {
                        IsmQueueEnumeration (
                            g_RegType,
                            actionStruct.ObjectBase,
                            g_VcmMode ? GatherVirtualComputer : PrepareActions,
                            0,
                            NULL
                            );
                    }
                    IsmQueueEnumeration (
                        g_RegType,
                        srcPattern,
                        g_VcmMode ? GatherVirtualComputer : PrepareActions,
                        0,
                        NULL
                        );
                }
            }
            __finally {
                if (objectBase) {
                    IsmDestroyObjectHandle (objectBase);
                    objectBase = NULL;
                }

                if (srcPattern) {
                    IsmDestroyObjectHandle (srcPattern);
                    srcPattern = NULL;
                }

                if (destPattern) {
                    IsmDestroyObjectHandle (destPattern);
                    destPattern = NULL;
                }
            }
        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    } else {
        LOG ((LOG_ERROR, (PCSTR) MSG_EMPTY_OR_MISSING_SECTION, Section));
    }

    InfCleanUpInfStruct (&is);

    return result;
}

BOOL
pParseRegEx (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      PCTSTR Application          OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR srcNode;
    PCTSTR srcLeaf;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    PCTSTR destNode;
    PCTSTR destLeaf;
    PCTSTR filesDest;
    PCTSTR newDest = NULL;
    ACTION_STRUCT actionStruct;
    BOOL result = FALSE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {
            if (IsmCheckCancel()) {
                break;
            }

            __try {
                ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));

                srcNode = InfGetStringField (&is, 1);
                srcLeaf = InfGetStringField (&is, 2);
                if (!srcNode && !srcLeaf) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_EMPTY_RENREGEX));
                    __leave;
                }

                // Validate rule
                if (!StringIMatchTcharCount (srcNode, S_HKLM, ARRAYSIZE(S_HKLM) - 1) &&
                    !StringIMatchTcharCount (srcNode, S_HKR, ARRAYSIZE(S_HKR) - 1) &&
                    !StringIMatchTcharCount (srcNode, S_HKCC, ARRAYSIZE(S_HKCC) - 1)
                    ) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_REGROOT, srcNode));
                    __leave;
                }

                srcHandle = CreatePatternFromNodeLeaf (srcNode, srcLeaf);
                if (!srcHandle) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, srcNode));
                    __leave;
                }

                actionStruct.ObjectBase = MakeRegExBase (srcNode, srcLeaf);
                if (!actionStruct.ObjectBase) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, srcNode));
                    __leave;
                }

                if (ActionGroup == ACTIONGROUP_RENAMEEX) {

                    destNode = InfGetStringField (&is, 3);
                    destLeaf = InfGetStringField (&is, 4);
                    if (!destNode && !destLeaf) {
                        LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_MISSING_DEST, srcNode));
                        __leave;
                    }

                    actionStruct.ObjectDest = CreatePatternFromNodeLeaf (destNode, destLeaf);
                    if (!actionStruct.ObjectDest) {
                        LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD_DEST, destNode));
                        __leave;
                    }
                }

                if (ActionGroup == ACTIONGROUP_REGFILEEX ||
                    ActionGroup == ACTIONGROUP_REGFOLDEREX ||
                    ActionGroup == ACTIONGROUP_REGICONEX
                    ) {

                    destNode = InfGetStringField (&is, 3);
                    destLeaf = InfGetStringField (&is, 4);
                    if (destNode && destLeaf &&
                        *destNode && *destLeaf) {
                        actionStruct.ObjectDest = CreatePatternFromNodeLeaf (destNode, destLeaf);
                        if (!actionStruct.ObjectDest) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD_DEST, destNode));
                            __leave;
                        }
                    }
                }

                if ((ActionGroup == ACTIONGROUP_REGFILEEX ||
                     ActionGroup == ACTIONGROUP_REGFOLDEREX ||
                     ActionGroup == ACTIONGROUP_REGICONEX
                     ) &&
                    ((ActionFlags & ACTION_PERSIST_PATH_IN_DATA) ||
                     (ActionFlags & ACTION_PERSIST_ICON_IN_DATA)
                     )
                    ) {

                    filesDest = InfGetStringField (&is, 5);

                    if (filesDest && *filesDest) {

                        newDest = SanitizePath (filesDest);

                        if (newDest) {
                            actionStruct.AddnlDest = TurnFileStringIntoHandle (
                                                            newDest,
                                                            PFF_COMPUTE_BASE|
                                                                PFF_NO_SUBDIR_PATTERN|
                                                                PFF_NO_PATTERNS_ALLOWED|
                                                                PFF_NO_LEAF_AT_ALL
                                                            );
                            FreePathString (newDest);
                            newDest = NULL;
                        }

                        if (!actionStruct.AddnlDest) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD_DEST, filesDest));
                        }
                    }

                    actionStruct.ObjectHint = InfGetStringField (&is, 6);
                    if (actionStruct.ObjectHint && !(*actionStruct.ObjectHint)) {
                        actionStruct.ObjectHint = NULL;
                    }
                }

                //
                // Add this rule
                //

                if (!AddRule (
                        g_RegType,
                        actionStruct.ObjectBase,
                        srcHandle,
                        ActionGroup,
                        ActionFlags,
                        &actionStruct
                        )) {
                    DEBUGMSG ((DBG_ERROR, "Error processing registry rules for %s", srcNode));
                }

                AddRuleEx (
                    g_RegType,
                    actionStruct.ObjectBase,
                    srcHandle,
                    ACTIONGROUP_DEFAULTPRIORITY,
                    ACTION_PRIORITYSRC,
                    NULL,
                    RULEGROUP_PRIORITY
                    );

                IsmHookEnumeration (
                    g_RegType,
                    srcHandle,
                    ObjectPriority,
                    0,
                    NULL
                    );

                //
                // Queue enumeration for include patterns
                //

                if ((ActionGroup == ACTIONGROUP_INCLUDEEX) ||
                    (ActionGroup == ACTIONGROUP_RENAMEEX) ||
                    (ActionGroup == ACTIONGROUP_REGFILEEX) ||
                    (ActionGroup == ACTIONGROUP_REGFOLDEREX) ||
                    (ActionGroup == ACTIONGROUP_REGICONEX)
                    ) {

                    if (IsmIsObjectHandleLeafOnly (srcHandle)) {
                        pQueueAllReg();
                        IsmHookEnumeration (
                            g_RegType,
                            srcHandle,
                            g_VcmMode ? GatherVirtualComputer : PrepareActions,
                            0,
                            NULL
                            );
                    } else {
                        IsmQueueEnumeration (
                            g_RegType,
                            srcHandle,
                            g_VcmMode ? GatherVirtualComputer : PrepareActions,
                            0,
                            NULL
                            );
                    }
                }

                if (ActionGroup == ACTIONGROUP_DELREGKEY) {
                    IsmHookEnumeration (g_RegType, srcHandle, ExcludeKeyIfValueExists, 0, NULL);
                    IsmRegisterTypePostEnumerationCallback (g_RegType, PostDelregKeyCallback, NULL);
                }
            }
            __finally {

                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;

                IsmDestroyObjectHandle (actionStruct.ObjectBase);
                actionStruct.ObjectBase = NULL;

                IsmDestroyObjectHandle (actionStruct.ObjectDest);
                actionStruct.ObjectDest = NULL;

                IsmDestroyObjectHandle (actionStruct.AddnlDest);
                actionStruct.AddnlDest = NULL;
            }

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    } else {
        LOG ((LOG_ERROR, (PCSTR) MSG_EMPTY_OR_MISSING_SECTION, Section));
    }

    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseReg (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      BOOL FixDestination,
    IN      PCTSTR Application          OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR pattern;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    PCTSTR destination;
    PCTSTR newDestination;
    PCTSTR filesDest;
    PCTSTR newDest = NULL;
    ACTION_STRUCT actionStruct;
    BOOL hadLeaf = FALSE;
    BOOL result = FALSE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {
            if (IsmCheckCancel()) {
                break;
            }

            __try {
                ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));
                srcHandle = NULL;

                pattern = InfGetStringField (&is, 0);

                if (!pattern) {
                    pattern = InfGetStringField (&is, 1);
                    if (!pattern) {
                        LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_RENREG));
                        __leave;
                    }
                }

                // Validate rule
                if (!StringIMatchTcharCount (pattern, S_HKLM, ARRAYSIZE(S_HKLM) - 1) &&
                    !StringIMatchTcharCount (pattern, S_HKR, ARRAYSIZE(S_HKR) - 1) &&
                    !StringIMatchTcharCount (pattern, S_HKCC, ARRAYSIZE(S_HKCC) - 1)
                    ) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_REGROOT, pattern));
                    __leave;
                }

                srcHandle = TurnRegStringIntoHandle (pattern, TRUE, &hadLeaf);
                if (!srcHandle) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, pattern));
                    __leave;
                }

                actionStruct.ObjectBase = TurnRegStringIntoHandle (pattern, FALSE, NULL);
                if (!actionStruct.ObjectBase) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, pattern));
                    __leave;
                }

                if (ActionGroup == ACTIONGROUP_RENAME) {

                    destination = InfGetStringField (&is, 1);

                    if (destination && *destination) {

                        if (FixDestination) {
                            newDestination = pFixDestination (pattern, destination);
                        } else {
                            newDestination = destination;
                        }

                        actionStruct.ObjectDest = TurnRegStringIntoHandle (newDestination, FALSE, NULL);

                        if (newDestination != destination) {
                            FreePathString (newDestination);
                        }

                        if (!actionStruct.ObjectDest) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD_DEST, destination));
                            __leave;
                        }

                    } else {
                        LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_MISSING_DEST, pattern));
                        __leave;
                    }
                }

                if (ActionGroup == ACTIONGROUP_REGFILE ||
                    ActionGroup == ACTIONGROUP_REGFOLDER ||
                    ActionGroup == ACTIONGROUP_REGICON
                    ) {

                    destination = InfGetStringField (&is, 1);

                    if (destination && *destination) {

                        if (FixDestination) {
                            newDestination = pFixDestination (pattern, destination);
                        } else {
                            newDestination = destination;
                        }

                        actionStruct.ObjectDest = TurnRegStringIntoHandle (newDestination, FALSE, NULL);

                        if (newDestination != destination) {
                            FreePathString (newDestination);
                        }

                        if (!actionStruct.ObjectDest) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD_DEST, destination));
                            __leave;
                        }
                    }
                }

                if ((ActionGroup == ACTIONGROUP_REGFILE ||
                     ActionGroup == ACTIONGROUP_REGFOLDER ||
                     ActionGroup == ACTIONGROUP_REGICON
                     ) &&
                    ((ActionFlags & ACTION_PERSIST_PATH_IN_DATA) ||
                     (ActionFlags & ACTION_PERSIST_ICON_IN_DATA)
                     )
                    ) {

                    filesDest = InfGetStringField (&is, 2);

                    if (filesDest && *filesDest) {

                        newDest = SanitizePath (filesDest);

                        if (newDest) {
                            actionStruct.AddnlDest = TurnFileStringIntoHandle (
                                                            newDest,
                                                            PFF_COMPUTE_BASE|
                                                                PFF_NO_SUBDIR_PATTERN|
                                                                PFF_NO_PATTERNS_ALLOWED|
                                                                PFF_NO_LEAF_AT_ALL
                                                            );
                            FreePathString (newDest);
                            newDest = NULL;
                        }

                        if (!actionStruct.AddnlDest) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD_DEST, filesDest));
                        }
                    }

                    actionStruct.ObjectHint = InfGetStringField (&is, 3);
                    if (actionStruct.ObjectHint && !(*actionStruct.ObjectHint)) {
                        actionStruct.ObjectHint = NULL;
                    }
                }

                //
                // Add this rule
                //

                if (!AddRule (
                        g_RegType,
                        actionStruct.ObjectBase,
                        srcHandle,
                        ActionGroup,
                        ActionFlags,
                        &actionStruct
                        )) {
                    DEBUGMSG ((DBG_ERROR, "Error processing registry rules for %s", pattern));
                }

                AddRuleEx (
                    g_RegType,
                    actionStruct.ObjectBase,
                    srcHandle,
                    ACTIONGROUP_DEFAULTPRIORITY,
                    ACTION_PRIORITYSRC,
                    NULL,
                    RULEGROUP_PRIORITY
                    );

                IsmHookEnumeration (
                    g_RegType,
                    srcHandle,
                    ObjectPriority,
                    0,
                    NULL
                    );

                //
                // Queue enumeration for include patterns
                //

                if ((ActionGroup == ACTIONGROUP_INCLUDE) ||
                    (ActionGroup == ACTIONGROUP_RENAME) ||
                    (ActionGroup == ACTIONGROUP_REGFILE) ||
                    (ActionGroup == ACTIONGROUP_REGFOLDER) ||
                    (ActionGroup == ACTIONGROUP_REGICON)
                    ) {

                    if (IsmIsObjectHandleLeafOnly (srcHandle)) {
                        pQueueAllReg();
                        IsmHookEnumeration (
                            g_RegType,
                            srcHandle,
                            g_VcmMode ? GatherVirtualComputer : PrepareActions,
                            0,
                            NULL
                            );
                    } else {
                        if ((!hadLeaf) && actionStruct.ObjectBase) {
                            IsmQueueEnumeration (
                                g_RegType,
                                actionStruct.ObjectBase,
                                g_VcmMode ? GatherVirtualComputer : PrepareActions,
                                0,
                                NULL
                                );
                        }
                        IsmQueueEnumeration (
                            g_RegType,
                            srcHandle,
                            g_VcmMode ? GatherVirtualComputer : PrepareActions,
                            0,
                            NULL
                            );
                    }
                }

                if (ActionGroup == ACTIONGROUP_DELREGKEY) {
                    IsmHookEnumeration (g_RegType, srcHandle, ExcludeKeyIfValueExists, 0, NULL);
                    IsmRegisterTypePostEnumerationCallback (g_RegType, PostDelregKeyCallback, NULL);
                }
            }
            __finally {

                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;

                IsmDestroyObjectHandle (actionStruct.ObjectBase);
                actionStruct.ObjectBase = NULL;

                IsmDestroyObjectHandle (actionStruct.ObjectDest);
                actionStruct.ObjectDest = NULL;

                IsmDestroyObjectHandle (actionStruct.AddnlDest);
                actionStruct.AddnlDest = NULL;
            }

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    } else {
        LOG ((LOG_ERROR, (PCSTR) MSG_EMPTY_OR_MISSING_SECTION, Section));
    }

    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseFiles (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      PCTSTR Application              OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR pattern;
    PCTSTR newPattern = NULL;
    PCTSTR dirText;
    BOOL tree;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    PCTSTR destination;
    PCTSTR leafDest;
    TCHAR buffer1[MAX_TCHAR_PATH * 2];
    ACTION_STRUCT actionStruct;
    BOOL result = FALSE;
    PCTSTR msgNode;
    PCTSTR msgLeaf;
    PCTSTR newDest = NULL;
    BOOL expandResult = TRUE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {

            if (IsmCheckCancel()) {
                break;
            }

            ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));

            dirText = InfGetStringField (&is, 0);
            pattern = InfGetStringField (&is, 1);

            if (!pattern) {
                continue;
            }

            //
            // Expand environment variables in pattern (the left-side file spec)
            //

            expandResult = AppSearchAndReplace (
                                PLATFORM_SOURCE,
                                Application,
                                pattern,
                                buffer1,
                                ARRAYSIZE(buffer1)
                                );

            if (!expandResult) {
                // the line contains at least one unexpandable env. variables
                expandResult = AppCheckAndLogUndefVariables (
                                    PLATFORM_SOURCE,
                                    Application,
                                    pattern
                                    );
                if (expandResult) {
                    // the line contains known but undefined env. variables
                    continue;
                }
            }

            //
            // Fix the pattern
            //

            newPattern = SanitizePath(buffer1);
            if(!newPattern) {
                continue;
            }

            //
            // Test for dir specification
            //

            if (dirText && StringIMatch (dirText, TEXT("Dir")) && !StringIMatch (pattern, TEXT("Dir"))) {
                tree = TRUE;
            } else {
                tree = FALSE;
            }

            // require full spec or leaf only
            if (!IsValidFileSpec (newPattern) && _tcschr (newPattern, TEXT('\\'))) {
                if (expandResult) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, pattern));
                }
                continue;
            }

            srcHandle = TurnFileStringIntoHandle (newPattern, tree ? PFF_PATTERN_IS_DIR : 0);

            if (!srcHandle) {
                LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, pattern));
                continue;
            }

            actionStruct.ObjectBase = TurnFileStringIntoHandle (
                                            newPattern,
                                            PFF_COMPUTE_BASE|
                                                PFF_NO_SUBDIR_PATTERN|
                                                (tree?PFF_NO_LEAF_AT_ALL:PFF_NO_LEAF_PATTERN)
                                            );

            if (actionStruct.ObjectBase && !StringIMatch (actionStruct.ObjectBase, srcHandle)) {

                IsmCreateObjectStringsFromHandle (actionStruct.ObjectBase, &msgNode, &msgLeaf);
                MYASSERT (!msgLeaf);

                LOG ((LOG_INFORMATION, (PCSTR) MSG_FILE_MOVE_BASE_INFO, newPattern, msgNode));

                IsmDestroyObjectString (msgNode);
                IsmDestroyObjectString (msgLeaf);
            }

            if (ActionFlags & ACTION_PERSIST) {
                if (ActionGroup == ACTIONGROUP_INCLUDE ||
                    ActionGroup == ACTIONGROUP_INCLUDEEX ||
                    ActionGroup == ACTIONGROUP_RENAME ||
                    ActionGroup == ACTIONGROUP_RENAMEEX ||
                    ActionGroup == ACTIONGROUP_INCLUDERELEVANT ||
                    ActionGroup == ACTIONGROUP_INCLUDERELEVANTEX ||
                    ActionGroup == ACTIONGROUP_RENAMERELEVANT ||
                    ActionGroup == ACTIONGROUP_RENAMERELEVANTEX
                    ) {

                    //
                    // For the CopyFiles and CopyFilesFiltered sections, get the
                    // optional destination. If destination is specified, move
                    // all of the files into that destination.
                    //

                    destination = InfGetStringField (&is, 2);

                    if (destination && *destination) {

                        if (ActionGroup == ACTIONGROUP_INCLUDE) {
                            ActionGroup = ACTIONGROUP_RENAME;
                        }

                        if (ActionGroup == ACTIONGROUP_INCLUDEEX) {
                            ActionGroup = ACTIONGROUP_RENAMEEX;
                        }

                        if (ActionGroup == ACTIONGROUP_INCLUDERELEVANT) {
                            ActionGroup = ACTIONGROUP_RENAMERELEVANT;
                        }

                        if (ActionGroup == ACTIONGROUP_INCLUDERELEVANTEX) {
                            ActionGroup = ACTIONGROUP_RENAMERELEVANTEX;
                        }

                        newDest = SanitizePath (destination);

                        if (newDest) {
                            actionStruct.ObjectDest = TurnFileStringIntoHandle (
                                                            newDest,
                                                            PFF_COMPUTE_BASE|
                                                                PFF_NO_SUBDIR_PATTERN|
                                                                PFF_NO_PATTERNS_ALLOWED|
                                                                PFF_NO_LEAF_AT_ALL
                                                            );
                            FreePathString (newDest);
                            newDest = NULL;
                        }

                        if ((ActionGroup == ACTIONGROUP_RENAMEEX) ||
                            (ActionGroup == ACTIONGROUP_RENAMERELEVANTEX)
                            ) {
                            // we might have an extra field for the leaf name
                            leafDest = InfGetStringField (&is, 3);
                            if (leafDest && *leafDest) {
                                // we have to rebuild actionStruct.ObjectDest
                                IsmCreateObjectStringsFromHandle (actionStruct.ObjectDest, &msgNode, &msgLeaf);
                                IsmDestroyObjectHandle (actionStruct.ObjectDest);
                                actionStruct.ObjectDest = IsmCreateObjectHandle (msgNode, leafDest);
                                IsmDestroyObjectString (msgNode);
                                IsmDestroyObjectString (msgLeaf);
                            }
                        }

                        if (!actionStruct.ObjectDest) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD_DEST, destination));

                            IsmDestroyObjectHandle (srcHandle);
                            srcHandle = NULL;
                            continue;
                        }
                    }
                }
            }

            //
            // Add this rule
            //

            if (!AddRule (
                    g_FileType,
                    actionStruct.ObjectBase,
                    srcHandle,
                    ActionGroup,
                    ActionFlags,
                    &actionStruct
                    )) {
                DEBUGMSG ((DBG_ERROR, "Error processing file rules"));
                break;
            }

            //
            // Queue enumeration for include patterns
            //

            if ((ActionGroup == ACTIONGROUP_INCLUDE) ||
                (ActionGroup == ACTIONGROUP_INCLUDEEX) ||
                (ActionGroup == ACTIONGROUP_RENAME) ||
                (ActionGroup == ACTIONGROUP_RENAMEEX) ||
                (ActionGroup == ACTIONGROUP_INCLUDERELEVANT) ||
                (ActionGroup == ACTIONGROUP_INCLUDERELEVANTEX) ||
                (ActionGroup == ACTIONGROUP_RENAMERELEVANT) ||
                (ActionGroup == ACTIONGROUP_RENAMERELEVANTEX)
                ) {

                //
                // Queue the enumeration callback
                //

                if (IsmIsObjectHandleLeafOnly (srcHandle)) {

                    DEBUGMSG ((DBG_SCRIPT, "Pattern %s triggered enumeration of entire file system", pattern));

                    QueueAllFiles();
                    IsmHookEnumeration (
                        g_FileType,
                        srcHandle,
                        g_VcmMode ? GatherVirtualComputer : PrepareActions,
                        0,
                        NULL
                        );
                } else {
                    if (tree && actionStruct.ObjectBase) {
                        IsmQueueEnumeration (
                            g_FileType,
                            actionStruct.ObjectBase,
                            g_VcmMode ? GatherVirtualComputer : PrepareActions,
                            0,
                            NULL
                            );
                    }
                    IsmQueueEnumeration (
                        g_FileType,
                        srcHandle,
                        g_VcmMode ? GatherVirtualComputer : PrepareActions,
                        0,
                        NULL
                        );
                }
            }

            IsmDestroyObjectHandle (srcHandle);
            srcHandle = NULL;

            IsmDestroyObjectHandle (actionStruct.ObjectBase);
            actionStruct.ObjectBase = NULL;

            IsmDestroyObjectHandle (actionStruct.ObjectDest);
            actionStruct.ObjectDest = NULL;

            FreePathString(newPattern);

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    }

    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseLockPartition (
    IN      HINF Inf,
    IN      PCTSTR Section
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR pattern;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    BOOL result = FALSE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {
            if (IsmCheckCancel()) {
                break;
            }

            pattern = InfGetStringField (&is, 0);
            if (!pattern) {
                LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_FILE_SPEC));
                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;
                continue;
            }

            srcHandle = TurnFileStringIntoHandle (pattern, 0);
            if (!srcHandle) {
                LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, pattern));
                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;
                continue;
            }

            IsmHookEnumeration (
                g_FileType,
                srcHandle,
                LockPartition,
                0,
                NULL
                );

            IsmDestroyObjectHandle (srcHandle);
            srcHandle = NULL;

        } while (InfFindNextLine (&is));
        result = !IsmCheckCancel();
    }
    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseRegPriority (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      DWORD ActionFlags,
    IN      PCTSTR Application,             OPTIONAL
    IN      BOOL ExtendedPattern
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR pattern = NULL;
    PCTSTR patternLeaf = NULL;
    PCTSTR baseNode = NULL;
    PCTSTR nodeCopy = NULL;
    PTSTR ptr;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    MIG_OBJECTSTRINGHANDLE baseHandle = NULL;
    BOOL result = FALSE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {

            if (IsmCheckCancel()) {
                break;
            }

            pattern = InfGetStringField (&is, 1);

            if (!pattern) {
                LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_RENREG));
                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;
                continue;
            }

            if (ExtendedPattern) {
                patternLeaf = InfGetStringField (&is, 2);
            }

            if (ExtendedPattern) {
                srcHandle = CreatePatternFromNodeLeaf (pattern, patternLeaf?patternLeaf:TEXT("*"));
            } else {
                srcHandle = TurnRegStringIntoHandle (pattern, TRUE, NULL);
            }
            if (!srcHandle) {
                LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, pattern));
                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;
                continue;
            }

            if (ExtendedPattern) {
                ptr = _tcschr (pattern, TEXT('\\'));
                if (ptr) {
                    if (StringIPrefix (pattern, TEXT("HKR\\"))) {
                        nodeCopy = JoinText (TEXT("HKCU"), ptr);
                    } else {
                        nodeCopy = DuplicateText (pattern);
                    }
                    baseNode = GetPatternBase (nodeCopy);
                    if (baseNode) {
                        baseHandle = IsmCreateObjectHandle (baseNode, NULL);
                        FreePathString (baseNode);
                    }
                    FreeText (nodeCopy);
                }
            } else {
                baseHandle = TurnRegStringIntoHandle (pattern, FALSE, NULL);
            }

            AddRuleEx (
                g_RegType,
                baseHandle,
                srcHandle,
                ACTIONGROUP_SPECIFICPRIORITY,
                ActionFlags,
                NULL,
                RULEGROUP_PRIORITY
                );

            IsmHookEnumeration (
                g_RegType,
                srcHandle,
                ObjectPriority,
                0,
                NULL
                );

            IsmDestroyObjectHandle (baseHandle);
            IsmDestroyObjectHandle (srcHandle);
            srcHandle = NULL;

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    }

    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseFilePriority (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      DWORD ActionFlags,
    IN      PCTSTR Application              OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR newPattern = NULL;
    PCTSTR pattern;
    PCTSTR dirText;
    BOOL tree;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    MIG_OBJECTSTRINGHANDLE baseHandle = NULL;
    TCHAR buffer1[MAX_TCHAR_PATH * 2];
    BOOL result = FALSE;
    BOOL expandResult = TRUE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {

            if (IsmCheckCancel()) {
                break;
            }

            dirText = InfGetStringField (&is, 0);
            pattern = InfGetStringField (&is, 1);

            if (!pattern) {
                continue;
            }

            //
            // Expand environment variables in pattern (the left-side file spec)
            //

            expandResult = AppSearchAndReplace (
                                PLATFORM_SOURCE,
                                Application,
                                pattern,
                                buffer1,
                                ARRAYSIZE(buffer1)
                                );

            if (!expandResult) {
                // the line contains at least one unexpandable env. variables
                expandResult = AppCheckAndLogUndefVariables (
                                    PLATFORM_SOURCE,
                                    Application,
                                    pattern
                                    );
                if (expandResult) {
                    // the line contains known but undefined env. variables
                    continue;
                }
            }

            //
            // Fix the pattern
            //

            newPattern = SanitizePath(buffer1);
            if(!newPattern) {
                continue;
            }

            //
            // Test for dir specification
            //

            if (dirText && StringIMatch (dirText, TEXT("Dir"))) {
                tree = TRUE;
            } else {
                tree = FALSE;
            }

            // require full spec
            if (!IsValidFileSpec (newPattern)) {
                if (expandResult) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, pattern));
                }
                FreePathString (newPattern);
                newPattern = NULL;
                continue;
            }

            srcHandle = TurnFileStringIntoHandle (newPattern, tree ? PFF_PATTERN_IS_DIR : 0);

            if (!srcHandle) {
                LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, pattern));
                FreePathString (newPattern);
                newPattern = NULL;
                continue;
            }

            baseHandle = TurnFileStringIntoHandle (
                            newPattern,
                            PFF_COMPUTE_BASE|
                            PFF_NO_SUBDIR_PATTERN|
                            (tree?PFF_NO_LEAF_AT_ALL:PFF_NO_LEAF_PATTERN)
                            );

            AddRuleEx (
                g_FileType,
                baseHandle,
                srcHandle,
                ACTIONGROUP_SPECIFICPRIORITY,
                ActionFlags,
                NULL,
                RULEGROUP_PRIORITY
                );

            IsmHookEnumeration (
                g_FileType,
                srcHandle,
                ObjectPriority,
                0,
                NULL
                );

            IsmDestroyObjectHandle (baseHandle);
            IsmDestroyObjectHandle (srcHandle);
            srcHandle = NULL;

            FreePathString (newPattern);
            newPattern = NULL;

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    }

    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseFileCollisionPattern (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      PCTSTR Application              OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR pattern;
    PCTSTR newPattern = NULL;
    PCTSTR dirText;
    BOOL tree;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    PCTSTR collPattern;
    TCHAR buffer1[MAX_TCHAR_PATH * 2];
    ACTION_STRUCT actionStruct;
    BOOL result = FALSE;
    PCTSTR msgNode;
    PCTSTR msgLeaf;
    BOOL expandResult = TRUE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {

            if (IsmCheckCancel()) {
                break;
            }

            ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));

            dirText = InfGetStringField (&is, 0);
            pattern = InfGetStringField (&is, 1);

            if (!pattern) {
                continue;
            }

            //
            // Expand environment variables in pattern (the left-side file spec)
            //

            expandResult = AppSearchAndReplace (
                                PLATFORM_SOURCE,
                                Application,
                                pattern,
                                buffer1,
                                ARRAYSIZE(buffer1)
                                );

            if (!expandResult) {
                // the line contains at least one unexpandable env. variables
                expandResult = AppCheckAndLogUndefVariables (
                                    PLATFORM_SOURCE,
                                    Application,
                                    pattern
                                    );
                if (expandResult) {
                    // the line contains known but undefined env. variables
                    continue;
                }
            }

            //
            // Fix the pattern
            //

            newPattern = SanitizePath(buffer1);
            if(!newPattern) {
                continue;
            }

            //
            // Test for dir specification
            //

            if (dirText && StringIMatch (dirText, TEXT("Dir")) && !StringIMatch (pattern, TEXT("Dir"))) {
                tree = TRUE;
            } else {
                tree = FALSE;
            }

            // require full spec or leaf only
            if (!IsValidFileSpec (newPattern) && _tcschr (newPattern, TEXT('\\'))) {
                if (expandResult) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, pattern));
                }
                continue;
            }

            srcHandle = TurnFileStringIntoHandle (newPattern, tree ? PFF_PATTERN_IS_DIR : 0);

            if (!srcHandle) {
                LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, pattern));
                continue;
            }

            actionStruct.ObjectBase = TurnFileStringIntoHandle (
                                            newPattern,
                                            PFF_COMPUTE_BASE|
                                                PFF_NO_SUBDIR_PATTERN|
                                                (tree?PFF_NO_LEAF_AT_ALL:PFF_NO_LEAF_PATTERN)
                                            );

            collPattern = InfGetStringField (&is, 2);

            if ((!collPattern) || (!(*collPattern))) {
                // we have no collision pattern, let's get out
                continue;
            }

            actionStruct.ObjectHint = IsmDuplicateString (collPattern);

            //
            // Add this rule
            //

            if (!AddRuleEx (
                    g_FileType,
                    actionStruct.ObjectBase,
                    srcHandle,
                    ACTIONGROUP_FILECOLLPATTERN,
                    0,
                    &actionStruct,
                    RULEGROUP_COLLPATTERN
                    )) {
                DEBUGMSG ((DBG_ERROR, "Error processing file rules"));
                break;
            }

            //
            // Queue the enumeration callback
            //

            if (IsmIsObjectHandleLeafOnly (srcHandle)) {

                DEBUGMSG ((DBG_SCRIPT, "Pattern %s triggered enumeration of entire file system", pattern));

                IsmHookEnumeration (
                    g_FileType,
                    srcHandle,
                    FileCollPattern,
                    0,
                    NULL
                    );
            } else {
                if (tree && actionStruct.ObjectBase) {
                    IsmHookEnumeration (
                        g_FileType,
                        actionStruct.ObjectBase,
                        FileCollPattern,
                        0,
                        NULL
                        );
                }
                IsmHookEnumeration (
                    g_FileType,
                    srcHandle,
                    FileCollPattern,
                    0,
                    NULL
                    );
            }

            IsmDestroyObjectHandle (srcHandle);
            srcHandle = NULL;

            IsmDestroyObjectHandle (actionStruct.ObjectBase);
            actionStruct.ObjectBase = NULL;

            IsmReleaseMemory (actionStruct.ObjectHint);
            actionStruct.ObjectHint = NULL;

            FreePathString(newPattern);

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    }

    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseOneInstruction (
    IN      HINF InfHandle,
    IN      PCTSTR Type,
    IN      PCTSTR SectionMultiSz,
    IN      PINFSTRUCT InfStruct,
    IN      PCTSTR Application          OPTIONAL
    )
{
    ACTIONGROUP actionGroup;
    DWORD actionFlags;
    MULTISZ_ENUM e;
    BOOL result = TRUE;
    MIG_PLATFORMTYPEID platform = IsmGetRealPlatform();

    //
    // First thing: look for nested sections
    //
    if (StringIMatch (Type, TEXT("ProcessSection"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {
            do {
                result = result & ParseOneApplication (
                                    PLATFORM_SOURCE,
                                    InfHandle,
                                    Application,
                                    FALSE,
                                    0,
                                    e.CurrentString,
                                    NULL,
                                    NULL,
                                    NULL
                                    );
            } while (EnumNextMultiSz (&e));
        }
        return result;
    }

    //
    // Parse registry sections
    //

    actionGroup = ACTIONGROUP_NONE;
    actionFlags = 0;

    if (StringIMatch (Type, TEXT("AddReg"))) {
        actionGroup = ACTIONGROUP_INCLUDE;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("RenReg"))) {
        actionGroup = ACTIONGROUP_RENAME;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("DelReg"))) {
        actionGroup = ACTIONGROUP_EXCLUDE;
        actionFlags = 0;
    } else if (StringIMatch (Type, TEXT("RegFile"))) {
        actionGroup = ACTIONGROUP_REGFILE;
        actionFlags = ACTION_PERSIST_PATH_IN_DATA;
    } else if (StringIMatch (Type, TEXT("RegFolder"))) {
        actionGroup = ACTIONGROUP_REGFOLDER;
        actionFlags = ACTION_PERSIST_PATH_IN_DATA;
    } else if (StringIMatch (Type, TEXT("RegIcon"))) {
        actionGroup = ACTIONGROUP_REGICON;
        actionFlags = ACTION_PERSIST_ICON_IN_DATA;
    } else if (StringIMatch (Type, TEXT("DelRegKey"))) {
        actionGroup = ACTIONGROUP_DELREGKEY;
        actionFlags = 0;
    }

    if (actionGroup != ACTIONGROUP_NONE) {

        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseReg (
                        InfHandle,
                        e.CurrentString,
                        actionGroup,
                        actionFlags,
                        TRUE,
                        Application
                        )) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse file sections
    //

    if (StringIMatch (Type, TEXT("CopyFilesFiltered"))) {
        actionGroup = ACTIONGROUP_INCLUDERELEVANT;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("CopyFilesFilteredEx"))) {
        actionGroup = ACTIONGROUP_INCLUDERELEVANTEX;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("CopyFiles"))) {
        actionGroup = ACTIONGROUP_INCLUDE;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("CopyFilesEx"))) {
        actionGroup = ACTIONGROUP_INCLUDEEX;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("DelFiles"))) {
        actionGroup = ACTIONGROUP_EXCLUDE;
        actionFlags = 0;
    }

    if (actionGroup != ACTIONGROUP_NONE) {

        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (IsmIsEnvironmentFlagSet (platform, NULL, S_ENV_ALL_FILES)) {
                    if (!pParseFiles (
                            InfHandle,
                            e.CurrentString,
                            actionGroup,
                            actionFlags,
                            Application
                            )) {
                        result = FALSE;
                        if (InfStruct) {
                            InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                        }
                        break;
                    }
                } else {
                    LOG ((
                        LOG_INFORMATION,
                        (PCSTR) MSG_IGNORING_FILE_SECTION,
                        e.CurrentString
                        ));
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse registry priority
    //

    if (StringIMatch (Type, TEXT("ForceDestRegEx"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseRegPriority (InfHandle, e.CurrentString, ACTION_PRIORITYDEST, Application, TRUE)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }
    if (StringIMatch (Type, TEXT("ForceDestReg"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseRegPriority (InfHandle, e.CurrentString, ACTION_PRIORITYDEST, Application, FALSE)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }
    if (StringIMatch (Type, TEXT("ForceSrcRegEx"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseRegPriority (InfHandle, e.CurrentString, ACTION_PRIORITYSRC, Application, TRUE)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }
    if (StringIMatch (Type, TEXT("ForceSrcReg"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseRegPriority (InfHandle, e.CurrentString, ACTION_PRIORITYSRC, Application, FALSE)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse file collision rules (default is %s(%d).%s)
    //
    if (StringIMatch (Type, TEXT("FileCollisionPattern"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseFileCollisionPattern (InfHandle, e.CurrentString, Application)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse restore callback rule
    //

    if (StringIMatch (Type, TEXT("RestoreCallback"))) {
        if (!g_VcmMode) {
            if (EnumFirstMultiSz (&e, SectionMultiSz)) {

                do {
                    IsmAppendEnvironmentString (PLATFORM_SOURCE, NULL, S_ENV_DEST_RESTORE, e.CurrentString);
                } while (EnumNextMultiSz (&e));
            }
        }

        return result;
    }

    //
    // Parse destination rule
    //

    if (StringIMatch (Type, TEXT("DestDelReg"))) {
        if (!g_VcmMode) {
            if (EnumFirstMultiSz (&e, SectionMultiSz)) {

                do {
                    IsmAppendEnvironmentString (PLATFORM_SOURCE, NULL, S_ENV_DEST_DELREG, e.CurrentString);
                } while (EnumNextMultiSz (&e));
            }
        }

        return result;
    }

    if (StringIMatch (Type, TEXT("DestDelRegEx"))) {
        if (!g_VcmMode) {
            if (EnumFirstMultiSz (&e, SectionMultiSz)) {

                do {
                    IsmAppendEnvironmentString (PLATFORM_SOURCE, NULL, S_ENV_DEST_DELREGEX, e.CurrentString);
                } while (EnumNextMultiSz (&e));
            }
        }

        return result;
    }

    //
    // Parse destination detect rules
    //

    if (StringIMatch (Type, TEXT("DestCheckDetect"))) {
        if (!g_VcmMode) {
            if (EnumFirstMultiSz (&e, SectionMultiSz)) {

                do {
                    IsmAppendEnvironmentString (PLATFORM_SOURCE, NULL, S_ENV_DEST_CHECKDETECT, e.CurrentString);
                } while (EnumNextMultiSz (&e));
            }
        }

        return result;
    }

    //
    // Parse destination AddObject rule
    //

    if (StringIMatch (Type, TEXT("DestAddObject"))) {
        if (!g_VcmMode) {
            if (EnumFirstMultiSz (&e, SectionMultiSz)) {

                do {
                    IsmAppendEnvironmentString (PLATFORM_SOURCE, NULL, S_ENV_DEST_ADDOBJECT, e.CurrentString);
                } while (EnumNextMultiSz (&e));
            }
        }

        return result;
    }

    //
    // Parse execute rule
    //

    if (StringIMatch (Type, TEXT("Execute"))) {
        if (!g_VcmMode) {
            if (EnumFirstMultiSz (&e, SectionMultiSz)) {

                do {
                    IsmAppendEnvironmentString (PLATFORM_SOURCE, NULL, S_ENV_SCRIPT_EXECUTE, e.CurrentString);
                } while (EnumNextMultiSz (&e));
            }
        }

        return result;
    }

    //
    // Parse file priority
    //

    if (StringIMatch (Type, TEXT("ForceDestFile"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (IsmIsEnvironmentFlagSet (platform, NULL, S_ENV_ALL_FILES)) {
                    if (!pParseFilePriority (InfHandle, e.CurrentString, ACTION_PRIORITYDEST, Application)) {
                        result = FALSE;
                        if (InfStruct) {
                            InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                        }
                        break;
                    }
                } else {
                    LOG ((
                        LOG_INFORMATION,
                        (PCSTR) MSG_IGNORING_FILE_SECTION,
                        e.CurrentString
                        ));
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }
    if (StringIMatch (Type, TEXT("ForceSrcFile"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (IsmIsEnvironmentFlagSet (platform, NULL, S_ENV_ALL_FILES)) {
                    if (!pParseFilePriority (InfHandle, e.CurrentString, ACTION_PRIORITYSRC, Application)) {
                        result = FALSE;
                        if (InfStruct) {
                            InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                        }
                        break;

                    }
                } else {
                    LOG ((
                        LOG_INFORMATION,
                        (PCSTR) MSG_IGNORING_FILE_SECTION,
                        e.CurrentString
                        ));
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse special conversion
    //

    if (StringIMatch (Type, TEXT("Conversion"))) {

        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!DoRegistrySpecialConversion (InfHandle, e.CurrentString)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    if (StringIMatch (Type, TEXT("RenRegFn"))) {

        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!DoRegistrySpecialRename (InfHandle, e.CurrentString)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse enhanced renreg
    //

    actionGroup = ACTIONGROUP_NONE;
    actionFlags = 0;

    if (StringIMatch (Type, TEXT("AddRegEx"))) {
        actionGroup = ACTIONGROUP_INCLUDEEX;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("RenRegEx"))) {
        actionGroup = ACTIONGROUP_RENAMEEX;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("DelRegEx"))) {
        actionGroup = ACTIONGROUP_EXCLUDEEX;
        actionFlags = 0;
    } else if (StringIMatch (Type, TEXT("RegFileEx"))) {
        actionGroup = ACTIONGROUP_REGFILEEX;
        actionFlags = ACTION_PERSIST_PATH_IN_DATA;
    } else if (StringIMatch (Type, TEXT("RegFolderEx"))) {
        actionGroup = ACTIONGROUP_REGFOLDEREX;
        actionFlags = ACTION_PERSIST_PATH_IN_DATA;
    } else if (StringIMatch (Type, TEXT("RegIconEx"))) {
        actionGroup = ACTIONGROUP_REGICONEX;
        actionFlags = ACTION_PERSIST_ICON_IN_DATA;
    }

    if (actionGroup != ACTIONGROUP_NONE) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {
            do {
                if (!pParseRegEx (InfHandle, e.CurrentString, actionGroup, actionFlags, Application)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }
            } while (EnumNextMultiSz (&e));
        }
        return result;
    }

    if (StringIMatch (Type, TEXT("LockPartition"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {
            do {
                if (!pParseLockPartition (InfHandle, e.CurrentString)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }
            } while (EnumNextMultiSz (&e));
        }
        return result;
    }

    //
    // Unknown section type
    //

    LOG ((LOG_ERROR, (PCSTR) MSG_UNEXPECTED_SECTION_TYPE, Type));

    if (InfStruct) {
        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
    }

    return FALSE;
}


BOOL
pParseInfInstructionsWorker (
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfHandle,
    IN      PCTSTR Application,     OPTIONAL
    IN      PCTSTR Section
    )
{
    PCTSTR type;
    PCTSTR sections;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    BOOL result = TRUE;

    if (InfFindFirstLine (InfHandle, Section, NULL, InfStruct)) {
        do {

            if (IsmCheckCancel()) {
                result = FALSE;
                break;
            }

            InfResetInfStruct (InfStruct);

            type = InfGetStringField (InfStruct, 0);
            sections = InfGetMultiSzField (InfStruct, 1);

            if (!type || !sections) {
                LOG ((LOG_WARNING, (PCSTR) MSG_BAD_INF_LINE, Section));
                InfLogContext (LOG_WARNING, InfHandle, InfStruct);
                continue;
            }

            result = pParseOneInstruction (InfHandle, type, sections, InfStruct, Application);

        } while (result && InfFindNextLine (InfStruct));
    }

    InfCleanUpInfStruct (InfStruct);

    GbFree (&multiSz);

    return result;
}


BOOL
ParseInfInstructions (
    IN      HINF InfHandle,
    IN      PCTSTR Application,     OPTIONAL
    IN      PCTSTR Section
    )
{
    PCTSTR osSpecificSection;
    BOOL b;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PTSTR instrSection;

    b = pParseInfInstructionsWorker (&is, InfHandle, Application, Section);

    if (b) {
        osSpecificSection = GetMostSpecificSection (&is, InfHandle, Section);

        if (osSpecificSection) {
            b = pParseInfInstructionsWorker (&is, InfHandle, Application, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    InfCleanUpInfStruct (&is);

    return b;
}


BOOL
pParseInf (
    IN      HINF InfHandle,
    IN      BOOL PreParse
    )
{
    BOOL result = TRUE;

    if (InfHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Process the application sections
    //

    if (!ParseApplications (PLATFORM_SOURCE, InfHandle, TEXT("Applications"), PreParse, MASTERGROUP_APP)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_APP_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    //
    // Process system settings
    //

    if (!ParseApplications (PLATFORM_SOURCE, InfHandle, TEXT("System Settings"), PreParse, MASTERGROUP_SYSTEM)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_SYSTEM_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    //
    // Process user settings
    //

    if (!ParseApplications (PLATFORM_SOURCE, InfHandle, TEXT("User Settings"), PreParse, MASTERGROUP_USER)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_USER_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    //
    // Process files and folders settings
    //

    if (!ProcessFilesAndFolders (InfHandle, TEXT("Files and Folders"), PreParse)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_FNF_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    //
    // Process the administrator script sections
    //

    if (!ParseApplications (PLATFORM_SOURCE, InfHandle, TEXT("Administrator Scripts"), PreParse, MASTERGROUP_SCRIPT)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_SCRIPT_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    return TRUE;
}


BOOL
pAddFileSpec (
    IN      PCTSTR Node,                OPTIONAL
    IN      PCTSTR Leaf,                OPTIONAL
    IN      BOOL IncludeSubDirs,
    IN      BOOL LeafIsPattern,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      BOOL DefaultPriority,
    IN      BOOL SrcPriority
    )
{
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    MIG_OBJECTSTRINGHANDLE srcBaseHandle = NULL;
    BOOL result = FALSE;
    ACTION_STRUCT actionStruct;

    __try {
        //
        // Build object string
        //

        MYASSERT (Node || Leaf);

        srcHandle = IsmCreateSimpleObjectPattern (Node, IncludeSubDirs, Leaf, LeafIsPattern);

        if (!srcHandle) {
            __leave;
        }

        if (Node) {
            srcBaseHandle = IsmCreateObjectHandle (Node, NULL);
        }

        //
        // Add this rule
        //

        ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));
        actionStruct.ObjectBase = srcBaseHandle;

        if (!AddRule (
                g_FileType,
                actionStruct.ObjectBase,
                srcHandle,
                ActionGroup,
                ActionFlags,
                &actionStruct
                )) {
            __leave;
        }

        if (!DefaultPriority) {

            AddRuleEx (
                g_FileType,
                actionStruct.ObjectBase,
                srcHandle,
                ACTIONGROUP_SPECIFICPRIORITY,
                SrcPriority?ACTION_PRIORITYSRC:ACTION_PRIORITYDEST,
                NULL,
                RULEGROUP_PRIORITY
                );

            IsmHookEnumeration (
                g_RegType,
                srcHandle,
                ObjectPriority,
                0,
                NULL
                );
        }

        //
        // Queue enumeration for include patterns
        //

        if (ActionGroup == ACTIONGROUP_INCLUDE) {

            if (IsmIsObjectHandleLeafOnly (srcHandle)) {

                DEBUGMSG ((
                    DBG_SCRIPT,
                    "File node %s leaf %s triggered enumeration of entire file system",
                    Node,
                    Leaf
                    ));

                QueueAllFiles();
                IsmHookEnumeration (
                    g_FileType,
                    srcHandle,
                    g_VcmMode ? GatherVirtualComputer : PrepareActions,
                    0,
                    NULL
                    );
            } else {
                IsmQueueEnumeration (
                    g_FileType,
                    srcHandle,
                    g_VcmMode ? GatherVirtualComputer : PrepareActions,
                    0,
                    NULL
                    );
            }
        }

        result = TRUE;
    }
    __finally {
        IsmDestroyObjectHandle (srcHandle);
        INVALID_POINTER (srcHandle);

        IsmDestroyObjectHandle (srcBaseHandle);
        INVALID_POINTER (srcBaseHandle);
    }

    return result;
}


BOOL
pParseFilesAndFolders (
    IN      UINT Group,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      BOOL HasNode,
    IN      BOOL HasLeaf,
    IN      BOOL HasPriority
    )
{
    MIG_COMPONENT_ENUM e;
    BOOL result = FALSE;
    PCTSTR node;
    PCTSTR leaf;
    PTSTR copyOfData = NULL;
    PTSTR p;
    BOOL defaultPriority = TRUE;
    BOOL srcPriority = FALSE;

    __try {
        //
        // Enumerate all the components
        //

        if (IsmEnumFirstComponent (&e, COMPONENTENUM_ENABLED|COMPONENTENUM_ALIASES, Group)) {
            do {
                //
                // Parse string into node/leaf format
                //

                if (e.MasterGroup != MASTERGROUP_FILES_AND_FOLDERS) {
                    continue;
                }

                copyOfData = DuplicateText (e.LocalizedAlias);

                node = copyOfData;
                leaf = NULL;

                if (HasNode && HasLeaf) {
                    p = (PTSTR) FindLastWack (copyOfData);
                    if (p) {
                        leaf = _tcsinc (p);
                        *p = 0;
                    }
                } else if (!HasNode) {
                    node = NULL;
                    leaf = JoinText (TEXT("*."), copyOfData);
                }

                //
                // Add rule
                //

                if (!pAddFileSpec (
                        node,
                        leaf,
                        (HasNode && (!HasLeaf)),
                        (HasNode && (!HasLeaf)) || (!HasNode),
                        ActionGroup,
                        ActionFlags,
                        defaultPriority,
                        srcPriority
                        )) {
                    IsmAbortComponentEnum (&e);
                    __leave;
                }

                if (!HasNode) {
                    FreeText (leaf);
                }

                FreeText (copyOfData);
                copyOfData = NULL;

            } while (IsmEnumNextComponent (&e));
        }

        result = TRUE;
    }
    __finally {
        FreeText (copyOfData);

        if (!result) {
            IsmAbortComponentEnum (&e);
        }
    }

    return result;
}


BOOL
pSelectFilesAndFolders (
    VOID
    )
{
    if (!pParseFilesAndFolders (
            COMPONENT_EXTENSION,
            ACTIONGROUP_INCLUDE,
            ACTION_PERSIST,
            FALSE,
            TRUE,
            TRUE
            )) {
        return FALSE;
    }

    if (!pParseFilesAndFolders (
            COMPONENT_FOLDER,
            ACTIONGROUP_INCLUDE,
            ACTION_PERSIST,
            TRUE,
            FALSE,
            TRUE
            )) {
        return FALSE;
    }

    if (!pParseFilesAndFolders (
            COMPONENT_FILE,
            ACTIONGROUP_INCLUDE,
            ACTION_PERSIST,
            TRUE,
            TRUE,
            TRUE
            )) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pParseAllInfs (
    IN      BOOL PreParse
    )
{
    PTSTR multiSz = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_TYPE dataType;
    BOOL result = FALSE;

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {

        if (pParseInf (infHandle, PreParse)) {
            result = TRUE;
        }

        InfNameHandle (infHandle, NULL, FALSE);

    } else {

        if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, NULL, 0, &sizeNeeded, NULL)) {
            return TRUE;        // no INF files specified
        }

        __try {
            multiSz = AllocText (sizeNeeded);
            if (!multiSz) {
                __leave;
            }

            if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, (PBYTE) multiSz, sizeNeeded, NULL, NULL)) {
                __leave;
            }

            if (EnumFirstMultiSz (&e, multiSz)) {

                do {

                    infHandle = InfOpenInfFile (e.CurrentString);
                    if (infHandle != INVALID_HANDLE_VALUE) {
                        if (!pParseInf (infHandle, PreParse)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            __leave;
                        }
                    } else {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_INF, e.CurrentString));
                    }
                    InfCloseInfFile (infHandle);
                    infHandle = INVALID_HANDLE_VALUE;
                } while (EnumNextMultiSz (&e));

            }

            result = TRUE;
        }
        __finally {
            if (multiSz) {
                FreeText (multiSz);
                multiSz = NULL;
            }
        }
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\unicode\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\v1p.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    v1p.h

Abstract:

    Header file for shared types, macros, etc., common to all v1 source files.

Author:

    Jim Schmidt (jimschm) 14-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "logmsg.h"

//
// Strings
//

#define S_SOURCE_MACHINE_SECTION    TEXT("Source Machine")
#define S_VERSION_INFKEY            TEXT("version")
#define S_ACP_INFKEY                TEXT("acp")
#define S_USER_SECTION              TEXT("User")
#define S_USER_INFKEY               TEXT("User")
#define S_DOMAIN_INFKEY             TEXT("Domain")

#define S_HKCU                      TEXT("HKCU")
#define S_HKCC                      TEXT("HKCC")
#define S_HKLM                      TEXT("HKLM")
#define S_HKR                       TEXT("HKR")

#define S_V1PROP_ICONDATA           TEXT("V1.PROP.ICONDATA")
#define S_V1PROP_FILECOLLPATTERN    TEXT("V1.PROP.FILECOLLPATTERN")

#define S_OE_COMPONENT              TEXT("$Outlook Express")
#define S_OUTLOOK9798_COMPONENT     TEXT("$Microsoft Outlook 97 & 98")
#define S_OFFICE_COMPONENT          TEXT("$Microsoft Office")
#define S_OE4_APPDETECT             TEXT("Outlook Express.OutlookExpress4")
#define S_OE5_APPDETECT             TEXT("Outlook Express.OutlookExpress5")
#define S_OUTLOOK9798_APPDETECT     TEXT("Microsoft Outlook 97 & 98.Outlook98.97")
#define S_OFFICE9798_APPDETECT      TEXT("Microsoft Office.Microsoft Office 97")


//
// Constants
//

#define ACTION_PERSIST                  0x0001
#define ACTION_PERSIST_PATH_IN_DATA     0x0002
#define ACTION_PERSIST_ICON_IN_DATA     0x0004

#define ACTION_PRIORITYSRC              0x0001
#define ACTION_PRIORITYDEST             0x0002

typedef enum {
    ACTIONGROUP_NONE = 0,
    ACTIONGROUP_DEFAULTPRIORITY,
    ACTIONGROUP_SPECIFICPRIORITY,
    ACTIONGROUP_FILECOLLPATTERN,
    ACTIONGROUP_EXCLUDE,
    ACTIONGROUP_EXCLUDEEX,
    ACTIONGROUP_INCLUDE,
    ACTIONGROUP_INCLUDEEX,
    ACTIONGROUP_RENAME,
    ACTIONGROUP_RENAMEEX,
    ACTIONGROUP_INCLUDERELEVANT,
    ACTIONGROUP_INCLUDERELEVANTEX,
    ACTIONGROUP_RENAMERELEVANT,
    ACTIONGROUP_RENAMERELEVANTEX,
    ACTIONGROUP_REGFILE,
    ACTIONGROUP_REGFILEEX,
    ACTIONGROUP_REGFOLDER,
    ACTIONGROUP_REGFOLDEREX,
    ACTIONGROUP_REGICON,
    ACTIONGROUP_REGICONEX,
    ACTIONGROUP_DELREGKEY,
} ACTIONGROUP, *PACTIONGROUP;

#define ACTIONWEIGHT_EXCLUDE            0x00000001
#define ACTIONWEIGHT_EXCLUDEEX          0x00000002
#define ACTIONWEIGHT_DELREGKEY          0x00000003
#define ACTIONWEIGHT_INCLUDE            0x00000004
#define ACTIONWEIGHT_INCLUDEEX          0x00000005
#define ACTIONWEIGHT_RENAME             0x00000006
#define ACTIONWEIGHT_RENAMEEX           0x00000007
#define ACTIONWEIGHT_INCLUDERELEVANT    0x00000008
#define ACTIONWEIGHT_INCLUDERELEVANTEX  0x00000009
#define ACTIONWEIGHT_RENAMERELEVANT     0x0000000A
#define ACTIONWEIGHT_RENAMERELEVANTEX   0x0000000B
#define ACTIONWEIGHT_REGFILE            0x0000000C
#define ACTIONWEIGHT_REGFILEEX          0x0000000D
#define ACTIONWEIGHT_REGFOLDER          0x0000000E
#define ACTIONWEIGHT_REGFOLDEREX        0x0000000F
#define ACTIONWEIGHT_REGICON            0x00000010
#define ACTIONWEIGHT_REGICONEX          0x00000011

#define ACTIONWEIGHT_DEFAULTPRIORITY    0x00000001
#define ACTIONWEIGHT_SPECIFICPRIORITY   0x10000000

#define ACTIONWEIGHT_FILECOLLPATTERN    0x00000000

typedef enum {
    RULEGROUP_NORMAL = 0,
    RULEGROUP_PRIORITY,
    RULEGROUP_COLLPATTERN
} RULEGROUP;


#define PFF_NO_PATTERNS_ALLOWED             0x0001
#define PFF_COMPUTE_BASE                    0x0002
#define PFF_NO_SUBDIR_PATTERN               0x0004
#define PFF_NO_LEAF_PATTERN                 0x0008
#define PFF_PATTERN_IS_DIR                  0x0010

#define PFF_NO_LEAF_AT_ALL                  (PFF_NO_LEAF_PATTERN|PFF_PATTERN_IS_DIR)

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PMAPSTRUCT AppEnvMapSrc;
    PMAPSTRUCT AppEnvMapDest;
    PMAPSTRUCT UndefEnvMapSrc;
    PMAPSTRUCT UndefEnvMapDest;
} APP_SPECIFIC_DATA, *PAPP_SPECIFIC_DATA;

typedef struct {
    MIG_OBJECTSTRINGHANDLE ObjectBase;
    MIG_OBJECTSTRINGHANDLE ObjectDest;
    MIG_OBJECTSTRINGHANDLE AddnlDest;
    PCTSTR ObjectHint;
    PAPP_SPECIFIC_DATA AppSpecificData;
} ACTION_STRUCT, *PACTION_STRUCT;

typedef struct {
    MIG_PLATFORMTYPEID Platform;
    PCTSTR ScriptSpecifiedType;
    PCTSTR ScriptSpecifiedObject;
    PCTSTR ApplicationName;

    PCTSTR ReturnString;
    union {
        struct _TAG_ISM_OBJECT {
            MIG_OBJECTTYPEID ObjectTypeId;
            MIG_OBJECTSTRINGHANDLE ObjectName;
            PMIG_CONTENT ObjectContent;
        };

        struct _TAG_OBJECT {
            UINT DataSize;
            PCBYTE Data;
        };
    };
} ATTRIB_DATA, *PATTRIB_DATA;

ETMINITIALIZE ScriptEtmInitialize;
ETMPARSE ScriptEtmParse;
ETMTERMINATE ScriptEtmTerminate;

VCMINITIALIZE ScriptVcmInitialize;
VCMPARSE ScriptVcmParse;
VCMQUEUEENUMERATION ScriptVcmQueueEnumeration;
VCMTERMINATE ScriptTerminate;

SGMINITIALIZE ScriptSgmInitialize;
SGMPARSE ScriptSgmParse;
SGMQUEUEENUMERATION ScriptSgmQueueEnumeration;

DGMINITIALIZE ScriptDgmInitialize;
DGMQUEUEENUMERATION ScriptDgmQueueEnumeration;
CSMINITIALIZE ScriptCsmInitialize;
CSMTERMINATE ScriptCsmTerminate;
CSMEXECUTE ScriptCsmExecute;
OPMINITIALIZE ScriptOpmInitialize;
OPMTERMINATE ScriptOpmTerminate;

//
// Globals
//

extern PMAPSTRUCT g_EnvMap;
extern PMAPSTRUCT g_UndefMap;
extern PMAPSTRUCT g_RevEnvMap;
extern HASHTABLE g_RenameSrcTable;
extern HASHTABLE g_RenameDestTable;
extern HASHTABLE g_DePersistTable;
extern PMHANDLE g_V1Pool;
extern MIG_OBJECTTYPEID g_FileType;
extern MIG_OBJECTTYPEID g_RegType;
extern MIG_OPERATIONID g_RenameOp;
extern MIG_OPERATIONID g_RenameFileExOp;
extern MIG_OPERATIONID g_RenameFileOp;
extern MIG_OPERATIONID g_DeleteOp;
extern MIG_OPERATIONID g_RenameExOp;
extern MIG_ATTRIBUTEID g_OsFileAttribute;
extern MIG_ATTRIBUTEID g_CopyIfRelevantAttr;
extern MIG_ATTRIBUTEID g_LockPartitionAttr;
extern MIG_PROPERTYID g_DefaultIconData;
extern MIG_PROPERTYID g_FileCollPatternData;
extern MIG_OPERATIONID g_DefaultIconOp;
extern MIG_OPERATIONID g_DestAddObject;
extern MIG_OPERATIONID g_RegAutoFilterOp;
extern BOOL g_PreParse;
extern PMAPSTRUCT g_DestEnvMap;
extern PMAPSTRUCT g_FileNodeFilterMap;
extern BOOL g_OERulesMigrated;
extern GROWLIST g_SectionStack;

//
// Macro expansion lists
//

#define STANDARD_DWORD_SETTINGS                     \


#define STANDARD_STRING_SETTINGS                    \
    DEFMAC("timezone", "hklm\\System\\CurrentControlSet\\Control\\TimeZoneInformation", "StandardName") \
    DEFMAC("locale", "hklm\\System\\CurrentControlSet\\Control\\Nls\\Locale", "")                       \

#define STANDARD_STRING_SETTINGS_9X                 \
    DEFMAC("fullname", "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion", "RegisteredOwner")         \
    DEFMAC("orgname", "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion", "RegisteredOrganization")   \

#define STANDARD_STRING_SETTINGS_NT                 \
    DEFMAC("fullname", "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", "RegisteredOwner")      \
    DEFMAC("orgname", "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", "RegisteredOrganization")\


//
// Public function prototypes
//

MIG_OBJECTSTRINGHANDLE
MakeRegExBase (
    IN      PCTSTR Node,
    IN      PCTSTR Leaf
    );

MIG_OBJECTSTRINGHANDLE
CreatePatternFromNodeLeaf (
    IN      PCTSTR Node,
    IN      PCTSTR Leaf
    );

MIG_OBJECTSTRINGHANDLE
TurnRegStringIntoHandle (
    IN      PCTSTR String,
    IN      BOOL Pattern,
    OUT     PBOOL HadLeaf           OPTIONAL
    );

MIG_OBJECTSTRINGHANDLE
TurnFileStringIntoHandle (
    IN      PCTSTR String,
    IN      DWORD Flags
    );

BOOL
AllocScriptType (
    IN OUT      PATTRIB_DATA AttribData     CALLER_INITIALIZED
    );

BOOL
FreeScriptType (
    IN          PATTRIB_DATA AttribData     ZEROED
    );

VOID
InitSpecialConversion (
    IN      MIG_PLATFORMTYPEID Platform
    );

VOID
TerminateSpecialConversion (
    VOID
    );

VOID
InitSpecialRename (
    IN      MIG_PLATFORMTYPEID Platform
    );

VOID
TerminateSpecialRename (
    VOID
    );

VOID
InitRules (
    VOID
    );

VOID
TerminateRules (
    VOID
    );

BOOL
AddRuleEx (
    IN      MIG_OBJECTTYPEID Type,
    IN      MIG_OBJECTSTRINGHANDLE ObjectBase,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      PACTION_STRUCT ActionStruct,    OPTIONAL
    IN      RULEGROUP RuleGroup
    );

#define AddRule(t,b,p,g,f,s) AddRuleEx(t,b,p,g,f,s,RULEGROUP_NORMAL)

BOOL
QueryRuleEx (
    IN      MIG_OBJECTTYPEID Type,
    IN      MIG_OBJECTSTRINGHANDLE EncodedString,
    IN      PCTSTR ObjectNode,
    OUT     PACTIONGROUP ActionGroup,
    OUT     PDWORD ActionFlags,
    OUT     PACTION_STRUCT ActionStruct,    OPTIONAL
    IN      RULEGROUP RuleGroup
    );

#define QueryRule(t,e,n,g,f,s) QueryRuleEx(t,e,n,g,f,s,RULEGROUP_NORMAL)


//
// renregfn.c
//

BOOL
DoRegistrySpecialConversion (
    IN      HINF InfHandle,
    IN      PCTSTR Section
    );

BOOL
DoRegistrySpecialRename (
    IN      HINF InfHandle,
    IN      PCTSTR Section
    );

BOOL
AddSpecialRenameRule (
    IN      PCTSTR Pattern,
    IN      PCTSTR Function
);

//
// sgmutils.c
//

PCTSTR
GetShellFolderPath (
    IN      INT Folder,
    IN      PCTSTR FolderStr,
    IN      BOOL UserFolder,
    OUT     PTSTR Buffer
    );

PCTSTR
GetAllUsersProfilePath (
    OUT     PTSTR Buffer
    );

PCTSTR
GetUserProfileRootPath (
    OUT     PTSTR Buffer
    );

PCTSTR
IsValidUncPath (
    IN      PCTSTR Path
    );

BOOL
IsValidFileSpec (
    IN      PCTSTR FileSpec
    );

VOID
QueueAllFiles (
    VOID
    );

VOID
AddRemappingEnvVar (
    IN      PMAPSTRUCT Map,
    IN      PMAPSTRUCT ReMap,
    IN      PMAPSTRUCT UndefMap,            OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableData
    );

VOID
SetIsmEnvironmentFromPhysicalMachine (
    IN      PMAPSTRUCT Map,
    IN      BOOL MapDestToSource,
    IN      PMAPSTRUCT UndefMap             OPTIONAL
    );

VOID
SetIsmEnvironmentFromVirtualMachine (
    IN      PMAPSTRUCT DirectMap,
    IN      PMAPSTRUCT ReverseMap,
    IN      PMAPSTRUCT UndefMap
    );

//
// app.c
//

PCTSTR
GetMostSpecificSection (
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfFile,
    IN      PCTSTR BaseSection
    );

VOID
InitAppModule (
    VOID
    );

VOID
TerminateAppModule (
    VOID
    );

PAPP_SPECIFIC_DATA
FindAppSpecificData (
    IN      PCTSTR AppTag
    );

BOOL
AppCheckAndLogUndefVariables (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Application,
    IN      PCTSTR UnexpandedString
    );

BOOL
AppSearchAndReplace (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Application,
    IN      PCTSTR UnexpandedString,
    OUT     PTSTR ExpandedString,
    IN      UINT ExpandedStringTchars
    );

BOOL
ParseOneApplication (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      BOOL PreParse,
    IN      UINT MasterGroup,
    IN      PCTSTR Application,
    IN      PCTSTR LocSection,
    IN      PCTSTR AliasType,
    IN      PCTSTR MultiSz
    );

BOOL
ParseApplications (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      BOOL PreParse,
    IN      UINT MasterGroup
    );

BOOL
ProcessFilesAndFolders (
    IN      HINF InfHandle,
    IN      PCTSTR Section,
    IN      BOOL PreParse
    );

BOOL
ParseAppDetectSection (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF InfFile,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    );

//
// sgmcallback.c
//

MIG_OBJECTENUMCALLBACK GatherVirtualComputer;
MIG_OBJECTENUMCALLBACK PrepareActions;
MIG_OBJECTENUMCALLBACK NulCallback;
MIG_OBJECTENUMCALLBACK ObjectPriority;
MIG_OBJECTENUMCALLBACK FileCollPattern;
MIG_OBJECTENUMCALLBACK ExcludeKeyIfValueExists;
MIG_OBJECTENUMCALLBACK LockPartition;
MIG_POSTENUMCALLBACK PostDelregKeyCallback;

//
// sgmqueue.c
//

BOOL
ParseInfInstructions (
    IN      HINF InfHandle,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    );

BOOL
ParseTranslationSection (
    IN      HINF InfHandle,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    );

//
// attrib.c
//

BOOL
TestAttributes (
    IN      PMHANDLE WorkPool,
    IN      PCTSTR ArgumentMultiSz,
    IN      PATTRIB_DATA AttribData
    );

//
// opm.c
//
BOOL
WINAPI
FilterRenameExFilter (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    );

//
// regconv.c
//
BOOL
DoesDestRegExist (
    IN      MIG_OBJECTSTRINGHANDLE DestName,
    IN      DWORD RegType
    );

BOOL
IsValidRegSz (
    IN      PCMIG_CONTENT CurrentContent
    );

BOOL
IsValidRegType (
    IN      PCMIG_CONTENT CurrentContent,
    IN      DWORD RegType
    );

BOOL
CreateDwordRegObject (
    IN      PCTSTR KeyStr,
    IN      PCTSTR ValueName,
    IN      DWORD Value
    );

// oeutils.c

VOID
OETerminate (
    VOID
    );

BOOL
OEIsIdentityAssociated (
    IN      PTSTR IdStr
    );

BOOL
OEIAMAssociateId (
    IN      PTSTR SrcId
    );

PTSTR
OEGetRemappedId (
    IN      PCTSTR IdStr
    );

PTSTR
OEGetAssociatedId (
    IN      MIG_PLATFORMTYPEID Platform
    );

PTSTR
OEGetDefaultId (
    IN      MIG_PLATFORMTYPEID Platform
    );

VOID
WABMerge (
    VOID
    );

VOID
OE5MergeStoreFolders (
    VOID
    );

VOID
OE4MergeStoreFolder (
    VOID
    );

BOOL
OE5RemapDefaultId (
    VOID
    );

BOOL
OEAddComplexRules (
    VOID
    );

PTSTR
OECreateFirstIdentity (
    VOID
    );

BOOL
OEInitializeIdentity (
    VOID
    );

BOOL
OEFixLastUser (
    VOID
    );


//
// restore.c
//
BOOL
InitRestoreCallback (
    IN      MIG_PLATFORMTYPEID Platform
    );

VOID
TerminateRestoreCallback (
    VOID
    );

//
// Macro expansion definition
//

// None

//
// ANSI/UNICODE macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\v1.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    v1.c

Abstract:

    Implements a module to meet the functionality of the version 1
    state save/apply tool.

Author:

    Jim Schmidt (jimschm) 12-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

MIG_OPERATIONID g_DefaultIconOp;
MIG_PROPERTYID g_DefaultIconData;
MIG_PROPERTYID g_FileCollPatternData;
MIG_OPERATIONID g_RegAutoFilterOp;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

EXPORT
BOOL
WINAPI
ModuleInitialize (
    VOID
    )
{
    UtInitialize (NULL);
    RegInitialize ();           // for user profile code
    FileEnumInitialize ();
    InfGlobalInit (FALSE);
    InitAppModule ();
    return TRUE;
}

EXPORT
VOID
WINAPI
ModuleTerminate (
    VOID
    )
{
    if (g_RevEnvMap) {
        DestroyStringMapping (g_RevEnvMap);
    }
    if (g_EnvMap) {
        DestroyStringMapping (g_EnvMap);
    }
    if (g_UndefMap) {
        DestroyStringMapping (g_UndefMap);
    }
    if (g_V1Pool) {
        PmDestroyPool (g_V1Pool);
    }

    TerminateAppModule ();

    InfGlobalInit (TRUE);
    FileEnumTerminate ();
    RegTerminate ();

    // UtTerminate must be last
    UtTerminate ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\sgmutil.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sgmutil.c

Abstract:

    Implements basic utilities used for source data gathering.

Author:

    Jim Schmidt (jimschm) 14-May-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_FOO     "Foo"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

#define USER_SHELL_FOLDERS                                       \
    DEFMAC(CSIDL_APPDATA, TEXT("AppData"), TEXT("CSIDL_APPDATA"))                       \
    DEFMAC(CSIDL_APPDATA, TEXT("AppData"), TEXT("APPDATA"))                             \
    DEFMAC(CSIDL_ADMINTOOLS, TEXT("Administrative Tools"), TEXT("CSIDL_ADMINTOOLS"))    \
    DEFMAC(CSIDL_ALTSTARTUP, TEXT("AltStartup"), TEXT("CSIDL_ALTSTARTUP"))              \
    DEFMAC(CSIDL_BITBUCKET, TEXT("RecycleBinFolder"), TEXT("CSIDL_BITBUCKET"))          \
    DEFMAC(CSIDL_CONTROLS, TEXT("ControlPanelFolder"), TEXT("CSIDL_CONTROLS"))          \
    DEFMAC(CSIDL_COOKIES, TEXT("Cookies"), TEXT("CSIDL_COOKIES"))                       \
    DEFMAC(CSIDL_DESKTOP, TEXT("Desktop"), TEXT("CSIDL_DESKTOP"))                       \
    DEFMAC(CSIDL_DESKTOPDIRECTORY, TEXT("Desktop"), TEXT("CSIDL_DESKTOPDIRECTORY"))     \
    DEFMAC(CSIDL_DRIVES, TEXT("DriveFolder"), TEXT("CSIDL_DRIVES"))                     \
    DEFMAC(CSIDL_FAVORITES, TEXT("Favorites"), TEXT("CSIDL_FAVORITES"))                 \
    DEFMAC(CSIDL_FONTS, TEXT("Fonts"), TEXT("CSIDL_FONTS"))                             \
    DEFMAC(CSIDL_HISTORY, TEXT("History"), TEXT("CSIDL_HISTORY"))                       \
    DEFMAC(CSIDL_INTERNET, TEXT("InternetFolder"), TEXT("CSIDL_INTERNET"))              \
    DEFMAC(CSIDL_INTERNET_CACHE, TEXT("Cache"), TEXT("CSIDL_INTERNET_CACHE"))           \
    DEFMAC(CSIDL_LOCAL_APPDATA, TEXT("Local AppData"), TEXT("CSIDL_LOCAL_APPDATA"))     \
    DEFMAC(CSIDL_MYPICTURES, TEXT("My Pictures"), TEXT("CSIDL_MYPICTURES"))             \
    DEFMAC(CSIDL_NETHOOD, TEXT("NetHood"), TEXT("CSIDL_NETHOOD"))                       \
    DEFMAC(CSIDL_NETWORK, TEXT("NetworkFolder"), TEXT("CSIDL_NETWORK"))                 \
    DEFMAC(CSIDL_PERSONAL, TEXT("Personal"), TEXT("CSIDL_PERSONAL"))                    \
    DEFMAC(CSIDL_PROFILE, TEXT("Profile"), TEXT("CSIDL_PROFILE"))                       \
    DEFMAC(CSIDL_PROGRAM_FILES, TEXT("ProgramFiles"), TEXT("CSIDL_PROGRAM_FILES"))      \
    DEFMAC(CSIDL_PROGRAM_FILES, TEXT("ProgramFiles"), TEXT("PROGRAMFILES"))             \
    DEFMAC(CSIDL_PROGRAM_FILES_COMMON, TEXT("CommonProgramFiles"), TEXT("CSIDL_PROGRAM_FILES_COMMON"))  \
    DEFMAC(CSIDL_PROGRAM_FILES_COMMON, TEXT("CommonProgramFiles"), TEXT("COMMONPROGRAMFILES"))  \
    DEFMAC(CSIDL_PROGRAMS, TEXT("Programs"), TEXT("CSIDL_PROGRAMS"))                    \
    DEFMAC(CSIDL_RECENT, TEXT("Recent"), TEXT("CSIDL_RECENT"))                          \
    DEFMAC(CSIDL_SENDTO, TEXT("SendTo"), TEXT("CSIDL_SENDTO"))                          \
    DEFMAC(CSIDL_STARTMENU, TEXT("Start Menu"), TEXT("CSIDL_STARTMENU"))                \
    DEFMAC(CSIDL_STARTUP, TEXT("Startup"), TEXT("CSIDL_STARTUP"))                       \
    DEFMAC(CSIDL_SYSTEM, TEXT("System"), TEXT("CSIDL_SYSTEM"))                          \
    DEFMAC(CSIDL_TEMPLATES, TEXT("Templates"), TEXT("CSIDL_TEMPLATES"))                 \
    DEFMAC(CSIDL_WINDOWS, TEXT("Windows"), TEXT("CSIDL_WINDOWS"))                       \
    DEFMAC(CSIDL_MYDOCUMENTS, TEXT("My Documents"), TEXT("CSIDL_MYDOCUMENTS"))          \
    DEFMAC(CSIDL_MYMUSIC, TEXT("My Music"), TEXT("CSIDL_MYMUSIC"))                      \
    DEFMAC(CSIDL_MYVIDEO, TEXT("My Video"), TEXT("CSIDL_MYVIDEO"))                      \
    DEFMAC(CSIDL_SYSTEMX86, TEXT("SystemX86"), TEXT("CSIDL_SYSTEMX86"))                 \
    DEFMAC(CSIDL_PROGRAM_FILESX86, TEXT("ProgramFilesX86"), TEXT("CSIDL_PROGRAM_FILESX86"))             \
    DEFMAC(CSIDL_PROGRAM_FILES_COMMONX86, TEXT("CommonProgramFilesX86"), TEXT("CSIDL_PROGRAM_FILES_COMMONX86")) \
    DEFMAC(CSIDL_CONNECTIONS, TEXT("ConnectionsFolder"), TEXT("CSIDL_CONNECTIONS"))     \

#define COMMON_SHELL_FOLDERS    \
    DEFMAC(CSIDL_COMMON_ADMINTOOLS, TEXT("Common Administrative Tools"), TEXT("CSIDL_COMMON_ADMINTOOLS"))   \
    DEFMAC(CSIDL_COMMON_ALTSTARTUP, TEXT("Common AltStartup"), TEXT("CSIDL_COMMON_ALTSTARTUP"))             \
    DEFMAC(CSIDL_COMMON_APPDATA, TEXT("Common AppData"), TEXT("CSIDL_COMMON_APPDATA"))                      \
    DEFMAC(CSIDL_COMMON_DESKTOPDIRECTORY, TEXT("Common Desktop"), TEXT("CSIDL_COMMON_DESKTOPDIRECTORY"))    \
    DEFMAC(CSIDL_COMMON_DOCUMENTS, TEXT("Common Documents"), TEXT("CSIDL_COMMON_DOCUMENTS"))                \
    DEFMAC(CSIDL_COMMON_FAVORITES, TEXT("Common Favorites"), TEXT("CSIDL_COMMON_FAVORITES"))                \
    DEFMAC(CSIDL_COMMON_PROGRAMS, TEXT("Common Programs"), TEXT("CSIDL_COMMON_PROGRAMS"))                   \
    DEFMAC(CSIDL_COMMON_STARTMENU, TEXT("Common Start Menu"), TEXT("CSIDL_COMMON_STARTMENU"))               \
    DEFMAC(CSIDL_COMMON_STARTUP, TEXT("Common Startup"), TEXT("CSIDL_COMMON_STARTUP"))                      \
    DEFMAC(CSIDL_COMMON_TEMPLATES, TEXT("Common Templates"), TEXT("CSIDL_COMMON_TEMPLATES"))                \

#define ENVIRONMENT_VARIABLES                           \
    DEFMAC(TEXT("WINDIR"))                              \
    DEFMAC(TEXT("SYSTEMROOT"))                          \
    DEFMAC(TEXT("SYSTEM16"))                            \
    DEFMAC(TEXT("SYSTEM32"))                            \
    DEFMAC(TEXT("SYSTEM"))                              \
    DEFMAC(TEXT("ALLUSERSPROFILE"))                     \
    DEFMAC(TEXT("USERPROFILE"))                         \
    DEFMAC(TEXT("PROFILESFOLDER"))                      \
    DEFMAC(TEXT("APPDATA"))                             \
    DEFMAC(TEXT("CSIDL_APPDATA"))                       \
    DEFMAC(TEXT("CSIDL_ADMINTOOLS"))                    \
    DEFMAC(TEXT("CSIDL_ALTSTARTUP"))                    \
    DEFMAC(TEXT("CSIDL_BITBUCKET"))                     \
    DEFMAC(TEXT("CSIDL_COMMON_ADMINTOOLS"))             \
    DEFMAC(TEXT("CSIDL_COMMON_ALTSTARTUP"))             \
    DEFMAC(TEXT("CSIDL_COMMON_APPDATA"))                \
    DEFMAC(TEXT("CSIDL_COMMON_DESKTOPDIRECTORY"))       \
    DEFMAC(TEXT("CSIDL_COMMON_DOCUMENTS"))              \
    DEFMAC(TEXT("CSIDL_COMMON_FAVORITES"))              \
    DEFMAC(TEXT("CSIDL_COMMON_PROGRAMS"))               \
    DEFMAC(TEXT("CSIDL_COMMON_STARTMENU"))              \
    DEFMAC(TEXT("CSIDL_COMMON_STARTUP"))                \
    DEFMAC(TEXT("CSIDL_COMMON_TEMPLATES"))              \
    DEFMAC(TEXT("CSIDL_CONTROLS"))                      \
    DEFMAC(TEXT("CSIDL_COOKIES"))                       \
    DEFMAC(TEXT("CSIDL_DESKTOP"))                       \
    DEFMAC(TEXT("CSIDL_DESKTOPDIRECTORY"))              \
    DEFMAC(TEXT("CSIDL_DRIVES"))                        \
    DEFMAC(TEXT("CSIDL_FAVORITES"))                     \
    DEFMAC(TEXT("CSIDL_FONTS"))                         \
    DEFMAC(TEXT("CSIDL_HISTORY"))                       \
    DEFMAC(TEXT("CSIDL_INTERNET"))                      \
    DEFMAC(TEXT("CSIDL_INTERNET_CACHE"))                \
    DEFMAC(TEXT("CSIDL_LOCAL_APPDATA"))                 \
    DEFMAC(TEXT("CSIDL_MYPICTURES"))                    \
    DEFMAC(TEXT("CSIDL_NETHOOD"))                       \
    DEFMAC(TEXT("CSIDL_NETWORK"))                       \
    DEFMAC(TEXT("CSIDL_PERSONAL"))                      \
    DEFMAC(TEXT("CSIDL_PRINTERS"))                      \
    DEFMAC(TEXT("CSIDL_PRINTHOOD"))                     \
    DEFMAC(TEXT("CSIDL_PROFILE"))                       \
    DEFMAC(TEXT("CSIDL_PROGRAM_FILES"))                 \
    DEFMAC(TEXT("ProgramFiles"))                        \
    DEFMAC(TEXT("CSIDL_PROGRAM_FILES_COMMON"))          \
    DEFMAC(TEXT("CommonProgramFiles"))                  \
    DEFMAC(TEXT("CSIDL_PROGRAMS"))                      \
    DEFMAC(TEXT("CSIDL_RECENT"))                        \
    DEFMAC(TEXT("CSIDL_SENDTO"))                        \
    DEFMAC(TEXT("CSIDL_STARTMENU"))                     \
    DEFMAC(TEXT("CSIDL_STARTUP"))                       \
    DEFMAC(TEXT("CSIDL_SYSTEM"))                        \
    DEFMAC(TEXT("CSIDL_TEMPLATES"))                     \
    DEFMAC(TEXT("CSIDL_WINDOWS"))                       \
    DEFMAC(TEXT("CSIDL_MYDOCUMENTS"))                   \
    DEFMAC(TEXT("CSIDL_MYMUSIC"))                       \
    DEFMAC(TEXT("CSIDL_MYVIDEO"))                       \
    DEFMAC(TEXT("CSIDL_SYSTEMX86"))                     \
    DEFMAC(TEXT("CSIDL_PROGRAM_FILESX86"))              \
    DEFMAC(TEXT("CSIDL_PROGRAM_FILES_COMMONX86"))       \
    DEFMAC(TEXT("CSIDL_CONNECTIONS"))                   \
    DEFMAC(TEXT("TEMP"))                                \
    DEFMAC(TEXT("TMP"))                                 \

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

/*++

  The shell folder functions here are duplicates of the RAS code. This is not
  a good solution (we have two copies of the same code), but the designed
  solution requires engine scope support. Scopes are the mechanism in which
  major groups of data are separated from each other, such as the separation
  of multiple users. A scope provides properties that affect objects within
  the scope. For example, a user scope has properties such as domain name,
  profile path, sid, and so on.

  In order not to duplicate this code but still maintain modularity and system
  independence, a scope module is needed for users. So instead of the code
  below, the code would be something like

  property = IsmGetScopeProperty ("userprofile");

  This will be implemented if we want to (A) support multiple scopes, (B)
  eliminate physical system access in non-type modules, or (C) clean up this
  duplicated code.

--*/

typedef HRESULT (WINAPI SHGETFOLDERPATH)(HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, PTSTR pszPath);
typedef SHGETFOLDERPATH * PSHGETFOLDERPATH;

HANDLE
pGetShFolderLib (
    VOID
    )
{
    static HANDLE lib;

    if (lib) {
        return lib;
    }

    lib = LoadLibrary (TEXT("shfolder.dll"));
    if (!lib) {
        LOG ((LOG_ERROR, (PCSTR) MSG_SHFOLDER_LOAD_ERROR));
    }

    return lib;
}

PTSTR
pFindSfPath (
    IN      PCTSTR FolderStr,
    IN      BOOL UserFolder
    )
{
    HKEY key;
    REGSAM prevMode;
    PCTSTR data;
    PCTSTR result = NULL;

    if (!result) {
        if (UserFolder) {
            prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);
            key = OpenRegKeyStr (TEXT("HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders"));
            SetRegOpenAccessMode (prevMode);
        } else {
            prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);
            key = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders"));
            SetRegOpenAccessMode (prevMode);
        }

        if (key) {
            data = GetRegValueString (key, FolderStr);

            if (data) {
                result = DuplicatePathString (data, 0);
                FreeAlloc (data);
            }
            CloseRegKey (key);
        }
    }

    if (!result) {
        if (UserFolder) {
            prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);
            key = OpenRegKeyStr (TEXT("HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"));
            SetRegOpenAccessMode (prevMode);
        } else {
            prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);
            key = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"));
            SetRegOpenAccessMode (prevMode);
        }

        if (key) {
            data = GetRegValueString (key, FolderStr);

            if (data) {
                result = DuplicatePathString (data, 0);
                FreeAlloc (data);
            }
            CloseRegKey (key);
        }
    }

    return (PTSTR) result;
}

PCTSTR
GetShellFolderPath (
    IN      INT Folder,
    IN      PCTSTR FolderStr,
    IN      BOOL UserFolder,
    OUT     PTSTR Buffer
    )
{
    HRESULT result;
    LPITEMIDLIST pidl;
    BOOL b;
    LPMALLOC mallocFn;
    HANDLE lib;
    PSHGETFOLDERPATH shGetFolderPath;
    PCTSTR sfPath = NULL;
    PCTSTR expandedPath = NULL;
    PTSTR endPtr = NULL;
    TCHAR currUserProfile[MAX_TCHAR_PATH];
    MIG_USERDATA userData;

    result = SHGetMalloc (&mallocFn);
    if (result != S_OK) {
        return NULL;
    }

    if (FolderStr) {

        //
        // First try to find this in Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders
        //
        sfPath = pFindSfPath (FolderStr, UserFolder);

        if (sfPath && *sfPath) {
            //
            // We found it.
            //
            StringCopyTcharCount (Buffer, sfPath, MAX_PATH);
            expandedPath = IsmExpandEnvironmentString (IsmGetRealPlatform (), S_SYSENVVAR_GROUP, sfPath, NULL);
            FreePathString (sfPath);
            sfPath = NULL;
            if (expandedPath && *expandedPath) {
                StringCopyTcharCount (Buffer, expandedPath, MAX_PATH);
            }
            if (expandedPath) {
                IsmReleaseMemory (expandedPath);
            }

            if (IsmGetMappedUserData (&userData)) {
                // we have a mapped user, try to build it's default shell folder location
                GetUserProfileRootPath (currUserProfile);

                if (StringIMatch (currUserProfile, Buffer)) {
                    StringCopyTcharCount (Buffer, userData.UserProfileRoot, MAX_PATH);
                } else {
                    AppendWack (currUserProfile);

                    if (StringIMatchTcharCount (currUserProfile, Buffer, TcharCount (currUserProfile))) {

                        endPtr = Buffer + TcharCount (currUserProfile);
                        sfPath = JoinPaths (userData.UserProfileRoot, endPtr);
                        StringCopyTcharCount (Buffer, sfPath, MAX_PATH);
                        FreePathString (sfPath);
                    }
                }
            }

            return Buffer;
        }
        if (sfPath) {
            FreePathString (sfPath);
        }

        lib = pGetShFolderLib ();

        if (lib) {
#ifdef UNICODE
            (FARPROC) shGetFolderPath = GetProcAddress (lib, "SHGetFolderPathW");
#else
            (FARPROC) shGetFolderPath = GetProcAddress (lib, "SHGetFolderPathA");
#endif
            if (shGetFolderPath) {
                result = shGetFolderPath (NULL, Folder, NULL, 1, Buffer);
                if (result != S_OK) {
                    return NULL;
                }
                expandedPath = IsmExpandEnvironmentString (IsmGetRealPlatform (), S_SYSENVVAR_GROUP, Buffer, NULL);
                if (expandedPath && *expandedPath) {
                    StringCopyTcharCount (Buffer, expandedPath, MAX_PATH);
                }
                if (expandedPath) {
                    IsmReleaseMemory (expandedPath);
                    expandedPath = NULL;
                }

                if (IsmGetMappedUserData (&userData)) {
                    // we have a mapped user, try to build it's default shell folder location
                    GetUserProfileRootPath (currUserProfile);

                    if (StringIMatch (currUserProfile, Buffer)) {
                        StringCopyTcharCount (Buffer, userData.UserProfileRoot, MAX_PATH);
                    } else {
                        AppendWack (currUserProfile);

                        if (StringIMatchTcharCount (currUserProfile, Buffer, TcharCount (currUserProfile))) {

                            endPtr = Buffer + TcharCount (currUserProfile);
                            sfPath = JoinPaths (userData.UserProfileRoot, endPtr);
                            StringCopyTcharCount (Buffer, sfPath, MAX_PATH);
                            FreePathString (sfPath);
                        }
                    }

                    return Buffer;

                } else {
                    // no mapped user, use the current user's path
                    result = shGetFolderPath (NULL, Folder, NULL, 0, Buffer);
                }
                if (result != S_OK) {
                    return NULL;
                }
                expandedPath = IsmExpandEnvironmentString (IsmGetRealPlatform (), S_SYSENVVAR_GROUP, Buffer, NULL);
                if (expandedPath && *expandedPath) {
                    StringCopyTcharCount (Buffer, expandedPath, MAX_PATH);
                }
                if (expandedPath) {
                    IsmReleaseMemory (expandedPath);
                    expandedPath = NULL;
                }
                return Buffer;
            } else {
                result = SHGetSpecialFolderLocation (NULL, Folder, &pidl);
            }
        } else {
            result = SHGetSpecialFolderLocation (NULL, Folder, &pidl);
        }

        if (result != S_OK) {
            return NULL;
        }

        b = SHGetPathFromIDList (pidl, Buffer);
    } else {

        result = SHGetSpecialFolderLocation (NULL, Folder, &pidl);

        if (result != S_OK) {
            return NULL;
        }

        b = SHGetPathFromIDList (pidl, Buffer);
    }

    IMalloc_Free (mallocFn, pidl);

    return b ? Buffer : NULL;
}


PCTSTR
GetAllUsersProfilePath (
    OUT     PTSTR Buffer
    )
{
    HKEY key;
    REGSAM prevMode;
    PCTSTR data;
    PCTSTR expData;

    prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);
    key = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"));
    SetRegOpenAccessMode (prevMode);

    if (key) {

        data = GetRegValueString (key, TEXT("ProfilesDirectory"));

        if (data) {
            expData = IsmExpandEnvironmentString (IsmGetRealPlatform (), S_SYSENVVAR_GROUP, data, NULL);
            StringCopyByteCount (Buffer, expData, MAX_PATH);
            IsmReleaseMemory (expData);
            FreeAlloc (data);
        } else {
            GetWindowsDirectory (Buffer, MAX_PATH);
            StringCopy (AppendWack (Buffer), TEXT("Profiles"));
        }

        data = GetRegValueString (key, TEXT("AllUsersProfile"));

        if (data) {
            StringCopy (AppendWack (Buffer), data);
            FreeAlloc (data);
        } else {
            StringCopy (AppendWack (Buffer), TEXT("All Users"));
        }

        CloseRegKey (key);
        return Buffer;
    }

    GetWindowsDirectory (Buffer, MAX_PATH);
    return Buffer;
}

PCTSTR
GetProfilesFolderPath (
    OUT     PTSTR Buffer
    )
{
    HKEY key;
    REGSAM prevMode;
    PCTSTR data;
    PCTSTR expData;

    prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);
    key = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"));
    SetRegOpenAccessMode (prevMode);

    if (key) {

        data = GetRegValueString (key, TEXT("ProfilesDirectory"));

        if (data) {
            expData = IsmExpandEnvironmentString (IsmGetRealPlatform (), S_SYSENVVAR_GROUP, data, NULL);
            StringCopyByteCount (Buffer, expData, MAX_PATH);
            IsmReleaseMemory (expData);
            FreeAlloc (data);
        } else {
            GetWindowsDirectory (Buffer, MAX_PATH);
            StringCopy (AppendWack (Buffer), TEXT("Profiles"));
        }

        CloseRegKey (key);
        return Buffer;
    }

    GetWindowsDirectory (Buffer, MAX_PATH);
    return Buffer;
}

PCTSTR
GetUserProfileRootPath (
    OUT     PTSTR Buffer
    )
{
    HKEY key;
    REGSAM prevMode;
    PDWORD data;
    DWORD size;

    //
    // For Win2k and higher, use the shell
    //

    if (GetShellFolderPath (CSIDL_PROFILE, NULL, FALSE, Buffer)) {
        return Buffer;
    }

    //
    // For NT 4, use the environment
    //

    if (GetEnvironmentVariable (TEXT("USERPROFILE"), Buffer, MAX_PATH)) {
        return Buffer;
    }

    //
    // For Win9x, are profiles enabled?  If so, return %windir%\profiles\%user%.
    // If not, return %windir%.
    //

    GetWindowsDirectory (Buffer, MAX_PATH);

    prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);
    key = OpenRegKeyStr (TEXT("HKLM\\Network\\Logon"));
    SetRegOpenAccessMode (prevMode);
    if (key) {

        data = GetRegValueDword (key, TEXT("UserProfiles"));

        if (data && *data) {
            StringCat (Buffer, TEXT("\\Profiles\\"));

            size = MAX_PATH;
            GetUserName (GetEndOfString (Buffer), &size);

            FreeAlloc (data);
        }

        CloseRegKey (key);
    }

    return Buffer;
}


PCTSTR
IsValidUncPath (
    IN      PCTSTR Path
    )
{
    BOOL needNonWack = FALSE;
    BOOL wackRequired = TRUE;
    INT wacks = 0;

    while (*Path) {

        if (_tcsnextc (Path) == TEXT('\\')) {

            if (needNonWack) {
                break;
            }

            wacks++;
            if (wacks != 1) {
                needNonWack = TRUE;
                wackRequired = FALSE;
            }

            Path++;

        } else {
            //
            // Note: it would be nice to validate the non-wack characters against the
            //       legal unc charset
            //

            if (needNonWack) {
                if (wacks == 3) {
                    //
                    // Found \\x\x syntax; it's a UNC path
                    //

                    do {
                        Path = _tcsinc (Path);
                    } while (*Path && _tcsnextc (Path) != TEXT('\\'));

                    MYASSERT (*Path == 0 || *Path == TEXT('\\'));
                    return Path;
                }

                needNonWack = FALSE;
            }

            if (wackRequired) {
                break;
            }

            Path = _tcsinc (Path);
        }
    }

    return NULL;
}


BOOL
IsValidFileSpec (
    IN      PCTSTR FileSpec
    )
{
    CHARTYPE ch;
    BOOL result = TRUE;

    for (;;) {
        ch = (CHARTYPE) _tcsnextc (FileSpec);
        if (ch == TEXT('*')) {
            //
            // Really can't say what the validity is!
            //

            break;
        }

        if (!_istalpha (ch) && ch != TEXT('?')) {
            result = FALSE;
            break;
        }

        ch = (CHARTYPE) _tcsnextc (FileSpec + 1);
        if (ch == TEXT('*')) {
            break;
        }

        if (ch != TEXT(':') && ch != TEXT('?')) {
            result = FALSE;
            break;
        }

        ch = (CHARTYPE) _tcsnextc (FileSpec + 2);

        if (ch == 0) {
            // this is something like "d:", it's valid
            break;
        }

        if (ch == TEXT('*')) {
            break;
        }

        if (ch != TEXT('\\') && ch != TEXT('?')) {
            result = FALSE;
            break;
        }

        break;
    }

    if (!result) {
        result = (IsValidUncPath (FileSpec) != NULL);
    }

    return result;
}


VOID
pSetEnvironmentVar (
    IN      PMAPSTRUCT Map,
    IN      PMAPSTRUCT UndefMap,            OPTIONAL
    IN      BOOL MapSourceToDest,
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableData             OPTIONAL
    )
{
    TCHAR encodedVariableName[128];
    TCHAR buffer[MAX_TCHAR_PATH];
    PCTSTR undefText;

    //
    // VariableData is NULL when VariableName is not present on the machine
    //

    if (MapSourceToDest) {

        //
        // MapSourceToDest tells us to map a source path (c:\windows) to
        // a destination path (d:\winnt).
        //

        if (VariableData) {
            if (IsmGetEnvironmentString (
                    PLATFORM_SOURCE,
                    S_SYSENVVAR_GROUP,
                    VariableName,
                    buffer,
                    ARRAYSIZE(buffer),
                    NULL
                    )) {
                AddStringMappingPair (Map, buffer, VariableData);
            }
        }

        return;
    }

    //
    // MapSourceToDest is FALSE when we want to map environment variables
    // to the actual path.
    //

    //
    // VariableName length is hard-coded, so we know it does not exceed our
    // buffer
    //

    wsprintf (encodedVariableName, TEXT("%%%s%%"), VariableName);

    if (VariableData) {

        IsmSetEnvironmentString (IsmGetRealPlatform (), S_SYSENVVAR_GROUP, VariableName, VariableData);
        AddStringMappingPair (Map, encodedVariableName, VariableData);

    } else if (UndefMap) {

        //
        // If no variable data, then put environment variable in the
        // "undefined" variable mapping
        //

        undefText = JoinTextEx (NULL, TEXT("--> "), TEXT(" <--"), encodedVariableName, 0, NULL);
        AddStringMappingPair (UndefMap, encodedVariableName, undefText);
        FreeText (undefText);
    }
}


VOID
AddRemappingEnvVar (
    IN      PMAPSTRUCT Map,
    IN      PMAPSTRUCT ReMap,
    IN      PMAPSTRUCT UndefMap,            OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableData
    )
{
    pSetEnvironmentVar (Map, UndefMap, FALSE, VariableName, VariableData);
    pSetEnvironmentVar (ReMap, UndefMap, TRUE, VariableName, VariableData);
}


VOID
SetIsmEnvironmentFromPhysicalMachine (
    IN      PMAPSTRUCT Map,
    IN      BOOL MapSourceToDest,
    IN      PMAPSTRUCT UndefMap             OPTIONAL
    )
{
    TCHAR dir[MAX_TCHAR_PATH];
    PCTSTR path;
    PTSTR p;
    MIG_USERDATA userData;
    BOOL mappedUser = FALSE;

    mappedUser = IsmGetMappedUserData (&userData);

    //
    // Prepare ISM environment variables. The ones added last have the highest priority when
    // two or more variables map to the same path.
    //

    //
    // ...user profile
    //

    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("ALLUSERSPROFILE"), GetAllUsersProfilePath (dir));

    if (mappedUser) {
        pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("USERPROFILE"), userData.UserProfileRoot);
    } else {
        pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("USERPROFILE"), GetUserProfileRootPath (dir));
    }

    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("PROFILESFOLDER"), GetProfilesFolderPath (dir));

    //
    // ...temp dir
    //

    if (GetTempPath (MAX_PATH, dir)) {
        p = (PTSTR) FindLastWack (dir);
        if (p) {
            if (p[1] == 0) {
                *p = 0;
            }

            pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("TEMP"), dir);
            pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("TMP"), dir);
        }
    }

    //
    // ...windows directory env variable
    //

    GetWindowsDirectory (dir, ARRAYSIZE(dir));
    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("WINDIR"), dir);
    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("SYSTEMROOT"), dir);

    //
    // ...16-bit system directory. We invent SYSTEM16 and SYSTEM32 for use
    //    in scripts.
    //

    path = JoinPaths (dir, TEXT("system"));
    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("SYSTEM16"), path);
    FreePathString (path);

    path = JoinPaths (dir, TEXT("system32"));
    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("SYSTEM32"), path);
    FreePathString (path);

    //
    // ...platform-specific system directory
    //

    GetSystemDirectory (dir, ARRAYSIZE(dir));
    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("SYSTEM"), dir);

    //
    // ...shell folders -- we invent all variables with the CSIDL_ prefix
    //

#define DEFMAC(id,folder_str,var_name)              \
    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, var_name, \
                        GetShellFolderPath (id, folder_str, TRUE, dir));

    USER_SHELL_FOLDERS

#undef DEFMAC


#define DEFMAC(id,folder_str,var_name)                  \
    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, var_name, \
                        GetShellFolderPath (id, folder_str, FALSE, dir));

    COMMON_SHELL_FOLDERS

#undef DEFMAC
}

VOID
pTransferEnvPath (
    IN      PCTSTR IsmVariableName,
    IN      PMAPSTRUCT DirectMap,
    IN      PMAPSTRUCT ReverseMap,
    IN      PMAPSTRUCT UndefMap
    )
{
    TCHAR dir[MAX_TCHAR_PATH];
    TCHAR encodedVariableName[128];
    PCTSTR undefText;

    wsprintf (encodedVariableName, TEXT("%%%s%%"), IsmVariableName);

    if (IsmGetEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, IsmVariableName, dir, sizeof(dir)/sizeof((dir)[0]), NULL)) {
        if (DirectMap) {
            AddStringMappingPair (DirectMap, encodedVariableName, dir);
        }
        if (ReverseMap) {
            AddStringMappingPair (ReverseMap, dir, encodedVariableName);
        }
    } else {
        undefText = JoinTextEx (NULL, TEXT("--> "), TEXT(" <--"), encodedVariableName, 0, NULL);
        if (UndefMap) {
            AddStringMappingPair (UndefMap, encodedVariableName, undefText);
        }
        FreeText (undefText);
    }
}

VOID
SetIsmEnvironmentFromVirtualMachine (
    IN      PMAPSTRUCT DirectMap,
    IN      PMAPSTRUCT ReverseMap,
    IN      PMAPSTRUCT UndefMap
    )
{
    //
    // Need to transfer ISM environment into our string mapping
    //

#define DEFMAC(name)        pTransferEnvPath(name, DirectMap, ReverseMap, UndefMap);

    ENVIRONMENT_VARIABLES

#undef DEFMAC
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\vcm.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    vcm.c

Abstract:

    Implements the script parser and virtual computer building code

Author:

    Jim Schmidt (jimschm) 12-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\script\renregfn.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    renregfn.c

Abstract:

    Implements code-based registry rename.

Author:

    Jim Schmidt (jimschm) 15-Sep-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_RENREGFN    "RenRegFn"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef VOID(RENREGFNINIT)(MIG_PLATFORMTYPEID);
typedef RENREGFNINIT *PRENREGFNINIT;

typedef BOOL (STDMETHODCALLTYPE RENAMERULE)(
    IN      PCTSTR OldNode,
    IN      PCTSTR NewNode,
    IN      PCTSTR Leaf,
    IN      BOOL NoRestoreObject,
    OUT     PMIG_FILTEROUTPUT OutputData
    );
typedef RENAMERULE FAR *LPRENAMERULE;

//
// Globals
//

PTSTR g_DestIdentityGUID = NULL;
BOOL g_OERulesMigrated = FALSE;

//
// Macro expansion list
//

//
// DEFMAC(<script tag>, <enum callback>, <operation name>, <op init>, <operation callback>)
//
// It is assumed that <operation callback> is a tree filter (it can modify part of a path).
// The code does not currently support the contrary.
//

#define DEFAULT_ENUM        pDefaultRenRegFnQueueCallback
#define DEFAULT_INIT        pNulInit

#define RENAME_FUNCTIONS        \
    DEFMAC(ConvertOE4,          DEFAULT_ENUM, MOVE.ConvertOE4,          pConvertOE4Init,    pConvertOE4Move    ) \
    DEFMAC(ConvertOE4IAM,       DEFAULT_ENUM, MOVE.ConvertOE4IAM,       pConvertOE4Init,    pConvertOEIAMMove  ) \
    DEFMAC(ConvertOE5IAM,       DEFAULT_ENUM, MOVE.ConvertOE5IAM,       pConvertOE5IAMInit, pConvertOEIAMMove  ) \
    DEFMAC(ConvertOE5IdIAM,     DEFAULT_ENUM, MOVE.ConvertOE5IdIAM,     DEFAULT_INIT,       pConvertOEIdIAMMove) \
    DEFMAC(ConvertOE5MailRules, DEFAULT_ENUM, MOVE.ConvertOE5MailRules, DEFAULT_INIT,       pConvertOE5MailRulesMove) \
    DEFMAC(ConvertOE5NewsRules, DEFAULT_ENUM, MOVE.ConvertOE5NewsRules, DEFAULT_INIT,       pConvertOE5NewsRulesMove) \
    DEFMAC(ConvertOE5Block,     DEFAULT_ENUM, MOVE.ConvertOE5Block,     DEFAULT_INIT,       pConvertOE5BlockMove) \

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

//
// Declare special rename operation apply callback functions
//
#define DEFMAC(ifn,ec,opn,opi,opc) SGMENUMERATIONCALLBACK ec; RENREGFNINIT opi; OPMFILTERCALLBACK opc;
RENAME_FUNCTIONS
#undef DEFMAC

//
// This is the structure used for handling action functions
//
typedef struct {
    PCTSTR InfFunctionName;
    PSGMENUMERATIONCALLBACK EnumerationCallback;
    PCTSTR OperationName;
    MIG_OPERATIONID OperationId;
    PRENREGFNINIT OperationInit;
    POPMFILTERCALLBACK OperationCallback;
} RENAME_STRUCT, *PRENAME_STRUCT;

//
// Declare a global array of rename functions
//
#define DEFMAC(ifn,ec,opn,opi,opc) {TEXT("\\")TEXT(#ifn),ec,TEXT(#opn),0,opi,opc},
static RENAME_STRUCT g_RenameFunctions[] = {
                              RENAME_FUNCTIONS
                              {NULL, NULL, NULL, 0, NULL, NULL}
                              };
#undef DEFMAC

//
// Code
//

VOID
pNulInit (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
}

UINT
pDefaultRenRegFnQueueCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    PRENAME_STRUCT p = (PRENAME_STRUCT)CallerArg;

    IsmSetOperationOnObject (Data->ObjectTypeId, Data->ObjectName, p->OperationId, NULL, NULL);

    return CALLBACK_ENUM_CONTINUE;
}

PRENAME_STRUCT
pGetRenameStruct (
    IN      PCTSTR FunctionName
    )
{
    PRENAME_STRUCT p = g_RenameFunctions;
    INT i = 0;
    while (p->InfFunctionName != NULL) {
        if (StringIMatch (p->InfFunctionName, FunctionName)) {
            return p;
        }
        p++;
        i++;
    }
    return NULL;
}

VOID
InitSpecialRename (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    PRENAME_STRUCT p = g_RenameFunctions;

    while (p->InfFunctionName) {
        p->OperationId = IsmRegisterOperation (p->OperationName, FALSE);
        if (Platform == PLATFORM_DESTINATION) {
            IsmRegisterOperationFilterCallback (p->OperationId, p->OperationCallback, TRUE, TRUE, FALSE);
        }

        p->OperationInit(Platform);
        p++;
    }
}

VOID
TerminateSpecialRename (
    VOID
    )
{
    if (g_DestIdentityGUID) {
        FreeText (g_DestIdentityGUID);
    }
}

BOOL
AddSpecialRenameRule (
    IN      PCTSTR Pattern,
    IN      PCTSTR Function
)
{
    PRENAME_STRUCT functionStruct = NULL;
    BOOL result = FALSE;

    functionStruct = pGetRenameStruct (Function);

    if (functionStruct) {
        result = IsmHookEnumeration (
            g_RegType,
            Pattern,
            functionStruct->EnumerationCallback?
                functionStruct->EnumerationCallback:
                pDefaultRenRegFnQueueCallback,
            (ULONG_PTR)functionStruct,
            functionStruct->InfFunctionName
            );
    } else {
        LOG ((
            LOG_ERROR,
            (PCSTR) MSG_DATA_RENAME_BAD_FN,
            Function,
            Pattern
            ));
    }

    return result;
}

BOOL
pProcessDataRenameSection (
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfHandle,
    IN      PCTSTR Section
    )
{
    PCTSTR pattern;
    ENCODEDSTRHANDLE encodedPattern = NULL;
    PCTSTR functionName;
    BOOL result = FALSE;

    __try {
        if (InfFindFirstLine (InfHandle, Section, NULL, InfStruct)) {
            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                pattern = InfGetStringField (InfStruct, 0);

                if (!pattern) {
                    continue;
                }
                encodedPattern = TurnRegStringIntoHandle (pattern, TRUE, NULL);

                functionName = InfGetStringField (InfStruct, 1);

                if (functionName) {
                    AddSpecialRenameRule(encodedPattern, functionName);
                } else {
                    LOG ((LOG_ERROR, (PCSTR) MSG_DATA_RENAME_NO_FN, pattern));
                }

                IsmDestroyObjectHandle (encodedPattern);
                encodedPattern = NULL;
            } while (InfFindNextLine (InfStruct));
        }

        result = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (InfStruct);
    }

    return result;
}

BOOL
DoRegistrySpecialRename (
    IN      HINF InfHandle,
    IN      PCTSTR Section
    )
{
    PCTSTR osSpecificSection;
    BOOL b;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;

    b = pProcessDataRenameSection (&is, InfHandle, Section);

    if (b) {
        osSpecificSection = GetMostSpecificSection (&is, InfHandle, Section);

        if (osSpecificSection) {
            b = pProcessDataRenameSection (&is, InfHandle, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    InfCleanUpInfStruct (&is);
    return b;
}


//
// Helpers below
//

VOID
pConvertOE4Init (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    if (Platform == PLATFORM_DESTINATION &&
        IsmGetRealPlatform() == PLATFORM_DESTINATION &&
        IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE4_APPDETECT))
    {

        if (g_DestIdentityGUID != NULL) {
            // Already got it.. punt
            return;
        }

        // pull out the GUID from dest
        g_DestIdentityGUID = OEGetDefaultId (PLATFORM_DESTINATION);

        if (g_DestIdentityGUID == NULL)
        {
            // This is when we created a new user
            g_DestIdentityGUID = OECreateFirstIdentity();
        } else {
            // This is when applying to a user who never ran OE
            OEInitializeIdentity();
        }
    }
}

BOOL
WINAPI
pConvertOE4Move (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PTSTR newNode = NULL;
    PTSTR ptr = NULL;
    MIG_OBJECTSTRINGHANDLE newName;

    if (g_DestIdentityGUID == NULL) {
        return FALSE;
    }

    IsmCreateObjectStringsFromHandle (InputData->CurrentObject.ObjectName, &srcNode, &srcLeaf);

    // srcNode should be "HKCU\Software\Microsoft\Outlook Express\..."

    if (!srcNode) {
        return FALSE;
    }

    ptr = (PTSTR)_tcsistr (srcNode, TEXT("\\Outlook Express"));
    if (!ptr) {
        return FALSE;
    }
    ptr += 16;

    newNode = AllocText (CharCount (srcNode) + CharCount (g_DestIdentityGUID) + 17);
    StringCopy (newNode, TEXT("HKCU\\Identities\\"));                          // +12
    StringCat (newNode, g_DestIdentityGUID);
    StringCat (newNode, TEXT("\\Software\\Microsoft\\Outlook Express\\5.0"));  // +4
    StringCat (newNode, ptr);

    // newNode should be "HKCU\Identities\{GUID}\Software\Microsoft\Outlook Express\5.0\..."

    newName = IsmCreateObjectHandle (newNode, srcLeaf);
    FreeText (newNode);
    IsmDestroyObjectString (srcLeaf);
    IsmDestroyObjectString (srcNode);

    OutputData->NewObject.ObjectName = newName;

    return TRUE;
}

VOID
pConvertOE5IAMInit (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    BOOL remap = TRUE;
    PTSTR srcAssocId;
    PTSTR newIdentity;
    PTSTR srcDefaultId;
    PTSTR destDefaultId;

    if (Platform == PLATFORM_DESTINATION &&
        IsmGetRealPlatform() == PLATFORM_DESTINATION &&
        IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT))
    {
        // g_DestIdentityGUID should remain NULL if we do not want to remap the IAM tree
        // This is true when the destination user profile has not been created yet.  We also
        // want to leave it alone when the IAM has not yet been initialized (assume that [AssociatedID]
        // has not yet been written.. if this is not a valid assumption, compare to source's AssociatedID)

        if (g_DestIdentityGUID != NULL) {
            // Already got it.. punt
            return;
        }

        srcAssocId = OEGetAssociatedId (PLATFORM_SOURCE);
        if (srcAssocId) {
            newIdentity = OEGetRemappedId (srcAssocId);
            if (newIdentity) {
               if (OEIsIdentityAssociated(newIdentity)) {
                   FreeText(newIdentity);
               } else {
                   g_DestIdentityGUID = newIdentity;
               }
            }
            FreeText(srcAssocId);
        }

        OEInitializeIdentity();
    }
}

BOOL
WINAPI
pConvertOE5IAMMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PTSTR newNode = NULL;
    PTSTR ptr = NULL;
    BOOL retval = FALSE;

    if (g_DestIdentityGUID == NULL ||
        OEIsIdentityAssociated (g_DestIdentityGUID)) {
        // Do Nothing
        return TRUE;
    }

    IsmCreateObjectStringsFromHandle (InputData->CurrentObject.ObjectName, &srcNode, &srcLeaf);
    if (srcNode) {
        // srcNode should be "HKCU\Software\Microsoft\Internet Account Manager\..."

        ptr = _tcschr (srcNode, TEXT('\\'));
        if (ptr) {

            newNode = AllocText (CharCount (srcNode) + CharCount (g_DestIdentityGUID) + 13);
            StringCopy (newNode, TEXT("HKCU\\Identities\\"));    // +12
            StringCat (newNode, g_DestIdentityGUID);
            StringCat (newNode, ptr);

            // newNode should be "HKCU\Identities\{GUID}\Software\Microsoft\Internet Account Manager\..."

            OutputData->NewObject.ObjectName = IsmCreateObjectHandle (newNode, srcLeaf);
            FreeText (newNode);
            retval = TRUE;
        }
    }

    IsmDestroyObjectString (srcNode);
    IsmDestroyObjectString (srcLeaf);

    return retval;
}

BOOL
pConcatRuleIndex (
    IN      PCTSTR Node,
    IN      PCTSTR SearchStr
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    PTSTR tmpNode;
    PTSTR ptr;
    TCHAR number[5];
    PTSTR newStr;

    tmpNode = DuplicateText(Node);
    if (tmpNode) {
        ptr = (PTSTR)_tcsistr (tmpNode, SearchStr);
        if (ptr) {
            ptr += CharCount(SearchStr);
            StringCopyCharCount(number, ptr, 4);
            number[4] = 0;
            *ptr = 0;
            objectName = IsmCreateObjectHandle (tmpNode, TEXT("Order"));
            if (IsmAcquireObject(g_RegType | PLATFORM_DESTINATION,
                                 objectName,
                                 &objectContent)) {
                if (IsValidRegSz(&objectContent)) {
                    if (!_tcsistr ((PCTSTR)objectContent.MemoryContent.ContentBytes, number)) {
                        newStr = IsmGetMemory(objectContent.MemoryContent.ContentSize + SizeOfString(number) + 1);
                        StringCopy(newStr, (PCTSTR)objectContent.MemoryContent.ContentBytes);
                        StringCat(newStr, TEXT(" "));
                        StringCat(newStr, number);

                        IsmReleaseMemory(objectContent.MemoryContent.ContentBytes);
                        objectContent.MemoryContent.ContentSize = SizeOfString(newStr);
                        objectContent.MemoryContent.ContentBytes = (PCBYTE)newStr;

                        IsmReplacePhysicalObject (g_RegType, objectName, &objectContent);
                    }
                }
                IsmReleaseObject(&objectContent);
            }
            IsmDestroyObjectHandle(objectName);
        }
        FreeText(tmpNode);
    }
    return TRUE;
}

BOOL
pRenameEx
(
    IN      PCTSTR OldNode,
    IN      PCTSTR NewNode,
    IN      PCTSTR Leaf,
    IN      BOOL NoRestoreObject,
    IN      PCTSTR PrevKey,
    IN      PCTSTR FormatStr,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL ZeroBase
    )
{
    BOOL result = FALSE;
    PTSTR patternNode;
    PTSTR tmpNode;
    PTSTR ptr;
    PTSTR searchStr;
    DWORD prevCount;
    DWORD keySize = 1;
    MIG_FILTERINPUT filterInput;
    MIG_FILTEROUTPUT filterOutput;
    MIG_BLOB migBlob;
    MIG_BLOB zeroBaseBlob;
    PTSTR filteredNode = NULL;

    tmpNode = DuplicateText(NewNode);
    if (tmpNode) {
        prevCount = CharCount(PrevKey);
        searchStr = AllocText(prevCount + 3);
        if (searchStr) {
            _stprintf(searchStr, TEXT("\\%s\\"), PrevKey);

            ptr = (PTSTR)_tcsistr (tmpNode, searchStr);
            if (ptr) {
                ptr += (prevCount + 2); // Advance to next portion
                *ptr = 0;
                ptr = _tcsinc(ptr);
                while (*ptr && *ptr != TEXT('\\')) {
                    ptr = _tcsinc(ptr);
                    keySize++;
                }

                patternNode = AllocText(CharCount(NewNode) + (CharCount(FormatStr) - keySize));
                if (patternNode) {
                    StringCopy(patternNode, tmpNode);
                    StringCat(patternNode, FormatStr);
                    StringCat(patternNode, ptr);

                    filterInput.OriginalObject.ObjectTypeId = g_RegType;
                    filterInput.OriginalObject.ObjectName = IsmCreateObjectHandle (OldNode, NULL);
                    filterInput.CurrentObject.ObjectTypeId = g_RegType;
                    filterInput.CurrentObject.ObjectName = IsmCreateObjectHandle (OldNode, NULL);
                    migBlob.Type = BLOBTYPE_STRING;
                    migBlob.String = IsmCreateObjectHandle (patternNode, NULL);

                    if (ZeroBase) {
                        zeroBaseBlob.Type = BLOBTYPE_BINARY;
                        zeroBaseBlob.BinarySize = sizeof(PCBYTE);
                        zeroBaseBlob.BinaryData = (PCBYTE)TRUE;

                        FilterRenameExFilter (&filterInput, &filterOutput, NoRestoreObject, &zeroBaseBlob, &migBlob);
                    } else {
                        FilterRenameExFilter (&filterInput, &filterOutput, NoRestoreObject, NULL, &migBlob);
                    }

                    IsmDestroyObjectHandle (migBlob.String);
                    IsmDestroyObjectHandle (filterInput.CurrentObject.ObjectName);
                    IsmDestroyObjectHandle (filterInput.OriginalObject.ObjectName);

                    IsmCreateObjectStringsFromHandle (filterOutput.NewObject.ObjectName, &filteredNode, NULL);
                    IsmDestroyObjectHandle (filterOutput.NewObject.ObjectName);

                    OutputData->NewObject.ObjectName = IsmCreateObjectHandle (filteredNode, Leaf);
                    if (0 == *ptr) {
                        pConcatRuleIndex(filteredNode, searchStr);
                    }
                    FreeText (filteredNode);

                    FreeText(patternNode);
                }
            } else {
                OutputData->NewObject.ObjectName = IsmCreateObjectHandle (tmpNode, Leaf);
            }
            FreeText(searchStr);
        } else {
            OutputData->NewObject.ObjectName = IsmCreateObjectHandle (tmpNode, Leaf);
        }
        FreeText(tmpNode);
    }
    return TRUE;
}

BOOL
pRenameNewsRule
(
    IN      PCTSTR OldNode,
    IN      PCTSTR NewNode,
    IN      PCTSTR Leaf,
    IN      BOOL NoRestoreObject,
    OUT     PMIG_FILTEROUTPUT OutputData
    )
{
    return pRenameEx(OldNode, NewNode, Leaf, NoRestoreObject, TEXT("News"), TEXT("<%03d>"), OutputData, TRUE);
}

BOOL
pRenameMailRule
(
    IN      PCTSTR OldNode,
    IN      PCTSTR NewNode,
    IN      PCTSTR Leaf,
    IN      BOOL NoRestoreObject,
    OUT     PMIG_FILTEROUTPUT OutputData
    )
{
    return pRenameEx(OldNode, NewNode, Leaf, NoRestoreObject, TEXT("Mail"), TEXT("<%03d>"), OutputData, TRUE);
}

BOOL
pRenameBlockRule
(
    IN      PCTSTR OldNode,
    IN      PCTSTR NewNode,
    IN      PCTSTR Leaf,
    IN      BOOL NoRestoreObject,
    OUT     PMIG_FILTEROUTPUT OutputData
    )
{
    return pRenameEx(OldNode, NewNode, Leaf, NoRestoreObject, TEXT("Criteria"), TEXT("<%03d>"), OutputData, TRUE);
}



BOOL
pRenameAccount
(
    IN      PCTSTR OldNode,
    IN      PCTSTR NewNode,
    IN      PCTSTR Leaf,
    IN      BOOL NoRestoreObject,
    OUT     PMIG_FILTEROUTPUT OutputData
    )
{
    return pRenameEx(OldNode, NewNode, Leaf, NoRestoreObject, TEXT("Accounts"), TEXT("<%08d>"), OutputData, FALSE);
}

BOOL
WINAPI
pConvertOE5RulesMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      LPRENAMERULE fnRename
    )
{
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PTSTR newNode = NULL;
    PTSTR tmpText;
    TCHAR *endId;
    TCHAR *srcIdentity;
    PTSTR newIdentity;

    // Move tree and Merge account name

    IsmCreateObjectStringsFromHandle (InputData->CurrentObject.ObjectName, &srcNode, &srcLeaf);
    if (srcNode) {
        // srcNode should be "HKCU\Identities\{GUID}\Software\Microsoft\Outlook Express\Rules\Mail\..."
        tmpText = DuplicateText(srcNode);
        if (tmpText) {
            srcIdentity = _tcschr(tmpText, TEXT('{'));
            if (srcIdentity) {
                endId = _tcschr(srcIdentity, TEXT('\\'));
                if (endId) {
                    *endId = 0;
                    endId = _tcsinc(endId);

                    // endId should be "Software\Microsoft\Outlook Express\Rules\Mail\..."
                    // srcIdentity should be "{GUID}"

                    newIdentity = OEGetRemappedId (srcIdentity);
                    if (newIdentity) {
                        newNode = AllocText (CharCount(srcNode) + 1);
                        StringCopy (newNode, TEXT("HKCU\\Identities\\"));
                        StringCat (newNode, newIdentity);
                        StringCat (newNode, TEXT("\\"));
                        StringCat (newNode, endId);

                        if (newNode) {
                            if (srcLeaf &&
                                !g_OERulesMigrated &&
                                !StringIMatch(srcLeaf, TEXT("Version"))) {
                                g_OERulesMigrated = TRUE;
                            }
                            fnRename(srcNode, newNode, srcLeaf, NoRestoreObject, OutputData);
                            FreeText(newNode);
                        }
                        FreeText(newIdentity);
                    }
                }
            }
            FreeText(tmpText);
        }
        IsmDestroyObjectString (srcNode);
    }
    IsmDestroyObjectString (srcLeaf);

    return TRUE;
}

BOOL
WINAPI
pConvertOE5NewsRulesMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    return pConvertOE5RulesMove(InputData, OutputData, NoRestoreObject, pRenameNewsRule);
}

BOOL
WINAPI
pConvertOE5MailRulesMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    return pConvertOE5RulesMove(InputData, OutputData, NoRestoreObject, pRenameMailRule);
}

BOOL
WINAPI
pConvertOE5BlockMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    return pConvertOE5RulesMove(InputData, OutputData, NoRestoreObject, pRenameBlockRule);
}

BOOL
WINAPI
pConvertOEIdIAMMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PTSTR newNode = NULL;
    PTSTR tmpText;
    TCHAR *endId;
    TCHAR *srcIdentity;
    PTSTR newIdentity;

    // Move tree and Merge account name

    IsmCreateObjectStringsFromHandle (InputData->CurrentObject.ObjectName, &srcNode, &srcLeaf);
    if (srcNode) {
        // srcNode should be "HKCU\Identities\{GUID}\Software\Microsoft\Internet Account Manager\..."
        tmpText = DuplicateText(srcNode);
        if (tmpText) {
            srcIdentity = _tcschr(tmpText, TEXT('{'));
            if (srcIdentity) {
                endId = _tcschr(srcIdentity, TEXT('\\'));
                if (endId) {
                    *endId = 0;
                    endId = _tcsinc(endId);

                    // endId should be "Software\Microsoft\Internet Account Manager\..."
                    // srcIdentity should be "{GUID}"

                    newIdentity = OEGetRemappedId (srcIdentity);
                    if (newIdentity) {
                        if (OEIsIdentityAssociated (newIdentity)) {
                            // allocText below does include 1 extra for Null
                            newNode = AllocText (CharCount(endId) + 6);
                            StringCopy (newNode, TEXT("HKCU\\"));  // +5
                            StringCat (newNode, endId);
                            // newNode should be "HKCU\Software\Microsoft\Internet Account Manager\..."
                        } else {
                            newNode = AllocText (CharCount(srcNode) + 1);
                            StringCopy (newNode, TEXT("HKCU\\Identities\\"));
                            StringCat (newNode, newIdentity);
                            StringCat (newNode, TEXT("\\"));
                            StringCat (newNode, endId);
                        }

                        if (newNode) {
                            pRenameAccount(srcNode,
                                           newNode,
                                           srcLeaf,
                                           NoRestoreObject,
                                           OutputData);
                            FreeText(newNode);
                        }
                        FreeText(newIdentity);
                    }
                }
            }
            FreeText(tmpText);
        }
        IsmDestroyObjectString (srcNode);
    }
    IsmDestroyObjectString (srcLeaf);

    return TRUE;
}

BOOL
WINAPI
pConvertOEIAMMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PTSTR newNode = NULL;
    PTSTR filteredNode = NULL;
    PTSTR ptr = NULL;

    // Move tree and Merge account name

    IsmCreateObjectStringsFromHandle (InputData->CurrentObject.ObjectName, &srcNode, &srcLeaf);
    if (srcNode) {
        // srcNode should be "HKCU\Software\Microsoft\Internet Account Manager\..."
        if (g_DestIdentityGUID != NULL &&
            !OEIsIdentityAssociated (g_DestIdentityGUID)) {

            ptr = _tcschr (srcNode, TEXT('\\'));
            if (ptr) {
                newNode = AllocText (TcharCount (srcNode) + TcharCount (g_DestIdentityGUID) + 13);
                StringCopy (newNode, TEXT("HKCU\\Identities\\"));    // +12
                StringCat (newNode, g_DestIdentityGUID);
                StringCat (newNode, ptr);

                // newNode should be "HKCU\Identities\{GUID}\Software\Microsoft\Internet Account Manager\..."
            }
        } else {
            newNode = DuplicateText (srcNode);
        }

        if (newNode) {
            pRenameAccount(srcNode,
                           newNode,
                           srcLeaf,
                           NoRestoreObject,
                           OutputData);
            FreeText (newNode);
        }
        IsmDestroyObjectString (srcNode);
    }
    IsmDestroyObjectString (srcLeaf);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\access.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    access.c

Abstract:

    Implements Win9x accessiblity conversion by hooking the physical registry type
    and emulating the NT registry format.

Author:

    Jim Schmidt (jimschm) 29-Aug-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"

#define DBG_ACCESS     "Accessibility"

//
// Strings
//

#define S_ACCESSIBILITY_ROOT        TEXT("HKCU\\Control Panel\\Accessibility")

//
// Constants
//

#define SPECIAL_INVERT_OPTION   0x80000000

//
// Macros
//

// none

//
// Types
//

typedef struct {
    PCTSTR ValueName;
    DWORD FlagVal;
} ACCESS_OPTION, *PACCESS_OPTION;

typedef struct {
    PACCESS_OPTION AccessibilityMap;
    PCTSTR Win9xSubKey;
    PCTSTR NtSubKey;
} ACCESSIBILITY_MAPPINGS, *PACCESSIBILITY_MAPPINGS;

typedef struct {
    MEMDB_ENUM EnumStruct;
    DWORD RegType;
} ACCESSIBILITY_ENUM_STATE, *PACCESSIBILITY_ENUM_STATE;


//
// Globals
//

MIG_OBJECTTYPEID g_RegistryTypeId;
HASHTABLE g_ProhibitTable;

ACCESS_OPTION g_FilterKeys[] = {
    TEXT("On"),                     FKF_FILTERKEYSON,
    TEXT("Available"),              FKF_AVAILABLE,
    TEXT("HotKeyActive"),           FKF_HOTKEYACTIVE,
    TEXT("ConfirmHotKey"),          FKF_CONFIRMHOTKEY,
    TEXT("HotKeySound"),            FKF_HOTKEYSOUND,
    TEXT("ShowStatusIndicator"),    FKF_INDICATOR,
    TEXT("ClickOn"),                FKF_CLICKON,
    TEXT("OnOffFeedback"),          0,
    NULL
};

ACCESS_OPTION g_MouseKeys[] = {
    TEXT("On"),                     MKF_MOUSEKEYSON,
    TEXT("Available"),              MKF_AVAILABLE,
    TEXT("HotKeyActive"),           MKF_HOTKEYACTIVE,
    TEXT("ConfirmHotKey"),          MKF_CONFIRMHOTKEY,
    TEXT("HotKeySound"),            MKF_HOTKEYSOUND,
    TEXT("ShowStatusIndicator"),    MKF_INDICATOR,
    TEXT("Modifiers"),              MKF_MODIFIERS|SPECIAL_INVERT_OPTION,
    TEXT("ReplaceNumbers"),         MKF_REPLACENUMBERS,
    TEXT("OnOffFeedback"),          0,
    NULL
};

ACCESS_OPTION g_StickyKeys[] = {
    TEXT("On"),                     SKF_STICKYKEYSON,
    TEXT("Available"),              SKF_AVAILABLE,
    TEXT("HotKeyActive"),           SKF_HOTKEYACTIVE,
    TEXT("ConfirmHotKey"),          SKF_CONFIRMHOTKEY,
    TEXT("HotKeySound"),            SKF_HOTKEYSOUND,
    TEXT("ShowStatusIndicator"),    SKF_INDICATOR,
    TEXT("AudibleFeedback"),        SKF_AUDIBLEFEEDBACK,
    TEXT("TriState"),               SKF_TRISTATE,
    TEXT("TwoKeysOff"),             SKF_TWOKEYSOFF,
    TEXT("OnOffFeedback"),          0,
    NULL
};

ACCESS_OPTION g_SoundSentry[] = {
    TEXT("On"),                     SSF_SOUNDSENTRYON,
    TEXT("Available"),              SSF_AVAILABLE,
    TEXT("ShowStatusIndicator"),    SSF_INDICATOR,
    NULL
};

ACCESS_OPTION g_TimeOut[] = {
    TEXT("On"),                     ATF_TIMEOUTON,
    TEXT("OnOffFeedback"),          ATF_ONOFFFEEDBACK,
    NULL
};

ACCESS_OPTION g_ToggleKeys[] = {
    TEXT("On"),                     TKF_TOGGLEKEYSON,
    TEXT("Available"),              TKF_AVAILABLE,
    TEXT("HotKeyActive"),           TKF_HOTKEYACTIVE,
    TEXT("ConfirmHotKey"),          TKF_CONFIRMHOTKEY,
    TEXT("HotKeySound"),            TKF_HOTKEYSOUND,
    TEXT("ShowStatusIndicator"),    TKF_INDICATOR,
    TEXT("OnOffFeedback"),          0,
    NULL
};

ACCESS_OPTION g_HighContrast[] = {
    TEXT("On"),                     HCF_HIGHCONTRASTON,
    TEXT("Available"),              HCF_AVAILABLE,
    TEXT("HotKeyActive"),           HCF_HOTKEYACTIVE,
    TEXT("ConfirmHotKey"),          HCF_CONFIRMHOTKEY,
    TEXT("HotKeySound"),            HCF_HOTKEYSOUND,
    TEXT("ShowStatusIndicator"),    HCF_INDICATOR,
    TEXT("HotKeyAvailable"),        HCF_HOTKEYAVAILABLE,
    TEXT("OnOffFeedback"),          0,
    NULL
};


ACCESSIBILITY_MAPPINGS g_AccessibilityMappings[] = {
    {g_FilterKeys,      TEXT("KeyboardResponse"),   TEXT("Keyboard Response")},
    {g_MouseKeys,       TEXT("MouseKeys")},
    {g_StickyKeys,      TEXT("StickyKeys")},
    {g_SoundSentry,     TEXT("SoundSentry")},
    {g_TimeOut,         TEXT("TimeOut")},
    {g_ToggleKeys,      TEXT("ToggleKeys")},
    {g_HighContrast,    TEXT("HighContrast")},
    {NULL}
};


//
// Macro expansion list
//

// none

//
// Private function prototypes
//

// none

//
// Macro expansion definition
//

// none

//
// Private prototypes
//

ETMINITIALIZE AccessibilityEtmInitialize;
MIG_PHYSICALENUMADD EmulatedEnumCallback;
MIG_PHYSICALACQUIREHOOK AcquireAccessibilityFlags;
MIG_PHYSICALACQUIREFREE ReleaseAccessibilityFlags;

//
// Code
//

VOID
pProhibit9xSetting (
    IN      PCTSTR Key,
    IN      PCTSTR ValueName        OPTIONAL
    )
{
    MIG_OBJECTSTRINGHANDLE handle;

    handle = IsmCreateObjectHandle (Key, ValueName);
    MYASSERT (handle);

    IsmProhibitPhysicalEnum (g_RegistryTypeId, handle, NULL, 0, NULL);
    HtAddString (g_ProhibitTable, handle);

    IsmDestroyObjectHandle (handle);
}


BOOL
pStoreEmulatedSetting (
    IN      PCTSTR Key,
    IN      PCTSTR ValueName,           OPTIONAL
    IN      DWORD Type,
    IN      PBYTE ValueData,
    IN      UINT ValueDataSize
    )
{
    MIG_OBJECTSTRINGHANDLE handle;
    PCTSTR memdbNode;
    BOOL stored = FALSE;

    handle = IsmCreateObjectHandle (Key, ValueName);
    memdbNode = JoinPaths (TEXT("~Accessibility"), handle);
    IsmDestroyObjectHandle (handle);

    if (MemDbAddKey (memdbNode)) {
        if (ValueData) {
            stored = (MemDbSetValue (memdbNode, Type) != 0);
            stored &= (MemDbSetUnorderedBlob (memdbNode, 0, ValueData, ValueDataSize) != 0);
        } else {
            stored = TRUE;
        }
    }

    FreePathString (memdbNode);

    return stored;
}


VOID
pMoveAccessibilityValue (
    IN      PCTSTR Win9xKey,
    IN      PCTSTR Win9xValue,
    IN      PCTSTR NtKey,
    IN      PCTSTR NtValue,
    IN      BOOL ForceDword
    )
{
    HKEY key;
    PBYTE data = NULL;
    PBYTE storeData;
    DWORD conversionDword;
    DWORD valueType;
    DWORD valueSize;
    MIG_OBJECTSTRINGHANDLE handle;
    BOOL prohibited;

    handle = IsmCreateObjectHandle (Win9xKey, Win9xValue);
    prohibited = (HtFindString (g_ProhibitTable, handle) != NULL);
    IsmDestroyObjectHandle (handle);

    if (prohibited) {
        return;
    }

    key = OpenRegKeyStr (Win9xKey);
    if (!key) {
        return;
    }

    __try {
        if (!GetRegValueTypeAndSize (key, Win9xValue, &valueType, &valueSize)) {
            __leave;
        }

        if (valueType != REG_SZ && valueType != REG_DWORD) {
            __leave;
        }

        data = GetRegValueData (key, Win9xValue);
        if (!data) {
            __leave;
        }

        if (ForceDword && valueType == REG_SZ) {
            storeData = (PBYTE) &conversionDword;
            conversionDword = _ttoi ((PCTSTR) data);
            valueType = REG_DWORD;
            valueSize = sizeof (DWORD);
        } else {
            storeData = data;
        }

        if (pStoreEmulatedSetting (NtKey, NtValue, valueType, storeData, valueSize)) {
            pProhibit9xSetting (Win9xKey, Win9xValue);
        }
    }
    __finally {
        CloseRegKey (key);

        if (data) {
            FreeAlloc (data);
        }
    }
}


VOID
pMoveAccessibilityKey (
    IN      PCTSTR Win9xKey,
    IN      PCTSTR NtKey
    )
{
    HKEY key;
    PBYTE data = NULL;
    DWORD valueType;
    DWORD valueSize;
    LONG rc;
    DWORD index = 0;
    TCHAR valueName[MAX_REGISTRY_KEY];
    DWORD valueNameSize;
    GROWBUFFER value = INIT_GROWBUFFER;
    MIG_OBJECTSTRINGHANDLE handle;
    BOOL prohibited;

    key = OpenRegKeyStr (Win9xKey);
    if (!key) {
        return;
    }

    __try {
        for (;;) {

            valueNameSize = ARRAYSIZE(valueName);
            valueSize = 0;
            rc = RegEnumValue (key, index, valueName, &valueNameSize, NULL, &valueType, NULL, &valueSize);

            if (rc != ERROR_SUCCESS) {
                break;
            }

            handle = IsmCreateObjectHandle (Win9xKey, valueName);
            prohibited = (HtFindString (g_ProhibitTable, handle) != NULL);
            IsmDestroyObjectHandle (handle);

            if (!prohibited) {

                value.End = 0;
                data = GbGrow (&value, valueSize);

                valueNameSize = ARRAYSIZE(valueName);
                rc = RegEnumValue (key, index, valueName, &valueNameSize, NULL, &valueType, value.Buf, &valueSize);

                if (rc != ERROR_SUCCESS) {
                    break;
                }

                if (pStoreEmulatedSetting (NtKey, valueName, valueType, data, valueSize)) {
                    pProhibit9xSetting (Win9xKey, valueName);
                }
            }

            index++;
        }

        if (pStoreEmulatedSetting (NtKey, NULL, 0, NULL, 0)) {
            pProhibit9xSetting (Win9xKey, NULL);
        }
    }
    __finally {
        CloseRegKey (key);

        GbFree (&value);
    }
}


VOID
pTranslateAccessibilityKey (
    IN      PCTSTR Win9xSubKey,
    IN      PCTSTR NtSubKey,
    IN      PACCESS_OPTION AccessibilityMap
    )
{
    TCHAR full9xKey[MAX_REGISTRY_KEY];
    TCHAR fullNtKey[MAX_REGISTRY_KEY];
    MIG_OBJECTSTRINGHANDLE handle = NULL;
    HKEY key = NULL;
    PCTSTR data;
    DWORD flags = 0;
    DWORD thisFlag;
    BOOL enabled;
    TCHAR buffer[32];

    __try {
        StringCopy (full9xKey, S_ACCESSIBILITY_ROOT TEXT("\\"));
        StringCopy (fullNtKey, full9xKey);
        StringCat (full9xKey, Win9xSubKey);
        StringCat (fullNtKey, NtSubKey);

        key = OpenRegKeyStr (full9xKey);
        if (!key) {
            __leave;
        }

        while (AccessibilityMap->ValueName) {
            //
            // Prohibit enum of this value
            //

            handle = IsmCreateObjectHandle (full9xKey, AccessibilityMap->ValueName);
            MYASSERT (handle);

            IsmProhibitPhysicalEnum (g_RegistryTypeId, handle, NULL, 0, NULL);
            HtAddString (g_ProhibitTable, handle);

            IsmDestroyObjectHandle (handle);
            handle = NULL;

            //
            // Update the emulated flags
            //

            data = GetRegValueString (key, AccessibilityMap->ValueName);
            if (data) {

                enabled = (_ttoi (data) != 0);
                thisFlag = (AccessibilityMap->FlagVal & (~SPECIAL_INVERT_OPTION));

                if (AccessibilityMap->FlagVal & SPECIAL_INVERT_OPTION) {
                    enabled = !enabled;
                }

                if (enabled) {
                    flags |= thisFlag;
                }

                FreeAlloc (data);
            }

            AccessibilityMap++;
        }

        //
        // Put the emulated value in the hash table
        //

        wsprintf (buffer, TEXT("%u"), flags);
        pStoreEmulatedSetting (fullNtKey, TEXT("Flags"), REG_SZ, (PBYTE) buffer, SizeOfString (buffer));
    }
    __finally {
        if (key) {
            CloseRegKey (key);
        }
    }
}


VOID
pFillTranslationTable (
    VOID
    )
{
    PACCESSIBILITY_MAPPINGS mappings;

    //
    // Loop through all flags that need translation. Disable enumeration of
    // the Win9x physical values and enable enumeration of the translated values
    // via population of the hash table.
    //

    mappings = g_AccessibilityMappings;

    while (mappings->AccessibilityMap) {

        pTranslateAccessibilityKey (
            mappings->Win9xSubKey,
            mappings->NtSubKey ? mappings->NtSubKey : mappings->Win9xSubKey,
            mappings->AccessibilityMap
            );

        mappings++;
    }

    //
    // Add all keys that have moved, ordered from most specific to least specific
    //

    // AutoRepeat values are transposed
    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT TEXT("\\KeyboardResponse"), TEXT("AutoRepeatDelay"),
        S_ACCESSIBILITY_ROOT TEXT("\\Keyboard Response"), TEXT("AutoRepeatRate"),
        FALSE
        );

    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT TEXT("\\KeyboardResponse"), TEXT("AutoRepeatRate"),
        S_ACCESSIBILITY_ROOT TEXT("\\Keyboard Response"), TEXT("AutoRepeatDelay"),
        FALSE
        );

    // double c in DelayBeforeAcceptance value name
    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT TEXT("\\KeyboardResponse"), TEXT("DelayBeforeAcceptancce"),
        S_ACCESSIBILITY_ROOT TEXT("\\Keyboard Response"), TEXT("DelayBeforeAcceptance"),
        FALSE
        );

    // add a space to the key name for the rest of the values
    pMoveAccessibilityKey (
        S_ACCESSIBILITY_ROOT TEXT("\\KeyboardResponse"),
        S_ACCESSIBILITY_ROOT TEXT("\\Keyboard Response")
        );

    // change BaudRate to Baud & convert to DWORD
    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT TEXT("\\SerialKeys"), TEXT("BaudRate"),
        S_ACCESSIBILITY_ROOT TEXT("\\SerialKeys"), TEXT("Baud"),
        TRUE
        );

    // convert Flags to DWORD
    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT TEXT("\\SerialKeys"), TEXT("Flags"),
        S_ACCESSIBILITY_ROOT TEXT("\\SerialKeys"), TEXT("Flags"),
        TRUE
        );

    // add space between high and contrast
    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT TEXT("\\HighContrast"), TEXT("Pre-HighContrast Scheme"),
        S_ACCESSIBILITY_ROOT TEXT("\\HighContrast"), TEXT("Pre-High Contrast Scheme"),
        FALSE
        );

    // move two values from the root into their own subkeys
    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT, TEXT("Blind Access"),
        S_ACCESSIBILITY_ROOT TEXT("\\Blind Access"), TEXT("On"),
        FALSE
        );

    pStoreEmulatedSetting (S_ACCESSIBILITY_ROOT TEXT("\\Blind Access"), NULL, 0, NULL, 0);

    pMoveAccessibilityValue (
        S_ACCESSIBILITY_ROOT, TEXT("Keyboard Preference"),
        S_ACCESSIBILITY_ROOT TEXT("\\Keyboard Preference"), TEXT("On"),
        FALSE
        );

    pStoreEmulatedSetting (S_ACCESSIBILITY_ROOT TEXT("\\Keyboard Preference"), NULL, 0, NULL, 0);

}


BOOL
WINAPI
AccessibilityEtmInitialize (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    BOOL b = TRUE;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    if (ISWIN9X()) {
        g_RegistryTypeId = IsmGetObjectTypeId (S_REGISTRYTYPE);
        MYASSERT (g_RegistryTypeId);

        g_ProhibitTable = HtAlloc();
        MYASSERT (g_ProhibitTable);

        if (g_RegistryTypeId) {
            //
            // Add a callback for additional enumeration. If we are unable to do so, then
            // someone else is already doing something different for this key.
            //

            objectName = IsmCreateObjectHandle (S_ACCESSIBILITY_ROOT, NULL);

            b = IsmAddToPhysicalEnum (g_RegistryTypeId, objectName, EmulatedEnumCallback, 0);

            IsmDestroyObjectHandle (objectName);

            if (b) {
                //
                // Add a callback to acquire the data of the new physical objects
                //

                objectName = IsmCreateSimpleObjectPattern (
                                    S_ACCESSIBILITY_ROOT,
                                    TRUE,
                                    NULL,
                                    TRUE
                                    );

                b = IsmRegisterPhysicalAcquireHook (
                        g_RegistryTypeId,
                        objectName,
                        AcquireAccessibilityFlags,
                        ReleaseAccessibilityFlags,
                        0,
                        NULL
                        );

                IsmDestroyObjectHandle (objectName);
            }

            if (b) {

                //
                // Now load memdb with the current registry values and
                // prohibit the enumeration of Win9x values.
                //

                pFillTranslationTable ();
            }
            ELSE_DEBUGMSG ((DBG_WARNING, "Not allowed to translate accessibility key"));
        }

        HtFree (g_ProhibitTable);
        g_ProhibitTable = NULL;
    }

    return b;
}


BOOL
WINAPI
EmulatedEnumCallback (
    IN OUT  PMIG_TYPEOBJECTENUM ObjectEnum,
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      MIG_PARSEDPATTERN ParsedPattern,
    IN      ULONG_PTR Arg,
    IN      BOOL Abort
    )
{
    PACCESSIBILITY_ENUM_STATE state = (PACCESSIBILITY_ENUM_STATE) ObjectEnum->EtmHandle;
    BOOL result = FALSE;
    BOOL cleanUpMemdb = TRUE;
    PCTSTR p;

    for (;;) {

        if (!Abort) {

            //
            // Begin or continue? If the EtmHandle is NULL, begin. Otherwise, continue.
            //

            if (!state) {
                state = (PACCESSIBILITY_ENUM_STATE) MemAllocUninit (sizeof (ACCESSIBILITY_ENUM_STATE));
                if (!state) {
                    MYASSERT (FALSE);
                    return FALSE;
                }

                ObjectEnum->EtmHandle = (LONG_PTR) state;

                result = MemDbEnumFirst (
                            &state->EnumStruct,
                            TEXT("~Accessibility\\*"),
                            ENUMFLAG_NORMAL,
                            1,
                            MEMDB_LAST_LEVEL
                            );

            } else {
                result = MemDbEnumNext (&state->EnumStruct);
            }

            //
            // If an item was found, populate the enum struct. Otherwise, set
            // Abort to TRUE to clean up.
            //

            if (result) {
                //
                // Test against pattern
                //

                if (!IsmParsedPatternMatch (ParsedPattern, 0, state->EnumStruct.KeyName)) {
                    continue;
                }

                MYASSERT ((ObjectEnum->ObjectTypeId & (~PLATFORM_MASK)) == g_RegistryTypeId);

                ObjectEnum->ObjectName = state->EnumStruct.KeyName;
                state->RegType = state->EnumStruct.Value;

                //
                // Fill in node, leaf and details
                //

                IsmDestroyObjectString (ObjectEnum->ObjectNode);
                IsmDestroyObjectString (ObjectEnum->ObjectLeaf);
                IsmReleaseMemory (ObjectEnum->NativeObjectName);

                IsmCreateObjectStringsFromHandle (
                    ObjectEnum->ObjectName,
                    &ObjectEnum->ObjectNode,
                    &ObjectEnum->ObjectLeaf
                    );

                MYASSERT (ObjectEnum->ObjectNode);

                ObjectEnum->Level = 0;

                p = _tcschr (ObjectEnum->ObjectNode, TEXT('\\'));
                while (p) {
                    ObjectEnum->Level++;
                    p = _tcschr (p + 1, TEXT('\\'));
                }

                ObjectEnum->SubLevel = 0;

                if (ObjectEnum->ObjectLeaf) {
                    ObjectEnum->IsNode = FALSE;
                    ObjectEnum->IsLeaf = TRUE;
                } else {
                    ObjectEnum->IsNode = TRUE;
                    ObjectEnum->IsLeaf = FALSE;
                }

                if (state->RegType) {
                    ObjectEnum->Details.DetailsSize = sizeof (state->RegType);
                    ObjectEnum->Details.DetailsData = &state->RegType;
                } else {
                    ObjectEnum->Details.DetailsSize = 0;
                    ObjectEnum->Details.DetailsData = NULL;
                }

                //
                // Rely on base type to get the native object name
                //

                ObjectEnum->NativeObjectName = IsmGetNativeObjectName (
                                                    ObjectEnum->ObjectTypeId,
                                                    ObjectEnum->ObjectName
                                                    );


            } else {
                Abort = TRUE;
                cleanUpMemdb = FALSE;
            }
        }

        if (Abort) {
            //
            // Clean up our enum struct
            //

            if (state) {
                if (cleanUpMemdb) {
                    MemDbAbortEnum (&state->EnumStruct);
                }

                IsmDestroyObjectString (ObjectEnum->ObjectNode);
                ObjectEnum->ObjectNode = NULL;
                IsmDestroyObjectString (ObjectEnum->ObjectLeaf);
                ObjectEnum->ObjectLeaf = NULL;
                IsmReleaseMemory (ObjectEnum->NativeObjectName);
                ObjectEnum->NativeObjectName = NULL;
                FreeAlloc (state);
            }

            // return value ignored in Abort case, and ObjectEnum is zeroed by the ISM
        }

        break;
    }

    return result;
}


BOOL
WINAPI
AcquireAccessibilityFlags(
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit,
    OUT     PMIG_CONTENT *NewObjectContent,         CALLER_INITIALIZED OPTIONAL
    IN      BOOL ReleaseContent,
    IN      ULONG_PTR Arg
    )
{
    BOOL result = TRUE;
    PDWORD details;
    PMIG_CONTENT ourContent;
    PCTSTR memdbNode;

    //
    // Is this object in our hash table?
    //

    if (ContentType == CONTENTTYPE_FILE) {
        DEBUGMSG ((DBG_ERROR, "Accessibility content cannot be saved to a file"));
        result = FALSE;
    } else {

        memdbNode = JoinPaths (TEXT("~Accessibility"), ObjectName);

        if (MemDbTestKey (memdbNode)) {

            //
            // Alloc updated content struct
            //

            ourContent = MemAllocZeroed (sizeof (MIG_CONTENT) + sizeof (DWORD));
            ourContent->EtmHandle = ourContent;
            details = (PDWORD) (ourContent + 1);

            //
            // Get the content from memdb
            //

            ourContent->MemoryContent.ContentBytes = MemDbGetUnorderedBlob (
                                                            memdbNode,
                                                            0,
                                                            &ourContent->MemoryContent.ContentSize
                                                            );

            if (ourContent->MemoryContent.ContentBytes) {
                MemDbGetValue (memdbNode, details);

                ourContent->Details.DetailsSize = sizeof (DWORD);
                ourContent->Details.DetailsData = details;

            } else {
                ourContent->MemoryContent.ContentSize = 0;

                ourContent->Details.DetailsSize = 0;
                ourContent->Details.DetailsData = NULL;
            }

            ourContent->ContentInFile = FALSE;

            //
            // Pass it to ISM
            //

            *NewObjectContent = ourContent;

        }

        FreePathString (memdbNode);
    }

    return result;      // always TRUE unless an error occurred
}

VOID
WINAPI
ReleaseAccessibilityFlags(
    IN      PMIG_CONTENT ObjectContent
    )
{
    //
    // This callback is called to free the content we allocated above.
    //

    if (ObjectContent->MemoryContent.ContentBytes) {
        MemDbReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
    }

    FreeAlloc ((PMIG_CONTENT) ObjectContent->EtmHandle);
}


BOOL
WINAPI
AccessibilitySourceInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    if (!g_RegistryTypeId) {
        g_RegistryTypeId = IsmGetObjectTypeId (S_REGISTRYTYPE);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\dbattrib.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    dbattrib.c

Abstract:

    This source implements attribute functions used by MigDb

Author:

    Calin Negreanu (calinn) 07-Jan-1998

Revision History:

  28-May-1999   ovidiut     Added SECTIONKEY attribute
  22-Apr-1999   jimschm     Added UPTOBIN*VER attributes
  07-Jan-1999   jimschm     Added HASVERSION attribute
  18-May-1998   jimschm     Added INPARENTDIR attribute
  08-Apr-1998   calinn      Added two more attributes (ExeType and Description)
  29-Jan-1998   calinn      Modified CheckSum and FileSize to work with hex numbers
  19-Jan-1998   calinn      added CheckSum attribute

--*/

#include "pch.h"
#include "logmsg.h"
#include "osfiles.h"

/*++

Macro Expansion List Description:

  ATTRIBUTE_FUNCTIONS lists all valid attributes to query for a specific file.
  They are used by migdb in it's attempt to locate files.

Line Syntax:

   DEFMAC(AttribFn, AttribName, ReqArgs)

Arguments:

   AttribFn   - This is a boolean function that returnes TRUE if a specified file has
                the specified attribute. You must implement a function with this name
                and required parameters.

   AttribName - This is the string that identifies the attribute function. It should
                have the same value as listed in migdb.inf

   ReqArgs    - Specifies the number of args that are required for the action.  Used
                by the parser.

Variables Generated From List:

   g_AttributeFunctions - do not touch!

For accessing the array there are the following functions:

   MigDb_GetAttributeAddr
   MigDb_GetAttributeIdx
   MigDb_GetAttributeName
   MigDb_GetReqArgCount

--*/

#define ATTRIBUTE_FUNCTIONS        \
        DEFMAC(CompanyName,         COMPANYNAME,        1)  \
        DEFMAC(FileDescription,     FILEDESCRIPTION,    1)  \
        DEFMAC(FileVersion,         FILEVERSION,        1)  \
        DEFMAC(InternalName,        INTERNALNAME,       1)  \
        DEFMAC(LegalCopyright,      LEGALCOPYRIGHT,     1)  \
        DEFMAC(OriginalFilename,    ORIGINALFILENAME,   1)  \
        DEFMAC(ProductName,         PRODUCTNAME,        1)  \
        DEFMAC(ProductVersion,      PRODUCTVERSION,     1)  \
        DEFMAC(FileSize,            FILESIZE,           1)  \
        DEFMAC(IsMsBinary,          ISMSBINARY,         0)  \
        DEFMAC(CheckSum,            CHECKSUM,           1)  \
        DEFMAC(ExeType,             EXETYPE,            1)  \
        DEFMAC(Description,         DESCRIPTION,        1)  \
        DEFMAC(HasVersion,          HASVERSION,         0)  \
        DEFMAC(BinFileVer,          BINFILEVER,         1)  \
        DEFMAC(BinProductVer,       BINPRODUCTVER,      1)  \
        DEFMAC(FileDateHi,          FILEDATEHI,         1)  \
        DEFMAC(FileDateLo,          FILEDATELO,         1)  \
        DEFMAC(FileVerOs,           FILEVEROS,          1)  \
        DEFMAC(FileVerType,         FILEVERTYPE,        1)  \
        DEFMAC(SizeCheckSum,        FC,                 2)  \
        DEFMAC(UpToBinProductVer,   UPTOBINPRODUCTVER,  1)  \
        DEFMAC(UpToBinFileVer,      UPTOBINFILEVER,     1)  \


typedef struct {
    PCTSTR AttributeName;
    PATTRIBUTE_PROTOTYPE AttributeFunction;
    UINT RequiredArgs;
} ATTRIBUTE_STRUCT, *PATTRIBUTE_STRUCT;

//
// Declare the attribute functions
//
#define DEFMAC(fn,id,reqargs) ATTRIBUTE_PROTOTYPE fn;
ATTRIBUTE_FUNCTIONS
#undef DEFMAC

//
// Declare a global array of functions and name identifiers for attribute functions
//
#define DEFMAC(fn,id,regargs) {TEXT(#id), fn, regargs},
static ATTRIBUTE_STRUCT g_AttributeFunctions[] = {
                              ATTRIBUTE_FUNCTIONS
                              {NULL, NULL}
                              };
#undef DEFMAC

BOOL
pAlwaysFalseAttribute (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return FALSE;
}

PATTRIBUTE_PROTOTYPE
MigDb_GetAttributeAddr (
    IN      INT AttributeIdx
    )
/*++

Routine Description:

  MigDb_GetAttributeAddr returns the address of the attribute function based on the attribute index

Arguments:

  AttributeIdx - Attribute index.

Return value:

  Attribute function address. Note that no checking is made so the address returned could be invalid.
  This is not a problem since the parsing code did the right job.

--*/
{
    if (AttributeIdx == -1) {
        return &pAlwaysFalseAttribute;
    }

    return g_AttributeFunctions[AttributeIdx].AttributeFunction;
}

INT
MigDb_GetAttributeIdx (
    IN      PCTSTR AttributeName
    )
/*++

Routine Description:

  MigDb_GetAttributeIdx returns the attribute index based on the attribute name

Arguments:

  AttributeName - Attribute name.

Return value:

  Attribute index. If the name is not found, the index returned is -1.

--*/
{
    PATTRIBUTE_STRUCT p = g_AttributeFunctions;
    INT i = 0;
    while (p->AttributeName != NULL) {
        if (StringIMatch (p->AttributeName, AttributeName)) {
            return i;
        }
        p++;
        i++;
    }
    return -1;
}

PCTSTR
MigDb_GetAttributeName (
    IN      INT AttributeIdx
    )
/*++

Routine Description:

  MigDb_GetAttributeName returns the name of an attribute based on the attribute index

Arguments:

  AttributeIdx - Attribute index.

Return value:

  Attribute name. Note that no checking is made so the returned pointer could be invalid.
  This is not a problem since the parsing code did the right job.

--*/
{
    if (AttributeIdx == -1) {
        return TEXT("nul");
    }

    return g_AttributeFunctions[AttributeIdx].AttributeName;
}

UINT
MigDb_GetReqArgCount (
    IN      INT AttributeIndex
    )

/*++

Routine Description:

  MigDb_GetReqArgCount is called by the migdb parser to get the required
  argument count.  When the parser sees arguments that lack the required
  arguments, it skips them.

Arguments:

  Index - Specifies the argument index

Return Value:

  The required argument count, which can be zero or more.

--*/

{
    if (AttributeIndex == -1) {
        return 0;
    }

    return g_AttributeFunctions[AttributeIndex].RequiredArgs;
}

ULONGLONG
GetBinFileVer (
    IN      PCTSTR FileName
    )
{
    VRVALUE_ENUM Version;
    ULONGLONG result = 0;

    if (VrCreateEnumStruct (&Version, FileName)) {
        result = VrGetBinaryFileVersion (&Version);
        VrDestroyEnumStruct (&Version);
    }
    return result;
}

ULONGLONG
GetBinProductVer (
    IN      PCTSTR FileName
    )
{
    VRVALUE_ENUM Version;
    ULONGLONG result = 0;

    if (VrCreateEnumStruct (&Version, FileName)) {
        result = VrGetBinaryProductVersion (&Version);
        VrDestroyEnumStruct (&Version);
    }
    return result;
}

DWORD
GetFileDateHi (
    IN      PCTSTR FileName
    )
{
    VRVALUE_ENUM Version;
    DWORD result = 0;

    if (VrCreateEnumStruct (&Version, FileName)) {
        result = VrGetBinaryFileDateHi (&Version);
        VrDestroyEnumStruct (&Version);
    }
    return result;
}

DWORD
GetFileDateLo (
    IN      PCTSTR FileName
    )
{
    VRVALUE_ENUM Version;
    DWORD result = 0;

    if (VrCreateEnumStruct (&Version, FileName)) {
        result = VrGetBinaryFileDateLo (&Version);
        VrDestroyEnumStruct (&Version);
    }
    return result;
}

DWORD
GetFileVerOs (
    IN      PCTSTR FileName
    )
{
    VRVALUE_ENUM Version;
    DWORD result = 0;

    if (VrCreateEnumStruct (&Version, FileName)) {
        result = VrGetBinaryOsVersion (&Version);
        VrDestroyEnumStruct (&Version);
    }
    return result;
}

DWORD
GetFileVerType (
    IN      PCTSTR FileName
    )
{
    VRVALUE_ENUM Version;
    DWORD result = 0;

    if (VrCreateEnumStruct (&Version, FileName)) {
        result = VrGetBinaryFileType (&Version);
        VrDestroyEnumStruct (&Version);
    }
    return result;
}

/*++
  CompanyName, FileDescription, FileVersion, InternalName, LegalCopyright, OriginalFilename,
  ProductName, ProductVersion are attribute functions that are querying the version structure
  for their specific entries. They all return TRUE if the specific entry has specific value,
  FALSE otherwise.
--*/

BOOL
CompanyName (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("CompanyName"), Args);
}

BOOL
FileDescription (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("FileDescription"), Args);
}

BOOL
FileVersion (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("FileVersion"), Args);
}

BOOL
InternalName (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("InternalName"), Args);
}

BOOL
LegalCopyright (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("LegalCopyright"), Args);
}

BOOL
OriginalFilename (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("OriginalFilename"), Args);
}

BOOL
ProductName (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("ProductName"), Args);
}

BOOL
ProductVersion (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("ProductVersion"), Args);
}

BOOL
FileSize (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
/*++

Routine Description:

  FileSize checks for the size of a file.

Arguments:

  Params - See definition.

  Args   - MultiSz. First Sz is the file size we need to check.

Return value:

  TRUE  - the file size matches Args
  FALSE - otherwise

--*/
{
    DWORD fileSize;

    _stscanf (Args, TEXT("%lx"), &fileSize);
    if (fileSize == AttribParams->FileParams->FindData->nFileSizeLow) {
        return TRUE;
    }
    else {
        return (_ttoi64 (Args) == AttribParams->FileParams->FindData->nFileSizeLow);
    }
}

BOOL
IsMsBinary (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
/*++

Routine Description:

  IsMsBinary checks to see if a certain file is Microsoft stuff. For 32 bit modules
  we query CompanyName for "Microsoft" somewhere inside. For other modules we are
  relying on InWinDir attribute

Arguments:

  Params - See definition.

  Args   - MultiSz. Not used.

Return value:

  TRUE  - the file is MS stuff
  FALSE - otherwise

--*/
{
    return VrCheckFileVersion (AttribParams->FileParams->NativeObjectName, TEXT("CompanyName"), TEXT("*Microsoft*"));
}

BOOL
CheckSum (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
/*++

Routine Description:

  CheckSum returns TRUE if file's checksum equals the value in Args

Arguments:

  Params - See definition.

  Args   - checksum value.

Return value:

  TRUE  - the file's checksum equals the value in Args
  FALSE - otherwise

--*/
{
    UINT   checkSum   = 0;
    UINT   oldSum     = 0;

    checkSum = MdGetCheckSum (AttribParams->FileParams->NativeObjectName);

    _stscanf (Args, TEXT("%lx"), &oldSum);
    if (oldSum == checkSum) {
        return TRUE;
    }
    else {
        return (_ttoi64 (Args) == checkSum);
    }
}

BOOL
SizeCheckSum (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
/*++

Routine Description:

  Returns TRUE if file's size equals first arg and checksum equals to the second arg

Arguments:

  Params - See definition.

  Args   - checksum value.

Return value:

  TRUE  - the file's checksum equals the value in Args
  FALSE - otherwise

--*/
{
    PCTSTR currArg = Args;

    if (!FileSize (AttribParams, currArg)) {
        return FALSE;
    }
    currArg = GetEndOfString (currArg);
    if (!currArg) {
        return FALSE;
    }
    currArg = _tcsinc (currArg);
    if (!currArg) {
        return FALSE;
    }
    return (CheckSum (AttribParams, currArg));
}

PTSTR g_ExeTypes[] = {
    TEXT("NONE"),
    TEXT("DOS"),
    TEXT("WIN16"),
    TEXT("WIN32")
};

BOOL
ExeType (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
/*++

Routine Description:

  ExeType returns TRUE if file's type is according with Args. This can be:
  NONE, DOS, WIN16, WIN32

Arguments:

  Params - See definition.

  Args   - type of module.

Return value:

  TRUE  - the file's type is the same as Args
  FALSE - otherwise

--*/
{
    return IsPatternMatch (Args, g_ExeTypes[MdGetModuleType (AttribParams->FileParams->NativeObjectName)]);
}


BOOL
Description (
    PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
/*++

Routine Description:

  Description returns TRUE if file's description matches Args

Arguments:

  Params - See definition.

  Args   - description

Return value:

  TRUE  - the file's description matches Args
  FALSE - otherwise

--*/
{
    PCTSTR descr = NULL;
    BOOL result = FALSE;

    descr = MdGet16ModuleDescription (AttribParams->FileParams->NativeObjectName);

    if (descr != NULL) {
        result = IsPatternMatch (Args, descr);
        FreePathString (descr);
    }
    return result;
}

BOOL
HasVersion (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )

/*++

Routine Description:

  HasVersion determines if a file has any entries in its version
  stamp.

Arguments:

  Params - Specifies the helper params that give the files to test.
  Args   - Unused

Return Value:

  TRUE if the specified file has an entry in its version stamp,
  FALSE otherwsie.

--*/

{
    VRVALUE_ENUM Version;
    BOOL Result = FALSE;

    if (VrCreateEnumStruct (&Version, AttribParams->FileParams->NativeObjectName)) {
        Result = TRUE;
        VrDestroyEnumStruct (&Version);
    }

    return Result;
}

BOOL
pHexMatch (
    IN      DWORD NewValue,
    IN      PCTSTR Args
    )
{
    DWORD oldValue;

    _stscanf (Args, TEXT("%lx"), &oldValue);
    if (oldValue == NewValue) {
        return TRUE;
    }
    else {
        return (_ttoi64 (Args) == NewValue);
    }
}

BOOL
pConvertDotStringToValue (
    IN      PCTSTR String,
    OUT     ULONGLONG *Value
    )
{
    PWORD valueIdx;
    UINT index;

    valueIdx = (PWORD) Value + 3;

    for (index = 0 ; index < 4 ; index++) {

        if (*String == 0) {
            *valueIdx = 0xFFFF;
            valueIdx--;
            continue;
        }

        *valueIdx = (WORD) _tcstoul (String, &(PTSTR) String, 10);
        if (*String && (_tcsnextc (String) != TEXT('.'))) {
            return FALSE;
        }

        String = _tcsinc (String);
        valueIdx--;
    }

    return TRUE;
}

BOOL
pMaskHexMatch (
    IN      ULONGLONG NewValue,
    IN      PCTSTR Args
    )
{
    ULONGLONG oldValue = 0;
    ULONGLONG mask = 0;
    PWORD maskIdx;
    PWORD valueIdx;
    UINT index;

    maskIdx = (PWORD)&mask + 3;
    valueIdx = (PWORD)&oldValue + 3;
    index = 0;

    while (Args && *Args) {

        if (index >= 4) {
            return FALSE;
        }

        *valueIdx = (WORD) _tcstoul ((PTSTR)Args, &((PTSTR)Args), 10);

        if (*Args) {
            if (_tcsnextc (Args) != TEXT('.')) {
                return FALSE;
            }

            Args = _tcsinc (Args);
        }

        *maskIdx = 65535;

        valueIdx--;
        maskIdx--;
        index++;
    }

    NewValue = NewValue & mask;

    return (oldValue == NewValue);
}

BOOL
BinFileVer (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return pMaskHexMatch (GetBinFileVer (AttribParams->FileParams->NativeObjectName), Args);
}

BOOL
BinProductVer (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return pMaskHexMatch (GetBinProductVer (AttribParams->FileParams->NativeObjectName), Args);
}

BOOL
FileDateHi (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return pHexMatch (GetFileDateHi (AttribParams->FileParams->NativeObjectName), Args);
}

BOOL
FileDateLo (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return pHexMatch (GetFileDateLo (AttribParams->FileParams->NativeObjectName), Args);
}

BOOL
FileVerOs (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return pHexMatch (GetFileVerOs (AttribParams->FileParams->NativeObjectName), Args);
}

BOOL
FileVerType (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    return pHexMatch (GetFileVerType (AttribParams->FileParams->NativeObjectName), Args);
}


BOOL
UpToBinProductVer (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    VRVALUE_ENUM Version;
    ULONGLONG versionStampValue = 0;
    ULONGLONG maxValue;

    if (VrCreateEnumStruct (&Version, AttribParams->FileParams->NativeObjectName)) {
        versionStampValue = VrGetBinaryProductVersion (&Version);
        VrDestroyEnumStruct (&Version);
    } else {
        return FALSE;
    }

    if (!pConvertDotStringToValue (Args, &maxValue)) {
        DEBUGMSG ((DBG_WHOOPS, "Invalid value of %s caused UpToBinProductVer to fail", Args));
        return FALSE;
    }

    return versionStampValue <= maxValue;
}


BOOL
UpToBinFileVer (
    IN      PDBATTRIB_PARAMS AttribParams,
    IN      PCTSTR Args
    )
{
    VRVALUE_ENUM Version;
    ULONGLONG versionStampValue = 0;
    ULONGLONG maxValue;

    if (VrCreateEnumStruct (&Version, AttribParams->FileParams->NativeObjectName)) {
        versionStampValue = VrGetBinaryFileVersion (&Version);
        VrDestroyEnumStruct (&Version);
    } else {
        return FALSE;
    }

    if (!pConvertDotStringToValue (Args, &maxValue)) {
        DEBUGMSG ((DBG_WHOOPS, "Invalid value of %s caused UpToBinFileVer to fail", Args));
        return FALSE;
    }

    return versionStampValue <= maxValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\dbaction.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    dbaction.c

Abstract:

    This source implements action functions used by MigDb. There are two types
    of action functions here as the third parameter of the macro list is TRUE
    or FALSE.
    First type of action function is called whenever an action is triggered
    during file scanning. The second type of action function is called at the
    end of file scanning if the associated action was not triggered during
    file scanning phase.

Author:

    Calin Negreanu (calinn) 07-Jan-1998

Revision History:

  marcw     31-Aug-1999 Added BlockingHardware
  ovidiut   20-Jul-1999 Added Ignore
  ovidiut   28-May-1999 Added IniFileMappings
  marcw     23-Sep-1998 Added BlockingVirusScanner
  jimschm   13-Aug-1998 Added CompatibleFiles
  jimschm   19-May-1998 Added MinorProblems_NoLinkRequired
  jimschm   27-Feb-1998 Added UninstallSections
  calinn    18-Jan-1998 Added CompatibleModules action

--*/

#include "pch.h"
#include "logmsg.h"
#include "osfiles.h"

/*++

Macro Expansion List Description:

  GATHER_DATA_FUNCTIONS and ACTION_FUNCTIONS lists all valid actions to be performed
  by migdb when a context is met. Meeting a context means that all the sections
  associated with the context are satisfied (usually there is only one section).
  The difference is that GATHER_DATA_FUNCTIONS are called even if some function already
  handles a file.

Line Syntax:

   DEFMAC(ActionFn, ActionName, CallWhenTriggered, CanHandleVirtualFiles)

Arguments:

   ActionFn   - This is a boolean function that returnes TRUE if the specified action
                could be performed. It should return FALSE only if a serious error
                occures. You must implement a function with this name and required
                parameters.

   ActionName - This is the string that identifies the action function. It should
                have the same value as listed in migdb.inf.  This arg is declared
                as both a macro and the migdb.inf section name string.

   PatternFormat - The format in the INF for this section is the pattern format. The non
                pattern format is the file name followed by the attributes. The pattern
                format is the leaf pattern, node pattern and then the attributes.

   CallWhenTriggered - If the MigDbContext this action is associated with is triggered
                the action will be called if this field is TRUE, otherwise we will call
                the action at the end of file scan if the context was not triggered.

   CanHandleVirtualFiles - This is for treating files that are supposed to be in a fixed place
                but are not there (not installed or deleted). We need this in order to fix
                registry or links that point to this kind of files. A good example is backup.exe
                which is located in %ProgramFiles%\Accessories. The rules say that we should
                use ntbackup.exe instead but since this file is not existent we don't normalle fix
                registry settings pointing to this file. We do now, with this new variable

Variables Generated From List:

   g_ActionFunctions - do not touch!

For accessing the array there are the following functions:

   MigDb_GetActionAddr
   MigDb_GetActionIdx
   MigDb_GetActionName

--*/


/*
   Declare the macro list of action functions. If you need to add a new action just
   add a line in this list and implement the function.
*/
#define ACTION_FUNCTIONS        \
        DEFMAC(OsFiles,         TEXT("OsFiles"),            FALSE,  TRUE,   TRUE)  \
        DEFMAC(OsFiles,         TEXT("OsFilesPattern"),     TRUE,   TRUE,   TRUE)  \
        DEFMAC(NonCritical,     TEXT("NonCriticalFiles"),   TRUE,   TRUE,   TRUE)  \
        DEFMAC(OsFilesExcluded, TEXT("OsFilesExcluded"),    TRUE,   TRUE,   TRUE)  \


/*
   Declare the action functions
*/
#define DEFMAC(fn,id,pat,trig,call) ACTION_PROTOTYPE fn;
ACTION_FUNCTIONS
#undef DEFMAC


/*
   This is the structure used for handling action functions
*/
typedef struct {
    PCTSTR ActionName;
    PACTION_PROTOTYPE ActionFunction;
    BOOL PatternFormat;
    BOOL CallWhenTriggered;
    BOOL CallAlways;
} ACTION_STRUCT, *PACTION_STRUCT;


/*
   Declare a global array of functions and name identifiers for action functions
*/
#define DEFMAC(fn,id,pat,trig,call) {id,fn,pat,trig,call},
static ACTION_STRUCT g_ActionFunctions[] = {
                              ACTION_FUNCTIONS
                              {NULL, NULL, FALSE, FALSE, FALSE}
                              };
#undef DEFMAC

PACTION_PROTOTYPE
MigDb_GetActionAddr (
    IN      INT ActionIdx
    )

/*++

Routine Description:

  MigDb_GetActionAddr returns the address of the action function based on the action index

Arguments:

  ActionIdx - Action index.

Return value:

  Action function address. Note that no checking is made so the address returned could be invalid.
  This is not a problem since the parsing code did the right job.

--*/

{
    return g_ActionFunctions[ActionIdx].ActionFunction;
}

INT
MigDb_GetActionIdx (
    IN      PCTSTR ActionName
    )

/*++

Routine Description:

  MigDb_GetActionIdx returns the action index based on the action name

Arguments:

  ActionName - Action name.

Return value:

  Action index. If the name is not found, the index returned is -1.

--*/

{
    PACTION_STRUCT p = g_ActionFunctions;
    INT i = 0;
    while (p->ActionName != NULL) {
        if (StringIMatch (p->ActionName, ActionName)) {
            return i;
        }
        p++;
        i++;
    }
    return -1;
}

PCTSTR
MigDb_GetActionName (
    IN      INT ActionIdx
    )

/*++

Routine Description:

  MigDb_GetActionName returns the name of an action based on the action index

Arguments:

  ActionIdx - Action index.

Return value:

  Action name. Note that no checking is made so the returned pointer could be invalid.
  This is not a problem since the parsing code did the right job.

--*/

{
    return g_ActionFunctions[ActionIdx].ActionName;
}

BOOL
MigDb_IsPatternFormat (
    IN      INT ActionIdx
    )

/*++

Routine Description:

  MigDb_IsPatternFormat is called when we try to find what is the section format.

Arguments:

  ActionIdx - Action index.

Return value:

  TRUE if the format is pattern like, FALSE otherwise.

--*/

{
    return g_ActionFunctions[ActionIdx].PatternFormat;
}

BOOL
MigDb_CallWhenTriggered (
    IN      INT ActionIdx
    )

/*++

Routine Description:

  MigDb_CallWhenTriggered is called every time when an action is triggered. Will return
  TRUE is the associated action function needs to be called, FALSE otherwise.

Arguments:

  ActionIdx - Action index.

Return value:

  TRUE if the associated action function needs to be called, FALSE otherwise.

--*/

{
    return g_ActionFunctions[ActionIdx].CallWhenTriggered;
}

BOOL
MigDb_CallAlways (
    IN      INT ActionIdx
    )

/*++

Routine Description:

  MigDb_CallAlways returnes if an action should be called regardless of handled state.

Arguments:

  ActionIdx - Action index.

Return value:

  TRUE if the associated action should be called every time.

--*/

{
    return g_ActionFunctions[ActionIdx].CallAlways;
}

BOOL
OsFiles (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when an OS file is found. Basically the file gets deleted to
  make room for NT version.

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    MULTISZ_ENUM fileEnum;

    if (EnumFirstMultiSz (&fileEnum, (PCTSTR) Context->FileList.Buf)) {
        do {
            IsmSetAttributeOnObject (
                MIG_FILE_TYPE,
                fileEnum.CurrentString,
                g_OsFileAttribute
                );
        }
        while (EnumNextMultiSz (&fileEnum));
    }
    return TRUE;
}

BOOL
NonCritical (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when an non critical file is found.
  We are calling ISM to mark this file as NonCritical

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    MULTISZ_ENUM fileEnum;

    if (EnumFirstMultiSz (&fileEnum, (PCTSTR) Context->FileList.Buf)) {
        do {
            IsmMakeNonCriticalObject (
                MIG_FILE_TYPE,
                fileEnum.CurrentString
                );
        }
        while (EnumNextMultiSz (&fileEnum));
    }
    return TRUE;
}

BOOL
OsFilesExcluded (
    IN      PMIGDB_CONTEXT Context
    )

/*++

Routine Description:

  This is the action taken when an file that is not an OS file is found.
  Since this file might have the OS file attribute (due to patterns in os files)
  we are calling ISM to remove the OsFile attribute from this file

Arguments:

  Context - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    MULTISZ_ENUM fileEnum;

    if (EnumFirstMultiSz (&fileEnum, (PCTSTR) Context->FileList.Buf)) {
        do {
            IsmClearAttributeOnObject (
                MIG_FILE_TYPE,
                fileEnum.CurrentString,
                g_OsFileAttribute
                );
        }
        while (EnumNextMultiSz (&fileEnum));
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\cookies.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    cookies.c

Abstract:

    Implements the cookies type module, which abstracts physical access to
    cookies, and queues all cookies to be migrated when the cookies component
    is enabled.

Author:

    Calin Negreanu (calinn) 11 July 2000

Revision History:

    jimschm 12-Oct-2000 Substantial redesign to work around several limiations
                        in wininet apis

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include <wininet.h>

#define DBG_COOKIES     "Cookies"

//
// Strings
//

#define S_COOKIES_POOL_NAME     "Cookies"
#define S_COOKIES_NAME          TEXT("Cookies")
#define S_COOKIES_SHELL_FOLDER  TEXT("Cookies.CSIDL_COOKIES")

//
// Constants
//

#define MAX_COOKIE_FILE_SIZE    65536

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PCTSTR Pattern;
    HASHTABLE_ENUM HashData;
} COOKIES_ENUM, *PCOOKIES_ENUM;

//
// Globals
//

PMHANDLE g_CookiesPool = NULL;
BOOL g_DelayCookiesOp;
HASHTABLE g_CookiesTable;
MIG_OBJECTTYPEID g_CookieTypeId = 0;
GROWBUFFER g_CookieConversionBuff = INIT_GROWBUFFER;
PCTSTR g_Days[] = {
    TEXT("SUN"),
    TEXT("MON"),
    TEXT("TUE"),
    TEXT("WED"),
    TEXT("THU"),
    TEXT("FRI"),
    TEXT("SAT")
};

PCTSTR g_Months[] = {
    TEXT("JAN"),
    TEXT("FEB"),
    TEXT("MAR"),
    TEXT("APR"),
    TEXT("MAY"),
    TEXT("JUN"),
    TEXT("JUL"),
    TEXT("AUG"),
    TEXT("SEP"),
    TEXT("OCT"),
    TEXT("NOV"),
    TEXT("DEC")
};

typedef struct {
    PCTSTR Url;
    PCTSTR CookieName;
    PCTSTR CookieData;
    PCTSTR ExpirationString;
} COOKIE_ITEM, *PCOOKIE_ITEM;

typedef struct {
    // return value
    PCOOKIE_ITEM Item;

    // private enum members
    PCOOKIE_ITEM Array;
    UINT ArrayCount;
    UINT ArrayPos;
    INTERNET_CACHE_ENTRY_INFO *CacheEntry;
    HANDLE EnumHandle;
    GROWBUFFER CacheBuf;
    PMHANDLE Pool;

} COOKIE_ENUM, *PCOOKIE_ENUM;



//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Private prototypes
//

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstCookie;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextCookie;
TYPE_ABORTENUMPHYSICALOBJECT AbortCookieEnum;
TYPE_CONVERTOBJECTTOMULTISZ ConvertCookieToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToCookie;
TYPE_GETNATIVEOBJECTNAME GetNativeCookieName;
TYPE_ACQUIREPHYSICALOBJECT AcquireCookie;
TYPE_RELEASEPHYSICALOBJECT ReleaseCookie;
TYPE_DOESPHYSICALOBJECTEXIST DoesCookieExist;
TYPE_REMOVEPHYSICALOBJECT RemoveCookie;
TYPE_CREATEPHYSICALOBJECT CreateCookie;
TYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertCookieContentToUnicode;
TYPE_CONVERTOBJECTCONTENTTOANSI ConvertCookieContentToAnsi;
TYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedCookieContent;

BOOL
pEnumNextCookie (
    IN OUT  PCOOKIE_ENUM EnumPtr
    );

VOID
pAbortCookieEnum (
    IN      PCOOKIE_ENUM EnumPtr        ZEROED
    );

//
// Code
//

BOOL
CookiesInitialize (
    VOID
    )

/*++

Routine Description:

  CookiesInitialize is the ModuleInitialize entry point for the cookies
  module.

Arguments:

  None.

Return Value:

  TRUE if init succeeded, FALSE otherwise.

--*/

{
    g_CookiesTable = HtAllocEx (
                        CASE_SENSITIVE,
                        sizeof (PCTSTR),
                        DEFAULT_BUCKET_SIZE
                        );

    if (!g_CookiesTable) {
        return FALSE;
    }

    g_CookiesPool = PmCreateNamedPool (S_COOKIES_POOL_NAME);
    return (g_CookiesPool != NULL);
}


VOID
CookiesTerminate (
    VOID
    )

/*++

Routine Description:

  CookiesTerminate is the ModuleTerminate entry point for the cookies module.

Arguments:

  None.

Return Value:

  None.

--*/

{
    GbFree (&g_CookieConversionBuff);

    if (g_CookiesTable) {
        HtFree (g_CookiesTable);
        g_CookiesTable = NULL;
    }

    if (g_CookiesPool) {
        PmEmptyPool (g_CookiesPool);
        PmDestroyPool (g_CookiesPool);
        g_CookiesPool = NULL;
    }
}


VOID
WINAPI
CookiesEtmNewUserCreated (
    IN      PCTSTR UserName,
    IN      PCTSTR DomainName,
    IN      PCTSTR UserProfileRoot,
    IN      PSID UserSid
    )

/*++

Routine Description:

  CookiesEtmNewUserCreated is a callback that gets called when a new user
  account is created. In this case, we must delay the apply of cookies,
  because we can only apply to the current user.

Arguments:

  UserName        - Specifies the name of the user being created
  DomainName      - Specifies the NT domain name for the user (or NULL for no
                    domain)
  UserProfileRoot - Specifies the root path to the user profile directory
  UserSid         - Specifies the user's SID

Return Value:

  None.

--*/

{
    // a new user was created, the cookies operations need to be delayed
    CookiesTerminate ();
    g_DelayCookiesOp = TRUE;
}


BOOL
pGetCookiesPath (
    OUT     PTSTR Buffer
    )

/*++

Routine Description:

  pGetCookiesPath retreives the path to CSIDL_COOKIES. This path is needed
  for registration of a static exclusion (so that .txt files in CSIDL_COOKIES
  do not get processed).

Arguments:

  Buffer - Receives the path

Return Value:

  TRUE if the cookies directory was obtained, FALSE otherwise.

--*/

{
    HRESULT result;
    LPITEMIDLIST pidl;
    BOOL b;
    LPMALLOC malloc;

    result = SHGetMalloc (&malloc);
    if (result != S_OK) {
        return FALSE;
    }

    result = SHGetSpecialFolderLocation (NULL, CSIDL_COOKIES, &pidl);

    if (result != S_OK) {
        return FALSE;
    }

    b = SHGetPathFromIDList (pidl, Buffer);

    IMalloc_Free (malloc, pidl);

    return b;
}



/*++

  The following routines parse a cookie TXT file (specifically, the wininet
  form of a cookie file). They are fairly straight-forward.

--*/


BOOL
pGetNextLineFromFile (
    IN OUT  PCSTR *CurrentPos,
    OUT     PCSTR *LineStart,
    OUT     PCSTR *LineEnd,
    IN      PCSTR FileEnd
    )
{
    PCSTR pos;

    pos = *CurrentPos;
    *LineEnd = NULL;

    //
    // Find the first non-whitespace character
    //

    while (pos < FileEnd) {
        if (!_ismbcspace (_mbsnextc (pos))) {
            break;
        }

        pos = _mbsinc (pos);
    }

    *LineStart = pos;

    //
    // Find the end
    //

    if (pos < FileEnd) {
        pos = _mbsinc (pos);

        while (pos < FileEnd) {
            if (*pos == '\r' || *pos == '\n') {
                break;
            }

            pos = _mbsinc (pos);
        }

        *LineEnd = pos;
    }

    *CurrentPos = pos;

    return *LineEnd != NULL;
}


PCTSTR
pConvertStrToTchar (
    IN      PMHANDLE Pool,          OPTIONAL
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
#ifdef UNICODE
    return DbcsToUnicodeN (Pool, Start, CharCountABA (Start, End));
#else

    PTSTR dupStr;

    dupStr = AllocTextEx (Pool, (HALF_PTR) ((PBYTE) End - (PBYTE) Start) + 1);
    StringCopyAB (dupStr, Start, End);

    return dupStr;

#endif
}


VOID
pFreeUtilString (
    IN      PCTSTR String
    )
{
#ifdef UNICODE
    FreeConvertedStr (String);
#else
    FreeText (String);
#endif
}


PCOOKIE_ITEM
pGetCookiesFromFile (
    IN      PCTSTR LocalFileName,
    IN      PMHANDLE CookiePool,
    OUT     UINT *ItemCount
    )
{
    LONGLONG fileSize;
    HANDLE file;
    HANDLE map;
    PCSTR cookieFile;
    PCSTR currentPos;
    PCSTR lineStart;
    PCSTR lineEnd;
    PCSTR endOfFile;
    PCTSTR convertedStr;
    PCTSTR cookieName;
    PCTSTR cookieData;
    PCTSTR cookieUrl;
    GROWBUFFER tempBuf = INIT_GROWBUFFER;
    PCOOKIE_ITEM cookieArray;
    BOOL b;
    FILETIME expireTime;
    SYSTEMTIME cookieSysTime;
    TCHAR dateBuf[64];
    PTSTR dateBufEnd;

    // Let's check the size of the file. We don't want a malformed cookie
    // file to force us to map a huge file into memory.
    fileSize = BfGetFileSize (LocalFileName);
    if (fileSize > MAX_COOKIE_FILE_SIZE) {
        return NULL;
    }

    cookieFile = MapFileIntoMemory (LocalFileName, &file, &map);
    if (!cookieFile) {
        return NULL;
    }

    //
    // Parse the file
    //

    endOfFile = cookieFile + GetFileSize (file, NULL);
    currentPos = cookieFile;

    do {
        //
        // Get the cookie name, cookie data, and url. Then skip a line. Then
        // get the expiration low and high values.
        //

        // cookie name
        b = pGetNextLineFromFile (&currentPos, &lineStart, &lineEnd, endOfFile);
        if (b) {
            cookieName = pConvertStrToTchar (CookiePool, lineStart, lineEnd);
        }

        // cookie data
        b = b && pGetNextLineFromFile (&currentPos, &lineStart, &lineEnd, endOfFile);
        if (b) {
            cookieData = pConvertStrToTchar (CookiePool, lineStart, lineEnd);
        }

        // url
        b = b && pGetNextLineFromFile (&currentPos, &lineStart, &lineEnd, endOfFile);
        if (b) {
            convertedStr = pConvertStrToTchar (NULL, lineStart, lineEnd);
            cookieUrl = JoinTextEx (CookiePool, TEXT("http://"), convertedStr, NULL, 0, NULL);
            pFreeUtilString (convertedStr);
        }

        // don't care about the next line
        b = b && pGetNextLineFromFile (&currentPos, &lineStart, &lineEnd, endOfFile);

        // low DWORD for expire time
        b = b && pGetNextLineFromFile (&currentPos, &lineStart, &lineEnd, endOfFile);
        if (b) {
            convertedStr = pConvertStrToTchar (NULL, lineStart, lineEnd);
            expireTime.dwLowDateTime = _tcstoul (convertedStr, NULL, 10);
            pFreeUtilString (convertedStr);
        }

        // high DWORD for expire time
        b = b && pGetNextLineFromFile (&currentPos, &lineStart, &lineEnd, endOfFile);
        if (b) {
            convertedStr = pConvertStrToTchar (NULL, lineStart, lineEnd);
            expireTime.dwHighDateTime = _tcstoul (convertedStr, NULL, 10);
            pFreeUtilString (convertedStr);

            //
            // Got the cookie; now find a "*" line (the terminator for the cookie)
            //

            while (pGetNextLineFromFile (&currentPos, &lineStart, &lineEnd, endOfFile)) {
                if (StringMatchABA ("*", lineStart, lineEnd)) {
                    break;
                }
            }

            //
            // Create an expiration string
            //

            if (FileTimeToSystemTime (&expireTime, &cookieSysTime)) {
                //
                // Need to make something like this: "expires = Sat, 01-Jan-2000 00:00:00 GMT"
                //

                dateBufEnd = StringCopy (dateBuf, TEXT("expires = "));

                dateBufEnd += wsprintf (
                                    dateBufEnd,
                                    TEXT("%s, %02u-%s-%04u %02u:%02u:%02u GMT"),
                                    g_Days[cookieSysTime.wDayOfWeek],
                                    (UINT) cookieSysTime.wDay,
                                    g_Months[cookieSysTime.wMonth - 1],
                                    (UINT) cookieSysTime.wYear,
                                    cookieSysTime.wHour,
                                    cookieSysTime.wMinute,
                                    cookieSysTime.wSecond
                                    );
            } else {
                *dateBuf = 0;
            }

            //
            // Add an entry to the array of cookie items
            //

            cookieArray = (PCOOKIE_ITEM) GbGrow (&tempBuf, sizeof (COOKIE_ITEM));

            cookieArray->Url = cookieUrl;
            cookieArray->CookieName = cookieName;
            cookieArray->CookieData = cookieData;
            cookieArray->ExpirationString = PmDuplicateString (CookiePool, dateBuf);
        }

    } while (b);

    //
    // Transfer array to caller's pool
    //

    *ItemCount = tempBuf.End / sizeof (COOKIE_ITEM);

    if (tempBuf.End) {
        cookieArray = (PCOOKIE_ITEM) PmDuplicateMemory (CookiePool, tempBuf.Buf, tempBuf.End);
    } else {
        cookieArray = NULL;
    }

    //
    // Clean up
    //

    GbFree (&tempBuf);

    UnmapFile (cookieFile, map, file);

    return cookieArray;
}


MIG_OBJECTSTRINGHANDLE
pCreateCookieHandle (
    IN      PCTSTR Url,
    IN      PCTSTR CookieName
    )

/*++

Routine Description:

  pCreateCookieHandle generates a MIG_OBJECTSTRINGHANDLE for a cookie object.
  This routine decorates the CookieName leaf so that case is preserved.

Arguments:

  Url        - Specifies the node portion (the URL associated with the cookie)
  CookieName - Specifies the case-sensitive name of the cookie

Return Value:

  A handle to the cookie object (which may be cast to a PCTSTR), or NULL if
  an error occurs.

--*/

{
    PTSTR buffer;
    PTSTR p;
    PCTSTR q;
    MIG_OBJECTSTRINGHANDLE result;
    CHARTYPE ch;

    //
    // Cobra object strings are case-insensitive, but CookieName is not. Here
    // we convert CookieName into all lower-case, decorating with a caret to
    // indicate uppercase
    //

    buffer = AllocText (TcharCount (CookieName) * 2 + 1);

    q = CookieName;
    p = buffer;

    while (*q) {
        ch = (CHARTYPE) _tcsnextc (q);

        if (_istupper (ch) || ch == TEXT('#')) {
            *p++ = TEXT('#');
        }

#ifndef UNICODE
        if (IsLeadByte (q)) {
            *p++ = *q++;
        }
#endif

        *p++ = *q++;
    }

    *p = 0;
    CharLower (buffer);

    result = IsmCreateObjectHandle (Url, buffer);

    FreeText (buffer);

    return result;
}


BOOL
pCreateCookieStrings (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PCTSTR *Url,
    OUT     PCTSTR *Cookie
    )

/*++

Routine Description:

  pCreateCookieStrings converts an object handle into the URL and cookie name
  strings. It performs decoding of the decoration needed to support
  case-sensitive cookie names.

Arguments:

  ObjectName - Specifies the encoded object name
  Url        - Receives the URL string, unencoded
  Cookie     - Receives the cookie name, unencoded

Return Value:

  TRUE of the object was converted to strings, FALSE otherwise. The caller
  must call pDestroyCookieStrings to clean up Url and Cookie.

--*/

{
    PCTSTR node;
    PCTSTR leaf;
    PTSTR buffer;
    PTSTR p;
    PCTSTR q;
    PTSTR p2;

    //
    // Cobra object strings are case-insensitive, but CookieName is not.
    // Therefore, we must convert the string from an encoded lowercase format
    // into the original form.
    //

    IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf);

    if (!node || !leaf) {
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);

        return FALSE;
    }

    *Url = node;

    //
    // Decode Cookie
    //

    buffer = AllocText (TcharCount (leaf) + 1);
    CharLower ((PTSTR) leaf);

    q = leaf;
    p = buffer;

    while (*q) {
        if (_tcsnextc (q) == TEXT('#')) {
            q = _tcsinc (q);
            if (*q == 0) {
                break;
            }

            p2 = p;
        } else {
            p2 = NULL;
        }

#ifndef UNICODE
        if (IsLeadByte (q)) {
            *p++ = *q++;
        }
#endif

        *p++ = *q++;

        if (p2) {
            *p = 0;
            CharUpper (p2);
        }
    }

    *p = 0;
    *Cookie = buffer;
    IsmDestroyObjectString (leaf);

    return TRUE;
}


VOID
pDestroyCookieStrings (
    IN      PCTSTR Url,
    IN      PCTSTR CookieName
    )
{
    IsmDestroyObjectString (Url);
    FreeText (CookieName);
}

VOID
pAbortCookieEnum (
    IN      PCOOKIE_ENUM EnumPtr        ZEROED
    )
{
    if (EnumPtr->Pool) {
        GbFree (&EnumPtr->CacheBuf);

        if (EnumPtr->EnumHandle) {
            FindCloseUrlCache (EnumPtr->EnumHandle);
        }

        PmDestroyPool (EnumPtr->Pool);
    }


    ZeroMemory (EnumPtr, sizeof (COOKIE_ENUM));
}



/*++

  The following enumeration routines enumerate the current user's cookies on
  the physical machine. They use wininet apis as much as possible, but
  they have to parse cookie TXT files because of api limitations.

--*/

BOOL
pEnumFirstCookie (
    OUT     PCOOKIE_ENUM EnumPtr
    )
{
    DWORD size;
    BOOL b = FALSE;

    ZeroMemory (EnumPtr, sizeof (COOKIE_ENUM));
    EnumPtr->Pool = PmCreatePoolEx (512);

    size = EnumPtr->CacheBuf.End;

    EnumPtr->EnumHandle = FindFirstUrlCacheEntry (TEXT("cookie:"), NULL, &size);

    if (!EnumPtr->EnumHandle) {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            EnumPtr->CacheEntry = (INTERNET_CACHE_ENTRY_INFO *) GbGrow (&EnumPtr->CacheBuf, size);
            MYASSERT (EnumPtr->CacheEntry);

            EnumPtr->EnumHandle = FindFirstUrlCacheEntry (
                                        TEXT("cookie:"),
                                        EnumPtr->CacheEntry,
                                        &size
                                        );

            if (EnumPtr->EnumHandle) {
                b = TRUE;
            }
        }
    }

    if (!b) {
        pAbortCookieEnum (EnumPtr);
        return FALSE;
    }

    return pEnumNextCookie (EnumPtr);
}


BOOL
pEnumNextCookie (
    IN OUT  PCOOKIE_ENUM EnumPtr
    )
{
    DWORD size;
    BOOL b;
    INTERNET_CACHE_ENTRY_INFO *cacheEntry = EnumPtr->CacheEntry;

    for (;;) {

        //
        // Is the cookie array empty? If so, fill it now.
        //

        if (!EnumPtr->ArrayCount) {

            if (!cacheEntry) {
                return FALSE;
            }

            EnumPtr->Array = pGetCookiesFromFile (
                                cacheEntry->lpszLocalFileName,
                                EnumPtr->Pool,
                                &EnumPtr->ArrayCount
                                );

            if (EnumPtr->Array) {
                //
                // Array was filled. Return the first item.
                //

                EnumPtr->Item = EnumPtr->Array;
                EnumPtr->ArrayPos = 1;
                return TRUE;
            }

            DEBUGMSG ((DBG_ERROR, "Unable to get cookies from %s", cacheEntry->lpszLocalFileName));

        } else if (EnumPtr->ArrayPos < EnumPtr->ArrayCount) {
            //
            // Another element in the array is available. Return it.
            //

            EnumPtr->Item = &EnumPtr->Array[EnumPtr->ArrayPos];
            EnumPtr->ArrayPos++;
            return TRUE;
        }

        //
        // Current local file enumeration is done. Now get the next local file.
        //

        EnumPtr->ArrayCount = 0;
        PmEmptyPool (EnumPtr->Pool);

        size = EnumPtr->CacheBuf.End;

        b = FindNextUrlCacheEntry (
                EnumPtr->EnumHandle,
                (INTERNET_CACHE_ENTRY_INFO *) EnumPtr->CacheBuf.Buf,
                &size
                );

        if (!b) {

            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

                EnumPtr->CacheBuf.End = 0;

                EnumPtr->CacheEntry = (INTERNET_CACHE_ENTRY_INFO *) GbGrow (&EnumPtr->CacheBuf, size);
                MYASSERT (EnumPtr->CacheEntry);

                b = FindNextUrlCacheEntry (
                        EnumPtr->EnumHandle,
                        (INTERNET_CACHE_ENTRY_INFO *) EnumPtr->CacheBuf.Buf,
                        &size
                        );
            }
        }

        if (!b) {
            //
            // Enumeration is complete
            //

            break;
        }
    }

    pAbortCookieEnum (EnumPtr);
    return FALSE;
}


VOID
pAddCookieToHashTable (
    IN OUT  PGROWBUFFER TempBuf,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR Url,
    IN      PCTSTR CookieName,
    IN      PCTSTR CookieData,
    IN      PCTSTR ExpirationString
    )

/*++

Routine Description:

  pAddCookieToHashTable puts a cookie in a hash table that is used for cache
  purposes. Cookies cannot be read easily in a random order. Therefore, a
  hash table is used to store each cookie. This routine adds the cookie to
  the hash table, complete with its URL, cookie name, cookie data and
  expiration string.

Arguments:

  TempBuf          - Specifies an initialized grow buffer used for temporary
                     memory allocations, receives undefined temporary data.
  ObjectName       - Specifies the cookie URL and name
  Url              - Specifies the cookie URL (unencoded)
  CookieName       - Specifies the cookie name (unencoded)
  CookieData       - Specifies the cookie data string
  ExpirationString - Specifies the cookie expiration date, in string format

Return Value:

  None.

--*/

{
    PCTSTR dupData;

    //
    // Write the cookie to the hash table. The object string is stored in the
    // hash table, along with a pointer to the cookie data and expiration
    // string. The cookie data and expieration string are kept in a separate
    // pool.
    //

    if (!HtFindString (g_CookiesTable, ObjectName)) {
        TempBuf->End = 0;

        GbMultiSzAppend (TempBuf, CookieData);
        GbMultiSzAppend (TempBuf, ExpirationString);

        dupData = (PCTSTR) PmDuplicateMemory (g_CookiesPool, TempBuf->Buf, TempBuf->End);
        HtAddStringAndData (g_CookiesTable, ObjectName, &dupData);
    }
    ELSE_DEBUGMSG ((DBG_ERROR, "Cookie already in the hash table: %s:%s", Url, CookieName));
}


BOOL
pLoadCookiesData (
    VOID
    )

/*++

Routine Description:

  pLoadCookieData fills the hash table with all of the current user's
  cookies. The hash table is later used to drive enumeration, to acquire the
  cookie, and to test its existence.

Arguments:

  None.

Return Value:

  TRUE if the cookie cache was filled, FALSE otherwise.

--*/

{
    COOKIE_ENUM e;
    GROWBUFFER tempBuf = INIT_GROWBUFFER;
    MIG_OBJECTSTRINGHANDLE objectName;

    if (pEnumFirstCookie (&e)) {

        do {
            //
            // Store the cookie in a hash table (used for caching)
            //

            objectName = pCreateCookieHandle (e.Item->Url, e.Item->CookieName);

            pAddCookieToHashTable (
                &tempBuf,
                objectName,
                e.Item->Url,
                e.Item->CookieName,
                e.Item->CookieData,
                e.Item->ExpirationString
                );

            IsmDestroyObjectHandle (objectName);

        } while (pEnumNextCookie (&e));
    }

    GbFree (&tempBuf);

    return TRUE;
}


BOOL
WINAPI
CookiesEtmInitialize (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )

/*++

Routine Description:

  CookiesEtmInitialize initializes the physical type module aspect of this
  code. The ETM module is responsible for abstracting all access to cookies.

Arguments:

  Platform    - Specifies the platform that the type is running on
                (PLATFORM_SOURCE or PLATFORM_DESTINATION)
  LogCallback - Specifies the arg to pass to the central logging mechanism
  Reserved    - Unused

Return Value:

  TRUE if initialization succeeded, FALSE otherwise.

--*/

{
    TYPE_REGISTER cookieTypeData;
    TCHAR cookiesDir[MAX_PATH];
    MIG_OBJECTSTRINGHANDLE handle;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    //
    // Initialize a hash table of all cookies
    //

    pLoadCookiesData ();

    //
    // Exclude the cookies .txt files from other processing
    //

    if (Platform == PLATFORM_SOURCE) {
        if (pGetCookiesPath (cookiesDir)) {

            handle = IsmCreateObjectHandle (cookiesDir, NULL);
            IsmRegisterStaticExclusion (MIG_FILE_TYPE, handle);
            IsmSetEnvironmentString (PLATFORM_SOURCE, NULL, S_COOKIES_SHELL_FOLDER, handle);
            IsmDestroyObjectHandle (handle);
        }
        ELSE_DEBUGMSG ((DBG_COOKIES, "Unable to get cookies path"));
    } else {
        if (IsmCopyEnvironmentString (PLATFORM_SOURCE, NULL, S_COOKIES_SHELL_FOLDER, cookiesDir)) {
            IsmRegisterStaticExclusion (MIG_FILE_TYPE, cookiesDir);
        }
    }

    //
    // Register the type module callbacks
    //

    ZeroMemory (&cookieTypeData, sizeof (TYPE_REGISTER));

    if (Platform != PLATFORM_SOURCE) {
        cookieTypeData.RemovePhysicalObject = RemoveCookie;
        cookieTypeData.CreatePhysicalObject = CreateCookie;
    }

    cookieTypeData.DoesPhysicalObjectExist = DoesCookieExist;
    cookieTypeData.EnumFirstPhysicalObject = EnumFirstCookie;
    cookieTypeData.EnumNextPhysicalObject = EnumNextCookie;
    cookieTypeData.AbortEnumPhysicalObject = AbortCookieEnum;
    cookieTypeData.ConvertObjectToMultiSz = ConvertCookieToMultiSz;
    cookieTypeData.ConvertMultiSzToObject = ConvertMultiSzToCookie;
    cookieTypeData.GetNativeObjectName = GetNativeCookieName;
    cookieTypeData.AcquirePhysicalObject = AcquireCookie;
    cookieTypeData.ReleasePhysicalObject = ReleaseCookie;
    cookieTypeData.ConvertObjectContentToUnicode = ConvertCookieContentToUnicode;
    cookieTypeData.ConvertObjectContentToAnsi = ConvertCookieContentToAnsi;
    cookieTypeData.FreeConvertedObjectContent = FreeConvertedCookieContent;

    g_CookieTypeId = IsmRegisterObjectType (
                            S_COOKIES_NAME,
                            TRUE,
                            FALSE,
                            &cookieTypeData
                            );

    MYASSERT (g_CookieTypeId);
    return TRUE;
}


BOOL
WINAPI
CookiesSgmParse (
    IN      PVOID Reserved
    )

/*++

Routine Description:

  CookiesSgmParse registers a component with the engine.

Arguments:

  Reserved - Unused.

Return Value:

  Always TRUE.

--*/

{
    TCHAR cookiesDir[MAX_PATH];

    IsmAddComponentAlias (
        TEXT("$Browser"),
        MASTERGROUP_SYSTEM,
        S_COOKIES_NAME,
        COMPONENT_SUBCOMPONENT,
        FALSE
        );


    if (pGetCookiesPath (cookiesDir)) {
        IsmAddComponentAlias (
            S_COOKIES_NAME,
            MASTERGROUP_SYSTEM,
            cookiesDir,
            COMPONENT_FOLDER,
            FALSE
            );
    }

    return TRUE;
}


BOOL
WINAPI
CookiesSgmQueueEnumeration (
    IN      PVOID Reserved
    )

/*++

Routine Description:

  CookiesSgmQueueEnumeration queues all cookies to be processed if the
  cookies component is selected.

Arguments:

  Reserved - Unused

Return Value:

  Always TRUE.

--*/

{
    ENCODEDSTRHANDLE pattern;

    if (!IsmIsComponentSelected (S_COOKIES_NAME, COMPONENT_SUBCOMPONENT)) {
        return TRUE;
    }

    //
    // Use the ISM's build-in callback
    //

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmQueueEnumeration (
        g_CookieTypeId,
        pattern,
        NULL,
        QUEUE_MAKE_APPLY|QUEUE_OVERWRITE_DEST|QUEUE_MAKE_NONCRITICAL,
        S_COOKIES_NAME
        );

    IsmDestroyObjectHandle (pattern);

    return TRUE;
}


BOOL
WINAPI
CookiesSourceInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )

/*++

Routine Description:

  CookiesSourceInitialize initializes the SGM module.

Arguments:

  LogCallback - Specifies the argument to pass to the log APIs
  Reserved    - Unused

Return Value:

  Always TRUE.

--*/

{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}


BOOL
CookiesVcmQueueEnumeration (
    IN      PVOID Reserved
    )

/*++

Routine Description:

  CookiesVcmQueueEnumeration is similar to the SGM queue enumeration, except
  that it only marks cookies as persistent. There is no need to set
  destination priority or apply here.

Arguments:

  Reserved - Unused

Return Value:

  Always TRUE.

--*/

{
    if (!IsmIsComponentSelected (S_COOKIES_NAME, COMPONENT_SUBCOMPONENT)) {
        return TRUE;
    }

    IsmQueueEnumeration (g_CookieTypeId, NULL, NULL, QUEUE_MAKE_PERSISTENT|QUEUE_MAKE_NONCRITICAL, NULL);

    return TRUE;
}


/*++

  The following enumeration routines are the ETM entry points. They rely
  on the enumeration routines above to access the physical machine.

--*/


BOOL
pEnumCookieWorker (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      PCOOKIES_ENUM CookieEnum
    )
{
    PCTSTR expiresStr;

    //
    // Clean up previous enum resources
    //

    pDestroyCookieStrings (EnumPtr->ObjectNode, EnumPtr->ObjectLeaf);
    EnumPtr->ObjectNode = NULL;
    EnumPtr->ObjectLeaf = NULL;

    IsmReleaseMemory (EnumPtr->NativeObjectName);
    EnumPtr->NativeObjectName = NULL;

    //
    // Find the next match
    //

    for (;;) {
        EnumPtr->ObjectName = CookieEnum->HashData.String;

        if (ObsPatternMatch (CookieEnum->Pattern, EnumPtr->ObjectName)) {
            break;
        }

        if (!EnumNextHashTableString (&CookieEnum->HashData)) {
            AbortCookieEnum (EnumPtr);
            return FALSE;
        }
    }

    //
    // Fill the caller's structure and return success
    //

    if (!pCreateCookieStrings (EnumPtr->ObjectName, &EnumPtr->ObjectNode, &EnumPtr->ObjectLeaf)) {
        return FALSE;
    }

    EnumPtr->NativeObjectName = GetNativeCookieName (EnumPtr->ObjectName);
    EnumPtr->Level = 1;
    EnumPtr->SubLevel = 0;
    EnumPtr->IsLeaf = TRUE;
    EnumPtr->IsNode = TRUE;

    expiresStr = *((PCTSTR *) CookieEnum->HashData.ExtraData);
    expiresStr = GetEndOfString (expiresStr) + 1;

    EnumPtr->Details.DetailsSize = SizeOfString (expiresStr);
    EnumPtr->Details.DetailsData = (PCBYTE) expiresStr;

    return TRUE;
}


BOOL
EnumFirstCookie (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,            CALLER_INITIALIZED
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    PCOOKIES_ENUM cookieEnum = NULL;

    if (!g_CookiesTable) {
        return FALSE;
    }

    cookieEnum = (PCOOKIES_ENUM) PmGetMemory (g_CookiesPool, sizeof (COOKIES_ENUM));
    cookieEnum->Pattern = PmDuplicateString (g_CookiesPool, Pattern);
    EnumPtr->EtmHandle = (LONG_PTR) cookieEnum;

    if (EnumFirstHashTableString (&cookieEnum->HashData, g_CookiesTable)) {
        return pEnumCookieWorker (EnumPtr, cookieEnum);
    } else {
        AbortCookieEnum (EnumPtr);
        return FALSE;
    }
}


BOOL
EnumNextCookie (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PCOOKIES_ENUM cookieEnum = NULL;

    cookieEnum = (PCOOKIES_ENUM)(EnumPtr->EtmHandle);
    if (!cookieEnum) {
        return FALSE;
    }

    if (EnumNextHashTableString (&cookieEnum->HashData)) {
        return pEnumCookieWorker (EnumPtr, cookieEnum);
    } else {
        AbortCookieEnum (EnumPtr);
        return FALSE;
    }
}


VOID
AbortCookieEnum (
    IN      PMIG_TYPEOBJECTENUM EnumPtr             ZEROED
    )
{
    PCOOKIES_ENUM cookieEnum;

    pDestroyCookieStrings (EnumPtr->ObjectNode, EnumPtr->ObjectLeaf);
    IsmReleaseMemory (EnumPtr->NativeObjectName);

    cookieEnum = (PCOOKIES_ENUM)(EnumPtr->EtmHandle);
    if (cookieEnum) {
        PmReleaseMemory (g_CookiesPool, cookieEnum->Pattern);
        PmReleaseMemory (g_CookiesPool, cookieEnum);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}


/*++

  The next set of functions implement the ETM entry points to acquire, test,
  create and remove cookies. They rely on the cookie hash table being
  accurate.

--*/

BOOL
AcquireCookie (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,             CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PCTSTR cookieData = NULL;

    MYASSERT (ObjectContent);

    if (ContentType == CONTENTTYPE_FILE) {
        // nobody should request this as a file
        MYASSERT (FALSE);
        return FALSE;
    }

    if (HtFindStringEx (g_CookiesTable, ObjectName, (PVOID) (&cookieData), FALSE)) {
        ObjectContent->MemoryContent.ContentBytes = (PCBYTE) cookieData;
        ObjectContent->MemoryContent.ContentSize = SizeOfString (cookieData);

        cookieData = GetEndOfString (cookieData) + 1;
        ObjectContent->Details.DetailsData = (PCBYTE) cookieData;
        ObjectContent->Details.DetailsSize = SizeOfString (cookieData);

        return TRUE;
    }

    return FALSE;
}


BOOL
ReleaseCookie (
    IN      PMIG_CONTENT ObjectContent              ZEROED
    )
{
    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }
    return TRUE;
}


BOOL
DoesCookieExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    if (g_DelayCookiesOp) {
        return FALSE;
    }

    if (HtFindString (g_CookiesTable, ObjectName)) {
        return TRUE;
    }

    return FALSE;
}


BOOL
pRemoveCookieWorker (
    IN      PCTSTR ObjectName,
    IN      PCTSTR Url,
    IN      PCTSTR CookieName
    )
{
    BOOL result = TRUE;

    if (InternetSetCookie (
            Url,
            CookieName,
            TEXT("foo; expires = Sat, 01-Jan-2000 00:00:00 GMT")
            )) {

        HtRemoveString (g_CookiesTable, ObjectName);

    } else {
        result = FALSE;
        DEBUGMSG ((
            DBG_ERROR,
            "Unable to delete cookie %s for URL %s\n",
            CookieName,
            Url
            ));
    }

    return result;
}


BOOL
RemoveCookie (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR url;
    PCTSTR cookieName;
    BOOL result = FALSE;

    if (pCreateCookieStrings (ObjectName, &url, &cookieName)) {
        if (url && cookieName) {

            if (g_DelayCookiesOp) {

                //
                // delay this cookie create because wininet apis do not work
                // for non-logged on users
                //

                IsmRecordDelayedOperation (
                    JRNOP_DELETE,
                    g_CookieTypeId,
                    ObjectName,
                    NULL
                    );
                result = TRUE;

            } else {
                //
                // add journal entry, then perform cookie deletion
                //

                IsmRecordOperation (
                    JRNOP_DELETE,
                    g_CookieTypeId,
                    ObjectName
                    );

                result = pRemoveCookieWorker (ObjectName, url, cookieName);
            }
        }

        pDestroyCookieStrings (url, cookieName);
    }

    return result;
}


BOOL
pCreateCookieWorker (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent,
    IN      PCTSTR Url,
    IN      PCTSTR CookieName
    )
{
    PCTSTR fixedCookieData;
    PCTSTR cookieData;
    PCTSTR expires;
    BOOL result = FALSE;
    GROWBUFFER tempBuf = INIT_GROWBUFFER;

    //
    // write the object by joining the content with the details
    //

    cookieData = (PCTSTR) (ObjectContent->MemoryContent.ContentBytes);
    expires = (PCTSTR) (ObjectContent->Details.DetailsData);
    fixedCookieData = JoinTextEx (
                            NULL,
                            cookieData,
                            expires,
                            TEXT(";"),
                            0,
                            NULL
                            );

    if (InternetSetCookie (Url, CookieName, fixedCookieData)) {

        pAddCookieToHashTable (
            &tempBuf,
            ObjectName,
            Url,
            CookieName,
            cookieData,
            expires
            );
        result = TRUE;

    } else {
        DEBUGMSG ((
            DBG_COOKIES,
            "Unable to set cookie %s for URL %s\n",
            CookieName,
            Url
            ));
    }

    FreeText (fixedCookieData);
    GbFree (&tempBuf);

    return result;
}


BOOL
CreateCookie (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR url;
    PCTSTR cookieName;
    BOOL result = FALSE;

    if (!ObjectContent->ContentInFile) {

        if (ObjectContent->MemoryContent.ContentBytes &&
            ObjectContent->MemoryContent.ContentSize &&
            ObjectContent->Details.DetailsSize &&
            ObjectContent->Details.DetailsData
            ) {

            if (pCreateCookieStrings (ObjectName, &url, &cookieName)) {
                if (url && cookieName) {

                    if (g_DelayCookiesOp) {

                        //
                        // delay this cookie create because wininet apis do not work
                        // for non-logged on users
                        //

                        IsmRecordDelayedOperation (
                            JRNOP_CREATE,
                            g_CookieTypeId,
                            ObjectName,
                            ObjectContent
                            );
                        result = TRUE;

                    } else {
                        //
                        // add journal entry, then create the cookie
                        //

                        IsmRecordOperation (
                            JRNOP_CREATE,
                            g_CookieTypeId,
                            ObjectName
                            );

                        if (DoesCookieExist (ObjectName)) {
                            //
                            // Fail because cookie cannot be overwritten
                            //

                            result = FALSE;
                        } else {
                            result = pCreateCookieWorker (
                                            ObjectName,
                                            ObjectContent,
                                            url,
                                            cookieName
                                            );
                        }
                    }
                }
                ELSE_DEBUGMSG ((DBG_ERROR, "Invalid cookie node or leaf: %s", ObjectName));

                pDestroyCookieStrings (url, cookieName);
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Invalid cookie object: %s", ObjectName));
        }
        ELSE_DEBUGMSG ((DBG_ERROR, "Can't write incomplete cookie object"));
    }

    return result;
}


/*++

  The next group of functions converts a cookie object into a string format,
  suitable for output to an INF file. The reverse conversion is also
  implemented.

--*/

PCTSTR
ConvertCookieToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR url, cookieName;
    PTSTR result = NULL;
    PCTSTR data;

    if (pCreateCookieStrings (ObjectName, &url, &cookieName)) {

        MYASSERT (url);
        MYASSERT (cookieName);

        //
        // Build a multi-sz in the following format:
        //
        // <url>\0<cookie name>\0<cookie data>\0<expiration>\0\0
        //

        g_CookieConversionBuff.End = 0;

        // <url>
        GbCopyQuotedString (&g_CookieConversionBuff, url);

        // <cookie name>
        GbCopyQuotedString (&g_CookieConversionBuff, cookieName);

        // <cookie data>
        MYASSERT (!ObjectContent->ContentInFile);

        if ((!ObjectContent->ContentInFile) &&
            (ObjectContent->MemoryContent.ContentSize) &&
            (ObjectContent->MemoryContent.ContentBytes)
            ) {

            data = (PCTSTR) ObjectContent->MemoryContent.ContentBytes;
            GbCopyQuotedString (&g_CookieConversionBuff, data);
        }

        // <expiration>
        MYASSERT (ObjectContent->Details.DetailsSize);

        if (ObjectContent->Details.DetailsSize &&
            ObjectContent->Details.DetailsData
            ) {
            data = (PCTSTR) ObjectContent->Details.DetailsData;
            GbCopyQuotedString (&g_CookieConversionBuff, data);
        }

        // nul terminator
        GbCopyString (&g_CookieConversionBuff, TEXT(""));

        //
        // Transfer multi-sz to ISM memory
        //

        result = IsmGetMemory (g_CookieConversionBuff.End);
        CopyMemory (result, g_CookieConversionBuff.Buf, g_CookieConversionBuff.End);

        //
        // Clean up
        //

        pDestroyCookieStrings (url, cookieName);
    }
    ELSE_DEBUGMSG ((DBG_ERROR, "Invalid cookie object: %s", ObjectName));

    return result;
}

BOOL
ConvertMultiSzToCookie (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent              OPTIONAL CALLER_INITIALIZED
    )
{
    MULTISZ_ENUM e;
    PCTSTR strings[4];
    UINT field;

    g_CookieConversionBuff.End = 0;

    //
    // Fill the object content from the following multi-sz:
    //
    // <url>\0<cookie name>\0<cookie data>\0<expiration>\0\0
    //

    field = 0;

    if (EnumFirstMultiSz (&e, ObjectMultiSz)) {
        do {

            strings[field] = e.CurrentString;
            field++;

        } while (field < 4 && EnumNextMultiSz (&e));
    }

    //
    // Validate data (end-user can edit it!)
    //

    if (field != 4) {
        return FALSE;
    }

    if (!strings[0] || !strings[1] || !strings[3]) {
        return FALSE;
    }

    //
    // Create the content struct
    //

    if (ObjectContent) {

        ObjectContent->ContentInFile = FALSE;

        ObjectContent->MemoryContent.ContentSize = SizeOfString (strings[2]);
        if (ObjectContent->MemoryContent.ContentSize) {
            ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            CopyMemory (
                (PBYTE) ObjectContent->MemoryContent.ContentBytes,
                strings[2],
                ObjectContent->MemoryContent.ContentSize
                );
        }

        ObjectContent->Details.DetailsSize = SizeOfString (strings[3]);
        ObjectContent->Details.DetailsData = IsmGetMemory (ObjectContent->Details.DetailsSize);

        CopyMemory (
            (PBYTE) ObjectContent->Details.DetailsData,
            strings[3],
            ObjectContent->Details.DetailsSize
            );
    }

    *ObjectName = pCreateCookieHandle (strings[0], strings[1]);

    return TRUE;
}


PCTSTR
GetNativeCookieName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )

/*++

Routine Description:

  GetNativeCookieName converts the standard Cobra object into a more friendly
  format. The Cobra object comes in the form of ^a<node>^b^c<leaf>, where
  <node> is the URL, and <leaf> is the cookie name. The Cookies native name is
  in the format of <CookieUrl>:<CookieName>.

  Here is an example:

    Cobra object:   ^ahttp://foo.com/^b^c#my#cookie
    Native object:  cookie://foo.com/:MyCookie

  (^a, ^b and ^c are placeholders for ISM-defined control characters.)

Arguments:

  ObjectName - Specifies the encoded object name

Return Value:

  A string that is equivalent to ObjectName, but is in a friendly format.
  This string must be freed with IsmReleaseMemory.

--*/

{
    PCTSTR cookieName;
    UINT size;
    PTSTR result = NULL;
    PCTSTR url;
    PCTSTR subUrl;
    PCTSTR cookieUrl;
    PCTSTR fullName;

    if (pCreateCookieStrings (ObjectName, &url, &cookieName)) {

        if (url && cookieName) {

            //
            // Skip beyond http:// prefix
            //

            subUrl = _tcschr (url, TEXT(':'));

            if (subUrl) {

                subUrl = _tcsinc (subUrl);

                if (_tcsnextc (subUrl) == TEXT('/')) {
                    subUrl = _tcsinc (subUrl);
                }

                if (_tcsnextc (subUrl) == TEXT('/')) {
                    subUrl = _tcsinc (subUrl);
                }

                //
                // Connect sub url with cookie:// prefix, then make full native name
                //

                cookieUrl = JoinText (TEXT("cookie://"), subUrl);

                fullName = JoinTextEx (
                                NULL,
                                cookieUrl,
                                cookieName,
                                TEXT(":"),
                                0,
                                NULL
                                );

                FreeText (cookieUrl);

                size = SizeOfString (fullName);
                result = IsmGetMemory (size);
                if (result) {
                    CopyMemory (result, fullName, size);
                }

                FreeText (fullName);
            }
        }

        pDestroyCookieStrings (url, cookieName);
    }

    return result;
}

PMIG_CONTENT
ConvertCookieContentToUnicode (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert cookie content
            result->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize * 2);
            if (result->MemoryContent.ContentBytes) {
                DirectDbcsToUnicodeN (
                    (PWSTR)result->MemoryContent.ContentBytes,
                    (PSTR)ObjectContent->MemoryContent.ContentBytes,
                    ObjectContent->MemoryContent.ContentSize
                    );
                result->MemoryContent.ContentSize = SizeOfStringW ((PWSTR)result->MemoryContent.ContentBytes);
            }
        }

        if ((ObjectContent->Details.DetailsSize != 0) &&
            (ObjectContent->Details.DetailsData != NULL)
            ) {
            // convert cookie details
            result->Details.DetailsData = IsmGetMemory (ObjectContent->Details.DetailsSize * 2);
            if (result->Details.DetailsData) {
                DirectDbcsToUnicodeN (
                    (PWSTR)result->Details.DetailsData,
                    (PSTR)ObjectContent->Details.DetailsData,
                    ObjectContent->Details.DetailsSize
                    );
                result->Details.DetailsSize = SizeOfStringW ((PWSTR)result->Details.DetailsData);
            }
        }
    }

    return result;
}

PMIG_CONTENT
ConvertCookieContentToAnsi (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert cookie content
            result->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            if (result->MemoryContent.ContentBytes) {
                DirectUnicodeToDbcsN (
                    (PSTR)result->MemoryContent.ContentBytes,
                    (PWSTR)ObjectContent->MemoryContent.ContentBytes,
                    ObjectContent->MemoryContent.ContentSize
                    );
                result->MemoryContent.ContentSize = SizeOfStringA ((PSTR)result->MemoryContent.ContentBytes);
            }
        }

        if ((ObjectContent->Details.DetailsSize != 0) &&
            (ObjectContent->Details.DetailsData != NULL)
            ) {
            // convert cookie details
            result->Details.DetailsData = IsmGetMemory (ObjectContent->Details.DetailsSize);
            if (result->Details.DetailsData) {
                DirectUnicodeToDbcsN (
                    (PSTR)result->Details.DetailsData,
                    (PWSTR)ObjectContent->Details.DetailsData,
                    ObjectContent->Details.DetailsSize
                    );
                result->Details.DetailsSize = SizeOfStringA ((PSTR)result->Details.DetailsData);
            }
        }
    }

    return result;
}

BOOL
FreeConvertedCookieContent (
    IN      PMIG_CONTENT ObjectContent
    )
{
    if (!ObjectContent) {
        return TRUE;
    }

    if (ObjectContent->MemoryContent.ContentBytes) {
        IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
    }

    if (ObjectContent->Details.DetailsData) {
        IsmReleaseMemory (ObjectContent->Details.DetailsData);
    }

    IsmReleaseMemory (ObjectContent);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\lnkmig.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    lnkmig.h

Abstract:

    Header file for implementing shell folders migration

Author:

    Calin Negreanu (calinn) 07-Ian-1998

Revision History:

    <alias> <date> <comments>

--*/

#define S_SFOLDERS_ATTRIBUTE       TEXT("SFOLDERS.SFOLDER")

#define S_LNKMIGATTR_SHORTCUT      TEXT("LNKMIG.ATTR.SHORTCUT")
#define S_LNKMIGPROP_TARGET        TEXT("LNKMIG.PROP.TARGET")
#define S_LNKMIGPROP_PARAMS        TEXT("LNKMIG.PROP.PARAMS")
#define S_LNKMIGPROP_WORKDIR       TEXT("LNKMIG.PROP.WORKDIR")
#define S_LNKMIGPROP_ICONPATH      TEXT("LNKMIG.PROP.ICONPATH")
#define S_LNKMIGPROP_ICONNUMBER    TEXT("LNKMIG.PROP.ICONNUMBER")
#define S_LNKMIGPROP_ICONDATA      TEXT("LNKMIG.PROP.ICONDATA")
#define S_LNKMIGPROP_HOTKEY        TEXT("LNKMIG.PROP.HOTKEY")
#define S_LNKMIGPROP_DOSAPP        TEXT("LNKMIG.PROP.DOSAPP")
#define S_LNKMIGPROP_MSDOSMODE     TEXT("LNKMIG.PROP.MSDOSMODE")
#define S_LNKMIGPROP_EXTRADATA     TEXT("LNKMIG.PROP.EXTRADATA")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\entry.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    entry.c

Abstract:

    Implements the DLL entry point that provides all Cobra module entry points
    to the engine.

Author:

    Jim Schmidt (jimschm) 11-Aug-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "sysmod.h"

#define NOPARSE NULL
#define NOQUEUE NULL
#define NOINIT  NULL
#define NOTERMINATE NULL
#define NOHIGHPRIQUEUE  NULL
#define NOEXECUTE NULL
#define NOPROGBAR NULL
#define NONOTIFY NULL

#define NO_SGM      NOINIT,NOPARSE,NOQUEUE,NOHIGHPRIQUEUE,NOTERMINATE
#define NO_SAM      NOINIT,NOEXECUTE,NOPROGBAR,NOTERMINATE
#define NO_DGM      NOINIT,NOQUEUE,NOHIGHPRIQUEUE,NOTERMINATE
#define NO_DAM      NOINIT,NOEXECUTE,NOPROGBAR,NOTERMINATE
#define NO_CSM      NOINIT,NOEXECUTE,NOPROGBAR,NOTERMINATE
#define NO_OPM      NOINIT,NOTERMINATE

typedef struct {
    PCTSTR Name;
    TYPE_ENTRYPOINTS EntryPoints;
} ETM_TABLE, *PETM_TABLE;

typedef struct {
    PCTSTR Name;
    VIRTUAL_COMPUTER_ENTRYPOINTS EntryPoints;
} VCM_TABLE, *PVCM_TABLE;

typedef struct {
    PCTSTR Name;
    SOURCE_ENTRYPOINTS EntryPoints;
} SOURCE_TABLE, *PSOURCE_TABLE;

typedef struct {
    PCTSTR Name;
    DESTINATION_ENTRYPOINTS EntryPoints;
} DESTINATION_TABLE, *PDESTINATION_TABLE;


//
// Add an entry for each ETM module in the DLL
//

ETM_TABLE g_EtmEntryPoints[] = {
    {   TEXT("ACCESSIBILITY"), ISM_VERSION,
        AccessibilityEtmInitialize, NOPARSE, NOTERMINATE, NONOTIFY
    },

    {   TEXT("COOKIES"), ISM_VERSION,
        CookiesEtmInitialize, NOPARSE, NOTERMINATE, CookiesEtmNewUserCreated
    },

    {   TEXT("NETDRIVES"), ISM_VERSION,
        NetDrivesEtmInitialize, NOPARSE, NOTERMINATE, NetDrivesEtmNewUserCreated
    },

    {   TEXT("NETSHARES"), ISM_VERSION,
        NetSharesEtmInitialize, NOPARSE, NOTERMINATE, NONOTIFY
    },

    {   TEXT("PRINTERS"), ISM_VERSION,
        PrintersEtmInitialize, NOPARSE, NOTERMINATE, PrintersEtmNewUserCreated
    },

    {   TEXT("RAS"), ISM_VERSION,
        RasMigEtmInitialize, NOPARSE, NOTERMINATE, NONOTIFY
    },

    {NULL}
};

//
// Add an entry for each VCM module in the DLL
//

VCM_TABLE g_VcmEntryPoints[] = {
    {   TEXT("ACCESSIBILITY"), ISM_VERSION,
        AccessibilitySourceInitialize, NOPARSE, NOQUEUE, NOHIGHPRIQUEUE, NOTERMINATE
    },

    {   TEXT("COOKIES"), ISM_VERSION,
        CookiesSourceInitialize, CookiesVcmParse, CookiesVcmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE
    },

    {   TEXT("LNKMIG"), ISM_VERSION,
        LnkMigVcmInitialize, NOPARSE, LnkMigVcmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE
    },

    {   TEXT("NETDRIVES"), ISM_VERSION,
        NetDrivesVcmInitialize, NetDrivesVcmParse, NetDrivesVcmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE
    },

    {   TEXT("NETSHARES"), ISM_VERSION,
        NetSharesVcmInitialize, NetSharesVcmParse, NetSharesVcmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE
    },

    {   TEXT("OSFILES"), ISM_VERSION,
        OsFilesVcmInitialize, NOPARSE, OsFilesVcmQueueEnumeration, OsFilesVcmQueueHighPriorityEnumeration, NOTERMINATE
    },

    {   TEXT("PRINTERS"), ISM_VERSION,
        PrintersVcmInitialize, PrintersVcmParse, PrintersVcmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE
    },

    {   TEXT("RAS"), ISM_VERSION,
        RasMigVcmInitialize, RasMigVcmParse, RasMigVcmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE
    },

    {NULL}
};

//
// Add an entry for each source module in the DLL
//

SOURCE_TABLE g_SourceEntryPoints[] = {
    {   TEXT("ACCESSIBILITY"), ISM_VERSION,
        (PSGMINITIALIZE) AccessibilitySourceInitialize, NOPARSE, NOQUEUE, NOHIGHPRIQUEUE, NOTERMINATE,
        NO_SAM
    },

    {   TEXT("COOKIES"), ISM_VERSION,
        (PSGMINITIALIZE) CookiesSourceInitialize, CookiesSgmParse, CookiesSgmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE,
        NO_SAM
    },

    {   TEXT("LNKMIG"), ISM_VERSION,
        LnkMigSgmInitialize, NOPARSE, LnkMigSgmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE,
        NO_SAM
    },

    {   TEXT("NETDRIVES"), ISM_VERSION,
        NetDrivesSgmInitialize, NetDrivesSgmParse, NetDrivesSgmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE,
        NO_SAM
    },

    {   TEXT("NETSHARES"), ISM_VERSION,
        NetSharesSgmInitialize, NetSharesSgmParse, NetSharesSgmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE,
        NO_SAM
    },

    {   TEXT("OSFILES"), ISM_VERSION,
        OsFilesSgmInitialize, NOPARSE, OsFilesSgmQueueEnumeration, OsFilesSgmQueueHighPriorityEnumeration, NOTERMINATE,
        NO_SAM
    },

    {   TEXT("PRINTERS"), ISM_VERSION,
        PrintersSgmInitialize, PrintersSgmParse, PrintersSgmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE,
        NO_SAM
    },

    {   TEXT("RAS"), ISM_VERSION,
        RasMigSgmInitialize, RasMigSgmParse, RasMigSgmQueueEnumeration, NOHIGHPRIQUEUE, NOTERMINATE,
        NO_SAM
    },

    {NULL}
};

//
// Add an entry for each destination module in the DLL
//

DESTINATION_TABLE g_DestinationEntryPoints[] = {
    {   TEXT("ACCESSIBILITY"), ISM_VERSION,
        NO_DGM, NO_DAM, NO_CSM, NO_OPM
    },

    {   TEXT("LNKMIG"), ISM_VERSION,
        NO_DGM, NO_DAM, NO_CSM,
        LnkMigOpmInitialize, NOTERMINATE
    },

    {   TEXT("NETDRIVES"), ISM_VERSION,
        NO_DGM, NO_DAM,
        NetDrivesCsmInitialize, NetDrivesCsmExecute, NOPROGBAR, NOTERMINATE,
        NetDrivesOpmInitialize, NOTERMINATE
    },

    {   TEXT("RAS"), ISM_VERSION,
        NO_DGM, NO_DAM, NO_CSM,
        RasMigOpmInitialize, NOTERMINATE
    },

    {NULL}
};


EXPORT
BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        g_hInst = hInstance;
    }

    return TRUE;
}


EXPORT
BOOL
WINAPI
ModuleInitialize (
    VOID
    )
{
    TCHAR memDbDir[MAX_PATH];

    UtInitialize (NULL);
    FileEnumInitialize ();
    RegInitialize ();           // for accessibility and ras
    InfGlobalInit (FALSE);      // for os files

    IsmGetTempDirectory (memDbDir, ARRAYSIZE (memDbDir));
    if (!MemDbInitializeEx (memDbDir)) {
        DEBUGMSG ((DBG_ERROR, "Failing to initialize unc transports because MemDb failed to initialize"));
        IsmSetCancel();
        return FALSE;
    }

#define DEFMAC(prefix)  if (!prefix##Initialize()) return FALSE;

MODULE_LIST

#undef DEFMAC

    return TRUE;
}

EXPORT
VOID
WINAPI
ModuleTerminate (
    VOID
    )
{
#define DEFMAC(prefix)  prefix##Terminate();

MODULE_LIST

#undef DEFMAC

    InfGlobalInit (TRUE);
    RegTerminate ();
    MemDbTerminateEx (TRUE);
    FileEnumTerminate ();
    UtTerminate ();
}


BOOL
WINAPI
pFindModule (
    IN      PCTSTR ModuleId,
    OUT     PVOID IsmBuffer,
    IN      PCTSTR *TableEntry,
    IN      UINT StructureSize
    )
{

    while (*TableEntry) {
        if (StringIMatch (*TableEntry, ModuleId)) {
            CopyMemory (
                IsmBuffer,
                (PBYTE) (TableEntry + 1),
                StructureSize
                );
            return TRUE;
        }

        TableEntry = (PCTSTR *) ((PBYTE) (TableEntry + 1) + StructureSize);
    }

    return FALSE;
}



EXPORT
BOOL
WINAPI
TypeModule (
    IN      PCTSTR ModuleId,
    IN OUT  PTYPE_ENTRYPOINTS TypeEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) TypeEntryPoints,
                (PCTSTR *) g_EtmEntryPoints,
                sizeof (TYPE_ENTRYPOINTS)
                );
}


EXPORT
BOOL
WINAPI
VirtualComputerModule (
    IN      PCTSTR ModuleId,
    IN OUT  PVIRTUAL_COMPUTER_ENTRYPOINTS VirtualComputerEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) VirtualComputerEntryPoints,
                (PCTSTR *) g_VcmEntryPoints,
                sizeof (VIRTUAL_COMPUTER_ENTRYPOINTS)
                );
}


EXPORT
BOOL
WINAPI
SourceModule (
    IN      PCTSTR ModuleId,
    IN OUT  PSOURCE_ENTRYPOINTS SourceEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) SourceEntryPoints,
                (PCTSTR *) g_SourceEntryPoints,
                sizeof (SOURCE_ENTRYPOINTS)
                );
}


EXPORT
BOOL
WINAPI
DestinationModule (
    IN      PCTSTR ModuleId,
    IN OUT  PDESTINATION_ENTRYPOINTS DestinationEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) DestinationEntryPoints,
                (PCTSTR *) g_DestinationEntryPoints,
                sizeof (DESTINATION_ENTRYPOINTS)
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\lnkmig.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    lnkmig.c

Abstract:

    <abstract>

Author:

    Calin Negreanu (calinn) 08 Mar 2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include "lnkmig.h"

#define DBG_LINKS       "Links"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_LinksPool = NULL;
MIG_ATTRIBUTEID g_LnkMigAttr_Shortcut = 0;
MIG_ATTRIBUTEID g_CopyIfRelevantAttr;
MIG_ATTRIBUTEID g_OsFileAttribute;

MIG_PROPERTYID g_LnkMigProp_Target = 0;
MIG_PROPERTYID g_LnkMigProp_Params = 0;
MIG_PROPERTYID g_LnkMigProp_WorkDir = 0;
MIG_PROPERTYID g_LnkMigProp_IconPath = 0;
MIG_PROPERTYID g_LnkMigProp_IconNumber = 0;
MIG_PROPERTYID g_LnkMigProp_IconData = 0;
MIG_PROPERTYID g_LnkMigProp_HotKey = 0;
MIG_PROPERTYID g_LnkMigProp_DosApp = 0;
MIG_PROPERTYID g_LnkMigProp_MsDosMode = 0;
MIG_PROPERTYID g_LnkMigProp_ExtraData = 0;

MIG_OPERATIONID g_LnkMigOp_FixContent;

IShellLink *g_ShellLink = NULL;
IPersistFile *g_PersistFile = NULL;

BOOL g_VcmMode = FALSE;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Private prototypes
//

MIG_OBJECTENUMCALLBACK LinksCallback;
MIG_PREENUMCALLBACK LnkMigPreEnumeration;
MIG_POSTENUMCALLBACK LnkMigPostEnumeration;
OPMAPPLYCALLBACK DoLnkContentFix;
MIG_RESTORECALLBACK LinkRestoreCallback;

//
// Code
//

BOOL
pIsUncPath (
    IN      PCTSTR Path
    )
{
    return (Path && (Path[0] == TEXT('\\')) && (Path[1] == TEXT('\\')));
}

BOOL
LinksInitialize (
    VOID
    )
{
    g_LinksPool = PmCreateNamedPool ("Links");
    return (g_LinksPool != NULL);
}

VOID
LinksTerminate (
    VOID
    )
{
    if (g_LinksPool) {
        PmDestroyPool (g_LinksPool);
        g_LinksPool = NULL;
    }
}

BOOL
pCommonInitialize (
    IN      PMIG_LOGCALLBACK LogCallback
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    g_LnkMigAttr_Shortcut = IsmRegisterAttribute (S_LNKMIGATTR_SHORTCUT, FALSE);
    g_CopyIfRelevantAttr = IsmRegisterAttribute (S_ATTRIBUTE_COPYIFRELEVANT, FALSE);

    g_LnkMigProp_Target = IsmRegisterProperty (S_LNKMIGPROP_TARGET, FALSE);
    g_LnkMigProp_Params = IsmRegisterProperty (S_LNKMIGPROP_PARAMS, FALSE);
    g_LnkMigProp_WorkDir = IsmRegisterProperty (S_LNKMIGPROP_WORKDIR, FALSE);
    g_LnkMigProp_IconPath = IsmRegisterProperty (S_LNKMIGPROP_ICONPATH, FALSE);
    g_LnkMigProp_IconNumber = IsmRegisterProperty (S_LNKMIGPROP_ICONNUMBER, FALSE);
    g_LnkMigProp_IconData = IsmRegisterProperty (S_LNKMIGPROP_ICONDATA, FALSE);
    g_LnkMigProp_HotKey = IsmRegisterProperty (S_LNKMIGPROP_HOTKEY, FALSE);
    g_LnkMigProp_DosApp = IsmRegisterProperty (S_LNKMIGPROP_DOSAPP, FALSE);
    g_LnkMigProp_MsDosMode = IsmRegisterProperty (S_LNKMIGPROP_MSDOSMODE, FALSE);
    g_LnkMigProp_ExtraData = IsmRegisterProperty (S_LNKMIGPROP_EXTRADATA, FALSE);

    g_LnkMigOp_FixContent = IsmRegisterOperation (S_OPERATION_LNKMIG_FIXCONTENT, FALSE);

    return TRUE;
}

BOOL
WINAPI
LnkMigVcmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    g_VcmMode = TRUE;
    return pCommonInitialize (LogCallback);
}

BOOL
WINAPI
LnkMigSgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    return pCommonInitialize (LogCallback);
}

BOOL
LnkMigPreEnumeration (
    VOID
    )
{
    if (!InitCOMLink (&g_ShellLink, &g_PersistFile)) {
        DEBUGMSG ((DBG_ERROR, "Error initializing COM %d", GetLastError ()));
    }
    return TRUE;
}

BOOL
LnkMigPostEnumeration (
    VOID
    )
{
    FreeCOMLink (&g_ShellLink, &g_PersistFile);
    g_ShellLink = NULL;
    g_PersistFile = NULL;
    return TRUE;
}

ENCODEDSTRHANDLE
pBuildEncodedNameFromNativeName (
    IN      PCTSTR NativeName
    )
{
    PCTSTR nodeName;
    PTSTR leafName;
    ENCODEDSTRHANDLE result;
    MIG_OBJECT_ENUM objEnum;

    result = IsmCreateObjectHandle (NativeName, NULL);
    if (result) {
        if (IsmEnumFirstSourceObject (&objEnum, MIG_FILE_TYPE | PLATFORM_SOURCE, result)) {
            IsmAbortObjectEnum (&objEnum);
            return result;
        }
        IsmDestroyObjectHandle (result);
    }

    // we have to split this path because it could be a file
    nodeName = DuplicatePathString (NativeName, 0);
    leafName = _tcsrchr (nodeName, TEXT('\\'));
    if (leafName) {
        *leafName = 0;
        leafName ++;
    }
    result = IsmCreateObjectHandle (nodeName, leafName);
    FreePathString (nodeName);

    return result;
}

PCTSTR
pSpecialExpandEnvironmentString (
    IN      PCTSTR SrcString,
    IN      PCTSTR Context
    )
{
    PCTSTR result = NULL;
    PCTSTR srcWinDir = NULL;
    PCTSTR destWinDir = NULL;
    PTSTR newSrcString = NULL;
    PCTSTR copyPtr = NULL;

    if (IsmGetRealPlatform () == PLATFORM_DESTINATION) {
        // Special case where this is actually the destination machine and
        // first part of SrcString matches %windir%. In this case, it is likely that
        // the shell replaced the source windows directory with the destination one.
        // We need to change it back
        destWinDir = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, TEXT ("%windir%"), NULL);
        if (destWinDir) {
            if (StringIPrefix (SrcString, destWinDir)) {
                srcWinDir = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, TEXT ("%windir%"), NULL);
                if (srcWinDir) {
                    newSrcString = IsmGetMemory (SizeOfString (srcWinDir) + SizeOfString (SrcString));
                    if (newSrcString) {
                        copyPtr = SrcString + TcharCount (destWinDir);
                        StringCopy (newSrcString, srcWinDir);
                        StringCat (newSrcString, copyPtr);
                    }
                    IsmReleaseMemory (srcWinDir);
                    srcWinDir = NULL;
                }
            }
            IsmReleaseMemory (destWinDir);
            destWinDir = NULL;
        }
    }

    result = IsmExpandEnvironmentString (
                PLATFORM_SOURCE,
                S_SYSENVVAR_GROUP,
                newSrcString?newSrcString:SrcString,
                Context
                );

    if (newSrcString) {
        IsmReleaseMemory (newSrcString);
    }

    return result;
}

UINT
LinksCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    MIG_OBJECTID objectId;
    BOOL extractResult = FALSE;
    PCTSTR lnkTarget;
    PCTSTR lnkParams;
    PCTSTR lnkWorkDir;
    PCTSTR lnkIconPath;
    INT lnkIconNumber;
    WORD lnkHotKey;
    BOOL lnkDosApp;
    BOOL lnkMsDosMode;
    LNK_EXTRA_DATA lnkExtraData;
    ENCODEDSTRHANDLE encodedName;
    MIG_BLOB migBlob;
    PCTSTR expTmpStr;
    PCTSTR longTmpStr;
    MIG_CONTENT lnkContent;
    MIG_CONTENT lnkIconContent;
    PICON_GROUP iconGroup = NULL;
    ICON_SGROUP iconSGroup;
    PCTSTR lnkIconResId = NULL;

    if (Data->IsLeaf) {

        objectId = IsmGetObjectIdFromName (MIG_FILE_TYPE, Data->ObjectName, TRUE);
        if (IsmIsPersistentObjectId (objectId)) {

            IsmSetAttributeOnObjectId (objectId, g_LnkMigAttr_Shortcut);

            if (IsmAcquireObjectEx (
                    Data->ObjectTypeId,
                    Data->ObjectName,
                    &lnkContent,
                    CONTENTTYPE_FILE,
                    0
                    )) {

                if (lnkContent.ContentInFile && lnkContent.FileContent.ContentPath) {

                    if (ExtractShortcutInfo (
                            lnkContent.FileContent.ContentPath,
                            &lnkTarget,
                            &lnkParams,
                            &lnkWorkDir,
                            &lnkIconPath,
                            &lnkIconNumber,
                            &lnkHotKey,
                            &lnkDosApp,
                            &lnkMsDosMode,
                            &lnkExtraData,
                            g_ShellLink,
                            g_PersistFile
                            )) {
                        // let's get all the paths through the hooks and add everything as properties of this shortcut
                        if (lnkTarget) {
                            if (*lnkTarget) {
                                expTmpStr = pSpecialExpandEnvironmentString (lnkTarget, Data->NativeObjectName);
                                longTmpStr = BfGetLongFileName (expTmpStr);
                                encodedName = pBuildEncodedNameFromNativeName (longTmpStr);
                                IsmExecuteHooks (MIG_FILE_TYPE, encodedName);
                                if (!g_VcmMode) {
                                    migBlob.Type = BLOBTYPE_STRING;
                                    migBlob.String = encodedName;
                                    IsmAddPropertyToObjectId (objectId, g_LnkMigProp_Target, &migBlob);
                                } else {
                                    // persist the target so we can examine it later
                                    if (!IsmIsPersistentObject (MIG_FILE_TYPE, encodedName)) {
                                        IsmMakePersistentObject (MIG_FILE_TYPE, encodedName);
                                        IsmMakeNonCriticalObject (MIG_FILE_TYPE, encodedName);
                                    }
                                }
                                if (encodedName) {
                                    IsmDestroyObjectHandle (encodedName);
                                }
                                FreePathString (longTmpStr);
                                IsmReleaseMemory (expTmpStr);
                            } else {
                                if (IsmIsAttributeSetOnObjectId (objectId, g_CopyIfRelevantAttr)) {
                                    IsmClearPersistenceOnObjectId (objectId);
                                }
                            }
                            FreePathString (lnkTarget);
                        } else {
                            if (IsmIsAttributeSetOnObjectId (objectId, g_CopyIfRelevantAttr)) {
                                IsmClearPersistenceOnObjectId (objectId);
                            }
                        }
                        if (lnkParams) {
                            if (*lnkParams) {
                                if (!g_VcmMode) {
                                    migBlob.Type = BLOBTYPE_STRING;
                                    migBlob.String = lnkParams;
                                    IsmAddPropertyToObjectId (objectId, g_LnkMigProp_Params, &migBlob);
                                }
                            }
                            FreePathString (lnkParams);
                        }
                        if (lnkWorkDir) {
                            if (*lnkWorkDir) {
                                expTmpStr = pSpecialExpandEnvironmentString (lnkWorkDir, Data->NativeObjectName);
                                longTmpStr = BfGetLongFileName (expTmpStr);
                                encodedName = pBuildEncodedNameFromNativeName (longTmpStr);
                                IsmExecuteHooks (MIG_FILE_TYPE, encodedName);
                                if (!g_VcmMode) {
                                    migBlob.Type = BLOBTYPE_STRING;
                                    migBlob.String = encodedName;
                                    IsmAddPropertyToObjectId (objectId, g_LnkMigProp_WorkDir, &migBlob);
                                } else {
                                    // persist the working directory (it has almost no space impact)
                                    // so we can examine it later
                                    if (!IsmIsPersistentObject (MIG_FILE_TYPE, encodedName)) {
                                        IsmMakePersistentObject (MIG_FILE_TYPE, encodedName);
                                        IsmMakeNonCriticalObject (MIG_FILE_TYPE, encodedName);
                                    }
                                }
                                if (encodedName) {
                                    IsmDestroyObjectHandle (encodedName);
                                }
                                FreePathString (longTmpStr);
                                IsmReleaseMemory (expTmpStr);
                            }
                            FreePathString (lnkWorkDir);
                        }
                        if (lnkIconPath) {
                            if (*lnkIconPath) {
                                expTmpStr = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, lnkIconPath, Data->NativeObjectName);
                                longTmpStr = BfGetLongFileName (expTmpStr);
                                encodedName = pBuildEncodedNameFromNativeName (longTmpStr);
                                IsmExecuteHooks (MIG_FILE_TYPE, encodedName);
                                if (!g_VcmMode) {
                                    migBlob.Type = BLOBTYPE_STRING;
                                    migBlob.String = encodedName;
                                    IsmAddPropertyToObjectId (objectId, g_LnkMigProp_IconPath, &migBlob);

                                    // one last thing: let's extract the icon and preserve it just in case.
                                    if (IsmAcquireObjectEx (
                                            MIG_FILE_TYPE,
                                            encodedName,
                                            &lnkIconContent,
                                            CONTENTTYPE_FILE,
                                            0
                                            )) {
                                        if (lnkIconContent.ContentInFile && lnkIconContent.FileContent.ContentPath) {
                                            if (lnkIconNumber >= 0) {
                                                iconGroup = IcoExtractIconGroupByIndexFromFile (
                                                                lnkIconContent.FileContent.ContentPath,
                                                                lnkIconNumber,
                                                                NULL
                                                                );
                                            } else {
                                                lnkIconResId = (PCTSTR) (LONG_PTR) (-lnkIconNumber);
                                                iconGroup = IcoExtractIconGroupFromFile (
                                                                lnkIconContent.FileContent.ContentPath,
                                                                lnkIconResId,
                                                                NULL
                                                                );
                                            }
                                            if (iconGroup) {
                                                if (IcoSerializeIconGroup (iconGroup, &iconSGroup)) {
                                                    migBlob.Type = BLOBTYPE_BINARY;
                                                    migBlob.BinaryData = (PCBYTE)(iconSGroup.Data);
                                                    migBlob.BinarySize = iconSGroup.DataSize;
                                                    IsmAddPropertyToObjectId (objectId, g_LnkMigProp_IconData, &migBlob);
                                                    IcoReleaseIconSGroup (&iconSGroup);
                                                }
                                                IcoReleaseIconGroup (iconGroup);
                                            }
                                        }
                                        IsmReleaseObject (&lnkIconContent);
                                    }
                                } else {
                                    // persist the icon file so we can examine it later
                                    if (!pIsUncPath (longTmpStr)) {
                                        if (!IsmIsPersistentObject (MIG_FILE_TYPE, encodedName)) {
                                            IsmMakePersistentObject (MIG_FILE_TYPE, encodedName);
                                            IsmMakeNonCriticalObject (MIG_FILE_TYPE, encodedName);
                                        }
                                    }
                                }

                                if (encodedName) {
                                    IsmDestroyObjectHandle (encodedName);
                                }
                                FreePathString (longTmpStr);
                                IsmReleaseMemory (expTmpStr);
                            }
                            FreePathString (lnkIconPath);
                        }

                        if (!g_VcmMode) {
                            migBlob.Type = BLOBTYPE_BINARY;
                            migBlob.BinaryData = (PCBYTE)(&lnkIconNumber);
                            migBlob.BinarySize = sizeof (INT);
                            IsmAddPropertyToObjectId (objectId, g_LnkMigProp_IconNumber, &migBlob);
                            migBlob.Type = BLOBTYPE_BINARY;
                            migBlob.BinaryData = (PCBYTE)(&lnkDosApp);
                            migBlob.BinarySize = sizeof (BOOL);
                            IsmAddPropertyToObjectId (objectId, g_LnkMigProp_DosApp, &migBlob);
                            if (lnkDosApp) {
                                migBlob.Type = BLOBTYPE_BINARY;
                                migBlob.BinaryData = (PCBYTE)(&lnkMsDosMode);
                                migBlob.BinarySize = sizeof (BOOL);
                                IsmAddPropertyToObjectId (objectId, g_LnkMigProp_MsDosMode, &migBlob);
                                migBlob.Type = BLOBTYPE_BINARY;
                                migBlob.BinaryData = (PCBYTE)(&lnkExtraData);
                                migBlob.BinarySize = sizeof (LNK_EXTRA_DATA);
                                IsmAddPropertyToObjectId (objectId, g_LnkMigProp_ExtraData, &migBlob);
                            } else {
                                migBlob.Type = BLOBTYPE_BINARY;
                                migBlob.BinaryData = (PCBYTE)(&lnkHotKey);
                                migBlob.BinarySize = sizeof (WORD);
                                IsmAddPropertyToObjectId (objectId, g_LnkMigProp_HotKey, &migBlob);
                            }
                            IsmSetOperationOnObjectId (
                                objectId,
                                g_LnkMigOp_FixContent,
                                NULL,
                                NULL
                                );
                        }
                    } else {
                        if (IsmIsAttributeSetOnObjectId (objectId, g_CopyIfRelevantAttr)) {
                            IsmClearPersistenceOnObjectId (objectId);
                        }
                    }
                } else {
                    if (IsmIsAttributeSetOnObjectId (objectId, g_CopyIfRelevantAttr)) {
                        IsmClearPersistenceOnObjectId (objectId);
                    }
                }
                IsmReleaseObject (&lnkContent);
            } else {
                if (IsmIsAttributeSetOnObjectId (objectId, g_CopyIfRelevantAttr)) {
                    IsmClearPersistenceOnObjectId (objectId);
                }
            }
        }
    }
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
pCommonLnkMigQueueEnumeration (
    VOID
    )
{
    ENCODEDSTRHANDLE pattern;

    // hook all LNK files
    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, TEXT("*.lnk"), TRUE);
    if (pattern) {
        IsmHookEnumeration (MIG_FILE_TYPE, pattern, LinksCallback, (ULONG_PTR) 0, TEXT("Links.Files"));
        IsmDestroyObjectHandle (pattern);
    }

    // hook all PIF files
    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, TEXT("*.pif"), TRUE);
    if (pattern) {
        IsmHookEnumeration (MIG_FILE_TYPE, pattern, LinksCallback, (ULONG_PTR) 0, TEXT("Links.Files"));
        IsmDestroyObjectHandle (pattern);
    }

    IsmRegisterPreEnumerationCallback (LnkMigPreEnumeration, NULL);
    IsmRegisterPostEnumerationCallback (LnkMigPostEnumeration, NULL);

    return TRUE;
}

BOOL
WINAPI
LnkMigVcmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    return pCommonLnkMigQueueEnumeration ();
}

BOOL
WINAPI
LnkMigSgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    return pCommonLnkMigQueueEnumeration ();
}

BOOL
WINAPI
DoLnkContentFix (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_PROPERTYDATAID propDataId;
    MIG_BLOBTYPE propDataType;
    UINT requiredSize;
    BOOL lnkTargetPresent = FALSE;
    PCTSTR lnkTargetNode = NULL;
    PCTSTR lnkTargetLeaf = NULL;
    PCTSTR objectNode = NULL;
    PCTSTR objectLeaf = NULL;
    MIG_OBJECTSTRINGHANDLE lnkTarget = NULL;
    MIG_OBJECTTYPEID lnkTargetDestType = 0;
    MIG_OBJECTSTRINGHANDLE lnkTargetDest = NULL;
    BOOL lnkTargetDestDel = FALSE;
    BOOL lnkTargetDestRepl = FALSE;
    PCTSTR lnkTargetDestNative = NULL;
    PCTSTR lnkParams = NULL;
    MIG_OBJECTSTRINGHANDLE lnkWorkDir = NULL;
    MIG_OBJECTTYPEID lnkWorkDirDestType = 0;
    MIG_OBJECTSTRINGHANDLE lnkWorkDirDest = NULL;
    BOOL lnkWorkDirDestDel = FALSE;
    BOOL lnkWorkDirDestRepl = FALSE;
    PCTSTR lnkWorkDirDestNative = NULL;
    MIG_OBJECTSTRINGHANDLE lnkIconPath = NULL;
    MIG_OBJECTTYPEID lnkIconPathDestType = 0;
    MIG_OBJECTSTRINGHANDLE lnkIconPathDest = NULL;
    BOOL lnkIconPathDestDel = FALSE;
    BOOL lnkIconPathDestRepl = FALSE;
    PCTSTR lnkIconPathDestNative = NULL;
    INT lnkIconNumber = 0;
    PICON_GROUP lnkIconGroup = NULL;
    ICON_SGROUP lnkIconSGroup = {0, NULL};
    WORD lnkHotKey = 0;
    BOOL lnkDosApp = FALSE;
    BOOL lnkMsDosMode = FALSE;
    PLNK_EXTRA_DATA lnkExtraData = NULL;
    BOOL comInit = FALSE;
    BOOL modifyFile = FALSE;
    PTSTR iconLibPath = NULL;

    // now it's finally time to fix the LNK file content
    if ((g_ShellLink == NULL) || (g_PersistFile == NULL)) {
        comInit = TRUE;
        if (!InitCOMLink (&g_ShellLink, &g_PersistFile)) {
            DEBUGMSG ((DBG_ERROR, "Error initializing COM %d", GetLastError ()));
            return TRUE;
        }
    }

    // first, retrieve the properties
    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_Target);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            lnkTarget = PmGetMemory (g_LinksPool, requiredSize);
            IsmGetPropertyData (propDataId, (PBYTE)lnkTarget, requiredSize, NULL, &propDataType);
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_Params);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            lnkParams = PmGetMemory (g_LinksPool, requiredSize);
            IsmGetPropertyData (propDataId, (PBYTE)lnkParams, requiredSize, NULL, &propDataType);
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_WorkDir);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            lnkWorkDir = PmGetMemory (g_LinksPool, requiredSize);
            IsmGetPropertyData (propDataId, (PBYTE)lnkWorkDir, requiredSize, NULL, &propDataType);
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_IconPath);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            lnkIconPath = PmGetMemory (g_LinksPool, requiredSize);
            IsmGetPropertyData (propDataId, (PBYTE)lnkIconPath, requiredSize, NULL, &propDataType);
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_IconNumber);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            if (requiredSize == sizeof (INT)) {
                IsmGetPropertyData (propDataId, (PBYTE)(&lnkIconNumber), requiredSize, NULL, &propDataType);
            }
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_IconData);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            lnkIconSGroup.DataSize = requiredSize;
            lnkIconSGroup.Data = PmGetMemory (g_LinksPool, requiredSize);
            IsmGetPropertyData (propDataId, (PBYTE)lnkIconSGroup.Data, requiredSize, NULL, &propDataType);
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_HotKey);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            if (requiredSize == sizeof (WORD)) {
                IsmGetPropertyData (propDataId, (PBYTE)(&lnkHotKey), requiredSize, NULL, &propDataType);
            }
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_DosApp);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            if (requiredSize == sizeof (BOOL)) {
                IsmGetPropertyData (propDataId, (PBYTE)(&lnkDosApp), requiredSize, NULL, &propDataType);
            }
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_MsDosMode);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            if (requiredSize == sizeof (BOOL)) {
                IsmGetPropertyData (propDataId, (PBYTE)(&lnkMsDosMode), requiredSize, NULL, &propDataType);
            }
        }
    }

    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_LnkMigProp_ExtraData);
    if (propDataId) {
        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
            lnkExtraData = PmGetMemory (g_LinksPool, requiredSize);
            IsmGetPropertyData (propDataId, (PBYTE)lnkExtraData, requiredSize, NULL, &propDataType);
        }
    }

    // let's examine the target, see if it was migrated
    if (lnkTarget) {
        lnkTargetDest = IsmFilterObject (
                            MIG_FILE_TYPE | PLATFORM_SOURCE,
                            lnkTarget,
                            &lnkTargetDestType,
                            &lnkTargetDestDel,
                            &lnkTargetDestRepl
                            );
        if (((lnkTargetDestDel == FALSE) || (lnkTargetDestRepl == TRUE)) &&
            ((lnkTargetDestType & (~PLATFORM_MASK)) == MIG_FILE_TYPE)
            ) {
            if (lnkTargetDest) {
                // the target changed location, we need to adjust the link
                modifyFile = TRUE;
                lnkTargetDestNative = IsmGetNativeObjectName (MIG_FILE_TYPE, lnkTargetDest);
            }
        }
        lnkTargetPresent = !lnkTargetDestDel;
    }

    // let's examine the working directory
    if (lnkWorkDir) {
        lnkWorkDirDest = IsmFilterObject (
                            MIG_FILE_TYPE | PLATFORM_SOURCE,
                            lnkWorkDir,
                            &lnkWorkDirDestType,
                            &lnkWorkDirDestDel,
                            &lnkWorkDirDestRepl
                            );
        if (((lnkWorkDirDestDel == FALSE) || (lnkWorkDirDestRepl == TRUE)) &&
            ((lnkWorkDirDestType & (~PLATFORM_MASK)) == MIG_FILE_TYPE)
            ) {
            if (lnkWorkDirDest) {
                // the working directory changed location, we need to adjust the link
                modifyFile = TRUE;
                lnkWorkDirDestNative = IsmGetNativeObjectName (MIG_FILE_TYPE, lnkWorkDirDest);
            }
        } else {
            // seems like the working directory is gone. If the target is still present, we will adjust
            // the working directory to point where the target is located
            if (lnkTargetPresent) {
                if (IsmCreateObjectStringsFromHandle (lnkTargetDest?lnkTargetDest:lnkTarget, &lnkTargetNode, &lnkTargetLeaf)) {
                    lnkWorkDirDest = IsmCreateObjectHandle (lnkTargetNode, NULL);
                    if (lnkWorkDirDest) {
                        modifyFile = TRUE;
                        lnkWorkDirDestNative = IsmGetNativeObjectName (MIG_FILE_TYPE, lnkWorkDirDest);
                    }
                    IsmDestroyObjectString (lnkTargetNode);
                    IsmDestroyObjectString (lnkTargetLeaf);
                }
            }
        }
    }

    // let's examine the icon path
    if (lnkIconPath) {
        lnkIconPathDest = IsmFilterObject (
                            MIG_FILE_TYPE | PLATFORM_SOURCE,
                            lnkIconPath,
                            &lnkIconPathDestType,
                            &lnkIconPathDestDel,
                            &lnkIconPathDestRepl
                            );
        if (((lnkIconPathDestDel == FALSE) || (lnkIconPathDestRepl == TRUE)) &&
            ((lnkIconPathDestType & (~PLATFORM_MASK)) == MIG_FILE_TYPE)
            ) {
            if (lnkIconPathDest) {
                // the icon path changed location, we need to adjust the link
                modifyFile = TRUE;
                lnkIconPathDestNative = IsmGetNativeObjectName (MIG_FILE_TYPE, lnkIconPathDest);
            }
        } else {
            if (!pIsUncPath (lnkIconPath)) {
                // seems like the icon path is gone. If the we have the icon extracted we will try to add it to the
                // icon library and adjust this link to point there.
                if (lnkIconSGroup.DataSize) {
                    lnkIconGroup = IcoDeSerializeIconGroup (&lnkIconSGroup);
                    if (lnkIconGroup) {
                        if (IsmGetEnvironmentString (
                                PLATFORM_DESTINATION,
                                NULL,
                                S_ENV_ICONLIB,
                                NULL,
                                0,
                                &requiredSize
                                )) {
                            iconLibPath = PmGetMemory (g_LinksPool, requiredSize);
                            if (IsmGetEnvironmentString (
                                    PLATFORM_DESTINATION,
                                    NULL,
                                    S_ENV_ICONLIB,
                                    iconLibPath,
                                    requiredSize,
                                    NULL
                                    )) {
                                if (IcoWriteIconGroupToPeFile (iconLibPath, lnkIconGroup, NULL, &lnkIconNumber)) {
                                    modifyFile = TRUE;
                                    lnkIconPathDestNative = IsmGetMemory (SizeOfString (iconLibPath));
                                    StringCopy ((PTSTR)lnkIconPathDestNative, iconLibPath);
                                    IsmSetEnvironmentFlag (PLATFORM_DESTINATION, NULL, S_ENV_SAVE_ICONLIB);
                                }
                            }
                            PmReleaseMemory (g_LinksPool, iconLibPath);
                        }
                        IcoReleaseIconGroup (lnkIconGroup);
                    }
                }
            }
        }
    }

    if (modifyFile) {
        if (CurrentContent->ContentInFile) {
            if (IsmCreateObjectStringsFromHandle (SrcObjectName, &objectNode, &objectLeaf)) {
                if (ModifyShortcutFileEx (
                        (PCTSTR) CurrentContent->FileContent.ContentPath,
                        GetFileExtensionFromPath (objectLeaf),
                        lnkTargetDestNative,
                        NULL,
                        lnkWorkDirDestNative,
                        lnkIconPathDestNative,
                        lnkIconNumber,
                        lnkHotKey,
                        NULL,
                        g_ShellLink,
                        g_PersistFile
                        )) {
                    NewContent->FileContent.ContentPath = CurrentContent->FileContent.ContentPath;
                }
                IsmDestroyObjectString (objectNode);
                IsmDestroyObjectString (objectLeaf);
            }
        } else {
            // something is wrong, the content of this shortcut should be in a file
            MYASSERT (FALSE);
        }
    }

    if (lnkIconPathDestNative) {
        IsmReleaseMemory (lnkIconPathDestNative);
        lnkIconPathDestNative = NULL;
    }

    if (lnkWorkDirDestNative) {
        IsmReleaseMemory (lnkWorkDirDestNative);
        lnkWorkDirDestNative = NULL;
    }

    if (lnkTargetDestNative) {
        IsmReleaseMemory (lnkTargetDestNative);
        lnkTargetDestNative = NULL;
    }

    if (lnkIconPathDest) {
        IsmDestroyObjectHandle (lnkIconPathDest);
        lnkIconPathDest = NULL;
    }

    if (lnkWorkDirDest) {
        IsmDestroyObjectHandle (lnkWorkDirDest);
        lnkWorkDirDest = NULL;
    }

    if (lnkTargetDest) {
        IsmDestroyObjectHandle (lnkTargetDest);
        lnkTargetDest = NULL;
    }

    if (lnkExtraData) {
        PmReleaseMemory (g_LinksPool, lnkExtraData);
        lnkExtraData = NULL;
    }

    if (lnkIconSGroup.DataSize && lnkIconSGroup.Data) {
        PmReleaseMemory (g_LinksPool, lnkIconSGroup.Data);
        lnkIconSGroup.DataSize = 0;
        lnkIconSGroup.Data = NULL;
    }

    if (lnkIconPath) {
        PmReleaseMemory (g_LinksPool, lnkIconPath);
        lnkIconPath = NULL;
    }

    if (lnkWorkDir) {
        PmReleaseMemory (g_LinksPool, lnkWorkDir);
        lnkWorkDir = NULL;
    }

    if (lnkParams) {
        PmReleaseMemory (g_LinksPool, lnkParams);
        lnkParams = NULL;
    }

    if (lnkTarget) {
        PmReleaseMemory (g_LinksPool, lnkTarget);
        lnkTarget = NULL;
    }

    if (comInit) {
        FreeCOMLink (&g_ShellLink, &g_PersistFile);
        g_ShellLink = NULL;
        g_PersistFile = NULL;
    }

    return TRUE;
}

BOOL
LinkRestoreCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    MIG_PROPERTYDATAID propDataId;
    MIG_BLOBTYPE propDataType;
    UINT requiredSize;
    MIG_OBJECTSTRINGHANDLE lnkTarget = NULL;
    MIG_OBJECTTYPEID lnkTargetDestType = 0;
    MIG_OBJECTSTRINGHANDLE lnkTargetDest = NULL;
    BOOL lnkTargetDestDel = FALSE;
    BOOL lnkTargetDestRepl = FALSE;
    PCTSTR lnkTargetNative = NULL;
    PCTSTR objectNode = NULL;
    PCTSTR objectLeaf = NULL;
    PCTSTR extPtr = NULL;
    BOOL result = TRUE;

    if (IsmIsAttributeSetOnObjectId (ObjectId, g_CopyIfRelevantAttr)) {
        if (IsmCreateObjectStringsFromHandle (ObjectName, &objectNode, &objectLeaf)) {
            if (objectLeaf) {
                extPtr = GetFileExtensionFromPath (objectLeaf);
                if (extPtr &&
                    (StringIMatch (extPtr, TEXT("LNK")) ||
                     StringIMatch (extPtr, TEXT("PIF"))
                     )
                    ) {
                    propDataId = IsmGetPropertyFromObject (ObjectTypeId, ObjectName, g_LnkMigProp_Target);
                    if (propDataId) {
                        if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
                            lnkTarget = PmGetMemory (g_LinksPool, requiredSize);
                            IsmGetPropertyData (propDataId, (PBYTE)lnkTarget, requiredSize, NULL, &propDataType);
                            if (IsmIsAttributeSetOnObject (MIG_FILE_TYPE | PLATFORM_SOURCE, lnkTarget, g_OsFileAttribute)) {
                                // NTRAID#NTBUG9-153265-2000/08/01-jimschm Need to migrate customized OS files links
                                result = FALSE;
                            } else {
                                lnkTargetNative = IsmGetNativeObjectName (MIG_FILE_TYPE, lnkTarget);
                                if (lnkTargetNative) {
                                    if (pIsUncPath (lnkTargetNative)) {
                                        result = TRUE;
                                    } else {
                                        lnkTargetDest = IsmFilterObject (
                                                            MIG_FILE_TYPE | PLATFORM_SOURCE,
                                                            lnkTarget,
                                                            &lnkTargetDestType,
                                                            &lnkTargetDestDel,
                                                            &lnkTargetDestRepl
                                                            );
                                        result = (lnkTargetDestDel == FALSE) || (lnkTargetDestRepl == TRUE);
                                        if (lnkTargetDest) {
                                            IsmDestroyObjectHandle (lnkTargetDest);
                                        }
                                    }
                                    IsmReleaseMemory (lnkTargetNative);
                                } else {
                                    result = FALSE;
                                }
                            }
                            PmReleaseMemory (g_LinksPool, lnkTarget);
                        }
                    }
                }
            }
            IsmDestroyObjectString (objectNode);
            IsmDestroyObjectString (objectLeaf);
        }
    }
    return result;
}

BOOL
WINAPI
LnkMigOpmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    g_LnkMigAttr_Shortcut = IsmRegisterAttribute (S_LNKMIGATTR_SHORTCUT, FALSE);
    g_CopyIfRelevantAttr = IsmRegisterAttribute (S_ATTRIBUTE_COPYIFRELEVANT, FALSE);
    g_OsFileAttribute = IsmRegisterAttribute (S_ATTRIBUTE_OSFILE, FALSE);

    g_LnkMigProp_Target = IsmRegisterProperty (S_LNKMIGPROP_TARGET, FALSE);
    g_LnkMigProp_Params = IsmRegisterProperty (S_LNKMIGPROP_PARAMS, FALSE);
    g_LnkMigProp_WorkDir = IsmRegisterProperty (S_LNKMIGPROP_WORKDIR, FALSE);
    g_LnkMigProp_IconPath = IsmRegisterProperty (S_LNKMIGPROP_ICONPATH, FALSE);
    g_LnkMigProp_IconNumber = IsmRegisterProperty (S_LNKMIGPROP_ICONNUMBER, FALSE);
    g_LnkMigProp_IconData = IsmRegisterProperty (S_LNKMIGPROP_ICONDATA, FALSE);
    g_LnkMigProp_HotKey = IsmRegisterProperty (S_LNKMIGPROP_HOTKEY, FALSE);
    g_LnkMigProp_DosApp = IsmRegisterProperty (S_LNKMIGPROP_DOSAPP, FALSE);
    g_LnkMigProp_MsDosMode = IsmRegisterProperty (S_LNKMIGPROP_MSDOSMODE, FALSE);
    g_LnkMigProp_ExtraData = IsmRegisterProperty (S_LNKMIGPROP_EXTRADATA, FALSE);

    g_LnkMigOp_FixContent = IsmRegisterOperation (S_OPERATION_LNKMIG_FIXCONTENT, FALSE);

    IsmRegisterRestoreCallback (LinkRestoreCallback);
    IsmRegisterOperationApplyCallback (g_LnkMigOp_FixContent, DoLnkContentFix, TRUE);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\migdb.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    migdb.c

Abstract:

    This source implements old AppDb functionality

Author:

    Calin Negreanu (calinn) 07-Jan-1998

Revision History:

    jimschm     23-Sep-1998 Updated for new fileops code
    jimschm     25-Feb-1998 Added UninstallSection support
    calinn      19-Jan-1998 Added CANCELLED response

--*/

#include "pch.h"
#include "logmsg.h"
#include "osfiles.h"

#define DBG_MIGDB           "MigDb"
#define S_STRINGS           TEXT("Strings")

//
// Globals
//

PMHANDLE            g_MigDbPool     = NULL;
PMIGDB_CONTEXT      g_ContextList   = NULL;
HASHTABLE           g_FileTable     = NULL;
PMIGDB_TYPE_RULE    g_TypeRule      = NULL;
GROWBUFFER          g_TypeRuleList  = INIT_GROWBUFFER;
HINF                g_OsFilesInf    = INVALID_HANDLE_VALUE;

GROWBUFFER          g_AttrGrowBuff  = INIT_GROWBUFFER;
GROWBUFFER          g_TypeGrowBuff  = INIT_GROWBUFFER;

static PINFCONTEXT g_Line;
PMIGDB_HOOK_PROTOTYPE g_MigDbHook = NULL;


#define ArgFunction     TEXT("ARG")
#define ArgFunctionLen  3


BOOL
pCallAction (
    IN      PMIGDB_CONTEXT MigDbContext
    );

PMIGDB_ATTRIB
pLoadAttribData (
    IN      PCTSTR MultiSzStr
    );

PMIGDB_HOOK_PROTOTYPE
SetMigDbHook (
    PMIGDB_HOOK_PROTOTYPE HookFunction
    )
{
    PMIGDB_HOOK_PROTOTYPE savedHook;

    savedHook = g_MigDbHook;
    g_MigDbHook = HookFunction;
    return savedHook;
}

INT
pGetAttribIndex (
    IN      PCTSTR AttribName
    )

/*++

Routine Description:

  This routine returns the index in attribute functions array for a specified attribute.

Arguments:

  AttribName - Attribute name

Return value:

  -1 - no such attribute in attribute table

--*/

{
    INT attribIndex;
    INT rc = 0;
    PTSTR attrEnd = NULL;
    TCHAR savedChar = 0;

    attrEnd = (PTSTR) SkipSpaceR (AttribName, GetEndOfString (AttribName));
    if (attrEnd != NULL) {
        attrEnd = _tcsinc (attrEnd);
        savedChar = attrEnd [0];
        attrEnd [0] = 0;
    }
    __try {
        attribIndex = MigDb_GetAttributeIdx (AttribName);
        if (attribIndex == -1) {
            LOG((LOG_ERROR, (PCSTR) MSG_MIGDB_ATTRIBUTE_NOT_FOUND, AttribName));
        }
        rc = attribIndex;
    }
    __finally {
        if (attrEnd != NULL) {
            attrEnd [0] = savedChar;
        }
    }

    return rc;
}

BOOL
pValidateArg (
    IN OUT  PMIGDB_ATTRIB AttribStruct
    )
{
    MYASSERT (AttribStruct);

    if (AttribStruct->ArgCount != MigDb_GetReqArgCount (AttribStruct->AttribIndex)) {

#ifdef DEBUG
        if (AttribStruct->AttribIndex != -1) {
            TCHAR Buffer[16384];

            SetupGetLineText (g_Line, NULL, NULL, NULL, Buffer, ARRAYSIZE(Buffer), NULL);
            DEBUGMSG ((
                DBG_WHOOPS,
                "Discarding attribute %s because of too few arguments.\n"
                    "  Line: %s\n",
                MigDb_GetAttributeName (AttribStruct->AttribIndex),
                Buffer
                ));
        }
#endif

        AttribStruct->AttribIndex = -1;
        return FALSE;
    }

    return TRUE;
}


#define STATE_ATTRNAME  1
#define STATE_ATTRARG   2

PMIGDB_ATTRIB
pLoadAttribData (
    IN      PCTSTR MultiSzStr
    )

/*++

Routine Description:

  This routine creates a list of MIGDB_ATTRIBs from a multisz.

Arguments:

  MultiSzStr - multisz to be processed

Return value:

  MIGDB_ATTRIB nodes

--*/

{
    MULTISZ_ENUM multiSzEnum;
    PMIGDB_ATTRIB result  = NULL;
    PMIGDB_ATTRIB tmpAttr = NULL;
    INT state = STATE_ATTRNAME;
    PTSTR currStrPtr = NULL;
    PTSTR currArgPtr = NULL;
    PTSTR endArgPtr  = NULL;
    TCHAR savedChar  = 0;

    g_AttrGrowBuff.End = 0;

    if (EnumFirstMultiSz (&multiSzEnum, MultiSzStr)) {
        do {
            currStrPtr = (PTSTR) SkipSpace (multiSzEnum.CurrentString);
            if (state == STATE_ATTRNAME) {
                tmpAttr = (PMIGDB_ATTRIB) PmGetMemory (g_MigDbPool, sizeof (MIGDB_ATTRIB));

                ZeroMemory (tmpAttr, sizeof (MIGDB_ATTRIB));

                if (_tcsnextc (currStrPtr) == TEXT('!')) {
                    currStrPtr = _tcsinc (currStrPtr);
                    currStrPtr = (PTSTR) SkipSpace (currStrPtr);
                    tmpAttr->NotOperator = TRUE;
                }

                currArgPtr = _tcschr (currStrPtr, TEXT('('));

                if (currArgPtr) {
                    endArgPtr = _tcsdec (currStrPtr, currArgPtr);
                    if (endArgPtr) {
                        endArgPtr = (PTSTR) SkipSpaceR (currStrPtr, endArgPtr);
                        endArgPtr = _tcsinc (endArgPtr);
                    }
                    else {
                        endArgPtr = currStrPtr;
                    }
                    savedChar = *endArgPtr;
                    *endArgPtr = 0;
                    tmpAttr->AttribIndex = pGetAttribIndex (currStrPtr);
                    *endArgPtr = savedChar;
                    currStrPtr = _tcsinc (currArgPtr);
                    state = STATE_ATTRARG;
                }
                else {
                    // this attribute has no arguments.
                    tmpAttr->AttribIndex = pGetAttribIndex (currStrPtr);
                    tmpAttr->Next = result;
                    result = tmpAttr;

                    pValidateArg (result);
                    continue;
                }
            }
            if (state == STATE_ATTRARG) {
                currStrPtr = (PTSTR) SkipSpace (currStrPtr);
                endArgPtr = _tcsrchr (currStrPtr, TEXT(')'));
                if (endArgPtr) {
                    endArgPtr = _tcsdec (currStrPtr, endArgPtr);
                    if (endArgPtr) {
                        endArgPtr = (PTSTR) SkipSpaceR (currStrPtr, endArgPtr);
                        endArgPtr = _tcsinc (endArgPtr);
                    }
                    else {
                        endArgPtr = currStrPtr;
                    }
                    savedChar = *endArgPtr;
                    *endArgPtr = 0;
                }

                GbMultiSzAppend (&g_AttrGrowBuff, currStrPtr);

                tmpAttr->ArgCount++;

                if (endArgPtr) {
                    *endArgPtr = savedChar;
                    tmpAttr->Arguments = PmDuplicateMultiSz (g_MigDbPool, (PTSTR)g_AttrGrowBuff.Buf);
                    g_AttrGrowBuff.End = 0;
                    state = STATE_ATTRNAME;
                    tmpAttr->Next = result;
                    result = tmpAttr;

                    pValidateArg (result);
                }
            }
        } while (EnumNextMultiSz (&multiSzEnum));
    }

    return result;
}


BOOL
AddFileToMigDbLinkage (
    IN      PCTSTR FileName,
    IN      PINFCONTEXT Context,        OPTIONAL
    IN      DWORD FieldIndex            OPTIONAL
    )
{
    TCHAR tempField [MEMDB_MAX];
    DWORD fieldIndex = FieldIndex;
    PMIGDB_FILE   migDbFile   = NULL;
    PMIGDB_ATTRIB migDbAttrib = NULL;
    HASHITEM stringId;
    FILE_LIST_STRUCT fileList;

    //creating MIGDB_FILE structure for current file
    migDbFile = (PMIGDB_FILE) PmGetMemory (g_MigDbPool, sizeof (MIGDB_FILE));
    if (migDbFile != NULL) {
        ZeroMemory (migDbFile, sizeof (MIGDB_FILE));
        migDbFile->Section = g_ContextList->Sections;

        if (Context) {
            fieldIndex ++;

            if (SetupGetMultiSzField (Context, fieldIndex, tempField, MEMDB_MAX, NULL)) {

                g_Line = Context;
                migDbFile->Attributes = pLoadAttribData (tempField);

                if (g_MigDbHook != NULL) {
                    migDbAttrib = migDbFile->Attributes;
                    while (migDbAttrib) {
                        g_MigDbHook (FileName, g_ContextList, g_ContextList->Sections, migDbFile, migDbAttrib);
                        migDbAttrib = migDbAttrib->Next;
                    }
                }
            }
        }

        //adding this file into string table and create a MIGDB_FILE node. If file
        //already exists in string table then just create another MIGDB_FILE node
        //chained with already existing ones.
        stringId = HtFindString (g_FileTable, FileName);

        if (stringId) {
            HtCopyStringData (g_FileTable, stringId, &fileList);

            fileList.Last->Next = migDbFile;
            fileList.Last = migDbFile;

            HtSetStringData (g_FileTable, stringId, &fileList);

        } else {
            fileList.First = fileList.Last = migDbFile;
            HtAddStringAndData (g_FileTable, FileName, &fileList);
        }
    }

    return TRUE;
}


BOOL
pScanForFile (
    IN      PINFCONTEXT Context,
    IN      DWORD FieldIndex
    )

/*++

Routine Description:

  This routine updates migdb data structures loading a specified file info from inf file.
  Creates a migdb file node and the file is added in a string table for fast query.

Arguments:

  SectionStr  - section to process

Return value:

  TRUE  - the operation was successful
  FALSE - otherwise

--*/

{
    TCHAR fileName [MEMDB_MAX];

    //scanning for file name
    if (!SetupGetStringField (Context, FieldIndex, fileName, MEMDB_MAX, NULL)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_MIGDB_BAD_FILENAME));
        return FALSE;
    }

    return AddFileToMigDbLinkage (fileName, Context, FieldIndex);
}


BOOL
pMigDbAddRuleToTypeRule (
    IN      PMIGDB_TYPE_RULE TypeRule,
    IN      PMIGDB_RULE Rule
    )
{
    PMIGDB_CHAR_NODE node, currNode, prevNode;
    PTSTR nodeBase;
    PCTSTR p;
    WORD w;
    BOOL found;

    if (Rule->NodeBase) {
        currNode = TypeRule->FirstLevel;
        prevNode = currNode;
        nodeBase = DuplicatePathString (Rule->NodeBase, 0);
        CharLower (nodeBase);
        p = nodeBase;
        while (*p) {
            w = (WORD) _tcsnextc (p);
            p = _tcsinc (p);
            if (currNode) {
                if (currNode->Char == w) {
                    if (!*p) {
                        Rule->NextRule = currNode->RuleList;
                        currNode->RuleList = Rule;
                    }
                    prevNode = currNode;
                    currNode = currNode->NextLevel;
                } else {
                    found = FALSE;
                    while (!found && currNode->NextPeer) {
                        if (currNode->NextPeer->Char == w) {
                            if (!*p) {
                                Rule->NextRule = currNode->NextPeer->RuleList;
                                currNode->NextPeer->RuleList = Rule;
                            }
                            prevNode = currNode->NextPeer;
                            currNode = prevNode->NextLevel;
                            found = TRUE;
                            break;
                        }
                        currNode = currNode->NextPeer;
                    }
                    if (!found) {
                        node = PmGetMemory (g_MigDbPool, sizeof (MIGDB_CHAR_NODE));
                        ZeroMemory (node, sizeof (MIGDB_CHAR_NODE));
                        if (!*p) {
                            node->RuleList = Rule;
                        }
                        node->Char = w;
                        node->NextPeer = currNode->NextPeer;
                        currNode->NextPeer = node;
                        prevNode = node;
                        currNode = node->NextLevel;
                    }
                }
            } else {
                node = PmGetMemory (g_MigDbPool, sizeof (MIGDB_CHAR_NODE));
                ZeroMemory (node, sizeof (MIGDB_CHAR_NODE));
                if (!*p) {
                    node->RuleList = Rule;
                }
                node->Char = w;
                if (prevNode) {
                    prevNode->NextLevel = node;
                } else {
                    TypeRule->FirstLevel = node;
                }
                prevNode = node;
                currNode = prevNode->NextLevel;
            }
        }
        FreePathString (nodeBase);
    } else {
        Rule->NextRule = TypeRule->RuleList;
        TypeRule->RuleList = Rule;
    }
    return TRUE;
}


BOOL
AddPatternToMigDbLinkage (
    IN      PCTSTR LeafPattern,
    IN      PCTSTR NodePattern,
    IN      PINFCONTEXT Context,        OPTIONAL
    IN      DWORD FieldIndex,
    IN      INT IncludeNodes
    )
{
    PMIGDB_RULE rule;
    MIG_SEGMENTS nodeSegment;
    MIG_SEGMENTS leafSegment;
    PCTSTR ourEncodedString;
    PCTSTR nodeBase;
    TCHAR tempField [MEMDB_MAX];
    DWORD fieldIndex = FieldIndex;

    nodeSegment.Segment = NodePattern ? NodePattern : TEXT("*");
    nodeSegment.IsPattern = TRUE;

    leafSegment.Segment = LeafPattern ? LeafPattern : TEXT("*");
    leafSegment.IsPattern = TRUE;

    ourEncodedString = IsmCreateObjectPattern (
                            &nodeSegment,
                            1,
                            &leafSegment,
                            1
                            );

    //
    // build the rule
    //
    rule = PmGetMemory (g_MigDbPool, sizeof (MIGDB_RULE));
    ZeroMemory (rule, sizeof (MIGDB_RULE));

    if (NodePattern) {
        nodeBase = GetPatternBase (NodePattern);
        if (nodeBase) {
            rule->NodeBase = PmDuplicateString (g_MigDbPool, nodeBase);
            FreePathString (nodeBase);
        }
    }
    rule->ObjectPattern = PmDuplicateString (g_MigDbPool, ourEncodedString);
    rule->ParsedPattern = ObsCreateParsedPatternEx (g_MigDbPool, ourEncodedString, FALSE);
    MYASSERT (rule->ParsedPattern);
    if (rule->ParsedPattern) {

        // add aditional information
        rule->Section = g_ContextList->Sections;
        if (Context) {

            fieldIndex ++;

            if (SetupGetMultiSzField (Context, fieldIndex, tempField, MEMDB_MAX, NULL)) {

                g_Line = Context;
                rule->Attributes = pLoadAttribData (tempField);
            }
        }

        rule->IncludeNodes = IncludeNodes;

        pMigDbAddRuleToTypeRule (g_TypeRule, rule);
    }

    IsmDestroyObjectHandle (ourEncodedString);

    return TRUE;
}


BOOL
pScanForFilePattern (
    IN      PINFCONTEXT Context,
    IN      DWORD FieldIndex
    )

/*++

Routine Description:

  This routine updates migdb data structures loading a specified file pattern info from inf file.
  Creates a migdb file node and the file is added in a string table for fast query.

Arguments:

  Context - inf context for the section that we are currently processing
  FieldIndex - field index to start with

Return value:

  TRUE  - the operation was successful
  FALSE - otherwise

--*/

{
    TCHAR leafPattern [MEMDB_MAX];
    PCTSTR leafPatternExp = NULL;
    TCHAR nodePattern [MEMDB_MAX];
    PCTSTR nodePatternExp = NULL;
    PCTSTR sanitizedPath = NULL;
    INT includeNodes = 0;
    BOOL result = TRUE;

    //scanning for leaf pattern
    if (!SetupGetStringField (Context, FieldIndex, leafPattern, MEMDB_MAX, NULL)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_MIGDB_BAD_FILENAME));
        return FALSE;
    }
    leafPatternExp = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, leafPattern, NULL);

    FieldIndex ++;

    //scanning for node pattern
    if (!SetupGetStringField (Context, FieldIndex, nodePattern, MEMDB_MAX, NULL)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_MIGDB_BAD_FILENAME));
        return FALSE;
    }
    nodePatternExp = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, nodePattern, NULL);

    if (nodePatternExp) {
        sanitizedPath = SanitizePath (nodePatternExp);
    }

    FieldIndex ++;

    //scanning for indicator if we should include the nodes as well
    if (!SetupGetIntField (Context, FieldIndex, &includeNodes)) {
        includeNodes = 0;
    }

    result =  AddPatternToMigDbLinkage (
                    leafPatternExp?leafPatternExp:leafPattern,
                    sanitizedPath?sanitizedPath:nodePattern,
                    Context,
                    FieldIndex,
                    includeNodes
                    );

    if (leafPatternExp) {
        IsmReleaseMemory (leafPatternExp);
        leafPatternExp = NULL;
    }

    if (nodePatternExp) {
        IsmReleaseMemory (nodePatternExp);
        nodePatternExp = NULL;
    }
    if (sanitizedPath) {
        FreePathString (sanitizedPath);
    }

    return result;
}


/*++

Routine Description:

  The subsequent two routines enumerate the sections with a particular name and
  with .999 extension from an inf file.

Arguments:

  SectEnum  - enumeration structure

Return value:

  TRUE  - enumeration continues
  FALSE - enumeration ended

--*/

typedef struct _SECT_ENUM {
    HINF InfHandle;
    INT  SectIndex;
    PTSTR SectNameEnd;
    PTSTR SectName;
} SECT_ENUM, *PSECT_ENUM;


VOID
pAbortSectionEnum (
    IN OUT  PSECT_ENUM SectEnum
    )
{
    if (SectEnum && SectEnum->SectName) {
        FreePathString (SectEnum->SectName);
        SectEnum->SectName = NULL;
        SectEnum->SectNameEnd = NULL;
    }
}


BOOL
pEnumNextSection (
    IN OUT  PSECT_ENUM SectEnum
    )
{
    INFCONTEXT context;
    BOOL result = FALSE;

    if (SectEnum->SectIndex == -1) {
        pAbortSectionEnum (SectEnum);
        return FALSE;
    }
    SectEnum->SectIndex ++;
    _stprintf (SectEnum->SectNameEnd, TEXT(".%d"), SectEnum->SectIndex);
    result = SetupFindFirstLine (SectEnum->InfHandle, SectEnum->SectName, NULL, &context);
    if (!result) {
        pAbortSectionEnum (SectEnum);
    }
    return result;
}


BOOL
pEnumFirstSection (
    OUT     PSECT_ENUM SectEnum,
    IN      PCTSTR SectionStr,
    IN      HINF InfHandle
    )
{
    INFCONTEXT context;

    ZeroMemory (SectEnum, sizeof (SECT_ENUM));
    SectEnum->SectIndex = -1;
    if (SetupFindFirstLine (InfHandle, SectionStr, NULL, &context)) {
        //good, only one section
        SectEnum->SectName = DuplicatePathString (SectionStr, 0);
        return TRUE;
    }
    else {
        //more than one section
        SectEnum->SectIndex = 0;
        SectEnum->InfHandle = InfHandle;
        SectEnum->SectName = DuplicatePathString (SectionStr, 32);
        if (SectEnum->SectName) {
            SectEnum->SectNameEnd = GetEndOfString (SectEnum->SectName);
            if (SectEnum->SectNameEnd) {
                return pEnumNextSection (SectEnum);
            }
        }
    }
    // something went wrong, let's get out of here
    return FALSE;
}


BOOL
pLoadSectionData (
    IN      PCTSTR SectionStr,
    IN      BOOL PatternScan
    )

/*++

Routine Description:

  This routine updates migdb data structures loading a specified section from inf file. For
  every line in the section there is a migdb file node created. Also the file is added in
  a string table for fast query.

Arguments:

  SectionStr  - section to process

Return value:

  TRUE  - the operation was successful
  FALSE - otherwise

--*/

{
    INFCONTEXT context;
    SECT_ENUM sectEnum;
    PMIGDB_SECTION migDbSection;
    BOOL result = TRUE;

    MYASSERT (g_OsFilesInf != INVALID_HANDLE_VALUE);

    if (pEnumFirstSection (&sectEnum, SectionStr, g_OsFilesInf)) {
        do {
            //initialize the section (this context can have multiple sections)
            //and parse the file info
            migDbSection = (PMIGDB_SECTION) PmGetMemory (g_MigDbPool, sizeof (MIGDB_SECTION));
            if (migDbSection != NULL) {

                ZeroMemory (migDbSection, sizeof (MIGDB_SECTION));
                migDbSection->Context = g_ContextList;
                migDbSection->Next = g_ContextList->Sections;
                g_ContextList->Sections = migDbSection;
                if (SetupFindFirstLine (g_OsFilesInf, sectEnum.SectName, NULL, &context)) {
                    do {
                        if (PatternScan) {
                            if (!pScanForFilePattern (&context, 1)) {
                                return FALSE;
                            }
                        } else {
                            if (!pScanForFile (&context, 1)) {
                                return FALSE;
                            }
                        }
                    }
                    while (SetupFindNextLine (&context, &context));
                }
            }
            else {
                DEBUGMSG ((DBG_ERROR, "Unable to create section for %s", SectionStr));
            }
        }
        while (pEnumNextSection (&sectEnum));
    }
    return result;
}

BOOL
pLoadTypeData (
    IN      PCTSTR TypeStr,
    IN      BOOL PatternScan
    )

/*++

Routine Description:

  This routine updates migdb data structures loading a specified type data from inf file. For
  every line in type section there is a migdb context created. Also for every migdb context
  the coresponding section(s) is processed.

Arguments:

  TypeStr     - file type to process

Return value:

  TRUE  - the operation was successful
  FALSE - otherwise

--*/

{
    TCHAR section [MEMDB_MAX];
    TCHAR locSection [MEMDB_MAX];
    TCHAR message [MEMDB_MAX];
    TCHAR tempField [MEMDB_MAX];
    PTSTR tempFieldPtr;
    PTSTR endOfArg  = NULL;
    DWORD fieldIndex;
    PMIGDB_CONTEXT migDbContext = NULL;
    INFCONTEXT context, context1;
    BOOL result = TRUE;
    INT actionIndex;

    MYASSERT (g_OsFilesInf != INVALID_HANDLE_VALUE);

    g_TypeGrowBuff.End = 0;

    if (SetupFindFirstLine (g_OsFilesInf, TypeStr, NULL, &context)) {
        //let's identify the action function index to update MIGDB_CONTEXT structure
        actionIndex = MigDb_GetActionIdx (TypeStr);
        if (actionIndex == -1) {
            LOG ((LOG_ERROR, (PCSTR) MSG_MIGDB_BAD_ACTION, TypeStr));
        }

        do {
            if (!SetupGetStringField (&context, 1, section, MEMDB_MAX, NULL)) {
                LOG ((LOG_ERROR, (PCSTR) MSG_MIGDB_BAD_OR_MISSING_SECTION, TypeStr));
                return FALSE;
            }

            if (!SetupGetStringField (&context, 2, message, MEMDB_MAX, NULL)) {
                message [0] = 0;
            }

            migDbContext = (PMIGDB_CONTEXT) PmGetMemory (g_MigDbPool, sizeof (MIGDB_CONTEXT));
            if (migDbContext == NULL) {
                DEBUGMSG ((DBG_ERROR, "Unable to create context for %s.", TypeStr));
                return FALSE;
            }

            ZeroMemory (migDbContext, sizeof (MIGDB_CONTEXT));
            migDbContext->Next = g_ContextList;
            g_ContextList = migDbContext;

            // update ActionIndex with known value
            migDbContext->ActionIndex = actionIndex;

            // update SectName field
            migDbContext->SectName = PmDuplicateString (g_MigDbPool, section);

            // update SectLocalizedName field
            if (SetupFindFirstLine (g_OsFilesInf, S_STRINGS, section, &context1)) {
                if (SetupGetStringField (&context1, 1, locSection, MEMDB_MAX, NULL)) {
                    migDbContext->SectLocalizedName = PmDuplicateString (g_MigDbPool, locSection);
                }
            }

            // set SectNameForDisplay to localized name, or sect name if no localized name
            if (migDbContext->SectLocalizedName) {
                migDbContext->SectNameForDisplay = migDbContext->SectLocalizedName;
            } else {
                migDbContext->SectNameForDisplay = migDbContext->SectName;
            }

            // update Message field
            if (message[0] != 0) {
                migDbContext->Message  = PmDuplicateString (g_MigDbPool, message);
            }

            // OK, now let's scan all the remaining fields
            fieldIndex = 3;
            do {
                tempField [0] = 0;

                if (SetupGetStringField (&context, fieldIndex, tempField, MEMDB_MAX, NULL)) {
                    if (StringIMatchCharCount (tempField, ArgFunction, ArgFunctionLen)) {
                        //we have an additional argument for action function
                        tempFieldPtr = _tcschr (tempField, TEXT('('));
                        if (tempFieldPtr != NULL) {

                            tempFieldPtr = (PTSTR) SkipSpace (_tcsinc (tempFieldPtr));

                            if (tempFieldPtr != NULL) {

                                endOfArg = _tcschr (tempFieldPtr, TEXT(')'));

                                if (endOfArg != NULL) {
                                    *endOfArg = 0;
                                    endOfArg = (PTSTR) SkipSpaceR (tempFieldPtr, endOfArg);
                                }

                                if (endOfArg != NULL) {
                                    *_tcsinc (endOfArg) = 0;
                                    GbMultiSzAppend (&g_TypeGrowBuff, tempFieldPtr);
                                }
                                ELSE_DEBUGMSG ((
                                    DBG_WHOOPS,
                                    "Improperly formatted arg: %s in %s",
                                    tempField,
                                    TypeStr
                                    ));
                            }
                        }
                    }
                    else {
                        //we have something else, probably file name and attributes

                        if (!PatternScan) {
                            if (_tcschr (tempField, TEXT('.')) == NULL) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_MIGDB_DOT_SYNTAX_ERROR, TypeStr, section));
                            }
                        }

                        //therefore we initialize the section (this context will have
                        //only one section) and parse the file info
                        migDbContext->Sections = (PMIGDB_SECTION) PmGetMemory (
                                                                        g_MigDbPool,
                                                                        sizeof (MIGDB_SECTION)
                                                                        );
                        if (migDbContext->Sections != NULL) {
                            ZeroMemory (migDbContext->Sections, sizeof (MIGDB_SECTION));
                            migDbContext->Sections->Context = migDbContext;
                            migDbContext->Arguments = PmDuplicateMultiSz (g_MigDbPool, (PTSTR)g_TypeGrowBuff.Buf);
                            g_TypeGrowBuff.End = 0;
                            if (PatternScan) {
                                if (!pScanForFilePattern (&context, fieldIndex)) {
                                    return FALSE;
                                }
                            } else {
                                if (!pScanForFile (&context, fieldIndex)) {
                                    return FALSE;
                                }
                            }
                            tempField [0] = 0;
                        }
                        else {
                            DEBUGMSG ((DBG_ERROR, "Unable to create section for %s/%s", TypeStr, section));
                            return FALSE;
                        }
                    }
                }

                fieldIndex ++;
            } while (tempField [0] != 0);

            if (migDbContext->Sections == NULL) {
                //now let's add action function arguments in MIGDB_CONTEXT structure
                migDbContext->Arguments = PmDuplicateMultiSz (g_MigDbPool, (PTSTR)g_TypeGrowBuff.Buf);
                g_TypeGrowBuff.End = 0;

                //let's go to the sections and scan all files
                if (!pLoadSectionData (section, PatternScan)) {
                    return FALSE;
                }
            }

        }
        while (SetupFindNextLine (&context, &context));
    }
    return result;
}

BOOL
InitMigDb (
    IN      PCTSTR MigDbFile
    )

/*++

Routine Description:

  This routine initialize memory and data structures used by MigDb.

Arguments:

  NONE

Return value:

  TRUE  - the operation was successful
  FALSE - otherwise

--*/

{
    INT i;
    BOOL patternFormat;
    PCTSTR typeStr;

    MYASSERT (g_OsFilesInf == INVALID_HANDLE_VALUE);

    g_OsFilesInf = InfOpenInfFile (MigDbFile);
    if (g_OsFilesInf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    g_MigDbPool = PmCreateNamedPool ("MigDb Pool");

    PmDisableTracking (g_MigDbPool);
    g_FileTable = HtAllocWithData (sizeof (FILE_LIST_STRUCT));

    if (g_FileTable == NULL) {
        DEBUGMSG ((DBG_ERROR, "Cannot initialize memory for migdb operations"));
        return FALSE;
    }

    //load known types from migdb
    i = 0;
    do {
        typeStr = MigDb_GetActionName (i);
        if (typeStr != NULL) {
            patternFormat = MigDb_IsPatternFormat (i);
            if (!pLoadTypeData (typeStr, patternFormat)) {
                GbFree (&g_AttrGrowBuff);
                GbFree (&g_TypeGrowBuff);
                return FALSE;
            }
        }
        i++;
    }
    while (typeStr != NULL);

    GbFree (&g_AttrGrowBuff);
    GbFree (&g_TypeGrowBuff);

    return TRUE;
}

BOOL
InitMigDbEx (
    IN      HINF InfHandle
    )
{
    INT i;
    BOOL patternFormat;
    PCTSTR typeStr;

    MYASSERT (g_OsFilesInf == INVALID_HANDLE_VALUE);
    MYASSERT (InfHandle != INVALID_HANDLE_VALUE);

    g_OsFilesInf = InfHandle;
    if (g_OsFilesInf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    g_MigDbPool = PmCreateNamedPool ("MigDb Pool");

    PmDisableTracking (g_MigDbPool);
    g_FileTable = HtAllocWithData (sizeof (FILE_LIST_STRUCT));
    g_TypeRule = PmGetMemory (g_MigDbPool, sizeof (MIGDB_TYPE_RULE));
    ZeroMemory (g_TypeRule, sizeof (MIGDB_TYPE_RULE));

    if (g_FileTable == NULL) {
        DEBUGMSG ((DBG_ERROR, "Cannot initialize memory for migdb operations"));
        return FALSE;
    }

    //load known types from migdb
    i = 0;
    do {
        typeStr = MigDb_GetActionName (i);
        if (typeStr != NULL) {
            patternFormat = MigDb_IsPatternFormat (i);
            if (!pLoadTypeData (typeStr, patternFormat)) {
                GbFree (&g_AttrGrowBuff);
                GbFree (&g_TypeGrowBuff);
                return FALSE;
            }
        }
        i++;
    }
    while (typeStr != NULL);

    GbFree (&g_AttrGrowBuff);
    GbFree (&g_TypeGrowBuff);

    return TRUE;
}

BOOL
DoneMigDbEx (
    VOID
    )

/*++

Routine Description:

  This routine cleans up all memory used by MigDb.

Arguments:

  NONE

Return value:

  always TRUE

--*/

{
    PMIGDB_CONTEXT migDbContext = NULL;

    // first, let's walk through any context and check if it's a required one
    migDbContext = g_ContextList;

    while (migDbContext) {
        if ((!MigDb_CallWhenTriggered (migDbContext->ActionIndex)) &&
            (migDbContext->TriggerCount == 0)
            ) {

            pCallAction (migDbContext);
        }
        migDbContext = migDbContext->Next;
    }

    if (g_FileTable != NULL) {
        HtFree (g_FileTable);
        g_FileTable = NULL;
    }

    if (g_MigDbPool != NULL) {
        PmEmptyPool (g_MigDbPool);
        PmDestroyPool (g_MigDbPool);
        g_MigDbPool = NULL;
    }

    g_ContextList = NULL;
    return TRUE;
}

BOOL
DoneMigDb (
    VOID
    )

/*++

Routine Description:

  This routine cleans up all memory used by MigDb.

Arguments:

  NONE

Return value:

  always TRUE

--*/

{
    if (!DoneMigDbEx ()) {
        return FALSE;
    }

    if (g_OsFilesInf != INVALID_HANDLE_VALUE) {
        InfCloseInfFile (g_OsFilesInf);
        g_OsFilesInf = INVALID_HANDLE_VALUE;
    }

    return TRUE;
}

BOOL
CallAttribute (
    IN      PMIGDB_ATTRIB MigDbAttrib,
    IN      PDBATTRIB_PARAMS AttribParams
    )

/*++

Routine Description:

  This routine calls a specified attribute function for a specified file.

Arguments:

  MigDbAttrib - See definition.
  AttribParams - See definition

Return value:

  TRUE  - if attribute function succeded
  FALSE - otherwise

--*/

{
    PATTRIBUTE_PROTOTYPE p;
    BOOL b;

    if (MigDbAttrib->AttribIndex == -1) {
        //invalid index for attribute function
        return FALSE;
    }

    p = MigDb_GetAttributeAddr (MigDbAttrib->AttribIndex);
    MYASSERT (p);

    if (MigDbAttrib->NotOperator) {
        b = !(p (AttribParams, MigDbAttrib->Arguments));
    } else {
        b = p (AttribParams, MigDbAttrib->Arguments);
    }

    return b;
}


BOOL
pCallAction (
    IN      PMIGDB_CONTEXT MigDbContext
    )

/*++

Routine Description:

  This routine calls an appropriate action for a specified migdb context.

Arguments:

  MigDbContext - See definition.

Return value:

  TRUE  - if action function succeded
  FALSE - otherwise

--*/

{
    PACTION_PROTOTYPE p;
    BOOL b;

    p = MigDb_GetActionAddr (MigDbContext->ActionIndex);

    MYASSERT (p);

    b = p (MigDbContext);

    return b;
}


BOOL
pCheckContext (
    IN      PMIGDB_CONTEXT MigDbContext,
    IN      BOOL Handled
    )

/*++

Routine Description:

  This routine checkes to see if a migdb context is met, that is if all sections
  have Satisfied field TRUE.

Arguments:

  MigDbContext - See definition.

Return value:

  always TRUE

--*/

{
    PMIGDB_SECTION migDbSection;
    BOOL contextSelected;
    BOOL result = FALSE;

    migDbSection = MigDbContext->Sections;
    contextSelected = TRUE;
    while (migDbSection) {
        if (!migDbSection->Satisfied) {
            contextSelected = FALSE;
            break;
        }
        migDbSection = migDbSection->Next;
    }
    if (contextSelected) {
        MigDbContext->TriggerCount ++;

        if (MigDbContext->ActionIndex == -1) {
            //
            // invalid index for action function
            //
            DEBUGMSG ((DBG_ERROR, "MigDb: Invalid action index"));
            return FALSE;
        }

        //
        // if appropriate call the action
        //
        if (MigDb_CallWhenTriggered (MigDbContext->ActionIndex)) {
            if ((!Handled) ||
                (MigDb_CallAlways (MigDbContext->ActionIndex))
                ) {
                result = pCallAction (MigDbContext);
            }
        }
        //clean up the grow buffer with file list
        GbFree (&MigDbContext->FileList);
    }
    return result;
}

BOOL
pQueryRule (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR ObjectNode
    )
{
    PTSTR objectBase = NULL;
    PMIGDB_RULE rule;
    PMIGDB_CHAR_NODE charNode;
    PCTSTR p;
    WORD w;
    BOOL result = FALSE;

    if (ObjectNode) {
        objectBase = DuplicatePathString (ObjectNode, 0);
        CharLower (objectBase);
    }

    g_TypeRuleList.End = 0;
    p = objectBase;
    if (p) {
        w = (WORD) _tcsnextc (p);
        charNode = g_TypeRule->FirstLevel;
        while (charNode && *p) {
            if (charNode->Char == w) {
                if (charNode->RuleList) {
                    rule = charNode->RuleList;
                    while (rule) {
                        if (IsmParsedPatternMatch (
                                (MIG_PARSEDPATTERN)rule->ParsedPattern,
                                MIG_FILE_TYPE,
                                ObjectName
                                )) {
                            CopyMemory (
                                GbGrow (&g_TypeRuleList, sizeof (PMIGDB_RULE)),
                                &(rule),
                                sizeof (PMIGDB_RULE)
                                );
                            result = TRUE;
                        }
                        rule = rule->NextRule;
                    }
                }
                charNode = charNode->NextLevel;
                p = _tcsinc (p);
                w = (WORD) _tcsnextc (p);
            } else {
                charNode = charNode->NextPeer;
            }
        }
    }

    if (objectBase) {
        FreePathString (objectBase);
    }

    return result;
}

BOOL
MigDbTestFile (
    IN OUT  PFILE_HELPER_PARAMS Params
    )

/*++

Routine Description:

  This is a callback function called for every file scanned. If the file is not handled we try
  to see if we have this file in database. If so then we check for attributes, update the migdb
  context and if necessarry call the appropriate action.

Arguments:

  Params - See definition.

Return value:

  TRUE  - if operation was successful
  FALSE - otherwise

--*/

{
    HASHITEM stringId;
    PMIGDB_RULE rule;
    PMIGDB_FILE migDbFile;
    PMIGDB_ATTRIB migDbAttrib;
    DBATTRIB_PARAMS attribParams;
    BOOL fileSelected;
    PCTSTR fileName;
    PCTSTR fileExt;
    FILE_LIST_STRUCT fileList;
    UINT index;

    // we don't check the Handled field here because the code will be carefull enough not
    // to call actions that are not gathering informations if the Handled field is not 0.

    fileName = GetFileNameFromPath (Params->NativeObjectName);
    fileExt  = GetFileExtensionFromPath (fileName);

    if (g_FileTable) {

        stringId = HtFindString (g_FileTable, fileName);

        if (stringId) {

            //The string table has extra data (a pointer to a MigDbFile node)

            HtCopyStringData (g_FileTable, stringId, &fileList);
            migDbFile = fileList.First;

            while (migDbFile) {

                //check all attributes for this file
                migDbAttrib = migDbFile->Attributes;
                fileSelected = TRUE;
                while (migDbAttrib != NULL) {
                    attribParams.FileParams = Params;
                    if (!CallAttribute (migDbAttrib, &attribParams)) {
                        fileSelected = FALSE;
                        break;
                    }
                    migDbAttrib = migDbAttrib->Next;
                }
                if (fileSelected) {
                    MYASSERT (migDbFile->Section);
                    //go to section and mark it as satisfied
                    migDbFile->Section->Satisfied = TRUE;
                    //go to context and add there the file we found in file list
                    GbMultiSzAppend (&migDbFile->Section->Context->FileList, Params->ObjectName);
                    //check if context is satisfied and if so then call the appropriate action
                    if (pCheckContext (migDbFile->Section->Context, Params->Handled)) {
                        Params->Handled = TRUE;
                    }
                }
                migDbFile = migDbFile->Next;
            }
        }
    }
    if (g_TypeRule) {
        g_TypeRuleList.End = 0;
        if (pQueryRule (Params->ObjectName, Params->ObjectNode)) {
            // let's enumerate all the matching rules to check for attributes
            index = 0;
            while (index < g_TypeRuleList.End) {
                CopyMemory (&rule, &(g_TypeRuleList.Buf[index]), sizeof (PMIGDB_RULE));

                //check all attributes for this file
                migDbAttrib = rule->Attributes;
                fileSelected = TRUE;
                while (migDbAttrib != NULL) {
                    attribParams.FileParams = Params;
                    if (!CallAttribute (migDbAttrib, &attribParams)) {
                        fileSelected = FALSE;
                        break;
                    }
                    migDbAttrib = migDbAttrib->Next;
                }
                if (fileSelected) {
                    //One last thing. See if this object is a node and the rule accepts nodes
                    if (!rule->IncludeNodes) {
                        if (IsmIsObjectHandleNodeOnly (Params->ObjectName)) {
                            fileSelected = FALSE;
                        }
                    }
                    if (fileSelected) {
                        MYASSERT (rule->Section);
                        //go to section and mark it as satisfied
                        rule->Section->Satisfied = TRUE;
                        //go to context and add there the file we found in file list
                        GbMultiSzAppend (&rule->Section->Context->FileList, Params->ObjectName);
                        //check if context is satisfied and if so then call the appropriate action
                        if (pCheckContext (rule->Section->Context, Params->Handled)) {
                            Params->Handled = TRUE;
                        }
                    }
                }
                index += sizeof (PMIGDB_RULE);
            }

        }
        g_TypeRuleList.End = 0;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\netshares.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    netshares.c

Abstract:

    <abstract>

Author:

    Jay Thaler (jthaler) 21 Apr 2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include <Winnetwk.h>
#include <Lm.h>
#include <Lmshare.h>

#define DBG_NETSHARES    "NetShares"

//
// Strings
//

#define S_NETSHARES_NAME          TEXT("NetShares")

//
// Constants
//

/* These flags are relevant for share-level security on VSERVER
 * When operating with user-level security, use SHI50F_FULL - the actual
 * access rights are determined by the NetAccess APIs.
 */
#define SHI50F_RDONLY       0x0001
#define SHI50F_FULL         0x0002
#define SHI50F_ACCESSMASK   (SHI50F_RDONLY|SHI50F_FULL)

/* The share is restored on system startup */
#define SHI50F_PERSIST      0x0100
/* The share is not normally visible  */
#define SHI50F_SYSTEM       0x0200
//
// Win9x migration net share flag, used to distinguish user-level security and
// password-level security.  When it is specified, user-level
// security is enabled, and NetShares\<share>\ACL\<list> exists.
//
#define SHI50F_ACLS         0x1000

//
// Flags that help determine when custom access is enabled
//

#define READ_ACCESS_FLAGS   0x0081
#define READ_ACCESS_MASK    0x7fff
#define FULL_ACCESS_FLAGS   0x00b7
#define FULL_ACCESS_MASK    0x7fff

#define INDEXLOCAL   0
#define INDEXREMOTE  1

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PCTSTR Pattern;
    HASHTABLE_ENUM HashData;
} NETSHARE_ENUM, *PNETSHARE_ENUM;

typedef struct {
    CHAR sharePath[MAX_PATH + 1];
} NETSHARE_DATAA, *PNETSHARE_DATAA;

typedef struct {
    WCHAR sharePath[MAX_PATH + 1];
} NETSHARE_DATAW, *PNETSHARE_DATAW;

#ifdef UNICODE
#define NETSHARE_DATA   NETSHARE_DATAW
#define PNETSHARE_DATA  PNETSHARE_DATAW
#else
#define NETSHARE_DATA   NETSHARE_DATAA
#define PNETSHARE_DATA  PNETSHARE_DATAA
#endif

//
// types not defined by public headers
//

typedef NET_API_STATUS (* ScanNetShareEnumNT) (
        LMSTR servername,
        DWORD level,
        PBYTE *bufptr,
        DWORD prefmaxlen,
        PDWORD entriesread,
        PDWORD totalentries,
        PDWORD resume_handle
        );

typedef NET_API_STATUS (* ScanNetShareEnum9x) (
        const char *      servername,
        short             level,
        char *            bufptr,
        unsigned short    prefmaxlen,
        unsigned short *  entriesread,
        unsigned short *  totalentries
        );

typedef NET_API_STATUS (* ScanNetApiBufferFreeNT) ( void *);

typedef NET_API_STATUS (* ScanNetAccessEnum9x) (
        const char *     pszServer,
        char *           pszBasePath,
        short            fsRecursive,
        short            sLevel,
        char *           pbBuffer,
        unsigned short   cbBuffer,
        unsigned short * pcEntriesRead,
        unsigned short * pcTotalAvail
        );

#pragma pack(push)
#pragma pack(1)         /* Assume byte packing throughout */

struct _share_info_50 {
        char            shi50_netname[LM20_NNLEN+1];
        unsigned char   shi50_type;
        unsigned short  shi50_flags;
        char *          shi50_remark;
        char *          shi50_path;
        char            shi50_rw_password[SHPWLEN+1];
        char            shi50_ro_password[SHPWLEN+1];
};

struct access_list_2
{
        char *          acl2_ugname;
        unsigned short  acl2_access;
};      /* access_list_2 */

struct access_info_2
{
        char *          acc2_resource_name;
        short           acc2_attr;
        unsigned short  acc2_count;
};      /* access_info_2 */

#pragma pack(pop)

//
// netapi functions
//

typedef NET_API_STATUS(WINAPI NETSHAREADDW)(
                        IN      PWSTR servername,
                        IN      DWORD level,
                        IN      PBYTE buf,
                        OUT     PDWORD parm_err
                        );
typedef NETSHAREADDW *PNETSHAREADDW;

typedef NET_API_STATUS(WINAPI NETSHAREDELW)(
                        IN      PWSTR servername,
                        IN      PWSTR netname,
                        IN      DWORD reserved
                        );
typedef NETSHAREDELW *PNETSHAREDELW;

//
// Globals
//

PMHANDLE g_NetSharesPool = NULL;
PMHANDLE g_PathPool = NULL;
HASHTABLE g_NetSharesTable;
MIG_OBJECTTYPEID g_NetShareTypeId = 0;
static BOOL g_IsWin9x = FALSE;
GROWBUFFER g_NetShareConversionBuff = INIT_GROWBUFFER;
BOOL g_NetSharesMigEnabled = FALSE;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Private prototypes
//

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstNetShare;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextNetShare;
TYPE_ABORTENUMPHYSICALOBJECT AbortEnumNetShare;
TYPE_CONVERTOBJECTTOMULTISZ ConvertNetShareToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToNetShare;
TYPE_GETNATIVEOBJECTNAME GetNativeNetShareName;
TYPE_ACQUIREPHYSICALOBJECT AcquireNetShare;
TYPE_RELEASEPHYSICALOBJECT ReleaseNetShare;
TYPE_DOESPHYSICALOBJECTEXIST DoesNetShareExist;
TYPE_REMOVEPHYSICALOBJECT RemoveNetShare;
TYPE_CREATEPHYSICALOBJECT CreateNetShare;
TYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertNetShareContentToUnicode;
TYPE_CONVERTOBJECTCONTENTTOANSI ConvertNetShareContentToAnsi;
TYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedNetShareContent;

//
// netapi functions
//

PNETSHAREADDW g_NetShareAddW = NULL;
PNETSHAREDELW g_NetShareDelW = NULL;

//
// Code
//

BOOL
NetSharesInitialize (
    VOID
    )
{
    OSVERSIONINFO versionInfo;

    ZeroMemory (&versionInfo, sizeof (OSVERSIONINFO));
    versionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (!GetVersionEx (&versionInfo)) {
        return FALSE;
    }
    g_IsWin9x = (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);

    g_PathPool = PmCreateNamedPool ("NetShares Paths");
    g_NetSharesTable = HtAllocWithData (sizeof (PNETSHARE_DATA));
    g_NetSharesPool = PmCreateNamedPool ("NetShares");

    return TRUE;
}

VOID
NetSharesTerminate (
    VOID
    )
{
    HASHTABLE_ENUM e;
    PNETSHARE_DATA netshareData;

    if (g_NetSharesTable) {
        if (EnumFirstHashTableString (&e, g_NetSharesTable)) {
            do {
                netshareData = *((PNETSHARE_DATA *) e.ExtraData);
                if (netshareData) {
                    PmReleaseMemory (g_NetSharesPool, netshareData);
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_NetSharesTable);
        g_NetSharesTable = NULL;
    }

    PmDestroyPool (g_NetSharesPool);
    g_NetSharesPool = NULL;

    PmDestroyPool (g_PathPool);
    g_PathPool = NULL;
}

BOOL
pLoadNetSharesData (
    VOID
    )
{
    DWORD  error;
    PBYTE  netBuffer = NULL;
    CHAR netBuf9x[16384];   // static because NetShareEnum is unreliable
    DWORD  netNumEntries = 0;
    DWORD  totalEntries = 0;
    DWORD  i;
    DWORD  j;
    DWORD  level;
    HINSTANCE hInst;
    PCTSTR name = NULL;
    PCTSTR path = NULL;
    PNETSHARE_DATA netshareData;

    //
    // Get the net share info from the machine
    //

    level = (g_IsWin9x ? 50 : 502);
    hInst = LoadLibraryA (g_IsWin9x ? "svrapi.dll" : "netapi32.dll");
    if (hInst == 0) {
        SetLastError (ERROR_INVALID_DLL);
        return FALSE;
    }

    if (g_IsWin9x) {
        struct _share_info_50 *tmpBuf;
        ScanNetShareEnum9x  pNetShareEnum9x  = NULL;
        ScanNetAccessEnum9x pNetAccessEnum9x = NULL;

        pNetShareEnum9x = (ScanNetShareEnum9x) GetProcAddress (hInst, "NetShareEnum");
        if (pNetShareEnum9x == NULL) {
            SetLastError (ERROR_INVALID_DLL);
            return FALSE;
        }
        pNetAccessEnum9x = (ScanNetAccessEnum9x) GetProcAddress (hInst, "NetAccessEnum");
        if (pNetAccessEnum9x == NULL) {
            SetLastError (ERROR_INVALID_DLL);
            return FALSE;
        }

        error = (*pNetShareEnum9x)(NULL,
                                   (short)level,
                                   netBuf9x,
                                   sizeof (netBuf9x),
                                   (USHORT *)&netNumEntries,
                                   (USHORT *)&totalEntries);

        if ((error == ERROR_SUCCESS) || (error == ERROR_MORE_DATA)) {

            for (i = 0; i < netNumEntries; i++) {
                DWORD dwPerms = 0;
                tmpBuf = (struct _share_info_50 *)(netBuf9x + (i * sizeof(struct _share_info_50)));

                // Require share to be a user-defined, persistent disk share
                if ((tmpBuf->shi50_flags & SHI50F_SYSTEM) ||
                   !(tmpBuf->shi50_flags & SHI50F_PERSIST) ||
                    tmpBuf->shi50_type != STYPE_DISKTREE ) {
                    continue;
                }

                if (tmpBuf->shi50_flags & SHI50F_RDONLY) {
                    dwPerms = ACCESS_READ;
                } else if (tmpBuf->shi50_flags & SHI50F_FULL) {
                    dwPerms = ACCESS_ALL;
                }

                // JTJTJT: Also store dwPerms

                //
                // Process custom access permissions
                //
                if ((tmpBuf->shi50_flags & SHI50F_ACCESSMASK) ==
                                                SHI50F_ACCESSMASK) {
                   static CHAR AccessInfoBuf[16384];
                   WORD wItemsAvail, wItemsRead;
                   error = (*pNetAccessEnum9x) (NULL,
                                     tmpBuf->shi50_path,
                                     0,
                                     2,
                                     AccessInfoBuf,
                                     sizeof (AccessInfoBuf),
                                     &wItemsRead,
                                     &wItemsAvail
                                     );

                   if (error != NERR_ACFNotLoaded) {
                       BOOL LostCustomAccess = FALSE;
                       if (error == ERROR_SUCCESS) {
                            struct access_info_2 *pai;
                            struct access_list_2 *pal;
                            pai = (struct access_info_2 *) AccessInfoBuf;
                            pal = (struct access_list_2 *) (&pai[1]);

                            for (j = 0 ; j < pai->acc2_count ; j++) {
#if 0
                    // turn off custom access support
                    // implementation is incomplete
                                if (pal->acl2_access & READ_ACCESS_FLAGS) {
                                    Win32Printf (h, "  %s, read\r\n",
                                                    pal->acl2_ugname);
                                } else if(pal->acl2_access & FULL_ACCESS_FLAGS) {
                                    Win32Printf (h, "  %s, full\r\n",
                                                    pal->acl2_ugname);
                                } else
#endif
                                    LostCustomAccess = TRUE;

                                pal++;
                            }
                            if (LostCustomAccess) {
                                DEBUGMSG ((DBG_NETSHARES, "Share %s not migrated.", tmpBuf->shi50_netname));
                                continue;
                            }
                            tmpBuf->shi50_flags |= SHI50F_ACLS;
                       } else if (error != ERROR_SUCCESS) {
                            return FALSE;
                       }
                   }
                }
                if (!(tmpBuf->shi50_flags & SHI50F_ACLS) &&
                         (tmpBuf->shi50_rw_password[0] ||
                          tmpBuf->shi50_ro_password[0])) {
                    //  IDS_SHARE_PASSWORD_NOT_MIGRATED, tmpBuf->shi50_netname
                    DEBUGMSG ((DBG_NETSHARES, "Share %s not migrated.", tmpBuf->shi50_netname));
                    continue;
                }

                // everything looks OK, let's add this entry
                name = ConvertAtoT (tmpBuf->shi50_netname);
                path = ConvertAtoT (tmpBuf->shi50_path);

                netshareData = (PNETSHARE_DATA) PmGetMemory (g_NetSharesPool, sizeof (NETSHARE_DATA));
                ZeroMemory (netshareData, sizeof (NETSHARE_DATA));

                StringCopy (netshareData->sharePath, path);
                HtAddStringEx (g_NetSharesTable, name, &netshareData, FALSE);

                FreeAtoT (name);
                INVALID_POINTER (name);
                FreeAtoT (path);
                INVALID_POINTER (path);
            }
        } else if (error == NERR_ServerNotStarted) {
             error = ERROR_SUCCESS;
        }
    } else {
        ScanNetShareEnumNT  pNetShareEnum    = NULL;
        SHARE_INFO_502* tmpBuf = NULL;

        pNetShareEnum = (ScanNetShareEnumNT) GetProcAddress(hInst, "NetShareEnum");
        if (pNetShareEnum == NULL) {
            SetLastError (ERROR_INVALID_DLL);
            return FALSE;
        }
        //
        // Call the NetShareEnum function to list the
        //  shares, specifying information level 502.
        //
        error = (*pNetShareEnum)(NULL,
                                 level,
                                 (BYTE **) &netBuffer,
                                 MAX_PREFERRED_LENGTH,
                                 &netNumEntries,
                                 &totalEntries,
                                 NULL);

        //
        // Loop through the entries; process errors.
        //
        if (error == ERROR_SUCCESS) {
            if ((tmpBuf = (SHARE_INFO_502 *)netBuffer) != NULL) {
                for (i = 0; (i < netNumEntries); i++) {
                    if (!(tmpBuf->shi502_type & STYPE_SPECIAL)) {

                        name = ConvertWtoT (tmpBuf->shi502_netname);
                        path = ConvertWtoT (tmpBuf->shi502_path);

                        netshareData = (PNETSHARE_DATA) PmGetMemory (g_NetSharesPool, sizeof (NETSHARE_DATA));
                        ZeroMemory (netshareData, sizeof (NETSHARE_DATA));

                        StringCopy (netshareData->sharePath, path);
                        HtAddStringEx (g_NetSharesTable, name, &netshareData, FALSE);
                        // JTJTJT: also store tmpBuf->shi502_permissions, tmpBuf->shi502_remark));

                        FreeWtoT (name);
                        INVALID_POINTER (name);
                        FreeWtoT (path);
                        INVALID_POINTER (path);
                    }
                    tmpBuf++;
                }
            }
        } else {
            //SetLastError (IDS_CANNOT_ENUM_NETSHARES);
            return FALSE;
        }

        if (netBuffer != NULL) {
           ScanNetApiBufferFreeNT pNetApiBufferFree = NULL;

           pNetApiBufferFree = (ScanNetApiBufferFreeNT) GetProcAddress (hInst, "NetApiBufferFree");
           if (pNetApiBufferFree != NULL)
               (*pNetApiBufferFree) (netBuffer);
        }
    }

    return TRUE;
}

BOOL
pLoadNetEntries (
    VOID
    )
{
    HMODULE netDll = NULL;
    BOOL result = FALSE;

    //
    // Get the net api entry points. Sometimes networking isn't installed.
    //

    __try {
        netDll = LoadLibrary (TEXT("NETAPI32.DLL"));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        netDll = NULL;
    }
    if (netDll) {
        g_NetShareAddW = (PNETSHAREADDW) GetProcAddress (netDll, "NetShareAdd");
        g_NetShareDelW = (PNETSHAREDELW) GetProcAddress (netDll, "NetShareDel");
        if (g_NetShareAddW && g_NetShareDelW) {
            result = TRUE;
        } else {
            result = FALSE;
            DEBUGMSG ((DBG_NETSHARES, "Not all NETAPI32 entry points were found."));
        }
    } else {
        DEBUGMSG ((DBG_NETSHARES, "NETAPI32 is not installed on this computer."));
    }
    return result;
}


BOOL
WINAPI
NetSharesEtmInitialize (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    TYPE_REGISTER netSharesTypeData;

    //
    // We need to register our type callback functions. Types allow us to
    // abstract net shares into generalized objects. The engine can perform
    // global operations with this abstraction (such as undo or compare), and
    // modules can access net shares without knowing the complexities of
    // OS-specific APIs, bugs & workarounds, storage formats, etc.  Script
    // modules can implement script capabilities that control net shares
    // without actually inventing special net share syntaxes (or even knowing
    // about net shares).
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    pLoadNetSharesData ();

    ZeroMemory (&netSharesTypeData, sizeof (TYPE_REGISTER));

    if (Platform == PLATFORM_SOURCE) {

        netSharesTypeData.EnumFirstPhysicalObject = EnumFirstNetShare;
        netSharesTypeData.EnumNextPhysicalObject = EnumNextNetShare;
        netSharesTypeData.AbortEnumPhysicalObject = AbortEnumNetShare;
        netSharesTypeData.ConvertObjectToMultiSz = ConvertNetShareToMultiSz;
        netSharesTypeData.ConvertMultiSzToObject = ConvertMultiSzToNetShare;
        netSharesTypeData.GetNativeObjectName = GetNativeNetShareName;
        netSharesTypeData.AcquirePhysicalObject = AcquireNetShare;
        netSharesTypeData.ReleasePhysicalObject = ReleaseNetShare;
        netSharesTypeData.ConvertObjectContentToUnicode = ConvertNetShareContentToUnicode;
        netSharesTypeData.ConvertObjectContentToAnsi = ConvertNetShareContentToAnsi;
        netSharesTypeData.FreeConvertedObjectContent = FreeConvertedNetShareContent;

        g_NetShareTypeId = IsmRegisterObjectType (
                                S_NETSHARES_NAME,
                                TRUE,
                                FALSE,
                                &netSharesTypeData
                                );
    } else {

        netSharesTypeData.EnumFirstPhysicalObject = EnumFirstNetShare;
        netSharesTypeData.EnumNextPhysicalObject = EnumNextNetShare;
        netSharesTypeData.AbortEnumPhysicalObject = AbortEnumNetShare;
        netSharesTypeData.ConvertObjectToMultiSz = ConvertNetShareToMultiSz;
        netSharesTypeData.ConvertMultiSzToObject = ConvertMultiSzToNetShare;
        netSharesTypeData.GetNativeObjectName = GetNativeNetShareName;
        netSharesTypeData.AcquirePhysicalObject = AcquireNetShare;
        netSharesTypeData.ReleasePhysicalObject = ReleaseNetShare;
        netSharesTypeData.DoesPhysicalObjectExist = DoesNetShareExist;
        netSharesTypeData.RemovePhysicalObject = RemoveNetShare;
        netSharesTypeData.CreatePhysicalObject = CreateNetShare;
        netSharesTypeData.ConvertObjectContentToUnicode = ConvertNetShareContentToUnicode;
        netSharesTypeData.ConvertObjectContentToAnsi = ConvertNetShareContentToAnsi;
        netSharesTypeData.FreeConvertedObjectContent = FreeConvertedNetShareContent;

        g_NetShareTypeId = IsmRegisterObjectType (
                                S_NETSHARES_NAME,
                                TRUE,
                                FALSE,
                                &netSharesTypeData
                                );
        pLoadNetEntries ();
    }

    MYASSERT (g_NetShareTypeId);
    return TRUE;
}

UINT
NetSharesCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    //
    // This callback gets called for each net share.  We simply mark the
    // share to be applied.
    //

    IsmMakeApplyObject (Data->ObjectTypeId, Data->ObjectName);

    return CALLBACK_ENUM_CONTINUE;
}

BOOL
WINAPI
NetSharesSgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    //
    // Set the log callback (so all log messages to to the app)
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}

BOOL
WINAPI
NetSharesSgmParse (
    IN      PVOID Reserved
    )
{
    PCTSTR friendlyName;

    friendlyName = GetStringResource (MSG_NET_SHARE_NAME);

    IsmAddComponentAlias (
        S_NETSHARES_NAME,
        MASTERGROUP_SYSTEM,
        friendlyName,
        COMPONENT_NAME,
        FALSE
        );

    FreeStringResource (friendlyName);
    return TRUE;
}

BOOL
WINAPI
NetSharesSgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    if (!IsmIsComponentSelected (S_NETSHARES_NAME, 0)) {
        g_NetSharesMigEnabled = FALSE;
        return TRUE;
    }
    g_NetSharesMigEnabled = TRUE;

    //
    // Queue all net shares to be applied. This could be enhanced to allow a
    // script to drive what should be restored.
    //

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, FALSE);
    IsmQueueEnumeration (g_NetShareTypeId, pattern, NetSharesCallback, (ULONG_PTR) 0, S_NETSHARES_NAME);
    IsmDestroyObjectHandle (pattern);

    return TRUE;
}

BOOL
NetSharesVcmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    //
    // Set the log callback (so all log messages to to the app)
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}

BOOL
WINAPI
NetSharesVcmParse (
    IN      PVOID Reserved
    )
{
    return NetSharesSgmParse (Reserved);
}

BOOL
WINAPI
NetSharesVcmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    if (!IsmIsComponentSelected (S_NETSHARES_NAME, 0)) {
        g_NetSharesMigEnabled = FALSE;
        return TRUE;
    }
    g_NetSharesMigEnabled = TRUE;

    //
    // Queue all net share objects to be marked as persistent
    //

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, FALSE);
    IsmQueueEnumeration (g_NetShareTypeId, pattern, NetSharesCallback, (ULONG_PTR) 0, S_NETSHARES_NAME);
    IsmDestroyObjectHandle (pattern);

    return TRUE;
}


BOOL
pEnumNetShareWorker (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      PNETSHARE_ENUM NetShareEnum
    )
{
    //
    // Test enumerated item against the pattern, and return only
    // when the pattern matches. Also, fill the entire enum
    // structure upon successful enumeration.
    //

    IsmDestroyObjectString (EnumPtr->ObjectNode);
    EnumPtr->ObjectNode = NULL;

    IsmDestroyObjectString (EnumPtr->ObjectLeaf);
    EnumPtr->ObjectLeaf = NULL;

    for (;;) {
        EnumPtr->ObjectName = IsmCreateObjectHandle (NetShareEnum->HashData.String, NULL);

        if (!ObsPatternMatch (NetShareEnum->Pattern, EnumPtr->ObjectName)) {
            if (!EnumNextHashTableString (&NetShareEnum->HashData)) {
                AbortEnumNetShare (EnumPtr);
                return FALSE;
            }
            continue;
        }

        EnumPtr->NativeObjectName = NetShareEnum->HashData.String;

        IsmCreateObjectStringsFromHandle (EnumPtr->ObjectName, &EnumPtr->ObjectNode, &EnumPtr->ObjectLeaf);

        EnumPtr->Level = 1;
        EnumPtr->SubLevel = 0;
        EnumPtr->IsLeaf = FALSE;
        EnumPtr->IsNode = TRUE;
        EnumPtr->Details.DetailsSize = 0;
        EnumPtr->Details.DetailsData = NULL;

        break;
    }

    return TRUE;
}

BOOL
EnumFirstNetShare (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,            CALLER_INITIALIZED
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    PNETSHARE_ENUM netShareEnum = NULL;

    if (!g_NetSharesTable) {
        return FALSE;
    }

    netShareEnum = (PNETSHARE_ENUM) PmGetMemory (g_NetSharesPool, sizeof (NETSHARE_ENUM));
    netShareEnum->Pattern = PmDuplicateString (g_NetSharesPool, Pattern);
    EnumPtr->EtmHandle = (LONG_PTR) netShareEnum;

    if (EnumFirstHashTableString (&netShareEnum->HashData, g_NetSharesTable)) {
        return pEnumNetShareWorker (EnumPtr, netShareEnum);
    }

    AbortEnumNetShare (EnumPtr);
    return FALSE;
}

BOOL
EnumNextNetShare (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PNETSHARE_ENUM netShareEnum = NULL;

    netShareEnum = (PNETSHARE_ENUM)(EnumPtr->EtmHandle);
    if (!netShareEnum) {
        return FALSE;
    }

    if (EnumPtr->ObjectName) {
        IsmDestroyObjectHandle (EnumPtr->ObjectName);
        EnumPtr->ObjectName = NULL;
    }

    if (EnumNextHashTableString (&netShareEnum->HashData)) {
        return pEnumNetShareWorker (EnumPtr, netShareEnum);
    }

    AbortEnumNetShare (EnumPtr);
    return FALSE;
}


VOID
AbortEnumNetShare (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PNETSHARE_ENUM netShareEnum = NULL;

    MYASSERT (EnumPtr);

    netShareEnum = (PNETSHARE_ENUM)(EnumPtr->EtmHandle);
    if (!netShareEnum) {
        return;
    }

    IsmDestroyObjectHandle (EnumPtr->ObjectName);
    IsmDestroyObjectString (EnumPtr->ObjectNode);
    IsmDestroyObjectString (EnumPtr->ObjectLeaf);
    PmReleaseMemory (g_NetSharesPool, netShareEnum->Pattern);
    PmReleaseMemory (g_NetSharesPool, netShareEnum);

    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}


BOOL
AcquireNetShare (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN OUT  PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PCTSTR node;
    PCTSTR leaf;
    PNETSHARE_DATA netshareData;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    //
    // NOTE: Do not zero ObjectContent; some of its members were already set
    //

    if (ContentType == CONTENTTYPE_FILE) {
        // nobody should request this as a file
        DEBUGMSG ((
            DBG_WHOOPS,
            "Unexpected acquire request for %s: Can't acquire net shares as files",
            ObjectName
            ));

        return FALSE;
    }

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (HtFindStringEx (g_NetSharesTable, node, (PVOID)&netshareData, FALSE)) {

            //
            // Fill in all the content members.  We already zeroed the struct,
            // so most of the members are taken care of because they are zero.
            //

            ObjectContent->MemoryContent.ContentBytes = (PBYTE)netshareData;
            ObjectContent->MemoryContent.ContentSize = sizeof(NETSHARE_DATA);

            result = TRUE;
        }

        IsmDestroyObjectString (node);
        INVALID_POINTER (node);

        IsmDestroyObjectString (leaf);
        INVALID_POINTER (leaf);
    }
    return result;
}


BOOL
ReleaseNetShare (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    //
    // Clean up routine for the AcquireNetShare function
    //

    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }

    return TRUE;
}


BOOL
DoesNetShareExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node;
    PCTSTR leaf;
    BOOL result = FALSE;

    //
    // Given an object name (the net share), we must test to see if the
    // share exists on the machine.  A table was built at initialization
    // time to provide fast access to net shares.
    //

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (HtFindStringEx (g_NetSharesTable, node, NULL, FALSE)) {
            result = TRUE;
        }

        IsmDestroyObjectString (node);
        INVALID_POINTER (node);

        IsmDestroyObjectString (leaf);
        INVALID_POINTER (leaf);
    }
    return result;
}

BOOL
RemoveNetShare (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node;
    PCTSTR leaf;
    DWORD result = ERROR_NOT_FOUND;
    PCWSTR name;

    //
    // Given an object name (the net share), we must delete the share.
    //

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (node && (!leaf)) {
            if (g_IsWin9x) {
               // JTJT: add here
            } else {

                name = CreateUnicode (node);

                if (g_NetShareDelW) {
                    // record value name deletion
                    IsmRecordOperation (JRNOP_DELETE,
                                        g_NetShareTypeId,
                                        ObjectName);
                    result = g_NetShareDelW (NULL, (PWSTR) name, 0);
                } else {
                    result = ERROR_CALL_NOT_IMPLEMENTED;
                }

                DestroyUnicode (name);
            }
            if (result != NERR_Success) {
                DEBUGMSG ((DBG_NETSHARES, "Failed to delete existent net share %s", name));
            } else {
                HtRemoveString (g_NetSharesTable, node);
            }
        }

        IsmDestroyObjectString (node);
        INVALID_POINTER (node);

        IsmDestroyObjectString (leaf);
        INVALID_POINTER (leaf);
    }
    return (result == NERR_Success);
}


BOOL
CreateNetShare (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node;
    PCTSTR leaf;
    DWORD result = NERR_Success;
    DWORD level;
    SHARE_INFO_502 shareInfo;
    PNETSHARE_DATA netshareData = NULL;

    //
    // The name of the net share is in the object name's node. The net share
    // content provides the path of the share.  Details provide the net share
    // ACLs.
    //
    // Our job is to take the object name, content and details, and create a
    // share.  We ignore the case where the content is in a file.  This should
    // not apply to net shares.
    //

    if (!ObjectContent->ContentInFile) {
        if (ObjectContent->MemoryContent.ContentBytes && ObjectContent->MemoryContent.ContentSize) {
            if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
                if (node && (!leaf)) {
                    level = (g_IsWin9x ? 50 : 502);

                    netshareData = (PNETSHARE_DATA) PmGetMemory (g_NetSharesPool, sizeof (NETSHARE_DATA));
                    CopyMemory (netshareData,
                                ObjectContent->MemoryContent.ContentBytes,
                                sizeof(NETSHARE_DATA));

                    if (DoesFileExist (netshareData->sharePath)) {

                        if (g_IsWin9x) {
                           // JTJT: add here
                        } else {
                            shareInfo.shi502_netname = (PWSTR) CreateUnicode (node);
                            shareInfo.shi502_path = (PWSTR) CreateUnicode (netshareData->sharePath);

                            shareInfo.shi502_type = STYPE_DISKTREE;       // JTJTJT: retrieve type
                            shareInfo.shi502_remark = NULL;               // JTJTJT: retrieve remark
                            shareInfo.shi502_permissions = ACCESS_ALL;    // JTJTJT: retrieve perms
                            shareInfo.shi502_max_uses = -1;               // JTJTJT: retrieve max uses
                            shareInfo.shi502_current_uses = 0;
                            shareInfo.shi502_passwd = NULL;               // JTJTJT: retrieve password
                            shareInfo.shi502_reserved = 0;
                            shareInfo.shi502_security_descriptor = NULL;  // JTJTJT: retrieve ACLs

                            if (g_NetShareAddW) {
                                IsmRecordOperation (JRNOP_CREATE,
                                                    g_NetShareTypeId,
                                                    ObjectName);
                                result = g_NetShareAddW (NULL, level, (PBYTE)&shareInfo, NULL);
                            } else {
                                result = ERROR_CALL_NOT_IMPLEMENTED;
                            }

                            DestroyUnicode (shareInfo.shi502_netname);
                            DestroyUnicode (shareInfo.shi502_path);
                        }

                        if (result != NERR_Success) {
                            DEBUGMSG ((DBG_NETSHARES, "Failed to add net share for %s", node));
                        } else {
                            HtAddStringEx (g_NetSharesTable, node, &netshareData, FALSE);
                        }
                    }
                    PmReleaseMemory (g_NetSharesPool, netshareData);
                }

                IsmDestroyObjectString (node);
                INVALID_POINTER (node);

                IsmDestroyObjectString (leaf);
                INVALID_POINTER (leaf);
            }
        }
    } else {
        DEBUGMSG ((DBG_WHOOPS, "Did not expect content to come in the form of a file."));
    }

    return (result == NERR_Success);
}

PCTSTR
ConvertNetShareToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node = NULL, leaf = NULL;
    PTSTR result;
    PNETSHARE_DATA netshareData;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        //
        // Copy field 1 (share name) and field 2 (share path) to a temp
        // multi-sz buffer
        //

        MYASSERT (!ObjectContent->ContentInFile);
        MYASSERT (ObjectContent->MemoryContent.ContentBytes);
        g_NetShareConversionBuff.End = 0;

        GbCopyQuotedString (&g_NetShareConversionBuff, node);

        if (ObjectContent->MemoryContent.ContentBytes) {
            netshareData = (PNETSHARE_DATA) PmGetMemory (g_NetSharesPool, sizeof (NETSHARE_DATA));
            CopyMemory (&netshareData->sharePath, ObjectContent->MemoryContent.ContentBytes, sizeof(NETSHARE_DATA));

            GbCopyQuotedString (&g_NetShareConversionBuff, netshareData->sharePath);

            PmReleaseMemory (g_NetSharesPool, netshareData);
            netshareData = NULL;
        }

        IsmDestroyObjectString (node);
        INVALID_POINTER (node);

        IsmDestroyObjectString (leaf);
        INVALID_POINTER (leaf);
    }

    //
    // Terminate the multi-sz
    //

    GbCopyString (&g_NetShareConversionBuff, TEXT(""));

    //
    // Transfer temp buffer to an ISM-allocated buffer and forget about it
    //

    result = IsmGetMemory (g_NetShareConversionBuff.End);
    CopyMemory (result, g_NetShareConversionBuff.Buf, g_NetShareConversionBuff.End);

    return result;
}


BOOL
ConvertMultiSzToNetShare (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    )
{
    MULTISZ_ENUM e;
    PCTSTR localName = NULL;
    UINT index;
    NETSHARE_DATA netshareData;
    BOOL pathFound = FALSE;

    //
    // Parse the multi-sz into the net share content and details.
    // The user may have edited the text (and potentially introduced
    // errors).
    //

    ZeroMemory (&netshareData, sizeof (NETSHARE_DATA));

    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }

    if (EnumFirstMultiSz (&e, ObjectMultiSz)) {
        index = 0;
        do {
            switch (index) {
            case INDEXLOCAL:
               localName = e.CurrentString;
               break;
            case INDEXREMOTE:
               pathFound = TRUE;
               StringCopy (netshareData.sharePath, e.CurrentString);
               break;
            default:
               // Ignore extra data
               DEBUGMSG ((DBG_WARNING, "Extra net share string ignored: %s", e.CurrentString));
               break;
            }

            index++;

        } while (EnumNextMultiSz (&e));
    }

    if (!localName || !pathFound) {
        //
        // Bogus data, fail
        //

        return FALSE;
    }

    //
    // Fill in all the members of the content structure. Keep in mind
    // we already zeroed the buffer.
    //

    *ObjectName = IsmCreateObjectHandle (localName, NULL);

    if (ObjectContent) {
        ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (NETSHARE_DATA));
        CopyMemory ((PBYTE) ObjectContent->MemoryContent.ContentBytes, &netshareData, sizeof (NETSHARE_DATA));
        ObjectContent->MemoryContent.ContentSize = sizeof (NETSHARE_DATA);
    }

    return TRUE;
}


PCTSTR
GetNativeNetShareName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node, leaf;
    UINT size;
    PTSTR result = NULL;

    //
    // The "native" format is what most people would use to describe our
    // object.  For the net share case, we simply get the share name from the
    // node; the node is not encoded in any way, and the leaf is not used.
    //

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (node) {
            size = SizeOfString (node);
            if (size) {
                result = IsmGetMemory (size);
                CopyMemory (result, node, size);
            }
        }

        IsmDestroyObjectString (node);
        INVALID_POINTER (node);

        IsmDestroyObjectString (leaf);
        INVALID_POINTER (leaf);
    }

    return result;
}

PMIG_CONTENT
ConvertNetShareContentToUnicode (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Mapped Drive content
            result->MemoryContent.ContentBytes = IsmGetMemory (sizeof (NETSHARE_DATAW));
            if (result->MemoryContent.ContentBytes) {
                DirectDbcsToUnicodeN (
                    ((PNETSHARE_DATAW)result->MemoryContent.ContentBytes)->sharePath,
                    ((PNETSHARE_DATAA)ObjectContent->MemoryContent.ContentBytes)->sharePath,
                    MAX_PATH + 1
                    );
                result->MemoryContent.ContentSize = sizeof (NETSHARE_DATAW);
            }
        }
    }

    return result;
}

PMIG_CONTENT
ConvertNetShareContentToAnsi (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Mapped Drive content
            result->MemoryContent.ContentBytes = IsmGetMemory (sizeof (NETSHARE_DATAA));
            if (result->MemoryContent.ContentBytes) {
                DirectUnicodeToDbcsN (
                    ((PNETSHARE_DATAA)result->MemoryContent.ContentBytes)->sharePath,
                    ((PNETSHARE_DATAW)ObjectContent->MemoryContent.ContentBytes)->sharePath,
                    MAX_PATH + 1
                    );
                result->MemoryContent.ContentSize = sizeof (NETSHARE_DATAA);
            }
        }
    }

    return result;
}

BOOL
FreeConvertedNetShareContent (
    IN      PMIG_CONTENT ObjectContent
    )
{
    if (!ObjectContent) {
        return TRUE;
    }

    if (ObjectContent->MemoryContent.ContentBytes) {
        IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
    }

    IsmReleaseMemory (ObjectContent);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\osfiles.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    osfiles.c

Abstract:

    <abstract>

Author:

    Calin Negreanu (calinn) 08 Mar 2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include "osfiles.h"

#define DBG_OSFILES     "OsFiles"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

MIG_ATTRIBUTEID g_OsFileAttribute;
PCTSTR g_InfPath = NULL;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Private prototypes
//

SGMENUMERATIONCALLBACK SgmOsFilesCallback;
VCMENUMERATIONCALLBACK VcmOsFilesCallback;

//
// Code
//

BOOL
WINAPI
OsFilesSgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    HINF infHandle;
    UINT sizeNeeded;
    ENVENTRY_TYPE dataType;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    g_OsFileAttribute = IsmRegisterAttribute (S_ATTRIBUTE_OSFILE, FALSE);

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {
        if (!InitMigDbEx (infHandle)) {
            DEBUGMSG((DBG_ERROR, "Error initializing OsFiles database"));
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
WINAPI
OsFilesSgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmHookEnumeration (MIG_FILE_TYPE, pattern, SgmOsFilesCallback, (ULONG_PTR) 0, TEXT("OsFiles"));
    IsmDestroyObjectHandle (pattern);
    return TRUE;
}

BOOL
WINAPI
OsFilesSgmQueueHighPriorityEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmHookEnumeration (MIG_FILE_TYPE, pattern, SgmOsFilesCallback, (ULONG_PTR) 0, TEXT("OsFiles"));
    IsmDestroyObjectHandle (pattern);
    return TRUE;
}

UINT
SgmOsFilesCallback (
    PCMIG_OBJECTENUMDATA Data,
    ULONG_PTR CallerArg
    )
{
    FILE_HELPER_PARAMS params;

    params.ObjectName = Data->ObjectName;
    params.NativeObjectName = Data->NativeObjectName;
    params.Handled = FALSE;
    params.FindData = (PWIN32_FIND_DATA)(Data->Details.DetailsData);
    params.ObjectNode = Data->ObjectNode;
    params.ObjectLeaf = Data->ObjectLeaf;
    params.IsNode = Data->IsNode;
    params.IsLeaf = Data->IsLeaf;

    MigDbTestFile (&params);

    return CALLBACK_ENUM_CONTINUE;
}

BOOL
WINAPI
OsFilesVcmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    HINF infHandle;
    UINT sizeNeeded;
    ENVENTRY_TYPE dataType;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    if (IsmGetRealPlatform () == PLATFORM_DESTINATION) {
        // we don't have any work to do
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    g_OsFileAttribute = IsmRegisterAttribute (S_ATTRIBUTE_OSFILE, FALSE);

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {
        if (!InitMigDbEx (infHandle)) {
            DEBUGMSG((DBG_ERROR, "Error initializing OsFiles database"));
            return FALSE;
        }
    }
    return TRUE;
}

BOOL
WINAPI
OsFilesVcmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmHookEnumeration (MIG_FILE_TYPE, pattern, VcmOsFilesCallback, (ULONG_PTR) 0, TEXT("OsFiles"));
    IsmDestroyObjectHandle (pattern);
    return TRUE;
}

BOOL
WINAPI
OsFilesVcmQueueHighPriorityEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmHookEnumeration (MIG_FILE_TYPE, pattern, VcmOsFilesCallback, (ULONG_PTR) 0, TEXT("OsFiles"));
    IsmDestroyObjectHandle (pattern);
    return TRUE;
}

UINT
VcmOsFilesCallback (
    PCMIG_OBJECTENUMDATA Data,
    ULONG_PTR CallerArg
    )
{
    FILE_HELPER_PARAMS params;

    params.ObjectName = Data->ObjectName;
    params.NativeObjectName = Data->NativeObjectName;
    params.Handled = FALSE;
    params.FindData = (PWIN32_FIND_DATA)(Data->Details.DetailsData);
    params.ObjectNode = Data->ObjectNode;
    params.ObjectLeaf = Data->ObjectLeaf;
    params.IsNode = Data->IsNode;
    params.IsLeaf = Data->IsLeaf;

    MigDbTestFile (&params);

    return CALLBACK_ENUM_CONTINUE;
}

BOOL
OsFilesInitialize (
    VOID
    )
{
    return TRUE;
}


VOID
OsFilesTerminate (
    VOID
    )
{
    DoneMigDbEx ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cookies.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\osfiles.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    osfiles.h

Abstract:

    Header file for implementing migdb functionality

Author:

    Calin Negreanu (calinn) 07-Ian-1998

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    ENCODEDSTRHANDLE  ObjectName;
    PCTSTR            NativeObjectName;
    PCTSTR            ObjectNode;
    PCTSTR            ObjectLeaf;
    BOOL              IsNode;
    BOOL              IsLeaf;
    DWORD             Handled;
    WIN32_FIND_DATA * FindData;
} FILE_HELPER_PARAMS, * PFILE_HELPER_PARAMS;

typedef struct _MIGDB_ATTRIB {
    INT     AttribIndex;
    UINT    ArgCount;
    PCTSTR  Arguments;
    BOOL    NotOperator;
    struct _MIGDB_ATTRIB *Next;
} MIGDB_ATTRIB, *PMIGDB_ATTRIB;

typedef struct _MIGDB_CONTEXT;

typedef struct _MIGDB_SECTION {
    BOOL    Satisfied;
    struct _MIGDB_CONTEXT *Context;
    struct _MIGDB_SECTION *Next;
} MIGDB_SECTION, *PMIGDB_SECTION;

typedef struct _MIGDB_CONTEXT {
    INT     ActionIndex;
    UINT    TriggerCount;
    PCTSTR  SectName;
    PCTSTR  SectLocalizedName;
    PCTSTR  SectNameForDisplay;     // SectLocalizedName, or SectName if not localized
    PCTSTR  Message;
    PCTSTR  Arguments;
    GROWBUFFER FileList;
    PMIGDB_SECTION Sections;
    struct _MIGDB_CONTEXT *Next;
} MIGDB_CONTEXT, *PMIGDB_CONTEXT;

typedef struct _MIGDB_FILE {
    PMIGDB_SECTION Section;
    PMIGDB_ATTRIB  Attributes;
    struct _MIGDB_FILE *Next;
} MIGDB_FILE, *PMIGDB_FILE;

typedef struct {
    PMIGDB_FILE First;
    PMIGDB_FILE Last;
} FILE_LIST_STRUCT, *PFILE_LIST_STRUCT;

typedef struct {
    PFILE_HELPER_PARAMS FileParams;
} DBATTRIB_PARAMS, *PDBATTRIB_PARAMS;

typedef struct _TAG_MIGDB_RULE {
    PCTSTR NodeBase;
    MIG_OBJECTSTRINGHANDLE ObjectPattern;
    POBSPARSEDPATTERN ParsedPattern;
    PMIGDB_SECTION Section;
    PMIGDB_ATTRIB  Attributes;
    INT IncludeNodes;
    struct _TAG_MIGDB_RULE *NextRule;
} MIGDB_RULE, *PMIGDB_RULE;

typedef struct _TAG_CHAR_NODE {
    PMIGDB_RULE RuleList;
    WORD Char;
    WORD Flags;
    struct _TAG_CHAR_NODE *NextLevel;
    struct _TAG_CHAR_NODE *NextPeer;
} MIGDB_CHAR_NODE, *PMIGDB_CHAR_NODE;

typedef struct {
    PMIGDB_RULE RuleList;
    PMIGDB_CHAR_NODE FirstLevel;
} MIGDB_TYPE_RULE, *PMIGDB_TYPE_RULE;

//
// Declare the attribute functions prototype
//
typedef BOOL (ATTRIBUTE_PROTOTYPE) (PDBATTRIB_PARAMS AttribParams, PCTSTR Args);
typedef ATTRIBUTE_PROTOTYPE * PATTRIBUTE_PROTOTYPE;

//
// Declare the action functions prototype
//
typedef BOOL (ACTION_PROTOTYPE) (PMIGDB_CONTEXT Context);
typedef ACTION_PROTOTYPE * PACTION_PROTOTYPE;

//
// Declare MigDb hook function prototype
//
typedef BOOL (MIGDB_HOOK_PROTOTYPE) (PCTSTR FileName, PMIGDB_CONTEXT Context, PMIGDB_SECTION Section, PMIGDB_FILE File, PMIGDB_ATTRIB Attrib);
typedef MIGDB_HOOK_PROTOTYPE * PMIGDB_HOOK_PROTOTYPE;

//
// Globals
//

extern HINF g_OsFilesInf;
extern MIG_ATTRIBUTEID g_OsFileAttribute;

//
// Macro expansion list
//

// None

//
// Macro expansion definition
//

// None

//
// Public function declarations
//

PATTRIBUTE_PROTOTYPE
MigDb_GetAttributeAddr (
    IN      INT AttributeIdx
    );

INT
MigDb_GetAttributeIdx (
    IN      PCTSTR AttributeStr
    );

UINT
MigDb_GetReqArgCount (
    IN      INT AttributeIndex
    );

PCTSTR
MigDb_GetAttributeName (
    IN      INT AttributeIdx
    );

PACTION_PROTOTYPE
MigDb_GetActionAddr (
    IN      INT ActionIdx
    );

INT
MigDb_GetActionIdx (
    IN      PCTSTR ActionStr
    );

PCTSTR
MigDb_GetActionName (
    IN      INT ActionIdx
    );

BOOL
MigDb_IsPatternFormat (
    IN      INT ActionIdx
    );

BOOL
MigDb_CallWhenTriggered (
    IN      INT ActionIdx
    );

BOOL
MigDb_CallAlways (
    IN      INT ActionIdx
    );

PMIGDB_HOOK_PROTOTYPE
SetMigDbHook (
    PMIGDB_HOOK_PROTOTYPE HookFunction
    );

BOOL
CallAttribute (
    IN      PMIGDB_ATTRIB MigDbAttrib,
    IN      PDBATTRIB_PARAMS AttribParams
    );

ULONGLONG
GetBinFileVer (
    IN      PCTSTR FileName
    );

ULONGLONG
GetBinProductVer (
    IN      PCTSTR FileName
    );

DWORD
GetFileDateHi (
    IN      PCTSTR FileName
    );

DWORD
GetFileDateLo (
    IN      PCTSTR FileName
    );

DWORD
GetFileVerOs (
    IN      PCTSTR FileName
    );

DWORD
GetFileVerType (
    IN      PCTSTR FileName
    );

BOOL
InitMigDb (
    IN      PCTSTR MigDbFile
    );

BOOL
InitMigDbEx (
    IN      HINF InfHandle
    );

BOOL
DoneMigDbEx (
    VOID
    );

BOOL
DoneMigDb (
    VOID
    );

BOOL
MigDbTestFile (
    IN      PFILE_HELPER_PARAMS Params
    );

BOOL
IsKnownMigDbFile (
    IN      PCTSTR FileName
    );

BOOL
AddFileToMigDbLinkage (
    IN      PCTSTR FileName,
    IN      PINFCONTEXT Context,        OPTIONAL
    IN      DWORD FieldIndex            OPTIONAL
    );

//
// ANSI/UNICODE macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\ansi\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\printers.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    printers.c

Abstract:

    <abstract>

Author:

    Calin Negreanu (calinn) 08 Mar 2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include <winspool.h>

#define DBG_PRINTERS    "Printers"

//
// Strings
//

#define S_PRINTERS_POOL_NAME     "Printers"
#define S_PRINTERS_NAME          TEXT("Printers")
#define S_CORPNET_NAME           TEXT("Net Printers and Drives")

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PCTSTR Pattern;
    HASHTABLE_ENUM HashData;
} PRINTER_ENUM, *PPRINTER_ENUM;

typedef struct {
    BOOL Default;
    DWORD dmFields;
    SHORT dmOrientation;
    SHORT dmPaperSize;
    SHORT dmPaperLength;
    SHORT dmPaperWidth;
    POINTL dmPosition;
    SHORT dmScale;
    SHORT dmCopies;
    SHORT dmDefaultSource;
    SHORT dmPrintQuality;
    SHORT dmColor;
    SHORT dmDuplex;
    SHORT dmYResolution;
    SHORT dmTTOption;
    SHORT dmCollate;
    CHAR dmFormName[CCHFORMNAME];
    WORD dmLogPixels;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    DWORD dmDisplayFlags;
    DWORD dmNup;
    DWORD dmDisplayFrequency;
    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmPanningWidth;
    DWORD dmPanningHeight;
} PRINTER_DATAA, *PPRINTER_DATAA;

typedef struct {
    BOOL Default;
    DWORD dmFields;
    SHORT dmOrientation;
    SHORT dmPaperSize;
    SHORT dmPaperLength;
    SHORT dmPaperWidth;
    POINTL dmPosition;
    SHORT dmScale;
    SHORT dmCopies;
    SHORT dmDefaultSource;
    SHORT dmPrintQuality;
    SHORT dmColor;
    SHORT dmDuplex;
    SHORT dmYResolution;
    SHORT dmTTOption;
    SHORT dmCollate;
    WCHAR dmFormName[CCHFORMNAME];
    WORD dmLogPixels;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    DWORD dmDisplayFlags;
    DWORD dmNup;
    DWORD dmDisplayFrequency;
    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmPanningWidth;
    DWORD dmPanningHeight;
} PRINTER_DATAW, *PPRINTER_DATAW;

#ifdef UNICODE
#define PRINTER_DATA    PRINTER_DATAW
#define PPRINTER_DATA   PPRINTER_DATAW
#else
#define PRINTER_DATA    PRINTER_DATAA
#define PPRINTER_DATA   PPRINTER_DATAA
#endif

//
// Globals
//

BOOL g_PrinterMigEnabled = FALSE;
PMHANDLE g_PrintersPool = NULL;
HASHTABLE g_PrintersTable;
MIG_OBJECTTYPEID g_PrinterTypeId = 0;
static BOOL g_IsWin9x = FALSE;
GROWBUFFER g_PrinterConversionBuff = INIT_GROWBUFFER;
BOOL g_DelayPrintersOp = FALSE;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Private prototypes
//

SGMENUMERATIONCALLBACK SgmPrintersCallback;
VCMENUMERATIONCALLBACK VcmPrintersCallback;

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstPrinter;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextPrinter;
TYPE_ABORTENUMPHYSICALOBJECT AbortEnumPrinter;
TYPE_CONVERTOBJECTTOMULTISZ ConvertPrinterToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToPrinter;
TYPE_GETNATIVEOBJECTNAME GetNativePrinterName;
TYPE_ACQUIREPHYSICALOBJECT AcquirePrinter;
TYPE_RELEASEPHYSICALOBJECT ReleasePrinter;
TYPE_DOESPHYSICALOBJECTEXIST DoesPrinterExist;
TYPE_REMOVEPHYSICALOBJECT RemovePrinter;
TYPE_CREATEPHYSICALOBJECT CreatePrinter;
TYPE_REPLACEPHYSICALOBJECT ReplacePrinter;
TYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertPrinterContentToUnicode;
TYPE_CONVERTOBJECTCONTENTTOANSI ConvertPrinterContentToAnsi;
TYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedPrinterContent;

//
// Code
//

BOOL
PrintersInitialize (
    VOID
    )
{
    OSVERSIONINFO versionInfo;

    ZeroMemory (&versionInfo, sizeof (OSVERSIONINFO));
    versionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (!GetVersionEx (&versionInfo)) {
        return FALSE;
    }
    g_IsWin9x = (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
    g_PrintersTable = HtAllocWithData (sizeof (PPRINTER_DATA));
    if (!g_PrintersTable) {
        return FALSE;
    }
    g_PrintersPool = PmCreateNamedPool (S_PRINTERS_POOL_NAME);
    return (g_PrintersPool != NULL);
}

BOOL
pLoadPrintersData (
    VOID
    )
{
    PTSTR defaultPrinter = NULL;
    PTSTR defaultPrinterPtr = NULL;
    DWORD defaultGap = 1024;
    DWORD initialSize = 0;
    DWORD resultSize = 0;
    PBYTE prnBuffer = NULL;
    DWORD prnBufferSize = 0;
    DWORD prnNumbers = 0;
    DWORD error;
    PPRINTER_INFO_2 prnInfo;
    PPRINTER_DATA printerData;

    do {
        initialSize = initialSize + defaultGap;
        defaultPrinter = (PTSTR) PmGetMemory (g_PrintersPool, initialSize * sizeof (TCHAR));
        resultSize = GetProfileString (TEXT("windows"), TEXT("device"), TEXT(",,"), defaultPrinter, initialSize);
        if (resultSize < (initialSize - 1)) {
            break;
        }
        PmReleaseMemory (g_PrintersPool, defaultPrinter);
    } while (TRUE);
    defaultPrinterPtr = _tcschr (defaultPrinter, TEXT(','));
    if (defaultPrinterPtr) {
        *defaultPrinterPtr = 0;
    }

    if (!EnumPrinters (PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS, NULL, 2, NULL, 0, &prnBufferSize, &prnNumbers)) {
        error = GetLastError ();
        if (error != ERROR_INSUFFICIENT_BUFFER) {
            PmReleaseMemory (g_PrintersPool, defaultPrinter);
            return FALSE;
        }
    }
    if (prnBufferSize) {
        prnBuffer = PmGetMemory (g_PrintersPool, prnBufferSize);
        if (!EnumPrinters (PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS, NULL, 2, prnBuffer, prnBufferSize, &prnBufferSize, &prnNumbers)) {
            PmReleaseMemory (g_PrintersPool, defaultPrinter);
            PmReleaseMemory (g_PrintersPool, prnBuffer);
            return FALSE;
        }
        prnInfo = (PPRINTER_INFO_2) (prnBuffer);
        while (prnNumbers) {
            if (prnInfo->Attributes & PRINTER_ATTRIBUTE_NETWORK) {
                printerData = (PPRINTER_DATA) PmGetMemory (g_PrintersPool, sizeof (PRINTER_DATA));
                ZeroMemory (printerData, sizeof (PRINTER_DATA));
                if (prnInfo->pDevMode) {
                    // let's save printer settings
                    printerData->dmFields = prnInfo->pDevMode->dmFields;
                    if (prnInfo->pDevMode->dmFields & DM_ORIENTATION) {
                        printerData->dmOrientation = prnInfo->pDevMode->dmOrientation;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PAPERSIZE) {
                        printerData->dmPaperSize = prnInfo->pDevMode->dmPaperSize;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PAPERLENGTH) {
                        printerData->dmPaperLength = prnInfo->pDevMode->dmPaperLength;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PAPERWIDTH) {
                        printerData->dmPaperWidth = prnInfo->pDevMode->dmPaperWidth;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_SCALE) {
                        printerData->dmScale = prnInfo->pDevMode->dmScale;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_POSITION) {
                        CopyMemory (&printerData->dmPosition, &prnInfo->pDevMode->dmPosition, sizeof(POINTL));
                    }
                    if (prnInfo->pDevMode->dmFields & DM_NUP) {
                        printerData->dmNup = prnInfo->pDevMode->dmNup;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_COPIES) {
                        printerData->dmCopies = prnInfo->pDevMode->dmCopies;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_DEFAULTSOURCE) {
                        printerData->dmDefaultSource = prnInfo->pDevMode->dmDefaultSource;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PRINTQUALITY) {
                        printerData->dmPrintQuality = prnInfo->pDevMode->dmPrintQuality;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_COLOR) {
                        printerData->dmColor = prnInfo->pDevMode->dmColor;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_DUPLEX) {
                        printerData->dmDuplex = prnInfo->pDevMode->dmDuplex;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_YRESOLUTION) {
                        printerData->dmYResolution = prnInfo->pDevMode->dmYResolution;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_TTOPTION) {
                        printerData->dmTTOption = prnInfo->pDevMode->dmTTOption;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_COLLATE) {
                        printerData->dmCollate = prnInfo->pDevMode->dmCollate;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_FORMNAME) {
                        CopyMemory (printerData->dmFormName, prnInfo->pDevMode->dmFormName, sizeof (printerData->dmFormName));
                    }
                    if (prnInfo->pDevMode->dmFields & DM_LOGPIXELS) {
                        printerData->dmLogPixels = prnInfo->pDevMode->dmLogPixels;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_BITSPERPEL) {
                        printerData->dmBitsPerPel = prnInfo->pDevMode->dmBitsPerPel;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PELSWIDTH) {
                        printerData->dmPelsWidth = prnInfo->pDevMode->dmPelsWidth;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PELSHEIGHT) {
                        printerData->dmPelsHeight = prnInfo->pDevMode->dmPelsHeight;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_DISPLAYFLAGS) {
                        printerData->dmDisplayFlags = prnInfo->pDevMode->dmDisplayFlags;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_DISPLAYFREQUENCY) {
                        printerData->dmDisplayFrequency = prnInfo->pDevMode->dmDisplayFrequency;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_ICMMETHOD) {
                        printerData->dmICMMethod = prnInfo->pDevMode->dmICMMethod;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_ICMINTENT) {
                        printerData->dmICMIntent = prnInfo->pDevMode->dmICMIntent;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_MEDIATYPE) {
                        printerData->dmMediaType = prnInfo->pDevMode->dmMediaType;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_DITHERTYPE) {
                        printerData->dmDitherType = prnInfo->pDevMode->dmDitherType;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PANNINGWIDTH) {
                        printerData->dmPanningWidth = prnInfo->pDevMode->dmPanningWidth;
                    }
                    if (prnInfo->pDevMode->dmFields & DM_PANNINGHEIGHT) {
                        printerData->dmPanningHeight = prnInfo->pDevMode->dmPanningHeight;
                    }
                }
                printerData->Default = StringIMatch (prnInfo->pPrinterName, defaultPrinter);
                if (g_IsWin9x) {
                    HtAddStringEx (g_PrintersTable, prnInfo->pPortName, &printerData, FALSE);
                } else {
                    HtAddStringEx (g_PrintersTable, prnInfo->pPrinterName, &printerData, FALSE);
                }
            }
            prnInfo ++;
            prnNumbers --;
        }
        PmReleaseMemory (g_PrintersPool, prnBuffer);
    }
    PmReleaseMemory (g_PrintersPool, defaultPrinter);
    return TRUE;
}

VOID
PrintersTerminate (
    VOID
    )
{
    HASHTABLE_ENUM e;
    PPRINTER_DATA printerData;

    GbFree (&g_PrinterConversionBuff);

    if (g_PrintersTable) {
        if (EnumFirstHashTableString (&e, g_PrintersTable)) {
            do {
                printerData = *((PPRINTER_DATA *) e.ExtraData);
                if (printerData) {
                    PmReleaseMemory (g_PrintersPool, printerData);
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_PrintersTable);
        g_PrintersTable = NULL;
    }
    if (g_PrintersPool) {
        PmDestroyPool (g_PrintersPool);
        g_PrintersPool = NULL;
    }
}

BOOL
WINAPI
PrintersEtmInitialize (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    TYPE_REGISTER printerTypeData;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    pLoadPrintersData ();

    ZeroMemory (&printerTypeData, sizeof (TYPE_REGISTER));

    if (Platform == PLATFORM_SOURCE) {

        printerTypeData.EnumFirstPhysicalObject = EnumFirstPrinter;
        printerTypeData.EnumNextPhysicalObject = EnumNextPrinter;
        printerTypeData.AbortEnumPhysicalObject = AbortEnumPrinter;
        printerTypeData.ConvertObjectToMultiSz = ConvertPrinterToMultiSz;
        printerTypeData.ConvertMultiSzToObject = ConvertMultiSzToPrinter;
        printerTypeData.GetNativeObjectName = GetNativePrinterName;
        printerTypeData.AcquirePhysicalObject = AcquirePrinter;
        printerTypeData.ReleasePhysicalObject = ReleasePrinter;
        printerTypeData.ConvertObjectContentToUnicode = ConvertPrinterContentToUnicode;
        printerTypeData.ConvertObjectContentToAnsi = ConvertPrinterContentToAnsi;
        printerTypeData.FreeConvertedObjectContent = FreeConvertedPrinterContent;

        g_PrinterTypeId = IsmRegisterObjectType (
                                S_PRINTERS_NAME,
                                TRUE,
                                FALSE,
                                &printerTypeData
                                );
    } else {

        printerTypeData.EnumFirstPhysicalObject = EnumFirstPrinter;
        printerTypeData.EnumNextPhysicalObject = EnumNextPrinter;
        printerTypeData.AbortEnumPhysicalObject = AbortEnumPrinter;
        printerTypeData.ConvertObjectToMultiSz = ConvertPrinterToMultiSz;
        printerTypeData.ConvertMultiSzToObject = ConvertMultiSzToPrinter;
        printerTypeData.GetNativeObjectName = GetNativePrinterName;
        printerTypeData.AcquirePhysicalObject = AcquirePrinter;
        printerTypeData.ReleasePhysicalObject = ReleasePrinter;
        printerTypeData.DoesPhysicalObjectExist = DoesPrinterExist;
        printerTypeData.RemovePhysicalObject = RemovePrinter;
        printerTypeData.CreatePhysicalObject = CreatePrinter;
        printerTypeData.ReplacePhysicalObject = ReplacePrinter;
        printerTypeData.ConvertObjectContentToUnicode = ConvertPrinterContentToUnicode;
        printerTypeData.ConvertObjectContentToAnsi = ConvertPrinterContentToAnsi;
        printerTypeData.FreeConvertedObjectContent = FreeConvertedPrinterContent;

        g_PrinterTypeId = IsmRegisterObjectType (
                                S_PRINTERS_NAME,
                                TRUE,
                                FALSE,
                                &printerTypeData
                                );
    }
    MYASSERT (g_PrinterTypeId);
    return TRUE;
}

VOID
WINAPI
PrintersEtmNewUserCreated (
    IN      PCTSTR UserName,
    IN      PCTSTR DomainName,
    IN      PCTSTR UserProfileRoot,
    IN      PSID UserSid
    )
{
    // a new user was created, the printer operations need to be delayed
    PrintersTerminate ();
    g_DelayPrintersOp = TRUE;
}

BOOL
WINAPI
PrintersSgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}

BOOL
WINAPI
PrintersSgmParse (
    IN      PVOID Reserved
    )
{
    PCTSTR friendlyName;

    friendlyName = GetStringResource (MSG_PRINTERS_NAME);

    //IsmAddComponentAlias (
    //    S_PRINTERS_NAME,
    //    MASTERGROUP_SYSTEM,
    //    friendlyName,
    //    COMPONENT_NAME,
    //    FALSE
    //    );

    IsmAddComponentAlias (
        S_CORPNET_NAME,
        MASTERGROUP_SYSTEM,
        friendlyName,
        COMPONENT_NAME,
        FALSE
        );

    FreeStringResource (friendlyName);
    return TRUE;
}

UINT
SgmPrintersCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    IsmAbandonObjectOnCollision (Data->ObjectTypeId, Data->ObjectName);
    IsmMakeApplyObject (Data->ObjectTypeId, Data->ObjectName);
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
WINAPI
PrintersSgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    if (!IsmIsComponentSelected (S_PRINTERS_NAME, 0) &&
        !IsmIsComponentSelected (S_CORPNET_NAME, 0)
        ) {
        g_PrinterMigEnabled = FALSE;
        return TRUE;
    }
    g_PrinterMigEnabled = TRUE;

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, FALSE);
    IsmQueueEnumeration (
        g_PrinterTypeId,
        pattern,
        SgmPrintersCallback,
        (ULONG_PTR) 0,
        S_PRINTERS_NAME
        );
    IsmDestroyObjectHandle (pattern);

    return TRUE;
}

BOOL
WINAPI
PrintersVcmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}

BOOL
WINAPI
PrintersVcmParse (
    IN      PVOID Reserved
    )
{
    return PrintersSgmParse (Reserved);
}

UINT
VcmPrintersCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    IsmMakePersistentObject (Data->ObjectTypeId, Data->ObjectName);
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
WINAPI
PrintersVcmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    if (!IsmIsComponentSelected (S_PRINTERS_NAME, 0) &&
        !IsmIsComponentSelected (S_CORPNET_NAME, 0)
        ) {
        g_PrinterMigEnabled = FALSE;
        return TRUE;
    }
    g_PrinterMigEnabled = TRUE;

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, FALSE);
    IsmQueueEnumeration (
        g_PrinterTypeId,
        pattern,
        VcmPrintersCallback,
        (ULONG_PTR) 0,
        S_PRINTERS_NAME
        );
    IsmDestroyObjectHandle (pattern);

    return TRUE;
}

BOOL
pEnumPrinterWorker (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      PPRINTER_ENUM PrinterEnum
    )
{
    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    do {
        EnumPtr->ObjectName = IsmCreateObjectHandle (PrinterEnum->HashData.String, NULL);
        if (!ObsPatternMatch (PrinterEnum->Pattern, EnumPtr->ObjectName)) {
            if (!EnumNextHashTableString (&PrinterEnum->HashData)) {
                AbortEnumPrinter (EnumPtr);
                return FALSE;
            }
            continue;
        }
        EnumPtr->NativeObjectName = PrinterEnum->HashData.String;
        IsmCreateObjectStringsFromHandle (EnumPtr->ObjectName, &EnumPtr->ObjectNode, &EnumPtr->ObjectLeaf);
        EnumPtr->Level = 1;
        EnumPtr->SubLevel = 0;
        EnumPtr->IsLeaf = FALSE;
        EnumPtr->IsNode = TRUE;
        EnumPtr->Details.DetailsSize = 0;
        EnumPtr->Details.DetailsData = NULL;
        return TRUE;
    } while (TRUE);
}

BOOL
EnumFirstPrinter (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,            CALLER_INITIALIZED
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    PPRINTER_ENUM printerEnum = NULL;

    if (!g_PrintersTable) {
        return FALSE;
    }
    printerEnum = (PPRINTER_ENUM) PmGetMemory (g_PrintersPool, sizeof (PRINTER_ENUM));
    printerEnum->Pattern = PmDuplicateString (g_PrintersPool, Pattern);
    EnumPtr->EtmHandle = (LONG_PTR) printerEnum;

    if (EnumFirstHashTableString (&printerEnum->HashData, g_PrintersTable)) {
        return pEnumPrinterWorker (EnumPtr, printerEnum);
    } else {
        AbortEnumPrinter (EnumPtr);
        return FALSE;
    }
}

BOOL
EnumNextPrinter (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PPRINTER_ENUM printerEnum = NULL;

    if (EnumPtr->ObjectName) {
        IsmDestroyObjectHandle (EnumPtr->ObjectName);
        EnumPtr->ObjectName = NULL;
    }
    printerEnum = (PPRINTER_ENUM)(EnumPtr->EtmHandle);
    if (!printerEnum) {
        return FALSE;
    }
    if (EnumNextHashTableString (&printerEnum->HashData)) {
        return pEnumPrinterWorker (EnumPtr, printerEnum);
    } else {
        AbortEnumPrinter (EnumPtr);
        return FALSE;
    }
}

VOID
AbortEnumPrinter (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PPRINTER_ENUM printerEnum = NULL;

    if (EnumPtr->ObjectName) {
        IsmDestroyObjectHandle (EnumPtr->ObjectName);
        EnumPtr->ObjectName = NULL;
    }
    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    printerEnum = (PPRINTER_ENUM)(EnumPtr->EtmHandle);
    if (!printerEnum) {
        return;
    }
    PmReleaseMemory (g_PrintersPool, printerEnum->Pattern);
    PmReleaseMemory (g_PrintersPool, printerEnum);
    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}

BOOL
AcquirePrinter (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,                 CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PCTSTR node;
    PCTSTR leaf;
    PPRINTER_DATA printerData = NULL;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    if (ContentType == CONTENTTYPE_FILE) {
        // nobody should request this as a file
        MYASSERT (FALSE);
        return FALSE;
    }

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (HtFindStringEx (g_PrintersTable, node, (PVOID)(&printerData), FALSE)) {

            ObjectContent->MemoryContent.ContentBytes = (PCBYTE)printerData;
            ObjectContent->MemoryContent.ContentSize = sizeof (PRINTER_DATA);

            result = TRUE;
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
ReleasePrinter (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }
    return TRUE;
}

BOOL
DoesPrinterExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node;
    PCTSTR leaf;
    PPRINTER_DATA printerData = NULL;
    BOOL result = FALSE;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (g_PrintersTable &&
            HtFindStringEx (g_PrintersTable, node, (PVOID)(&printerData), FALSE)
            ) {
            result = TRUE;
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
RemovePrinter (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node;
    PCTSTR leaf;
    BOOL result = FALSE;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (node && (!leaf)) {
            result = DeletePrinterConnection ((PTSTR)node);
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
CreatePrinter (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node;
    PCTSTR leaf;
    PPRINTER_DATA printerData;
    HANDLE printerHandle = NULL;
    BOOL result = FALSE;
    UINT devModeSize;
    PPRINTER_INFO_2 printerInfo;
    UINT printerInfoSize;
    PDEVMODE devMode;

    if (!ObjectContent->ContentInFile) {
        if (ObjectContent->MemoryContent.ContentBytes && ObjectContent->MemoryContent.ContentSize) {
            if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
                if (node && (!leaf)) {

                    if (g_DelayPrintersOp) {

                        // we need to delay this operation
                        // record delayed printer replace operation
                        IsmRecordDelayedOperation (
                            JRNOP_CREATE,
                            g_PrinterTypeId,
                            ObjectName,
                            ObjectContent
                            );
                        result = TRUE;

                    } else {

                        // record printer creation
                        IsmRecordOperation (
                            JRNOP_CREATE,
                            g_PrinterTypeId,
                            ObjectName
                            );

                        result = AddPrinterConnection ((PTSTR)node);
                        if (result) {
                            printerData = (PPRINTER_DATA)(ObjectContent->MemoryContent.ContentBytes);
                            if (printerData->dmFields) {
                                // let's restore printer settings
                                if (OpenPrinter ((PTSTR)node, &printerHandle, NULL)) {
                                    if (GetPrinter (printerHandle, 2, 0, 0, &printerInfoSize) || (GetLastError () == ERROR_INSUFFICIENT_BUFFER)) {
                                        printerInfo = PmGetMemory (g_PrintersPool, (printerInfoSize > sizeof (PRINTER_INFO_2))?printerInfoSize:sizeof (PRINTER_INFO_2));
                                        ZeroMemory (printerInfo, (printerInfoSize > sizeof (PRINTER_INFO_2))?printerInfoSize:sizeof (PRINTER_INFO_2));
                                        if (GetPrinter (printerHandle, 2, (PBYTE)printerInfo, printerInfoSize, &printerInfoSize)) {
                                            if (printerInfo->pDevMode) {
                                                devMode = printerInfo->pDevMode;
                                            } else {
                                                devModeSize = DocumentProperties (NULL, printerHandle, (PTSTR)node, NULL, NULL, 0);
                                                if (devModeSize) {
                                                    devMode = PmGetMemory (g_PrintersPool, (devModeSize > sizeof (DEVMODE))?devModeSize:sizeof (DEVMODE));
                                                    if (!DocumentProperties (NULL, printerHandle, (PTSTR)node, devMode, NULL, DM_OUT_BUFFER) == IDOK) {
                                                        PmReleaseMemory (g_PrintersPool, devMode);
                                                        devMode = NULL;
                                                    } else {
                                                        printerInfo->pDevMode = devMode;
                                                    }
                                                }
                                            }
                                            if (devMode) {
                                                if ((devMode->dmFields & DM_ORIENTATION) && (printerData->dmFields & DM_ORIENTATION)) {
                                                    devMode->dmOrientation = printerData->dmOrientation;
                                                }
                                                if ((devMode->dmFields & DM_PAPERSIZE) && (printerData->dmFields & DM_PAPERSIZE)) {
                                                    devMode->dmPaperSize = printerData->dmPaperSize;
                                                }
                                                if ((devMode->dmFields & DM_PAPERLENGTH) && (printerData->dmFields & DM_PAPERLENGTH)) {
                                                    devMode->dmPaperLength = printerData->dmPaperLength;
                                                }
                                                if ((devMode->dmFields & DM_PAPERWIDTH) && (printerData->dmFields & DM_PAPERWIDTH)) {
                                                    devMode->dmPaperWidth = printerData->dmPaperWidth;
                                                }
                                                if ((devMode->dmFields & DM_SCALE) && (printerData->dmFields & DM_SCALE)) {
                                                    devMode->dmScale = printerData->dmScale;
                                                }
                                                if ((devMode->dmFields & DM_POSITION) && (printerData->dmFields & DM_POSITION)) {
                                                    CopyMemory (&devMode->dmScale, &printerData->dmScale, sizeof(POINTL));
                                                }
                                                if ((devMode->dmFields & DM_NUP) && (printerData->dmFields & DM_NUP)) {
                                                    devMode->dmNup = printerData->dmNup;
                                                }
                                                if ((devMode->dmFields & DM_COPIES) && (printerData->dmFields & DM_COPIES)) {
                                                    devMode->dmCopies = printerData->dmCopies;
                                                }
                                                if ((devMode->dmFields & DM_DEFAULTSOURCE) && (printerData->dmFields & DM_DEFAULTSOURCE)) {
                                                    devMode->dmDefaultSource = printerData->dmDefaultSource;
                                                }
                                                if ((devMode->dmFields & DM_PRINTQUALITY) && (printerData->dmFields & DM_PRINTQUALITY)) {
                                                    devMode->dmPrintQuality = printerData->dmPrintQuality;
                                                }
                                                if ((devMode->dmFields & DM_COLOR) && (printerData->dmFields & DM_COLOR)) {
                                                    devMode->dmColor = printerData->dmColor;
                                                }
                                                if ((devMode->dmFields & DM_DUPLEX) && (printerData->dmFields & DM_DUPLEX)) {
                                                    devMode->dmDuplex = printerData->dmDuplex;
                                                }
                                                if ((devMode->dmFields & DM_YRESOLUTION) && (printerData->dmFields & DM_YRESOLUTION)) {
                                                    devMode->dmYResolution = printerData->dmYResolution;
                                                }
                                                if ((devMode->dmFields & DM_TTOPTION) && (printerData->dmFields & DM_TTOPTION)) {
                                                    devMode->dmTTOption = printerData->dmTTOption;
                                                }
                                                if ((devMode->dmFields & DM_COLLATE) && (printerData->dmFields & DM_COLLATE)) {
                                                    devMode->dmCollate = printerData->dmCollate;
                                                }
                                                if ((devMode->dmFields & DM_FORMNAME) && (printerData->dmFields & DM_FORMNAME)) {
                                                    CopyMemory (devMode->dmFormName, printerData->dmFormName, sizeof (devMode->dmFormName));
                                                }
                                                if ((devMode->dmFields & DM_LOGPIXELS) && (printerData->dmFields & DM_LOGPIXELS)) {
                                                    devMode->dmLogPixels = printerData->dmLogPixels;
                                                }
                                                if ((devMode->dmFields & DM_BITSPERPEL) && (printerData->dmFields & DM_BITSPERPEL)) {
                                                    devMode->dmBitsPerPel = printerData->dmBitsPerPel;
                                                }
                                                if ((devMode->dmFields & DM_PELSWIDTH) && (printerData->dmFields & DM_PELSWIDTH)) {
                                                    devMode->dmPelsWidth = printerData->dmPelsWidth;
                                                }
                                                if ((devMode->dmFields & DM_PELSHEIGHT) && (printerData->dmFields & DM_PELSHEIGHT)) {
                                                    devMode->dmPelsHeight = printerData->dmPelsHeight;
                                                }
                                                if ((devMode->dmFields & DM_DISPLAYFLAGS) && (printerData->dmFields & DM_DISPLAYFLAGS)) {
                                                    devMode->dmDisplayFlags = printerData->dmDisplayFlags;
                                                }
                                                if ((devMode->dmFields & DM_DISPLAYFREQUENCY) && (printerData->dmFields & DM_DISPLAYFREQUENCY)) {
                                                    devMode->dmDisplayFrequency = printerData->dmDisplayFrequency;
                                                }
                                                if ((devMode->dmFields & DM_ICMMETHOD) && (printerData->dmFields & DM_ICMMETHOD)) {
                                                    devMode->dmICMMethod = printerData->dmICMMethod;
                                                }
                                                if ((devMode->dmFields & DM_ICMINTENT) && (printerData->dmFields & DM_ICMINTENT)) {
                                                    devMode->dmICMIntent = printerData->dmICMIntent;
                                                }
                                                if ((devMode->dmFields & DM_MEDIATYPE) && (printerData->dmFields & DM_MEDIATYPE)) {
                                                    devMode->dmMediaType = printerData->dmMediaType;
                                                }
                                                if ((devMode->dmFields & DM_DITHERTYPE) && (printerData->dmFields & DM_DITHERTYPE)) {
                                                    devMode->dmDitherType = printerData->dmDitherType;
                                                }
                                                if ((devMode->dmFields & DM_PANNINGWIDTH) && (printerData->dmFields & DM_PANNINGWIDTH)) {
                                                    devMode->dmPanningWidth = printerData->dmPanningWidth;
                                                }
                                                if ((devMode->dmFields & DM_PANNINGHEIGHT) && (printerData->dmFields & DM_PANNINGHEIGHT)) {
                                                    devMode->dmPanningHeight = printerData->dmPanningHeight;
                                                }
                                                if (DocumentProperties (NULL, printerHandle, (PTSTR)node, devMode, devMode, DM_IN_BUFFER | DM_OUT_BUFFER) == IDOK) {
                                                    SetPrinter (printerHandle, 2, (PBYTE)printerInfo, 0);
                                                } else {
                                                    DEBUGMSG ((DBG_PRINTERS, "Failed to restore printer %s settings", node));
                                                }
                                                if (devMode != printerInfo->pDevMode) {
                                                    PmReleaseMemory (g_PrintersPool, devMode);
                                                }
                                            } else {
                                                DEBUGMSG ((DBG_PRINTERS, "Failed to restore printer %s settings", node));
                                            }
                                        } else {
                                            DEBUGMSG ((DBG_PRINTERS, "Failed to restore printer %s settings", node));
                                        }
                                        PmReleaseMemory (g_PrintersPool, printerInfo);
                                    } else {
                                        DEBUGMSG ((DBG_PRINTERS, "Failed to restore printer %s settings", node));
                                    }
                                    ClosePrinter (printerHandle);
                                } else {
                                    DEBUGMSG ((DBG_PRINTERS, "Failed to restore printer %s settings", node));
                                }
                            }
                            if (printerData && printerData->Default) {
                                result = SetDefaultPrinter (node);
                                if (!result) {
                                    DEBUGMSG ((DBG_PRINTERS, "Failed to set %s as default printer", node));
                                }
                            }
                        } else {
                            DEBUGMSG ((DBG_PRINTERS, "Failed to add printer connection for %s", node));
                        }
                    }
                }
                IsmDestroyObjectString (node);
                IsmDestroyObjectString (leaf);
            }
        }
    }
    return result;
}

BOOL
ReplacePrinter (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    BOOL result = TRUE;

    if (g_DelayPrintersOp) {

        // we need to delay this operation
        // record delayed printer replace operation
        IsmRecordDelayedOperation (
            JRNOP_REPLACE,
            g_PrinterTypeId,
            ObjectName,
            ObjectContent
            );
        result = TRUE;

    } else {

        // we are going to delete any existing printers with this name,
        // and create a new one
        if (DoesPrinterExist (ObjectName)) {
            result = RemovePrinter (ObjectName);
        }
        if (result) {
            result = CreatePrinter (ObjectName, ObjectContent);
        }
    }
    return result;
}

PCTSTR
ConvertPrinterToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node, leaf;
    PTSTR result = NULL;
    BOOL bresult = TRUE;
    PPRINTER_DATA printerData;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        MYASSERT (!leaf);

        g_PrinterConversionBuff.End = 0;

        GbCopyQuotedString (&g_PrinterConversionBuff, node);

        MYASSERT (ObjectContent->Details.DetailsSize == 0);
        MYASSERT (!ObjectContent->ContentInFile);
        MYASSERT (ObjectContent->MemoryContent.ContentSize = sizeof (PRINTER_DATA));

        if ((!ObjectContent->ContentInFile) &&
            (ObjectContent->MemoryContent.ContentSize) &&
            (ObjectContent->MemoryContent.ContentSize == sizeof (PRINTER_DATA)) &&
            (ObjectContent->MemoryContent.ContentBytes)
            ) {
            printerData = (PPRINTER_DATA)ObjectContent->MemoryContent.ContentBytes;
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->Default
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmFields
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmOrientation
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPaperSize
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPaperLength
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPaperWidth
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPosition.x
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPosition.y
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmScale
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmCopies
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmDefaultSource
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPrintQuality
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmColor
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmDuplex
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmYResolution
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmTTOption
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmCollate
                );
            GbCopyQuotedString (&g_PrinterConversionBuff, printerData->dmFormName);
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmLogPixels
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmBitsPerPel
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPelsWidth
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPelsHeight
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmDisplayFlags
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmNup
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmDisplayFrequency
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmICMMethod
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmICMIntent
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmMediaType
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmDitherType
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPanningWidth
                );
            wsprintf (
                (PTSTR) GbGrow (&g_PrinterConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                printerData->dmPanningHeight
                );
        } else {
            bresult = FALSE;
        }

        if (bresult) {
            GbCopyString (&g_PrinterConversionBuff, TEXT(""));
            result = IsmGetMemory (g_PrinterConversionBuff.End);
            CopyMemory (result, g_PrinterConversionBuff.Buf, g_PrinterConversionBuff.End);
        }

        g_PrinterConversionBuff.End = 0;

        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    return result;
}

BOOL
ConvertMultiSzToPrinter (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    )
{
    MULTISZ_ENUM multiSzEnum;
    PCTSTR name = NULL;
    PRINTER_DATA printerData;
    DWORD dummy;
    UINT index;

    g_PrinterConversionBuff.End = 0;

    ZeroMemory (&printerData, sizeof (PRINTER_DATA));

    if (EnumFirstMultiSz (&multiSzEnum, ObjectMultiSz)) {
        index = 0;
        do {
            if (index == 0) {
                name = multiSzEnum.CurrentString;
            }
            if (index == 1) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.Default = dummy;
            }
            if (index == 2) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmFields = dummy;
            }
            if (index == 3) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmOrientation = (SHORT)dummy;
            }
            if (index == 4) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPaperSize = (SHORT)dummy;
            }
            if (index == 5) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPaperLength = (SHORT)dummy;
            }
            if (index == 6) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPaperWidth = (SHORT)dummy;
            }
            if (index == 7) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPosition.x = dummy;
            }
            if (index == 8) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPosition.y = dummy;
            }
            if (index == 9) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmScale = (SHORT)dummy;
            }
            if (index == 10) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmCopies = (SHORT)dummy;
            }
            if (index == 11) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmDefaultSource = (SHORT)dummy;
            }
            if (index == 12) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPrintQuality = (SHORT)dummy;
            }
            if (index == 13) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmColor = (SHORT)dummy;
            }
            if (index == 14) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmDuplex = (SHORT)dummy;
            }
            if (index == 15) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmYResolution = (SHORT)dummy;
            }
            if (index == 16) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmTTOption = (SHORT)dummy;
            }
            if (index == 17) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmCollate = (SHORT)dummy;
            }
            if (index == 18) {
                if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                    StringCopyTcharCount (printerData.dmFormName, multiSzEnum.CurrentString, CCHFORMNAME);
                }
            }
            if (index == 19) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmLogPixels = (WORD)dummy;
            }
            if (index == 20) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmBitsPerPel = dummy;
            }
            if (index == 21) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPelsWidth = dummy;
            }
            if (index == 22) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPelsHeight = dummy;
            }
            if (index == 23) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmDisplayFlags = dummy;
            }
            if (index == 24) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmNup = dummy;
            }
            if (index == 25) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmDisplayFrequency = dummy;
            }
            if (index == 26) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmICMMethod = dummy;
            }
            if (index == 27) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmICMIntent = dummy;
            }
            if (index == 28) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmMediaType = dummy;
            }
            if (index == 29) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmDitherType = dummy;
            }
            if (index == 30) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPanningWidth = dummy;
            }
            if (index == 31) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                printerData.dmPanningHeight = dummy;
            }
            index ++;
        } while (EnumNextMultiSz (&multiSzEnum));
    }

    if (!name) {
        return FALSE;
    }

    if (ObjectContent) {

        ObjectContent->ContentInFile = FALSE;
        ObjectContent->MemoryContent.ContentSize = sizeof (PRINTER_DATA);
        ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
        CopyMemory (
            (PBYTE)ObjectContent->MemoryContent.ContentBytes,
            &printerData,
            ObjectContent->MemoryContent.ContentSize
            );

        ObjectContent->Details.DetailsSize = 0;
        ObjectContent->Details.DetailsData = NULL;
    }
    *ObjectName = IsmCreateObjectHandle (name, NULL);

    return TRUE;
}

PCTSTR
GetNativePrinterName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node, leaf;
    PTSTR nodePtr = NULL, nodeBegin = NULL;
    UINT strSize = 0;
    PTSTR result = NULL;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (node) {
            nodePtr = _tcsrchr (node, TEXT('\\'));
            if (nodePtr) {
                *nodePtr = 0;
                nodePtr ++;
            }
            nodeBegin = (PTSTR)node;
            while (*nodeBegin == TEXT('\\')) {
                nodeBegin ++;
            }
            if (nodePtr) {
                strSize = CharCount (nodePtr) +         \
                          CharCount (TEXT(" on ")) +    \
                          CharCount (nodeBegin) +       \
                          1;
                result = IsmGetMemory (strSize * sizeof (TCHAR));
                _tcscpy (result, nodePtr);
                _tcscat (result, TEXT(" on "));
                _tcscat (result, nodeBegin);
            } else {
                strSize = CharCount (nodeBegin) +       \
                          1;
                result = IsmGetMemory (strSize * sizeof (TCHAR));
                _tcscpy (result, nodeBegin);
            }
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

PMIG_CONTENT
ConvertPrinterContentToUnicode (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Printer content
            result->MemoryContent.ContentBytes = IsmGetMemory (sizeof (PRINTER_DATAW));
            if (result->MemoryContent.ContentBytes) {
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->Default =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->Default;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmFields =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmFields;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmOrientation =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmOrientation;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPaperSize =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPaperSize;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPaperLength =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPaperLength;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPaperWidth =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPaperWidth;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPosition.x =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPosition.x;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPosition.y =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPosition.y;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmScale =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmScale;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmCopies =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmCopies;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmDefaultSource =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmDefaultSource;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPrintQuality =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPrintQuality;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmColor =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmColor;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmDuplex =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmDuplex;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmYResolution =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmYResolution;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmTTOption =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmTTOption;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmCollate =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmCollate;
                DirectDbcsToUnicodeN (
                    ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmFormName,
                    ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmFormName,
                    CCHFORMNAME
                    );
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmLogPixels =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmLogPixels;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmBitsPerPel =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmBitsPerPel;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPelsWidth =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPelsWidth;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPelsHeight =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPelsHeight;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmDisplayFlags =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmDisplayFlags;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmNup =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmNup;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmDisplayFrequency =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmDisplayFrequency;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmICMMethod =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmICMMethod;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmICMIntent =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmICMIntent;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmMediaType =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmMediaType;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmDitherType =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmDitherType;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPanningWidth =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPanningWidth;
                ((PPRINTER_DATAW)result->MemoryContent.ContentBytes)->dmPanningHeight =
                ((PPRINTER_DATAA)ObjectContent->MemoryContent.ContentBytes)->dmPanningHeight;
                result->MemoryContent.ContentSize = sizeof (PRINTER_DATAW);
            }
        }
    }

    return result;
}

PMIG_CONTENT
ConvertPrinterContentToAnsi (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Printer content
            result->MemoryContent.ContentBytes = IsmGetMemory (sizeof (PRINTER_DATAW));
            if (result->MemoryContent.ContentBytes) {
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->Default =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->Default;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmFields =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmFields;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmOrientation =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmOrientation;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPaperSize =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPaperSize;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPaperLength =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPaperLength;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPaperWidth =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPaperWidth;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPosition.x =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPosition.x;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPosition.y =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPosition.y;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmScale =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmScale;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmCopies =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmCopies;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmDefaultSource =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmDefaultSource;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPrintQuality =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPrintQuality;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmColor =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmColor;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmDuplex =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmDuplex;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmYResolution =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmYResolution;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmTTOption =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmTTOption;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmCollate =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmCollate;
                DirectUnicodeToDbcsN (
                    ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmFormName,
                    ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmFormName,
                    CCHFORMNAME
                    );
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmLogPixels =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmLogPixels;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmBitsPerPel =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmBitsPerPel;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPelsWidth =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPelsWidth;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPelsHeight =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPelsHeight;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmDisplayFlags =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmDisplayFlags;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmNup =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmNup;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmDisplayFrequency =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmDisplayFrequency;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmICMMethod =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmICMMethod;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmICMIntent =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmICMIntent;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmMediaType =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmMediaType;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmDitherType =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmDitherType;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPanningWidth =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPanningWidth;
                ((PPRINTER_DATAA)result->MemoryContent.ContentBytes)->dmPanningHeight =
                ((PPRINTER_DATAW)ObjectContent->MemoryContent.ContentBytes)->dmPanningHeight;
                result->MemoryContent.ContentSize = sizeof (PRINTER_DATAA);
            }
        }
    }

    return result;
}

BOOL
FreeConvertedPrinterContent (
    IN      PMIG_CONTENT ObjectContent
    )
{
    if (!ObjectContent) {
        return TRUE;
    }

    if (ObjectContent->MemoryContent.ContentBytes) {
        IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
    }

    IsmReleaseMemory (ObjectContent);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\netdrives.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    nettype.c

Abstract:

    <abstract>

Author:

    Jay Thaler (jthaler) 21 Apr 2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include <Winnetwk.h>

#define DBG_NETRESOURCES    "MappedDrives"

//
// Strings
//

#define S_MAPPEDDRIVES_POOL_NAME        "MappedDrives"
#define S_MAPPEDDRIVES_NAME             TEXT("MappedDrives")
#define S_CORPNET_NAME                  TEXT("Net Printers and Drives")

//
// Constants
//

// none

//
// Macros
//

// none

//
// Types
//

typedef struct {
    PCTSTR Pattern;
    HASHTABLE_ENUM HashData;
} NETRESOURCE_ENUM, *PNETRESOURCE_ENUM;

typedef struct {
    DWORD DisplayType;
    DWORD Usage;
    CHAR Comment[MAX_PATH];
} NETDRIVE_DATAA, *PNETDRIVE_DATAA;

typedef struct {
    DWORD DisplayType;
    DWORD Usage;
    WCHAR Comment[MAX_PATH];
} NETDRIVE_DATAW, *PNETDRIVE_DATAW;

#ifdef UNICODE
#define NETDRIVE_DATA   NETDRIVE_DATAW
#define PNETDRIVE_DATA  PNETDRIVE_DATAW
#else
#define NETDRIVE_DATA   NETDRIVE_DATAA
#define PNETDRIVE_DATA  PNETDRIVE_DATAA
#endif

//
// Globals
//

PMHANDLE g_MappedDrivesPool = NULL;
HASHTABLE g_MappedDrivesTable;
HASHTABLE g_DriveCollisionTable;
MIG_OBJECTTYPEID g_MappedDriveTypeId = 0;
GROWBUFFER g_MappedDriveConversionBuff = INIT_GROWBUFFER;
BOOL g_MappedDrivesMigEnabled = FALSE;
DWORD g_AvailableDrives = 0;
MIG_OPERATIONID g_MappedDriveOp;
BOOL g_DelayNetDrivesOp = FALSE;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Private prototypes
//

SGMENUMERATIONCALLBACK SgmMappedDrivesCallback;
VCMENUMERATIONCALLBACK VcmMappedDrivesCallback;

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstMappedDrive;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextMappedDrive;
TYPE_ABORTENUMPHYSICALOBJECT AbortEnumMappedDrive;
TYPE_CONVERTOBJECTTOMULTISZ ConvertMappedDriveToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToMappedDrive;
TYPE_GETNATIVEOBJECTNAME GetNativeMappedDriveName;
TYPE_ACQUIREPHYSICALOBJECT AcquireMappedDrive;
TYPE_RELEASEPHYSICALOBJECT ReleaseMappedDrive;
TYPE_DOESPHYSICALOBJECTEXIST DoesMappedDriveExist;
TYPE_REMOVEPHYSICALOBJECT RemoveMappedDrive;
TYPE_CREATEPHYSICALOBJECT CreateMappedDrive;
TYPE_REPLACEPHYSICALOBJECT ReplaceMappedDrive;
TYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertMappedDriveContentToUnicode;
TYPE_CONVERTOBJECTCONTENTTOANSI ConvertMappedDriveContentToAnsi;
TYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedMappedDriveContent;

OPMFILTERCALLBACK FilterMappedDrive;

//
// Code
//

BOOL
NetDrivesInitialize (
    VOID
    )
{
    g_MappedDrivesTable = HtAllocWithData (sizeof (PNETDRIVE_DATA));
    g_MappedDrivesPool = PmCreateNamedPool (S_MAPPEDDRIVES_POOL_NAME);

    return (g_MappedDrivesPool != NULL);
}

VOID
NetDrivesTerminate (
    VOID
    )
{
    HASHTABLE_ENUM e;
    PNETDRIVE_DATA netdriveData;

    GbFree (&g_MappedDriveConversionBuff);

    if (g_MappedDrivesTable) {
        if (EnumFirstHashTableString (&e, g_MappedDrivesTable)) {
            do {
                netdriveData = *((PNETDRIVE_DATA *) e.ExtraData);
                if (netdriveData) {
                    PmReleaseMemory (g_MappedDrivesPool, netdriveData);
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_MappedDrivesTable);
        g_MappedDrivesTable = NULL;
    }
    if (g_MappedDrivesPool) {
        PmDestroyPool (g_MappedDrivesPool);
        g_MappedDrivesPool = NULL;
    }
}

BOOL
pLoadMappedDrivesData (
    VOID
    )
{
    DWORD error;
    LPNETRESOURCE netBuffer = NULL;
    HANDLE netHandle;
    DWORD netBufferSize = 16384;   // 16K is a good size
    DWORD netNumEntries = -1;      // enumerate all possible entries
    DWORD i;
    PNETDRIVE_DATA netDriveData;
    MIG_OBJECTSTRINGHANDLE netObject = NULL;

    error = WNetOpenEnum (RESOURCE_REMEMBERED, RESOURCETYPE_DISK, 0, netBuffer, &netHandle);
    if (error != NO_ERROR) {
        return FALSE;
    }

    netBuffer = PmGetMemory (g_MappedDrivesPool, netBufferSize);

    do {
        ZeroMemory(netBuffer, netBufferSize);

        error = WNetEnumResource (netHandle, &netNumEntries, netBuffer, &netBufferSize);

        if (error == ERROR_NO_MORE_ITEMS) {
            break;
        }

        if (error != NO_ERROR) {
            PmReleaseMemory (g_MappedDrivesPool, netBuffer);
            return FALSE;
        }

        for (i=0; i<netNumEntries; i++) {
            if (netBuffer[i].lpLocalName != NULL) {
                netObject = IsmCreateObjectHandle (netBuffer[i].lpLocalName, netBuffer[i].lpRemoteName);
                if (netObject) {
                    netDriveData = (PNETDRIVE_DATA) PmGetMemory (g_MappedDrivesPool, sizeof (NETDRIVE_DATA));
                    ZeroMemory (netDriveData, sizeof (NETDRIVE_DATA));
                    netDriveData->DisplayType = netBuffer[i].dwDisplayType;
                    netDriveData->Usage = netBuffer[i].dwUsage;
                    if (netBuffer[i].lpComment) {
                        StringCopyTcharCount (netDriveData->Comment, netBuffer[i].lpComment, MAX_PATH);
                    }
                    HtAddStringEx (g_MappedDrivesTable, netObject, &netDriveData, FALSE);
                    IsmDestroyObjectHandle (netObject);
                }
            }
        }
    } while (error != ERROR_NO_MORE_ITEMS);

    PmReleaseMemory (g_MappedDrivesPool, netBuffer);
    return TRUE;
}

BOOL
WINAPI
NetDrivesEtmInitialize (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    TYPE_REGISTER mappedDrivesTypeData;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    pLoadMappedDrivesData ();

    ZeroMemory (&mappedDrivesTypeData, sizeof (TYPE_REGISTER));

    if (Platform == PLATFORM_SOURCE) {

        mappedDrivesTypeData.EnumFirstPhysicalObject = EnumFirstMappedDrive;
        mappedDrivesTypeData.EnumNextPhysicalObject = EnumNextMappedDrive;
        mappedDrivesTypeData.AbortEnumPhysicalObject = AbortEnumMappedDrive;
        mappedDrivesTypeData.ConvertObjectToMultiSz = ConvertMappedDriveToMultiSz;
        mappedDrivesTypeData.ConvertMultiSzToObject = ConvertMultiSzToMappedDrive;
        mappedDrivesTypeData.GetNativeObjectName = GetNativeMappedDriveName;
        mappedDrivesTypeData.AcquirePhysicalObject = AcquireMappedDrive;
        mappedDrivesTypeData.ReleasePhysicalObject = ReleaseMappedDrive;
        mappedDrivesTypeData.ConvertObjectContentToUnicode = ConvertMappedDriveContentToUnicode;
        mappedDrivesTypeData.ConvertObjectContentToAnsi = ConvertMappedDriveContentToAnsi;
        mappedDrivesTypeData.FreeConvertedObjectContent = FreeConvertedMappedDriveContent;

        g_MappedDriveTypeId = IsmRegisterObjectType (
                                    S_MAPPEDDRIVES_NAME,
                                    TRUE,
                                    FALSE,
                                    &mappedDrivesTypeData
                                    );
    } else {

        mappedDrivesTypeData.EnumFirstPhysicalObject = EnumFirstMappedDrive;
        mappedDrivesTypeData.EnumNextPhysicalObject = EnumNextMappedDrive;
        mappedDrivesTypeData.AbortEnumPhysicalObject = AbortEnumMappedDrive;
        mappedDrivesTypeData.ConvertObjectToMultiSz = ConvertMappedDriveToMultiSz;
        mappedDrivesTypeData.ConvertMultiSzToObject = ConvertMultiSzToMappedDrive;
        mappedDrivesTypeData.GetNativeObjectName = GetNativeMappedDriveName;
        mappedDrivesTypeData.AcquirePhysicalObject = AcquireMappedDrive;
        mappedDrivesTypeData.ReleasePhysicalObject = ReleaseMappedDrive;
        mappedDrivesTypeData.DoesPhysicalObjectExist = DoesMappedDriveExist;
        mappedDrivesTypeData.RemovePhysicalObject = RemoveMappedDrive;
        mappedDrivesTypeData.CreatePhysicalObject = CreateMappedDrive;
        mappedDrivesTypeData.ReplacePhysicalObject = ReplaceMappedDrive;
        mappedDrivesTypeData.ConvertObjectContentToUnicode = ConvertMappedDriveContentToUnicode;
        mappedDrivesTypeData.ConvertObjectContentToAnsi = ConvertMappedDriveContentToAnsi;
        mappedDrivesTypeData.FreeConvertedObjectContent = FreeConvertedMappedDriveContent;

        g_MappedDriveTypeId = IsmRegisterObjectType (
                                    S_MAPPEDDRIVES_NAME,
                                    TRUE,
                                    FALSE,
                                    &mappedDrivesTypeData
                                    );
    }

    MYASSERT (g_MappedDriveTypeId);
    return TRUE;
}

VOID
WINAPI
NetDrivesEtmNewUserCreated (
    IN      PCTSTR UserName,
    IN      PCTSTR DomainName,
    IN      PCTSTR UserProfileRoot,
    IN      PSID UserSid
    )
{
    // a new user was created, the network drives operations need to be delayed
    NetDrivesTerminate ();
    g_DelayNetDrivesOp = TRUE;
}

BOOL
WINAPI
NetDrivesSgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    return TRUE;
}

BOOL
WINAPI
NetDrivesSgmParse (
    IN      PVOID Reserved
    )
{
    PCTSTR friendlyName;

    friendlyName = GetStringResource (MSG_NET_DRIVES_NAME);

    //IsmAddComponentAlias (
    //    S_MAPPEDDRIVES_NAME,
    //    MASTERGROUP_SYSTEM,
    //    friendlyName,
    //    COMPONENT_NAME,
    //    FALSE
    //    );

    IsmAddComponentAlias (
        S_CORPNET_NAME,
        MASTERGROUP_SYSTEM,
        friendlyName,
        COMPONENT_NAME,
        FALSE
        );

    FreeStringResource (friendlyName);
    return TRUE;
}

UINT
SgmMappedDrivesCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    IsmMakeApplyObject (Data->ObjectTypeId, Data->ObjectName);
    IsmSetOperationOnObject (Data->ObjectTypeId, Data->ObjectName, g_MappedDriveOp, NULL, NULL);
    IsmMakeNonCriticalObject (Data->ObjectTypeId, Data->ObjectName);
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
pEnumMappedDriveWorker (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      PNETRESOURCE_ENUM MappedDriveEnum
    )
{
    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    if (EnumPtr->NativeObjectName) {
        PmReleaseMemory (g_MappedDrivesPool, EnumPtr->NativeObjectName);
        EnumPtr->NativeObjectName = NULL;
    }
    do {
        EnumPtr->ObjectName = MappedDriveEnum->HashData.String;
        if (!ObsPatternMatch (MappedDriveEnum->Pattern, EnumPtr->ObjectName)) {
            if (!EnumNextHashTableString (&MappedDriveEnum->HashData)) {
                AbortEnumMappedDrive (EnumPtr);
                return FALSE;
            }
            continue;
        }
        IsmCreateObjectStringsFromHandle (EnumPtr->ObjectName, &EnumPtr->ObjectNode, &EnumPtr->ObjectLeaf);
        EnumPtr->NativeObjectName = JoinPathsInPoolEx ((
                                        g_MappedDrivesPool,
                                        EnumPtr->ObjectNode,
                                        TEXT("<=>"),
                                        EnumPtr->ObjectLeaf,
                                        NULL
                                        ));
        EnumPtr->Level = 1;
        EnumPtr->SubLevel = 0;
        EnumPtr->IsLeaf = FALSE;
        EnumPtr->IsNode = TRUE;
        EnumPtr->Details.DetailsSize = 0;
        EnumPtr->Details.DetailsData = NULL;
        return TRUE;
    } while (TRUE);
}

BOOL
EnumFirstMappedDrive (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,            CALLER_INITIALIZED
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    PNETRESOURCE_ENUM netResourceEnum = NULL;

    if (!g_MappedDrivesTable) {
        AbortEnumMappedDrive (EnumPtr);
        return FALSE;
    }
    netResourceEnum = (PNETRESOURCE_ENUM) PmGetMemory (g_MappedDrivesPool, sizeof (NETRESOURCE_ENUM));
    netResourceEnum->Pattern = PmDuplicateString (g_MappedDrivesPool, Pattern);
    EnumPtr->EtmHandle = (LONG_PTR) netResourceEnum;

    if (EnumFirstHashTableString (&netResourceEnum->HashData, g_MappedDrivesTable)) {
        return pEnumMappedDriveWorker (EnumPtr, netResourceEnum);
    } else {
        AbortEnumMappedDrive (EnumPtr);
        return FALSE;
    }
}

BOOL
EnumNextMappedDrive (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PNETRESOURCE_ENUM netResourceEnum = NULL;

    netResourceEnum = (PNETRESOURCE_ENUM)(EnumPtr->EtmHandle);
    if (!netResourceEnum) {
        AbortEnumMappedDrive (EnumPtr);
        return FALSE;
    }
    if (EnumNextHashTableString (&netResourceEnum->HashData)) {
        return pEnumMappedDriveWorker (EnumPtr, netResourceEnum);
    } else {
        AbortEnumMappedDrive (EnumPtr);
        return FALSE;
    }
}

VOID
AbortEnumMappedDrive (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PNETRESOURCE_ENUM netResourceEnum = NULL;

    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    if (EnumPtr->NativeObjectName) {
        PmReleaseMemory (g_MappedDrivesPool, EnumPtr->NativeObjectName);
        EnumPtr->NativeObjectName = NULL;
    }
    netResourceEnum = (PNETRESOURCE_ENUM)(EnumPtr->EtmHandle);
    if (!netResourceEnum) {
        ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
        return;
    }
    PmReleaseMemory (g_MappedDrivesPool, netResourceEnum->Pattern);
    PmReleaseMemory (g_MappedDrivesPool, netResourceEnum);
    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}

BOOL
AcquireMappedDrive (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,             CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    BOOL result = FALSE;
    PNETDRIVE_DATA netdriveData;

    if (!ObjectContent) {
        return FALSE;
    }

    // NOTE: Do not zero ObjectContent; some of its members were already set

    if (ContentType == CONTENTTYPE_FILE) {
        // nobody should request this as a file
        DEBUGMSG ((
            DBG_WHOOPS,
            "Unexpected acquire request for %s: Can't acquire mapped drives as files",
            ObjectName
            ));
        return FALSE;
    }

    if (HtFindStringEx (g_MappedDrivesTable, ObjectName, (PVOID) &netdriveData, FALSE)) {
        //
        // Fill in all the content members.  We already zeroed the struct,
        // so most of the members are taken care of because they are zero.
        //
        ObjectContent->MemoryContent.ContentBytes = (PBYTE)netdriveData;
        ObjectContent->MemoryContent.ContentSize = sizeof(NETDRIVE_DATA);

        result = TRUE;
    }
    return result;
}

BOOL
ReleaseMappedDrive (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }
    return TRUE;
}

BOOL
DoesMappedDriveExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    if (!g_MappedDrivesTable) {
        return FALSE;
    }
    return (HtFindStringEx (g_MappedDrivesTable, ObjectName, NULL, FALSE) != NULL);
}

BOOL
RemoveMappedDrive (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node;
    PCTSTR leaf;
    DWORD result = ERROR_NOT_FOUND;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (node && (leaf)) {
            IsmRecordOperation (JRNOP_DELETE,
                                g_MappedDriveTypeId,
                                ObjectName);

            // Only set CONNECT_UPDATE_PROFILE when deleting a connection that persists
            result = WNetCancelConnection2 ((LPCTSTR)node, CONNECT_UPDATE_PROFILE, TRUE);
            if (result != ERROR_SUCCESS) {
                DEBUGMSG ((DBG_NETRESOURCES, "Failed to delete existent net resource %s", node));
            }
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return (result == ERROR_SUCCESS);
}

BOOL
CreateMappedDrive (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node;
    PCTSTR leaf;
    NETRESOURCE netResource;
    BOOL result = ERROR_NOT_FOUND;
    PNETDRIVE_DATA netDriveData = NULL;


    if (!ObjectContent->ContentInFile) {
        if (ObjectContent->MemoryContent.ContentBytes && ObjectContent->MemoryContent.ContentSize) {
            if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
                if (node && (leaf)) {

                    if (g_DelayNetDrivesOp) {

                        // we need to delay this operation
                        // record delayed printer create operation
                        IsmRecordDelayedOperation (
                            JRNOP_CREATE,
                            g_MappedDriveTypeId,
                            ObjectName,
                            ObjectContent
                            );
                        result = TRUE;

                    } else {

                        netDriveData = (PNETDRIVE_DATA) PmGetMemory (g_MappedDrivesPool, sizeof (NETDRIVE_DATA));
                        CopyMemory (netDriveData, ObjectContent->MemoryContent.ContentBytes, sizeof (NETDRIVE_DATA));

                        ZeroMemory (&netResource, sizeof (NETRESOURCE));
                        netResource.dwScope = RESOURCE_REMEMBERED;
                        netResource.dwType = RESOURCETYPE_DISK;
                        netResource.dwDisplayType = netDriveData->DisplayType;
                        netResource.dwUsage = netDriveData->Usage;
                        netResource.lpLocalName = (LPTSTR)node;
                        netResource.lpRemoteName = (LPTSTR)leaf;
                        netResource.lpComment = netDriveData->Comment;
                        netResource.lpProvider = NULL;  // Let the API determine the provider

                        IsmRecordOperation (JRNOP_CREATE,
                                            g_MappedDriveTypeId,
                                            ObjectName);

                        result = WNetAddConnection2 (&netResource, NULL, NULL, CONNECT_UPDATE_PROFILE);
                        if (result != ERROR_SUCCESS) {
                            DEBUGMSG ((DBG_NETRESOURCES, "Failed to add net resource for %s", node));
                        }

                        PmReleaseMemory (g_MappedDrivesPool, netDriveData);
                    }
                }
            }
        }
    }
    SetLastError (result);
    return (result == ERROR_SUCCESS);
}


BOOL
ReplaceMappedDrive (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    BOOL result = TRUE;

    if (g_DelayNetDrivesOp) {

        // we need to delay this operation
        // record delayed printer replace operation
        IsmRecordDelayedOperation (
            JRNOP_REPLACE,
            g_MappedDriveTypeId,
            ObjectName,
            ObjectContent
            );
        result = TRUE;

    } else {

        // we are going to delete any existing net share with this name,
        // and create a new one
        if (DoesMappedDriveExist (ObjectName)) {
            result = RemoveMappedDrive (ObjectName);
        }
        if (result) {
            result = CreateMappedDrive (ObjectName, ObjectContent);
        }
    }
    return result;
}


PCTSTR
ConvertMappedDriveToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node, leaf;
    PTSTR result = NULL;
    BOOL bresult = TRUE;
    PNETDRIVE_DATA netDriveData;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        MYASSERT (leaf);

        g_MappedDriveConversionBuff.End = 0;

        GbCopyQuotedString (&g_MappedDriveConversionBuff, node);

        GbCopyQuotedString (&g_MappedDriveConversionBuff, leaf);

        MYASSERT (ObjectContent->Details.DetailsSize == 0);
        MYASSERT (!ObjectContent->ContentInFile);
        MYASSERT (ObjectContent->MemoryContent.ContentSize = sizeof (NETDRIVE_DATA));

        if (ObjectContent->MemoryContent.ContentBytes) {
            netDriveData = (PNETDRIVE_DATA)ObjectContent->MemoryContent.ContentBytes;
            wsprintf (
                (PTSTR) GbGrow (&g_MappedDriveConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                netDriveData->DisplayType
                );
            wsprintf (
                (PTSTR) GbGrow (&g_MappedDriveConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                netDriveData->Usage
                );

            GbCopyQuotedString (&g_MappedDriveConversionBuff, netDriveData->Comment);
        } else {
            bresult = FALSE;
        }

        if (bresult) {
            GbCopyString (&g_MappedDriveConversionBuff, TEXT(""));
            result = IsmGetMemory (g_MappedDriveConversionBuff.End);
            CopyMemory (result, g_MappedDriveConversionBuff.Buf, g_MappedDriveConversionBuff.End);
        }

        g_MappedDriveConversionBuff.End = 0;

        IsmDestroyObjectString (node);
        INVALID_POINTER (node);
        IsmDestroyObjectString (leaf);
        INVALID_POINTER (leaf);
    }

    return result;
}

BOOL
ConvertMultiSzToMappedDrive (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          CALLER_INITIALIZED OPTIONAL
    )
{
    MULTISZ_ENUM multiSzEnum;
    PCTSTR localName = NULL;
    PCTSTR remoteName = NULL;
    NETDRIVE_DATA netDriveData;
    DWORD dummy;
    UINT index;

    g_MappedDriveConversionBuff.End = 0;

    //
    // Parse the multi-sz into the net drive content and details.
    // The user may have edited the text (and potentially introduced
    // errors).
    //

    ZeroMemory (&netDriveData, sizeof (NETDRIVE_DATA));

    if (EnumFirstMultiSz (&multiSzEnum, ObjectMultiSz)) {
        index = 0;
        do {
            if (index == 0) {
                localName = multiSzEnum.CurrentString;
            }
            if (index == 1) {
                remoteName = multiSzEnum.CurrentString;
            }
            if (index == 2) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                netDriveData.DisplayType = dummy;
            }
            if (index == 3) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                netDriveData.Usage = dummy;
            }
            if (index == 4) {
                if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                    StringCopyTcharCount (netDriveData.Comment, multiSzEnum.CurrentString, MAX_PATH);
                }
            }
            index++;
        } while (EnumNextMultiSz (&multiSzEnum));
    }

    if (!localName || !remoteName) {
        //
        // Bogus data, fail
        //
        return FALSE;
    }

    //
    // Fill in all the members of the content structure.
    //

    if (ObjectContent) {
        ObjectContent->ContentInFile = FALSE;
        ObjectContent->MemoryContent.ContentSize = sizeof (NETDRIVE_DATA);
        ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
        CopyMemory (
            (PBYTE)ObjectContent->MemoryContent.ContentBytes,
            &netDriveData,
            ObjectContent->MemoryContent.ContentSize
            );

        ObjectContent->Details.DetailsSize = 0;
        ObjectContent->Details.DetailsData = NULL;
    }
    *ObjectName = IsmCreateObjectHandle (localName, remoteName);

    return TRUE;
}

PCTSTR
GetNativeMappedDriveName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node = NULL, leaf = NULL;
    PTSTR leafPtr = NULL, leafBegin = NULL, nodePtr = NULL;
    UINT strSize = 0;
    PTSTR result = NULL;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (leaf) {
            leafPtr = _tcsrchr (leaf, TEXT('\\'));
            if (leafPtr) {
                *leafPtr = 0;
                leafPtr ++;
            }
            leafBegin = (PTSTR)leaf;
            while (*leafBegin == TEXT('\\')) {
                leafBegin ++;
            }
        }
        if (node) {
            nodePtr = _tcsrchr (node, TEXT('\\'));
            if (nodePtr) {
                *nodePtr = 0;
            }
        }
        if (leafPtr) {
            if (node) {
                strSize = CharCount (leafPtr) +         \
                          CharCount (TEXT(" on \'")) +  \
                          CharCount (leafBegin) +       \
                          CharCount (TEXT("\' (")) +    \
                          CharCount (node) +            \
                          CharCount (TEXT(")")) +       \
                          1;
                result = IsmGetMemory (strSize * sizeof (TCHAR));
                _tcscpy (result, leafPtr);
                _tcscat (result, TEXT(" on \'"));
                _tcscat (result, leafBegin);
                _tcscat (result, TEXT("\' ("));
                _tcscat (result, node);
                _tcscat (result, TEXT(")"));
            } else {
                strSize = CharCount (leafPtr) +         \
                          CharCount (TEXT(" on \'")) +  \
                          CharCount (leafBegin) +       \
                          CharCount (TEXT("\'")) +      \
                          1;
                result = IsmGetMemory (strSize * sizeof (TCHAR));
                _tcscpy (result, leafPtr);
                _tcscat (result, TEXT(" on \'"));
                _tcscat (result, leafBegin);
                _tcscat (result, TEXT("\'"));
            }
        } else {
            if (leafBegin) {
                if (node) {
                    strSize = CharCount (TEXT("\'")) +      \
                              CharCount (leafBegin) +       \
                              CharCount (TEXT("\' (")) +    \
                              CharCount (node) +            \
                              CharCount (TEXT(")")) +       \
                              1;
                    result = IsmGetMemory (strSize * sizeof (TCHAR));
                    _tcscpy (result, TEXT("\'"));
                    _tcscat (result, leafBegin);
                    _tcscat (result, TEXT("\' ("));
                    _tcscat (result, node);
                    _tcscat (result, TEXT(")"));
                } else {
                    strSize = CharCount (TEXT("\'")) +      \
                              CharCount (leafBegin) +       \
                              CharCount (TEXT("\'")) +      \
                              1;
                    _tcscpy (result, TEXT("\'"));
                    _tcscat (result, leafBegin);
                    _tcscat (result, TEXT("\'"));
                }
            } else {
                if (node) {
                    strSize = CharCount (TEXT("(")) +       \
                              CharCount (node) +            \
                              CharCount (TEXT(")")) +       \
                              1;
                    result = IsmGetMemory (strSize * sizeof (TCHAR));
                    _tcscpy (result, TEXT("("));
                    _tcscat (result, node);
                    _tcscat (result, TEXT(")"));
                }
            }
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

PMIG_CONTENT
ConvertMappedDriveContentToUnicode (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Mapped Drive content
            result->MemoryContent.ContentBytes = IsmGetMemory (sizeof (NETDRIVE_DATAW));
            if (result->MemoryContent.ContentBytes) {
                ((PNETDRIVE_DATAW)result->MemoryContent.ContentBytes)->DisplayType =
                ((PNETDRIVE_DATAA)ObjectContent->MemoryContent.ContentBytes)->DisplayType;
                ((PNETDRIVE_DATAW)result->MemoryContent.ContentBytes)->Usage =
                ((PNETDRIVE_DATAA)ObjectContent->MemoryContent.ContentBytes)->Usage;
                DirectDbcsToUnicodeN (
                    ((PNETDRIVE_DATAW)result->MemoryContent.ContentBytes)->Comment,
                    ((PNETDRIVE_DATAA)ObjectContent->MemoryContent.ContentBytes)->Comment,
                    MAX_PATH
                    );
                result->MemoryContent.ContentSize = sizeof (NETDRIVE_DATAW);
            }
        }
    }

    return result;
}

PMIG_CONTENT
ConvertMappedDriveContentToAnsi (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Mapped Drive content
            result->MemoryContent.ContentBytes = IsmGetMemory (sizeof (NETDRIVE_DATAA));
            if (result->MemoryContent.ContentBytes) {
                ((PNETDRIVE_DATAA)result->MemoryContent.ContentBytes)->DisplayType =
                ((PNETDRIVE_DATAW)ObjectContent->MemoryContent.ContentBytes)->DisplayType;
                ((PNETDRIVE_DATAA)result->MemoryContent.ContentBytes)->Usage =
                ((PNETDRIVE_DATAW)ObjectContent->MemoryContent.ContentBytes)->Usage;
                DirectUnicodeToDbcsN (
                    ((PNETDRIVE_DATAA)result->MemoryContent.ContentBytes)->Comment,
                    ((PNETDRIVE_DATAW)ObjectContent->MemoryContent.ContentBytes)->Comment,
                    MAX_PATH
                    );
                result->MemoryContent.ContentSize = sizeof (NETDRIVE_DATAA);
            }
        }
    }

    return result;
}

BOOL
FreeConvertedMappedDriveContent (
    IN      PMIG_CONTENT ObjectContent
    )
{
    if (!ObjectContent) {
        return TRUE;
    }

    if (ObjectContent->MemoryContent.ContentBytes) {
        IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
    }

    IsmReleaseMemory (ObjectContent);

    return TRUE;
}

BOOL
WINAPI
NetDrivesVcmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}

BOOL
WINAPI
NetDrivesVcmParse (
    IN      PVOID Reserved
    )
{
    return NetDrivesSgmParse (Reserved);
}

UINT
VcmMappedDrivesCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    IsmMakePersistentObject (Data->ObjectTypeId, Data->ObjectName);
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
pCommonNetDrivesQueueEnumeration (
    IN      BOOL VcmMode
    )
{
    ENCODEDSTRHANDLE pattern;

    if (!IsmIsComponentSelected (S_MAPPEDDRIVES_NAME, 0) &&
        !IsmIsComponentSelected (S_CORPNET_NAME, 0)
        ) {
        g_MappedDrivesMigEnabled = FALSE;
        return TRUE;
    }
    g_MappedDrivesMigEnabled = TRUE;

    g_MappedDriveOp = IsmRegisterOperation (S_OPERATION_DRIVEMAP_FIXCONTENT, TRUE);

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmQueueEnumeration (
        g_MappedDriveTypeId,
        pattern,
        VcmMode ? VcmMappedDrivesCallback : SgmMappedDrivesCallback,
        (ULONG_PTR) 0,
        S_MAPPEDDRIVES_NAME
        );

    IsmDestroyObjectHandle (pattern);

    return TRUE;
}


BOOL
WINAPI
NetDrivesSgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    return pCommonNetDrivesQueueEnumeration (FALSE);
}


BOOL
WINAPI
NetDrivesVcmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    return pCommonNetDrivesQueueEnumeration (TRUE);
}


BOOL
WINAPI
NetDrivesCsmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    g_AvailableDrives = GetLogicalDrives ();
    g_DriveCollisionTable = HtAllocWithData (sizeof (TCHAR));
    return TRUE;
}

DWORD
pConvertDriveToBit (
    PCTSTR driveString
    )
{
    DWORD bit = 0;
    TCHAR driveLetter;

    if (driveString && *driveString) {
        driveLetter = (TCHAR)_totlower (*driveString);
        if (driveLetter >= TEXT('a') && driveLetter <= TEXT('z')) {
            bit = 0x1 << (driveLetter - TEXT('a'));
        }
    }
    return bit;
}

BOOL
pReserveAvailableDrive (
    TCHAR *driveLetter
    )
{
    DWORD bit;
    BOOL success = FALSE;

    // Start at bit 2 so we only map to C: or higher
    for (bit = 2; bit < 26; bit++) {
        if (!(g_AvailableDrives & (1 << bit))) {
            success = TRUE;
            g_AvailableDrives |= (1 << bit);
            *driveLetter = (TCHAR)(TEXT('a') + bit);
            break;
        }
    }

    return success;
}

BOOL
WINAPI
NetDrivesCsmExecute (
    VOID
    )
{
    GROWBUFFER collisions = INIT_GROWBUFFER;
    DWORD driveBit;
    TCHAR existingPath[MAX_PATH + 1];
    MULTISZ_ENUM e;
    TCHAR freeDrive;
    DWORD bufferSize;
    MIG_OBJECTSTRINGHANDLE pattern;
    MIG_OBJECT_ENUM objectEnum;
    PCTSTR node;
    PCTSTR leaf;
    DWORD result;

    // First, enumerate all the mapped drives and look for collisions
    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);  // *,*
    if (IsmEnumFirstSourceObject (&objectEnum, g_MappedDriveTypeId, pattern)) {
        do {
            IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
            // Leaf is the remote name.

            driveBit = pConvertDriveToBit (node);

            if (g_AvailableDrives & driveBit) {
                // Something is already there.  Is it the same thing?
                ZeroMemory (existingPath, MAX_PATH + 1);
                bufferSize = MAX_PATH + 1;
                result = WNetGetConnection (node, existingPath, &bufferSize);
                if (result != NO_ERROR) {
                    // this might be a fixed drive
                    GbMultiSzAppend (&collisions, node);
                } else {
                    if (!StringIMatch (existingPath, leaf)) {
                        // Whoops, we have a collision.  Save it for later
                        GbMultiSzAppend (&collisions, node);
                    }
                }
            } else {
                // It's free, so let's reserve it.
                g_AvailableDrives |= driveBit;
            }
            IsmDestroyObjectString (node);
            IsmDestroyObjectString (leaf);
        } while (IsmEnumNextObject (&objectEnum));
    }

    IsmDestroyObjectHandle (pattern);
    INVALID_POINTER (pattern);

    // Enumerate collided mappings and find new destinations
    if (EnumFirstMultiSz (&e, (PCTSTR) collisions.Buf)) {
        do {
            if (pReserveAvailableDrive (&freeDrive)) {
                HtAddStringEx (g_DriveCollisionTable, e.CurrentString, &freeDrive, FALSE);
            }
        } while (EnumNextMultiSz (&e));
    }

    GbFree (&collisions);

    return TRUE;
}

BOOL
WINAPI
NetDrivesOpmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    //
    // Get attribute and operation types
    //
    g_MappedDriveOp = IsmRegisterOperation (S_OPERATION_DRIVEMAP_FIXCONTENT, TRUE);

    //
    // Register operation callbacks
    //
    IsmRegisterOperationFilterCallback (g_MappedDriveOp, FilterMappedDrive, TRUE, TRUE, FALSE);

    return TRUE;
}

BOOL
WINAPI
FilterMappedDrive (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR node = NULL;
    PCTSTR leaf = NULL;
    MIG_OBJECTSTRINGHANDLE destHandle;
    TCHAR driveLetter;

    try {
        if ((InputData->CurrentObject.ObjectTypeId & (~PLATFORM_MASK)) != g_MappedDriveTypeId) {
            DEBUGMSG ((DBG_ERROR, "Unexpected object type in FilterMappedDrive"));
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (
                InputData->OriginalObject.ObjectName,
                &node,
                &leaf
                )) {
            __leave;
        }
        MYASSERT (node);
        MYASSERT (leaf);
        if (node) {
            if (HtFindStringEx (g_DriveCollisionTable, node, &driveLetter, FALSE)) {
                node[0] = driveLetter;
            }

            destHandle = IsmCreateObjectHandle (node, leaf);
            if (destHandle) {
                OutputData->NewObject.ObjectName = destHandle;
            }
        }
    }
    __finally {
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\unicode\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\rasmig.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    rasmig.c

Abstract:

    <abstract>

Author:

    Calin Negreanu (calinn) 08 Mar 2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"

#include <ras.h>
#include <raserror.h>

#define DBG_RASMIG  "RasMig"
#define SIZEOF_STRUCT(structname, uptomember)  ((int)((LPBYTE)(&((structname*)0)->uptomember) - ((LPBYTE)((structname*)0))))

//
// Strings
//

#define S_RAS_POOL_NAME     "RasConnection"
#define S_RAS_NAME          TEXT("RasConnection")
#define S_PBKFILE_ATTRIBUTE TEXT("PbkFile")
#ifdef UNICODE
#define S_RASAPI_RASSETCREDENTIALS      "RasSetCredentialsW"
#define S_RASAPI_RASDELETEENTRY         "RasDeleteEntryW"
#else
#define S_RASAPI_RASSETCREDENTIALS      "RasSetCredentialsA"
#define S_RASAPI_RASDELETEENTRY         "RasDeleteEntryA"
#endif

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// RAS api functions

typedef DWORD(WINAPI RASGETCREDENTIALSA)(
                        IN      LPCSTR lpszPhonebook,
                        IN      LPCSTR lpszEntry,
                        OUT     LPRASCREDENTIALSA lpRasCredentials
                        );
typedef RASGETCREDENTIALSA *PRASGETCREDENTIALSA;

typedef DWORD(WINAPI RASSETCREDENTIALS)(
                        IN      LPCTSTR lpszPhonebook,
                        IN      LPCTSTR lpszEntry,
                        IN      LPRASCREDENTIALS lpRasCredentials,
                        IN      BOOL fClearCredentials
                        );
typedef RASSETCREDENTIALS *PRASSETCREDENTIALS;

typedef DWORD(WINAPI RASDELETEENTRY)(
                        IN      LPCTSTR lpszPhonebook,
                        IN      LPCTSTR lpszEntry
                        );
typedef RASDELETEENTRY *PRASDELETEENTRY;

typedef struct {
    PCTSTR Pattern;
    HASHTABLE_ENUM HashData;
} RAS_ENUM, *PRAS_ENUM;

//
// Globals
//

PMHANDLE g_RasPool = NULL;
HASHTABLE g_RasTable;
MIG_OBJECTTYPEID g_RasTypeId = 0;
static MIG_OBJECTTYPEID g_FileTypeId = 0;
MIG_ATTRIBUTEID g_PbkFileAttribute = 0;
BOOL g_AllowPbkRestore = FALSE;
GROWBUFFER g_RasConversionBuff = INIT_GROWBUFFER;
MIG_OBJECTSTRINGHANDLE g_Win9xPbkFile = NULL;

// RAS api functions
PRASGETCREDENTIALSA g_RasGetCredentialsA = NULL;
PRASSETCREDENTIALS g_RasSetCredentials = NULL;
PRASDELETEENTRY g_RasDeleteEntry = NULL;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Private prototypes
//

SGMENUMERATIONCALLBACK SgmRasConnectionsCallback;
VCMENUMERATIONCALLBACK VcmRasConnectionsCallback;

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstRasConnection;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextRasConnection;
TYPE_ABORTENUMPHYSICALOBJECT AbortEnumRasConnection;
TYPE_CONVERTOBJECTTOMULTISZ ConvertRasConnectionToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToRasConnection;
TYPE_GETNATIVEOBJECTNAME GetNativeRasConnectionName;
TYPE_ACQUIREPHYSICALOBJECT AcquireRasConnection;
TYPE_RELEASEPHYSICALOBJECT ReleaseRasConnection;
TYPE_DOESPHYSICALOBJECTEXIST DoesRasConnectionExist;
TYPE_REMOVEPHYSICALOBJECT RemoveRasConnection;
TYPE_CREATEPHYSICALOBJECT CreateRasConnection;
TYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertRasConnectionContentToUnicode;
TYPE_CONVERTOBJECTCONTENTTOANSI ConvertRasConnectionContentToAnsi;
TYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedRasConnectionContent;
MIG_OBJECTENUMCALLBACK PbkFilesCallback;
MIG_RESTORECALLBACK PbkRestoreCallback;

PCTSTR
pCreate9xPbkFile (
    VOID
    );

//
// Code
//

BOOL
RasMigInitialize (
    VOID
    )
{
    g_RasTable = HtAllocWithData (sizeof (PCTSTR));
    if (!g_RasTable) {
        return FALSE;
    }
    g_RasPool = PmCreateNamedPool (S_RAS_POOL_NAME);
    if (!g_RasPool) {
        return FALSE;
    }
    return TRUE;
}

VOID
RasMigTerminate (
    VOID
    )
{
    HASHTABLE_ENUM e;
    PCTSTR nativeName;
    PCTSTR rasData = NULL;

    if (g_Win9xPbkFile) {
        nativeName = IsmGetNativeObjectName (
                        g_FileTypeId,
                        g_Win9xPbkFile
                        );
        if (nativeName) {
            DeleteFile (nativeName);
            IsmReleaseMemory (nativeName);
        }
        IsmDestroyObjectHandle (g_Win9xPbkFile);
        g_Win9xPbkFile = NULL;
    }

    GbFree (&g_RasConversionBuff);

    if (g_RasTable) {
        if (EnumFirstHashTableString (&e, g_RasTable)) {
            do {
                rasData = *(PCTSTR *)(e.ExtraData);
                PmReleaseMemory (g_RasPool, rasData);
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_RasTable);
        g_RasTable = NULL;
    }

    if (g_RasPool) {
        PmDestroyPool (g_RasPool);
        g_RasPool = NULL;
    }
}

BOOL
pLoadRasEntries (
    BOOL LeftSide
    )
{
    HMODULE rasDll = NULL;
    BOOL result = FALSE;

    __try {
        rasDll = LoadLibrary (TEXT("RASAPI32.DLL"));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        rasDll = NULL;
    }
    if (rasDll) {
        if (LeftSide) {
            g_RasGetCredentialsA = (PRASGETCREDENTIALSA) GetProcAddress (rasDll, "RasGetCredentialsA");
        } else {
            g_RasSetCredentials = (PRASSETCREDENTIALS) GetProcAddress (rasDll, S_RASAPI_RASSETCREDENTIALS);
            g_RasDeleteEntry = (PRASDELETEENTRY) GetProcAddress (rasDll, S_RASAPI_RASDELETEENTRY);
        }
    } else {
        DEBUGMSG ((DBG_RASMIG, "RAS is not installed on this computer."));
    }
    return result;
}

BOOL
pAddWin9xPbkObject (
    VOID
    )
{
    g_Win9xPbkFile = pCreate9xPbkFile ();

    return (g_Win9xPbkFile != NULL);
}

BOOL
WINAPI
RasMigEtmInitialize (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    MIG_OSVERSIONINFO versionInfo;
    TYPE_REGISTER rasConnTypeData;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    g_FileTypeId = MIG_FILE_TYPE;

    ZeroMemory (&rasConnTypeData, sizeof (TYPE_REGISTER));

    if (Platform == PLATFORM_SOURCE) {
        rasConnTypeData.EnumFirstPhysicalObject = EnumFirstRasConnection;
        rasConnTypeData.EnumNextPhysicalObject = EnumNextRasConnection;
        rasConnTypeData.AbortEnumPhysicalObject = AbortEnumRasConnection;
        rasConnTypeData.ConvertObjectToMultiSz = ConvertRasConnectionToMultiSz;
        rasConnTypeData.ConvertMultiSzToObject = ConvertMultiSzToRasConnection;
        rasConnTypeData.GetNativeObjectName = GetNativeRasConnectionName;
        rasConnTypeData.AcquirePhysicalObject = AcquireRasConnection;
        rasConnTypeData.ReleasePhysicalObject = ReleaseRasConnection;
        rasConnTypeData.ConvertObjectContentToUnicode = ConvertRasConnectionContentToUnicode;
        rasConnTypeData.ConvertObjectContentToAnsi = ConvertRasConnectionContentToAnsi;
        rasConnTypeData.FreeConvertedObjectContent = FreeConvertedRasConnectionContent;

        g_RasTypeId = IsmRegisterObjectType (
                            S_RAS_NAME,
                            TRUE,
                            FALSE,
                            &rasConnTypeData
                            );

        pLoadRasEntries (TRUE);
        if (IsmGetOsVersionInfo (Platform, &versionInfo)) {
            if (versionInfo.OsType == OSTYPE_WINDOWS9X) {
                // now it's time to convert registry into a PBK file
                pAddWin9xPbkObject ();
            }
        }
    } else {
        rasConnTypeData.ConvertObjectToMultiSz = ConvertRasConnectionToMultiSz;
        rasConnTypeData.ConvertMultiSzToObject = ConvertMultiSzToRasConnection;
        rasConnTypeData.GetNativeObjectName = GetNativeRasConnectionName;
        rasConnTypeData.DoesPhysicalObjectExist = DoesRasConnectionExist;
        rasConnTypeData.RemovePhysicalObject = RemoveRasConnection;
        rasConnTypeData.CreatePhysicalObject = CreateRasConnection;
        rasConnTypeData.ConvertObjectContentToUnicode = ConvertRasConnectionContentToUnicode;
        rasConnTypeData.ConvertObjectContentToAnsi = ConvertRasConnectionContentToAnsi;
        rasConnTypeData.FreeConvertedObjectContent = FreeConvertedRasConnectionContent;

        g_RasTypeId = IsmRegisterObjectType (
                            S_RAS_NAME,
                            TRUE,
                            FALSE,
                            &rasConnTypeData
                            );
        pLoadRasEntries (FALSE);
    }
    MYASSERT (g_RasTypeId);

    return TRUE;
}

PCTSTR
pGetNextRasConnection (
    IN      HANDLE PbkHandle
    )
{
    CHAR input = 0;
    ULONGLONG beginPos = 0;
    ULONGLONG endPos = 0;
    ULONGLONG lastPos = 0;
    PSTR resultTmp = NULL;
    PTSTR result = NULL;
#ifdef UNICODE
    WORD oldCodePage;
    DWORD sizeW = 0;
    PWSTR resultW = NULL;
#endif

    while (TRUE) {
        if (!BfReadFile (PbkHandle, (PBYTE)(&input), sizeof (CHAR))) {
            break;
        }
        if (input == '[') {
            if (!beginPos) {
                BfGetFilePointer (PbkHandle, &beginPos);
            }
        }
        if (input == ']') {
            if (beginPos) {
                if (!endPos) {
                    BfGetFilePointer (PbkHandle, &endPos);
                    endPos --;
                } else {
                    beginPos = 0;
                    endPos = 0;
                }
            }
        }
        if (input == '\n') {
            if (beginPos && endPos && (endPos > beginPos)) {
                BfGetFilePointer (PbkHandle, &lastPos);
                BfSetFilePointer (PbkHandle, beginPos);
                resultTmp = PmGetMemory (g_RasPool, ((UINT) (endPos - beginPos) + 1) * sizeof (CHAR));
                if (!BfReadFile (PbkHandle, (PBYTE) resultTmp, (UINT) (endPos - beginPos) + 1)) {
                    PmReleaseMemory (g_RasPool, resultTmp);
                    resultTmp = NULL;
                } else {
                    resultTmp [(UINT) (endPos - beginPos)] = 0;
                }
                BfSetFilePointer (PbkHandle, lastPos);
                break;
            }
            beginPos = 0;
            endPos = 0;
        }
    }
#ifdef UNICODE
    if (resultTmp) {
        // make sure that the conversion is using UTF8
        oldCodePage = SetConversionCodePage (CP_UTF8);
        sizeW = SizeOfStringA(resultTmp);
        resultW = PmGetMemory (g_RasPool, sizeW * sizeof (WCHAR));
        if (resultW) {
            KnownSizeAtoW (resultW, resultTmp);
        }
        SetConversionCodePage (oldCodePage);
        if (resultW) {
            result = PmDuplicateStringW (g_RasPool, resultW);
            PmReleaseMemory (g_RasPool, resultW);
            resultW = NULL;
        }
    }
#else
    result = resultTmp;
#endif
    return result;
}

BOOL
pGetNextRasPair (
    IN      HANDLE PbkHandle,
    OUT     PCTSTR *ValueName,
    OUT     PCTSTR *Value
    )
{
    BOOL error = FALSE;
    CHAR input = 0;
    ULONGLONG beginPos = 0;
    ULONGLONG endPos = 0;
    ULONGLONG lastPos = 0;
    BOOL begin = TRUE;
    BOOL inValue = FALSE;
    PSTR valueName = NULL;
    PSTR value = NULL;
#ifdef UNICODE
    WORD oldCodePage;
    DWORD sizeW = 0;
    PWSTR valueNameW = NULL;
    PWSTR valueW = NULL;
#endif

    BfGetFilePointer (PbkHandle, &beginPos);
    while (TRUE) {
        if (!BfReadFile (PbkHandle, (PBYTE)(&input), sizeof (CHAR))) {
            error = TRUE;
            break;
        }
        if ((input == '[') && begin) {
            BfSetFilePointer (PbkHandle, beginPos);
            error = TRUE;
            break;
        }
        if ((input == ' ') && begin) {
            continue;
        }
        begin = FALSE;
        if (input == '=') {
            if (!inValue) {
                BfGetFilePointer (PbkHandle, &endPos);
                endPos --;
                if (endPos > beginPos) {
                    BfGetFilePointer (PbkHandle, &lastPos);
                    BfSetFilePointer (PbkHandle, beginPos);
                    valueName = PmGetMemory (g_RasPool, ((UINT) (endPos - beginPos) + 1) * sizeof (CHAR));
                    if (!BfReadFile (PbkHandle, (PBYTE) valueName, (UINT) (endPos - beginPos) + 1)) {
                        error = TRUE;
                        break;
                    } else {
                        valueName [(UINT) (endPos - beginPos)] = 0;
                    }
                    BfSetFilePointer (PbkHandle, lastPos);
                }
                BfGetFilePointer (PbkHandle, &beginPos);
                inValue = TRUE;
            }
            continue;
        }
        if (input == '\r') {
            BfGetFilePointer (PbkHandle, &endPos);
            endPos --;
            continue;
        }
        if (input == '\n') {
            if (endPos > beginPos) {
                BfGetFilePointer (PbkHandle, &lastPos);
                BfSetFilePointer (PbkHandle, beginPos);
                if (inValue) {
                    value = PmGetMemory (g_RasPool, ((UINT) (endPos - beginPos) + 1) * sizeof (CHAR));
                    if (!BfReadFile (PbkHandle, (PBYTE) value, (UINT) (endPos - beginPos) + 1)) {
                        error = TRUE;
                        break;
                    } else {
                        value [(UINT) (endPos - beginPos)] = 0;
                    }
                } else {
                    valueName = PmGetMemory (g_RasPool, ((UINT) (endPos - beginPos) + 1) * sizeof (CHAR));
                    if (!BfReadFile (PbkHandle, (PBYTE) valueName, (UINT) (endPos - beginPos) + 1)) {
                        error = TRUE;
                        break;
                    } else {
                        valueName [(UINT) (endPos - beginPos)] = 0;
                    }
                }
                BfSetFilePointer (PbkHandle, lastPos);
            }
            break;
        }
    }

    if (error) {
        if (valueName) {
            PmReleaseMemory (g_RasPool, valueName);
            valueName = NULL;
        }
        if (value) {
            PmReleaseMemory (g_RasPool, value);
            value = NULL;
        }
    }
#ifdef UNICODE
    if (ValueName) {
        if (valueName) {
            // make sure that the conversion is using UTF8
            oldCodePage = SetConversionCodePage (CP_UTF8);
            sizeW = SizeOfStringA (valueName);
            valueNameW = PmGetMemory (g_RasPool, sizeW * sizeof (WCHAR));
            if (valueNameW) {
                KnownSizeAtoW (valueNameW, valueName);
            }
            SetConversionCodePage (oldCodePage);
            if (valueNameW) {
                *ValueName = PmDuplicateStringW (g_RasPool, valueNameW);
                PmReleaseMemory (g_RasPool, valueNameW);
            }
        } else {
            *ValueName = NULL;
        }
    }
    if (Value) {
        if (value) {
            // make sure that the conversion is using UTF8
            oldCodePage = SetConversionCodePage (CP_UTF8);
            sizeW = SizeOfStringA(value);
            valueW = PmGetMemory (g_RasPool, sizeW * sizeof (WCHAR));
            if (valueW) {
                KnownSizeAtoW (valueW, value);
            }
            SetConversionCodePage (oldCodePage);
            if (valueW) {
                *Value = PmDuplicateStringW (g_RasPool, valueW);
                PmReleaseMemory (g_RasPool, valueW);
            }
        } else {
            *Value = NULL;
        }
    }
#else
    if (ValueName) {
        *ValueName = valueName;
    }
    if (Value) {
        *Value = value;
    }
#endif
    return !error;
}

PCTSTR
pGetRasLineValue (
    IN      PCTSTR RasLines,
    IN      PCTSTR ValueName
    )
{
    MULTISZ_ENUM multiSzEnum;
    BOOL first = TRUE;
    BOOL found = FALSE;

    if (EnumFirstMultiSz (&multiSzEnum, RasLines)) {
        do {
            if (found) {
                return multiSzEnum.CurrentString;
            }
            if (first && StringIMatch (multiSzEnum.CurrentString, ValueName)) {
                found = TRUE;
            }
            first = !first;
        } while (EnumNextMultiSz (&multiSzEnum));
    }
    return NULL;
}

BOOL
pLoadRasConnections (
    IN      PCTSTR PbkFileName,
    IN      HASHTABLE RasTable
    )
{
    HANDLE pbkFileHandle;
    PCTSTR entryName;
    PCTSTR valueName;
    PCTSTR value;
    GROWBUFFER rasLines = INIT_GROWBUFFER;
    PTSTR rasLinesStr;
    MIG_OBJECTSTRINGHANDLE rasConnectionName;
    RASCREDENTIALSA rasCredentials;
    TCHAR valueStr [sizeof (DWORD) * 2 + 3];
    DWORD err;
    MIG_OSVERSIONINFO versionInfo;
    BOOL versionOk = FALSE;
    BOOL inMedia = FALSE;
    BOOL result = FALSE;
#ifdef UNICODE
    PCSTR tempStr1 = NULL;
    PCSTR tempStr2 = NULL;
    PCWSTR tempStr3 = NULL;
#endif

    if (!RasTable) {
        return FALSE;
    }

    pbkFileHandle = BfOpenReadFile (PbkFileName);
    if (pbkFileHandle) {
        while (TRUE) {
            // get the next RAS connection
            entryName = pGetNextRasConnection (pbkFileHandle);
            if (!entryName) {
                break;
            }
            rasLines.End = 0;
            GbMultiSzAppend (&rasLines, TEXT("ConnectionName"));
            GbMultiSzAppend (&rasLines, entryName);
            versionOk = IsmGetOsVersionInfo (PLATFORM_SOURCE, &versionInfo);
            // we use credentials API only on NT, on win9x the conversion code will automatically insert the fields
            if (!versionOk || (versionInfo.OsType != OSTYPE_WINDOWS9X)) {
                err = ERROR_INVALID_DATA;
                if (g_RasGetCredentialsA) {
                    ZeroMemory (&rasCredentials, sizeof (RASCREDENTIALSA));
                    rasCredentials.dwSize = sizeof (RASCREDENTIALSA);
                    rasCredentials.dwMask = RASCM_UserName | RASCM_Domain | RASCM_Password;
#ifdef UNICODE
                    tempStr1 = ConvertWtoA (PbkFileName);
                    tempStr2 = ConvertWtoA (entryName);
                    err = g_RasGetCredentialsA (tempStr1, tempStr2, &rasCredentials);
                    FreeConvertedStr (tempStr1);
                    FreeConvertedStr (tempStr2);
#else
                    err = g_RasGetCredentialsA (PbkFileName, entryName, &rasCredentials);
#endif
                    if (!err) {
                        wsprintf (valueStr, TEXT("0x%08X"), rasCredentials.dwMask);
                        GbMultiSzAppend (&rasLines, TEXT("CredMask"));
                        GbMultiSzAppend (&rasLines, valueStr);
                        GbMultiSzAppend (&rasLines, TEXT("CredName"));
#ifndef UNICODE
                        GbMultiSzAppend (&rasLines, (*rasCredentials.szUserName)?rasCredentials.szUserName:TEXT("<empty>"));
#else
                        tempStr3 = ConvertAtoW (rasCredentials.szUserName);
                        GbMultiSzAppend (&rasLines, (*tempStr3)?tempStr3:TEXT("<empty>"));
                        FreeConvertedStr (tempStr3);
#endif
                        GbMultiSzAppend (&rasLines, TEXT("CredDomain"));
#ifndef UNICODE
                        GbMultiSzAppend (&rasLines, (*rasCredentials.szDomain)?rasCredentials.szDomain:TEXT("<empty>"));
#else
                        tempStr3 = ConvertAtoW (rasCredentials.szDomain);
                        GbMultiSzAppend (&rasLines, (*tempStr3)?tempStr3:TEXT("<empty>"));
                        FreeConvertedStr (tempStr3);
#endif
                        GbMultiSzAppend (&rasLines, TEXT("CredPassword"));
#ifndef UNICODE
                        GbMultiSzAppend (&rasLines, (*rasCredentials.szPassword)?rasCredentials.szPassword:TEXT("<empty>"));
#else
                        tempStr3 = ConvertAtoW (rasCredentials.szPassword);
                        GbMultiSzAppend (&rasLines, (*tempStr3)?tempStr3:TEXT("<empty>"));
                        FreeConvertedStr (tempStr3);
#endif
                    }
                }
                if (err) {
                    GbMultiSzAppend (&rasLines, TEXT("CredMask"));
                    GbMultiSzAppend (&rasLines, TEXT("<empty>"));
                    GbMultiSzAppend (&rasLines, TEXT("CredName"));
                    GbMultiSzAppend (&rasLines, TEXT("<empty>"));
                    GbMultiSzAppend (&rasLines, TEXT("CredDomain"));
                    GbMultiSzAppend (&rasLines, TEXT("<empty>"));
                    GbMultiSzAppend (&rasLines, TEXT("CredPassword"));
                    GbMultiSzAppend (&rasLines, TEXT("<empty>"));
                }
            }
            inMedia = FALSE;
            while (TRUE) {
                // get the next RAS connection line
                if (!pGetNextRasPair (pbkFileHandle, &valueName, &value)) {
                    break;
                }
                if (valueName &&
                    StringMatch (valueName, TEXT("MEDIA")) &&
                    value &&
                    StringIMatch (value, TEXT("serial"))
                    ) {
                    inMedia = TRUE;
                }
                if (inMedia &&
                    valueName &&
                    StringMatch (valueName, TEXT("DEVICE"))
                    ) {
                    inMedia = FALSE;
                }
                if (inMedia &&
                    valueName &&
                    StringIMatch (valueName, TEXT("Port"))
                    ) {
                    if (value) {
                        PmReleaseMemory (g_RasPool, value);
                        value = NULL;
                    }
                }
                if (inMedia &&
                    valueName &&
                    StringMatch (valueName, TEXT("Device"))
                    ) {
                    if (value) {
                        PmReleaseMemory (g_RasPool, value);
                        value = NULL;
                    }
                }
                GbMultiSzAppend (&rasLines, valueName?valueName:TEXT("<empty>"));
                GbMultiSzAppend (&rasLines, value?value:TEXT("<empty>"));
                if (valueName) {
                    PmReleaseMemory (g_RasPool, valueName);
                    valueName = NULL;
                }
                if (value) {
                    PmReleaseMemory (g_RasPool, value);
                    value = NULL;
                }
            }
            GbMultiSzAppend (&rasLines, TEXT(""));
            if (rasLines.End) {
                // now add the RAS connection
                rasLinesStr = PmGetMemory (g_RasPool, rasLines.End);
                CopyMemory (rasLinesStr, rasLines.Buf, rasLines.End);
                rasConnectionName = IsmCreateObjectHandle (PbkFileName, entryName);
                MYASSERT (rasConnectionName);
                if (rasConnectionName) {
                    result = TRUE;
                    HtAddStringEx (RasTable, rasConnectionName, &rasLinesStr, FALSE);
                }
                IsmDestroyObjectHandle (rasConnectionName);
            }
            PmReleaseMemory (g_RasPool, entryName);
        }

        CloseHandle (pbkFileHandle);
    }

    return result;
}

UINT
PbkFilesCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    if (Data->IsLeaf) {
        // do this only if somebody actually persisted the object
        if (IsmIsPersistentObject (Data->ObjectTypeId, Data->ObjectName) ||
            IsmIsApplyObject (Data->ObjectTypeId, Data->ObjectName)
            ) {
            // record all connections from this PBK file
            if (pLoadRasConnections (Data->NativeObjectName, g_RasTable)) {
                // this is really a PBK file and at least one valid
                // connection was found
                // set the PbkFile attribute so we won't restore this one as a file (if it survives)
                IsmSetAttributeOnObject (Data->ObjectTypeId, Data->ObjectName, g_PbkFileAttribute);
            }
        }
    }
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
WINAPI
RasMigSgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}

BOOL
WINAPI
RasMigSgmParse (
    IN      PVOID Reserved
    )
{
    return TRUE;
}

UINT
SgmRasConnectionsCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    PCTSTR node, nodePtr, leaf;
    PTSTR leafPtr;
    PCTSTR rasLines;
    PCTSTR rasValue;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    PCTSTR nativeName;
    MIG_OSVERSIONINFO versionInfo;
    BOOL versionOk = FALSE;

    if (IsmGetRealPlatform () == PLATFORM_DESTINATION) {
        // let's reset the PbkFileAttribute on the source of this connection
        // because the attribute was lost during the transport
        if (IsmCreateObjectStringsFromHandle (Data->ObjectName, &node, &leaf)) {
            if (node) {
                leafPtr = _tcsrchr (node, TEXT('\\'));
                if (leafPtr) {
                    *leafPtr = 0;
                    leafPtr ++;
                    objectName = IsmCreateObjectHandle (node, leafPtr);
                    if (objectName) {
                        IsmSetAttributeOnObject (g_FileTypeId, objectName, g_PbkFileAttribute);
                        IsmDestroyObjectHandle (objectName);
                    }
                }
            }
            IsmDestroyObjectString (node);
            IsmDestroyObjectString (leaf);
        }
    }
    // let's see if we can actually migrate this RAS connection
    if (IsmAcquireObject (Data->ObjectTypeId, Data->ObjectName, &objectContent)) {
        versionOk = IsmGetOsVersionInfo (PLATFORM_SOURCE, &versionInfo);
        rasLines = (PCTSTR) objectContent.MemoryContent.ContentBytes;
        rasValue = pGetRasLineValue (rasLines, TEXT("BaseProtocol"));
        if (rasValue && (StringIMatch (rasValue, TEXT("1")) || StringIMatch (rasValue, TEXT("2")))) {
            IsmAbandonObjectOnCollision (Data->ObjectTypeId, Data->ObjectName);
            IsmMakeApplyObject (Data->ObjectTypeId, Data->ObjectName);

            // now it's a good time to force the migration of the script file
            // if this connection has one
            rasValue = NULL;
            if (versionOk) {
                if (versionInfo.OsType == OSTYPE_WINDOWSNT) {
                    if (versionInfo.OsMajorVersion == OSMAJOR_WINNT4) {
                        rasValue = pGetRasLineValue (rasLines, TEXT("Type"));
                    }
                    if (versionInfo.OsMajorVersion == OSMAJOR_WINNT5) {
                        rasValue = pGetRasLineValue (rasLines, TEXT("Name"));
                    }
                }
                if (versionInfo.OsType == OSTYPE_WINDOWS9X) {
                    rasValue = pGetRasLineValue (rasLines, TEXT("Name"));
                }
            }
            if (rasValue && *rasValue) {
                node = DuplicatePathString (rasValue, 0);
                if (_tcsnextc (node) == TEXT('[')) {
                    nodePtr = _tcsinc (node);
                } else {
                    nodePtr = node;
                }
                leafPtr = _tcsrchr (nodePtr, TEXT('\\'));
                if (leafPtr) {
                    *leafPtr = 0;
                    leafPtr ++;
                    objectName = IsmCreateObjectHandle (nodePtr, leafPtr);
                    if (objectName) {
                        IsmMakeApplyObject (g_FileTypeId, objectName);
                        IsmDestroyObjectHandle (objectName);
                    }
                }
                FreePathString (node);
            }
        } else {
            // this is an unsupported framing protocol
            // we will log a message and abandon this connection
            nativeName = IsmGetNativeObjectName (Data->ObjectTypeId, Data->ObjectName);
            LOG ((LOG_WARNING, (PCSTR) MSG_RASMIG_UNSUPPORTEDSETTINGS, nativeName));
            IsmReleaseMemory (nativeName);
        }
        IsmReleaseObject (&objectContent);
    }
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
WINAPI
RasMigSgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    g_PbkFileAttribute = IsmRegisterAttribute (S_PBKFILE_ATTRIBUTE, FALSE);
    MYASSERT (g_PbkFileAttribute);

    if (IsmGetRealPlatform () == PLATFORM_SOURCE) {

        // hook all PBK files enumeration, we will not migrate the files but the connections within
        pattern = IsmCreateSimpleObjectPattern (NULL, FALSE, TEXT("*.PBK"), TRUE);

        IsmHookEnumeration (
            g_FileTypeId,
            pattern,
            PbkFilesCallback,
            (ULONG_PTR) 0,
            TEXT("PbkFiles")
            );

        IsmDestroyObjectHandle (pattern);
    }

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmQueueEnumeration (
        g_RasTypeId,
        pattern,
        SgmRasConnectionsCallback,
        (ULONG_PTR) 0,
        S_RAS_NAME
        );
    IsmDestroyObjectHandle (pattern);

    return TRUE;
}

BOOL
WINAPI
RasMigVcmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    return TRUE;
}

BOOL
WINAPI
RasMigVcmParse (
    IN      PVOID Reserved
    )
{
    return RasMigSgmParse (Reserved);
}

UINT
VcmRasConnectionsCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    PCTSTR node, nodePtr;
    PTSTR leafPtr;
    PCTSTR rasLines;
    PCTSTR rasValue;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    PCTSTR nativeName;
    MIG_OSVERSIONINFO versionInfo;
    BOOL versionOk = FALSE;

    // let's see if we can actually migrate this RAS connection
    if (IsmAcquireObject (Data->ObjectTypeId, Data->ObjectName, &objectContent)) {
        versionOk = IsmGetOsVersionInfo (PLATFORM_SOURCE, &versionInfo);
        rasLines = (PCTSTR) objectContent.MemoryContent.ContentBytes;
        rasValue = pGetRasLineValue (rasLines, TEXT("BaseProtocol"));
        if (rasValue && (StringIMatch (rasValue, TEXT("1")) || StringIMatch (rasValue, TEXT("2")))) {
            IsmMakePersistentObject (Data->ObjectTypeId, Data->ObjectName);

            // now it's a good time to force the migration of the script file
            // if this connection has one
            rasValue = NULL;
            if (versionOk) {
                if (versionInfo.OsType == OSTYPE_WINDOWSNT) {
                    if (versionInfo.OsMajorVersion == OSMAJOR_WINNT4) {
                        rasValue = pGetRasLineValue (rasLines, TEXT("Type"));
                    }
                    if (versionInfo.OsMajorVersion == OSMAJOR_WINNT5) {
                        rasValue = pGetRasLineValue (rasLines, TEXT("Name"));
                    }
                }
                if (versionInfo.OsType == OSTYPE_WINDOWS9X) {
                    rasValue = pGetRasLineValue (rasLines, TEXT("Name"));
                }
            }
            if (rasValue && *rasValue) {
                node = DuplicatePathString (rasValue, 0);
                if (_tcsnextc (node) == TEXT('[')) {
                    nodePtr = _tcsinc (node);
                } else {
                    nodePtr = node;
                }
                leafPtr = _tcsrchr (nodePtr, TEXT('\\'));
                if (leafPtr) {
                    *leafPtr = 0;
                    leafPtr ++;
                    objectName = IsmCreateObjectHandle (nodePtr, leafPtr);
                    if (objectName) {
                        IsmMakePersistentObject (g_FileTypeId, objectName);
                        IsmDestroyObjectHandle (objectName);
                    }
                }
                FreePathString (node);
            }
        } else {
            // this is an unsupported framing protocol
            // we will log a message and abandon this connection
            nativeName = IsmGetNativeObjectName (Data->ObjectTypeId, Data->ObjectName);
            LOG ((LOG_WARNING, (PCSTR) MSG_RASMIG_UNSUPPORTEDSETTINGS, nativeName));
            IsmReleaseMemory (nativeName);
        }
        IsmReleaseObject (&objectContent);
    }
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
WINAPI
RasMigVcmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    ENCODEDSTRHANDLE pattern;

    g_PbkFileAttribute = IsmRegisterAttribute (S_PBKFILE_ATTRIBUTE, FALSE);
    MYASSERT (g_PbkFileAttribute);

    // hook all PBK files enumeration, we will not migrate the files but the connections within
    pattern = IsmCreateSimpleObjectPattern (NULL, FALSE, TEXT("*.PBK"), TRUE);

    IsmHookEnumeration (
        g_FileTypeId,
        pattern,
        PbkFilesCallback,
        (ULONG_PTR) 0,
        TEXT("PbkFiles")
        );

    IsmDestroyObjectHandle (pattern);

    pattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
    IsmQueueEnumeration (
        g_RasTypeId,
        pattern,
        VcmRasConnectionsCallback,
        (ULONG_PTR) 0,
        S_RAS_NAME
        );
    IsmDestroyObjectHandle (pattern);

    return TRUE;
}

BOOL
PbkRestoreCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    // if this is a PBK file we won't allow it to be restored like a file,
    // we will add the proper connections ourselves.
    return ((!IsmIsAttributeSetOnObjectId (ObjectId, g_PbkFileAttribute)) || g_AllowPbkRestore);
}

BOOL
WINAPI
RasMigOpmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    g_PbkFileAttribute = IsmRegisterAttribute (S_PBKFILE_ATTRIBUTE, FALSE);
    MYASSERT (g_PbkFileAttribute);

    IsmRegisterRestoreCallback (PbkRestoreCallback);

    return TRUE;
}

BOOL
pEnumRasConnectionWorker (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      PRAS_ENUM RasEnum
    )
{
    PCTSTR rasLines;
    PCTSTR connName;
    PCTSTR node, leaf;

    if (EnumPtr->ObjectName) {
        IsmDestroyObjectHandle (EnumPtr->ObjectName);
        EnumPtr->ObjectName = NULL;
    }
    if (EnumPtr->NativeObjectName) {
        IsmDestroyObjectHandle (EnumPtr->NativeObjectName);
        EnumPtr->NativeObjectName = NULL;
    }
    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    do {
        IsmCreateObjectStringsFromHandle (RasEnum->HashData.String, &node, &leaf);
        if (RasEnum->HashData.ExtraData) {
            rasLines = *((PCTSTR *) RasEnum->HashData.ExtraData);
            connName = pGetRasLineValue (rasLines, TEXT("ConnectionName"));
            EnumPtr->ObjectName = IsmCreateObjectHandle (node, connName?connName:leaf);
            EnumPtr->NativeObjectName = IsmCreateObjectHandle (node, connName?connName:leaf);
        } else {
            EnumPtr->ObjectName = IsmCreateObjectHandle (node, leaf);
            EnumPtr->NativeObjectName = IsmCreateObjectHandle (node, leaf);
        }
        if (!ObsPatternMatch (RasEnum->Pattern, EnumPtr->ObjectName)) {
            if (!EnumNextHashTableString (&RasEnum->HashData)) {
                AbortEnumRasConnection (EnumPtr);
                return FALSE;
            }
            continue;
        }
        IsmCreateObjectStringsFromHandle (EnumPtr->ObjectName, &EnumPtr->ObjectNode, &EnumPtr->ObjectLeaf);
        EnumPtr->Level = 1;
        EnumPtr->SubLevel = 0;
        EnumPtr->IsLeaf = TRUE;
        EnumPtr->IsNode = FALSE;
        EnumPtr->Details.DetailsSize = 0;
        EnumPtr->Details.DetailsData = NULL;
        return TRUE;
    } while (TRUE);
}

BOOL
EnumFirstRasConnection (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,            CALLER_INITIALIZED
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    PRAS_ENUM rasEnum = NULL;

    if (!g_RasTable) {
        return FALSE;
    }
    rasEnum = (PRAS_ENUM) PmGetMemory (g_RasPool, sizeof (RAS_ENUM));
    rasEnum->Pattern = PmDuplicateString (g_RasPool, Pattern);
    EnumPtr->EtmHandle = (LONG_PTR) rasEnum;

    if (EnumFirstHashTableString (&rasEnum->HashData, g_RasTable)) {
        return pEnumRasConnectionWorker (EnumPtr, rasEnum);
    } else {
        AbortEnumRasConnection (EnumPtr);
        return FALSE;
    }
}

BOOL
EnumNextRasConnection (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PRAS_ENUM rasEnum = NULL;

    rasEnum = (PRAS_ENUM)(EnumPtr->EtmHandle);
    if (!rasEnum) {
        return FALSE;
    }
    if (EnumNextHashTableString (&rasEnum->HashData)) {
        return pEnumRasConnectionWorker (EnumPtr, rasEnum);
    } else {
        AbortEnumRasConnection (EnumPtr);
        return FALSE;
    }
}

VOID
AbortEnumRasConnection (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PRAS_ENUM rasEnum = NULL;

    if (EnumPtr->ObjectName) {
        IsmDestroyObjectHandle (EnumPtr->ObjectName);
        EnumPtr->ObjectName = NULL;
    }
    if (EnumPtr->NativeObjectName) {
        IsmDestroyObjectHandle (EnumPtr->NativeObjectName);
        EnumPtr->NativeObjectName = NULL;
    }
    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    rasEnum = (PRAS_ENUM)(EnumPtr->EtmHandle);
    if (!rasEnum) {
        return;
    }
    PmReleaseMemory (g_RasPool, rasEnum->Pattern);
    PmReleaseMemory (g_RasPool, rasEnum);
    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}

BOOL
AcquireRasConnection (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,             CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PTSTR rasLines;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    if (ContentType == CONTENTTYPE_FILE) {
        // nobody should request this as a file
        MYASSERT (FALSE);
        return FALSE;
    }

    if (HtFindStringEx (g_RasTable, ObjectName, &rasLines, FALSE)) {

        ObjectContent->MemoryContent.ContentBytes = (PCBYTE) rasLines;
        ObjectContent->MemoryContent.ContentSize = SizeOfMultiSz (rasLines);

        result = TRUE;
    }
    return result;
}

BOOL
ReleaseRasConnection (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    return TRUE;
}

BOOL
pGetNewFileNameAndConnection (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PCTSTR *NewPbkFileName,
    OUT     PCTSTR *ConnectionName
    )
{
    PCTSTR node;
    PCTSTR leaf;
    PCTSTR newNode;
    PCTSTR newLeaf;
    PTSTR pbkDir;
    PTSTR pbkFile;
    MIG_OBJECTSTRINGHANDLE pbkObjectName;
    MIG_OBJECTSTRINGHANDLE newPbkObjectName;
    PCTSTR newFileName;
    MIG_OBJECTTYPEID newObjTypeId;
    BOOL deleted;
    BOOL replaced;
    BOOL result = FALSE;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        MYASSERT (leaf);

        if (leaf) {

            if (node) {

                pbkDir = (PTSTR) node;
                pbkFile = _tcsrchr (pbkDir, TEXT('\\'));

                if (pbkFile) {

                    // we know '\\' is not a multi-byte character so this is safe
                    *pbkFile = 0;
                    pbkFile ++;

                    pbkObjectName = IsmCreateObjectHandle (pbkDir, pbkFile);

                    if (pbkObjectName) {

                        g_AllowPbkRestore = TRUE;
                        newPbkObjectName = IsmFilterObject (
                                                Platform | g_FileTypeId,
                                                pbkObjectName,
                                                &newObjTypeId,
                                                &deleted,
                                                &replaced
                                                );
                        g_AllowPbkRestore = FALSE;

                        if ((!deleted) || (replaced)) {

                            if (IsmCreateObjectStringsFromHandle (newPbkObjectName?newPbkObjectName:pbkObjectName, &newNode, &newLeaf)) {

                                MYASSERT (newNode);
                                MYASSERT (newLeaf);

                                if (newNode && newLeaf) {

                                    newFileName = JoinPaths (newNode, newLeaf);

                                    if (NewPbkFileName) {
                                        *NewPbkFileName = newFileName;
                                    } else {
                                        FreePathString (newFileName);
                                    }
                                    if (ConnectionName) {
                                        *ConnectionName = DuplicatePathString (leaf, 0);
                                    }
                                    result = TRUE;

                                }
                                if (newNode) {
                                    IsmDestroyObjectString (newNode);
                                }
                                if (newLeaf) {
                                    IsmDestroyObjectString (newLeaf);
                                }
                            }
                        }
                        if (newPbkObjectName) {
                            IsmDestroyObjectHandle (newPbkObjectName);
                            newPbkObjectName = NULL;
                        }
                    }
                }
            }
            else {
                if (NewPbkFileName) {
                    *NewPbkFileName = NULL;
                }
                if (ConnectionName) {
                    *ConnectionName = DuplicatePathString (leaf, 0);
                }
                result = TRUE;
            }
        }
        if (node) {
            IsmDestroyObjectString (node);
        }
        if (leaf) {
            IsmDestroyObjectString (leaf);
        }
    }
    return result;
}

BOOL
DoesRasConnectionExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR newPbkFileName = NULL;
    PCTSTR newConnName = NULL;
    MIG_OBJECTSTRINGHANDLE newObjectName = NULL;
    HASHTABLE rasTable;
    BOOL result = FALSE;

    if (pGetNewFileNameAndConnection (PLATFORM_SOURCE, ObjectName, &newPbkFileName, &newConnName)) {

        if (newPbkFileName && newConnName) {
            newObjectName = IsmCreateObjectHandle (newPbkFileName, newConnName);
        }

        if (newObjectName) {

            rasTable = HtAllocWithData (sizeof (PCTSTR));
            if (rasTable) {

                if (pLoadRasConnections (newPbkFileName, rasTable)) {
                    result = (HtFindStringEx (rasTable, newObjectName, NULL, FALSE) != NULL);
                }

                HtFree (rasTable);
            }
        }

        if (newObjectName) {
            IsmDestroyObjectHandle (newObjectName);
            newObjectName = NULL;
        }

        if (newPbkFileName) {
            FreePathString (newPbkFileName);
            newPbkFileName = NULL;
        }

        if (newConnName) {
            FreePathString (newConnName);
            newConnName = NULL;
        }
    }
    return result;
}

BOOL
RemoveRasConnection (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node, leaf;
    DWORD err = 0;
    BOOL result = FALSE;

    if (g_RasDeleteEntry) {
        if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
            MYASSERT (node);
            MYASSERT (leaf);
            if (node && leaf) {
                err = g_RasDeleteEntry (node, leaf);
                if (err = ERROR_SUCCESS) {
                    result = TRUE;
                }
            }
            IsmDestroyObjectString (node);
            IsmDestroyObjectString (leaf);
        }
    }
    return result;
}

BOOL
pCopyNewFileLocation (
    OUT     PTSTR DestFile,
    IN      PCTSTR SrcFile,
    IN      UINT Size
    )
{
    PTSTR node, nodePtr, leaf, result;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    BOOL deleted;
    BOOL replaced;
    BOOL b = FALSE;

    *DestFile = 0;

    node = PmGetMemory (g_RasPool, Size);
    StringCopyTcharCount (node, SrcFile, Size);
    if (*node) {
        if (_tcsnextc (node) == TEXT('[')) {
            nodePtr = _tcsinc (node);
        } else {
            nodePtr = node;
        }
        leaf = _tcsrchr (nodePtr, TEXT('\\'));
        if (leaf) {
            *leaf = 0;
            leaf++;
            objectName = IsmCreateObjectHandle (nodePtr, leaf);
            PmReleaseMemory (g_RasPool, node);
            newObjectName = IsmFilterObject (
                                g_FileTypeId | PLATFORM_SOURCE,
                                objectName,
                                NULL,
                                &deleted,
                                &replaced
                                );
            if (!deleted || replaced) {
                if (!newObjectName) {
                    newObjectName = objectName;
                }
                if (IsmCreateObjectStringsFromHandle (newObjectName, &node, &leaf)) {
                    result = JoinPaths (node, leaf);
                    StringCopyTcharCount (DestFile, result, Size);
                    FreePathString (result);
                    b = TRUE;
                }
            }
            if (newObjectName && (newObjectName != objectName)) {
                IsmDestroyObjectHandle (newObjectName);
            }
            IsmDestroyObjectHandle (objectName);
        } else {
            PmReleaseMemory (g_RasPool, node);
        }
    } else {
        PmReleaseMemory (g_RasPool, node);
    }
    return b;
}

BOOL
pTrackedCreateDirectory (
    IN      PCTSTR DirName
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    PTSTR pathCopy;
    PTSTR p;
    BOOL result = TRUE;

    pathCopy = DuplicatePathString (DirName, 0);

    //
    // Advance past first directory
    //

    if (pathCopy[1] == TEXT(':') && pathCopy[2] == TEXT('\\')) {
        //
        // <drive>:\ case
        //

        p = _tcschr (&pathCopy[3], TEXT('\\'));

    } else if (pathCopy[0] == TEXT('\\') && pathCopy[1] == TEXT('\\')) {

        //
        // UNC case
        //

        p = _tcschr (pathCopy + 2, TEXT('\\'));
        if (p) {
            p = _tcschr (p + 1, TEXT('\\'));
        }

    } else {

        //
        // Relative dir case
        //

        p = _tcschr (pathCopy, TEXT('\\'));
    }

    //
    // Make all directories along the path
    //

    while (p) {

        *p = 0;

        if (!DoesFileExist (pathCopy)) {

            // record directory creation
            objectName = IsmCreateObjectHandle (pathCopy, NULL);
            IsmRecordOperation (
                JRNOP_CREATE,
                g_FileTypeId,
                objectName
                );
            IsmDestroyObjectHandle (objectName);

            result = CreateDirectory (pathCopy, NULL);
            if (!result) {
                break;
            }
        }

        *p = TEXT('\\');
        p = _tcschr (p + 1, TEXT('\\'));
    }

    FreePathString (pathCopy);

    return result;
}

BOOL
CreateRasConnection (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PCTSTR rasLines;
    MULTISZ_ENUM multiSzEnum;
    PCTSTR newPbkFileName = NULL;
    HANDLE newPbkFileHandle = NULL;
    PTSTR node = NULL, leaf = NULL;
    BOOL first = TRUE;
    MIG_OSVERSIONINFO versionInfo;
    BOOL versionOk = FALSE;
    BOOL fileField = FALSE;
    TCHAR destFileName [MAX_PATH];
    RASCREDENTIALS rasCredentials;
    BOOL lastVNEmpty = FALSE;
    BOOL result = FALSE;
    WORD oldCodePage;

    if (ObjectContent->ContentInFile) {
        return FALSE;
    }

    ZeroMemory (&rasCredentials, sizeof (RASCREDENTIALS));
    rasCredentials.dwSize = sizeof (RASCREDENTIALS);

    rasLines = (PCTSTR) ObjectContent->MemoryContent.ContentBytes;

    __try {

        if (!rasLines) {
            __leave;
        }

        if (!pGetNewFileNameAndConnection (PLATFORM_SOURCE, ObjectName, &newPbkFileName, NULL)) {
            __leave;
        }

        MYASSERT (newPbkFileName);
        if (!newPbkFileName) {
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
            __leave;
        }

        MYASSERT (leaf);
        if (!leaf) {
            __leave;
        }

        newObjectName = IsmCreateObjectHandle (newPbkFileName, leaf);

        // record RAS entry creation
        IsmRecordOperation (
            JRNOP_CREATE,
            g_RasTypeId,
            newObjectName
            );

        IsmDestroyObjectHandle (newObjectName);

        if (EnumFirstMultiSz (&multiSzEnum, rasLines)) {
            // get the first 8 fields as being part of rasCredentials structure

            MYASSERT (StringIMatch (multiSzEnum.CurrentString, TEXT("ConnectionName")));

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            // we are just skipping the connection name

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            MYASSERT (StringIMatch (multiSzEnum.CurrentString, TEXT("CredMask")));

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(rasCredentials.dwMask));
            }

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            MYASSERT (StringIMatch (multiSzEnum.CurrentString, TEXT("CredName")));

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                StringCopyTcharCount (rasCredentials.szUserName, multiSzEnum.CurrentString, UNLEN + 1);
            }

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            MYASSERT (StringIMatch (multiSzEnum.CurrentString, TEXT("CredDomain")));

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                StringCopyTcharCount (rasCredentials.szDomain, multiSzEnum.CurrentString, DNLEN + 1);
            }

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            MYASSERT (StringIMatch (multiSzEnum.CurrentString, TEXT("CredPassword")));

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }
            if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                StringCopyTcharCount (rasCredentials.szPassword, multiSzEnum.CurrentString, PWLEN + 1);
            }

            if (!EnumNextMultiSz (&multiSzEnum)) {
                __leave;
            }

            newPbkFileHandle = BfOpenFile (newPbkFileName);
            if (!newPbkFileHandle) {
                pTrackedCreateDirectory (newPbkFileName);
                newPbkFileHandle = BfCreateFile (newPbkFileName);
            }
            if (!newPbkFileHandle) {
                __leave;
            }
            BfGoToEndOfFile (newPbkFileHandle, NULL);
            WriteFileString (newPbkFileHandle, TEXT("\r\n["));
            // make sure that the conversion is using UTF8
            oldCodePage = SetConversionCodePage (CP_UTF8);
            WriteFileString (newPbkFileHandle, leaf);
            SetConversionCodePage (oldCodePage);
            WriteFileString (newPbkFileHandle, TEXT("]\r\n"));
            first = TRUE;
            versionOk = IsmGetOsVersionInfo (PLATFORM_SOURCE, &versionInfo);
            do {
                if (first) {
                    if (StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                        lastVNEmpty = TRUE;
                    } else {
                        lastVNEmpty = FALSE;
                        if (versionOk) {
                            if (versionInfo.OsType == OSTYPE_WINDOWSNT) {
                                if (versionInfo.OsMajorVersion == OSMAJOR_WINNT4) {
                                    fileField = StringIMatch (multiSzEnum.CurrentString, TEXT("Type"));
                                }
                                if (versionInfo.OsMajorVersion == OSMAJOR_WINNT5) {
                                    fileField = StringIMatch (multiSzEnum.CurrentString, TEXT("Name"));
                                }
                            }
                            if (versionInfo.OsType == OSTYPE_WINDOWS9X) {
                                fileField = StringIMatch (multiSzEnum.CurrentString, TEXT("Name"));
                            }
                        }
                        fileField = fileField || StringIMatch (multiSzEnum.CurrentString, TEXT("CustomDialDll"));
                        fileField = fileField || StringIMatch (multiSzEnum.CurrentString, TEXT("CustomRasDialDll"));
                        fileField = fileField || StringIMatch (multiSzEnum.CurrentString, TEXT("PrerequisitePbk"));
                        WriteFileString (newPbkFileHandle, multiSzEnum.CurrentString);
                    }
                } else {
                    if (StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                        if (!lastVNEmpty) {
                            WriteFileString (newPbkFileHandle, TEXT("="));
                        }
                        WriteFileString (newPbkFileHandle, TEXT("\r\n"));
                    } else {
                        WriteFileString (newPbkFileHandle, TEXT("="));
                        if (fileField && pCopyNewFileLocation (destFileName, multiSzEnum.CurrentString, MAX_PATH)) {
                            // make sure that the conversion is using UTF8
                            oldCodePage = SetConversionCodePage (CP_UTF8);
                            WriteFileString (newPbkFileHandle, destFileName);
                            SetConversionCodePage (oldCodePage);
                        } else {
                            // make sure that the conversion is using UTF8
                            oldCodePage = SetConversionCodePage (CP_UTF8);
                            WriteFileString (newPbkFileHandle, multiSzEnum.CurrentString);
                            oldCodePage = SetConversionCodePage (oldCodePage);
                        }
                        WriteFileString (newPbkFileHandle, TEXT("\r\n"));
                    }
                    fileField = FALSE;
                }
                first = !first;
            } while (EnumNextMultiSz (&multiSzEnum));
            WriteFileString (newPbkFileHandle, TEXT("\r\n"));

            result = TRUE;
        }
    }
    __finally {

        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);

        if (newPbkFileHandle) {
            CloseHandle (newPbkFileHandle);
            newPbkFileHandle = NULL;
        }
        if (result) {
            if (g_RasSetCredentials && rasCredentials.dwMask) {
                g_RasSetCredentials (newPbkFileName, leaf, &rasCredentials, FALSE);
            }
        }
        if (newPbkFileName) {
            FreePathString (newPbkFileName);
            newPbkFileName = NULL;
        }
    }

    return result;
}

PCTSTR
ConvertRasConnectionToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node, leaf;
    PTSTR result = NULL;
    BOOL bresult = TRUE;
    PCTSTR rasLines;
    MULTISZ_ENUM multiSzEnum;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        MYASSERT (leaf);

        g_RasConversionBuff.End = 0;

        if (node) {
            GbCopyQuotedString (&g_RasConversionBuff, node);
        } else {
            GbCopyQuotedString (&g_RasConversionBuff, TEXT(""));
        }

        GbCopyQuotedString (&g_RasConversionBuff, leaf);

        MYASSERT (ObjectContent->Details.DetailsSize == 0);
        MYASSERT (!ObjectContent->ContentInFile);

        if ((!ObjectContent->ContentInFile) &&
            (ObjectContent->MemoryContent.ContentSize) &&
            (ObjectContent->MemoryContent.ContentBytes)
            ) {
            rasLines = (PCTSTR)ObjectContent->MemoryContent.ContentBytes;
            if (EnumFirstMultiSz (&multiSzEnum, rasLines)) {
                do {
                    if (StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                        GbCopyQuotedString (&g_RasConversionBuff, TEXT(""));
                    } else {
                        GbCopyQuotedString (&g_RasConversionBuff, multiSzEnum.CurrentString);
                    }
                } while (EnumNextMultiSz (&multiSzEnum));
            }
        } else {
            bresult = FALSE;
        }

        if (bresult) {
            GbCopyString (&g_RasConversionBuff, TEXT(""));
            result = IsmGetMemory (g_RasConversionBuff.End);
            CopyMemory (result, g_RasConversionBuff.Buf, g_RasConversionBuff.End);
        }

        g_RasConversionBuff.End = 0;

        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    return result;
}

BOOL
ConvertMultiSzToRasConnection (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    )
{
    MULTISZ_ENUM multiSzEnum;
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    UINT index;

    g_RasConversionBuff.End = 0;

    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }

    if (EnumFirstMultiSz (&multiSzEnum, ObjectMultiSz)) {
        index = 0;
        do {
            if (index == 0) {
                if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                    node = multiSzEnum.CurrentString;
                }
            }
            if (index == 1) {
                leaf = multiSzEnum.CurrentString;
            }
            if (index > 1) {
                if (*multiSzEnum.CurrentString) {
                    GbMultiSzAppend (&g_RasConversionBuff, multiSzEnum.CurrentString);
                } else {
                    GbMultiSzAppend (&g_RasConversionBuff, TEXT("<empty>"));
                }
            }
            index ++;
        } while (EnumNextMultiSz (&multiSzEnum));
    }
    GbMultiSzAppend (&g_RasConversionBuff, TEXT(""));

    if (!leaf) {
        GbFree (&g_RasConversionBuff);
        return FALSE;
    }

    if (ObjectContent) {

        if (g_RasConversionBuff.End) {
            ObjectContent->MemoryContent.ContentSize = g_RasConversionBuff.End;
            ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            CopyMemory (
                (PBYTE)ObjectContent->MemoryContent.ContentBytes,
                g_RasConversionBuff.Buf,
                ObjectContent->MemoryContent.ContentSize
                );
        } else {
            ObjectContent->MemoryContent.ContentSize = 0;
            ObjectContent->MemoryContent.ContentBytes = NULL;
        }
        ObjectContent->Details.DetailsSize = 0;
        ObjectContent->Details.DetailsData = NULL;
    }
    *ObjectName = IsmCreateObjectHandle (node, leaf);

    GbFree (&g_RasConversionBuff);

    return TRUE;
}

PCTSTR
GetNativeRasConnectionName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node = NULL, leaf = NULL;
    UINT size;
    PTSTR result = NULL;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (leaf) {
            size = SizeOfString (leaf);
            if (size) {
                result = IsmGetMemory (size);
                CopyMemory (result, leaf, size);
            }
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

PMIG_CONTENT
ConvertRasConnectionContentToUnicode (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Ras Connection content
            result->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize * 2);
            if (result->MemoryContent.ContentBytes) {
                DirectDbcsToUnicodeN (
                    (PWSTR)result->MemoryContent.ContentBytes,
                    (PSTR)ObjectContent->MemoryContent.ContentBytes,
                    ObjectContent->MemoryContent.ContentSize
                    );
                result->MemoryContent.ContentSize = SizeOfMultiSzW ((PWSTR)result->MemoryContent.ContentBytes);
            }
        }
    }

    return result;
}

PMIG_CONTENT
ConvertRasConnectionContentToAnsi (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert Ras Connection content
            result->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            if (result->MemoryContent.ContentBytes) {
                DirectUnicodeToDbcsN (
                    (PSTR)result->MemoryContent.ContentBytes,
                    (PWSTR)ObjectContent->MemoryContent.ContentBytes,
                    ObjectContent->MemoryContent.ContentSize
                    );
                result->MemoryContent.ContentSize = SizeOfMultiSzA ((PSTR)result->MemoryContent.ContentBytes);
            }
        }
    }

    return result;
}

BOOL
FreeConvertedRasConnectionContent (
    IN      PMIG_CONTENT ObjectContent
    )
{
    if (!ObjectContent) {
        return TRUE;
    }

    if (ObjectContent->MemoryContent.ContentBytes) {
        IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
    }

    IsmReleaseMemory (ObjectContent);

    return TRUE;
}




//
// Win9x specific code. Converts registry format into a PBK file
//

//
// AddrEntry serves as a header for the entire block of data in the <entry>
// blob. entries in it are offsets to the strings which follow it..in many cases
// (i.e. all of the *Off* members...)
//
typedef struct  _AddrEntry     {
    DWORD       dwVersion;
    DWORD       dwCountryCode;
    UINT        uOffArea;
    UINT        uOffPhone;
    DWORD       dwCountryID;
    UINT        uOffSMMCfg;
    UINT        uOffSMM;
    UINT        uOffDI;
}   ADDRENTRY, *PADDRENTRY;

typedef struct {
    DWORD Size;
    DWORD Unknown1;
    DWORD ModemUiOptions; // num seconds in high byte.
    DWORD Unknown2;
    DWORD Unknown3;
    DWORD Unknown4;
    DWORD ConnectionSpeed;
    DWORD UnknownFlowControlData; //Somehow related to flow control.
    DWORD Unknown5;
    DWORD Unknown6;
    DWORD Unknown7;
    DWORD Unknown8;
    DWORD Unknown9;
    DWORD Unknown10;
    DWORD Unknown11;
    DWORD Unknown12;
    DWORD Unknown13;
    DWORD Unknown14;
    DWORD Unknown15;
    DWORD CancelSeconds; //Num seconds to wait before cancel if not connected. (0xFF equals off.)
    DWORD IdleDisconnectSeconds; // 0 = Not Set.
    DWORD Unknown16;
    DWORD SpeakerVolume; // 0|1
    DWORD ConfigOptions;
    DWORD Unknown17;
    DWORD Unknown18;
    DWORD Unknown19;
} MODEMDEVINFO, *PMODEMDEVINFO;

typedef struct _SubConnEntry {
    DWORD       dwSize;
    DWORD       dwFlags;
    CHAR        szDeviceType[RAS_MaxDeviceType+1];
    CHAR        szDeviceName[RAS_MaxDeviceName+1];
    CHAR        szLocal[RAS_MaxPhoneNumber+1];
}   SUBCONNENTRY, *PSUBCONNENTRY;

typedef struct  _SMMCFG  {
    DWORD       dwSize;
    DWORD       fdwOptions;
    DWORD       fdwProtocols;
}   SMMCFG, *PSMMCFG;

typedef struct  _DEVICEINFO  {
    DWORD       dwVersion;
    UINT        uSize;
    CHAR        szDeviceName[RAS_MaxDeviceName+1];
    CHAR        szDeviceType[RAS_MaxDeviceType+1];
}   DEVICEINFO, *PDEVICEINFO;

typedef struct _IPData   {
    DWORD     dwSize;
    DWORD     fdwTCPIP;
    DWORD     dwIPAddr;
    DWORD     dwDNSAddr;
    DWORD     dwDNSAddrAlt;
    DWORD     dwWINSAddr;
    DWORD     dwWINSAddrAlt;
}   IPDATA, *PIPDATA;

typedef struct {
    PCTSTR String;
    UINT   Value;
    WORD   DataType;
} MEMDB_RAS_DATA, *PMEMDB_RAS_DATA;

#define PAESMMCFG(pAE)          ((PSMMCFG)(((PBYTE)pAE)+(pAE->uOffSMMCfg)))
#define PAESMM(pAE)             ((PSTR)(((PBYTE)pAE)+(pAE->uOffSMM)))
#define PAEDI(pAE)              ((PDEVICEINFO)(((PBYTE)pAE)+(pAE->uOffDI    )))
#define PAEAREA(pAE)            ((PSTR)(((PBYTE)pAE)+(pAE->uOffArea)))
#define PAEPHONE(pAE)           ((PSTR)(((PBYTE)pAE)+(pAE->uOffPhone)))
#define DECRYPTENTRY(x, y, z)   EnDecryptEntry(x, (LPBYTE)y, z)

#define S_REMOTE_ACCESS_KEY             TEXT("HKCU\\RemoteAccess")
#define S_DIALUI                        TEXT("DialUI")
#define S_ENABLE_REDIAL                 TEXT("EnableRedial")
#define S_REDIAL_TRY                    TEXT("RedialTry")
#define S_REDIAL_WAIT                   TEXT("RedialWait")
#define S_ENABLE_IMPLICIT               TEXT("EnableImplicit")
#define S_PHONE_NUMBER                  TEXT("Phone Number")
#define S_AREA_CODE                     TEXT("Area Code")
#define S_SMM                           TEXT("SMM")
#define S_COUNTRY_CODE                  TEXT("Country Code")
#define S_COUNTRY_ID                    TEXT("Country Id")
#define S_DEVICE_NAME                   TEXT("Device Name")
#define S_DEVICE_TYPE                   TEXT("Device Type")
#define S_PROTOCOLS                     TEXT("Protocols")
#define S_SMM_OPTIONS                   TEXT("SMM Options")
#define S_IPINFO                        TEXT("IP")
#define S_IP_FTCPIP                     TEXT("_IP_FTCPIP")
#define S_IP_IPADDR                     TEXT("IpAddress")
#define S_IP_DNSADDR                    TEXT("IpDnsAddress")
#define S_IP_DNSADDR2                   TEXT("IpDns2Address")
#define S_IP_WINSADDR                   TEXT("IpWinsAddress")
#define S_IP_WINSADDR2                  TEXT("IpWins2Address")
#define S_DOMAIN                        TEXT("Domain")
#define S_USER                          TEXT("User")

#define S_MODEMS                        TEXT("HKLM\\System\\CurrentControlSet\\Services\\Class\\Modem")
#define S_ATTACHEDTO                    TEXT("AttachedTo")
#define S_DRIVERDESC                    TEXT("DriverDesc")
#define S_TERMINAL                      TEXT("Terminal")
#define S_MODE                          TEXT("Mode")
#define S_MULTILINK                     TEXT("MultiLink")

#define S_MODEM                         TEXT("Modem")
#define S_MODEMA                        "Modem"
#define S_MODEM_UI_OPTIONS              TEXT("__UiOptions")
#define S_MODEM_SPEED                   TEXT("__Speed")
#define S_MODEM_SPEAKER_VOLUME          TEXT("__SpeakerVolume")
#define S_MODEM_IDLE_DISCONNECT_SECONDS TEXT("__IdleDisconnect")
#define S_MODEM_CANCEL_SECONDS          TEXT("__CancelSeconds")
#define S_MODEM_CFG_OPTIONS             TEXT("__CfgOptions")
#define S_MODEM_COM_PORT                TEXT("ComPort")
#define S_DEVICECOUNT                   TEXT("__DeviceCount")

#define S_PPP                           TEXT("PPP")
#define S_PPPA                          "PPP"
#define S_SLIP                          TEXT("Slip")
#define S_SLIPA                         "Slip"
#define S_CSLIP                         TEXT("CSlip")
#define S_CSLIPA                        "CSlip"

#define S_SERVICEREMOTEACCESS           TEXT("HKLM\\System\\CurrentControlSet\\Services\\RemoteAccess")
#define S_REMOTE_ACCESS_KEY             TEXT("HKCU\\RemoteAccess")
#define S_PROFILE_KEY                   TEXT("HKCU\\RemoteAccess\\Profile")
#define S_ADDRESSES_KEY                 TEXT("HKCU\\RemoteAccess\\Addresses")
#define S_SUBENTRIES                    TEXT("SubEntries")

#define S_EMPTY                         TEXT("")

#define S_PPPSCRIPT                     TEXT("PPPSCRIPT")

#define MEMDB_CATEGORY_RAS_INFO         TEXT("RAS Info")
#define MEMDB_CATEGORY_RAS_USER         TEXT("RAS User")
#define MEMDB_CATEGORY_RAS_DATA         TEXT("Ras Data")
#define MEMDB_FIELD_USER_SETTINGS       TEXT("User Settings")

#define RASTYPE_PHONE 1
#define RASTYPE_VPN 2

#define S_VPN TEXT("VPN")
#define S_ZERO TEXT("0")
#define S_ONE TEXT("1")

#define SMMCFG_SW_COMPRESSION       0x00000001  // Software compression is on
#define SMMCFG_PW_ENCRYPTED         0x00000002  // Encrypted password only
#define SMMCFG_NW_LOGON             0x00000004  // Logon to the network

// Negotiated protocols
//
#define SMMPROT_NB                  0x00000001  // NetBEUI
#define SMMPROT_IPX                 0x00000002  // IPX
#define SMMPROT_IP                  0x00000004  // TCP/IP

#define IPF_IP_SPECIFIED    0x00000001
#define IPF_NAME_SPECIFIED  0x00000002
#define IPF_NO_COMPRESS     0x00000004
#define IPF_NO_WAN_PRI      0x00000008

#define RAS_UI_FLAG_TERMBEFOREDIAL      0x1
#define RAS_UI_FLAG_TERMAFTERDIAL       0x2
#define RAS_UI_FLAG_OPERATORASSISTED    0x4
#define RAS_UI_FLAG_MODEMSTATUS         0x8

#define RAS_CFG_FLAG_HARDWARE_FLOW_CONTROL  0x00000010
#define RAS_CFG_FLAG_SOFTWARE_FLOW_CONTROL  0x00000020
#define RAS_CFG_FLAG_STANDARD_EMULATION     0x00000040
#define RAS_CFG_FLAG_COMPRESS_DATA          0x00000001
#define RAS_CFG_FLAG_USE_ERROR_CONTROL      0x00000002
#define RAS_CFG_FLAG_ERROR_CONTROL_REQUIRED 0x00000004
#define RAS_CFG_FLAG_USE_CELLULAR_PROTOCOL  0x00000008
#define RAS_CFG_FLAG_NO_WAIT_FOR_DIALTONE   0x00000200

#define DIALUI_DONT_PROMPT_FOR_INFO         0x01
#define DIALUI_DONT_SHOW_ICON               0x04


//
// For each entry, the following basic information is stored.
//
#define ENTRY_SETTINGS                              \
    FUNSETTING(CredMask)                            \
    FUNSETTING(CredName)                            \
    FUNSETTING(CredDomain)                          \
    FUNSETTING(CredPassword)                        \
    STRSETTING(Encoding,S_ONE)                      \
    FUNSETTING(Type)                                \
    STRSETTING(Autologon,S_ZERO)                    \
    STRSETTING(DialParamsUID,S_EMPTY)               \
    STRSETTING(Guid,S_EMPTY)                        \
    STRSETTING(UsePwForNetwork,S_EMPTY)             \
    STRSETTING(ServerType,S_EMPTY)                  \
    FUNSETTING(BaseProtocol)                        \
    FUNSETTING(VpnStrategy)                         \
    STRSETTING(Authentication,S_EMPTY)              \
    FUNSETTING(ExcludedProtocols)                   \
    STRSETTING(LcpExtensions,S_ONE)                 \
    FUNSETTING(DataEncryption)                      \
    STRSETTING(SkipNwcWarning,S_EMPTY)              \
    STRSETTING(SkipDownLevelDialog,S_EMPTY)         \
    FUNSETTING(SwCompression)                       \
    FUNSETTING(ShowMonitorIconInTaskBar)            \
    STRSETTING(CustomAuthKey,S_EMPTY)               \
    STRSETTING(CustomAuthData,S_EMPTY)              \
    FUNSETTING(AuthRestrictions)                    \
    STRSETTING(OverridePref,TEXT("15"))             \
    STRSETTING(DialMode,S_EMPTY)                    \
    STRSETTING(DialPercent,S_EMPTY)                 \
    STRSETTING(DialSeconds,S_EMPTY)                 \
    STRSETTING(HangUpPercent,S_EMPTY)               \
    STRSETTING(HangUpSeconds,S_EMPTY)               \
    FUNSETTING(RedialAttempts)                      \
    FUNSETTING(RedialSeconds)                       \
    FUNSETTING(IdleDisconnectSeconds)               \
    STRSETTING(RedialOnLinkFailure,S_EMPTY)         \
    STRSETTING(CallBackMode,S_EMPTY)                \
    STRSETTING(CustomDialDll,S_EMPTY)               \
    STRSETTING(CustomDialFunc,S_EMPTY)              \
    STRSETTING(AuthenticateServer,S_EMPTY)          \
    STRSETTING(SecureLocalFiels,S_EMPTY)            \
    STRSETTING(ShareMsFilePrint,S_EMPTY)            \
    STRSETTING(BindMsNetClient,S_EMPTY)             \
    STRSETTING(SharedPhoneNumbers,S_EMPTY)          \
    STRSETTING(PrerequisiteEntry,S_EMPTY)           \
    FUNSETTING(PreviewUserPw)                       \
    FUNSETTING(PreviewDomain)                       \
    FUNSETTING(PreviewPhoneNumber)                  \
    STRSETTING(ShowDialingProgress,S_ONE)           \
    FUNSETTING(IpPrioritizeRemote)                  \
    FUNSETTING(IpHeaderCompression)                 \
    FUNSETTING(IpAddress)                           \
    FUNSETTING(IpAssign)                            \
    FUNSETTING(IpDnsAddress)                        \
    FUNSETTING(IpDns2Address)                       \
    FUNSETTING(IpWINSAddress)                       \
    FUNSETTING(IpWINS2Address)                      \
    FUNSETTING(IpNameAssign)                        \
    STRSETTING(IpFrameSize,S_EMPTY)                 \

//
// There can be multiple media sections for each entry.
//
#define MEDIA_SETTINGS                              \
    FUNSETTING(MEDIA)                               \
    FUNSETTING(Port)                                \
    FUNSETTING(Device)                              \
    FUNSETTING(ConnectBps)                          \

//
// There can be multiple device sections for each entry.
//
#define SWITCH_DEVICE_SETTINGS                      \
    FUNSETTING(DEVICE)                              \
    FUNSETTING(Name)                                \
    FUNSETTING(Terminal)                            \
    FUNSETTING(Script)                              \

#define MODEM_DEVICE_SETTINGS                       \
    FUNSETTING(DEVICE)                              \
    FUNSETTING(PhoneNumber)                         \
    FUNSETTING(AreaCode)                            \
    FUNSETTING(CountryCode)                         \
    FUNSETTING(CountryID)                           \
    FUNSETTING(UseDialingRules)                     \
    STRSETTING(Comment,S_EMPTY)                     \
    STRSETTING(LastSelectedPhone,S_EMPTY)           \
    STRSETTING(PromoteAlternates,S_EMPTY)           \
    STRSETTING(TryNextAlternateOnFail,S_EMPTY)      \
    FUNSETTING(HwFlowControl)                       \
    FUNSETTING(Protocol)                            \
    FUNSETTING(Compression)                         \
    FUNSETTING(Speaker)                             \

#define PAD_DEVICE_SETTINGS                         \
    STRSETTING(X25Pad,S_EMPTY)                      \
    STRSETTING(X25Address,S_EMPTY)                  \
    STRSETTING(UserData,S_EMPTY)                    \
    STRSETTING(Facilities,S_EMPTY)                  \

#define ISDN_DEVICE_SETTINGS                        \
    FUNSETTING(PhoneNumber)                         \
    FUNSETTING(AreaCode)                            \
    FUNSETTING(CountryCode)                         \
    FUNSETTING(CountryID)                           \
    FUNSETTING(UseDialingRules)                     \
    STRSETTING(Comment,S_EMPTY)                     \
    STRSETTING(LastSelectedPhone,S_EMPTY)           \
    STRSETTING(PromoteAlternates,S_EMPTY)           \
    STRSETTING(TryNextAlternateOnFail,S_EMPTY)      \
    STRSETTING(LineType,S_EMPTY)                    \
    STRSETTING(FallBack,S_EMPTY)                    \
    STRSETTING(EnableCompressiong,S_EMPTY)          \
    STRSETTING(ChannelAggregation,S_EMPTY)          \

#define X25_DEVICE_SETTINGS                         \
    STRSETTING(X25Address,S_EMPTY)                  \
    STRSETTING(UserData,S_EMPTY)                    \
    STRSETTING(Facilities,S_EMPTY)                  \

//
// Function prototypes.
//
typedef PCTSTR (DATA_FUNCTION_PROTOTYPE)(VOID);
typedef DATA_FUNCTION_PROTOTYPE * DATA_FUNCTION;

#define FUNSETTING(Data) DATA_FUNCTION_PROTOTYPE pGet##Data;
#define STRSETTING(x,y)

ENTRY_SETTINGS
MEDIA_SETTINGS
SWITCH_DEVICE_SETTINGS
MODEM_DEVICE_SETTINGS
PAD_DEVICE_SETTINGS
ISDN_DEVICE_SETTINGS
X25_DEVICE_SETTINGS

#undef FUNSETTING
#undef STRSETTING

#define FUNSETTING(x) {TEXT(#x), pGet##x, NULL},
#define STRSETTING(x,y) {TEXT(#x), NULL, y},
#define LASTSETTING {NULL,NULL,NULL}

typedef struct {
    PCTSTR SettingName;
    DATA_FUNCTION SettingFunction;
    PCTSTR SettingValue;
} RAS_SETTING, * PRAS_SETTING;


RAS_SETTING g_EntrySettings[] = {ENTRY_SETTINGS LASTSETTING};
RAS_SETTING g_MediaSettings[] = {MEDIA_SETTINGS LASTSETTING};
RAS_SETTING g_SwitchDeviceSettings[] = {SWITCH_DEVICE_SETTINGS LASTSETTING};
RAS_SETTING g_ModemDeviceSettings[] = {MODEM_DEVICE_SETTINGS LASTSETTING};
RAS_SETTING g_PadDeviceSettings[] = {PAD_DEVICE_SETTINGS LASTSETTING};
RAS_SETTING g_IsdnDeviceSettings[] = {ISDN_DEVICE_SETTINGS LASTSETTING};
RAS_SETTING g_X25DeviceSettings[] = {X25_DEVICE_SETTINGS LASTSETTING};

BOOL g_InSwitchSection = FALSE;
PCTSTR g_CurrentConnection = NULL;
UINT g_CurrentDevice = 0;
UINT g_CurrentDeviceType = 0;
#define RAS_BUFFER_SIZE MEMDB_MAX
TCHAR g_TempBuffer [RAS_BUFFER_SIZE];
HASHTABLE  g_DeviceTable = NULL;


BOOL
pIs9xRasInstalled (
    void
    )
{
    HKEY testKey = NULL;
    BOOL rf = FALSE;

    testKey = OpenRegKeyStr (S_SERVICEREMOTEACCESS);

    if (testKey) {
        //
        // Open key succeeded. Assume RAS is installed.
        //
        rf = TRUE;
        CloseRegKey(testKey);
    }

    return rf;
}

static BYTE NEAR PASCAL GenerateEncryptKey (LPCSTR szKey)
{
    BYTE   bKey;
    LPBYTE lpKey;

    for (bKey = 0, lpKey = (LPBYTE)szKey; *lpKey != 0; lpKey++)
    {
        bKey += *lpKey;
    };

    return bKey;
}

DWORD NEAR PASCAL EnDecryptEntry (LPCSTR szEntry, LPBYTE lpEnt,
                                  DWORD cb)
{
    BYTE   bKey;

    // Generate the encryption key from the entry name
    bKey = GenerateEncryptKey(szEntry);

    // Encrypt the address entry one byte at a time
    for (;cb > 0; cb--, lpEnt++)
    {
        *lpEnt ^= bKey;
    };
    return ERROR_SUCCESS;
}

PTSTR
pGetComPort (
    IN PCTSTR DriverDesc
    )
{
    PTSTR rPort = NULL;

    if (!HtFindStringEx (g_DeviceTable, DriverDesc, &rPort, FALSE)) {
        DEBUGMSG ((DBG_WARNING, "Could not find com port for device %s."));
    }

    if (!rPort) {
        rPort = S_EMPTY;
    }

    return rPort;
}

VOID
pInitializeDeviceTable (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE encodedRegPattern;
    REGTREE_ENUM e;
    PTSTR com;
    PTSTR desc;
    PTSTR p;

    encodedRegPattern = IsmCreateSimpleObjectPattern (S_MODEMS, TRUE, TEXT("*"), TRUE);

    if (EnumFirstRegObjectInTreeEx (
            &e,
            encodedRegPattern,
            TRUE,
            TRUE,
            TRUE,
            TRUE,
            1,
            FALSE,
            TRUE,
            RegEnumDefaultCallback
            )) {
        do {
            // we don't care about value names, we only want subkeys
            if (!e.CurrentValueData) {
                com = desc = NULL;
                com = GetRegValueString (e.CurrentKeyHandle, S_ATTACHEDTO);
                desc = GetRegValueString (e.CurrentKeyHandle, S_DRIVERDESC);

                if (com && desc) {
                    p = PmDuplicateString (g_RasPool, com);

                    HtAddStringEx (g_DeviceTable, desc, (PBYTE) &p, FALSE);

                    DEBUGMSG ((DBG_RASMIG, "%s on %s added to driver table.", desc, com));
                }

                if (com) {
                    MemFree (g_hHeap, 0, com);
                }
                if (desc) {
                    MemFree (g_hHeap, 0, desc);
                }
            }
        } while (EnumNextRegObjectInTree (&e));
    }

    //
    // Clean up resources.
    //
    IsmDestroyObjectHandle (encodedRegPattern);
}

BOOL
pGetPerUserSettings (
    VOID
    )
{
    HKEY settingsKey;
    PDWORD data;
    PCTSTR entryStr;
    BOOL rSuccess = TRUE;

    settingsKey = OpenRegKeyStr (S_REMOTE_ACCESS_KEY);

    if (settingsKey) {

        //
        // Get UI settings.
        //
        data = (PDWORD) GetRegValueBinary (settingsKey, S_DIALUI);

        //
        // Save Dial User Interface info into memdb for this user.
        //
        if (data) {

            entryStr = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_USER, MEMDB_FIELD_USER_SETTINGS, S_DIALUI, NULL));

            rSuccess &= (MemDbSetValue (entryStr, *data) != 0);

            MemFree (g_hHeap, 0, data);
        }
        ELSE_DEBUGMSG ((DBG_RASMIG, "No user UI settings found for current user."));

        //
        // Get Redial information.
        //
        data = (PDWORD) GetRegValueBinary (settingsKey, S_ENABLE_REDIAL);

        if (data) {

            entryStr = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_USER, MEMDB_FIELD_USER_SETTINGS, S_ENABLE_REDIAL, NULL));

            rSuccess &= (MemDbSetValue (entryStr, *data) != 0);

            MemFree (g_hHeap, 0, data);
        }
        ELSE_DEBUGMSG ((DBG_RASMIG, "No user redial information found for current user."));

        data = (PDWORD) GetRegValueBinary (settingsKey, S_REDIAL_TRY);

        if (data) {

            entryStr = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_USER, MEMDB_FIELD_USER_SETTINGS, S_REDIAL_TRY, NULL));

            rSuccess &= (MemDbSetValue (entryStr, *data) != 0);

            MemFree (g_hHeap, 0, data);
        }
        ELSE_DEBUGMSG ((DBG_RASMIG, "No user redial information found for current user."));

        data = (PDWORD) GetRegValueBinary (settingsKey, S_REDIAL_WAIT);

        if (data) {

            entryStr = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_USER, MEMDB_FIELD_USER_SETTINGS, S_REDIAL_WAIT, NULL));

            rSuccess &= (MemDbSetValue (entryStr, HIWORD(*data) * 60 + LOWORD(*data)) != 0);

            MemFree (g_hHeap, 0, data);
        }
        ELSE_DEBUGMSG ((DBG_RASMIG, "No user redial information found for current user."));

        //
        // Get implicit connection information. (Controls wether connection ui should be displayed or not)
        //
        data = (PDWORD) GetRegValueBinary (settingsKey, S_ENABLE_IMPLICIT);

        if (data) {

            entryStr = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_USER, MEMDB_FIELD_USER_SETTINGS, S_ENABLE_IMPLICIT, NULL));

            rSuccess &= (MemDbSetValue (entryStr, *data) != 0);

            MemFree(g_hHeap,0,data);
        }
        ELSE_DEBUGMSG ((DBG_RASMIG, "No user implicit connection information found for current user."));

        CloseRegKey(settingsKey);
    }

    return rSuccess;
}

VOID
pSaveConnectionDataToMemDb (
    IN PCTSTR Entry,
    IN PCTSTR ValueName,
    IN DWORD  ValueType,
    IN PBYTE  Value
    )
{
    KEYHANDLE keyHandle;
    PCTSTR entryStr;
    PCTSTR entryTmp;

    entryStr = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_INFO, Entry, ValueName, NULL));

    switch (ValueType) {
        case REG_SZ:
        case REG_MULTI_SZ:
        case REG_EXPAND_SZ:
            DEBUGMSG ((DBG_RASMIG, "String Data - %s = %s", ValueName, (PCTSTR) Value));

            entryTmp = JoinPaths (MEMDB_CATEGORY_RAS_DATA, (PCTSTR) Value);

            keyHandle = MemDbSetKey (entryTmp);

            if (!keyHandle) {
                DEBUGMSG ((DBG_ERROR, "Error saving ras data into memdb."));
            }

            FreePathString (entryTmp);

            if (!MemDbSetValueAndFlagsEx (entryStr, TRUE, keyHandle, TRUE, REG_SZ, 0)) {
                DEBUGMSG ((DBG_ERROR, "Error saving ras data into memdb."));
            }

            break;

        case REG_DWORD:

            DEBUGMSG ((DBG_RASMIG, "DWORD Data - %s = %u", ValueName, (DWORD)(ULONG_PTR) Value));

            if (!MemDbSetValueAndFlagsEx (entryStr, TRUE, (DWORD)(ULONG_PTR) Value, TRUE, ValueType, 0)) {
                DEBUGMSG ((DBG_ERROR, "Error saving ras data into memdb."));
            }

            break;

        case REG_BINARY:

            DEBUGMSG ((DBG_RASMIG, "Binary data for %s.", ValueName));

            if (StringIMatch (S_IPINFO, ValueName)) {

                //
                // Save IP address information.
                //
                pSaveConnectionDataToMemDb (Entry, S_IP_FTCPIP, REG_DWORD, (PBYTE)(ULONG_PTR)((PIPDATA) Value) -> fdwTCPIP);
                pSaveConnectionDataToMemDb (Entry, S_IP_IPADDR, REG_DWORD, (PBYTE)(ULONG_PTR)((PIPDATA) Value) -> dwIPAddr);
                pSaveConnectionDataToMemDb (Entry, S_IP_DNSADDR, REG_DWORD, (PBYTE)(ULONG_PTR)((PIPDATA) Value) -> dwDNSAddr);
                pSaveConnectionDataToMemDb (Entry, S_IP_DNSADDR2, REG_DWORD, (PBYTE)(ULONG_PTR)((PIPDATA) Value) -> dwDNSAddrAlt);
                pSaveConnectionDataToMemDb (Entry, S_IP_WINSADDR, REG_DWORD, (PBYTE)(ULONG_PTR)((PIPDATA) Value) -> dwWINSAddr);
                pSaveConnectionDataToMemDb (Entry, S_IP_WINSADDR2, REG_DWORD, (PBYTE)(ULONG_PTR)((PIPDATA) Value) -> dwWINSAddrAlt);

            } else if (StringIMatch (S_TERMINAL, ValueName)) {

                //
                // save information on the showcmd state. This will tell us how to set the ui display.
                //
                pSaveConnectionDataToMemDb (Entry, ValueName, REG_DWORD, (PBYTE)(ULONG_PTR)((PWINDOWPLACEMENT) Value) -> showCmd);

            } else if (StringIMatch (S_MODE, ValueName)) {

                //
                // This value tells what to do with scripting.
                //
                pSaveConnectionDataToMemDb (Entry, ValueName, REG_DWORD, (PBYTE)(ULONG_PTR) *((PDWORD) Value));

            } else if (StringIMatch (S_MULTILINK, ValueName)) {

                //
                //  Save wether or not multilink is enabled.
                //
                pSaveConnectionDataToMemDb (Entry, ValueName, REG_DWORD,(PBYTE)(ULONG_PTR) *((PDWORD) Value));

            } ELSE_DEBUGMSG ((DBG_WARNING, "Don't know how to handle binary data %s. It will be ignored.", ValueName));

            break;

        default:
            DEBUGMSG ((DBG_WHOOPS, "Unknown type of registry data found in RAS settings. %s", ValueName));
            break;
    }

    FreePathString (entryStr);
}

BOOL
pGetRasEntryAddressInfo (
    IN PCTSTR KeyName,
    IN PCTSTR EntryName
    )
{
    BOOL rSuccess = TRUE;

    MIG_OBJECTSTRINGHANDLE encodedRegPattern;
    MIG_OBJECTSTRINGHANDLE encodedSubPattern;
    PBYTE           data = NULL;
    UINT            count = 0;
    UINT            type  = 0;
    PADDRENTRY      entry;
    PSUBCONNENTRY   subEntry;
    PSMMCFG         smmCfg;
    PDEVICEINFO     devInfo;
    REGTREE_ENUM    e;
    PTSTR           subEntriesKeyStr;
    UINT            sequencer = 0;
    REGTREE_ENUM    eSubEntries;
    TCHAR           buffer[MAX_TCHAR_PATH];
    PMODEMDEVINFO   modemInfo;
#ifdef UNICODE
    PCSTR tempStr = NULL;
    PCWSTR tempStrW = NULL;
#endif

    //
    // First we have to get the real entry name. It must match exactly even case. Unfortunately, it isn't neccessarily a given
    // that the case between HKCU\RemoteAccess\Profiles\<Foo> and HKCU\RemoteAccess\Addresses\[Foo] is the same. The registry
    // apis will of course work fine because they work case insensitively. However, I will be unable to decrypt the value
    // if I use the wrong name.
    //


    encodedRegPattern = IsmCreateSimpleObjectPattern (KeyName, FALSE, TEXT("*"), TRUE);

    if (EnumFirstRegObjectInTreeEx (
            &e,
            encodedRegPattern,
            TRUE,
            TRUE,
            TRUE,
            TRUE,
            REGENUM_ALL_SUBLEVELS,
            FALSE,
            TRUE,
            RegEnumDefaultCallback
            )) {
        do {
            if (StringIMatch (e.Name, EntryName)) {

                //
                // Found the correct entry. Use it.
                //
                data = e.CurrentValueData;

                if (data) {

                    entry   = (PADDRENTRY) data;

#ifdef UNICODE
                    tempStr = ConvertWtoA (e.Name);
                    DECRYPTENTRY(tempStr, entry, e.CurrentValueDataSize);
                    FreeConvertedStr (tempStr);
#else
                    DECRYPTENTRY(e.Name, entry, e.CurrentValueDataSize);
#endif

                    smmCfg  = PAESMMCFG(entry);
                    devInfo = PAEDI(entry);

                    pSaveConnectionDataToMemDb (EntryName, S_PHONE_NUMBER, REG_SZ, (PBYTE) PAEPHONE(entry));
                    pSaveConnectionDataToMemDb (EntryName, S_AREA_CODE, REG_SZ, (PBYTE) PAEAREA(entry));
                    pSaveConnectionDataToMemDb (EntryName, S_SMM, REG_SZ, (PBYTE) PAESMM(entry));
                    pSaveConnectionDataToMemDb (EntryName, S_COUNTRY_CODE, REG_DWORD, (PBYTE)(ULONG_PTR) entry -> dwCountryCode);
                    pSaveConnectionDataToMemDb (EntryName, S_COUNTRY_ID, REG_DWORD, (PBYTE)(ULONG_PTR) entry -> dwCountryID);
                    pSaveConnectionDataToMemDb (EntryName, S_DEVICE_NAME, REG_SZ, (PBYTE) devInfo -> szDeviceName);
                    pSaveConnectionDataToMemDb (EntryName, S_DEVICE_TYPE, REG_SZ, (PBYTE) devInfo -> szDeviceType);
                    pSaveConnectionDataToMemDb (EntryName, S_PROTOCOLS, REG_DWORD, (PBYTE)(ULONG_PTR) smmCfg -> fdwProtocols);
                    pSaveConnectionDataToMemDb (EntryName, S_SMM_OPTIONS, REG_DWORD, (PBYTE)(ULONG_PTR) smmCfg -> fdwOptions);

                    //
                    // Save device information away.
                    //
                    if (StringIMatchA (devInfo -> szDeviceType, S_MODEMA)) {

                        modemInfo = (PMODEMDEVINFO) (devInfo->szDeviceType + RAS_MaxDeviceType + 3);

                        if (modemInfo -> Size >= sizeof (MODEMDEVINFO)) {
                            DEBUGMSG_IF ((modemInfo -> Size > sizeof (MODEMDEVINFO), DBG_RASMIG, "Structure size larger than our known size."));

                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_UI_OPTIONS, REG_DWORD, (PBYTE)(ULONG_PTR) modemInfo -> ModemUiOptions);
                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_SPEED, REG_DWORD, (PBYTE)(ULONG_PTR) modemInfo -> ConnectionSpeed);
                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_SPEAKER_VOLUME, REG_DWORD, (PBYTE)(ULONG_PTR) modemInfo -> SpeakerVolume);
                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_IDLE_DISCONNECT_SECONDS, REG_DWORD, (PBYTE)(ULONG_PTR) modemInfo -> IdleDisconnectSeconds);
                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_CANCEL_SECONDS, REG_DWORD, (PBYTE)(ULONG_PTR) modemInfo -> CancelSeconds);
                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_CFG_OPTIONS, REG_DWORD, (PBYTE)(ULONG_PTR) modemInfo -> ConfigOptions);
#ifdef UNICODE
                            tempStrW = ConvertAtoW (devInfo->szDeviceName);
                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_COM_PORT, REG_SZ, (PBYTE) pGetComPort (tempStrW));
                            FreeConvertedStr (tempStrW);
#else
                            pSaveConnectionDataToMemDb (EntryName, S_MODEM_COM_PORT, REG_SZ, (PBYTE) pGetComPort (devInfo->szDeviceName));
#endif

                        }
                        ELSE_DEBUGMSG ((DBG_WHOOPS, "No modem configuration data saved. Size smaller than known structure. Investigate."));
                    }

                    //
                    // If SMM is not SLIP, CSLIP or PPP, we need to add a message to the upgrade report.
                    //
                    if (!StringIMatchA (PAESMM(entry), S_SLIPA) && !StringIMatchA (PAESMM(entry), S_PPPA) && !StringIMatchA (PAESMM(entry), S_CSLIPA)) {
                        LOG ((LOG_WARNING, (PCSTR) MSG_RASMIG_UNSUPPORTEDSETTINGS, EntryName));
                    }
                }

                //
                // Check to see if there are any sub-entries for this connection (MULTILINK settings..)
                //
                //
                // Luckily, we don't have to do the same enumeration of these entries as we had to above to get around
                // the case sensitivity bug. the 9x code uses the address key name above for encryption/decryption.
                //

                subEntriesKeyStr = JoinPathsInPoolEx ((NULL, KeyName, S_SUBENTRIES, e.Name, NULL));
                sequencer = 1;

                encodedSubPattern = IsmCreateSimpleObjectPattern (subEntriesKeyStr, FALSE, TEXT("*"), TRUE);

                if (EnumFirstRegObjectInTreeEx (
                        &eSubEntries,
                        encodedSubPattern,
                        TRUE,
                        TRUE,
                        TRUE,
                        TRUE,
                        REGENUM_ALL_SUBLEVELS,
                        FALSE,
                        TRUE,
                        RegEnumDefaultCallback
                        )) {
                    do {

                        DEBUGMSG ((DBG_RASMIG, "Multi-Link Subentries found for entry %s. Processing.", e.Name));

                        data = eSubEntries.CurrentValueData;

                        if (data) {

                            subEntry = (PSUBCONNENTRY) data;
#ifdef UNICODE
                            tempStr = ConvertWtoA (e.Name);
                            DECRYPTENTRY (tempStr, subEntry, eSubEntries.CurrentValueDataSize);
                            FreeConvertedStr (tempStr);
#else
                            DECRYPTENTRY (e.Name, subEntry, eSubEntries.CurrentValueDataSize);
#endif
                            wsprintf (buffer, TEXT("ml%d%s"), sequencer, S_DEVICE_TYPE);
                            pSaveConnectionDataToMemDb (EntryName, buffer, REG_SZ, (PBYTE) subEntry->szDeviceType);

                            wsprintf (buffer, TEXT("ml%d%s"), sequencer, S_DEVICE_NAME);
                            pSaveConnectionDataToMemDb (EntryName, buffer, REG_SZ, (PBYTE) subEntry->szDeviceName);

                            wsprintf (buffer, TEXT("ml%d%s"), sequencer, S_PHONE_NUMBER);
                            pSaveConnectionDataToMemDb (EntryName, buffer, REG_SZ, (PBYTE) subEntry->szLocal);

                            wsprintf (buffer, TEXT("ml%d%s"), sequencer, S_MODEM_COM_PORT);
#ifdef UNICODE
                            tempStrW = ConvertAtoW (subEntry->szDeviceName);
                            pSaveConnectionDataToMemDb (EntryName, buffer, REG_SZ, (PBYTE) pGetComPort (tempStrW));
                            FreeConvertedStr (tempStrW);
#else
                            pSaveConnectionDataToMemDb (EntryName, buffer, REG_SZ, (PBYTE) pGetComPort (subEntry->szDeviceName));
#endif
                        }

                        sequencer++;

                    } while (EnumNextRegObjectInTree (&eSubEntries));
                }

                IsmDestroyObjectHandle (encodedSubPattern);
                FreePathString (subEntriesKeyStr);

                //
                // Save away the number of devices associated with this connection
                //
                pSaveConnectionDataToMemDb (EntryName, S_DEVICECOUNT, REG_DWORD, (PBYTE)(ULONG_PTR) sequencer);

                //
                // We're done. Break out of the enumeration.
                //
                AbortRegObjectInTreeEnum (&e);
                break;
            }

        } while (EnumNextRegObjectInTree (&e));
    }

    IsmDestroyObjectHandle (encodedRegPattern);

    return rSuccess;
}

BOOL
pGetRasEntrySettings (
    IN PCTSTR KeyName,
    IN PCTSTR EntryName
    )
{
    REGTREE_ENUM e;
    MIG_OBJECTSTRINGHANDLE encodedRegPattern;
    PBYTE curData = NULL;
    BOOL rSuccess = TRUE;

    encodedRegPattern = IsmCreateSimpleObjectPattern (KeyName, FALSE, TEXT("*"), TRUE);

    if (EnumFirstRegObjectInTreeEx (
            &e,
            encodedRegPattern,
            TRUE,
            TRUE,
            TRUE,
            TRUE,
            REGENUM_ALL_SUBLEVELS,
            FALSE,
            TRUE,
            RegEnumDefaultCallback
            )) {
        do {
            if (e.CurrentValueData) {
                pSaveConnectionDataToMemDb (
                        EntryName,
                        e.Name,
                        e.CurrentValueType,
                        e.CurrentValueType == REG_DWORD ? (PBYTE)(ULONG_PTR) (*((PDWORD)e.CurrentValueData)) : e.CurrentValueData
                        );
            }
        } while (EnumNextRegObjectInTree (&e));
    }

    IsmDestroyObjectHandle (encodedRegPattern);

    return rSuccess;
}

BOOL
pGetPerConnectionSettings (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE encodedRegPattern;
    REGTREE_ENUM e;
    PCTSTR entryKey = NULL;
    BOOL rSuccess = TRUE;

    encodedRegPattern = IsmCreateSimpleObjectPattern (S_ADDRESSES_KEY, FALSE, TEXT("*"), TRUE);

    //
    // Enumerate each entry for this user.
    //
    if (EnumFirstRegObjectInTreeEx (
            &e,
            encodedRegPattern,
            TRUE,
            TRUE,
            TRUE,
            TRUE,
            REGENUM_ALL_SUBLEVELS,
            FALSE,
            TRUE,
            RegEnumDefaultCallback
            )) {
        do {
            //
            // Get base connection info -- stored as binary blob under address key.
            // All connections will have this info -- It contains such things
            // as the phone number, area code, dialing rules, etc.. It does
            // not matter wether the connection has been used or not.
            //
            rSuccess &= pGetRasEntryAddressInfo (S_ADDRESSES_KEY, e.Name);

            //
            // Under the profile key are negotiated options for the connection.
            // This key will only exist if the entry has actually been connected
            // to by the user.
            //
            entryKey = JoinPaths (S_PROFILE_KEY, e.Name);

            if (entryKey) {
                rSuccess &= pGetRasEntrySettings (entryKey, e.Name);
                FreePathString (entryKey);
            }

        } while (EnumNextRegObjectInTree (&e));
    }

    //
    // Clean up resources.
    //
    IsmDestroyObjectHandle (encodedRegPattern);

    return rSuccess;
}

BOOL
pGetRasDataFromMemDb (
    IN      PCTSTR DataName,
    OUT     PMEMDB_RAS_DATA Data
    )
{
    BOOL rSuccess = FALSE;
    PCTSTR key;
    DWORD value;
    DWORD flags;
    PCTSTR tempBuffer;

    MYASSERT(DataName && Data && g_CurrentConnection);

    key = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_INFO, g_CurrentConnection, DataName, NULL));
    rSuccess = MemDbGetValueAndFlags (key, &value, &flags);
    FreePathString (key);

    //
    // If that wasn't successful, we need to look in the per-user settings.
    //
    if (!rSuccess) {
        key = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_USER, MEMDB_FIELD_USER_SETTINGS, DataName, NULL));
        rSuccess = MemDbGetValueAndFlags (key, &value, &flags);
        flags = REG_DWORD;
    }

    if (rSuccess) {
        //
        // There is information stored here. Fill it in and send it back to the user.
        //
        if (flags == REG_SZ) {

            //
            // String data, the value points to the offset for the string.
            //
            tempBuffer = MemDbGetKeyFromHandle (value, 1);
            if (!tempBuffer) {
                DEBUGMSG ((
                    DBG_ERROR,
                    "Could not retrieve RAS string information stored in Memdb. Entry=%s,Setting=%s",
                    g_CurrentConnection,
                    DataName
                    ));
                 return FALSE;
            }

            Data -> String = PmDuplicateString (g_RasPool, tempBuffer);
            MemDbReleaseMemory (tempBuffer);
        }
        else {

            //
            // Not string data. The data is stored as the value.
            //
            Data -> Value = value;

        }

        Data -> DataType = (WORD) flags;

    }

    return rSuccess;
}

BOOL
pWritePhoneBookLine (
    IN HANDLE FileHandle,
    IN PCTSTR SettingName,
    IN PCTSTR SettingValue
    )
{
    BOOL rSuccess = TRUE;

    rSuccess &= WriteFileString (FileHandle, SettingName);
    rSuccess &= WriteFileString (FileHandle, TEXT("="));
    rSuccess &= WriteFileString (FileHandle, SettingValue ? SettingValue : S_EMPTY);
    rSuccess &= WriteFileString (FileHandle, TEXT("\r\n"));

    return rSuccess;
}

BOOL
pWriteSettings (
    IN      HANDLE FileHandle,
    IN      PRAS_SETTING SettingList
    )
{

    BOOL rSuccess = TRUE;

    while (SettingList->SettingName) {
        rSuccess &= pWritePhoneBookLine (
            FileHandle,
            SettingList->SettingName,
            SettingList->SettingValue ?
                SettingList->SettingValue :
                SettingList->SettingFunction ());

        SettingList++;
    }

    return rSuccess;
}

PCTSTR
pGetSpeaker (
    VOID
    )
{

    MEMDB_RAS_DATA d;

    if (g_CurrentDevice) {
        return S_ONE;
    }

    if (!pGetRasDataFromMemDb (S_MODEM_SPEAKER_VOLUME, &d)) {
        return S_ONE;
    }

    if (d.Value) {
        return S_ONE;
    }

    return S_ZERO;
}

PCTSTR
pGetCompression (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (g_CurrentDevice) {
        return S_EMPTY;
    }

    if (!pGetRasDataFromMemDb (S_MODEM_CFG_OPTIONS, &d)) {
        return S_EMPTY;
    }

    if (d.Value & RAS_CFG_FLAG_COMPRESS_DATA) {
        return S_ONE;
    }

    return S_ZERO;
}

PCTSTR
pGetProtocol (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (g_CurrentDevice) {
        return S_EMPTY;
    }

    if (!pGetRasDataFromMemDb (S_MODEM_CFG_OPTIONS, &d)) {
        return S_EMPTY;
    }

    if (d.Value & RAS_CFG_FLAG_USE_ERROR_CONTROL) {
        return S_ONE;
    }

    return S_ZERO;
}

PCTSTR
pGetHwFlowControl (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (g_CurrentDevice) {
        return S_EMPTY;
    }

    if (!pGetRasDataFromMemDb (S_MODEM_CFG_OPTIONS, &d)) {
        return S_EMPTY;
    }

    if (d.Value & RAS_CFG_FLAG_HARDWARE_FLOW_CONTROL) {
        return S_ONE;
    }

    return S_ZERO;
}

PCTSTR
pGetUseDialingRules (
    VOID
    )
{
    MEMDB_RAS_DATA d;
    //
    // Win9x sets the areacode, countrycode, countryid to zero if
    // use dialing rules is disabled. For ease, we test off of country
    // code. If we can't get it, or, it is set to zero, we assume
    // that we should _not_ use dialing rules.
    //
    if (!pGetRasDataFromMemDb(S_COUNTRY_CODE, &d) || !d.Value) {
        return S_ZERO;
    }

    return S_ONE;
}

PCTSTR
pGetCountryID (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_COUNTRY_ID, &d) || !d.Value) {
        return S_EMPTY;
    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetCountryCode (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb(S_COUNTRY_CODE, &d) || !d.Value) {
        return S_EMPTY;
    }
    wsprintf(g_TempBuffer,TEXT("%d"),d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetAreaCode (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb(S_AREA_CODE, &d)) {
        return S_EMPTY;
    }



    return d.String;
}

PCTSTR
pGetPhoneNumber (
    VOID
    )
{
    MEMDB_RAS_DATA d;
    TCHAR buffer[MAX_TCHAR_PATH];

    if (g_CurrentDevice == 0) {
        if (!pGetRasDataFromMemDb(S_PHONE_NUMBER, &d)) {
            return S_EMPTY;
        }
    }
    else {

        wsprintf(buffer,TEXT("ml%d%s"),g_CurrentDevice,S_PHONE_NUMBER);
        if (!pGetRasDataFromMemDb(buffer, &d)) {
            return S_EMPTY;
        }

    }

    return d.String;
}

PCTSTR
pGetScript (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_PPPSCRIPT, &d)) {

        return S_ZERO;
    }

    return S_ONE;
}

PCTSTR
pGetTerminal (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_UI_OPTIONS, &d)) {

        return S_EMPTY;
    }

    if (d.Value & (RAS_UI_FLAG_TERMBEFOREDIAL | RAS_UI_FLAG_TERMAFTERDIAL)) {
        return S_ONE;
    }

    return S_ZERO;
}

PCTSTR
pGetName (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_PPPSCRIPT, &d)) {

        return S_EMPTY;
    }
    else {

        return d.String;
    }

}

PCTSTR
pGetDEVICE (
    VOID
    )
{
    if (g_InSwitchSection) {
        return TEXT("Switch");
    }

    if (g_CurrentDeviceType == RASTYPE_VPN) {
        return TEXT("rastapi");
    }

    return TEXT("modem");

}

PCTSTR
pGetConnectBps (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!g_CurrentDevice) {

        if (!pGetRasDataFromMemDb (S_MODEM_SPEED, &d)) {
            return S_EMPTY;
        }

        wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

        return g_TempBuffer;
    }

    return S_EMPTY;
}

PCTSTR
pGetDevice (
    VOID
    )
{

    PTSTR p = S_MODEM_COM_PORT;
    PTSTR value = NULL;
    MEMDB_RAS_DATA d;


    //
    // Very easy if this is a vpn connection.
    //
    if (g_CurrentDeviceType == RASTYPE_VPN) {
        return TEXT("rastapi");
    }



    if (g_CurrentDevice) {
        wsprintf (g_TempBuffer, TEXT("ml%d%s"), g_CurrentDevice, S_MODEM_COM_PORT);
        p = g_TempBuffer;
    }

    if (!pGetRasDataFromMemDb (p, &d)) {
        return S_EMPTY;
    }

    if (!HtFindStringEx (g_DeviceTable, d.String, &value, FALSE)) {
        return S_EMPTY;
    }

    return value;
}

PCTSTR
pGetPort (
    VOID
    )
{
    PTSTR value = NULL;
    MEMDB_RAS_DATA d;
    PTSTR p = S_MODEM_COM_PORT;

    if (g_CurrentDeviceType == RASTYPE_VPN) {
        return TEXT("VPN2-0");
    }


    if (g_CurrentDevice) {
        wsprintf (g_TempBuffer, TEXT("ml%d%s"), g_CurrentDevice, S_MODEM_COM_PORT);
        p = g_TempBuffer;
    }

    if (!pGetRasDataFromMemDb (p, &d)) {
        return S_EMPTY;
    }

    if (!HtFindStringEx (g_DeviceTable, d.String, &value, FALSE)) {
        return S_EMPTY;
    }

    return d.String;
}

PCTSTR
pGetMEDIA (
    VOID
    )
{

    if (g_CurrentDeviceType == RASTYPE_VPN) {

        return TEXT("rastapi");
    }
    else {

        return TEXT("Serial");
    }

}

PCTSTR
pGetIpNameAssign (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d)) {
        return S_EMPTY;
    }
    else if (d.Value & IPF_NAME_SPECIFIED) {
        return TEXT("2");
    }
    else {
        return S_ONE;
    }
}

PCTSTR
pGetNetAddress (
    IN PCTSTR Setting
    )
{
    MEMDB_RAS_DATA d;
    BYTE address[4];

    if (!pGetRasDataFromMemDb (Setting, &d) || !d.Value) {
        return S_EMPTY;
    }

    //
    // Data is stored as a REG_DWORD.
    // We need to write it in dotted decimal form.
    //

    *((LPDWORD)address) = d.Value;
    wsprintf (
        g_TempBuffer,
        TEXT("%d.%d.%d.%d"),
        address[3],
        address[2],
        address[1],
        address[0]
        );

    return g_TempBuffer;
}

PCTSTR
pGetIpWINS2Address (
    VOID
    )
{
   return pGetNetAddress (S_IP_WINSADDR2);
}

PCTSTR
pGetIpWINSAddress (
    VOID
    )
{
    return pGetNetAddress (S_IP_WINSADDR);
}

PCTSTR
pGetIpDns2Address (
    VOID
    )
{
    return pGetNetAddress (S_IP_DNSADDR2);
}

PCTSTR
pGetIpDnsAddress (
    VOID
    )
{
    return pGetNetAddress (S_IP_DNSADDR);
}

PCTSTR
pGetIpAssign (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d)) {
        return S_EMPTY;
    }
    else if (d.Value & IPF_IP_SPECIFIED) {
        return TEXT("2");
    }
    else {
        return S_ONE;
    }
}

PCTSTR
pGetIpAddress (
    VOID
    )
{
    return pGetNetAddress (S_IP_IPADDR);
}

PCTSTR
pGetIpHeaderCompression (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d)) {
        return S_EMPTY;
    }
    else if (d.Value & IPF_NO_COMPRESS) {
        return S_ZERO;
    }
    else {
        return S_ONE;
    }
}

PCTSTR
pGetIpPrioritizeRemote (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d)) {
        return S_ONE;
    }
    else if (d.Value & IPF_NO_WAN_PRI) {
        return S_ZERO;
    }
    else {
        return S_ONE;
    }

}

PCTSTR
pGetPreviewUserPw (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_DIALUI, &d)) {
        return S_ONE;
    }

    if (d.Value & DIALUI_DONT_PROMPT_FOR_INFO) {
        return S_ZERO;
    }


    return S_ONE;
}

PCTSTR
pGetPreviewPhoneNumber (
    VOID
    )
{
    if (g_CurrentDeviceType == RASTYPE_VPN) {
        return S_ZERO;
    }

    return pGetPreviewUserPw ();
}

PCTSTR
pGetPreviewDomain (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) {
        return S_ONE;
    }

    //
    // if 0x04 is set, then preview domain, otherwise don't.
    //

    if (d.Value & SMMCFG_NW_LOGON) {
        return S_ONE;
    }

    return S_ZERO;
}

PCTSTR
pGetIdleDisconnectSeconds (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_IDLE_DISCONNECT_SECONDS, &d)) {
        return S_EMPTY;
    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetRedialSeconds (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // NT wants this as a total number of seconds. The data we have from 9x has
    // the number of minutes in the hiword and the number of seconds in the loword.
    //

    if (!pGetRasDataFromMemDb (S_REDIAL_WAIT, &d)) {
        return S_EMPTY;
    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;

}

PCTSTR
pGetRedialAttempts (
    VOID
    )
{

    MEMDB_RAS_DATA d;

    //
    // Before getting the number of redial attempts on windows 9x,
    // we need to ensure that redialing is enabled. If it is not
    // enabled, we set this field to zero, regardless.
    //


    if (pGetRasDataFromMemDb (S_ENABLE_REDIAL, &d)) {
        if (!d.Value) {
            return S_ZERO;
        }
    }

    //
    // If we have gotten this far, then redialing is enabled.
    //
    if (!pGetRasDataFromMemDb (S_REDIAL_TRY, &d)) {
        DEBUGMSG((DBG_WARNING, "Redialing enabled, but no redial attempts info found."));
        return S_ZERO;

    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetAuthRestrictions (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) {
        return S_EMPTY;
    }

    //
    // password should be encrypted if 0x02 is set.
    //
    if (d.Value & SMMCFG_PW_ENCRYPTED) {
        return TEXT("2");
    }

    return S_EMPTY;
}

PCTSTR
pGetShowMonitorIconInTaskBar (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // This information is stored packed with other Dialing UI on
    // windows 9x. All we need to do is look for the specific
    // bit which is set when this is turned off.
    //

    if (pGetRasDataFromMemDb (S_DIALUI, &d) && (d.Value & DIALUI_DONT_SHOW_ICON)) {
        return S_ZERO;
    }
    return S_ONE;
}

PCTSTR
pGetSwCompression (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) {
        return S_EMPTY;
    }

    //
    // the 1 bit in SMM_OPTIONS controls software based compression.
    // if it is set, the connection is able to handled compression,
    // otherwise, it cannot.
    //
    if (d.Value & SMMCFG_SW_COMPRESSION) {
        return S_ONE;
    }

    return S_ZERO;
}

PCTSTR
pGetDataEncryption (
    VOID
    )
{
    MEMDB_RAS_DATA d;
    BOOL reqDataEncrypt;

    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) {
        return S_EMPTY;
    }

    //
    // data should be encrypted if 0x1000 is set.
    //
    reqDataEncrypt = (d.Value & 0x1000);
    if (!reqDataEncrypt) {
        reqDataEncrypt = (d.Value & 0x200);
    }

    return reqDataEncrypt ? TEXT("256") : TEXT("8");
}

PCTSTR
pGetExcludedProtocols (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Excluded protocols lists what protocols
    // are _not_ available for a particular ras connection.
    // This is a bit field where bits are set for each protocol
    // that is excluded.
    // NP_Nbf (0x1), NP_Ipx (0x2), NP_Ip (0x4)
    // Luckily, these are the same definitions as for win9x, except
    // each bit represents a protocol that is _enabled_ not
    // _disabled_. Therefore, all we need to do is reverse the bottom
    // three bits of the number.
    //

    if (!pGetRasDataFromMemDb (S_PROTOCOLS, &d)) {
        //
        // No data found, so we default to all protocols enabled.
        //
        return S_ZERO;
    }

    wsprintf (g_TempBuffer, TEXT("%d"), ~d.Value & 0x7);

    return g_TempBuffer;
}

PCTSTR
pGetVpnStrategy (
    VOID
    )
{

    if (g_CurrentDeviceType == RASTYPE_VPN) {
        return TEXT("2");
    }

    return S_EMPTY;
}

PCTSTR
pGetBaseProtocol (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Only supported protocol types for NT 5 are
    // BP_PPP (0x1), BP_SLIP (0x2), and BP_RAS (0x3)
    //
    // If we can't find one, we default to BP_PPP.
    //
    if (!pGetRasDataFromMemDb (S_SMM, &d) || StringIMatch (d.String, S_PPP)) {
        return S_ONE;
    }

    //
    // MaP CSLIP to SLIP -- Header Compression will be on.
    //
    if (StringIMatch (d.String, S_SLIP) || StringIMatch (d.String, S_CSLIP)) {
        return TEXT("2");
    }

    DEBUGMSG ((
        DBG_WARNING,
        "RAS Migration: Unusable base protocol type (%s) for entry %s. Forcing PPP.",
        d.String,
        g_CurrentConnection
        ));

    // we are going to return an invalid protocol so the connection
    // does not get migrated.
    return TEXT("3");
}

PCTSTR
pGetCredPassword (
    VOID
    )
{
    return S_EMPTY;
}

PCTSTR
pGetCredDomain (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_DOMAIN, &d)) {
        return S_EMPTY;
    }


    return d.String;
}

PCTSTR
pGetCredName (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_USER, &d)) {
        return S_EMPTY;
    }

    return d.String;
}

PCTSTR
pGetCredMask (
    VOID
    )
{
    return TEXT("0x00000005");
}

PCTSTR
pGetType (
    VOID
    )
{

    if (g_CurrentDeviceType == RASTYPE_VPN) {

        return TEXT("2");
    }
    else {
        return S_ONE;
    }

}

BOOL
pCreateUserPhonebook (
    IN      PCTSTR PbkFile
    )
{
    PCTSTR tempKey;
    BOOL noError = FALSE;
    MEMDB_RAS_DATA d;
    MEMDB_ENUM e;
    HANDLE file;
    UINT i;
    UINT count;

    tempKey = JoinPathsInPoolEx ((NULL, MEMDB_CATEGORY_RAS_INFO, TEXT("\\*"), NULL));

    if (MemDbEnumFirst (&e, tempKey, ENUMFLAG_ALL, 1, 1)) {

        //
        // Open the phonebook file and set the file pointer to the EOF.
        //

        file = CreateFile (
            PbkFile,
            GENERIC_READ | GENERIC_WRITE,
            0,                                  // No sharing.
            NULL,                               // No inheritance
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL                                // No template file.
            );

        if (file == INVALID_HANDLE_VALUE) {
            DEBUGMSG ((DBG_ERROR, "Unable to open the phonebook file (%s)", PbkFile));
            FreePathString (tempKey);
            return FALSE;
        }

        SetFilePointer (file, 0, NULL, FILE_END);

        //
        // Now, enumerate all of the entries and write a phonebook entry to this
        // file for each.
        //

        do {

            g_CurrentConnection = e.KeyName;
            g_CurrentDevice = 0;
            if (!pGetRasDataFromMemDb (S_DEVICE_TYPE, &d)) {
                g_CurrentDeviceType = RASTYPE_PHONE;
            }
            else {
                if (StringIMatch (d.String, S_MODEM)) {
                    g_CurrentDeviceType = RASTYPE_PHONE;
                }
                else if (StringIMatch (d.String, S_VPN)) {
                    g_CurrentDeviceType = RASTYPE_VPN;
                }
                else {
                    g_CurrentDeviceType = RASTYPE_PHONE;
                }
            }


            noError = TRUE;

            //
            // Add this entry to the phonebook.
            //

            //
            // Write title.
            //
            noError &= WriteFileString (file, TEXT("["));
            noError &= WriteFileString (file, g_CurrentConnection);
            noError &= WriteFileString (file, TEXT("]\r\n"));


            //
            // Write base entry settings.
            //
            noError &= pWriteSettings (file, g_EntrySettings);




            if (!pGetRasDataFromMemDb (S_DEVICECOUNT, &d)) {
                count = 1;
                DEBUGMSG ((DBG_WHOOPS, "No devices listed in memdb for connections %s.", g_CurrentConnection));
            }
            else {
                count = d.Value;
            }
            for (i = 0; i < count; i++) {

                g_CurrentDevice = i;

                //
                // Write media settings.
                //
                noError &= WriteFileString (file, TEXT("\r\n"));
                noError &= pWriteSettings (file, g_MediaSettings);

                //
                // Write modem Device settings.
                //
                noError &= WriteFileString (file, TEXT("\r\n"));
                noError &= pWriteSettings (file, g_ModemDeviceSettings);
                noError &= WriteFileString (file, TEXT("\r\n\r\n"));


            }

            g_InSwitchSection = TRUE;

            noError &= WriteFileString (file, TEXT("\r\n"));
            noError &= pWriteSettings (file, g_SwitchDeviceSettings);
            noError &= WriteFileString (file, TEXT("\r\n\r\n"));

            g_InSwitchSection = FALSE;


            if (!noError) {
                LOG ((
                    LOG_ERROR,
                    "Error while writing phonebook for %s.",
                    g_CurrentConnection
                    ));
            }

        } while (MemDbEnumNext (&e));

        //
        // Close the handle to the phone book file.
        //
        CloseHandle (file);
    }
    ELSE_DEBUGMSG ((DBG_RASMIG, "No dial-up entries for current user."));

    FreePathString (tempKey);

    return noError;
}

MIG_OBJECTSTRINGHANDLE
pCreate9xPbkFile (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE result = NULL;
    PCTSTR nativeName = NULL;
    TCHAR windir [MAX_PATH];
    BOOL b = FALSE;

    GetWindowsDirectory (windir, MAX_PATH);
    result = IsmCreateObjectHandle (windir, TEXT("usmt.pbk"));
    if (!result) {
        return NULL;
    }
    nativeName = IsmGetNativeObjectName (g_FileTypeId, result);
    if (!nativeName) {
        IsmDestroyObjectHandle (result);
        return NULL;
    }

    if (pIs9xRasInstalled ()) {

        g_DeviceTable = HtAllocWithData (sizeof (PTSTR));
        MYASSERT (g_DeviceTable);

        pInitializeDeviceTable ();

        __try {
            b = pGetPerUserSettings ();
            b = b && pGetPerConnectionSettings ();
            b = b && pCreateUserPhonebook (nativeName);
        }
        __except (TRUE) {
            DEBUGMSG ((DBG_WHOOPS, "Caught an exception while processing ras settings."));
        }
        HtFree (g_DeviceTable);
    }

    IsmReleaseMemory (nativeName);

    if (!b) {
        IsmDestroyObjectHandle (result);
        result = NULL;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\unctrans\sources.inc ===
!include ..\..\modules.mk

MINORCOMP=unctrans

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\inftrans.c       \
    ..\unctrans.rc      \
    ..\opaque.c         \
    ..\entry.c          \
    ..\logmsg.mc        \


DLLENTRY=_DllMainCRTStartup
DLLBASE=0x02900000
LINKER_FLAGS=$(LINKER_FLAGS) -SWAPRUN:CD -SWAPRUN:NET
SUBSYSTEM_VERSION=4.00

# extra libs
TARGETLIBS= $(TARGETLIBS)                           \
            $(COBRA_ROOT)\lib\$(O)\memdb.lib        \
            $(COBRA_ROOT)\lib\$(O)\file.lib         \
            $(COBRA_ROOT)\lib\$(O)\inf.lib          \
            $(COBRA_ROOT)\bin\$(O)\migism.lib       \
            $(COBRA_ROOT)\lib\$(O)\cablib.lib       \
            $(SDK_LIB_PATH)\cabinet.lib

PRECOMPILED_INCLUDE=pch.h

DLLDEF=..\unctrans.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\unctrans\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tmlrel.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\unctrans\entry.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    entry.c

Abstract:

    Implements the DLL entry point that provides all Cobra module entry points
    to the engine.

Author:

    Jim Schmidt (jimschm) 11-Aug-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "unctrans.h"

typedef struct {
    PCTSTR Name;
    TRANSPORT_ENTRYPOINTS EntryPoints;
} TRANSPORT_TABLE, *PTRANSPORT_TABLE;

#define NOPROGBAR NULL
#define NORESET NULL
#define NORESUME NULL

//
// Add an entry for each transport module in the DLL
//

TRANSPORT_TABLE g_TransportEntryPoints[] = {
    {   TEXT("INF_BASED_UNC_TRANSPORT"), ISM_VERSION,
        InfTransTransportInitialize,
        InfTransTransportEstimateProgressBar,
        InfTransTransportQueryCapabilities,
        InfTransTransportSetStorage,
        NORESET,
        InfTransTransportTerminate,
        InfTransTransportSaveState,
        NORESUME,
        InfTransTransportBeginApply,
        NORESUME,
        InfTransTransportAcquireObject,
        InfTransTransportReleaseObject,
        InfTransTransportEndApply
    },

    {   TEXT("OPAQUE_UNC_TRANSPORT"), ISM_VERSION,
        OpaqueTransportInitialize,
        OpaqueTransportEstimateProgressBar,
        OpaqueTransportQueryCapabilities,
        OpaqueTransportSetStorage,
        NORESET,
        OpaqueTransportTerminate,
        OpaqueTransportSaveState,
        NORESUME,
        OpaqueTransportBeginApply,
        NORESUME,
        OpaqueTransportAcquireObject,
        OpaqueTransportReleaseObject,
        OpaqueTransportEndApply
    },

    {NULL}
};

EXPORT
BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        g_hInst = hInstance;
    }

    return TRUE;
}


EXPORT
BOOL
WINAPI
ModuleInitialize (
    VOID
    )
{
    TCHAR memDbDir[MAX_PATH];

    UtInitialize (NULL);
    FileEnumInitialize ();

    IsmGetTempDirectory (memDbDir, ARRAYSIZE (memDbDir));
    if (!MemDbInitializeEx (memDbDir)) {
        DEBUGMSG ((DBG_ERROR, "Failing to initialize unc transports because MemDb failed to initialize"));
        IsmSetCancel();
        return FALSE;
    }

    InfGlobalInit (FALSE);

    return TRUE;
}

EXPORT
VOID
WINAPI
ModuleTerminate (
    VOID
    )
{
    InfGlobalInit (TRUE);
    MemDbTerminateEx (TRUE);
    FileEnumTerminate ();
    UtTerminate ();
}


BOOL
WINAPI
pFindModule (
    IN      PCTSTR ModuleId,
    OUT     PVOID IsmBuffer,
    IN      PCTSTR *TableEntry,
    IN      UINT StructureSize
    )
{

    while (*TableEntry) {
        if (StringIMatch (*TableEntry, ModuleId)) {
            CopyMemory (
                IsmBuffer,
                (PBYTE) (TableEntry + 1),
                StructureSize
                );
            return TRUE;
        }

        TableEntry = (PCTSTR *) ((PBYTE) (TableEntry + 1) + StructureSize);
    }

    return FALSE;
}



EXPORT
BOOL
WINAPI
TransportModule (
    IN      PCTSTR ModuleId,
    IN OUT  PTRANSPORT_ENTRYPOINTS TransportEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) TransportEntryPoints,
                (PCTSTR *) g_TransportEntryPoints,
                sizeof (TRANSPORT_ENTRYPOINTS)
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\sources.inc ===
!include ..\..\modules.mk

MINORCOMP=sysmod

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\entry.c          \
    ..\cookies.c        \
    ..\lnkmig.c         \
    ..\netdrives.c      \
    ..\netshares.c      \
    ..\osfiles.c        \
    ..\dbattrib.c       \
    ..\dbaction.c       \
    ..\migdb.c          \
    ..\printers.c       \
    ..\rasmig.c         \
    ..\access.c         \
    ..\sysmod.rc        \
    ..\logmsg.mc        \


DLLENTRY=_DllMainCRTStartup
LINKER_FLAGS=$(LINKER_FLAGS) -SWAPRUN:CD -SWAPRUN:NET
SUBSYSTEM_VERSION=4.00
WINVER_VERSION=0x0500


# extra libs
TARGETLIBS= $(TARGETLIBS)                           \
            $(SDK_LIB_PATH)\winspool.lib            \
            $(SDK_LIB_PATH)\wininet.lib             \
            $(COBRA_ROOT)\lib\$(O)\version.lib      \
            $(COBRA_ROOT)\lib\$(O)\modimage.lib     \
            $(COBRA_ROOT)\lib\$(O)\memdb.lib        \
            $(COBRA_ROOT)\lib\$(O)\reg.lib          \
            $(COBRA_ROOT)\lib\$(O)\inf.lib          \
            $(COBRA_ROOT)\bin\$(O)\migism.lib       \
            $(COBRA_ROOT)\lib\$(O)\file.lib         \
            $(COBRA_ROOT)\lib\$(O)\icons.lib        \
            $(COBRA_ROOT)\lib\$(O)\modimage.lib     \
            $(COBRA_ROOT)\lib\$(O)\linkpif.lib      \

PRECOMPILED_INCLUDE=pch.h

DLLDEF=..\sysmod.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\unctrans\opaque.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    opaque.c

Abstract:

    Implements a basic secure server transport module

Author:

    Jim Schmidt (jimschm) 08-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"

#define DBG_OPAQUE   "OpaqueUnc"

//
// Strings
//

#define S_TRANSPORT_DIR         TEXT("USMT2.UNC")
#define S_TRANSPORT_DAT_FILE    TEXT("TRANSDB.DAT")
#define S_TRANSPORT_IMG_FILE    TEXT("IMG%05X.DAT")
#define S_TRANSPORT_DSK_FILE    TEXT("DSK%05X")
#define S_TRANSPORT_STATUS_FILE TEXT("status")
#define S_FILEOBJECT_NAME       TEXT("File")
#define S_REGOBJECT_NAME        TEXT("Registry")
#define S_DATABASEOBJECT_NAME   TEXT("Database")
#define S_DETAILS_PREFIX        TEXT("details-")

//
// Constants
//

#define TRFLAG_FILE     0x01
#define TRFLAG_MEMORY   0x02
#define OPAQUETR_SIG    0x55534D32  //USM2

#define TRSTATUS_DIRTY  0x00000001
#define TRSTATUS_READY  0x00000002
#define TRSTATUS_LOCKED 0x00000003

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR TempFile [MAX_PATH];
    PCVOID AllocPtr;
    PCVOID DetailsPtr;
    HANDLE FileHandle;
    HANDLE MapHandle;
} ALLOCSTATE, *PALLOCSTATE;

//
// Globals
//

MIG_TRANSPORTSTORAGEID g_ReliableStorageId;
PCTSTR g_TransportPath = NULL;
PCTSTR g_TransportTempPath = NULL;
PCTSTR g_TransportStatus = NULL;
HANDLE g_TransportStatusHandle = NULL;
BOOL g_OtCompressData = FALSE;
UINT g_Platform;
MIG_PROGRESSSLICEID g_DatabaseSlice;
MIG_PROGRESSSLICEID g_PersistentSlice;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

BOOL
pOtSaveAllState (
    IN      BOOL Compressed
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pSetOpaqueTransportStatus (
    IN      HANDLE TrJournalHandle,
    IN      BOOL Compressed,
    IN      DWORD Status
    )
{
    DWORD signature = OPAQUETR_SIG;
    BOOL result = FALSE;

    if (BfSetFilePointer (TrJournalHandle, 0)) {
        result = TRUE;
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&signature), sizeof (DWORD));
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&Compressed), sizeof (BOOL));
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&Status), sizeof (DWORD));
        result = result && FlushFileBuffers (TrJournalHandle);
    }
    return result;
}

DWORD
pGetOpaqueTransportStatus (
    IN      PCTSTR TrJournal,
    OUT     PBOOL Compressed    OPTIONAL
    )
{
    HANDLE trJrnHandle;
    BOOL compressed = FALSE;
    DWORD signature = 0;
    DWORD result = 0;

    if (TrJournal && TrJournal [0]) {
        trJrnHandle = BfOpenReadFile (TrJournal);
        if (trJrnHandle) {
            if (BfSetFilePointer (trJrnHandle, 0)) {
                if (BfReadFile (trJrnHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                    if (signature == OPAQUETR_SIG) {
                        if (BfReadFile (trJrnHandle, (PBYTE)(&compressed), sizeof (BOOL))) {
                            BfReadFile (trJrnHandle, (PBYTE)(&result), sizeof (DWORD));
                        }
                    }
                }
            }
            CloseHandle (trJrnHandle);
        } else {
            if (GetLastError () == ERROR_ACCESS_DENIED) {
                result = TRSTATUS_LOCKED;
            }
        }
    }
    if (Compressed) {
        *Compressed = compressed;
    }
    return result;
}

PCTSTR
pGetOpaqueImageFile (
    IN      PCTSTR BasePath,
    IN      UINT ImageIdx
    )
{
    TCHAR imageFileName [13];
    PCTSTR imageFile = NULL;
    HANDLE imageFileHandle = NULL;

    wsprintf (imageFileName, S_TRANSPORT_IMG_FILE, ImageIdx);
    return JoinPaths (BasePath, imageFileName);
}

PCTSTR
pGetRealTransportPath (
    VOID
    )
{
    return g_OtCompressData?g_TransportTempPath:g_TransportPath;
}

BOOL
WINAPI
OpaqueTransportInitialize (
    IN      PMIG_LOGCALLBACK LogCallback
    )
{
    //
    // Initialize globals
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    g_ReliableStorageId = IsmRegisterTransport (S_RELIABLE_STORAGE_TRANSPORT);

    return TRUE;
}

VOID
WINAPI
OpaqueTransportEstimateProgressBar (
    MIG_PLATFORMTYPEID PlatformTypeId
    )
{
    UINT ticks;
    MIG_OBJECTSTRINGHANDLE pattern;
    PMIG_OBJECTCOUNT objectCount;

    if (PlatformTypeId == PLATFORM_SOURCE) {

        //
        // If saving, we know the number of ticks based on
        // the count of the persistent attribute.
        //

        objectCount = IsmGetObjectsStatistics (PLATFORM_SOURCE);

        if (objectCount) {
            ticks = objectCount->PersistentObjects;
        } else {
            ticks = 0;
        }

        g_PersistentSlice = IsmRegisterProgressSlice (ticks, max (1, ticks / 5));

        ticks = 0;

        pattern = IsmCreateObjectPattern (ALL_PATTERN, 0, ALL_PATTERN, 0);

        IsmDestroyObjectHandle (pattern);

        g_DatabaseSlice = IsmRegisterProgressSlice (ticks, ticks * 3);

    } else {
        //
        // If restoring, we have almost no work to account for, since
        // we download from the secure server file-by-file.
        //

        DEBUGMSG ((DBG_VERBOSE, "Assuming transport download has no progress impact"));
    }
}

BOOL
WINAPI
OpaqueTransportQueryCapabilities (
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    OUT     PMIG_TRANSPORTTYPE TransportType,
    OUT     PMIG_TRANSPORTCAPABILITIES Capabilities,
    OUT     PCTSTR *FriendlyDescription
    )
{
    if (TransportStorageId != g_ReliableStorageId) {
        return FALSE;
    }

    *TransportType = TRANSPORTTYPE_FULL;
    *Capabilities = CAPABILITY_COMPRESSED;
    *FriendlyDescription = TEXT("Local computer or another computer on the Network");
    return TRUE;
}

VOID
pOtCleanUpTempDir (
    VOID
    )
{
    if (g_TransportTempPath) {
        FiRemoveAllFilesInTree (g_TransportTempPath);
    }
}

PCTSTR
pOtCreateTemporaryDir (
    VOID
    )
{
    TCHAR tempFile[MAX_PATH];

    if (!IsmGetTempDirectory (tempFile, ARRAYSIZE(tempFile))) {
        return NULL;
    }
    return DuplicatePathString (tempFile, 0);
}

BOOL
WINAPI
OpaqueTransportSetStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL Valid,
    OUT     PBOOL ImageExists
    )
{
    PCTSTR transportPath;
    PCTSTR transportStatus;
    MIG_OBJECTSTRINGHANDLE encodedPath;
    DWORD status;
    BOOL result = FALSE;

    if (Valid) {
        *Valid = FALSE;
    }
    if (ImageExists) {
        *ImageExists = FALSE;
    }

    if (TransportStorageId == g_ReliableStorageId) {

        if ((!RequiredCapabilities) || (RequiredCapabilities == CAPABILITY_COMPRESSED)) {

            if (RequiredCapabilities == CAPABILITY_COMPRESSED) {
                g_OtCompressData = TRUE;
            } else {
                g_OtCompressData = FALSE;
            }

            transportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR);
            transportStatus = JoinPaths (transportPath, S_TRANSPORT_STATUS_FILE);

            if (!DoesFileExist (transportPath)) {

                // we require UNC path or a full path (like c:\...)
                if (transportPath[0] == '\\' && transportPath[1] == '\\') {
                    // this is a UNC path
                    *Valid = TRUE;
                } else if (transportPath[1] == ':') {
                    // this is a normal full path
                    *Valid = TRUE;
                } else {
                    *Valid = FALSE;
                }

                *ImageExists = FALSE;

            } else {

                status = pGetOpaqueTransportStatus (transportStatus, NULL);

                switch (status) {
                case TRSTATUS_LOCKED:
                    *ImageExists = TRUE;
                    *Valid = FALSE;
                    break;
                case TRSTATUS_READY:
                    *ImageExists = TRUE;
                    *Valid = TRUE;
                    break;
                case TRSTATUS_DIRTY:
                    *ImageExists = FALSE;
                    *Valid = TRUE;
                    break;
                default:
                    *ImageExists = FALSE;
                    *Valid = TRUE;
                }
            }

            FreePathString (transportStatus);
            FreePathString (transportPath);
            result = TRUE;
        }
    }

    if (result && *Valid) {

        if (g_TransportPath) {
            FreePathString (g_TransportPath);
            g_TransportPath = NULL;
        }

        g_TransportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR);
        g_TransportStatus = JoinPaths (g_TransportPath, S_TRANSPORT_STATUS_FILE);

        encodedPath = IsmCreateSimpleObjectPattern (g_TransportPath, FALSE, NULL, FALSE);
        if (encodedPath) {
            IsmRegisterStaticExclusion (MIG_FILE_TYPE, encodedPath);
            IsmDestroyObjectHandle (encodedPath);
        }
    }

    return result;
}

BOOL
WINAPI
OpaqueTransportSaveState (
    VOID
    )
{
    DWORD status;
    BOOL result = FALSE;
    BOOL allowDelete = FALSE;

    if (!g_TransportPath) {
        DEBUGMSG ((DBG_ERROR, "Transport Path is not selected"));
        return FALSE;
    }

    if (DoesFileExist (g_TransportPath)) {

        status = pGetOpaqueTransportStatus (g_TransportStatus, NULL);

        switch (status) {
        case TRSTATUS_LOCKED:
            SetLastError (ERROR_ACCESS_DENIED);
            LOG ((LOG_ERROR, (PCSTR) MSG_TRANSPORT_DIR_BUSY, g_TransportPath));
            return FALSE;
        case TRSTATUS_DIRTY:
            result = FiRemoveAllFilesInTree (g_TransportPath);
            if (!result) {
                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_EMPTY_DIR, g_TransportPath));
                return FALSE;
            }
            break;
        case TRSTATUS_READY:
        default:
            if (IsmSendMessageToApp (TRANSPORTMESSAGE_IMAGE_EXISTS, 0)) {
                if (!FiRemoveAllFilesInTree (g_TransportPath)) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_EMPTY_DIR, g_TransportPath));
                    return FALSE;
                }
            } else {
                LOG ((LOG_ERROR, (PCSTR) MSG_NOT_EMPTY, g_TransportPath));
                SetLastError (ERROR_ALREADY_EXISTS);
                return FALSE;
            }
            break;
        }
    }

    allowDelete = TRUE;

    if (!BfCreateDirectory (g_TransportPath)) {
        PushError ();
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_DIR, g_TransportPath));
        PopError ();
        return FALSE;
    }

    g_TransportStatusHandle = BfCreateFile (g_TransportStatus);
    if (!g_TransportStatusHandle) {
        PushError ();
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_STATUS_FILE, g_TransportStatus));
        PopError ();
        return FALSE;
    }

    pSetOpaqueTransportStatus (g_TransportStatusHandle, g_OtCompressData, TRSTATUS_DIRTY);

    g_Platform = PLATFORM_SOURCE;
    result = pOtSaveAllState (g_OtCompressData);

    if (result) {
        pSetOpaqueTransportStatus (g_TransportStatusHandle, g_OtCompressData, TRSTATUS_READY);
    }
    CloseHandle (g_TransportStatusHandle);
    g_TransportStatusHandle = NULL;

    if (allowDelete && (!result)) {
        FiRemoveAllFilesInTree (g_TransportPath);
    }

    return result;
}

BOOL
pOtReadAllImages (
    VOID
    )
{
    PCTSTR imageFile = NULL;
    UINT imageIdx = 1;
    OCABHANDLE cabHandle;
    BOOL result = TRUE;

    while (result) {
        imageFile = pGetOpaqueImageFile (g_TransportPath, imageIdx);
        if (!DoesFileExist (imageFile)) {
            FreePathString (imageFile);
            return TRUE;
        }
        cabHandle = CabOpenCabinet (imageFile);
        if (cabHandle) {
            if (!CabExtractAllFiles (cabHandle, g_TransportTempPath)) {
                result = FALSE;
            }
            CabCloseCabinet (cabHandle);
        }
        FreePathString (imageFile);
        imageIdx ++;
    }
    return result;
}

BOOL
WINAPI
OpaqueTransportBeginApply (
    VOID
    )
{
    DWORD status = 0;
    PCTSTR memDbFile;
    BOOL b;

    g_Platform = PLATFORM_DESTINATION;

    if (!g_TransportPath) {
        DEBUGMSG ((DBG_ERROR, "Transport Path is not selected"));
        return FALSE;
    }

    while (status != TRSTATUS_READY) {

        status = pGetOpaqueTransportStatus (g_TransportStatus, &g_OtCompressData);

        switch (status) {
        case TRSTATUS_LOCKED:
            if (!IsmSendMessageToApp (TRANSPORTMESSAGE_IMAGE_LOCKED, 0)) {
                SetLastError (ERROR_ACCESS_DENIED);
                LOG ((LOG_ERROR, (PCSTR) MSG_TRANSPORT_DIR_BUSY, g_TransportPath));
                return FALSE;
            }
            break;
        case TRSTATUS_DIRTY:
            SetLastError (ERROR_INVALID_DATA);
            LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_IMAGE, g_TransportPath));
            return FALSE;
        case TRSTATUS_READY:
            break;
        default:
            SetLastError (ERROR_INVALID_DATA);
            LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_IMAGE, g_TransportPath));
            return FALSE;
        }
    }

    g_TransportStatusHandle = BfOpenReadFile (g_TransportStatus);
    if (!g_TransportStatusHandle) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_STATUS_FILE, g_TransportStatus));
        return FALSE;
    }

    if (g_OtCompressData) {
        g_TransportTempPath = pOtCreateTemporaryDir ();

        if (!g_TransportTempPath) {
            CloseHandle (g_TransportStatusHandle);
            g_TransportStatusHandle = NULL;
            return FALSE;
        }

        if (!pOtReadAllImages ()) {
            CloseHandle (g_TransportStatusHandle);
            g_TransportStatusHandle = NULL;
            return FALSE;
        }
        CloseHandle (g_TransportStatusHandle);
        g_TransportStatusHandle = NULL;
    }

    memDbFile = JoinPaths (pGetRealTransportPath (), S_TRANSPORT_DAT_FILE);

    b = MemDbLoad (memDbFile);
    FreePathString (memDbFile);

    return b;
}

VOID
WINAPI
OpaqueTransportEndApply (
    VOID
    )
{
    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    if (g_OtCompressData) {
        pOtCleanUpTempDir ();
    } else {
        CloseHandle (g_TransportStatusHandle);
        g_TransportStatusHandle = NULL;
    }
}

VOID
WINAPI
OpaqueTransportTerminate (
    VOID
    )
{
    pOtCleanUpTempDir();

    if (g_TransportTempPath) {
        FreePathString (g_TransportTempPath);
        g_TransportTempPath = NULL;
    }
    if (g_TransportStatus) {
        FreePathString (g_TransportStatus);
        g_TransportStatus = NULL;
    }
    if (g_TransportPath) {
        FreePathString (g_TransportPath);
        g_TransportPath = NULL;
    }
}

static
VOID
pGetTempFileName (
    OUT     PTSTR Buffer
    )
{
    static fileIndex = 0;

    fileIndex ++;
    wsprintf (Buffer, TEXT("%08X.DAT"), fileIndex);
}

PCTSTR
pOpaqueAllocStorageFileName (
    IN      PCTSTR FileName         OPTIONAL
    )
{
    TCHAR buffer[32];

    if (FileName) {
        StringCopy (buffer, FileName);
    } else {
        pGetTempFileName (buffer);
    }

    return JoinPaths (g_TransportPath, buffer);
}

VOID
pFreeStorageFileName (
    IN      PCTSTR FileName
    )
{
    FreePathString (FileName);
}

BOOL
pOpaqueSaveDetails (
    IN      PCTSTR DecoratedObject,
    IN      PMIG_DETAILS Details
    )
{
    PCTSTR key;
    BOOL b;

    if ((!Details) || (!Details->DetailsSize)) {
        return TRUE;
    }

    key = JoinText (S_DETAILS_PREFIX, DecoratedObject);

    b = (MemDbSetUnorderedBlob (key, 0, Details->DetailsData, Details->DetailsSize) != 0);

    FreeText (key);

    return b;
}

BOOL
pOtAddFileToImage (
    IN      PCTSTR FileName,
    IN      PCTSTR CabName,
    IN OUT  CCABHANDLE CabHandle
    )
{
    return CabAddFileToCabinet (CabHandle, FileName, CabName);
}

BOOL
pOtSaveContentInFile (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedFileName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content,
    IN OUT  CCABHANDLE CabHandle    OPTIONAL
    )
{
    BOOL result = FALSE;
    PCTSTR destPath = NULL;

    MYASSERT (Content->ContentInFile);
    if (!Content->ContentInFile) {
        return FALSE;
    }

    //
    // Use the CopyFile API to move the file from local to storage.
    //

    __try {
        if (!Content->FileContent.ContentSize) {

            // this must be a directory, let's just write the key

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

        } else {

            //
            // Get a temp file, assemble the src path, copy the file
            //

            destPath = pOpaqueAllocStorageFileName (NULL);
            if (!destPath) {
                __leave;
            }

            if (CabHandle) {
                if (!pOtAddFileToImage (Content->FileContent.ContentPath, GetFileNameFromPath (destPath), CabHandle)) {
                    __leave;
                }
            } else {
                if (!CopyFile (Content->FileContent.ContentPath, destPath, FALSE)) {
                    __leave;
                }
            }

            //
            // Keep track of where the file went
            //

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

            if (!MemDbAddSingleLinkage (DecoratedObject, GetFileNameFromPath (destPath), 0)) {
                __leave;
            }
        }

        //
        // Save details
        //

        result = pOpaqueSaveDetails (DecoratedObject, &(Content->Details));

    }
    __finally {
        pFreeStorageFileName (destPath);
        INVALID_POINTER (destPath);
    }

    return result;
}

BOOL
pOtSaveContentInMemory (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedObjectName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content
    )
{
    BOOL result = FALSE;

    MYASSERT (!Content->ContentInFile);
    if (Content->ContentInFile) {
        return FALSE;
    }

    MemDbSetValue (DecoratedObject, TRFLAG_MEMORY);

    if (Content->MemoryContent.ContentBytes && Content->MemoryContent.ContentSize) {

        MemDbSetUnorderedBlob (
            DecoratedObject,
            0,
            Content->MemoryContent.ContentBytes,
            Content->MemoryContent.ContentSize
            );
    }

    result = pOpaqueSaveDetails (DecoratedObject, &(Content->Details));

    return result;
}

PCTSTR
pOpaqueBuildDecoratedObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName
    )
{
    TCHAR prefix[32];

    wsprintf (prefix, TEXT("%u"), ObjectTypeId);

    return JoinPaths (prefix, ObjectName);
}

VOID
pOtDestroyDecoratedObject (
    IN      PCTSTR String
    )
{
    FreePathString (String);
}

BOOL
pOtWriteAllImages (
    VOID
    )
{
    UINT imageIdx = 1;
    PCTSTR imageFile;
    PCTSTR imageDest;
    BOOL result = FALSE;

    while (TRUE) {
        imageFile = pGetOpaqueImageFile (g_TransportTempPath, imageIdx);
        imageDest = pGetOpaqueImageFile (g_TransportPath, imageIdx);
        if (DoesFileExist (imageFile)) {
            if (!CopyFile (imageFile, imageDest, FALSE)) {
                break;
            }
        } else {
            result = TRUE;
            break;
        }
        FreePathString (imageDest);
        FreePathString (imageFile);
        imageIdx ++;
    }
    return result;
}

BOOL
pOtSaveAllState (
    IN      BOOL Compressed
    )
{
    MIG_CONTENT value;
    PMIG_CONTENT convValue;
    ULONGLONG size;
    MIG_OBJECTWITHATTRIBUTE_ENUM objEnum;
    PCTSTR ourDbFile = NULL;
    PCTSTR decoratedObject = NULL;
    ULONGLONG bytesSaved = 0;
    UINT lastTick = GetTickCount();
    TCHAR text[64];
    UINT fraction;
    CCABHANDLE cabHandle = NULL;
    INT_PTR appReply;
    BOOL okSave = FALSE;
    TRANSCOPY_ERROR transCopyError;
    BOOL result = FALSE;

    __try {

        if (Compressed) {
            g_TransportTempPath = pOtCreateTemporaryDir ();

            if (!g_TransportTempPath) {
                __leave;
            }

            cabHandle = CabCreateCabinet (g_TransportTempPath, S_TRANSPORT_IMG_FILE, S_TRANSPORT_DSK_FILE, IsmGetTempFile, 0);
            if (!cabHandle) {
                __leave;
            }
        }

        //
        // Enumerate all objects with "save" attribute
        //

        if (IsmEnumFirstPersistentObject (&objEnum)) {
            do {
                //
                // For each object to be saved, do the appropriate
                // data copy action
                //

                okSave = FALSE;
                while (!okSave) {

                    if (!IsmAcquireObjectEx (
                            objEnum.ObjectTypeId,
                            objEnum.ObjectName,
                            &value,
                            CONTENTTYPE_ANY,
                            0
                            )) {

                        transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                        transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                        transCopyError.Error = GetLastError ();

                        if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                            appReply = APPRESPONSE_IGNORE;
                        } else {
                            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                            if ((appReply == APPRESPONSE_NONE) ||
                                (appReply == APPRESPONSE_FAIL)
                                ) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                IsmReleaseMemory (transCopyError.ObjectName);
                                IsmAbortPersistentObjectEnum (&objEnum);
                                __leave;
                            }
                        }
                        if (appReply == APPRESPONSE_IGNORE) {
                            LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                            IsmReleaseMemory (transCopyError.ObjectName);
                            break;
                        }
                        IsmReleaseMemory (transCopyError.ObjectName);
                        continue;
                    }
                    okSave = TRUE;
                }

                if (okSave) {

#ifdef UNICODE
                    convValue = &value;
#else
                    // now let's convert this object content to UNICODE
                    convValue = IsmConvertObjectContentToUnicode (objEnum.ObjectTypeId, objEnum.ObjectName, &value);
                    if (!convValue) {
                        convValue = &value;
                    }
#endif
                    decoratedObject = pOpaqueBuildDecoratedObject (objEnum.ObjectTypeId, objEnum.ObjectName);

                    if (convValue->ContentInFile) {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pOtSaveContentInFile (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue, cabHandle)) {

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                        size = convValue->FileContent.ContentSize;
                    } else {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pOtSaveContentInMemory (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue)) {

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                        size = convValue->MemoryContent.ContentSize;
                    }

#ifndef UNICODE
                    if (convValue != (&value)) {
                        IsmFreeConvertedObjectContent (objEnum.ObjectTypeId, convValue);
                    }
#endif
                    IsmReleaseObject (&value);

                    pOtDestroyDecoratedObject (decoratedObject);
                    decoratedObject = NULL;
                }

                if (!IsmTickProgressBar (g_PersistentSlice, 1)) {
                    IsmAbortPersistentObjectEnum (&objEnum);
                    __leave;
                }

                //
                // Send bytes saved to app every 3 seconds
                //

                bytesSaved += size;

                if (GetTickCount() - lastTick > 3000) {

                    if (bytesSaved < 1048576) {
                        wsprintf (text, TEXT("Saved: %u K"), (UINT) (bytesSaved / 1024));
                    } else if (bytesSaved < 8388608) {
                        fraction = (UINT) (bytesSaved / 10485);
                        wsprintf (text, TEXT("Saved: %u.%02u M"), fraction / 100, fraction % 100);
                    } else if (bytesSaved < 1073741824) {
                        wsprintf (text, TEXT("Saved: %u M"), (UINT) (bytesSaved / 1048576));
                    } else {
                        fraction = (UINT) (bytesSaved / 10737418);
                        wsprintf (text, TEXT("Saved: %u.%02u G"), fraction / 100, fraction % 100);
                    }

                    IsmSendMessageToApp (TRANSPORTMESSAGE_SIZE_SAVED, (ULONG_PTR) text);

                    lastTick = GetTickCount();
                }

            } while (IsmEnumNextPersistentObject (&objEnum));
        }

        if (Compressed) {
            ourDbFile = JoinPaths (g_TransportTempPath, S_TRANSPORT_DAT_FILE);
        } else {
            ourDbFile = pOpaqueAllocStorageFileName (S_TRANSPORT_DAT_FILE);
            if (!ourDbFile) {
                __leave;
            }
        }

        if (!MemDbSave (ourDbFile)) {
            __leave;
        }

        if (Compressed) {
            if (!pOtAddFileToImage (ourDbFile, S_TRANSPORT_DAT_FILE, cabHandle)) {
                __leave;
            }
            if (!CabFlushAndCloseCabinet (cabHandle)) {
                __leave;
            }
            if (!pOtWriteAllImages ()) {
                __leave;
            }
        }

        IsmSendMessageToApp (TRANSPORTMESSAGE_SIZE_SAVED, 0);
        result = TRUE;

    }
    __finally {
        pFreeStorageFileName (ourDbFile);
        INVALID_POINTER (ourDbFile);

        pOtDestroyDecoratedObject (decoratedObject);
        INVALID_POINTER (decoratedObject);

        if (g_OtCompressData && g_TransportTempPath) {
            pOtCleanUpTempDir ();
        }
    }

    return result;
}

BOOL
WINAPI
OpaqueTransportAcquireObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,                 CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    UINT value;
    PCBYTE memValue;
    UINT memValueSize;
    PCTSTR fileValue = NULL;
    BOOL valueInFile;
    KEYHANDLE keyHandle;
    PALLOCSTATE allocState;
    PCTSTR detailsKey = NULL;
    PBYTE details;
    UINT detailsSize;
    PCTSTR sourceFile;
    PCTSTR decoratedObject = NULL;
    HANDLE fileHandle;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    MYASSERT (g_Platform == PLATFORM_DESTINATION);
    MYASSERT ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE);

    decoratedObject = pOpaqueBuildDecoratedObject (ObjectTypeId, ObjectName);

    allocState = (PALLOCSTATE) MemAllocZeroed (sizeof (ALLOCSTATE));

    if (MemDbGetValue (decoratedObject, &value)) {
        if (value == TRFLAG_FILE) {
            valueInFile = TRUE;
            keyHandle = MemDbGetSingleLinkage (decoratedObject, 0, 0);
            if (keyHandle) {
                fileValue = MemDbGetKeyFromHandle (keyHandle, 0);
                result = fileValue != NULL;
            } else {
                fileValue = NULL;
                result = TRUE;
            }
        } else if (value == TRFLAG_MEMORY) {
            valueInFile = FALSE;
            memValueSize = 0;
            memValue = MemDbGetUnorderedBlob (decoratedObject, 0, &memValueSize);
            result = TRUE;
        } else {
            LOG ((LOG_ERROR, (PCSTR) MSG_UNSUPPORTED_DATA, value));
            SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        }
        if (result) {
            result = FALSE;

            if (valueInFile) {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_FILE) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as a file and it's wanted as a file
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = TRUE;
                    if (fileValue) {
                        ObjectContent->FileContent.ContentPath = JoinPaths (pGetRealTransportPath (), fileValue);
                        ObjectContent->FileContent.ContentSize = BfGetFileSize (ObjectContent->FileContent.ContentPath);
                    } else {
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                    result = TRUE;
                } else {
                    // this is stored as a file and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    if (fileValue) {
                        sourceFile = JoinPaths (pGetRealTransportPath (), fileValue);
                        ObjectContent->MemoryContent.ContentSize = (UINT) BfGetFileSize (sourceFile);
                        ObjectContent->MemoryContent.ContentBytes = MapFileIntoMemory (
                                                                        sourceFile,
                                                                        &allocState->FileHandle,
                                                                        &allocState->MapHandle
                                                                        );
                        FreePathString (sourceFile);
                        result = (ObjectContent->MemoryContent.ContentBytes != NULL);
                    } else {
                        ObjectContent->MemoryContent.ContentSize = 0;
                        ObjectContent->MemoryContent.ContentBytes = NULL;
                        result = TRUE;
                    }
                }
                MemDbReleaseMemory (fileValue);
            } else {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_MEMORY) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as memory and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    ObjectContent->MemoryContent.ContentSize = memValueSize;
                    ObjectContent->MemoryContent.ContentBytes = memValue;
                    result = TRUE;
                } else {
                    // this is stored as memory and it's wanted as a file
                    if (memValue) {
                        if (IsmGetTempFile (allocState->TempFile, ARRAYSIZE(allocState->TempFile))) {
                            fileHandle = BfCreateFile (allocState->TempFile);
                            if (fileHandle) {
                                if (BfWriteFile (fileHandle, memValue, memValueSize)) {
                                    ObjectContent->ObjectTypeId = ObjectTypeId;
                                    ObjectContent->ContentInFile = TRUE;
                                    ObjectContent->FileContent.ContentSize = memValueSize;
                                    ObjectContent->FileContent.ContentPath = DuplicatePathString (allocState->TempFile, 0);
                                    result = TRUE;
                                }
                                CloseHandle (fileHandle);
                            }
                        }
                        MemDbReleaseMemory (memValue);
                    } else {
                        ObjectContent->ObjectTypeId = ObjectTypeId;
                        ObjectContent->ContentInFile = TRUE;
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                }
            }
        }
    } else {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
    }

    if (result) {
        //
        // Fill the details
        //

        detailsKey = JoinText (S_DETAILS_PREFIX, decoratedObject);

        details = MemDbGetUnorderedBlob (detailsKey, 0, &detailsSize);

        if (!details) {
            detailsSize = 0;
        }

        allocState->DetailsPtr = details;

        ObjectContent->Details.DetailsSize = detailsSize;
        ObjectContent->Details.DetailsData = details;

        FreeText (detailsKey);

        ObjectContent->TransHandle = allocState;
    }

    if (!result) {
        FreeAlloc (allocState);
    }

    FreePathString (decoratedObject);

    return result;
}

BOOL
WINAPI
OpaqueTransportReleaseObject (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PALLOCSTATE allocState;

    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    allocState = (PALLOCSTATE) ObjectContent->TransHandle;

    if (ObjectContent->ContentInFile) {
        FreePathString (ObjectContent->FileContent.ContentPath);
        if (allocState && allocState->TempFile[0]) {
            DeleteFile (allocState->TempFile);
        }
    } else {
        if (allocState && allocState->FileHandle && allocState->MapHandle) {
            UnmapFile (
                ObjectContent->MemoryContent.ContentBytes,
                allocState->MapHandle,
                allocState->FileHandle
                );
        } else {
            MemDbReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
        }
    }

    if (allocState && allocState->DetailsPtr) {
        MemDbReleaseMemory (allocState->DetailsPtr);
    }

    FreeAlloc (allocState);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\unctrans\ansi\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "trans.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\unctrans\unicode\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "trans.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\sysmod\sysmod.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sysmod.h

Abstract:

    Header file for prototypes of modules combined into sysmod.dll.

Author:

    Jim Schmidt (jimschm) 11-Aug-2000

Revision History:

    <alias> <date> <comments>

--*/

// Accessiblity
ETMINITIALIZE AccessibilityEtmInitialize;
VCMINITIALIZE AccessibilitySourceInitialize;
VCMQUEUEENUMERATION AccessibilityQueueEnumeration;
VCMPARSE AccessibilityParse;

// Cookies
ETMINITIALIZE CookiesEtmInitialize;
VCMINITIALIZE CookiesSourceInitialize;
#define CookiesVcmParse     ((PVCMPARSE) CookiesSgmParse)
VCMQUEUEENUMERATION CookiesVcmQueueEnumeration;
SGMPARSE CookiesSgmParse;
SGMQUEUEENUMERATION CookiesSgmQueueEnumeration;
ETMNEWUSERCREATED CookiesEtmNewUserCreated;

// LnkMig
VCMINITIALIZE LnkMigVcmInitialize;
VCMQUEUEENUMERATION LnkMigVcmQueueEnumeration;
SGMINITIALIZE LnkMigSgmInitialize;
SGMQUEUEENUMERATION LnkMigSgmQueueEnumeration;
OPMINITIALIZE LnkMigOpmInitialize;

// NetDrives
ETMINITIALIZE NetDrivesEtmInitialize;
ETMNEWUSERCREATED NetDrivesEtmNewUserCreated;
SGMINITIALIZE NetDrivesSgmInitialize;
SGMPARSE NetDrivesSgmParse;
SGMQUEUEENUMERATION NetDrivesSgmQueueEnumeration;
VCMINITIALIZE NetDrivesVcmInitialize;
VCMPARSE NetDrivesVcmParse;
VCMQUEUEENUMERATION NetDrivesVcmQueueEnumeration;
CSMINITIALIZE NetDrivesCsmInitialize;
CSMEXECUTE NetDrivesCsmExecute;
OPMINITIALIZE NetDrivesOpmInitialize;

// NetShares
ETMINITIALIZE NetSharesEtmInitialize;
SGMINITIALIZE NetSharesSgmInitialize;
SGMPARSE NetSharesSgmParse;
SGMQUEUEENUMERATION NetSharesSgmQueueEnumeration;
VCMINITIALIZE NetSharesVcmInitialize;
VCMPARSE NetSharesVcmParse;
VCMQUEUEENUMERATION NetSharesVcmQueueEnumeration;

// OsFiles
SGMINITIALIZE OsFilesSgmInitialize;
SGMQUEUEENUMERATION OsFilesSgmQueueEnumeration;
SGMQUEUEHIGHPRIORITYENUMERATION OsFilesSgmQueueHighPriorityEnumeration;
VCMINITIALIZE OsFilesVcmInitialize;
VCMQUEUEENUMERATION OsFilesVcmQueueEnumeration;
VCMQUEUEHIGHPRIORITYENUMERATION OsFilesVcmQueueHighPriorityEnumeration;

// Printers
ETMINITIALIZE PrintersEtmInitialize;
ETMNEWUSERCREATED PrintersEtmNewUserCreated;
SGMINITIALIZE PrintersSgmInitialize;
SGMPARSE PrintersSgmParse;
SGMQUEUEENUMERATION PrintersSgmQueueEnumeration;
VCMINITIALIZE PrintersVcmInitialize;
VCMPARSE PrintersVcmParse;
VCMQUEUEENUMERATION PrintersVcmQueueEnumeration;

// RasMig
ETMINITIALIZE RasMigEtmInitialize;
SGMINITIALIZE RasMigSgmInitialize;
SGMPARSE RasMigSgmParse;
SGMQUEUEENUMERATION RasMigSgmQueueEnumeration;
VCMINITIALIZE RasMigVcmInitialize;
VCMPARSE RasMigVcmParse;
VCMQUEUEENUMERATION RasMigVcmQueueEnumeration;
OPMINITIALIZE RasMigOpmInitialize;

#define MODULE_LIST             \
    DEFMAC(Cookies)             \
    DEFMAC(Links)               \
    DEFMAC(NetDrives)           \
    DEFMAC(NetShares)           \
    DEFMAC(OsFiles)             \
    DEFMAC(Printers)            \
    DEFMAC(RasMig)              \

typedef BOOL(OURMODULEINIT)(VOID);
typedef OURMODULEINIT *POURMODULEINIT;

typedef VOID(OURMODULETERMINATE)(VOID);
typedef OURMODULETERMINATE *POURMODULETERMINATE;

#define DEFMAC(prefix)  OURMODULEINIT prefix##Initialize; OURMODULETERMINATE prefix##Terminate;

MODULE_LIST

#undef DEFMAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\unctrans\inftrans.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    inftrans.c

Abstract:

    Implements a basic secure server transport module

Author:

    Jim Schmidt (jimschm) 08-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"

#define DBG_INFTRANS      "InfTrans"

//
// Strings
//

#define S_TRANSPORT_DIR         TEXT("USMT2I.UNC")
#define S_TRANSPORT_INF_FILE    TEXT("migration.inf")
#define S_TRANSPORT_STATUS_FILE TEXT("status")
#define S_DETAILS_PREFIX        TEXT("details")

#define S_DATABASEFILE_LITE TEXT("|MainDatabaseFile\\LITE")   // pipe is to decorate for uniqueness

//
// Constants
//

#define TRFLAG_FILE     0x01
#define TRFLAG_MEMORY   0x02
#define INFTR_SIG       0x55534D32  //USM2

#define TRSTATUS_DIRTY  0x00000001
#define TRSTATUS_READY  0x00000002
#define TRSTATUS_LOCKED 0x00000003

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR TempFile [MAX_PATH];
    PCVOID AllocPtr;
    PCVOID DetailsPtr;
    HANDLE FileHandle;
    HANDLE MapHandle;
} ALLOCSTATE, *PALLOCSTATE;

//
// Globals
//

MIG_TRANSPORTSTORAGEID g_ReliableStorageId;
PCTSTR g_InfTransTransportPath = NULL;
PCTSTR g_InfTransTransportStatus = NULL;
HANDLE g_InfTransTransportStatusHandle = NULL;
UINT g_Platform;
MIG_PROGRESSSLICEID g_DatabaseSlice;
MIG_PROGRESSSLICEID g_PersistentSlice;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// see unctrans.h

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
pSetInfTransStatus (
    IN      HANDLE TrJournalHandle,
    IN      DWORD Status
    )
{
    DWORD signature = INFTR_SIG;
    BOOL result = FALSE;

    if (BfSetFilePointer (TrJournalHandle, 0)) {
        result = TRUE;
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&signature), sizeof (DWORD));
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&Status), sizeof (DWORD));
        result = result && FlushFileBuffers (TrJournalHandle);
    }
    return TRUE;
}

DWORD
pGetInfTransStatus (
    IN      PCTSTR TrJournal
    )
{
    HANDLE trJrnHandle;
    DWORD signature = 0;
    DWORD result = 0;

    if (TrJournal && TrJournal [0]) {
        trJrnHandle = BfOpenReadFile (TrJournal);
        if (trJrnHandle) {
            if (BfSetFilePointer (trJrnHandle, 0)) {
                if (BfReadFile (trJrnHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                    if (signature == INFTR_SIG) {
                        if (!BfReadFile (trJrnHandle, (PBYTE)(&result), sizeof (DWORD))) {
                            result = 0;
                        }
                    }
                }
            }
            CloseHandle (trJrnHandle);
        } else {
            if (GetLastError () == ERROR_ACCESS_DENIED) {
                result = TRSTATUS_LOCKED;
            }
        }
    }
    return result;
}

BOOL
WINAPI
InfTransTransportInitialize (
    IN      PMIG_LOGCALLBACK LogCallback
    )
{
    //
    // Initialize globals
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    g_ReliableStorageId = IsmRegisterTransport (S_RELIABLE_STORAGE_TRANSPORT);

    return TRUE;
}

VOID
WINAPI
InfTransTransportEstimateProgressBar (
    MIG_PLATFORMTYPEID PlatformTypeId
    )
{
    DEBUGMSG ((DBG_VERBOSE, "Assuming transport download has no progress impact"));
}

BOOL
WINAPI
InfTransTransportQueryCapabilities (
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    OUT     PMIG_TRANSPORTTYPE TransportType,
    OUT     PMIG_TRANSPORTCAPABILITIES Capabilities,
    OUT     PCTSTR *FriendlyDescription
    )
{
    if (TransportStorageId != g_ReliableStorageId) {
        return FALSE;
    }

    *TransportType = TRANSPORTTYPE_LIGHT;
    *Capabilities = 0;
    *FriendlyDescription = TEXT("Another Computer on the Network");
    return TRUE;
}

BOOL
WINAPI
InfTransTransportSetStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL Valid,
    OUT     PBOOL ImageExists
    )
{
    PCTSTR transportPath;
    PCTSTR transportStatus;
    MIG_OBJECTSTRINGHANDLE encodedPath;
    DWORD status;
    BOOL result = FALSE;

    if (Valid) {
        *Valid = FALSE;
    }
    if (ImageExists) {
        *ImageExists = FALSE;
    }

    if (TransportStorageId == g_ReliableStorageId && !RequiredCapabilities) {

        transportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR);
        transportStatus = JoinPaths (transportPath, S_TRANSPORT_STATUS_FILE);

        if (!DoesFileExist (transportPath)) {

            // we require UNC path or a full path (like c:\...)
            if (transportPath[0] == '\\' && transportPath[1] == '\\') {
                // this is a UNC path
                *Valid = TRUE;
            } else if (transportPath[1] == ':') {
                // this is a normal full path
                *Valid = TRUE;
            } else {
                *Valid = FALSE;
            }

            *ImageExists = FALSE;

        } else {

            status = pGetInfTransStatus (transportStatus);

            switch (status) {
            case TRSTATUS_LOCKED:
                *ImageExists = TRUE;
                *Valid = FALSE;
                break;
            case TRSTATUS_READY:
                *ImageExists = TRUE;
                *Valid = TRUE;
                break;
            case TRSTATUS_DIRTY:
                *ImageExists = FALSE;
                *Valid = TRUE;
                break;
            default:
                *ImageExists = FALSE;
                *Valid = TRUE;
            }
        }

        FreePathString (transportStatus);
        FreePathString (transportPath);
        result = TRUE;
    }

    if (result && *Valid) {

        if (g_InfTransTransportPath) {
            FreePathString (g_InfTransTransportPath);
            g_InfTransTransportPath = NULL;
        }

        g_InfTransTransportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR);
        g_InfTransTransportStatus = JoinPaths (g_InfTransTransportPath, S_TRANSPORT_STATUS_FILE);

        encodedPath = IsmCreateSimpleObjectPattern (g_InfTransTransportPath, FALSE, NULL, FALSE);
        if (encodedPath) {
            IsmRegisterStaticExclusion (MIG_FILE_TYPE, encodedPath);
            IsmDestroyObjectHandle (encodedPath);
        }
    }

    return result;
}

BOOL
pInfTransSaveDetails (
    IN      PCTSTR DecoratedObject,
    IN      PMIG_DETAILS Details
    )
{
    PCTSTR key;
    BOOL b;

    if ((!Details) || (!Details->DetailsSize)) {
        return TRUE;
    }

    key = JoinText (S_DETAILS_PREFIX, DecoratedObject);

    b = (MemDbSetUnorderedBlob (key, 0, Details->DetailsData, Details->DetailsSize) != 0);

    FreeText (key);

    return b;
}

PCTSTR
pInfTransBuildDecoratedObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName
    )
{
    TCHAR prefix[32];

    wsprintf (prefix, TEXT("%u"), ObjectTypeId & (~PLATFORM_MASK));

    return JoinPaths (prefix, ObjectName);
}


VOID
pInfTransDestroyDecoratedObject (
    IN      PCTSTR String
    )
{
    FreePathString (String);
}

BOOL
pObjectNameToFileName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PCTSTR *FileName,
    OUT     PCTSTR *DirName     OPTIONAL
    )
{
    PCTSTR node, leaf;
    PCTSTR newNode, dirName;
    BOOL result = FALSE;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        newNode = StringSearchAndReplace (node, TEXT(":"), TEXT(""));
        if (newNode) {
            result = TRUE;
            if (leaf) {
                dirName = JoinPaths (g_InfTransTransportPath, newNode);
                *FileName = JoinPaths (dirName, leaf);
                if (!DirName) {
                    FreePathString (dirName);
                } else {
                    *DirName = dirName;
                }
                FreePathString (newNode);
            } else {
                *FileName = JoinPaths (g_InfTransTransportPath, newNode);
                if (DirName) {
                    *DirName = *FileName;
                }
                FreePathString (newNode);
            }
        } else {
            dirName = JoinPaths (g_InfTransTransportPath, node);
            *FileName = JoinPaths (dirName, leaf);
            FreePathString (dirName);
            if (DirName) {
                *DirName = JoinPaths (g_InfTransTransportPath, node);
            }
            result = TRUE;
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
pIsShortFileName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR TempDir
    )
{
    PCTSTR nativeFileName;
    PCTSTR fileNamePtr;
    PCTSTR testFileName;
    HANDLE fileHandle;
    WIN32_FIND_DATA fileInfo;
    BOOL result = FALSE;

    nativeFileName = IsmGetNativeObjectName (ObjectTypeId, ObjectName);
    if (nativeFileName) {
        fileNamePtr = GetFileNameFromPath (nativeFileName);
        if (fileNamePtr) {
            testFileName = JoinPaths (TempDir, fileNamePtr);
            fileHandle = BfCreateFile (testFileName);
            if (fileHandle) {
                CloseHandle (fileHandle);
                if (DoesFileExistEx (testFileName, &fileInfo)) {
                    result = (fileInfo.cAlternateFileName [0] == 0) ||
                             StringIMatch (fileInfo.cFileName, fileInfo.cAlternateFileName);
                }
                DeleteFile (testFileName);
            }
        }
        IsmReleaseMemory (nativeFileName);
    }
    return result;
}

BOOL
WINAPI
InfTransTransportSaveState (
    VOID
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    MIG_OBJECT_ENUM objEnum;
    MIG_OBJECTSTRINGHANDLE objectPattern = NULL;
    MIG_OBJECTSTRINGHANDLE objectName = NULL;
    MIG_CONTENT objectContent;
    PCTSTR infFile = NULL;
    HANDLE infFileHandle = NULL;
    PCTSTR objMultiSz;
    MULTISZ_ENUM multiSzEnum;
    BOOL firstMultiSz;
    PCTSTR fileName;
    PCTSTR dirName;
    DWORD status;
    MIG_OBJECTTYPEID dataTypeId;
    MIG_OBJECTTYPEID fileTypeId;
    TCHAR tempDir [MAX_PATH] = TEXT("");
    BOOL firstPass = TRUE;
    BOOL process = TRUE;
#ifdef DEBUG
    PCTSTR nativeObjectName;
#endif
    INT_PTR appReply;
    BOOL okSave = FALSE;
    TRANSCOPY_ERROR transCopyError;
    PTSTR encodedString = NULL;
    BOOL result = FALSE;
    GROWBUFFER writeBuffer = INIT_GROWBUFFER;

    if (DoesFileExist (g_InfTransTransportPath)) {

        status = pGetInfTransStatus (g_InfTransTransportStatus);

        switch (status) {
        case TRSTATUS_LOCKED:
            SetLastError (ERROR_ACCESS_DENIED);
            LOG ((LOG_ERROR, (PCSTR) MSG_TRANSPORT_DIR_BUSY, g_InfTransTransportPath));
            return FALSE;
        case TRSTATUS_DIRTY:
            result = FiRemoveAllFilesInTree (g_InfTransTransportPath);
            if (!result) {
                PushError ();
                SetLastError (ERROR_ACCESS_DENIED);
                LOG ((LOG_ERROR, (PCSTR) MSG_TRANSPORT_DIR_BUSY, g_InfTransTransportPath));
                PopError ();
                return FALSE;
            }
            break;
        case TRSTATUS_READY:
        default:
            if (IsmSendMessageToApp (TRANSPORTMESSAGE_IMAGE_EXISTS, 0)) {
                result = FiRemoveAllFilesInTree (g_InfTransTransportPath);
                if (!result) {
                    PushError ();
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_EMPTY_DIR , g_InfTransTransportPath));
                    PopError ();
                    return FALSE;
                }
            } else {
                LOG ((LOG_ERROR, (PCSTR) MSG_NOT_EMPTY, g_InfTransTransportPath));
                SetLastError (ERROR_ALREADY_EXISTS);
                return FALSE;
            }
            break;
        }
    }

    if (!BfCreateDirectory (g_InfTransTransportPath)) {
        PushError ();
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_DIR, g_InfTransTransportPath));
        PopError ();
        return FALSE;
    }

    g_InfTransTransportStatusHandle = BfCreateFile (g_InfTransTransportStatus);
    if (!g_InfTransTransportStatusHandle) {
        PushError ();
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_STATUS_FILE, g_InfTransTransportStatus));
        PopError ();
        return FALSE;
    }

    pSetInfTransStatus (g_InfTransTransportStatusHandle, TRSTATUS_DIRTY);

    __try {

        IsmGetTempDirectory (tempDir, MAX_PATH);

        g_Platform = PLATFORM_SOURCE;

        objectName = IsmCreateObjectHandle (S_DATABASEFILE_LITE, NULL);
        if (IsmAcquireObjectEx (
                MIG_DATA_TYPE | PLATFORM_SOURCE,
                objectName,
                &objectContent,
                CONTENTTYPE_FILE,
                0
                )) {
            // we have the database file, we assume it's an INF file
            // and we copy it to our transport location with the
            // migration.inf name.
            infFile = JoinPaths (g_InfTransTransportPath, S_TRANSPORT_INF_FILE);
            if (!CopyFile (objectContent.FileContent.ContentPath, infFile, FALSE)) {
                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_SAVE_ISM_INF));
                __leave;
            }
            IsmReleaseObject (&objectContent);
        } else {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_FIND_ISM_INF));
            __leave;
        }

        infFileHandle = BfOpenFile (infFile);
        if (!infFileHandle) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_FIND_ISM_INF));
            __leave;
        }
        BfGoToEndOfFile (infFileHandle, 0);

        objectPattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);

        objectTypeId = IsmGetFirstObjectTypeId ();

        dataTypeId = MIG_DATA_TYPE;
        fileTypeId = MIG_FILE_TYPE;

        while (objectTypeId) {
            if (firstPass) {
                WriteFileString (infFileHandle, TEXT("["));
                WriteFileString (infFileHandle, IsmGetObjectTypeName (objectTypeId));
                WriteFileString (infFileHandle, TEXT("]\r\n"));
            }

            if (IsmEnumFirstSourceObjectEx (&objEnum, objectTypeId, objectPattern, TRUE)) {
                do {

                    writeBuffer.End = 0;

                    if (IsmCheckCancel()) {
                        IsmAbortObjectEnum (&objEnum);
                        __leave;
                    }

                    if (objectTypeId == dataTypeId && StringIMatch(objEnum.ObjectName, objectName)) {
                        continue;
                    }
                    if (IsmIsPersistentObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {

                        process = TRUE;
                        if (objectTypeId == fileTypeId) {
                            if (firstPass) {
                                process = pIsShortFileName (objectTypeId, objEnum.ObjectName, tempDir);
                            } else {
                                process = !pIsShortFileName (objectTypeId, objEnum.ObjectName, tempDir);
                            }
                        }

                        if (process) {
#ifdef DEBUG
                            nativeObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                            DEBUGMSG ((DBG_INFTRANS, "Transporting: %s", nativeObjectName));
                            IsmReleaseMemory (nativeObjectName);
#endif

                            okSave = FALSE;
                            while (!okSave) {

                                if (!IsmAcquireObjectEx (
                                        objEnum.ObjectTypeId,
                                        objEnum.ObjectName,
                                        &objectContent,
                                        CONTENTTYPE_ANY,
                                        0
                                        )) {

                                    transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                    transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                    transCopyError.Error = GetLastError ();

                                    if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                        appReply = APPRESPONSE_IGNORE;
                                    } else {
                                        appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                        if ((appReply == APPRESPONSE_NONE) ||
                                            (appReply == APPRESPONSE_FAIL)
                                            ) {
                                            IsmAbortObjectEnum (&objEnum);
                                            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                            IsmReleaseMemory (transCopyError.ObjectName);
                                            IsmAbortObjectEnum (&objEnum);
                                            __leave;
                                        }
                                    }
                                    if (appReply == APPRESPONSE_IGNORE) {
                                        LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        break;
                                    }
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    continue;
                                }
                                okSave = TRUE;
                            }

                            if (okSave) {

                                // we have an object let's write it to the migration.inf
                                objMultiSz = IsmConvertObjectToMultiSz (
                                                objEnum.ObjectName,
                                                &objectContent
                                                );
                                if (objMultiSz) {
                                    if (EnumFirstMultiSz (&multiSzEnum, objMultiSz)) {
                                        firstMultiSz = TRUE;
                                        do {
                                            if (firstMultiSz) {
                                                firstMultiSz = FALSE;
                                            } else {
                                                GbAppendString (&writeBuffer, TEXT(","));
                                            }
                                            encodedString = AllocPathString (SizeOfString (multiSzEnum.CurrentString) * 6);
                                            if (EncodeRuleCharsEx (encodedString, multiSzEnum.CurrentString, TEXT("~\r\n")) != NULL) {
                                                GbAppendString (&writeBuffer, encodedString);
                                            } else {
                                                GbAppendString (&writeBuffer, multiSzEnum.CurrentString);
                                            }
                                            FreePathString (encodedString);
                                        } while (EnumNextMultiSz (&multiSzEnum));
                                        GbAppendString (&writeBuffer, TEXT("\r\n"));
                                    }
                                    IsmReleaseMemory (objMultiSz);
                                    if (objectContent.ContentInFile) {
                                        if (objectContent.FileContent.ContentPath) {
                                            // transform the object name into a file name and copy the
                                            // content file there
                                            if (!pObjectNameToFileName (objEnum.ObjectName, &fileName, &dirName)) {
                                                LOG ((
                                                    LOG_ERROR,
                                                    (PCSTR) MSG_COPYFILE_FAILURE,
                                                    objectContent.FileContent.ContentPath,
                                                    fileName
                                                    ));
                                                IsmAbortObjectEnum (&objEnum);
                                                __leave;
                                            }
                                            if (!BfCreateDirectory (dirName)) {
                                                LOG ((
                                                    LOG_ERROR,
                                                    (PCSTR) MSG_CREATE_FAILURE,
                                                    dirName,
                                                    objectContent.FileContent.ContentPath
                                                    ));
                                                IsmAbortObjectEnum (&objEnum);
                                                __leave;
                                            }
                                            okSave = FALSE;
                                            while (!okSave) {
                                                if (!CopyFile (objectContent.FileContent.ContentPath, fileName, TRUE)) {

                                                    transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                                    transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                                    transCopyError.Error = GetLastError ();

                                                    if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                                        appReply = APPRESPONSE_IGNORE;
                                                    } else {
                                                        appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                                        if ((appReply == APPRESPONSE_NONE) ||
                                                            (appReply == APPRESPONSE_FAIL)
                                                            ) {
                                                            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                                            IsmReleaseMemory (transCopyError.ObjectName);
                                                            IsmAbortObjectEnum (&objEnum);
                                                            __leave;
                                                        }
                                                    }
                                                    if (appReply == APPRESPONSE_IGNORE) {
                                                        LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                                        IsmReleaseMemory (transCopyError.ObjectName);
                                                        break;
                                                    }
                                                    IsmReleaseMemory (transCopyError.ObjectName);
                                                    continue;
                                                }
                                                okSave = TRUE;
                                            }
                                            if (dirName != fileName) {
                                                FreePathString (dirName);
                                            }
                                            FreePathString (fileName);
                                        }
                                    }
                                } else {
                                    GbAppendString (&writeBuffer, TEXT("\r\n"));
                                }
                                IsmReleaseObject (&objectContent);
                            }
                            WriteFileString (infFileHandle, (PTSTR) writeBuffer.Buf);
                        }
                    }
                } while (IsmEnumNextObject (&objEnum));
            }
            if (!firstPass || objectTypeId != fileTypeId) {
                WriteFileString (infFileHandle, TEXT("\r\n\r\n"));
            }

            if ((objectTypeId == fileTypeId) && firstPass) {
                firstPass = FALSE;
            } else {
                objectTypeId = IsmGetNextObjectTypeId (objectTypeId);
                firstPass = TRUE;
            }
        }
        result = TRUE;
    }
    __finally {
        if (tempDir [0]) {
            FiRemoveAllFilesInTree (tempDir);
        }
        IsmDestroyObjectHandle (objectName);
        if (infFileHandle != NULL) {
            CloseHandle (infFileHandle);
        }
        IsmDestroyObjectHandle (objectPattern);
        FreePathString (infFile);
        INVALID_POINTER (infFile);
    }

    if (result) {
        pSetInfTransStatus (g_InfTransTransportStatusHandle, TRSTATUS_READY);
    }
    CloseHandle (g_InfTransTransportStatusHandle);
    g_InfTransTransportStatusHandle = NULL;

    GbFree (&writeBuffer);

    if (!result) {
        FiRemoveAllFilesInTree (g_InfTransTransportPath);
    }

    return result;
}

BOOL
pSaveObjectContent (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR ObjectName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR fileName;
    BOOL result = FALSE;

    if (ObjectContent->ContentInFile) {
        MemDbSetValue (DecoratedObject, TRFLAG_FILE);
        if (pObjectNameToFileName (ObjectName, &fileName, NULL)) {
            if (DoesFileExist (fileName)) {
                MemDbAddSingleLinkage (DecoratedObject, fileName, 0);
            }
            FreePathString (fileName);
        }
    } else {
        MemDbSetValue (DecoratedObject, TRFLAG_MEMORY);
        if (ObjectContent->MemoryContent.ContentSize &&
            ObjectContent->MemoryContent.ContentBytes
            ) {

            MemDbSetUnorderedBlob (
                DecoratedObject,
                0,
                ObjectContent->MemoryContent.ContentBytes,
                ObjectContent->MemoryContent.ContentSize
                );
        }
    }

    result = pInfTransSaveDetails (DecoratedObject, &(ObjectContent->Details));

    return result;
}

BOOL
WINAPI
InfTransTransportBeginApply (
    VOID
    )
{
    PCTSTR infFile;
    HINF infHandle;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    MIG_OBJECTTYPEID objectTypeId;
    GROWBUFFER buff = INIT_GROWBUFFER;
    PCTSTR field;
    MIG_CONTENT objectContent;
    MIG_OBJECTSTRINGHANDLE objectName;
    UINT index;
    PCTSTR decoratedObject = NULL;
    DWORD status = 0;
    PTSTR decodedString = NULL;

    g_Platform = PLATFORM_DESTINATION;

    while (status != TRSTATUS_READY) {

        status = pGetInfTransStatus (g_InfTransTransportStatus);

        switch (status) {
        case TRSTATUS_LOCKED:
            if (!IsmSendMessageToApp (TRANSPORTMESSAGE_IMAGE_LOCKED, 0)) {
                LOG ((LOG_ERROR, (PCSTR) MSG_TRANSPORT_DIR_BUSY , g_InfTransTransportPath));
                SetLastError (ERROR_ACCESS_DENIED);
                return FALSE;
            }
            break;
        case TRSTATUS_DIRTY:
            SetLastError (ERROR_ACCESS_DENIED);
            LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_IMAGE, g_InfTransTransportPath));
            return FALSE;
        case TRSTATUS_READY:
            break;
        default:
            SetLastError (ERROR_INVALID_DATA);
            LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_IMAGE, g_InfTransTransportPath));
            return FALSE;
        }
    }

    g_InfTransTransportStatusHandle = BfOpenReadFile (g_InfTransTransportStatus);
    if (!g_InfTransTransportStatusHandle) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_STATUS_FILE, g_InfTransTransportStatus));
        return FALSE;
    }

    infFile = JoinPaths (g_InfTransTransportPath, S_TRANSPORT_INF_FILE);

    // add the database file in memdb so we can serve AcquireObject from the ISM

    objectName = IsmCreateObjectHandle (S_DATABASEFILE_LITE, NULL);
    decoratedObject = pInfTransBuildDecoratedObject (MIG_DATA_TYPE | PLATFORM_SOURCE, objectName);
    MemDbSetValue (decoratedObject, TRFLAG_FILE);
    MemDbAddSingleLinkage (decoratedObject, infFile, 0);
    pInfTransDestroyDecoratedObject (decoratedObject);
    IsmDestroyObjectHandle (objectName);

    infHandle = InfOpenInfFile (infFile);

    if (infHandle == INVALID_HANDLE_VALUE) {
        SetLastError (ERROR_FILE_NOT_FOUND);
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_ISM_INF, infFile));
        FreePathString (infFile);
        return FALSE;
    }

    objectTypeId = IsmGetFirstObjectTypeId ();
    while (objectTypeId) {

        if (InfFindFirstLine (infHandle, IsmGetObjectTypeName (objectTypeId), NULL, &is)) {
            do {
                index = 1;
                buff.End = 0;
                for (;;) {
                    field = InfGetStringField (&is, index);
                    if (!field) {
                        break;
                    }
                    if (*field) {
                        decodedString = DuplicatePathString (field, 0);
                        if (DecodeRuleChars (decodedString, field) != NULL) {
                            GbCopyString (&buff, decodedString);
                        } else {
                            GbCopyString (&buff, field);
                        }
                        FreePathString (decodedString);
                    } else {
                        GbCopyString (&buff, TEXT("<empty>"));
                    }
                    index ++;
                }
                if (buff.End) {
                    GbCopyString (&buff, TEXT(""));
                    if (IsmConvertMultiSzToObject (
                            objectTypeId,
                            (PCTSTR)buff.Buf,
                            &objectName,
                            &objectContent
                            )) {
                        // now save the object data into our database
                        // for future reference

                        decoratedObject = pInfTransBuildDecoratedObject (objectTypeId | PLATFORM_SOURCE, objectName);
                        pSaveObjectContent (objectTypeId | g_Platform, objectName, decoratedObject, &objectContent);
                        pInfTransDestroyDecoratedObject (decoratedObject);

                        IsmDestroyObjectHandle (objectName);
                        if ((objectContent.Details.DetailsSize) &&
                            (objectContent.Details.DetailsData)
                            ) {
                            IsmReleaseMemory (objectContent.Details.DetailsData);
                        }
                        if (objectContent.ContentInFile) {
                            if (objectContent.FileContent.ContentPath) {
                                IsmReleaseMemory (objectContent.FileContent.ContentPath);
                            }
                        } else {
                            if ((objectContent.MemoryContent.ContentSize) &&
                                (objectContent.MemoryContent.ContentBytes)
                                ) {
                                IsmReleaseMemory (objectContent.MemoryContent.ContentBytes);
                            }
                        }
                    }
                }

            } while (InfFindNextLine (&is));
        }

        objectTypeId = IsmGetNextObjectTypeId (objectTypeId);
    }

    GbFree (&buff);

    InfCleanUpInfStruct (&is);

    InfCloseInfFile (infHandle);

    FreePathString (infFile);

    return TRUE;
}

VOID
WINAPI
InfTransTransportEndApply (
    VOID
    )
{
    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    CloseHandle (g_InfTransTransportStatusHandle);
    g_InfTransTransportStatusHandle = NULL;
}

VOID
WINAPI
InfTransTransportTerminate (
    VOID
    )
{
    if (g_InfTransTransportPath) {
        FreePathString (g_InfTransTransportPath);
        g_InfTransTransportPath = NULL;
    }
    if (g_InfTransTransportStatus) {
        FreePathString (g_InfTransTransportStatus);
        g_InfTransTransportStatus = NULL;
    }
}

BOOL
WINAPI
InfTransTransportAcquireObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,             CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    UINT value;
    PCBYTE memValue;
    UINT memValueSize;
    PCTSTR fileValue = NULL;
    BOOL valueInFile;
    KEYHANDLE keyHandle;
    PALLOCSTATE allocState;
    PCTSTR detailsKey = NULL;
    PBYTE details;
    UINT detailsSize;
    PCTSTR decoratedObject = NULL;
    HANDLE fileHandle;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    MYASSERT (g_Platform == PLATFORM_DESTINATION);
    MYASSERT ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE);

    decoratedObject = pInfTransBuildDecoratedObject (ObjectTypeId, ObjectName);

    allocState = (PALLOCSTATE) MemAllocZeroed (sizeof (ALLOCSTATE));

    if (MemDbGetValue (decoratedObject, &value)) {
        if (value == TRFLAG_FILE) {
            valueInFile = TRUE;
            keyHandle = MemDbGetSingleLinkage (decoratedObject, 0, 0);
            if (keyHandle) {
                fileValue = MemDbGetKeyFromHandle (keyHandle, 0);
                result = fileValue != NULL;
            } else {
                fileValue = NULL;
                result = TRUE;
            }
        } else if (value == TRFLAG_MEMORY) {
            valueInFile = FALSE;
            memValueSize = 0;
            memValue = MemDbGetUnorderedBlob (decoratedObject, 0, &memValueSize);
            result = TRUE;
        } else {
            LOG ((LOG_ERROR, (PCSTR) MSG_UNSUPPORTED_DATA, value));
            SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        }
        if (result) {
            result = FALSE;

            if (valueInFile) {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_FILE) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as a file and it's wanted as a file
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = TRUE;
                    if (fileValue) {
                        ObjectContent->FileContent.ContentPath = DuplicatePathString (fileValue, 0);
                        ObjectContent->FileContent.ContentSize = BfGetFileSize (ObjectContent->FileContent.ContentPath);
                    } else {
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                    result = TRUE;
                } else {
                    // this is stored as a file and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    if (fileValue) {
                        ObjectContent->MemoryContent.ContentSize = (UINT) BfGetFileSize (fileValue);
                        ObjectContent->MemoryContent.ContentBytes = MapFileIntoMemory (
                                                                        fileValue,
                                                                        &allocState->FileHandle,
                                                                        &allocState->MapHandle
                                                                        );
                        result = (ObjectContent->MemoryContent.ContentBytes != NULL);
                    } else {
                        ObjectContent->MemoryContent.ContentSize = 0;
                        ObjectContent->MemoryContent.ContentBytes = NULL;
                        result = TRUE;
                    }
                }
                MemDbReleaseMemory (fileValue);
            } else {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_MEMORY) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as memory and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    ObjectContent->MemoryContent.ContentSize = memValueSize;
                    ObjectContent->MemoryContent.ContentBytes = memValue;
                    result = TRUE;
                } else {
                    // this is stored as memory and it's wanted as a file
                    if (memValue) {
                        if (IsmGetTempFile (allocState->TempFile, ARRAYSIZE(allocState->TempFile))) {
                            fileHandle = BfCreateFile (allocState->TempFile);
                            if (fileHandle) {
                                if (BfWriteFile (fileHandle, memValue, memValueSize)) {
                                    ObjectContent->ObjectTypeId = ObjectTypeId;
                                    ObjectContent->ContentInFile = TRUE;
                                    ObjectContent->FileContent.ContentSize = memValueSize;
                                    ObjectContent->FileContent.ContentPath = DuplicatePathString (allocState->TempFile, 0);
                                    result = TRUE;
                                }
                                CloseHandle (fileHandle);
                            }
                        }
                        MemDbReleaseMemory (memValue);
                    } else {
                        ObjectContent->ObjectTypeId = ObjectTypeId;
                        ObjectContent->ContentInFile = TRUE;
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                }
            }
        }
    } else {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
    }

    if (result) {
        //
        // Fill the details
        //

        detailsKey = JoinText (S_DETAILS_PREFIX, decoratedObject);

        details = MemDbGetUnorderedBlob (detailsKey, 0, &detailsSize);

        if (!details) {
            detailsSize = 0;
        }

        allocState->DetailsPtr = details;

        ObjectContent->Details.DetailsSize = detailsSize;
        ObjectContent->Details.DetailsData = details;

        FreeText (detailsKey);

        ObjectContent->TransHandle = allocState;
    }

    if (!result) {
        FreeAlloc (allocState);
    }

    FreePathString (decoratedObject);

    return result;
}

BOOL
WINAPI
InfTransTransportReleaseObject (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PALLOCSTATE allocState;

    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    allocState = (PALLOCSTATE) ObjectContent->TransHandle;

    if (ObjectContent->ContentInFile) {
        FreePathString (ObjectContent->FileContent.ContentPath);
        if (allocState && allocState->TempFile[0]) {
            DeleteFile (allocState->TempFile);
        }
    } else {
        if (allocState && allocState->FileHandle && allocState->MapHandle) {
            UnmapFile (
                ObjectContent->MemoryContent.ContentBytes,
                allocState->MapHandle,
                allocState->FileHandle
                );
        } else {
            MemDbReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
        }
    }

    if (allocState && allocState->DetailsPtr) {
        MemDbReleaseMemory (allocState->DetailsPtr);
    }

    FreeAlloc (allocState);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\modules\unctrans\unctrans.h ===
//
// Module entry points
//

// inftrans.c
TRANSPORTINITIALIZE InfTransTransportInitialize;
TRANSPORTQUERYCAPABILITIES InfTransTransportQueryCapabilities;
TRANSPORTSETSTORAGE InfTransTransportSetStorage;
TRANSPORTSAVESTATE InfTransTransportSaveState;
TRANSPORTBEGINAPPLY InfTransTransportBeginApply;
TRANSPORTACQUIREOBJECT InfTransTransportAcquireObject;
TRANSPORTRELEASEOBJECT InfTransTransportReleaseObject;
TRANSPORTENDAPPLY InfTransTransportEndApply;
TRANSPORTTERMINATE InfTransTransportTerminate;
TRANSPORTESTIMATEPROGRESSBAR InfTransTransportEstimateProgressBar;

// opaque.c
TRANSPORTINITIALIZE OpaqueTransportInitialize;
TRANSPORTQUERYCAPABILITIES OpaqueTransportQueryCapabilities;
TRANSPORTSETSTORAGE OpaqueTransportSetStorage;
TRANSPORTSAVESTATE OpaqueTransportSaveState;
TRANSPORTBEGINAPPLY OpaqueTransportBeginApply;
TRANSPORTACQUIREOBJECT OpaqueTransportAcquireObject;
TRANSPORTRELEASEOBJECT OpaqueTransportReleaseObject;
TRANSPORTENDAPPLY OpaqueTransportEndApply;
TRANSPORTTERMINATE OpaqueTransportTerminate;
TRANSPORTESTIMATEPROGRESSBAR OpaqueTransportEstimateProgressBar;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\placed\console\makefile.inc ===
APPTYPE=c
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\placed\sources.inc ===
#
# This file is designed to be included from 2 levels below
# (ie, daytona\srv, daytona\wks, cairo\srv, or cairo\wks).
#

TARGETNAME=inf
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY

#
# No explicit sources because build doesn't understand .inf files.
#
SOURCES=
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\placed\gui\makefile.inc ===
APPTYPE=g
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\placed\makefile.inc ===
LCID=409
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

#
# ANSI_CODEPAGE:  ANSI codepage for a given language.
#
# LCID:  Locale ID in hex.
#
# UNITEXT_OPT:  Unitext.exe command line options to specify the ANSI codepage
#   for a given language.  Used for Multibuyte -> Unicode conversion.
#

# Defaults
ANSI_CODEPAGE=1252
LANGUAGE_DRVCAB=$(LANGUAGE)

!if "$(LANGUAGE)"=="CHS" || "$(LANGUAGE)"=="chs"
# Chinese, Simplified
ANSI_CODEPAGE=936
LCID=804

!elseif "$(LANGUAGE)"=="CHT" || "$(LANGUAGE)"=="cht"
# Chinese, Traditional
ANSI_CODEPAGE=950
LCID=404

!elseif "$(LANGUAGE)"=="JPN" || "$(LANGUAGE)"=="jpn"
# Japanese
ANSI_CODEPAGE=932
LCID=411

!elseif "$(LANGUAGE)"=="KOR" || "$(LANGUAGE)"=="kor"
# Korean
ANSI_CODEPAGE=949
LCID=412

!elseif "$(LANGUAGE)"=="ARA" || "$(LANGUAGE)"=="ara"
# Arabic
ANSI_CODEPAGE=1256
LCID=401

!elseif "$(LANGUAGE)"=="HEB" || "$(LANGUAGE)"=="heb"
# Hebrew
ANSI_CODEPAGE=1255
LCID=40D

!elseif "$(LANGUAGE)"=="CS" || "$(LANGUAGE)"=="cs"
# Czech
ANSI_CODEPAGE=1250
LCID=405

!elseif "$(LANGUAGE)"=="HU" || "$(LANGUAGE)"=="hu"
# Hungarian
ANSI_CODEPAGE=1250
LCID=40E

!elseif "$(LANGUAGE)"=="PL" || "$(LANGUAGE)"=="pl"
# Polish
ANSI_CODEPAGE=1250
LCID=415

!elseif "$(LANGUAGE)"=="RU" || "$(LANGUAGE)"=="ru"
# Russian
ANSI_CODEPAGE=1251
LCID=419

!elseif "$(LANGUAGE)"=="EL" || "$(LANGUAGE)"=="el"
# Greek
ANSI_CODEPAGE=1253
LCID=408

!elseif "$(LANGUAGE)"=="TR" || "$(LANGUAGE)"=="tr"
# Turkish
ANSI_CODEPAGE=1254
LCID=41F

!elseif "$(LANGUAGE)"=="PSU" || "$(LANGUAGE)"=="psu"
ANSI_CODEPAGE=1253
LCID=408
!endif

UNITEXT_OPT=-m -$(ANSI_CODEPAGE)

STAMP=stampinf -f $@
PLACE=binplace -p .\placefil.txt $@

_LNG=..\$(LANGUAGE)
_INX=..
PREFLAGS=/DLANGUAGE_ID=0x0$(LCID) /EP

make_infs_g:  $(O)\migism.inf     \
              $(O)\usmtdef.inf    \
              $(O)\sysfiles.inf   \
              $(O)\migwiz.inf     \
              $(O)\miguser.inf    \
              $(O)\migsys.inf     \
              $(O)\migapp.inf     \
              $(O)\migwiz.htm     \
              $(O)\migwiz2.htm    \

make_infs_c:  $(O)\migism.inf     \
              $(O)\usmtdef.inf    \
              $(O)\sysfiles.inf   \
              $(O)\migwiz.inf     \
              $(O)\miguser.inf    \
              $(O)\migsys.inf     \
              $(O)\migapp.inf     \



$(O)\migism.inf: $(_INX)\migism.inx $(_LNG)\migism.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(APPTYPE)
    @del $(O)\$(@B).tmp
    $(STAMP)
    $(PLACE)

$(O)\usmtdef.inf: $(_INX)\usmtdef.inx $(_LNG)\usmtdef.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(APPTYPE)
    @del $(O)\$(@B).tmp
    $(STAMP)
    $(PLACE)

$(O)\sysfiles.inf: $(_INX)\sysfiles.inx $(_LNG)\sysfiles.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(APPTYPE)
    @del $(O)\$(@B).tmp
    $(STAMP)
    $(PLACE)

$(O)\migwiz.inf: $(_INX)\migwiz.inx $(_LNG)\migwiz.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(APPTYPE)
    @del $(O)\$(@B).tmp
    $(STAMP)
    $(PLACE)

$(O)\migsys.inf: $(_INX)\migsys.inx $(_LNG)\migsys.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(APPTYPE)
    @del $(O)\$(@B).tmp
    $(STAMP)
    $(PLACE)

$(O)\miguser.inf: $(_INX)\miguser.inx $(_LNG)\miguser.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(APPTYPE)
    @del $(O)\$(@B).tmp
    $(STAMP)
    $(PLACE)

$(O)\migapp.inf: $(_INX)\migapp.inx $(_LNG)\migapp.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(APPTYPE)
    @del $(O)\$(@B).tmp
    $(STAMP)
    $(PLACE)

$(O)\migwiz.htm: $(_INX)\migwiz.htm
    copy $(_INX)\$(@B).htm $(O)\$(@B).htm
    $(PLACE)

$(O)\migwiz2.htm: $(_INX)\migwiz2.htm
    copy $(_INX)\$(@B).htm $(O)\$(@B).htm
    $(PLACE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\changes\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\dbedit\datalist.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    datalist.c

Abstract:

    functions handling the operation of the listview
    that displays key data in memdbe.exe

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:



--*/

#include "pch.h"

#include "dbeditp.h"
#include <commdlg.h>


HWND g_hListData;

#define LISTITEMTEXT_MAX            1024

#define LINEHEADER_VALUE            "VALUE"
#define LINEHEADER_FLAGS            "FLAGS"
#define LINEHEADER_BINARY           "BINARY"
#define LINEHEADER_SINGLE_LINKAGE   "SINGLE LINKAGE"
#define LINEHEADER_DOUBLE_LINKAGE   "DOUBLE LINKAGE"


BOOL
IsDataList (
    HWND hwnd
    )
{
    return (hwnd == g_hListData);
}


BOOL
pIsDataLine (
    BYTE DataFlag,
    PSTR Line
    )
{
    CHAR LineCmp[16];
    switch (DataFlag) {
    case DATAFLAG_VALUE:
        StringCopyA (LineCmp, LINEHEADER_VALUE);
        break;
    case DATAFLAG_FLAGS:
        StringCopyA (LineCmp, LINEHEADER_FLAGS);
        break;
    case DATAFLAG_UNORDERED:
        StringCopyA (LineCmp, LINEHEADER_BINARY);
        break;
    case DATAFLAG_SINGLELINK:
        StringCopyA (LineCmp, LINEHEADER_SINGLE_LINKAGE);
        break;
    case DATAFLAG_DOUBLELINK:
        StringCopyA (LineCmp, LINEHEADER_DOUBLE_LINKAGE);
        break;
    default:
        return FALSE;
    }

    return StringMatchCharCountA (LineCmp, Line, CharCountA (LineCmp));
}



BOOL
DataListInit (
    HWND hdlg
    )
{
    g_hListData = GetDlgItem (hdlg, IDC_LIST_DATA);
    return TRUE;
}


BOOL
DataListClear (
    VOID
    )
{
    if (!ListView_DeleteAllItems (g_hListData)) {
        DEBUGMSG ((DBG_ERROR, "Could not clear List View!"));
        return FALSE;
    }

    return TRUE;
}

BOOL
DataListRefresh (
    VOID
    )
{
    if (!DataListClear ()) {
        return FALSE;
    }
    return TRUE;
}




INT
pDataListAddString (
    PSTR Str,
    LPARAM lParam
    )
{
    INT Index;
    LVITEM ListItem;

    ListItem.mask = LVIF_TEXT | LVIF_PARAM ;
    ListItem.pszText = Str;
    ListItem.iSubItem = 0;
    ListItem.lParam = lParam;

    ListItem.iItem = ListView_GetItemCount (g_hListData);

    Index = ListView_InsertItem (g_hListData, &ListItem);
    if (Index < 0) {
        DEBUGMSG ((DBG_ERROR, "Could not add list item!"));
    }
    return Index;
}


INT
DataListAddData (
    BYTE DataFlag,
    UINT DataValue,
    PBYTE DataPtr
    )
{
    INT i;
    PSTR Ptr;
    LPARAM lParam = 0;
    CHAR ListItemText[LISTITEMTEXT_MAX];

    switch (DataFlag) {
    case DATAFLAG_VALUE:
        sprintf (ListItemText, "%s: 0x%08lX", LINEHEADER_VALUE, DataValue);
        break;
    case DATAFLAG_FLAGS:
        sprintf (ListItemText, "%s: 0x%08lX", LINEHEADER_FLAGS, DataValue);
        break;
    case DATAFLAG_UNORDERED:
        sprintf (ListItemText, "%s: \"", LINEHEADER_BINARY);
        Ptr = GetEndOfStringA (ListItemText);

        for (i=0;i<(INT)(DataValue) && i<LISTITEMTEXT_MAX-2;i++) {
            *(Ptr++) = isprint(DataPtr[i]) ? DataPtr[i] : '.';
        }
        *(Ptr++) = '\"';
        *Ptr = 0;
        ListItemText[LISTITEMTEXT_MAX] = 0;
        break;

    case DATAFLAG_SINGLELINK:
        sprintf (ListItemText, "%s: %s", LINEHEADER_SINGLE_LINKAGE, (PSTR)DataPtr);
        lParam = DataValue;
        break;

    case DATAFLAG_DOUBLELINK:
        sprintf (ListItemText, "%s: %s", LINEHEADER_DOUBLE_LINKAGE, (PSTR)DataPtr);
        lParam = DataValue;
        break;

    }

    return pDataListAddString (ListItemText, lParam);
}



BOOL
DataListRightClick (
    HWND hdlg,
    POINT pt
    )
{
    HMENU hMenu;
    RECT rect;
    if (!(hMenu = LoadMenu (g_hInst, MAKEINTRESOURCE(IDR_MENU_POPUP))) ||
        (!(hMenu = GetSubMenu (hMenu, MENUINDEX_POPUP_KEY))) ||
        (!(hMenu = GetSubMenu (hMenu, MENUINDEX_POPUP_KEY_ADDDATA)))
        ) {
        return FALSE;
    }

    if (!GetWindowRect (g_hListData, &rect)) {
        return FALSE;
    }

    if (!TrackPopupMenu (hMenu, TPM_LEFTALIGN, pt.x+rect.left, pt.y+rect.top, 0, hdlg, NULL)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
DataListDblClick (
    HWND hdlg,
    INT iItem,
    INT iSubItem
    )
{
    CHAR ListItemText[LISTITEMTEXT_MAX];
    LVITEM Item;

    if (iItem<0) {
        return FALSE;
    }

    Item.mask = LVIF_TEXT | LVIF_PARAM;
    Item.iItem = iItem;
    Item.iSubItem = iSubItem;
    Item.pszText = ListItemText;
    Item.cchTextMax = LISTITEMTEXT_MAX;

    if (!ListView_GetItem (g_hListData, &Item)) {
        return FALSE;
    }

    if (pIsDataLine (DATAFLAG_SINGLELINK, ListItemText)) {
        SendMessage (hdlg, WM_SELECT_KEY, Item.lParam, 0);
        return TRUE;
    }

    if (pIsDataLine (DATAFLAG_DOUBLELINK, ListItemText)) {
        SendMessage (hdlg, WM_SELECT_KEY, Item.lParam, 0);
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\changes\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    <TODO: fill in abstract>

Author:

    TODO: <full name> (<alias>) <date>

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include "wininet.h"
#include <lm.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;
GROWLIST g_WindiffCmds = INIT_GROWLIST;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        UtInitialize (NULL);
        break;
    case DLL_PROCESS_DETACH:
        UtTerminate ();
        break;
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        //
        // TODO: Describe command line syntax(es), indent 2 spaces
        //

        "  changes <changenumber>\n"

        "\nDescription:\n\n"

        //
        // TODO: Describe tool, indent 2 spaces
        //

        "  changes.exe executes sd describe and windiff for a specific change.\n"

        "\nArguments:\n\n"

        //
        // TODO: Describe args, indent 2 spaces, say optional if necessary
        //

        "  <changenumber>   Specifies the Source Depot change number\n"

        );

    exit (1);
}


BOOL
pGetNextLine (
    IN      PCSTR Start,
    IN      PCSTR Eof,
    OUT     PCSTR *PrintableStart,
    OUT     PCSTR *End,
    OUT     PCSTR *NextLine
    )
{
    PCSTR pos;

    pos = Start;
    *End = NULL;

    while (pos < Eof) {
        if (pos[0] != ' ' && pos[0] != '\t') {
            break;
        }
        pos++;
    }

    *PrintableStart = pos;

    while (pos < Eof) {
        if (pos[0] == '\r' || pos[0] == '\n') {
            break;
        }
        pos++;
    }

    *End = pos;

    if (pos < Eof && pos[0] == '\r') {
        pos++;
    }
    if (pos < Eof && pos[0] == '\n') {
        pos++;
    }
    *NextLine = pos;

    return Start != *NextLine;
}

PCSTR
pFindNextCharAB (
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      CHAR FindChar
    )
{
    if (!Start) {
        return NULL;
    }

    while (Start < End) {
        if (*Start == FindChar) {
            return Start;
        }

        Start++;
    }

    return NULL;
}


BOOL
pParseViewLines (
    IN OUT  PCSTR *FilePos,
    IN      PCSTR Eof,
    IN      PCSTR Root,
    IN      PMAPSTRUCT Map
    )
{
    UINT count = 0;
    PCSTR pos;
    PCSTR nextPos;
    PSTR prefix;
    PCSTR prefixEnd;
    PSTR subDir;
    PCSTR localPath;
    PCSTR clientPathStart;
    PCSTR clientPathEnd;
    PSTR p;
    PCSTR lineStart;
    PCSTR lineEnd;

    pos = *FilePos;

    while (pGetNextLine (pos, Eof, &lineStart, &lineEnd, &nextPos)) {
        if (pos == lineStart) {
            break;
        }

        //
        // Find depot prefix
        //

        prefixEnd = lineStart;
        for (;;) {
            prefixEnd = pFindNextCharAB (prefixEnd, lineEnd, '.');
            if (!prefixEnd) {
                break;
            }

            if (prefixEnd[1] == '.' && prefixEnd[2] == '.' &&
                isspace(prefixEnd[3]) &&
                prefixEnd[4] == '/' && prefixEnd[5] == '/'
                ) {
                break;
            }

            prefixEnd++;
        }

        if (!prefixEnd || prefixEnd == lineStart) {
            break;
        }

        //
        // Find client path
        //

        clientPathStart = pFindNextCharAB (prefixEnd + 6, lineEnd, '/');
        if (!clientPathStart) {
            break;
        }

        clientPathStart++;

        clientPathEnd = clientPathStart;
        for (;;) {
            clientPathEnd = pFindNextCharAB (clientPathEnd, lineEnd, '.');
            if (!clientPathEnd) {
                break;
            }

            if (clientPathEnd[1] == '.' && clientPathEnd[2] == '.' &&
                clientPathEnd + 3 == lineEnd
                ) {
                break;
            }

            clientPathEnd++;
        }

        if (!clientPathEnd) {
            break;
        }

        if (clientPathEnd > clientPathStart) {
            clientPathEnd--;    // account for last slash
        }

        //
        // Clean the strings and add to mapping
        //

        prefix = AllocText (prefixEnd - lineStart);
        StringCopyAB (prefix, lineStart, prefixEnd);

        subDir = AllocText ((clientPathEnd - clientPathStart) + 1);
        if (clientPathEnd > clientPathStart) {
            StringCopyAB (subDir, clientPathStart, clientPathEnd);
        }

        p = strchr (subDir, '/');
        while (p) {
            *p++ = '\\';
            p = strchr (p, '/');
        }

        AppendWack (subDir);

        localPath = JoinPaths (Root, subDir);

        AddStringMappingPair (Map, prefix, localPath);

        FreeText (prefix);
        FreeText (subDir);
        FreePathString (localPath);

        count++;

        pos = nextPos;
    }


    *FilePos = pos;

    return count > 0;
}

BOOL
pParseClientMapping (
    IN      PCSTR SdClientOutput,
    IN      PCSTR Eof,
    OUT     PSTR RootPath,
    IN      PMAPSTRUCT Map
    )
{
    PCSTR lineStart;
    PCSTR lineEnd;
    PCSTR pos;
    PSTR dup;
    PCSTR root;
    BOOL viewFound = FALSE;

    //
    // Find Root: or View:
    //

    pos = SdClientOutput;
    *RootPath = 0;

    while (pGetNextLine (pos, Eof, &lineStart, &lineEnd, &pos)) {
        if (lineStart == lineEnd) {
            continue;
        }

        if (*lineStart == '#') {
            continue;
        }

        dup = AllocText (lineEnd - lineStart);
        StringCopyAB (dup, lineStart, lineEnd);

        if (StringIPrefix (dup, "Root:")) {
            root = dup + 5;
            while (isspace (*root)) {
                root++;
            }

            StringCopy (RootPath, root);

        } else if (StringIPrefix (dup, "View:")) {
            if (!(*RootPath)) {
                break;
            }

            viewFound = pParseViewLines (&pos, Eof, RootPath, Map);
        }

        FreeText (dup);
        dup = NULL;
    }

    FreeText (dup);

    return *RootPath && viewFound;
}


BOOL
pParseChangeList (
    IN      PCSTR SdDescribeOutput,
    IN      PCSTR Eof,
    IN      PMAPSTRUCT Map
    )
{
    PCSTR lineStart;
    PCSTR lineEnd;
    PCSTR pos;
    PCSTR nextPos;
    PSTR dup;
    BOOL result = FALSE;
    PSTR p;
    UINT num;
    CHAR bigBuf[2048];
    PSTR change;
    CHAR cmdLine[2048];

    //
    // Find the line Affected files
    //

    pos = SdDescribeOutput;
    printf ("\n\n");

    while (pGetNextLine (pos, Eof, &lineStart, &lineEnd, &nextPos)) {
        if (lineEnd > lineStart &&
            StringMatchAB ("Affected files ...", lineStart, lineEnd)
            ) {
            result = TRUE;
            break;
        }

        dup = AllocText ((lineEnd - pos) + 1);

        if (lineEnd > pos) {
            StringCopyAB (dup, pos, lineEnd);
        }

        printf ("%s\n", dup);
        FreeText (dup);

        pos = nextPos;
    }

    if (result) {
        //
        // Files listed in output
        //

        while (pGetNextLine (pos, Eof, &lineStart, &lineEnd, &nextPos)) {
            pos = nextPos;

            if (lineStart[0] != '.') {
                continue;
            }

            lineStart += 4;
            if (lineStart > lineEnd) {
                continue;
            }

            //
            // Translate depot path into local path
            //

            StringCopyAB (bigBuf, lineStart, lineEnd);

            p = strrchr (bigBuf, '#');
            if (!p) {
                continue;
            }

            *p = 0;
            num = strtoul (p + 1, &change, 10);

            while (isspace (*change)) {
                change++;
            }

            MappingSearchAndReplace (Map, bigBuf, ARRAYSIZE(bigBuf));

            p = strchr (bigBuf, '/');
            while (p) {
                *p++ = '\\';
                p = strchr (p, '/');
            }

            if (StringIMatch (change, "edit") && num > 1) {
                wsprintf (cmdLine, "windiff.exe %s#%u %s#%u", bigBuf, num - 1, bigBuf, num);
                GlAppendString (&g_WindiffCmds, cmdLine);
            }

            printf ("%s: %s#%u\n", change, bigBuf, num);

        }
    }

    return GlGetSize (&g_WindiffCmds) > 0;
}


BOOL
pLaunchSd (
    IN      PSTR CmdLine,
    IN      HANDLE TempFile,
    IN      PCSTR Msg,
    OUT     HANDLE *Mapping,
    OUT     PCSTR *FileContent,
    OUT     PCSTR *Eof
    )
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    LONG rc;

    SetFilePointer (TempFile, 0, NULL, FILE_BEGIN);
    SetEndOfFile (TempFile);

    ZeroMemory (&si, sizeof (si));

    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput = GetStdHandle (STD_INPUT_HANDLE);

    if (!DuplicateHandle (
            GetCurrentProcess(),
            TempFile,
            GetCurrentProcess(),
            &si.hStdOutput,
            0,
            TRUE,
            DUPLICATE_SAME_ACCESS
            )) {
        printf ("Can't dup temp file handle\n");
        return FALSE;
    }

    si.hStdError = GetStdHandle (STD_ERROR_HANDLE);

    if (!CreateProcess (
            NULL,
            CmdLine,
            NULL,
            NULL,
            TRUE,
            0,
            NULL,
            NULL,
            &si,
            &pi
            )) {
        printf ("Can't launch sd describe\n");
        CloseHandle (si.hStdOutput);
        return FALSE;
    }

    printf ("%s", Msg);
    rc = WaitForSingleObject (pi.hProcess, INFINITE);
    printf ("\n");

    CloseHandle (pi.hProcess);
    CloseHandle (pi.hThread);
    CloseHandle (si.hStdOutput);

    if (rc != WAIT_OBJECT_0) {
        return FALSE;
    }

    if (!GetFileSize (TempFile, NULL)) {
        return FALSE;
    }

    *Mapping = CreateFileMapping (TempFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!(*Mapping)) {
        printf ("Can't map temp file into memory\n");
        return FALSE;
    }

    *FileContent = (PCSTR) MapViewOfFile (*Mapping, FILE_MAP_READ, 0, 0, 0);
    if (!*FileContent) {
        printf ("Can't map temp file data into memory\n");
        CloseHandle (*Mapping);
        return FALSE;
    }

    *Eof = *FileContent + GetFileSize (TempFile, NULL);

    return TRUE;
}


BOOL
pLaunchWindiff (
    IN      PCSTR CmdLine
    )
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    LONG rc;
    PSTR writableCmdLine = DuplicateText (CmdLine);

    ZeroMemory (&si, sizeof (si));

    if (!CreateProcess (
            NULL,
            writableCmdLine,
            NULL,
            NULL,
            TRUE,
            0,
            NULL,
            NULL,
            &si,
            &pi
            )) {
        FreeText (writableCmdLine);
        printf ("Can't launch %s\n", CmdLine);
        return FALSE;
    }

    FreeText (writableCmdLine);

    rc = WaitForSingleObject (pi.hProcess, INFINITE);

    CloseHandle (pi.hProcess);
    CloseHandle (pi.hThread);

    return TRUE;
}



INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    UINT change = 0;
    UINT u;
    UINT count;

    //
    // TODO: Parse command line here
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            HelpAndExit();
        } else {
            //
            // Parse other args that don't require / or -
            //

            if (change) {
                HelpAndExit();
            }

            change = _tcstoul (argv[i], NULL, 10);
            if (!change) {
                HelpAndExit();
            }
        }
    }

    if (!change) {
        HelpAndExit();
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    //
    // TODO: Do work here
    //
    {
        TCHAR cmd[MAX_PATH];
        HANDLE tempFile;
        HANDLE mapping;
        PCSTR fileData;
        PCSTR endOfFile;
        BOOL runWinDiff = FALSE;
        CHAR root[MAX_PATH];
        PMAPSTRUCT map;

        tempFile = BfGetTempFile ();
        map = CreateStringMapping();

        if (!tempFile) {
            printf ("Can't create temp file\n");
            exit (1);
        }

        if (!pLaunchSd ("sd client -o", tempFile, "Getting client mapping...", &mapping, &fileData, &endOfFile)) {
            exit (1);
        }

        pParseClientMapping (fileData, endOfFile, root, map);

        wsprintf (cmd, TEXT("sd describe -s %u"), change);
        if (!pLaunchSd (cmd, tempFile, "Getting change list...", &mapping, &fileData, &endOfFile)) {
            exit (1);
        }

        runWinDiff = pParseChangeList (fileData, endOfFile, map);

        UnmapViewOfFile (fileData);
        CloseHandle (mapping);

        DestroyStringMapping (map);
        CloseHandle (tempFile);

        if (runWinDiff) {
            count = GlGetSize (&g_WindiffCmds);

            for (u = 0 ; u < count ; u++) {
                if (!pLaunchWindiff (GlGetString (&g_WindiffCmds, u))) {
                    break;
                }
            }

        }

        GlFree (&g_WindiffCmds);

    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\dbedit\dbeditp.h ===
#include "resource.h"

#define INVALID_KEY_HANDLE          0

extern HINSTANCE g_hInst;


#define WM_FILE_LOAD                (WM_APP + 1)
#define WM_FILE_UPDATE              (WM_APP + 2)
#define WM_QUIT_CHECK               (WM_APP + 3)
#define WM_SELECT_KEY               (WM_APP + 4)


#define MENUINDEX_POPUP_KEY             0
#define MENUINDEX_POPUP_KEY_ADDDATA     0
#define MENUINDEX_MAIN_FILE             0
#define MENUINDEX_MAIN_KEY              1


PSTR
GetPieceOfKey (
    PSTR KeyPtr,
    PSTR PieceBuf
    );


VOID
KeyAddClear (
    VOID
    );

HTREEITEM
KeyAddItem (
    PSTR ItemName,
    HTREEITEM Parent,
    UINT Index
    );


VOID
KeyAddSetFilterPattern (
    PSTR Pattern
    );


BOOL
KeyAddSubLevels (
    HTREEITEM ParentItem
    );



HTREEITEM
KeyAddCreateItem (
    PSTR Key
    );


BOOL
KeyAddCreateChildItem (
    HWND hdlg,
    HTREEITEM hItem
    );





BOOL
IsKeyTree (
    HWND hwnd
    );


BOOL
KeyTreeInit (
    HWND hParent
    );

VOID
KeyTreeDestroy (
    VOID
    );

BOOL
KeyTreeClear (
    VOID
    );

BOOL
KeyTreeRefresh (
    VOID
    );



BOOL
KeyTreeSetIndexOfItem (
    HTREEITEM hItem,
    UINT Index
    );

UINT
KeyTreeGetIndexOfItem (
    HTREEITEM hItem
    );

BOOL
KeyTreeGetNameOfItem (
    HTREEITEM hItem,
    PSTR Buffer
    );






VOID
KeyTreeSelectItem (
    HTREEITEM hItem
    );

VOID
KeyTreeSelectKey (
    UINT Index
    );

VOID
KeyTreeSelectRClickItem (
    VOID
    );


HTREEITEM
KeyTreeSelChanged (
    HWND hdlg,
    LPNMTREEVIEW pnmtv
    );



BOOL
KeyTreeBeginDrag (
    HWND hWnd,
    LPNMTREEVIEW pnmtv
    );


BOOL
KeyTreeMoveDrag (
    POINTS pt
    );


BOOL
KeyTreeEndDrag (
    BOOL TakeAction,
    POINTS *pt
    );







BOOL
KeyTreeRenameItem (
    HTREEITEM hItem,
    LPSTR Name
    );


BOOL
KeyTreeDeleteKey (
    HTREEITEM hItem
    );

BOOL
KeyTreeDeleteItem (
    HTREEITEM hItem
    );




VOID
KeyTreeExpandItem (
    HTREEITEM hItem,
    BOOL Expand,
    BOOL Recurse
    );




BOOL
KeyTreeRightClick (
    HWND hdlg,
    HTREEITEM hItem
    );

BOOL
KeyTreeForceEditLabel (
    HTREEITEM hItem
    );




BOOL
KeyTreeCreateItem (
    HWND hdlg
    );

BOOL
KeyTreeCreateChildItem (
    HWND hdlg,
    HTREEITEM hItem
    );


HTREEITEM
KeyTreeFindChildItem (
    HTREEITEM hItem,
    PSTR Str
    );

BOOL
KeyTreeFindNext (
    VOID
    );

BOOL
KeyTreeFind (
    HWND hdlg
    );




BOOL
KeyTreeCreateEmptyKey (
    HTREEITEM hItem
    );


BOOL
KeyTreeAddShortData (
    HWND hwnd,
    HTREEITEM hItem,
    BYTE DataFlag
    );

BOOL
KeyTreeClearData (
    HTREEITEM hItem
    );


VOID
KeyTreeSetFilterPattern (
    PSTR Pattern
    );

BOOL
KeyTreeCreateLinkage (
    HWND hdlg,
    HTREEITEM hItem,
    BOOL SingleLinkage,
    BYTE Instance
    );






BOOL
IsDataList (
    HWND hwnd
    );


BOOL
DataListInit (
    HWND hdlg
    );


BOOL
DataListClear (
    VOID
    );

BOOL
DataListRefresh (
    VOID
    );





INT
DataListAddData (
    BYTE DataFlag,
    UINT DataValue,
    PBYTE DataPtr
    );

BOOL
DataListRightClick (
    HWND hdlg,
    POINT pt
    );

BOOL
DataListDblClick (
    HWND hdlg,
    INT iItem,
    INT iSubItem
    );


BOOL
CALLBACK
MainDlgProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
WantProcess (
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
InitializeMemDb (
    HWND hWnd
    );

BOOL
DestroyMemDb (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\dbedit\keyadd.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    keytree.c

Abstract:

    functions handling the operation of the treeview
    that displays the keys in a memdb tree in memdbe.exe

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:



--*/

#include "pch.h"

#include "dbeditp.h"

//
// controls in display
//
extern HWND g_hTreeKey;

//
// when we put items in the treeview, instead of just inserting
// them, we create a growlist which we fill with relevant data.
// then we go through that and filter if necessary, and then
// we put the remaining stuff in the tree.
//
INT g_LastItem = -1;
CHAR g_LastItemName[MEMDB_MAX] = "";
GROWLIST g_AddList = INIT_GROWLIST;
typedef struct {
    INT ParentListIndex;
    UINT KeyIndex;
    HTREEITEM TreeItem;
    BYTE Flags;
    CHAR Name[];
} ADDLISTITEM, *PADDLISTITEM;

#define ADDLISTFLAG_ENDPOINT    0x01
#define ADDLISTFLAG_KEEP        0x02


extern BOOL g_ParsePaths = TRUE;

CHAR g_KeyPiece[MEMDB_MAX] = "";

CHAR g_FilterPattern[MEMDB_MAX] = "";






//
// functions we need from keytree.c
//
extern BOOL
KeyTreeGetNameOfItem (
    HTREEITEM hItem,
    PSTR Buffer
    );

extern HTREEITEM
KeyTreeFindChildItem (
    HTREEITEM hItem,
    PSTR Str
    );



#define ISDRIVELETTER(Str) ((Str) && (Str)[1]==':' && ((Str)[2]=='\0' || (Str)[2]=='\\'))

PSTR
GetPieceOfKey (
    PSTR KeyPtr,
    PSTR PieceBuf
    )
{
    PSTR Cur;
    if (!KeyPtr || (*KeyPtr=='\0') || (*KeyPtr=='\\')) {
        return NULL;
    }

    while ((*KeyPtr!='\0') && (*KeyPtr!='\\')) {
        *(PieceBuf++) = *(KeyPtr++);
    }

    *PieceBuf = '\0';
    if (*KeyPtr == '\\') {
        KeyPtr++;
    }

    return KeyPtr;
}


HTREEITEM
pKeyAddEnumFirstChild (
    HTREEITEM hParent
    )
{
    if (hParent == NULL) {
        return TreeView_GetRoot (g_hTreeKey);
    }
    return TreeView_GetChild (g_hTreeKey, hParent);
}

HTREEITEM
pKeyAddEnumNextChild (
    HTREEITEM hPrevChild
    )
{
    return TreeView_GetNextSibling (g_hTreeKey, hPrevChild);
}





VOID
KeyAddClear (
    VOID
    )
{
    g_LastItem = -1;
    g_LastItemName[0] = '\0';
}


HTREEITEM
KeyAddItem (
    PSTR ItemName,
    HTREEITEM Parent,
    KEYHANDLE Index
    )
{
    HTREEITEM Item;
    TVINSERTSTRUCT tvis;
    tvis.hParent = Parent;
    tvis.hInsertAfter = TVI_LAST;
    tvis.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvis.item.pszText = ItemName;
    tvis.item.iImage = 0;
    tvis.item.iSelectedImage = 1;
    tvis.item.lParam = Index;

    Item = TreeView_InsertItem (g_hTreeKey, &tvis);
    return Item;
}




INT
pKeyAddItemToList (
    PSTR ItemName,
    INT ParentListIndex,
    KEYHANDLE Index,
    BOOL EndPoint
    )
{
    PADDLISTITEM pItem;
    ADDLISTITEM ali;

    ali.TreeItem = NULL;
    ali.KeyIndex = Index;
    ali.ParentListIndex = ParentListIndex;
    ali.Flags = EndPoint ? ADDLISTFLAG_ENDPOINT : 0;

    if (!(pItem = (PADDLISTITEM) GlAppend (
        &g_AddList,
        (PBYTE)&ali,
        sizeof(ADDLISTITEM) + CharCountA (ItemName) + 1
        )))
    {
        DEBUGMSG ((DBG_ERROR, "Could not add item because GrowListAppend failed"));
        return -1;
    }

    StringCopyA (pItem->Name, ItemName);
    return GlGetSize (&g_AddList) - 1;
}


INT
pKeyAddKeyToList (
    PSTR Name,
    KEYHANDLE Index,
    BOOL EndPoint
    )
{
    PADDLISTITEM ali;
    INT Len;
    PSTR Next, NameLeft;
    INT ItemIndex;

    NameLeft = Name;

    while (g_LastItem >= 0) {
        Len = CharCountA (g_LastItemName);

        if (StringIMatchCharCountA (g_LastItemName, Name, Len) && (Name[Len]=='\\')) {
            //
            // we have found the parent of the new item
            //
            NameLeft = Name + Len + 1;
            break;
        }

        ali = (PADDLISTITEM) GlGetItem (&g_AddList, g_LastItem);
        if (((g_LastItem = ali->ParentListIndex) < 0) ||
            !(Next = _mbsrchr (g_LastItemName, '\\')))
        {
            g_LastItem = -1;
            g_LastItemName[0] = '\0';
            NameLeft = Name;
            break;
        }

        *Next = '\0';
    }

    if (ISDRIVELETTER (NameLeft) && g_ParsePaths)
    {
        if (EndPoint) {
            return pKeyAddItemToList (NameLeft, g_LastItem, Index, TRUE);
        } else {
            return -1;
        }
    }

    ItemIndex = pKeyAddItemToList (NameLeft, g_LastItem, Index, EndPoint);
    if (g_LastItem >= 0) {
        StringCatA (g_LastItemName, "\\");
        StringCatA (g_LastItemName, NameLeft);
    } else {
        StringCopyA (g_LastItemName, NameLeft);
    }
    g_LastItem = ItemIndex;
    return ItemIndex;
}


VOID
pKeyAddKeepListIndex (
    INT Index
    )
{
    PADDLISTITEM ali;

    if (Index < 0) {
        return;
    }
    ali = (PADDLISTITEM) GlGetItem (&g_AddList, Index);
    ali->Flags |= ADDLISTFLAG_KEEP;

    //
    // recurse up tree, marking all parent index items to keep them.
    //
    pKeyAddKeepListIndex (ali->ParentListIndex);
}

BOOL
pKeyAddApplyFilterToList (
    VOID
    )
{
    PCTSTR key;
    INT i, count;
    PADDLISTITEM ali;
    PPARSEDPATTERN parsedPattern;

    if (g_FilterPattern[0] == 0) {
        return TRUE;
    }

    parsedPattern = CreateParsedPattern (g_FilterPattern);

    count = GlGetSize (&g_AddList);

    for (i=0; i < count; i++) {

        ali = (PADDLISTITEM) GlGetItem (&g_AddList, i);
        if (ali->Flags & ADDLISTFLAG_ENDPOINT) {
            key = MemDbGetKeyFromHandle (ali->KeyIndex, 0);

            if (key) {
                if (TestParsedPattern (parsedPattern, key)) {
                    //
                    // we have found an endpoint that matches the pattern, so
                    // mark it and all its parents to keep them.
                    //
                    pKeyAddKeepListIndex (i);
                }

                MemDbReleaseMemory (key);
            }
        }
    }

    DestroyParsedPattern (parsedPattern);

    return TRUE;
}


BOOL
pKeyAddList (
    VOID
    )
{
    PADDLISTITEM ali, temp;
    HTREEITEM hParent;
    INT i, count;
    BOOL NoFilter;

    count = GlGetSize (&g_AddList);

    NoFilter = (g_FilterPattern[0] == '\0');

    for (i=0; i<count; i++) {

        ali = (PADDLISTITEM) GlGetItem (&g_AddList, i);
        if (ali->ParentListIndex >= 0) {
            //
            // get the index of the additem that is the parent of this
            // item, and then get the treeitem handle from that.
            //
            temp = (PADDLISTITEM) GlGetItem (&g_AddList, ali->ParentListIndex);
            hParent = temp->TreeItem;
        } else {
            hParent = NULL;
        }

        if (NoFilter || (ali->Flags & ADDLISTFLAG_KEEP)) {
            if (!(ali->TreeItem = KeyAddItem (ali->Name, hParent, ali->KeyIndex))) {
                DEBUGMSG ((DBG_ERROR, "Could not add item!"));
                return FALSE;
            }
        }
    }

    return TRUE;
}



BOOL
KeyAddSubLevels (
    HTREEITEM ParentItem
    )
{
    HTREEITEM hItem;
    MEMDB_ENUM e;
    TCHAR Key[MEMDB_MAX];

    g_LastItem = -1;

    ZeroMemory (&g_AddList, sizeof (g_AddList));

    if (ParentItem) {
        KeyTreeGetNameOfItem (ParentItem, Key);
        StringCat (Key, TEXT("\\*"));
    } else {
        StringCopy (Key, TEXT("*"));
    }

    if (MemDbEnumFirst (&e, Key, ENUMFLAG_ALL, 0, ENUMLEVEL_ALLLEVELS)) {
        do {
            pKeyAddKeyToList (e.FullKeyName, e.KeyHandle, e.EndPoint);

        } while (MemDbEnumNext (&e));
    }

    pKeyAddApplyFilterToList ();
    pKeyAddList ();

    GlFree (&g_AddList);
    ZeroMemory (&g_AddList, sizeof (g_AddList));

    return TRUE;
}



VOID
KeyAddSetFilterPattern (
    PSTR Pattern
    )
{
    if (Pattern) {
        StringCopyA (g_FilterPattern, Pattern);
    } else {
        g_FilterPattern[0] = '\0';
    }
}












HTREEITEM
KeyAddCreateItem (
    PSTR Key
    )
{
    BOOL Created = FALSE;
    CHAR NewKey[MEMDB_MAX];
    PSTR Next, End;
    KEYHANDLE Index;
    HTREEITEM hParent = NULL, hItem;

    NewKey[0] = '\0';

    while (Next = GetPieceOfKey (Key, g_KeyPiece)) {

        if (NewKey[0] != '\0') {
            StringCatA (NewKey, "\\");
        }
        StringCat (NewKey, g_KeyPiece);

        if (!(hItem = KeyTreeFindChildItem (hParent, g_KeyPiece))) {

            Created = TRUE;

            if (Next) {
                Index = MemDbAddKey (NewKey);
                if (!Index) {
                    return NULL;
                }
            } else {
                Index = MemDbAddKey (NewKey);
                if (!Index) {
                    return NULL;
                }
            }

            if (!(hItem = KeyAddItem (g_KeyPiece, hParent, Index))) {
                return NULL;
            }
        }

        hParent = hItem;
        Key = Next;
    }

    if (!Created) {
        MessageBox (NULL, "Key already exists", "MemDb Editor", MB_OK|MB_ICONEXCLAMATION);
    }

    return hParent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\dbedit\dialogs.h ===
VOID
AboutDialog (
    HWND hwnd
    );

BOOL
KeyFindDialog (
    HWND hwnd,
    PSTR StringBuffer,
    PBOOL UsePattern
    );

BOOL
ShortDataDialog (
    HWND hwnd,
    BYTE DataFlag,
    PDWORD DataValue,
    PBOOL AddData,
    PBYTE Instance
    );

BOOL
LinkageDialog (
    HWND hwnd,
    PSTR Key1,
    PSTR Key2
    );


BOOL
CreateKeyDialog (
    HWND hwnd,
    PSTR KeyName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\dbedit\dbedit.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    memdbe.c

Abstract:

    main file for memdbe.exe, containing winmain().
    this creates the application framework, and then
    the child window dialog which has the controls and
    displays.

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:



--*/

#include "pch.h"

#include "dbeditp.h"
#include "dialogs.h"

#define MAX_LOADSTRING 100

HWND g_hChildWindow = NULL;
HMENU g_hMenuMain;

#define DEFAULT_WINDOW_TITLE    "MemDb Editor"

#define DEFAULT_FILENAME        "ntsetup.dat"

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);



VOID
HelpAndExit (
    VOID
    )
{
    MessageBox (
        NULL,
        "Command Line Syntax:\n\n"
            "\tmemdbe [database file]\n"
            "\n"
            "If no database file is specified, \"ntsetup.dat\" is opened if it exists.",
        "MemDb Editor",
        MB_OK|MB_ICONINFORMATION
        );

    exit(1);
}


int WINAPI WinMain (
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpPtr,
    int nCmdShow
    )
{
    HACCEL hAccel;
    static char AppName[] = "MemDbEdit";
    MSG msg;
    HWND hwnd;
    WNDCLASSEX wndclass;
    RECT DialogRect;

    g_hInst = hInstance;

    wndclass.cbSize = sizeof(wndclass);
    wndclass.style = CS_HREDRAW|CS_VREDRAW;
    wndclass.lpfnWndProc = WndProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon (NULL, MAKEINTRESOURCE(IDI_ICON_SPHERE));
    wndclass.hCursor = LoadCursor (NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = AppName;
    wndclass.hIconSm = NULL;
    //LoadIcon (NULL, MAKEINTRESOURCE(IDI_ICON1));

    RegisterClassEx (&wndclass);

    hwnd = CreateWindow (
        AppName,
        DEFAULT_WINDOW_TITLE,
        WS_OVERLAPPEDWINDOW & (~WS_MAXIMIZEBOX) & (~WS_THICKFRAME),
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        hInstance,
        lpPtr
        );

    ShowWindow (hwnd, nCmdShow);
    UpdateWindow (hwnd);

    hAccel = LoadAccelerators (hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR));

    // Main message loop:
    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!TranslateAccelerator (hwnd, hAccel, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return msg.wParam;
}


VOID
pInitializeSystemMenu (
    HWND hwnd
    )
{
    HMENU hMenu;

    hMenu = GetSystemMenu (hwnd, FALSE);
    RemoveMenu (hMenu, SC_MAXIMIZE, MF_BYCOMMAND);
    RemoveMenu (hMenu, SC_SIZE, MF_BYCOMMAND);

}



BOOL
pInitializeWindows (
    HWND hwnd
    )
{
    RECT rect, rect2;

    g_hMenuMain = LoadMenu (g_hInst, MAKEINTRESOURCE(IDR_MENU_MAIN));
    SetMenu (hwnd, g_hMenuMain);

    g_hChildWindow = CreateDialog (
                        g_hInst,
                        MAKEINTRESOURCE(IDD_DIALOG_CHILD),
                        hwnd,
                        MainDlgProc
                        );

    if (!g_hChildWindow) {
        DEBUGMSG ((DBG_ERROR, "Could not create child window!"));
    }

    GetWindowRect(hwnd, &rect);
    GetWindowRect(g_hChildWindow, &rect2);

    MoveWindow (
        hwnd,
        rect.left,
        rect.top,
        (rect2.right-rect2.left) + 2*GetSystemMetrics(SM_CXDLGFRAME),
        (rect2.bottom-rect2.top) + 2*GetSystemMetrics(SM_CYDLGFRAME) + GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CYMENU),
        FALSE
        );

    ShowWindow (g_hChildWindow, SW_SHOWNORMAL);

    return TRUE;
}

BOOL
pDestroyWindows (
    HWND hwnd
    )
{
    DestroyWindow (g_hChildWindow);
    DestroyMenu (GetMenu(hwnd));

    return TRUE;
}


BOOL
pUpdateWindowTitle (
    HWND hwnd,
    LPSTR OpenFile,
    BOOL IsFileModified
    )
{
    char TempString[512];

    if (OpenFile && (OpenFile[0] != '\0')) {
        StringCopyA (TempString, OpenFile);
        StringCatA (TempString, " - ");
    } else {
        TempString[0] = '\0';
    }

    StringCatA (TempString, DEFAULT_WINDOW_TITLE);

    if (IsFileModified) {
        StringCatA (TempString, " *");
    }

    SetWindowText (hwnd, TempString);

    return TRUE;
}


LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL b;
    LPSTR Ptr;
    POINT pt;
    HWND hChildWnd;
    static LPCREATESTRUCT pCS;

    if (WantProcess (message, wParam, lParam)) {
        //
        // if the dialog window message handler wants to process the message
        // send it to it (in MemdbInt.c)
        //
        return SendMessage (g_hChildWindow, message, wParam, lParam);
    }

    switch (message)
    {
    case WM_CREATE:
        pInitializeSystemMenu (hwnd);

        InitializeMemDb (hwnd);
        pInitializeWindows (hwnd);

        pUpdateWindowTitle (hwnd, "", FALSE);

        pCS = (LPCREATESTRUCT)lParam;
        Ptr = (LPSTR)pCS->lpCreateParams;
        if (_mbschr (Ptr, '?')) {
            HelpAndExit ();
        }

        if (Ptr[0]!='\0') {
            SendMessage (g_hChildWindow, WM_FILE_LOAD, (WPARAM)Ptr, 0);
        } else if (DoesFileExistA (DEFAULT_FILENAME)) {
            SendMessage (g_hChildWindow, WM_FILE_LOAD, (WPARAM)(DEFAULT_FILENAME), 0);
        }

        break;

    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case ID_HELP_ABOUT:
            AboutDialog (hwnd);
            break;

        case ID_FILE_QUIT:
            SendMessage (g_hChildWindow, WM_QUIT_CHECK, (WPARAM)&b, 0);
            if (b) {
                DestroyWindow(hwnd);
            }
            break;
        default:
            return DefWindowProc(hwnd, message, wParam, lParam);
        }
        break;

    case WM_SYSCOMMAND:
        switch (wParam) {
        case SC_CLOSE:
            SendMessage (g_hChildWindow, WM_QUIT_CHECK, (WPARAM)&b, 0);
            if (b) {
                DestroyWindow(hwnd);
            }
            break;

        default:
            return DefWindowProc(hwnd, message, wParam, lParam);
        }

        break;

    case WM_FILE_UPDATE:

        pUpdateWindowTitle (hwnd, (LPSTR)wParam, (BOOL)lParam);
        break;

    case WM_DESTROY:
        pDestroyWindows (hwnd);
        DestroyMemDb ();

        PostQuitMessage (0);
        break;

    default:
        return DefWindowProc(hwnd, message, wParam, lParam);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\dbedit\keytree.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    keytree.c

Abstract:

    functions handling the operation of the treeview
    that displays the keys in a memdb tree in memdbe.exe

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:



--*/

#include "pch.h"

#include "dbeditp.h"
#include <commdlg.h>
#include "dialogs.h"

//
// controls in display
//
HWND g_hTreeKey;

//
// distance from corner of client window to
// corner of tree view
//
int g_TreeView_OffsetX, g_TreeView_OffsetY;

//
// handle of item being dragged
//
HTREEITEM g_hDragItem;


CHAR g_Key1[MEMDB_MAX] = "";
CHAR g_Key2[MEMDB_MAX] = "";

CHAR g_FindString[MEMDB_MAX] = "";
HTREEITEM g_hFindItem = NULL;
PPARSEDPATTERNA g_FindParsedPattern = NULL;


BOOL g_UpdateSel = TRUE;

extern VOID
AlertBadNewItemName (
    HTREEITEM hItem,
    PSTR ErrorStr
    );





HTREEITEM
pKeyTreeEnumNextItem (
    HTREEITEM hItem
    )
{
    HTREEITEM hNext;

    if (!hItem) {
        return TreeView_GetRoot (g_hTreeKey);
    }

    if (hNext = TreeView_GetChild (g_hTreeKey, hItem)) {
        return hNext;
    }

    do {
        if (hNext = TreeView_GetNextSibling (g_hTreeKey, hItem)) {
            return hNext;
        }
    } while (hItem = TreeView_GetParent (g_hTreeKey, hItem));

    return NULL;
}





PSTR
pIsChildKey (
    PSTR Parent,
    PSTR Child
    )
{
    INT ParentLen;
    ParentLen = CharCountA (Parent);
    if ((ParentLen > 0) &&
        StringIMatchCharCountA (Parent, Child, ParentLen) &&
        (Child[ParentLen] == '\\')) {
        return Child + ParentLen + 1;
    } else {
        return NULL;
    }
}








BOOL
IsKeyTree (
    HWND hwnd
    )
{
    return (hwnd == g_hTreeKey);
}


BOOL
KeyTreeInit (
    HWND hdlg
    )
{
    HBITMAP hBmp;
    HIMAGELIST ImgList;
    RECT r1, r2;

    g_hTreeKey = GetDlgItem (hdlg, IDC_TREE_KEY);

    GetWindowRect (g_hTreeKey, &r1);
    GetWindowRect (hdlg, &r2);

    g_TreeView_OffsetX = r1.left - r2.left;
    g_TreeView_OffsetY = r1.top - r2.top;

    if ((ImgList = ImageList_Create (16, 16, ILC_COLOR, 2, 0)) == NULL)
        return FALSE;

    hBmp = LoadBitmap (g_hInst, MAKEINTRESOURCE(IDB_BITMAP_KEY));
    ImageList_AddMasked (ImgList, hBmp, RGB (0, 255, 0));
    DeleteObject (hBmp);
    hBmp = LoadBitmap (g_hInst, MAKEINTRESOURCE(IDB_BITMAP_KEYSEL));
    ImageList_AddMasked (ImgList, hBmp, RGB (0, 255, 0));
    DeleteObject (hBmp);

    TreeView_SetImageList (g_hTreeKey, ImgList, TVSIL_NORMAL);

    return TRUE;
}


VOID
KeyTreeDestroy (
    VOID
    )
{
    if (g_FindParsedPattern) {
        DestroyParsedPatternA (g_FindParsedPattern);
    }
}

BOOL
KeyTreeClear (
    VOID
    )
{
    g_UpdateSel = FALSE;
    if (!TreeView_DeleteAllItems (g_hTreeKey)) {
        DEBUGMSG ((DBG_ERROR, "Could not clear Tree View!"));
        return FALSE;
    }
    g_UpdateSel = TRUE;

    KeyTreeSelectItem (NULL);

    KeyAddClear ();
    g_hFindItem = NULL;

    g_hDragItem = NULL;
    return TRUE;
}


BOOL
KeyTreeRefresh (
    VOID
    )
{
    TurnOnWaitCursor ();

    if (!KeyTreeClear ()) {
        return FALSE;
    }

    if (!KeyAddSubLevels (NULL)) {
        DEBUGMSG ((DBG_ERROR, "Could not fill Tree View!"));
        TurnOffWaitCursor ();
        return FALSE;
    }

    InvalidateRect (g_hTreeKey, NULL, TRUE);

    TurnOffWaitCursor ();

    return TRUE;
}



UINT
KeyTreeGetIndexOfItem (
    HTREEITEM hItem
    )
{
    TVITEM tvi;

    if (!hItem) {
        return INVALID_KEY_HANDLE;
    }

    tvi.hItem = hItem;
    tvi.mask = TVIF_PARAM;
    TreeView_GetItem (g_hTreeKey, &tvi);

    return tvi.lParam;
}

BOOL
KeyTreeGetNameOfItem (
    HTREEITEM hItem,
    PSTR Buffer
    )
{
    UINT Index;
    PCSTR key;

    Index = KeyTreeGetIndexOfItem (hItem);

    if (Index == INVALID_KEY_HANDLE) {
        return FALSE;
    }

    key = MemDbGetKeyFromHandleA (Index, 0);

    if (!key) {
        return FALSE;
    }

    StringCopyA (Buffer, key);
    MemDbReleaseMemory (key);

    return TRUE;
}









VOID
KeyTreeSelectItem (
    HTREEITEM hItem
    )
{
    HTREEITEM hItemCur;
    hItemCur = TreeView_GetDropHilight (g_hTreeKey);
    if (hItemCur != hItem) {
        TreeView_SelectDropTarget (g_hTreeKey, hItem);
    }
    hItemCur = TreeView_GetSelection (g_hTreeKey);
    if (hItemCur != hItem) {
        TreeView_SelectItem (g_hTreeKey, hItem);
    }
}

VOID
KeyTreeSelectKey (
    UINT Index
    )
{
    HTREEITEM hItem = NULL;
    PSTR Ptr;
    PCSTR key;

    key = MemDbGetKeyFromHandleA (Index, 0);
    if (!key) {
        return;
    }

    StringCopy (g_Key1, key);
    MemDbReleaseMemory (key);

    Ptr = g_Key1;

    while (Ptr = GetPieceOfKey (Ptr, g_Key2)) {

        if (!(hItem = KeyTreeFindChildItem (hItem, g_Key2))) {
            return;
        }
    }

    KeyTreeSelectItem (hItem);
}





VOID
KeyTreeSelectRClickItem (
    VOID
    )
{
    HTREEITEM hItem;
    hItem = TreeView_GetDropHilight (g_hTreeKey);
    KeyTreeSelectItem (hItem);
}


VOID
pKeyTreeDisplayItemData (
    HTREEITEM hItem
    )
{
    INT i, j;
    INT count;
    CHAR Linkage[MEMDB_MAX];
    KEYHANDLE memdbHandle;
    UINT value;
    UINT flags;
    UINT size;
    PBYTE p;
    KEYHANDLE *keyArray;
    PCSTR key;

    DataListClear ();

    //
    // Fill control with values and flags
    //

    memdbHandle = KeyTreeGetIndexOfItem (hItem);
    if (!memdbHandle) {
        return;
    }

    if (MemDbGetValueAndFlagsByHandle (memdbHandle, &value, &flags)) {
        DataListAddData (DATAFLAG_VALUE, value, NULL);
        DataListAddData (DATAFLAG_FLAGS, flags, NULL);
    }

    //
    // Fill control with unordered binary blobs
    //

    for (i = 0 ; i < 4 ; i++) {
        p = MemDbGetUnorderedBlobByKeyHandle (memdbHandle, (BYTE) i, &size);
        if (p) {
            DataListAddData (DATAFLAG_UNORDERED, size, p);
            MemDbReleaseMemory (p);
        }
    }

    //
    // Fill control with unidirectional linkage
    //

    for (i = 0 ; i < 4 ; i++) {
        keyArray = MemDbGetSingleLinkageArrayByKeyHandle (memdbHandle, (BYTE) i, &size);
        if (keyArray) {
            count = (INT) size / sizeof (KEYHANDLE);
            for (j = 0 ; j < count ; j++) {
                key = MemDbGetKeyFromHandle (keyArray[j], 0);
                DataListAddData (DATAFLAG_SINGLELINK, keyArray[j], (PBYTE) key);
                MemDbReleaseMemory (key);
            }

            MemDbReleaseMemory (keyArray);
        }
    }

    //
    // Fill control with bi-directional linkage
    //

    for (i = 0 ; i < 4 ; i++) {
        keyArray = MemDbGetDoubleLinkageArrayByKeyHandle (memdbHandle, (BYTE) i, &size);
        if (keyArray) {
            count = (INT) size / sizeof (KEYHANDLE);
            for (j = 0 ; j < count ; j++) {
                key = MemDbGetKeyFromHandle (keyArray[j], 0);
                DataListAddData (DATAFLAG_DOUBLELINK, keyArray[j], (PBYTE) key);
                MemDbReleaseMemory (key);
            }

            MemDbReleaseMemory (keyArray);
        }
    }
}


HTREEITEM
KeyTreeSelChanged (
    HWND hdlg,
    LPNMTREEVIEW pnmtv
    )
{
    if (!g_UpdateSel) {
        return NULL;
    }

    KeyTreeSelectItem (pnmtv->itemNew.hItem);

    if (!pnmtv->itemNew.hItem)
    {
        SetDlgItemText (hdlg, IDC_STATIC_KEYNAME, "");
        DataListClear ();
    } else {

        if (KeyTreeGetNameOfItem (pnmtv->itemNew.hItem, g_Key1)) {
            SetDlgItemText (hdlg, IDC_STATIC_KEYNAME, g_Key1);
        }

        pKeyTreeDisplayItemData (pnmtv->itemNew.hItem);
    }

    return pnmtv->itemNew.hItem;
}






BOOL
KeyTreeBeginDrag (
    HWND hWnd,
    LPNMTREEVIEW pnmtv
    )
{
    HIMAGELIST hDragImgList;

    if (!(hDragImgList = TreeView_CreateDragImage (g_hTreeKey, pnmtv->itemNew.hItem))) {
        DEBUGMSG ((DBG_ERROR, "Could not get drag image!"));
        return FALSE;
    }

    if (!ImageList_BeginDrag (hDragImgList, 0, 8, 8)) {
        DEBUGMSG ((DBG_ERROR, "Could not begin drag!"));
        return FALSE;
    }

    if (!ImageList_DragEnter(g_hTreeKey, pnmtv->ptDrag.x, pnmtv->ptDrag.y)) {
        DEBUGMSG ((DBG_ERROR, "Could not enter drag!"));
        return FALSE;
    }

    SetCapture (hWnd);
    g_hDragItem = pnmtv->itemNew.hItem;

    return TRUE;
}


BOOL
KeyTreeMoveDrag (
    POINTS pt
    )
{
    static HTREEITEM hItem, hItem2;
    static RECT TreeRect;
    static TVHITTESTINFO tvht;
    static int x, y, count;

    x = pt.x-g_TreeView_OffsetX;
    y = pt.y-g_TreeView_OffsetY;

    if (!ImageList_DragLeave (g_hTreeKey)) {
        DEBUGMSG ((DBG_ERROR, "Could not leave drag!"));
        return FALSE;
    }

    if (!ImageList_DragMove (x, y)) {
        DEBUGMSG ((DBG_ERROR, "Could not move drag!"));
        return FALSE;
    }

    tvht.pt.x = x;
    tvht.pt.y = y;
    TreeView_HitTest (g_hTreeKey, &tvht);
    if (tvht.flags & TVHT_ONITEM) {
        //
        // if we are over an item and it is not already selected, select it.
        //
        if (TreeView_GetSelection (g_hTreeKey) != tvht.hItem) {
            KeyTreeSelectItem (tvht.hItem);
        }
    } else if (tvht.flags & TVHT_ONITEMBUTTON) {
        //
        // if we are over a plus/minus sign, expand tree
        //
        TreeView_Expand (g_hTreeKey, tvht.hItem, TVE_EXPAND);
    } else if (tvht.flags & TVHT_ABOVE) {
        if (hItem = TreeView_GetFirstVisible (g_hTreeKey)) {
            if (hItem2 = TreeView_GetPrevVisible (g_hTreeKey, hItem)) {
                TreeView_EnsureVisible (g_hTreeKey, hItem2);
            }
        }
    } else if (tvht.flags & TVHT_BELOW) {
        if ((hItem = TreeView_GetFirstVisible (g_hTreeKey)) &&
            ((count = TreeView_GetVisibleCount (g_hTreeKey)) > 0))
        {
            hItem2 = hItem;
            while (hItem2 && count > 0) {
                hItem = hItem2;
                hItem2 = TreeView_GetNextVisible (g_hTreeKey, hItem);
                count --;
            }

            if (hItem2) {
                TreeView_EnsureVisible (g_hTreeKey, hItem2);
            }
        }
    }

    UpdateWindow (g_hTreeKey);

    if (!ImageList_DragEnter(g_hTreeKey, x, y)) {
        DEBUGMSG ((DBG_ERROR, "Could not enter drag!"));
        return FALSE;
    }

    return TRUE;
}




BOOL
KeyTreeEndDrag (
    BOOL TakeAction,
    POINTS *pt
    )
/*++

  only returns TRUE if the memdb database is altered

--*/
{
    TVITEM Item;
    HTREEITEM hItem;
    TVINSERTSTRUCT tvis;
    static TVHITTESTINFO tvht;
    int x, y;

    ReleaseCapture ();

    if (!ImageList_DragLeave (g_hTreeKey)) {
        DEBUGMSG ((DBG_ERROR, "Could not leave drag!"));
        return FALSE;
    }

    ImageList_EndDrag();

    if (!TakeAction) {
        KeyTreeSelectItem (NULL);
        return FALSE;
    }

    x = pt->x-g_TreeView_OffsetX;
    y = pt->y-g_TreeView_OffsetY;

    tvht.pt.x = x;
    tvht.pt.y = y;
    TreeView_HitTest (g_hTreeKey, &tvht);
    if (!(tvht.flags & TVHT_ONITEM)) {
        return FALSE;
    }

    if (!KeyTreeGetNameOfItem (g_hDragItem, g_Key1) ||
        !KeyTreeGetNameOfItem (tvht.hItem, g_Key2)) {
        return FALSE;
    }

    StringCatA (g_Key2, "\\");
    Item.hItem = g_hDragItem;
    Item.mask = TVIF_TEXT;
    Item.pszText = GetEndOfStringA (g_Key2);
    Item.cchTextMax = MEMDB_MAX;
    TreeView_GetItem (g_hTreeKey, &Item);

    //
    // MemDbMoveTree is not implemented
    //

    return FALSE;
/*
    if (!MemDbMoveTreeA (g_Key1, g_Key2)) {
        Beep (200, 50);
        return FALSE;
    }

    //
    // get the dragitem data, then delete it and children,
    // then add to new parent, then fill in child levels.
    //
    tvis.item.hItem = g_hDragItem;
    tvis.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvis.item.pszText = g_Key1;
    tvis.item.cchTextMax = MEMDB_MAX;
    if (!TreeView_GetItem (g_hTreeKey, &tvis.item)) {
        DEBUGMSG ((DBG_ERROR, "Could not get item data!"));
    }

    if (!TreeView_DeleteItem (g_hTreeKey, g_hDragItem)) {
        DEBUGMSG ((DBG_ERROR, "Could not delete item!"));
    }

    tvis.hParent = tvht.hItem;
    tvis.hInsertAfter = TVI_FIRST;
    if (!(hItem = TreeView_InsertItem (g_hTreeKey, &tvis))) {
        DEBUGMSG ((DBG_ERROR, "Could not insert item!"));
    }


    KeyAddSubLevels (hItem);

    KeyTreeSelectItem (hItem);

    return TRUE;
*/
}




BOOL
KeyTreeCreateItem (
    HWND hdlg
    )
{
    HTREEITEM hItem;

    if (!CreateKeyDialog (hdlg, g_Key1)) {
        return FALSE;
    }

    if (!(hItem = KeyAddCreateItem (g_Key1))) {
        return FALSE;
    }

    KeyTreeSelectItem (hItem);
    return TRUE;
}

BOOL
KeyTreeCreateChildItem (
    HWND hdlg,
    HTREEITEM hItem
    )
{
    if (!(hItem = KeyAddItem ("", hItem, INVALID_KEY_HANDLE))) {
        return FALSE;
    }

    KeyTreeSelectItem (hItem);

    if (!KeyTreeForceEditLabel (hItem)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
KeyTreeRenameItem (
    HTREEITEM hItem,
    LPSTR Name
    )
/*++

  only returns TRUE if the memdb database is altered

--*/
{
    HTREEITEM hParent;
    TVITEM Item;
    BOOL NewItem;

    if (!hItem || !Name) {
        return FALSE;
    }

    //
    // MemDbMove is not implemented
    //

    return FALSE;

/*
    hParent = TreeView_GetParent (g_hTreeKey, hItem);

    NewItem = (KeyTreeGetIndexOfItem (hItem) == INVALID_KEY_HANDLE);

    if (KeyTreeFindChildItem (hParent, Name)) {
        if (NewItem) {
            AlertBadNewItemName (hItem, "Name already exists at this level");
        } else {
            MessageBox (NULL, "Name already exists at this level", "Error", MB_OK|MB_ICONEXCLAMATION);
        }
        return FALSE;
    }

    if (NewItem) {
        if (Name[0]=='\0') {
            AlertBadNewItemName (hItem, "New keys must have name");
            return FALSE;
        }
    } else {
        if (!KeyTreeGetNameOfItem (hItem, g_Key1) ||
            !KeyTreeGetNameOfItem (hParent, g_Key2)) {
            return FALSE;
        }

        StringCatA (g_Key2, "\\");
        StringCatA (g_Key2, Name);

        if (!MemDbMoveTreeA (g_Key1, g_Key2)) {
            MessageBox (NULL, "Could not rename item", "Error", MB_OK|MB_ICONEXCLAMATION);
            return FALSE;
        }
    }

    Item.hItem = hItem;
    Item.mask = TVIF_TEXT;
    Item.pszText = Name;
    TreeView_SetItem (g_hTreeKey, &Item);

    return TRUE;
*/
}


BOOL
KeyTreeDeleteKey (
    HTREEITEM hItem
    )
/*++

  only returns TRUE if the memdb database is altered

--*/
{
    CHAR Key[MEMDB_MAX];
    HTREEITEM hParent;

    if (!hItem || !KeyTreeGetNameOfItem (hItem, Key)) {
        return FALSE;
    }

    do {
        //
        // move up tree, deleting parents if they have no other children
        // and they are not an endpoint (memdbgetvalue returns false)
        //
        hParent = TreeView_GetParent (g_hTreeKey, hItem);
        TreeView_DeleteItem (g_hTreeKey, hItem);

        hItem = hParent;
    } while (hItem && !TreeView_GetChild (g_hTreeKey, hItem) &&
        !(KeyTreeGetNameOfItem (hItem, g_Key1) && MemDbGetValueA (g_Key1, NULL)));

    MemDbDeleteTreeA (Key);

    return TRUE;
}


BOOL
KeyTreeDeleteItem (
    HTREEITEM hItem
    )
{
    return TreeView_DeleteItem (g_hTreeKey, hItem);
}



VOID
KeyTreeExpandItem (
    HTREEITEM hItem,
    BOOL Expand,
    BOOL Recurse
    )
{
    HTREEITEM hChildItem;
    if (!hItem) {
        if (!(hItem = TreeView_GetRoot (g_hTreeKey))) {
            return;
        }
    }

    if (!Recurse) {
        TreeView_Expand (g_hTreeKey, hItem, Expand ? TVE_EXPAND : TVE_COLLAPSE);
    } else {

        do {
            hChildItem = TreeView_GetChild (g_hTreeKey, hItem);

            if (hChildItem) {
                TreeView_Expand (g_hTreeKey, hItem, Expand ? TVE_EXPAND : TVE_COLLAPSE);
                KeyTreeExpandItem (hChildItem, Expand, TRUE);
            }
        } while (hItem = TreeView_GetNextSibling (g_hTreeKey, hItem));
    }
}




BOOL
KeyTreeRightClick (
    HWND hdlg,
    HTREEITEM hItem
    )
{
    RECT TVrect, rect;
    HMENU hMenu;

    if (!hItem || !GetWindowRect (g_hTreeKey, &TVrect)) {
        return FALSE;
    }

    TreeView_EnsureVisible (g_hTreeKey, hItem);

    if (!TreeView_GetItemRect (g_hTreeKey, hItem, &rect, TRUE)) {
        DEBUGMSG ((DBG_ERROR, "Error getting item rectangle!"));
    }

    if (!(hMenu = LoadMenu (g_hInst, MAKEINTRESOURCE(IDR_MENU_POPUP))) ||
        (!(hMenu = GetSubMenu (hMenu, MENUINDEX_POPUP_KEY)))) {
        return FALSE;
    }

    if (!TrackPopupMenu (
        hMenu,
        TPM_LEFTALIGN,
        TVrect.left + rect.right + 4,
        TVrect.top + rect.top,
        0,
        hdlg,
        NULL
        )) {
        return FALSE;
    }

    return TRUE;
}





BOOL
KeyTreeForceEditLabel (
    HTREEITEM hItem
    )
{
    if (!hItem) {
        return FALSE;
    }
    if (!TreeView_EditLabel (g_hTreeKey, hItem)) {
        TreeView_DeleteItem (g_hTreeKey, hItem);
        return FALSE;
    }
    return TRUE;
}







HTREEITEM
KeyTreeFindChildItem (
    HTREEITEM hItem,
    PSTR Str
    )
{
    TVITEM Item;
    static CHAR PieceBuf[MEMDB_MAX];

    Item.mask = TVIF_TEXT;
    Item.pszText = PieceBuf;
    Item.cchTextMax = MEMDB_MAX;
    if (hItem == NULL) {
        Item.hItem = TreeView_GetRoot (g_hTreeKey);
    } else {
        Item.hItem = TreeView_GetChild (g_hTreeKey, hItem);
    }

    while (Item.hItem) {
        TreeView_GetItem (g_hTreeKey, &Item);

        if (StringIMatchA (PieceBuf, Str)) {
            return Item.hItem;
        }

        Item.hItem = TreeView_GetNextSibling (g_hTreeKey, Item.hItem);
    }

    return NULL;

}


BOOL
KeyTreeFindNext (
    VOID
    )
{
    BOOL b;
    TurnOnWaitCursor ();

    while (g_hFindItem = pKeyTreeEnumNextItem (g_hFindItem))
    {
        if (!KeyTreeGetNameOfItem (g_hFindItem, g_Key1)) {
            TurnOffWaitCursor ();
            return FALSE;
        }

        if (MemDbGetValueA (g_Key1, NULL)) {
            //
            // if we are looking at an endpoint, see if it matches
            //
            if (g_FindParsedPattern) {
                b = TestParsedPatternA (g_FindParsedPattern, g_Key1);
            } else {
                b = (_mbsistr (g_Key1, g_FindString) != NULL);
            }

            if (b) {
                KeyTreeSelectItem (g_hFindItem);
                TurnOffWaitCursor ();
                return TRUE;
            }
        }
    }
    TurnOffWaitCursor ();

    MessageBox (NULL, "No more keys found", "MemDb Editor", MB_OK|MB_ICONINFORMATION);
    return FALSE;
}



BOOL
KeyTreeFind (
    HWND hwnd
    )
{
    BOOL UsePattern;

    if (!KeyFindDialog (hwnd, g_FindString, &UsePattern)) {
        return FALSE;
    }

    if (g_FindParsedPattern) {
        //
        // if we have an old pattern, destroy it.
        //
        DestroyParsedPatternA (g_FindParsedPattern);
        g_FindParsedPattern = NULL;
    }

    if (UsePattern) {
        g_FindParsedPattern = CreateParsedPatternA (g_FindString);
    }
    g_hFindItem = NULL;

    return KeyTreeFindNext ();
}




BOOL
KeyTreeCreateEmptyKey (
    HTREEITEM hItem
    )
{
    TVITEM Item;
    UINT Index;
    HTREEITEM hParent;

    if (hParent = TreeView_GetParent (g_hTreeKey, hItem)) {
        if (!KeyTreeGetNameOfItem (hParent, g_Key1)) {
            return FALSE;
        }
        StringCatA (g_Key1, "\\");
    } else {
        g_Key1[0] = '\0';
    }

    Item.hItem = hItem;
    Item.mask = TVIF_TEXT;
    Item.pszText = GetEndOfStringA (g_Key1);

    if (!TreeView_GetItem (g_hTreeKey, &Item)) {
        return FALSE;
    }

    Index = MemDbAddKeyA (g_Key1);

    if (!Index) {
        return FALSE;
    }

    Item.mask = TVIF_PARAM;
    Item.lParam = Index;
    return TreeView_SetItem (g_hTreeKey, &Item);
}



BOOL
KeyTreeAddShortData (
    HWND hwnd,
    HTREEITEM hItem,
    BYTE DataFlag
    )
{
    DWORD dataValue;
    BOOL addData;
    BYTE instance;

    if (!hItem || (DataFlag != DATAFLAG_VALUE) && (DataFlag != DATAFLAG_FLAGS)) {
        return FALSE;
    }

    if (!KeyTreeGetNameOfItem (hItem, g_Key1)) {
        DEBUGMSG ((DBG_ERROR, "Could not get item name!"));
        return FALSE;
    }

    if (!ShortDataDialog (hwnd, DataFlag, &dataValue, &addData, &instance)) {
        return FALSE;
    }

    if (addData) {
        if (!MemDbAddUnorderedBlobA (g_Key1, instance, (PBYTE) &dataValue, sizeof (dataValue))) {
            DEBUGMSG ((DBG_ERROR, "Could not add data to item!"));
            return FALSE;
        }
    } else if (DataFlag == DATAFLAG_VALUE) {

        if (!MemDbSetValue (g_Key1, dataValue)) {
            DEBUGMSG ((DBG_ERROR, "Could not set value of item!"));
            return FALSE;
        }
    } else if (DataFlag == DATAFLAG_FLAGS) {

        if (!MemDbSetFlags (g_Key1, dataValue, (UINT) -1)) {
            DEBUGMSG ((DBG_ERROR, "Could not set flag of item!"));
            return FALSE;
        }
    }

    pKeyTreeDisplayItemData (hItem);

    return TRUE;
}


BOOL
KeyTreeClearData (
    HTREEITEM hItem
    )
{
    if (!hItem || !KeyTreeGetNameOfItem (hItem, g_Key1)) {
        return FALSE;
    }

    if (MemDbTestKey (g_Key1)) {
        MemDbDeleteKey (g_Key1);
        if (!MemDbAddKey (g_Key1)) {
            return FALSE;
        }
    }

    pKeyTreeDisplayItemData (hItem);
    return TRUE;
}


VOID
KeyTreeSetFilterPattern (
    PSTR Pattern
    )
{
    KeyAddSetFilterPattern (Pattern);
}


BOOL
KeyTreeCreateLinkage (
    HWND hdlg,
    HTREEITEM hItem,
    BOOL SingleLinkage,
    BYTE Instance
    )
{
    BOOL b = TRUE;

    if (hItem) {
        KeyTreeGetNameOfItem (hItem, g_Key1);
    } else {
        g_Key1[0] = '\0';
    }
    g_Key2[0] = '\0';

    if (!LinkageDialog (hdlg, g_Key1, g_Key2)) {
        return FALSE;
    }

    if (SingleLinkage) {
        if (!MemDbAddSingleLinkage (g_Key1, g_Key2, Instance)) {
            DEBUGMSG ((DBG_ERROR, "Could not create linkage between %s and %s!", g_Key1, g_Key2));
            return FALSE;
        }
    } else {
        if (!MemDbAddDoubleLinkage (g_Key1, g_Key2, Instance)) {
            DEBUGMSG ((DBG_ERROR, "Could not create double linkage between %s and %s!", g_Key1, g_Key2));
            return FALSE;
        }
    }

    pKeyTreeDisplayItemData (hItem);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\fileenum\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\dbedit\dialogs.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    functions handling the dialog boxes in memdbe.exe

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:



--*/



#include "pch.h"

#include "dbeditp.h"



BOOL CALLBACK pAboutProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }
            break;
    }
    return FALSE;
}


VOID
AboutDialog (
    HWND hwnd
    )
{
    DialogBox(g_hInst, MAKEINTRESOURCE(IDD_DIALOG_ABOUT), hwnd, pAboutProc);
}





typedef struct {
    PSTR StringBuffer;
    BOOL UsePattern;
} FINDSTRUCT, *PFINDSTRUCT;


BOOL CALLBACK pKeyFindDialogProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL UsePatternState = TRUE;
    static PFINDSTRUCT fs;

    switch (uMsg) {
    case WM_INITDIALOG:
        fs = (PFINDSTRUCT)lParam;
        if (fs->StringBuffer) {
            SetDlgItemText (hdlg, IDC_EDIT_KEYPATTERN, fs->StringBuffer);
        }

        SetFocus (GetDlgItem (hdlg, IDC_EDIT_KEYPATTERN));
        SendMessage(GetDlgItem (hdlg, IDC_EDIT_KEYPATTERN), EM_SETSEL, 0, -1);
        CheckDlgButton (hdlg, IDC_CHECK_USEPATTERN, UsePatternState ? BST_CHECKED : BST_UNCHECKED);

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case IDOK:
            if (fs->StringBuffer) {
                GetDlgItemText (hdlg, IDC_EDIT_KEYPATTERN, fs->StringBuffer, MEMDB_MAX);
            }
            UsePatternState = (IsDlgButtonChecked (hdlg, IDC_CHECK_USEPATTERN) == BST_CHECKED);
            fs->UsePattern = UsePatternState;
            EndDialog (hdlg, TRUE);
            break;
        case IDCANCEL:
            EndDialog (hdlg, FALSE);
            break;
        default:
            return DefWindowProc(hdlg, uMsg, wParam, lParam);
        };

        break;
    };

    return FALSE;
}


BOOL
KeyFindDialog (
    HWND hwnd,
    PSTR StringBuffer,
    PBOOL UsePattern
    )
{
    BOOL b;
    FINDSTRUCT fs;

    fs.StringBuffer = StringBuffer;

    if (!DialogBoxParam (
        g_hInst,
        MAKEINTRESOURCE(IDD_DIALOG_KEYFIND),
        hwnd,
        pKeyFindDialogProc,
        (LPARAM)&fs
        )) {
        return FALSE;
    }

    if (UsePattern) {
        *UsePattern = fs.UsePattern;
    }

    return TRUE;
}






typedef struct {
    BYTE DataFlag;
    UINT DataValue;
    BOOL AddData;
    BYTE Instance;
} DATASTRUCT, *PDATASTRUCT;



#define DATA_STR_LEN        16

BOOL
CALLBACK
pShortDataDialogProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static INT InitBaseButtonCheck = IDC_RADIO_HEX;
    static BOOL AddButtonCheck = FALSE;
    static PDATASTRUCT pds = NULL;
    static CHAR DataStr[DATA_STR_LEN];

    switch (uMsg) {

    case WM_INITDIALOG:
        pds = (PDATASTRUCT)lParam;
        pds->DataValue = 0;
        CheckDlgButton (hdlg, InitBaseButtonCheck, BST_CHECKED);
        CheckDlgButton (hdlg, AddButtonCheck ? IDC_RADIO_ADDDATA : IDC_RADIO_SETDATA, BST_CHECKED);

        switch (pds->DataFlag) {
        case DATAFLAG_VALUE:
            SetWindowText (hdlg, "Set Value");
            break;
        case DATAFLAG_FLAGS:
            SetWindowText (hdlg, "Set Flags");
            break;
        };

        SetFocus (GetDlgItem (hdlg, IDC_EDIT_DATA));
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:
            GetDlgItemText (hdlg, IDC_EDIT_DATA, DataStr, DATA_STR_LEN);

            if (IsDlgButtonChecked (hdlg, IDC_RADIO_HEX) == BST_CHECKED) {
                pds->DataValue = strtol (DataStr, NULL, 16);
                InitBaseButtonCheck = IDC_RADIO_HEX;
            } else {
                pds->DataValue = strtol (DataStr, NULL, 10);
                InitBaseButtonCheck = IDC_RADIO_DEC;
            }

            pds->AddData = (IsDlgButtonChecked (hdlg, IDC_RADIO_ADDDATA) == BST_CHECKED);
            AddButtonCheck = pds->AddData;

            EndDialog (hdlg, TRUE);
            break;
        case IDCANCEL:
            EndDialog (hdlg, FALSE);
            break;
        default:
            return DefWindowProc(hdlg, uMsg, wParam, lParam);
        };

        break;
    };

    return FALSE;
}


BOOL
ShortDataDialog (
    HWND hwnd,
    BYTE DataFlag,
    PDWORD DataValue,
    PBOOL AddData,
    PBYTE Instance
    )
{

    DATASTRUCT ds;

    if ((DataFlag != DATAFLAG_VALUE) && (DataFlag != DATAFLAG_FLAGS)) {
        return FALSE;
    }

    ZeroMemory (&ds, sizeof (ds));
    ds.DataFlag = DataFlag;

    if (!DialogBoxParam (
        g_hInst,
        MAKEINTRESOURCE(IDD_DIALOG_SHORTDATA),
        hwnd,
        pShortDataDialogProc,
        (LPARAM)&ds
        )) {

        return FALSE;
    }

    if (DataValue) {
        *DataValue = ds.DataValue;
    }

    if (AddData) {
        *AddData = ds.AddData;
    }

    if (Instance) {
        *Instance = ds.Instance;
    }

    return TRUE;
}




typedef struct {
    PSTR Key1, Key2;
} LINKAGESTRUCT, *PLINKAGESTRUCT;


BOOL CALLBACK pLinkageDialogProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static PLINKAGESTRUCT pls = NULL;

    switch (uMsg) {

    case WM_INITDIALOG:
        pls = (PLINKAGESTRUCT)lParam;

        SetDlgItemText (hdlg, IDC_EDIT_KEY1, pls->Key1);
        SetDlgItemText (hdlg, IDC_EDIT_KEY2, pls->Key2);

        SetFocus (GetDlgItem (hdlg, (pls->Key1[0]=='\0') ? IDC_EDIT_KEY1 : IDC_EDIT_KEY2));
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:
            GetDlgItemText (hdlg, IDC_EDIT_KEY1, pls->Key1, MEMDB_MAX);
            GetDlgItemText (hdlg, IDC_EDIT_KEY2, pls->Key2, MEMDB_MAX);
            EndDialog (hdlg, TRUE);
            break;
        case IDCANCEL:
            EndDialog (hdlg, FALSE);
            break;
        default:
            return DefWindowProc(hdlg, uMsg, wParam, lParam);
        };

        break;
    };

    return FALSE;
}


BOOL
LinkageDialog (
    HWND hwnd,
    PSTR Key1,
    PSTR Key2
    )
{
    LINKAGESTRUCT ls;

    if (!Key1 || !Key2) {
        return FALSE;
    }

    ls.Key1 = Key1;
    ls.Key2 = Key2;

    if (!DialogBoxParam (
        g_hInst,
        MAKEINTRESOURCE(IDD_DIALOG_LINKAGE),
        hwnd,
        pLinkageDialogProc,
        (LPARAM)&ls
        )) {
        return FALSE;
    }

    return (Key1[0]!='\0' && Key2[0]!='\0');
}




BOOL CALLBACK pCreateKeyDialogProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static PSTR Str = NULL;

    switch (uMsg) {

    case WM_INITDIALOG:
        Str = (PSTR)lParam;
        SetFocus (GetDlgItem (hdlg, IDC_EDIT_KEY));
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:
            GetDlgItemText (hdlg, IDC_EDIT_KEY, Str, MEMDB_MAX);
            EndDialog (hdlg, TRUE);
            break;
        case IDCANCEL:
            EndDialog (hdlg, FALSE);
            break;
        default:
            return DefWindowProc(hdlg, uMsg, wParam, lParam);
        };

        break;
    };

    return FALSE;
}


BOOL
CreateKeyDialog (
    HWND hwnd,
    PSTR KeyName
    )
{
    if (!KeyName) {
        return FALSE;
    }

    return DialogBoxParam (
        g_hInst,
        MAKEINTRESOURCE(IDD_DIALOG_CREATEKEY),
        hwnd,
        pCreateKeyDialogProc,
        (LPARAM)KeyName
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\dbedit\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\filler\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\homenet\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\icontool\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\lsstub\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\dbedit\memdbint.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    memdbint.c

Abstract:

    operates the main child window of memdbe.exe.

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:



--*/

#include "pch.h"

#include "dbeditp.h"
#include <commdlg.h>

HINSTANCE g_hInst;
HANDLE g_hHeap;


extern HMENU g_hMenuMain;
BOOL g_ParsePaths;

OPENFILENAME g_Ofn;

BOOL g_IsFileModified;
CHAR g_FileName[_MAX_PATH];

HTREEITEM g_hSelItem;



BOOL
WantProcess (
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (msg) {
    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case ID_FILE_NEW:
        case ID_FILE_LOAD:
        case ID_FILE_SAVE:
        case ID_FILE_SAVEAS:
        case ID_FILE_REVERT:
        case ID_KEY_COPYNAME:
        case ID_KEY_CREATENEW:
        case ID_KEY_CREATECHILD:
        case ID_KEY_DELETE:
        case ID_KEY_FIND:
        case ID_KEY_FINDNEXT:
        case ID_KEY_PARSEPATHS:
        case ID_KEY_RENAME:
            return TRUE;
        }
        break;

    }
    return FALSE;
}


BOOL
InitializeMemDb (
    HWND hWnd
    )
{
    g_FileName[0] = '\0';

    g_Ofn.lStructSize = sizeof(OPENFILENAME);
    g_Ofn.hwndOwner = hWnd;
    g_Ofn.hInstance = NULL;
    g_Ofn.lpstrFilter = "DAT files\0*.dat\0All files\0*.*\0";
    g_Ofn.lpstrCustomFilter = NULL;
    g_Ofn.nMaxCustFilter = 0;
    g_Ofn.nFilterIndex = 1;
    g_Ofn.lpstrFile = g_FileName;
    g_Ofn.nMaxFile = _MAX_PATH;
    g_Ofn.lpstrFileTitle = NULL;
    g_Ofn.lpstrInitialDir = NULL;
    g_Ofn.lpstrTitle = NULL;
    g_Ofn.Flags = 0;
    g_Ofn.nFileOffset = 0;
    g_Ofn.nFileExtension = 0;
    g_Ofn.lpstrDefExt = "dat";
    g_Ofn.lCustData = 0L;
    g_Ofn.lpfnHook = NULL;
    g_Ofn.lpTemplateName = NULL;

    UtInitialize (NULL);
    MemDbInitialize ();

    return TRUE;
}


BOOL
DestroyMemDb (
    VOID
    )
{
    g_FileName[0] = '\0';

    MemDbTerminate();
    UtTerminate();

    return FALSE;
}


VOID
pDisplayInit (
    HWND hdlg
    )
{
    HMENU hMenu;

    SetDlgItemText (hdlg, IDC_STATIC_KEYNAME, "");

    if (hMenu = GetSubMenu (g_hMenuMain, MENUINDEX_MAIN_KEY)) {
        EnableMenuItem (hMenu, ID_KEY_FINDNEXT, MF_GRAYED);
    }

}



BOOL
pUpdateFileStatus (
    HWND hdlg,
    BOOL FileModified
    )
{
    HMENU hMenu;
    HWND hWnd;
    hWnd = GetParent (hdlg);

    g_IsFileModified = FileModified;

    if (hMenu = GetSubMenu (g_hMenuMain, MENUINDEX_MAIN_FILE)) {
        EnableMenuItem (hMenu, ID_FILE_REVERT, g_IsFileModified ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem (hMenu, ID_FILE_SAVE, g_IsFileModified ? MF_ENABLED : MF_GRAYED);
    }


    if (hWnd) {
        SendMessage (
            hWnd,
            WM_FILE_UPDATE,
            (WPARAM)GetFileNameFromPathA(g_FileName),
            (LPARAM)g_IsFileModified
            );
    }

    return TRUE;
}





BOOL
pRefreshView (
    HWND hdlg
    )
{
    SetDlgItemText (hdlg, IDC_STATIC_KEYNAME, "");
    g_hSelItem = NULL;
    KeyTreeRefresh ();
    DataListRefresh ();

    return TRUE;
}










BOOL
pLoadFile (
    LPSTR FileName
    )
{
    BOOL b;
    if (FileName) {
        b = TRUE;
        if (FileName != g_FileName) {
            //
            // (FileName == g_FileName) when we are reloading the same database
            //
            StringCopyA (g_FileName, FileName);
        }
    } else {
        g_Ofn.Flags = OFN_HIDEREADONLY;
        b = GetOpenFileName (&g_Ofn);
    }

    KeyTreeClear ();
    DataListClear ();
    if (b) {
        if (!(b = MemDbLoadA (g_FileName))) {
            if (GetLastError () == ERROR_BAD_FORMAT) {
                MessageBox (NULL, "Invalid database file format", "Error", MB_OK|MB_ICONEXCLAMATION);
            }
        }
    }

    return b;
}

BOOL
pSaveFile (
    BOOL UseCurrentName
    )
{
    BOOL b = TRUE;
    if (!UseCurrentName || (g_FileName[0] == '\0')) {
        g_Ofn.Flags = OFN_OVERWRITEPROMPT;
        b = GetSaveFileName (&g_Ofn);
    }

    if (b) {
        b = MemDbSaveA (g_FileName);
#ifdef DEBUG
        if (!b) {
            DEBUGMSG ((DBG_ERROR, "Could not save file \"%s\"!", g_FileName));
        }
#endif
    }

    return b;
}


BOOL
pVerifyClose (
    VOID
    )
{
    int Temp;

    if (!g_IsFileModified) {
        return TRUE;
    }

    Temp = MessageBox (
        NULL,
        "Database is modified, save?",
        "MemDb Editor",
        MB_YESNOCANCEL | MB_ICONQUESTION
        );

    if (Temp == IDYES) {
        pSaveFile (TRUE);
    }

    return Temp != IDCANCEL;
}

BOOL
pResetView (
    VOID
    )
{
    KeyTreeSetFilterPattern (NULL);
    return TRUE;
}




VOID
AlertBadNewItemName (
    HTREEITEM hItem,
    PSTR ErrorStr
    )
{
    if (MessageBox (
        NULL,
        ErrorStr ? ErrorStr : "Error",
        "Error",
        MB_OKCANCEL | MB_ICONEXCLAMATION
        ) == IDOK)
    {
        KeyTreeForceEditLabel (hItem);
    } else {
        KeyTreeDeleteItem (hItem);
    }
}


BOOL
pFindKey (
    HWND hdlg
    )
{
    BOOL b;
    HMENU hMenu;

    b = KeyTreeFind (hdlg);

    if (b) {
        if (hMenu = GetSubMenu (g_hMenuMain, MENUINDEX_MAIN_KEY)) {
            EnableMenuItem (hMenu, ID_KEY_FINDNEXT, MF_ENABLED);
        }
    }

    return b;
}

BOOL
pFindNextKey (
    HWND hdlg
    )
{
    BOOL b;
    HMENU hMenu;

    b = KeyTreeFindNext ();

    if (!b) {
        if (hMenu = GetSubMenu (g_hMenuMain, MENUINDEX_MAIN_KEY)) {
            EnableMenuItem (hMenu, ID_KEY_FINDNEXT, MF_GRAYED);
        }
    }

    return b;
}


BOOL
pToggleParsePaths (
    HWND hdlg
    )
{
    HMENU hMenu;

    if (!(hMenu = GetSubMenu (g_hMenuMain, MENUINDEX_MAIN_KEY))) {
        return FALSE;
    }

    g_ParsePaths = !(GetMenuState (hMenu, ID_KEY_PARSEPATHS, MF_BYCOMMAND) & MF_CHECKED);
    CheckMenuItem (hMenu, ID_KEY_PARSEPATHS, MF_BYCOMMAND | (g_ParsePaths?MF_CHECKED:MF_UNCHECKED));

    pRefreshView (hdlg);

    return FALSE;
}


VOID
pSetFilter (
    HWND hdlg,
    BOOL UseInput
    )
{
    CHAR Filter[MEMDB_MAX];

    if (UseInput) {
        GetDlgItemText (hdlg, IDC_EDIT_FILTERPATTERN, Filter, MEMDB_MAX);
    } else {
        Filter[0] = '\0';
    }

    KeyTreeSetFilterPattern (Filter);
    pRefreshView (hdlg);
}


BOOL
pCopyKeyNameToClipboard (
    HWND hdlg,
    HTREEITEM hItem
    )
{
    CHAR KeyName[MEMDB_MAX];

    if (!KeyTreeGetNameOfItem (hItem, KeyName)) {
        DEBUGMSG ((DBG_ERROR, "Could not get name of item"));
        return FALSE;
    }

    SetDlgItemText (hdlg, IDC_EDIT_KEYNAMEHIDDEN, KeyName);

    SendMessage (GetDlgItem (hdlg, IDC_EDIT_KEYNAMEHIDDEN), EM_SETSEL, 0, -1);
    SendMessage (GetDlgItem (hdlg, IDC_EDIT_KEYNAMEHIDDEN), WM_COPY, 0, 0);

    return TRUE;
}







BOOL
CALLBACK
MainDlgProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL InDrag = FALSE;
    BOOL b = FALSE;

    switch (uMsg) {

    case WM_INITDIALOG:

        pDisplayInit (hdlg);
        KeyTreeInit (hdlg);
        DataListInit (hdlg);

        g_FileName[0] = '\0';
        pUpdateFileStatus (hdlg, FALSE);

        InDrag = FALSE;
        g_hSelItem = NULL;

        g_ParsePaths = TRUE;

        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDC_BUTTON_EXPANDALL:
            if (HIWORD(wParam) == BN_CLICKED) {
                KeyTreeExpandItem (NULL, TRUE, TRUE);
            }
            break;

        case IDC_BUTTON_COLLAPSEALL:
            if (HIWORD(wParam) == BN_CLICKED) {
                KeyTreeExpandItem (NULL, FALSE, TRUE);
            }
            break;

        case IDC_BUTTON_REFRESH:
            if (HIWORD(wParam) == BN_CLICKED) {
                pRefreshView (hdlg);
            }
            break;

        case IDC_BUTTON_APPLYFILTER:
            if (HIWORD(wParam) == BN_CLICKED) {
                pSetFilter (hdlg, TRUE);
            }
            break;

        case IDC_BUTTON_SHOWALL:
            if (HIWORD(wParam) == BN_CLICKED) {
                pSetFilter (hdlg, FALSE);
            }
            break;

        case ID_FILE_NEW:

            if (pVerifyClose ()) {
                g_FileName[0] = '\0';
                pUpdateFileStatus (hdlg, FALSE);
                //MemDbReset();
                pResetView ();
                pRefreshView (hdlg);
            }
            break;

        case ID_FILE_REVERT:

            if (MessageBox (
                NULL,
                "Revert to saved database?",
                "MemDb Editor",
                MB_YESNO | MB_ICONQUESTION
                ) == IDYES)
            {
                if (g_FileName[0]=='\0') {
                    //MemDbReset();
                } else {
                    pLoadFile (g_FileName);
                }

                pRefreshView (hdlg);
                pUpdateFileStatus (hdlg, FALSE);
            }

            break;
        case ID_FILE_LOAD:

            if (pVerifyClose () && pLoadFile (NULL)) {
                pResetView ();
                pRefreshView (hdlg);
                pUpdateFileStatus (hdlg, FALSE);
            }
            break;

        case ID_FILE_SAVE:
        case ID_FILE_SAVEAS:
            //
            // if command is saveas, we dont use same filename.
            //
            if (pSaveFile (LOWORD(wParam) == ID_FILE_SAVE)) {
                pUpdateFileStatus (hdlg, FALSE);
            }
            break;

        case ID_KEY_CREATENEW:
            KeyTreeCreateItem (hdlg);
            break;

        case ID_KEY_CREATECHILD:
            if (g_hSelItem) {
                KeyTreeCreateChildItem (hdlg, g_hSelItem);
            }
            break;

        case ID_KEY_DELETE:
            if (g_hSelItem && KeyTreeDeleteKey (g_hSelItem)) {
                pUpdateFileStatus (hdlg, TRUE);
            }
            break;

        case ID_KEY_CREATELINKAGE:

            if (g_hSelItem && KeyTreeCreateLinkage (hdlg, g_hSelItem, FALSE, 0)) {
                pUpdateFileStatus (hdlg, TRUE);
            }
            break;

        case ID_KEY_COPYNAME:
            if (g_hSelItem) {
                pCopyKeyNameToClipboard (hdlg, g_hSelItem);
            }
            break;

        case ID_KEY_RENAME:
            if (g_hSelItem) {
                KeyTreeForceEditLabel (g_hSelItem);
                KeyTreeSelectItem (g_hSelItem);
            }
            break;

        case ID_KEY_FIND:
            pFindKey (hdlg);
            break;

        case ID_KEY_FINDNEXT:
            pFindNextKey (hdlg);
            break;

        case ID_KEY_PARSEPATHS:

            pToggleParsePaths (hdlg);
            break;

        case ID_KEY_CLEARDATA:
            if (g_hSelItem && KeyTreeClearData (g_hSelItem)) {
                pUpdateFileStatus (hdlg, TRUE);
            }
            break;

        case ID_DATA_ADDVALUE:
        case ID_DATA_ADDFLAGS:
            if (g_hSelItem && KeyTreeAddShortData (
                hdlg,
                g_hSelItem,
                (BYTE)((LOWORD(wParam)==ID_DATA_ADDVALUE) ? DATAFLAG_VALUE : DATAFLAG_FLAGS)
                ))
            {
                pUpdateFileStatus (hdlg, TRUE);
            }
            break;
        default:
            return DefWindowProc(hdlg, uMsg, wParam, lParam);
        }
        break;

    case WM_NOTIFY:

        if (IsKeyTree(((LPNMHDR)lParam)->hwndFrom))
        {
            switch (((LPNMHDR)lParam)->code) {
            case TVN_SELCHANGED:

                g_hSelItem = KeyTreeSelChanged (hdlg, (LPNMTREEVIEW)lParam);
                break;

            case TVN_KEYDOWN:

                switch (((LPNMTVKEYDOWN)lParam)->wVKey) {
                case VK_DELETE:
                    return SendMessage (hdlg, WM_COMMAND, MAKEWPARAM (ID_KEY_DELETE, 0), (LPARAM)NULL);
                case VK_INSERT:
                    return SendMessage (hdlg, WM_COMMAND, MAKEWPARAM (ID_KEY_RENAME, 0), (LPARAM)NULL);
                default:
                    return DefWindowProc(hdlg, uMsg, wParam, lParam);
                }
                break;

            case TVN_BEGINDRAG:

                if (InDrag) {
                    KeyTreeEndDrag (FALSE, NULL);
                    InDrag = FALSE;
                }

                if (KeyTreeBeginDrag (hdlg, (LPNMTREEVIEW)lParam)) {
                    InDrag = TRUE;
                }
                break;

            case TVN_ENDLABELEDIT:

                b = (KeyTreeGetIndexOfItem (g_hSelItem) == INVALID_KEY_HANDLE);
                b = FALSE;  // rename is not implemented

                if (((LPNMTVDISPINFO)lParam)->item.pszText) {
                    if (KeyTreeRenameItem (
                        ((LPNMTVDISPINFO)lParam)->item.hItem,
                        ((LPNMTVDISPINFO)lParam)->item.pszText
                        ))
                    {
                        pUpdateFileStatus (hdlg, TRUE);

                        if (b) {
                            if (!KeyTreeCreateEmptyKey (((LPNMTVDISPINFO)lParam)->item.hItem)) {
                                KeyTreeDeleteItem (((LPNMTVDISPINFO)lParam)->item.hItem);
                            }
                        }
                    }
                } else if (b) {
                    //
                    // for some reason the label edit failed, and this is a new
                    // item (meaning we need a label)
                    //
                    AlertBadNewItemName (g_hSelItem, "New keys must have name");
                }

                break;

            case NM_RCLICK:

                KeyTreeSelectRClickItem ();
                KeyTreeRightClick (hdlg, g_hSelItem);

                break;

            default:
                return DefWindowProc(hdlg, uMsg, wParam, lParam);
            }
        } else if (IsDataList (((LPNMHDR)lParam)->hwndFrom)) {
            switch (((LPNMHDR)lParam)->code) {
            case NM_RCLICK:

                if (g_hSelItem) {
                    DataListRightClick (hdlg, ((LPNMITEMACTIVATE)lParam)->ptAction);
                }
                break;

            case NM_DBLCLK:

                if (g_hSelItem) {
                    DataListDblClick (
                        hdlg,
                        ((LPNMITEMACTIVATE)lParam)->iItem,
                        ((LPNMITEMACTIVATE)lParam)->iSubItem
                        );
                }

                break;

            default:
                return DefWindowProc(hdlg, uMsg, wParam, lParam);
            }
        }
        break;

    case WM_CAPTURECHANGED:
        if (InDrag) {
            //
            // something grabbed the capture away from us while
            // we were dragging, so stop dragging without taking
            // any action.
            //
            InDrag = FALSE;
            KeyTreeEndDrag (FALSE, NULL);
        }
        break;

    case WM_MOUSEMOVE:
        if (InDrag) {
            KeyTreeMoveDrag (MAKEPOINTS(lParam));
        }
        break;

    case WM_LBUTTONUP:

        if (InDrag) {
            InDrag = FALSE;
            if (KeyTreeEndDrag (TRUE, &MAKEPOINTS(lParam))) {
                pUpdateFileStatus (hdlg, TRUE);
            }
        }
        break;

    case WM_FILE_LOAD:

        if (pVerifyClose () && pLoadFile ((LPSTR)wParam)) {
            pRefreshView (hdlg);
            pUpdateFileStatus (hdlg, FALSE);
        }
        break;

    case WM_QUIT_CHECK:

        *((PBOOL)wParam) = pVerifyClose ();
        break;

    case WM_SELECT_KEY:

        KeyTreeSelectKey ((UINT)wParam);
        break;

    case WM_DESTROY:
        KeyTreeDestroy ();
        break;

    default:
        return DefWindowProc(hdlg, uMsg, wParam, lParam);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\osver\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\filler\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implements a small utility that fills the disk for purposes of free space
    testing.

Author:

    Jim Schmidt (jimschm) 18-Aug-2000

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include "wininet.h"
#include <lm.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    UtInitialize (NULL);

    return TRUE;
}


VOID
Terminate (
    VOID
    )
{
    UtTerminate ();
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        "  filler <free_space> [/D:<drive>] [/C:<cmdline> [/M]]\n"
        "  filler /Q [/D:<drive>]\n"

        "\nDescription:\n\n"

        "  filler creates a file (bigfile.dat) on the current or specified\n"
        "  drive, leaving only the specified amount of free space on the drive.\n"

        "\nArguments:\n\n"

        "  free_space   Specifies the amount of free space to leave on\n"
        "               disk.\n"
        "  /D           Specifies the drive letter to fill (i.e. /D:C)\n"
        "  /Q           Queries the free space on the disk\n"
        "  /C           Executes command line specified in <cmdline>\n"
        "  /M           Issue message box if command line alters disk space\n"

        );

    exit (1);
}

INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    TCHAR drive;
    TCHAR curDir[MAX_PATH];
    LONGLONG freeSpace = -1;
    PCTSTR p;
    BOOL qSpecified = FALSE;
    PCTSTR cmdLine = NULL;
    BOOL mSpecified = FALSE;

    GetCurrentDirectory (ARRAYSIZE(curDir), curDir);
    drive = 0;

    //
    // TODO: Parse command line here
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('d'):
                if (drive) {
                    HelpAndExit();
                }

                if (argv[i][2] == TEXT(':')) {
                    if (!argv[i][3] || argv[i][4]) {
                        HelpAndExit();
                    }

                    drive = argv[i][3];

                } else if (i + 1 < argc) {
                    i++;
                    if (!argv[i][0] || argv[i][1]) {
                        HelpAndExit();
                    }

                    drive = argv[i][0];
                } else {
                    HelpAndExit();
                }

                if (!_istalpha (drive)) {
                    HelpAndExit();
                }

                break;

            case TEXT('c'):
                if (cmdLine) {
                    HelpAndExit();
                }

                if (argv[i][2] == TEXT(':')) {
                    if (!argv[i][3]) {
                        HelpAndExit();
                    }

                    cmdLine = &argv[i][3];
                } else if (i + 1 < argc) {
                    i++;
                    if (!argv[i][0]) {
                        HelpAndExit();
                    }

                    cmdLine = argv[i];
                } else {
                    HelpAndExit();
                }

                break;

            case TEXT('m'):
                if (mSpecified) {
                    HelpAndExit();
                }

                mSpecified = TRUE;
                break;

            case TEXT('q'):
                if (qSpecified || freeSpace != -1) {
                    HelpAndExit();
                }

                qSpecified = TRUE;
                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            if (qSpecified || freeSpace != -1) {
                HelpAndExit();
            }

            freeSpace = StringToInt64 (argv[i], &p);

            if (*p != 0 || freeSpace < 0) {
                HelpAndExit();
            }
        }
    }

    if (cmdLine && qSpecified) {
        HelpAndExit();
    }

    if (mSpecified && !cmdLine) {
        HelpAndExit();
    }

    if (!drive) {
        drive = curDir[0];
    }

    if (!qSpecified) {

        if (freeSpace == -1) {
            HelpAndExit();
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    printf ("---------------------------------------------------------\n");

    //
    // Do work here
    //
    {
        HANDLE file;
        TCHAR path[] = TEXT("?:\\bigfile.dat");
        TCHAR rootDir[] = TEXT("?:\\");
        ULARGE_INTEGER freeBytes;
        ULARGE_INTEGER totalBytes;
        ULARGE_INTEGER totalFreeBytes;
        ULARGE_INTEGER freeBytesAfter;
        ULARGE_INTEGER totalBytesAfter;
        ULARGE_INTEGER totalFreeBytesAfter;
        BOOL b;
        HANDLE h;

        path[0] = drive;
        rootDir[0] = drive;

        if (qSpecified) {
            b = GetDiskFreeSpaceEx (rootDir, &freeBytes, &totalBytes, &totalFreeBytes);

            if (b) {
                _ftprintf (stderr, TEXT("Drive %c has %I64u bytes free\n"), drive, freeBytes.QuadPart);
            } else {
                _ftprintf (stderr, TEXT("Can't get free space from drive %c\n"), drive);
            }
        } else {

            _tprintf (TEXT("FILLER: Deleting %s..."), path);

            SetFileAttributes (path, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (path);

            printf ("\n");

            b = GetDiskFreeSpaceEx (rootDir, &freeBytes, &totalBytes, &totalFreeBytes);

            if (b) {

                if (freeBytes.QuadPart <= (ULONGLONG) freeSpace) {
                    _ftprintf (stderr, TEXT("ERROR: Drive %c only has %I64u bytes available\n"), drive, freeBytes.QuadPart);
                    b = FALSE;
                }
            }

            if (b) {

                file = BfCreateFile (path);
                if (!file) {
                    _ftprintf (stderr, TEXT("ERROR: Can't create file %s\n"), path);
                } else {
                    printf ("FILLER: Allocating disk space...");

                    GetDiskFreeSpaceEx (rootDir, &freeBytes, &totalBytes, &totalFreeBytes);

                    freeBytes.QuadPart -= (ULONGLONG) freeSpace;
                    if (!BfSetFilePointer (file, freeBytes.QuadPart)) {
                        DEBUGMSG ((DBG_ERROR, "BfSetFilePointer failed"));
                    }

                    if (!SetEndOfFile (file)) {
                        DEBUGMSG ((DBG_ERROR, "SetEndOfFile failed"));
                    }
                    CloseHandle (file);

                    printf ("done\n");

                    b = GetDiskFreeSpaceEx (rootDir, &freeBytes, &totalBytes, &totalFreeBytes);

                    if (b) {
                        _ftprintf (stderr, TEXT("FILLER: Drive %c now has %I64u bytes available\n"), drive, freeBytes.QuadPart);
                    } else {
                        fprintf (stderr, "ERROR: Can't get free space again.\n");
                    }

                    if (cmdLine) {

                        h = StartProcess (cmdLine);

                        if (!h) {
                            _ftprintf (stderr, TEXT("\nERROR: Can't start process %s\n"), cmdLine);
                        } else {

                            _tprintf (TEXT("FILLER: Running\n\n  %s\n\n"), cmdLine);

                            WaitForSingleObject (h, INFINITE);
                            CloseHandle (h);

                            printf ("\n\nFILLER: Process done.\n");

                            b = GetDiskFreeSpaceEx (rootDir, &freeBytesAfter, &totalBytesAfter, &totalFreeBytesAfter);

                            if (b) {
                                _ftprintf (stderr, TEXT("FILLER: Drive %c has %I64u bytes available after cmdline\n"), drive, freeBytesAfter.QuadPart);

                                if (freeBytesAfter.QuadPart != freeBytes.QuadPart) {
                                    if (!mSpecified) {
                                        fprintf (stderr, "\nWARNING: Command line altered disk space\n\n");
                                    } else {
                                        TCHAR msg[1024];

                                        _stprintf (msg, "Command line altered disk space:\n\n%s\n\nSize: %I64i", cmdLine, freeSpace);
                                        MessageBox (NULL, msg, TEXT("filler.exe"), MB_OK);
                                    }
                                }
                            } else {
                                fprintf (stderr, "ERROR: Can't get free space again.\n");
                            }
                        }
                    }
                }
            } else {
                _ftprintf (stderr, TEXT("ERROR: Can't get free space for drive %c\n"), drive);
            }
        }
    }

    printf ("---------------------------------------------------------\n\n");

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\dbedit\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by memdbe.rc
//
#define IDI_ICON_SPHERE                 101
#define IDD_DIALOG_ABOUT                102
#define IDD_DIALOG_CHILD                105
#define IDR_MENU_MAIN                   106
#define IDB_BITMAP_KEY                  107
#define IDB_BITMAP_KEYSEL               108
#define IDR_ACCELERATOR                 110
#define IDR_MENU_POPUP                  111
#define IDD_DIALOG_SHORTDATA            112
#define IDD_DIALOG_KEYFIND              113
#define IDD_DIALOG_LINKAGE              114
#define IDD_DIALOG_CREATEKEY            115
#define IDC_LIST_DATA                   1003
#define IDC_TREE_KEY                    1004
#define IDC_BUTTON_EXPANDALL            1005
#define IDC_BUTTON_COLLAPSEALL          1006
#define IDC_BUTTON_REFRESH              1008
#define IDC_RADIO_DEC                   1015
#define IDC_RADIO_HEX                   1016
#define IDC_EDIT_DATA                   1017
#define IDC_EDIT_KEYPATTERN             1020
#define IDC_EDIT_FILTERPATTERN          1021
#define IDC_BUTTON_APPLYFILTER          1022
#define IDC_BUTTON_SHOWALL              1023
#define IDC_STATIC_KEYNAME              1024
#define IDC_EDIT_KEYNAMEHIDDEN          1026
#define IDC_EDIT_KEY1                   1027
#define IDC_EDIT_KEY2                   1028
#define IDC_CHECK_USEPATTERN            1031
#define IDC_EDIT_KEY                    1032
#define IDC_RADIO_SETDATA               1033
#define IDC_RADIO_ADDDATA               1034
#define ID_HELP_ABOUT                   40001
#define ID_QUIT                         40002
#define ID_FILE_NEW                     40003
#define ID_FILE_LOAD                    40004
#define ID_FILE_SAVE                    40005
#define ID_FILE_QUIT                    40006
#define ID_FILE_SAVEAS                  40007
#define ID_FILE_REVERT                  40008
#define ID_KEY_CREATECHILD              40009
#define ID_KEY_DELETEITEM               40010
#define ID_KEY_DELETE                   40011
#define ID_KEY_PARSEPATHS               40012
#define ID_KEY_ADDDATA                  40013
#define ID_DATA_ADDVALUE                40014
#define ID_DATA_ADDFLAGS                40015
#define ID_DATA_ADDBINARYDATA           40016
#define ID_DATA_ADDLINKAGE              40018
#define ID_KEY_RENAME                   40019
#define ID_KEY_CLEARDATA                40020
#define ID_KEY_FIND                     40021
#define ID_KEY_FINDNEXT                 40022
#define ID_KEY_COPYNAME                 40023
#define ID_KEY_CREATELINKAGE            40024
#define ID_KEY_CREATENEW                40032
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40033
#define _APS_NEXT_CONTROL_VALUE         1034
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\regenum\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\fileenum\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    <TODO: fill in abstract>

Author:

    TODO: <full name> (<alias>) <date>

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include <conio.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    //
    // Initialize the common libs
    //

    if (Reason == DLL_PROCESS_ATTACH) {
        UtInitialize (NULL);
        if (!FileEnumInitialize ()) {
            return FALSE;
        }

    } else {
        FileEnumTerminate ();
        UtTerminate ();
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        //
        // TODO: Describe command line syntax(es), indent 2 spaces
        //

        "  fileenum [/N] [/S] [/W] [/F] [/L:MaxSubLevel] [/X] <NodePattern> <LeafPattern>\n"

        "\nDescription:\n\n"

        //
        // TODO: Describe tool, indent 2 spaces
        //

        "  Enumerates the part of file system that matches <Pattern>.\n"
        "  Uses C:\\exclude.inf if present and /X not specified to determine what paths/files\n"
        "  are excluded.\n"

        "\nArguments:\n\n"

        //
        // TODO: Describe args, indent 2 spaces, say optional if necessary
        //

        "  /N  Specifies exclusion of directory names from enumeration; optional\n"
        "  /S  Specifies sub-directories to be enumerated before files for any dir; optional\n"
        "  /W  Specifies enumeration should be width-first; optional\n"
        "  /F  Specifies output should use \"dir <filename>\" format; optional\n"
        "  /L:MaxSubLevel  Specifies the maximum sub-level starting from the root of enum;\n"
        "                  -1 = all levels, 0 = only the root level etc.; optional\n"
        "  /X  Specifies to use exclusions in C:\\exclude.inf; optional\n"
        "  <NodePattern>  Specifies the dir pattern\n"
        "  <LeafPattern>  Specifies the file pattern\n"

        );

    exit (1);
}


BOOL
BuildExclusionList (
    IN      PCTSTR FileName
    )
{
    HINF h;
    INFCONTEXT ic;
    TCHAR buf[256];

    h = SetupOpenInfFile (FileName, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    if (SetupFindFirstLine (h, TEXT("Paths"), NULL, &ic)) {
        do {
            if (SetupGetStringField (&ic, 0, buf, DWSIZEOF (buf) / DWSIZEOF (TCHAR), NULL)) {
                ElAdd (ELT_PATH, buf);
            }
        } while (SetupFindNextLine (&ic, &ic));
    }
    if (SetupFindFirstLine (h, TEXT("Files"), NULL, &ic)) {
        do {
            if (SetupGetStringField (&ic, 0, buf, DWSIZEOF (buf) / DWSIZEOF (TCHAR), NULL)) {
                ElAdd (ELT_FILE, buf);
            }
        } while (SetupFindNextLine (&ic, &ic));
    }
    SetupCloseInfFile (h);
    return TRUE;
}

BOOL
FileEnumCallback (
    IN      PDIRNODE DirNode        OPTIONAL
    )
{
    BOOL b;

    if (!DirNode) {
        _ftprintf (stderr, TEXT("\nOut of memory\n"));
        return FALSE;
    }
    _ftprintf (stderr, TEXT("Error creating dir node: %s; continue anyway ? (yn):"), DirNode->DirName);
    b = _totupper(_getche ()) == TEXT('Y');
    _ftprintf (stderr, TEXT("\n"));
    return b;
}

INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR nodePattern = NULL;
    PCTSTR leafPattern = NULL;
    PTSTR encodedPattern = NULL;
    PTSTR p;
    PCTSTR level;
    BOOL enumDirNames = TRUE;
    BOOL filesFirst = TRUE;
    BOOL depthFirst = TRUE;
    BOOL nativeFormat = TRUE;
    UINT maxSubLevel = -1;
    BOOL exclusions = FALSE;
    INT pos;
    FILETREE_ENUM e;

    //
    // TODO: Parse command line here
    //
    if (argc < 2) {
        HelpAndExit ();
    }

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('x'):
                exclusions = TRUE;
                break;
            case TEXT('n'):
                enumDirNames = FALSE;
                break;
            case TEXT('s'):
                filesFirst = FALSE;
                break;
            case TEXT('w'):
                depthFirst = FALSE;
                break;
            case TEXT('f'):
                nativeFormat = FALSE;
                break;
            case TEXT('l'):
                if (argv[i][2] == TEXT(':')) {
                    level = &argv[i][3];
                } else if (i + 1 < argc) {
                    level = argv[++i];
                } else {
                    HelpAndExit();
                }
                if (!_stscanf (level, TEXT("%ld%n"), &maxSubLevel, &pos) || level[pos]) {
                    HelpAndExit();
                }
                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            if (nodePattern || leafPattern) {
                HelpAndExit();
            }
            nodePattern = argv[i];
            if (*nodePattern == TEXT('\"')) {
                nodePattern++;
                p = _tcsdec2 (nodePattern, GetEndOfString (nodePattern));
                if (p && *p == TEXT('\"')) {
                    *p = 0;
                }
            }
            leafPattern = argv[i+1];
            i++;
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 2;
    }

    //
    // TODO: Do work here
    //

    if (exclusions) {
        BuildExclusionList (TEXT("C:\\exclude.inf"));
    }

    encodedPattern = ObsBuildEncodedObjectStringEx (nodePattern, leafPattern, FALSE);

    if (EnumFirstFileInTreeEx (
            &e,
            encodedPattern,
            DRIVEENUM_ALLVALID,
            enumDirNames,
            filesFirst,
            depthFirst,
            maxSubLevel,
            exclusions,
            FileEnumCallback
            )) {
        do {
            _putts (nativeFormat ? e.NativeFullName : e.EncodedFullName);
        } while (EnumNextFileInTree (&e));
    }

    //
    // End of processing
    //

    if (exclusions) {
        ElRemoveAll ();
    }

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\ssstub\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\lsstub\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implements a small utility that fills the disk for purposes of free space
    testing.

Author:

    Jim Schmidt (jimschm) 18-Aug-2000

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include "wininet.h"
#include <lm.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    UtInitialize (NULL);

    return TRUE;
}


VOID
Terminate (
    VOID
    )
{
    UtTerminate ();
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        "  filler <free_space> [/D:<drive>] [/C:<cmdline> [/M]]\n"
        "  filler /Q [/D:<drive>]\n"

        "\nDescription:\n\n"

        "  filler creates a file (bigfile.dat) on the current or specified\n"
        "  drive, leaving only the specified amount of free space on the drive.\n"

        "\nArguments:\n\n"

        "  free_space   Specifies the amount of free space to leave on\n"
        "               disk.\n"
        "  /D           Specifies the drive letter to fill (i.e. /D:C)\n"
        "  /Q           Queries the free space on the disk\n"
        "  /C           Executes command line specified in <cmdline>\n"
        "  /M           Issue message box if command line alters disk space\n"

        );

    exit (1);
}

INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    TCHAR curDir[MAX_PATH];
    TCHAR curFileS[MAX_PATH];
    TCHAR curFileD[MAX_PATH];
    PCTSTR cmdLine = NULL;
    PCTSTR cmdPtr = NULL;
    TCHAR newCmdLine[MAX_PATH];

    GetCurrentDirectory (ARRAYSIZE(curDir), curDir);
    cmdLine = GetCommandLine ();
    if (!cmdLine) {
        _tprintf ("Error while getting the command line.\n");
        exit (-1);
    }
    cmdPtr = _tcsstr (cmdLine, TEXT("loadstate"));
    if (!cmdPtr) {
        _tprintf ("Error while getting the command line.\n");
        exit (-1);
    }
    StringCopyAB (newCmdLine, cmdLine, cmdPtr);
    StringCat (newCmdLine, TEXT("loadstate_u.exe"));
    cmdPtr = _tcschr (cmdPtr, TEXT(' '));
    if (!cmdPtr) {
        _tprintf ("Error while getting the command line.\n");
        exit (-1);
    }
    StringCat (newCmdLine, cmdPtr);

    //
    // Begin processing
    //

    if (!Init()) {
        exit (-1);
    }

    //
    // Do work here
    //
    {
        BOOL result = FALSE;
        STARTUPINFO startupInfo;
        PROCESS_INFORMATION processInformation;
        DWORD exitCode = -1;

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("guitrn_u.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("guitrn.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("unctrn_u.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("unctrn.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("script_u.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("script.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("sysmod_u.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("sysmod.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("migism_u.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("migism.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        ZeroMemory (&startupInfo, sizeof (STARTUPINFO));
        startupInfo.cb = sizeof (STARTUPINFO);
        ZeroMemory (&processInformation, sizeof (PROCESS_INFORMATION));

        result = CreateProcess (
                    NULL,
                    newCmdLine,
                    NULL,
                    NULL,
                    FALSE,
                    0,
                    NULL,
                    NULL,
                    &startupInfo,
                    &processInformation
                    );

        if (result && processInformation.hProcess && (processInformation.hProcess != INVALID_HANDLE_VALUE)) {
            WaitForSingleObject (processInformation.hProcess, INFINITE);
            if (!GetExitCodeProcess (processInformation.hProcess, &exitCode)) {
                exitCode = -1;
            }
            exit (exitCode);
        }
    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\template\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\icontool\icontool.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    icontool.c

Abstract:

    Tool to extract icons from ICO, PE and NE files and to write them
    to an ICO or PE file

Author:

    Calin Negreanu (calinn) 16 June 2000

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        UtInitialize (NULL);
        FileEnumInitialize ();
        LogReInit (NULL, NULL, NULL, NULL);
        break;
    case DLL_PROCESS_DETACH:
        FileEnumTerminate ();
        UtTerminate ();
        break;
    }
    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
pHelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        //
        // Describe command line syntax(es), indent 2 spaces
        //

        "  icontool [/D:<destination file>] <node pattern> <leaf pattern>\n"

        "\nDescription:\n\n"

        //
        // Describe tool, indent 2 spaces
        //

        "  Extracts icon groups from ICO, PE and NE files specified <node pattern> and\n"
        "  <leaf pattern>. Optionally writes the extracted icons to either a PE file or\n"
        "  a sequence of ICO files.\n"

        "\nArguments:\n\n"

        //
        // Describe args, indent 2 spaces, say optional if necessary
        //

        "  /D:<destination file> - Specifies the destination file where all extracted icons\n"
        "                          are going to be written. It's either a PE file specification\n"
        "                          or a sequence of ICO files with %%d in name (like icon%%04d.ico)\n"
        "  <node pattern>  Specifies the directory pattern (like c:\\foo*\\bar?\\*)\n"
        "  <leaf pattern>  Specifies the file pattern (like abc*.exe)\n"
        );

    exit (1);
}

BOOL
pGetFilePath (
    IN      PCSTR UserSpecifiedFile,
    OUT     PTSTR Buffer,
    IN      UINT BufferTchars
    )
{
    PSTR tempBuffer = NULL;
    CHAR modulePath[MAX_MBCHAR_PATH];
    CHAR currentDir[MAX_MBCHAR_PATH];
    PSTR p;
    PCSTR userFile = NULL;
    PSTR dontCare;

    __try {
        //
        // Locate the file using the full path specified by the user, or
        // if only a file spec was given, use the following priorities:
        //
        // 1. Current directory
        // 2. Directory where the tool is
        //
        // In all cases, return the full path to the file.
        //

        tempBuffer = AllocTextA (BufferTchars);
        *tempBuffer = 0;

        if (!_mbsrchr (UserSpecifiedFile, '\\')) {

            if (!GetModuleFileNameA (NULL, modulePath, ARRAYSIZE(modulePath))) {
                MYASSERT (FALSE);
                return FALSE;
            }

            p = _mbsrchr (modulePath, '\\');
            if (p) {
                *p = 0;
            } else {
                MYASSERT (FALSE);
                return FALSE;
            }

            if (!GetCurrentDirectoryA (ARRAYSIZE(currentDir), currentDir)) {
                MYASSERT (FALSE);
                return FALSE;
            }

            //
            // Let's see if it's in the current dir
            //

            userFile = JoinPathsA (currentDir, UserSpecifiedFile);

            if (DoesFileExistA (userFile)) {
                GetFullPathNameA (
                    userFile,
                    BufferTchars,
                    tempBuffer,
                    &dontCare
                    );
            } else {

                //
                // Let's try the module dir
                //

                FreePathStringA (userFile);
                userFile = JoinPathsA (modulePath, UserSpecifiedFile);

                if (DoesFileExistA (userFile)) {
                    GetFullPathNameA (
                        userFile,
                        BufferTchars,
                        tempBuffer,
                        &dontCare
                        );
                }
            }

        } else {
            //
            // Use the full path that the user specified
            //

            GetFullPathNameA (
                UserSpecifiedFile,
                BufferTchars,
                tempBuffer,
                &dontCare
                );
        }

        //
        // Transfer output into caller's buffer.  Note the TCHAR conversion.
        //

#ifdef UNICODE
        KnownSizeAtoW (Buffer, tempBuffer);
#else
        StringCopy (Buffer, tempBuffer);
#endif

    }
    __finally {
        if (userFile) {
            FreePathStringA (userFile);
        }

        FreeTextA (tempBuffer);
    }

    return *Buffer != 0;
}

PCTSTR
pGetIconFileType (
    IN      DWORD FileType
    )
{
    switch (FileType) {
    case ICON_ICOFILE:
        return TEXT("ICO File");
    case ICON_PEFILE:
        return TEXT("PE  File");
    case ICON_NEFILE:
        return TEXT("NE  File");
    }
    return TEXT("UNKNOWN ");
}

INT
__cdecl
_tmain (
    INT Argc,
    PCTSTR Argv[]
    )
{
    INT i;
    PCTSTR nodePattern = NULL;
    PCTSTR leafPattern = NULL;
    PTSTR encodedPattern = NULL;
    PCSTR destFile = NULL;
    PSTR p;
    TCHAR destPath[MAX_PATH_PLUS_NUL];
    TCHAR destIcoPath[MAX_PATH_PLUS_NUL];
    FILETREE_ENUM e;
    ICON_ENUM iconEnum;
    PCSTR resourceId;
    DWORD totalIcons = 0;
    DWORD fileIcons = 0;
    DWORD fileType = 0;

    if (!Init()) {
        return 0;
    }

    for (i = 1 ; i < Argc ; i++) {
        if (Argv[i][0] == TEXT('/') || Argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&Argv[i][1]))) {

            case TEXT('d'):

                if (Argv[i][2] == TEXT(':')) {
                    destFile = &Argv[i][3];
                } else if (i + 1 < Argc) {
                    i++;
                    destFile = Argv[i];
                } else {
                    pHelpAndExit();
                }

                if (!pGetFilePath (destFile, destPath, ARRAYSIZE(destPath))) {
                    destPath [0] = 0;
                    break;
                }
                break;

            default:
                pHelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            if (nodePattern || leafPattern) {
                pHelpAndExit();
            }
            nodePattern = Argv[i];
            if (*nodePattern == TEXT('\"')) {
                nodePattern++;
                p = _tcsdec2 (nodePattern, GetEndOfString (nodePattern));
                if (p && *p == TEXT('\"')) {
                    *p = 0;
                }
            }
            leafPattern = Argv[i+1];
            i++;
        }
    }

    if (!nodePattern) {
        pHelpAndExit ();
    }

    if (!leafPattern) {
        pHelpAndExit ();
    }

    //
    // Begin processing
    //

    encodedPattern = ObsBuildEncodedObjectStringEx (nodePattern, leafPattern, FALSE);

    if (EnumFirstFileInTree (&e, encodedPattern)) {
        // at this point, if we don't have a valid updateHandle and moduleHandle
        // we will assume that the destination specification is a sequence of ICO files.
        do {
            fileIcons = 0;
            if (IcoEnumFirstIconGroupInFile (e.NativeFullName, &iconEnum)) {
                fileType = iconEnum.FileType;
                do {
                    if (destPath [0]) {
                        if (fileIcons == 0x0b) {
                        } else {
                        if (!IcoWriteIconGroupToPeFile (destPath, iconEnum.IconGroup, &resourceId, NULL)) {
                            wsprintf (destIcoPath, destPath, totalIcons);
                            if (!IcoWriteIconGroupToIcoFile (destIcoPath, iconEnum.IconGroup, TRUE)) {
                                printf ("Error writing icon group to destination file %s\n", destPath);
                            }
                        }
                        }
                    }
                    totalIcons ++;
                    fileIcons ++;
                } while (IcoEnumNextIconGroupInFile (&iconEnum));
                IcoAbortEnumIconGroup (&iconEnum);
            }
            if (fileIcons) {
                printf ("[%6u],[%6u] [%8s] %s\n", totalIcons, fileIcons, pGetIconFileType (fileType), e.NativeFullName);
            }
        } while (EnumNextFileInTree (&e));
    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\osver\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    <TODO: fill in abstract>

Author:

    TODO: <full name> (<alias>) <date>

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include "wininet.h"
#include <lm.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        UtInitialize (NULL);
        break;
    case DLL_PROCESS_DETACH:
        UtTerminate ();
        break;
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR FileArg;

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    {
        OSVERSIONINFO versionInfo;

        ZeroMemory (&versionInfo, sizeof (OSVERSIONINFO));
        versionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

        if (GetVersionEx (&versionInfo)) {
            printf ("OS version information:\n");
            printf ("OS major version no    :%d\n", versionInfo.dwMajorVersion);
            printf ("OS minor version no    :%d\n", versionInfo.dwMinorVersion);
            printf ("OS build no            :%d\n", versionInfo.dwBuildNumber);
            printf ("OS platform ID         :%d\n", versionInfo.dwPlatformId);
            printf ("OS string              :%s\n", versionInfo.szCSDVersion);
        } else {
            printf ("Version information could not be retrieved: %d\n", GetLastError ());
        }
    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\homenet\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    homenet.exe is a proof-of-concept tool for the protocol-independent
    home networking transport.

Author:

    Jim Schmidt (jimschm) 01-Jul-2000

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include <initguid.h>
#include <winsock2.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <wsnetbs.h>
#include <nb30.h>

#define TCPIP_BROADCAST_PORT        2048
#define IPX_BROADCAST_PORT          1150
#define NETBIOS_BROADCAST_PORT      0x50

#define TCPIP_CONNECT_PORT          2049
#define IPX_CONNECT_PORT            1151
#define NETBIOS_CONNECT_PORT        0x51

#define MAX_SOCKADDR                (max(sizeof(SOCKADDR_IN),max(sizeof(SOCKADDR_IPX),sizeof(SOCKADDR_NB))))
#define DBG_HOMENET                 "HomeNet"

VOID
pDoSource (
    VOID
    );

VOID
pDoDestination (
    VOID
    );

// 36E4BE8D-0766-46E9-8679-8546529A90EE
DEFINE_GUID(g_MyGuid, 0x36E4BE8D, 0x0766, 0x46e9, 0x86, 0x79, 0X85, 0x46, 0x52, 0X9A, 0x90, 0XEE);

HANDLE g_StopHandle;
HANDLE g_ConnectionDone;
TCHAR g_StoragePath[MAX_PATH];

#pragma pack(push,1)

typedef struct {
    WORD PacketNumber;
    WORD DataLength;
} DATAGRAM_PACKET, *PDATAGRAM_PACKET;

#pragma pack(pop)

typedef struct TAG_DATAGRAM_POOL_ITEM {
    struct TAG_DATAGRAM_POOL_ITEM *Next, *Prev;
    DATAGRAM_PACKET Header;
    PCBYTE PacketData;
    // PacketData follows
} DATAGRAM_POOL_ITEM, *PDATAGRAM_POOL_ITEM;

typedef struct {
    PMHANDLE Pool;
    SOCKET Socket;
    PDATAGRAM_POOL_ITEM FirstItem;
    WORD SendSequenceNumber;
    WORD RecvSequenceNumber;
} DATAGRAM_POOL, *PDATAGRAM_POOL;


BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        UtInitialize (NULL);
        break;
    case DLL_PROCESS_DETACH:
        UtTerminate ();
        break;
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        //
        // Describe command line syntax(es), indent 2 spaces
        //

        "  homenet /S|/D\n"

        "\nDescription:\n\n"

        //
        // Describe tool, indent 2 spaces
        //

        "  HomeNet.exe is a proof-of-concept tool for the home networking transport.\n"

        "\nArguments:\n\n"

        //
        // Describe args, indent 2 spaces, say optional if necessary
        //

        "  /S  Executes the tool in source mode\n"
        "  /D  Executes the tool in destination mode\n"

        );

    exit (1);
}


BOOL
pCtrlCRoutine (
    IN      DWORD CtrlType
    )
{
    SetEvent (g_StopHandle);
    WaitForSingleObject (g_ConnectionDone, INFINITE);

    return FALSE;
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    BOOL destination = FALSE;
    BOOL source = FALSE;
    WSADATA startupData;
    INT result;

    g_StopHandle = CreateEvent (NULL, TRUE, FALSE, NULL);
    g_ConnectionDone = CreateEvent (NULL, TRUE, FALSE, NULL);
    SetConsoleCtrlHandler (pCtrlCRoutine, TRUE);

    //
    // Parse command line here
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('s'):
                if (source || destination) {
                    HelpAndExit();
                }

                source = TRUE;
                break;

            case TEXT('d'):
                if (source || destination) {
                    HelpAndExit();
                }

                destination = TRUE;
                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            // None
            HelpAndExit();
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    //
    // Start sockets
    //

    result = WSAStartup (2, &startupData);

    if (result) {
        printf ("Can't start sockets.  Code=%u\n", result);
        exit (1);
    }

    //
    // Do work
    //

    if (source) {
        pDoSource();
    } else {
        pDoDestination();
    }

    //
    // Shut down sockets
    //

    WSACleanup();

    //
    // End of processing
    //

    Terminate();

    return 0;
}


typedef struct {
    SOCKET Socket;
    BYTE BroadcastAddress[MAX_SOCKADDR];
    INT AddressLen;
    INT Family;
    INT Protocol;
} BROADCASTSOCKET, *PBROADCASTSOCKET;

typedef struct {
    SOCKET Socket;
    INT Family;
    INT Protocol;
    BOOL Datagram;
} LISTENSOCKET, *PLISTENSOCKET;

typedef struct {
    SOCKET Socket;
    BYTE LocalAddress[MAX_SOCKADDR];
    INT LocalAddressLen;
    BYTE RemoteAddress[MAX_SOCKADDR];
    INT RemoteAddressLen;
    INT Family;
    INT Protocol;
    BOOL Datagram;
    DATAGRAM_POOL DatagramPool;
} CONNECTIONSOCKET, *PCONNECTIONSOCKET;

typedef struct {
    BYTE LocalAddress[MAX_SOCKADDR];
    INT LocalAddressLen;
    BYTE RemoteAddress[MAX_SOCKADDR];
    INT RemoteAddressLen;
    INT Family;
    INT Protocol;
    BOOL Datagram;
    TCHAR DestinationName[MAX_COMPUTER_NAME];
} CONNECTADDRESS, *PCONNECTADDRESS;

typedef struct {
    PBROADCASTSOCKET BroadcastSockets;
    INT BroadcastCount;
    PLISTENSOCKET ListenSockets;
    INT ListenCount;
    CONNECTIONSOCKET ConnectionSocket;
    PGROWBUFFER AddressArray;
} BROADCASTARGS, *PBROADCASTARGS;

typedef struct {
    UINT StructSize;
    UINT FileCount;
    LONGLONG TotalSize;
} TRANSFERMETRICS, *PTRANSFERMETRICS;




PBROADCASTSOCKET
pOpenOneBroadcastSocket (
    IN OUT  PGROWBUFFER BroadcastSockets,
    IN      SOCKADDR *SockAddr,
    IN      INT SockAddrLen,
    IN      INT Family,
    IN      INT Protocol,
    IN      PCTSTR DebugText
    )
{
    PBROADCASTSOCKET broadcastSocket;
    BOOL b;

    broadcastSocket = (PBROADCASTSOCKET) GbGrow (BroadcastSockets, sizeof (BROADCASTSOCKET));
    broadcastSocket->Socket = socket (Family, SOCK_DGRAM, Protocol);

    if (broadcastSocket->Socket != INVALID_SOCKET) {

        b = TRUE;
        setsockopt (broadcastSocket->Socket, SOL_SOCKET, SO_BROADCAST, (PBYTE) &b, sizeof (b));
        setsockopt (broadcastSocket->Socket, SOL_SOCKET, SO_REUSEADDR, (PBYTE) &b, sizeof (b));

        if (bind (broadcastSocket->Socket, SockAddr, SockAddrLen)) {
            DEBUGMSG ((DBG_ERROR, "Can't bind to %s socket", DebugText));
            closesocket (broadcastSocket->Socket);
            broadcastSocket->Socket = INVALID_SOCKET;
        }
    }

    if (broadcastSocket->Socket == INVALID_SOCKET) {
        BroadcastSockets->End -= sizeof (BROADCASTSOCKET);
        broadcastSocket = NULL;
    } else {
        DEBUGMSG ((
            DBG_HOMENET,
            "%s is available for broadcast on socket %u",
            DebugText,
            (BroadcastSockets->End / sizeof (BROADCASTSOCKET)) - 1
            ));

        broadcastSocket->AddressLen = SockAddrLen;
        MYASSERT (SockAddrLen <= MAX_SOCKADDR);
        CopyMemory (broadcastSocket->BroadcastAddress, (PBYTE) SockAddr, SockAddrLen);
        broadcastSocket->Family = Family;
        broadcastSocket->Protocol = Protocol;
    }

    return broadcastSocket;
}


INT
pOpenBroadcastSockets (
    OUT     PGROWBUFFER BroadcastSockets
    )
{
    SOCKADDR_IPX ipxAddr;
    SOCKADDR_IN tcpipAddr;
    SOCKADDR_NB netbiosAddr;
    NCB ncbEnum;
    LANA_ENUM leBuf;
    INT rc;
    INT i;
    PBROADCASTSOCKET broadcastSocket;
    BOOL b;
    TCHAR netbiosDebugText[32];

    MYASSERT (!BroadcastSockets->Buf && !BroadcastSockets->End);

    //
    // Open sockets for broadcasts
    //

    // IPX
    ZeroMemory (&ipxAddr, sizeof (ipxAddr));
    ipxAddr.sa_family = AF_IPX;
    memset (ipxAddr.sa_nodenum, 0xFF, 6);
    ipxAddr.sa_socket = IPX_BROADCAST_PORT;

    pOpenOneBroadcastSocket (
        BroadcastSockets,
        (SOCKADDR *) &ipxAddr,
        sizeof (ipxAddr),
        AF_IPX,
        NSPROTO_IPX,
        TEXT("IPX")
        );

    // TCP/IP
    ZeroMemory (&tcpipAddr, sizeof (tcpipAddr));
    tcpipAddr.sin_family = AF_INET;
    tcpipAddr.sin_addr.s_addr = htonl (INADDR_ANY);
    tcpipAddr.sin_port = TCPIP_BROADCAST_PORT;

    broadcastSocket = pOpenOneBroadcastSocket (
                            BroadcastSockets,
                            (SOCKADDR *) &tcpipAddr,
                            sizeof (tcpipAddr),
                            AF_INET,
                            IPPROTO_UDP,
                            TEXT("UDP")
                            );

    if (broadcastSocket) {
        tcpipAddr.sin_addr.s_addr = htonl (INADDR_BROADCAST);
        CopyMemory (broadcastSocket->BroadcastAddress, &tcpipAddr, sizeof (tcpipAddr));
    }

    // NetBIOS
    ZeroMemory (&ncbEnum, sizeof (NCB));
    ncbEnum.ncb_command = NCBENUM;
    ncbEnum.ncb_buffer = (PBYTE) &leBuf;
    ncbEnum.ncb_length = sizeof (LANA_ENUM);

    rc = Netbios (&ncbEnum);

    if (rc == NRC_GOODRET) {

        for (i = 0 ; i < leBuf.length  ; i++) {
            SET_NETBIOS_SOCKADDR (&netbiosAddr, NETBIOS_GROUP_NAME, "usmt", NETBIOS_BROADCAST_PORT);

            wsprintf (netbiosDebugText, TEXT("NETBIOS cli lana %u"), leBuf.lana[i]);
            pOpenOneBroadcastSocket (
                BroadcastSockets,
                (SOCKADDR *) &netbiosAddr,
                sizeof (netbiosAddr),
                AF_NETBIOS,
                -leBuf.lana[i],
                netbiosDebugText
                );
        }

    }

    return BroadcastSockets->End / sizeof (BROADCASTSOCKET);
}


PLISTENSOCKET
pOpenOneListenSocket (
    IN OUT  PGROWBUFFER ListenSockets,
    IN      SOCKADDR *SockAddr,
    IN      INT SockAddrLen,
    IN      INT Family,
    IN      BOOL Multicast,
    IN      INT Protocol,
    IN      PCTSTR DebugText
    )
{
    PLISTENSOCKET listenSocket;
    BOOL b;

    listenSocket = (PLISTENSOCKET) GbGrow (ListenSockets, sizeof (LISTENSOCKET));
    listenSocket->Socket = socket (Family, Multicast ? SOCK_DGRAM : SOCK_STREAM, Protocol);
    listenSocket->Datagram = Multicast;
    listenSocket->Family = Family;
    listenSocket->Protocol = Protocol;

    if (listenSocket->Socket != INVALID_SOCKET) {

        b = TRUE;
        setsockopt (listenSocket->Socket, SOL_SOCKET, SO_REUSEADDR, (PBYTE) &b, sizeof (b));

        if (Multicast) {
            setsockopt (listenSocket->Socket, SOL_SOCKET, SO_BROADCAST, (PBYTE) &b, sizeof (b));
        }

        if (bind (listenSocket->Socket, SockAddr, SockAddrLen) ||
            (!Multicast && listen (listenSocket->Socket, 1))
            ) {
            DEBUGMSG ((DBG_ERROR, "Can't bind/listen to %s socket", DebugText));
            closesocket (listenSocket->Socket);
            listenSocket->Socket = INVALID_SOCKET;
        }
    }

    if (listenSocket->Socket == INVALID_SOCKET) {
        ListenSockets->End -= sizeof (LISTENSOCKET);
        listenSocket = NULL;
    } else {
        DEBUGMSG ((
            DBG_HOMENET,
            "%s is availble for connection on socket %u",
            DebugText,
            (ListenSockets->End / sizeof (LISTENSOCKET)) - 1
            ));
    }

    return listenSocket;
}


INT
pOpenListenSockets (
    OUT     PGROWBUFFER ListenSockets
    )
{
    SOCKADDR_IPX ipxAddr;
    SOCKADDR_IN tcpipAddr;
    SOCKADDR_NB netbiosAddr;
    NCB ncbEnum;
    LANA_ENUM leBuf;
    INT rc;
    INT i;
    TCHAR netbiosDebugText[32];

    MYASSERT (!ListenSockets->Buf && !ListenSockets->End);

    //
    // Open sockets to accept inbound connections
    //

    // SPX
    ZeroMemory (&ipxAddr, sizeof (ipxAddr));
    ipxAddr.sa_family = AF_IPX;
    ipxAddr.sa_socket = IPX_CONNECT_PORT;

    pOpenOneListenSocket (
        ListenSockets,
        (SOCKADDR *) &ipxAddr,
        sizeof (ipxAddr),
        AF_IPX,
        FALSE,
        NSPROTO_SPX,
        TEXT("SPX")
        );

    // TCP/IP
    ZeroMemory (&tcpipAddr, sizeof (tcpipAddr));
    tcpipAddr.sin_family = AF_INET;
    tcpipAddr.sin_port = TCPIP_CONNECT_PORT;

    pOpenOneListenSocket (
        ListenSockets,
        (SOCKADDR *) &tcpipAddr,
        sizeof (tcpipAddr),
        AF_INET,
        FALSE,
        IPPROTO_TCP,
        TEXT("TCP")
        );

    // NetBIOS
    ZeroMemory (&ncbEnum, sizeof (NCB));
    ncbEnum.ncb_command = NCBENUM;
    ncbEnum.ncb_buffer = (PBYTE) &leBuf;
    ncbEnum.ncb_length = sizeof (LANA_ENUM);

    rc = Netbios (&ncbEnum);

    if (rc == NRC_GOODRET) {

        for (i = 0 ; i < leBuf.length  ; i++) {
            SET_NETBIOS_SOCKADDR (&netbiosAddr, NETBIOS_GROUP_NAME, "usmt", NETBIOS_CONNECT_PORT);
            wsprintf (netbiosDebugText, TEXT("NETBIOS srv lana %u"), leBuf.lana[i]);

            pOpenOneListenSocket (
                ListenSockets,
                (SOCKADDR *) &netbiosAddr,
                sizeof (netbiosAddr),
                AF_NETBIOS,
                TRUE,
                -leBuf.lana[i],
                netbiosDebugText
                );
        }
    }

    return ListenSockets->End / sizeof (LISTENSOCKET);
}

PCTSTR
pGetNameFromMessage (
    IN      PCTSTR Message
    )
{
    PCTSTR p;
    PCTSTR name = NULL;
    INT len;
    CHARTYPE ch;

    if (_tcsprefixcmp (Message, TEXT("usmt-v2,"))) {

        p = Message + 8;
        len = 0;

        while (*p) {

            ch = _tcsnextc (p);
            p = _tcsinc (p);

            if (ch == TEXT(',')) {
                break;
            }

            if (ch < TEXT('0') || ch > TEXT('9')) {
                break;
            }

            len = len * 10 + (ch - TEXT('0'));
        }

        if (ch == TEXT(',') && len < MAX_COMPUTER_NAME) {

            name = p;

            while (*p && len) {
                if (*p < 32) {
                    break;
                }

                p++;
                len--;
            }

            if (len || *p) {
                name = NULL;
            }
        }
    }

    return name;
}


VOID
pTranslateBroadcastAddrToConnectAddr (
    IN      INT Family,
    IN OUT  PINT Protocol,
    IN OUT  PBOOL Datagram,
    IN OUT  SOCKADDR *SockAddr
    )
{
    SOCKADDR_IPX *ipxAddr;
    SOCKADDR_IN *tcpipAddr;
    SOCKADDR_NB *netbiosAddr;

    switch (Family) {

    case AF_INET:
        *Protocol = IPPROTO_TCP;
        tcpipAddr = (SOCKADDR_IN *) SockAddr;
        tcpipAddr->sin_port = TCPIP_CONNECT_PORT;
        break;

    case AF_IPX:
        *Protocol = NSPROTO_SPX;
        ipxAddr = (SOCKADDR_IPX *) SockAddr;
        ipxAddr->sa_socket = IPX_CONNECT_PORT;
        break;

    case AF_NETBIOS:
        netbiosAddr = (SOCKADDR_NB *) SockAddr;
        netbiosAddr->snb_name[NETBIOS_NAME_LENGTH - 1] = NETBIOS_CONNECT_PORT;
        *Datagram = TRUE;
        break;
    }
}


VOID
pResetPort (
    IN      INT Family,
    IN OUT  SOCKADDR *SockAddr
    )
{
    SOCKADDR_IN *tcpipAddr;

    switch (Family) {

    case AF_INET:
        tcpipAddr = (SOCKADDR_IN *) SockAddr;
        tcpipAddr->sin_port = 0;
        break;
    }
}


INT
pSourceBroadcast (
    PBROADCASTARGS Args
    )
{
    INT i;
    INT bytesIn;
    DWORD rc;
    TCHAR message[256];
    UINT size;
    FD_SET set;
    TIMEVAL zero = {0,0};
    INT waitCycle = -1;
    BOOL result = FALSE;
    PCTSTR name;
    PCONNECTADDRESS address;
    PCONNECTADDRESS end;
    PBROADCASTSOCKET broadcastSocket;
    BYTE remoteAddr[MAX_SOCKADDR];
    INT remoteAddrLen;

    for (;;) {
        //
        // Check cancel
        //

        rc = WaitForSingleObject (g_StopHandle, 250);

        if (rc == WAIT_OBJECT_0) {
            result = FALSE;
            break;
        }

        //
        // Check time to live
        //

        if (waitCycle > -1) {
            waitCycle--;

            if (!waitCycle) {
                break;
            }
        }

        //
        // Check for a message
        //

        FD_ZERO (&set);
        for (i = 0 ; i < Args->BroadcastCount ; i++) {
            FD_SET (Args->BroadcastSockets[i].Socket, &set);
        }

        i = select (0, &set, NULL, NULL, &zero);

        if (i > 0) {

            // once we receive something, wait 15 additional seconds for other inbound datagrams
            if (waitCycle == -1) {
                waitCycle = 60;
            }

            for (i = 0 ; i < Args->BroadcastCount ; i++) {

                broadcastSocket = &Args->BroadcastSockets[i];

                if (FD_ISSET (broadcastSocket->Socket, &set)) {

                    remoteAddrLen = MAX_SOCKADDR;

                    bytesIn = recvfrom (
                                    broadcastSocket->Socket,
                                    message,
                                    254,
                                    0,
                                    (SOCKADDR *) remoteAddr,
                                    &remoteAddrLen
                                    );

                    if (bytesIn > (10 * sizeof (TCHAR))) {
                        message[bytesIn] = 0;
                        message[bytesIn + 1] = 0;

                        //
                        // Parse the inbound text.  It must be in the format of
                        //
                        //      usmt-v2,<tchars>,<name>
                        //

                        name = pGetNameFromMessage (message);

                        if (name) {

                            result = TRUE;

                            //
                            // Scan the address list for the name
                            //

                            address = (PCONNECTADDRESS) Args->AddressArray->Buf;
                            end = (PCONNECTADDRESS) (Args->AddressArray->Buf + Args->AddressArray->End);

                            while (address < end) {
                                if (StringIMatch (address->DestinationName, name)) {
                                    if (address->Family == broadcastSocket->Family) {
                                        break;
                                    }
                                }

                                address++;
                            }

                            if (address >= end) {
                                //
                                // New computer name; add to the address list
                                //

                                address = (PCONNECTADDRESS) GbGrow (Args->AddressArray, sizeof (CONNECTADDRESS));

                                address->RemoteAddressLen = remoteAddrLen;
                                CopyMemory (address->RemoteAddress, remoteAddr, remoteAddrLen);

                                address->LocalAddressLen = MAX_SOCKADDR;
                                if (getsockname (
                                        broadcastSocket->Socket,
                                        (SOCKADDR *) address->LocalAddress,
                                        &address->LocalAddressLen
                                        )) {
                                    address->LocalAddressLen = broadcastSocket->AddressLen;
                                    ZeroMemory (address->LocalAddress, broadcastSocket->AddressLen);
                                    DEBUGMSG ((DBG_HOMENET, "Failed to get local socket name; using nul name instead"));
                                }

                                address->Family = broadcastSocket->Family;
                                address->Protocol = broadcastSocket->Protocol;
                                address->Datagram = FALSE;

                                pTranslateBroadcastAddrToConnectAddr (
                                    address->Family,
                                    &address->Protocol,
                                    &address->Datagram,
                                    (SOCKADDR *) &address->RemoteAddress
                                    );

                                StringCopy (address->DestinationName, name);

                                DEBUGMSG ((DBG_HOMENET, "Destination found: %s (protocol %i)", name, address->Family));
                            }
                        }
                        ELSE_DEBUGMSG ((DBG_HOMENET, "garbage found: %s", message));
                    }
                }
            }
        }
    }

    return result ? Args->AddressArray->End / sizeof (CONNECTADDRESS) : 0;
}


BOOL
pDestinationBroadcast (
    PBROADCASTARGS Args
    )
{
    INT i;
    DWORD rc;
    INT socketNum = 0;
    TCHAR message[256];
    TCHAR name[128];
    UINT size;
    FD_SET set;
    TIMEVAL zero = {0,0};
    PBROADCASTSOCKET broadcastSocket;
    BOOL result = FALSE;
    BYTE sockAddr[MAX_SOCKADDR];
    INT sockAddrLen;

    size = MAX_COMPUTER_NAME;
    GetComputerName (name, &size);

    size = wsprintf (message, TEXT("USMT-v2,%u,%s"), TcharCount (name), name);
    size = (size + 1) * sizeof (TCHAR);

    for (;;) {
        //
        // Check cancel
        //

        rc = WaitForSingleObject (g_StopHandle, 250);

        if (rc == WAIT_OBJECT_0) {
            break;
        }

        //
        // Send out the message
        //

        broadcastSocket = &Args->BroadcastSockets[socketNum];

        i = sendto (
                broadcastSocket->Socket,
                message,
                size,
                0,
                (SOCKADDR *) broadcastSocket->BroadcastAddress,
                broadcastSocket->AddressLen
                );

        if (i == SOCKET_ERROR) {
            DEBUGMSG ((DBG_VERBOSE, "Error sending on socket %u: %u", socketNum, WSAGetLastError()));
        } else {
            DEBUGMSG ((DBG_HOMENET, "Sent data on socket %u", socketNum));
        }

        socketNum++;
        if (socketNum >= Args->BroadcastCount) {
            socketNum = 0;
        }

        //
        // Check for an inbound connection
        //

        FD_ZERO (&set);
        for (i = 0 ; i < Args->ListenCount ; i++) {
            FD_SET (Args->ListenSockets[i].Socket, &set);
        }

        i = select (0, &set, NULL, NULL, &zero);

        if (i > 0) {
            DEBUGMSG ((DBG_HOMENET, "Connection request count = %i", i));
            for (i = 0 ; i < Args->ListenCount ; i++) {
                if (FD_ISSET (Args->ListenSockets[i].Socket, &set)) {

                    Args->ConnectionSocket.RemoteAddressLen = MAX_SOCKADDR;
                    Args->ConnectionSocket.Socket = accept (
                                                        Args->ListenSockets[i].Socket,
                                                        (SOCKADDR *) Args->ConnectionSocket.RemoteAddress,
                                                        &Args->ConnectionSocket.RemoteAddressLen
                                                        );


                    if (Args->ConnectionSocket.Socket != INVALID_SOCKET) {
                        Args->ConnectionSocket.Family = Args->ListenSockets[i].Family;
                        Args->ConnectionSocket.Protocol = Args->ListenSockets[i].Protocol;
                        Args->ConnectionSocket.Datagram = Args->ListenSockets[i].Datagram;

                        ZeroMemory (&Args->ConnectionSocket.DatagramPool, sizeof (DATAGRAM_POOL));
                        if (Args->ConnectionSocket.Datagram) {
                            Args->ConnectionSocket.DatagramPool.Pool = PmCreatePool();
                        }

                        Args->ConnectionSocket.LocalAddressLen = MAX_SOCKADDR;
                        if (getsockname (
                                Args->ConnectionSocket.Socket,
                                (SOCKADDR *) Args->ConnectionSocket.LocalAddress,
                                &Args->ConnectionSocket.LocalAddressLen
                                )) {
                            Args->ConnectionSocket.LocalAddressLen = broadcastSocket->AddressLen;
                            ZeroMemory (Args->ConnectionSocket.LocalAddress, broadcastSocket->AddressLen);
                            DEBUGMSG ((DBG_HOMENET, "Failed to get local socket name; using nul name instead"));
                        }

                        result = TRUE;
                        break;
                    } else {
                        DEBUGMSG ((DBG_ERROR, "select indicated connection, but accept failed"));
                    }
                }
            }

            if (result) {
                break;
            }
        }
    }

    return result;
}


INT
pNameResolver (
    OUT     PGROWBUFFER AddressBuffer,
    IN      BOOL DestinationMode,
    OUT     PCONNECTIONSOCKET ConnectionSocket
    )
{
    INT size;
    BROADCASTARGS args;
    INT i;
    INT result = 0;
    BOOL b;
    BOOL connected = FALSE;
    GROWBUFFER broadcastSockets = INIT_GROWBUFFER;
    GROWBUFFER listenSockets = INIT_GROWBUFFER;
    INT broadcastSocketCount;
    INT listenSocketCount = 0;
    PLISTENSOCKET connection;

    __try {

        //
        // In source mode, we collect datagrams sent by destinations on the network.  After
        // the first datagram is received, collection continues for 15 seconds.  At
        // that point, we have a list of socket addresses, protocol, and destination names.
        //
        // In destination mode, we send out periodic broadcasts, and we wait until a source
        // connects or the cancel event is signaled.
        //

        broadcastSocketCount = pOpenBroadcastSockets (&broadcastSockets);

        if (!broadcastSocketCount) {
            __leave;
        }

        if (DestinationMode) {
            listenSocketCount = pOpenListenSockets (&listenSockets);

            if (!listenSocketCount) {
                DEBUGMSG ((DBG_ERROR, "Able to set up broadcast sockets but not connection sockets"));
                __leave;
            }
        }

        // call mode-specific routine
        ZeroMemory (&args, sizeof (args));

        args.AddressArray = AddressBuffer;
        args.BroadcastSockets = (PBROADCASTSOCKET) broadcastSockets.Buf;
        args.BroadcastCount = broadcastSocketCount;
        args.ListenSockets = (PLISTENSOCKET) listenSockets.Buf;
        args.ListenCount = listenSocketCount;

        b = DestinationMode ? pDestinationBroadcast (&args) : pSourceBroadcast (&args);

        //
        // Clean up all sockets
        //

        for (i = 0 ; i < args.BroadcastCount ; i++) {
            closesocket (args.BroadcastSockets[i].Socket);
        }

        if (DestinationMode) {
            for (i = 0 ; i < args.ListenCount ; i++) {
                closesocket (args.ListenSockets[i].Socket);
            }
        }

        if (b) {
            if (DestinationMode) {
                CopyMemory (ConnectionSocket, &args.ConnectionSocket, sizeof (CONNECTIONSOCKET));
                result = 1;
            } else {
                result = AddressBuffer->End / sizeof (CONNECTADDRESS);
            }
        }
    }
    __finally {
        GbFree (&broadcastSockets);
        GbFree (&listenSockets);
        SetEvent (g_ConnectionDone);
    }

    return result;
}


BOOL
pSendExactData (
    IN      SOCKET Socket,
    IN      PBYTE Data,
    IN      UINT DataLen
    )
{
    INT result;

    result = send (Socket, Data, DataLen, 0);

    return result == (INT) DataLen;
}


BOOL
pSendDatagramData (
    IN      PDATAGRAM_POOL DatagramPool,
    IN      PCBYTE Data,
    IN      UINT DataLen
    )
{
    PDATAGRAM_PACKET header;
    BYTE buffer[512];
    PBYTE dataPtr;
    UINT bytesSent = 0;
    UINT bytesToSend;
    INT result;

    header = (PDATAGRAM_PACKET) buffer;
    dataPtr = (PBYTE) (&header[1]);

    do {

        bytesToSend = DataLen - bytesSent;
        bytesToSend = min (bytesToSend, 256);

        header->PacketNumber = DatagramPool->SendSequenceNumber;
        DatagramPool->SendSequenceNumber++;
        header->DataLength = (WORD) bytesToSend;

        CopyMemory (dataPtr, Data, bytesToSend);

        result = send (
                    DatagramPool->Socket,
                    (PBYTE) header,
                    header->DataLength + sizeof (DATAGRAM_PACKET),
                    0
                    );

        if (result == SOCKET_ERROR) {
            break;
        }

        bytesToSend = (UINT) result - sizeof (DATAGRAM_PACKET);
        Data += bytesToSend;
        bytesSent += bytesToSend;

    } while (bytesSent < DataLen);

    return bytesSent == DataLen;
}


PBYTE
pReceiveExactData (
    IN      SOCKET Socket,
    IN OUT  PGROWBUFFER Buffer,
    IN      UINT BytesToReceive
    )
{
    PBYTE recvBuf;
    PBYTE bufPos;
    UINT bytesSoFar = 0;
    INT result;
    UINT readSize;

    Buffer->End = 0;
    recvBuf = GbGrow (Buffer, BytesToReceive);
    bufPos = recvBuf;

    do {

        readSize = BytesToReceive - bytesSoFar;
        result = recv (Socket, bufPos, (INT) readSize, 0);

        if (result == SOCKET_ERROR) {
            DEBUGMSG ((DBG_ERROR, "Error reading from socket"));
            break;
        }

        bufPos += result;
        bytesSoFar += result;

    } while (bytesSoFar < BytesToReceive);

    MYASSERT (bytesSoFar <= BytesToReceive);

    return bytesSoFar == BytesToReceive ? recvBuf : NULL;
}


BOOL
pReceiveDatagramData (
    IN      PDATAGRAM_POOL DatagramPool,
    IN OUT  PGROWBUFFER Buffer,         OPTIONAL
    OUT     PBYTE AlternateBuffer,      OPTIONAL
    IN      UINT BytesToReceive
    )
{
    PDATAGRAM_POOL_ITEM itemHeader;
    PDATAGRAM_POOL_ITEM prevItem, nextItem;
    BYTE buffer[512];
    PBYTE dataPtr;
    PBYTE recvBuf;
    PBYTE bufPos;
    UINT bytesSoFar = 0;
    UINT bytesLeft;
    INT result;
    UINT readSize;
    PDATAGRAM_POOL_ITEM item;
    UINT newPacketNum;
    UINT currentPacketNum;

    if (Buffer) {
        Buffer->End = 0;
        recvBuf = GbGrow (Buffer, BytesToReceive);
    } else {
        recvBuf = AlternateBuffer;
    }

    bufPos = recvBuf;

    itemHeader = (PDATAGRAM_POOL_ITEM) buffer;
    dataPtr = (PBYTE) (&itemHeader[1]);

    for (;;) {
        //
        // Take all available data out of the pool
        //

        item = DatagramPool->FirstItem;
        bytesLeft = BytesToReceive - bytesSoFar;

        while (item) {

            if (item->Header.PacketNumber == DatagramPool->RecvSequenceNumber) {
                //
                // Two cases:
                //
                // 1. Want entire packet
                // 2. Want partial packet
                //

                if (bytesLeft >= item->Header.DataLength) {
                    // entire packet
                    CopyMemory (bufPos, item->PacketData, item->Header.DataLength);

                    MYASSERT (!item->Prev);
                    if (item->Next) {
                        item->Next->Prev = NULL;
                    }
                    DatagramPool->FirstItem = item->Next;

                    bytesSoFar += item->Header.DataLength;
                    PmReleaseMemory (DatagramPool->Pool, item);

                    DatagramPool->RecvSequenceNumber++;

                } else {
                    // partial packet
                    CopyMemory (bufPos, item->PacketData, bytesLeft);

                    item->PacketData += bytesLeft;
                    item->Header.DataLength -= (WORD) bytesLeft;

                    bytesSoFar += bytesLeft;
                }

                if (BytesToReceive == bytesSoFar) {
                    return TRUE;
                }
            }
        }

        //
        // Data is not available in the pool. Receive one packet and then try again.
        //

        // header
        if (!pReceiveExactData (
                DatagramPool->Socket,
                NULL,
                (PBYTE) &itemHeader->Header,
                sizeof (DATAGRAM_PACKET)
                )) {
            break;
        }

        if (itemHeader->Header.DataLength > 256) {
            break;
        }

        // data
        if (!pReceiveExactData (
                DatagramPool->Socket,
                NULL,
                (PBYTE) dataPtr,
                itemHeader->Header.DataLength
                )) {
            break;
        }

        //
        // Put the packet in the item linked list, sorted by packet number
        //

        item = (PDATAGRAM_POOL_ITEM) PmDuplicateMemory (
                                        DatagramPool->Pool,
                                        (PCBYTE) itemHeader,
                                        itemHeader->Header.DataLength + sizeof (DATAGRAM_PACKET)
                                        );

        item->PacketData = (PBYTE) (&item[1]);

        prevItem = NULL;
        nextItem = DatagramPool->FirstItem;

        while (nextItem) {

            //
            // Account for wrapping; assume a packet number difference no more
            // than 16383 out-of-sequence packets in the queue (about 4M of
            // data)
            //

            if (nextItem->Header.PacketNumber >= 49152 && item->Header.PacketNumber < 16384) {
                newPacketNum = (UINT) item->Header.PacketNumber + 65536;
                currentPacketNum = (UINT) nextItem->Header.PacketNumber;
            } else if (nextItem->Header.PacketNumber < 16384 && item->Header.PacketNumber >= 49152) {
                newPacketNum = (UINT) item->Header.PacketNumber;
                currentPacketNum = (UINT) nextItem->Header.PacketNumber + 65536;
            } else {
                newPacketNum = (UINT) item->Header.PacketNumber;
                currentPacketNum = (UINT) nextItem->Header.PacketNumber;
            }

            if (newPacketNum < currentPacketNum) {
                break;
            }

            prevItem = nextItem;
            nextItem = nextItem->Next;
        }

        item->Next = nextItem;
        item->Prev = prevItem;

        if (!prevItem) {
            DatagramPool->FirstItem = item;
        }
    }

    return bytesSoFar == BytesToReceive;
}


BOOL
pSendFile (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,    OPTIONAL
    IN      PCTSTR LocalFileName,           OPTIONAL
    IN      PCTSTR DestFileName             OPTIONAL
    )
{
    INT len;
    GROWBUFFER data = INIT_GROWBUFFER;
    BOOL result = FALSE;
    HANDLE file = NULL;
    LONGLONG fileSize;

    __try {
        //
        // If no file was specified, send length of zero
        //

        if (!LocalFileName || !DestFileName) {
            len = 0;
            if (!pSendExactData (Socket, (PBYTE) &len, 4)) {
                __leave;
            }

            result = TRUE;
            __leave;
        }

        //
        // Try to open the file
        //

        fileSize = BfGetFileSize (LocalFileName);

        file = BfOpenFile (LocalFileName);
        if (!file) {
            __leave;
        }

        //
        // Send the file name and file size
        //

        len = ByteCount (DestFileName);
        if (!pSendExactData (Socket, (PBYTE) &len, 4)) {
            __leave;
        }

        if (!pSendExactData (Socket, (PBYTE) DestFileName, len)) {
            __leave;
        }

        if (!pSendExactData (Socket, (PBYTE) &fileSize, 8)) {
            __leave;
        }

        //
        // Send the data 64K at a time
        //

        GbGrow (&data, 0x10000);

        while (fileSize) {
            if (fileSize >= 0x10000) {
                if (!BfReadFile (file, data.Buf, 0x10000)) {
                    DEBUGMSG ((DBG_ERROR, "Can't read from file"));
                    __leave;
                }

                if (!pSendExactData (Socket, data.Buf, 0x10000)) {
                    __leave;
                }

                fileSize -= 0x10000;
            } else {
                if (!BfReadFile (file, data.Buf, (UINT) fileSize)) {
                    DEBUGMSG ((DBG_ERROR, "Can't read from file"));
                    __leave;
                }

                if (!pSendExactData (Socket, data.Buf, (UINT) fileSize)) {
                    __leave;
                }

                fileSize = 0;
            }
        }

        //
        // Done!
        //

        result = TRUE;

    }
    __finally {
        GbFree (&data);
        if (file) {
            CloseHandle (file);
        }
    }

    return result;
}


BOOL
pReceiveStreamFile (
    IN      SOCKET Socket
    )
{
    TCHAR fileName[MAX_PATH * 2];
    INT len;
    INT bytesIn;
    GROWBUFFER data = INIT_GROWBUFFER;
    BOOL result = FALSE;
    PTSTR p;
    HANDLE file = NULL;
    LONGLONG fileSize;

    __try {
        //
        // Wait for file name
        //

        if (!pReceiveExactData (Socket, &data, 4)) {
            __leave;
        }

        len = *((PDWORD) data.Buf);

        if (!len) {
            result = TRUE;
            __leave;
        }

        if (len >= (MAX_PATH * sizeof (TCHAR))) {
            __leave;
        }

        if (!pReceiveExactData (Socket, &data, len)) {
            __leave;
        }

        StringCopy (fileName, g_StoragePath);

        GbGrow (&data, sizeof (TCHAR) * 2);
        p = (PTSTR) data.Buf;
        p[len] = 0;
        p[len + 1] = 0;

        StringCopy (AppendWack (fileName), p);

        //
        // Get the file size
        //

        if (!pReceiveExactData (Socket, &data, 8)) {
            __leave;
        }

        fileSize = *((PLONGLONG) data.Buf);

        DEBUGMSG ((DBG_HOMENET, "Receiving %s", fileName));

        //
        // Create the file
        //

        file = BfCreateFile (fileName);
        if (!file) {
            __leave;
        }

        //
        // Fetch the data 64K at a time
        //

        while (fileSize) {
            if (fileSize >= 0x10000) {
                if (!pReceiveExactData (Socket, &data, 0x10000)) {
                    __leave;
                }

                if (!BfWriteFile (file, data.Buf, data.End)) {
                    DEBUGMSG ((DBG_ERROR, "Can't write to file"));
                    __leave;
                }

                fileSize -= 0x10000;
            } else {
                if (!pReceiveExactData (Socket, &data, (UINT) fileSize)) {
                    __leave;
                }

                if (!BfWriteFile (file, data.Buf, data.End)) {
                    DEBUGMSG ((DBG_ERROR, "Can't write to file"));
                    __leave;
                }

                fileSize = 0;
            }
        }

        //
        // Done!
        //

        result = TRUE;

    }
    __finally {
        GbFree (&data);
        if (file) {
            CloseHandle (file);
            if (!result) {
                DeleteFile (fileName);
            }
        }
    }

    return result;
}


BOOL
pReceiveFile (
    IN      SOCKET Socket,
    IN      BOOL Datagram
    )
{
    if (Datagram) {
        return FALSE;
    }

    return pReceiveStreamFile (Socket);
}


BOOL
pSendMetrics (
    IN      SOCKET Socket,
    IN      BOOL Datagram,
    IN      PTRANSFERMETRICS Metrics
    )
{
    if (Datagram) {
        return FALSE;
    }

    Metrics->StructSize = sizeof (TRANSFERMETRICS);

    if (!pSendExactData (Socket, (PBYTE) Metrics, sizeof (TRANSFERMETRICS))) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pReceiveMetrics (
    IN      SOCKET Socket,
    OUT     PTRANSFERMETRICS Metrics
    )
{
    GROWBUFFER data = INIT_GROWBUFFER;
    BOOL result = FALSE;

    __try {
        if (!pReceiveExactData (Socket, &data, sizeof (TRANSFERMETRICS))) {
            __leave;
        }

        CopyMemory (Metrics, data.Buf, data.End);

        if (Metrics->StructSize != sizeof (TRANSFERMETRICS)) {
            DEBUGMSG ((DBG_ERROR, "Invalid transfer metrics received"));
            __leave;
        }

        result = TRUE;
    }
    __finally {
        GbFree (&data);
    }

    return result;
}


VOID
pDoDestination (
    VOID
    )
{
    GROWBUFFER sourceAddress = INIT_GROWBUFFER;
    CONNECTIONSOCKET connection;
    TRANSFERMETRICS metrics;
    UINT u;

    ZeroMemory (&connection, sizeof (CONNECTIONSOCKET));
    connection.Socket = INVALID_SOCKET;

    __try {

        GetTempPath (MAX_PATH, g_StoragePath);

        if (!pNameResolver (&sourceAddress, TRUE, &connection)) {
            __leave;
        }

        printf ("Connected!\n");

        if (!pReceiveMetrics (connection.Socket, &metrics)) {
            __leave;
        }

        for (u = 0 ; u < metrics.FileCount ; u++) {
            if (!pReceiveFile (connection.Socket, connection.Datagram)) {
                __leave;
            }
        }
    }
    __finally {
        GbFree (&sourceAddress);

        if (connection.Socket != INVALID_SOCKET) {
            closesocket (connection.Socket);
        }
    }
}


BOOL
pConnectToDestination (
    IN      PCONNECTADDRESS Address,
    OUT     PCONNECTIONSOCKET Connection
    )
{
    BOOL result = FALSE;
    BOOL b;

    CopyMemory (Connection->LocalAddress, Address->LocalAddress, Address->LocalAddressLen);
    Connection->LocalAddressLen = Address->LocalAddressLen;

    CopyMemory (Connection->RemoteAddress, Address->RemoteAddress, Address->RemoteAddressLen);
    Connection->RemoteAddressLen = Address->RemoteAddressLen;

    Connection->Socket = socket (
                            Address->Family,
                            Address->Datagram ? SOCK_DGRAM : SOCK_STREAM,
                            Address->Protocol
                            );

    if (Connection->Socket == INVALID_SOCKET) {
        DEBUGMSG ((DBG_ERROR, "Can't create socket for connection"));
        return FALSE;
    }

    __try {

        b = TRUE;
        setsockopt (Connection->Socket, SOL_SOCKET, SO_REUSEADDR, (PBYTE) &b, sizeof (b));

        pResetPort (Address->Family, (SOCKADDR *) Address->LocalAddress);

        if (bind (Connection->Socket, (SOCKADDR *) Address->LocalAddress, Address->LocalAddressLen)) {
            DEBUGMSG ((DBG_ERROR, "Failed to bind to connection socket"));
            __leave;
        }

        if (connect (Connection->Socket, (SOCKADDR *) Address->RemoteAddress, Address->RemoteAddressLen)) {
            DEBUGMSG ((DBG_ERROR, "Failed to connect to socket"));
            __leave;
        }

        Connection->Family = Address->Family;
        Connection->Protocol = Address->Protocol;
        Connection->Datagram = Address->Datagram;

        result = TRUE;
    }
    __finally {
        if (!result && Connection->Socket != INVALID_SOCKET) {
            closesocket (Connection->Socket);
            Connection->Socket = INVALID_SOCKET;
        }
    }

    return result;
}


VOID
pDoSource (
    VOID
    )
{
    GROWBUFFER destinationAddresses = INIT_GROWBUFFER;
    INT destinationCount;
    PCTSTR firstName;
    PCONNECTADDRESS addressArray;
    PCONNECTADDRESS address;
    CONNECTIONSOCKET connection;
    INT i;
    TRANSFERMETRICS metrics;
    PCTSTR localFileName = TEXT("c:\\debug.inf");
    PCTSTR destFileName = TEXT("foo.inf");

    ZeroMemory (&connection, sizeof (CONNECTIONSOCKET));
    connection.Socket = INVALID_SOCKET;

    __try {

        destinationCount = pNameResolver (&destinationAddresses, FALSE, NULL);

        if (!destinationCount) {
            __leave;
        }

        addressArray = (PCONNECTADDRESS) destinationAddresses.Buf;

        //
        // Determine which address to use.  Rules are:
        //
        // 1. Must have only one destination to choose from
        // 2. Pick TCP/IP, then IPX, then NetBIOS
        //

        if (destinationCount > 1) {
            firstName = addressArray[0].DestinationName;

            for (i = 1 ; i < destinationCount ; i++) {
                if (!StringIMatch (firstName, addressArray[i].DestinationName)) {
                    break;
                }
            }

            if (i < destinationCount) {
                DEBUGMSG ((DBG_ERROR, "Multiple destinations found on the subnet; can't continue"));
                __leave;
            }
        }

        for (i = 0 ; i < destinationCount ; i++) {
            if (addressArray[i].Family == AF_INET) {
                break;
            }
        }

        if (i == destinationCount) {
            for (i = 0 ; i < destinationCount ; i++) {
                if (addressArray[i].Family == AF_IPX) {
                    break;
                }
            }

            if (i == destinationCount) {
                for (i = 0 ; i < destinationCount ; i++) {
                    if (addressArray[i].Family == AF_NETBIOS) {
                        break;
                    }
                }

                if (i == destinationCount) {
                    DEBUGMSG ((DBG_WHOOPS, "Connection is from unsupported protocol"));
                    __leave;
                }
            }
        }

        //
        // Now connect to destination (at index i)
        //

        DEBUGMSG ((
            DBG_HOMENET,
            "Attempting connection to %s (protocol %i)",
            addressArray[i].DestinationName,
            addressArray[i].Protocol
            ));

        if (!pConnectToDestination (&addressArray[i], &connection)) {
            __leave;
        }

        printf ("Connected!\n");

        ZeroMemory (&metrics, sizeof (metrics));

        metrics.FileCount = 1;
        metrics.TotalSize = 0;

        if (!pSendMetrics (connection.Socket, connection.Datagram, &metrics)) {
            __leave;
        }

        if (!pSendFile (
                connection.Socket,
                connection.Datagram ? &connection.DatagramPool : NULL,
                localFileName,
                destFileName
                )) {
            __leave;
        }
    }
    __finally {
        GbFree (&destinationAddresses);

        if (connection.Socket != INVALID_SOCKET) {
            closesocket (connection.Socket);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\regenum\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    <TODO: fill in abstract>

Author:

    TODO: <full name> (<alias>) <date>

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include <conio.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    //
    // Initialize the common libs
    //

    if (Reason == DLL_PROCESS_ATTACH) {
        UtInitialize (NULL);
        if (!RegInitialize ()) {
            return FALSE;
        }

    } else {
        RegTerminate();
        UtTerminate ();
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        //
        // TODO: Describe command line syntax(es), indent 2 spaces
        //

        "  regenum [/N] [/S] [/W] [/F] [/L:MaxSubLevel] [/X] <Node Pattern> <Leaf Pattern>\n"

        "\nDescription:\n\n"

        //
        // TODO: Describe tool, indent 2 spaces
        //

        "  Enumerates the part of registry that matches <Pattern>.\n"
        "  Uses C:\\exclude.inf if present and /X not specified to determine what keys/values\n"
        "  are excluded.\n"

        "\nArguments:\n\n"

        //
        // TODO: Describe args, indent 2 spaces, say optional if necessary
        //

        "  /N  Specifies exclusion of key names from enumeration; optional\n"
        "  /S  Specifies sub-keys to be enumerated before values for any key; optional\n"
        "  /W  Specifies enumeration should be width-first; optional\n"
        "  /F  Specifies output should use \"key <value>\" format; optional\n"
        "  /L:MaxSubLevel  Specifies the maximum sub-level starting from the root of enum;\n"
        "                  -1 = all levels (default), 0 = only the root level etc.; optional\n"
        "  /X  Specifies to use exclusions in C:\\exclude.inf; optional\n"
        "  <Pattern>  Specifies the file/dir pattern; must have the form \"DirPattern <FilePattern>\"\n"
        "             the <FilePattern> part is optional; quotes required if both parts are specified\n"

        );

    exit (1);
}


BOOL
BuildExclusionList (
    IN      PCTSTR FileName
    )
{
    HINF h;
    INFCONTEXT ic;
    TCHAR buf[256];

    h = SetupOpenInfFile (FileName, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    if (SetupFindFirstLine (h, TEXT("RegKeys"), NULL, &ic)) {
        do {
            if (SetupGetStringField (&ic, 0, buf, DWSIZEOF (buf) / DWSIZEOF (TCHAR), NULL)) {
                //ElAdd (ELT_REGKEY, buf);
            }
        } while (SetupFindNextLine (&ic, &ic));
    }
    if (SetupFindFirstLine (h, TEXT("RegValues"), NULL, &ic)) {
        do {
            if (SetupGetStringField (&ic, 0, buf, DWSIZEOF (buf) / DWSIZEOF (TCHAR), NULL)) {
                //ElAdd (ELT_REGVALUE, buf);
            }
        } while (SetupFindNextLine (&ic, &ic));
    }
    SetupCloseInfFile (h);
    return TRUE;
}

BOOL
RegEnumCallback (
    IN      PREGNODE RegNode        OPTIONAL
    )
{
    BOOL b;

    if (!RegNode) {
        _ftprintf (stderr, TEXT("\nOut of memory\n"));
        return FALSE;
    }
    _ftprintf (stderr, TEXT("Error creating key node: %s; continue anyway ? (yn):"), RegNode->KeyName);
    b = _totupper(_getche ()) == TEXT('Y');
    _ftprintf (stderr, TEXT("\n"));
    return b;
}

INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR patternNode = NULL;
    PCTSTR patternLeaf = NULL;
    PTSTR p;
    PCTSTR level;
    BOOL enumKeyNames = TRUE;
    BOOL valuesFirst = TRUE;
    BOOL depthFirst = TRUE;
    BOOL nativeFormat = TRUE;
    UINT maxSubLevel = -1;
    BOOL exclusions = FALSE;
    INT pos;
    REGTREE_ENUM e;
    PCTSTR pattern;

    //
    // TODO: Parse command line here
    //
    if (argc < 2) {
        HelpAndExit ();
    }

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('x'):
                exclusions = TRUE;
                break;
            case TEXT('n'):
                enumKeyNames = FALSE;
                break;
            case TEXT('s'):
                valuesFirst = FALSE;
                break;
            case TEXT('w'):
                depthFirst = FALSE;
                break;
            case TEXT('f'):
                nativeFormat = FALSE;
                break;
            case TEXT('l'):
                if (argv[i][2] == TEXT(':')) {
                    level = &argv[i][3];
                } else if (i + 1 < argc) {
                    level = argv[++i];
                } else {
                    HelpAndExit();
                }
                if (!_stscanf (level, TEXT("%ld%n"), &maxSubLevel, &pos) || level[pos]) {
                    HelpAndExit();
                }
                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            if (!patternNode) {
                patternNode = argv[i];
            } else if (!patternLeaf) {
                patternLeaf = argv[i];
            } else {
                HelpAndExit();
            }
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 2;
    }

    if (!patternLeaf) {
        HelpAndExit ();
    }

    pattern = ObsBuildEncodedObjectStringEx (patternNode, patternLeaf, FALSE);

    //
    // TODO: Do work here
    //

    if (exclusions) {
        BuildExclusionList (TEXT("C:\\exclude.inf"));
    }

    if (EnumFirstRegObjectInTreeEx (
            &e,
            pattern,
            enumKeyNames,
            TRUE,
            valuesFirst,
            depthFirst,
            maxSubLevel,
            exclusions,
            FALSE,
            RegEnumDefaultCallback
            )) {
        do {
            _tprintf (
                TEXT("%s - %s\n"),
                nativeFormat ? e.NativeFullName : e.EncodedFullName,
                (e.Attributes & REG_ATTRIBUTE_KEY) ? TEXT("Key") : TEXT("Value")
                );
        } while (EnumNextRegObjectInTree (&e));
    }

    //
    // End of processing
    //

    if (exclusions) {
        ElRemoveAll ();
    }

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\ssstub\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implements a small utility that fills the disk for purposes of free space
    testing.

Author:

    Jim Schmidt (jimschm) 18-Aug-2000

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include "wininet.h"
#include <lm.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    UtInitialize (NULL);

    return TRUE;
}


VOID
Terminate (
    VOID
    )
{
    UtTerminate ();
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        "  filler <free_space> [/D:<drive>] [/C:<cmdline> [/M]]\n"
        "  filler /Q [/D:<drive>]\n"

        "\nDescription:\n\n"

        "  filler creates a file (bigfile.dat) on the current or specified\n"
        "  drive, leaving only the specified amount of free space on the drive.\n"

        "\nArguments:\n\n"

        "  free_space   Specifies the amount of free space to leave on\n"
        "               disk.\n"
        "  /D           Specifies the drive letter to fill (i.e. /D:C)\n"
        "  /Q           Queries the free space on the disk\n"
        "  /C           Executes command line specified in <cmdline>\n"
        "  /M           Issue message box if command line alters disk space\n"

        );

    exit (1);
}

INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    TCHAR curDir[MAX_PATH];
    TCHAR curFileS[MAX_PATH];
    TCHAR curFileD[MAX_PATH];
    PCTSTR cmdLine = NULL;
    PCTSTR cmdPtr = NULL;
    TCHAR newCmdLine[MAX_PATH];

    GetCurrentDirectory (ARRAYSIZE(curDir), curDir);
    cmdLine = GetCommandLine ();
    if (!cmdLine) {
        _tprintf ("Error while getting the command line.\n");
        exit (-1);
    }
    cmdPtr = _tcsstr (cmdLine, TEXT("scanstate"));
    if (!cmdPtr) {
        _tprintf ("Error while getting the command line.\n");
        exit (-1);
    }
    StringCopyAB (newCmdLine, cmdLine, cmdPtr);
    StringCat (newCmdLine, TEXT("scanstate_a.exe"));
    cmdPtr = _tcschr (cmdPtr, TEXT(' '));
    if (!cmdPtr) {
        _tprintf ("Error while getting the command line.\n");
        exit (-1);
    }
    StringCat (newCmdLine, cmdPtr);

    //
    // Begin processing
    //

    if (!Init()) {
        exit (-1);
    }

    //
    // Do work here
    //
    {
        BOOL result = FALSE;
        STARTUPINFO startupInfo;
        PROCESS_INFORMATION processInformation;
        DWORD exitCode = -1;

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("guitrn_a.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("guitrn.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("unctrn_a.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("unctrn.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("script_a.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("script.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("sysmod_a.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("sysmod.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        StringCopy (curFileS, curDir);
        StringCopy (AppendWack (curFileS), TEXT("migism_a.dll"));
        StringCopy (curFileD, curDir);
        StringCopy (AppendWack (curFileD), TEXT("migism.dll"));
        CopyFile (curFileS, curFileD, FALSE);

        ZeroMemory (&startupInfo, sizeof (STARTUPINFO));
        startupInfo.cb = sizeof (STARTUPINFO);
        ZeroMemory (&processInformation, sizeof (PROCESS_INFORMATION));

        result = CreateProcess (
                    NULL,
                    newCmdLine,
                    NULL,
                    NULL,
                    FALSE,
                    0,
                    NULL,
                    NULL,
                    &startupInfo,
                    &processInformation
                    );

        if (result && processInformation.hProcess && (processInformation.hProcess != INVALID_HANDLE_VALUE)) {
            WaitForSingleObject (processInformation.hProcess, INFINITE);
            if (!GetExitCodeProcess (processInformation.hProcess, &exitCode)) {
                exitCode = -1;
            }
            exit (exitCode);
        }
    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\compress\compress.c ===
#include "pch.h"
#include "compress.h"
#include "mrcicode.h"

#define COMPRESS_SIG            0x434F4D50  //COMP
#define COMPRESS_CONT_SIG       0x434F4D43  //COMC
#define COMPRESS_NEWFILE        0x434F4D46  //COMF
#define COMPRESS_BUFFER_SIZE    0x8000      //32K
#define COMPRESS_DEFAULT_SIZE   0x7FFFFFFF  //2GB

BOOL g_ErrorMode = FALSE;

unsigned
CompressData(
    IN  CompressionType Type,
    IN  PBYTE           Data,
    IN  unsigned        DataSize,
    OUT PBYTE           CompressedData,
    IN  unsigned        BufferSize
    )
{
    unsigned u;

    switch(Type) {

    case CompressNone:
    default:
        //
        // Force caller to do something intelligent, such as
        // writing directly out of the uncompressed buffer.
        // This avoids an extra memory move.
        //
        u = (unsigned)(-1);
        break;

    case CompressMrci1:
        u = Mrci1MaxCompress(Data,DataSize,CompressedData,BufferSize);
        break;

    case CompressMrci2:
        u = Mrci2MaxCompress(Data,DataSize,CompressedData,BufferSize);
        break;
    }

    return(u);
}


unsigned
DecompressData(
    IN  CompressionType Type,
    IN  PBYTE           CompressedData,
    IN  unsigned        CompressedDataSize,
    OUT PBYTE           DecompressedData,
    IN  unsigned        BufferSize
    )
{
    unsigned u;

    switch(Type) {

    case CompressNone:
        if(BufferSize >= CompressedDataSize) {
            memmove(DecompressedData,CompressedData,CompressedDataSize);
            u = CompressedDataSize;
        } else {
            u = (unsigned)(-1);
        }
        break;

    case CompressMrci1:
        u = Mrci1Decompress(CompressedData,CompressedDataSize,DecompressedData,BufferSize);
        break;

    case CompressMrci2:
        u = Mrci2Decompress(CompressedData,CompressedDataSize,DecompressedData,BufferSize);
        break;

    default:
        u = (unsigned)(-1);
        break;
    }

    return(u);
}

VOID
CompressCleanupHandleA (
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle
    )
{
    if (CompressedHandle) {
        if (CompressedHandle->ReadBuffer) {
            MemFree (g_hHeap, 0, CompressedHandle->ReadBuffer);
        }
        if (CompressedHandle->ExtraBuffer) {
            MemFree (g_hHeap, 0, CompressedHandle->ExtraBuffer);
        }
        if (CompressedHandle->CompBuffer) {
            MemFree (g_hHeap, 0, CompressedHandle->CompBuffer);
        }
        if (CompressedHandle->StorePath) {
            FreePathStringA (CompressedHandle->StorePath);
        }
        if (CompressedHandle->MainFilePattern) {
            FreePathStringA (CompressedHandle->MainFilePattern);
        }
        if ((CompressedHandle->CurrFileHandle) &&
            (CompressedHandle->CurrFileHandle != INVALID_HANDLE_VALUE)
            ) {
            CloseHandle (CompressedHandle->CurrFileHandle);
        }
        ZeroMemory (CompressedHandle, sizeof (COMPRESS_HANDLEA));
    }
}

VOID
CompressCleanupHandleW (
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle
    )
{
    if (CompressedHandle) {
        if (CompressedHandle->ReadBuffer) {
            MemFree (g_hHeap, 0, CompressedHandle->ReadBuffer);
        }
        if (CompressedHandle->ExtraBuffer) {
            MemFree (g_hHeap, 0, CompressedHandle->ExtraBuffer);
        }
        if (CompressedHandle->CompBuffer) {
            MemFree (g_hHeap, 0, CompressedHandle->CompBuffer);
        }
        if (CompressedHandle->StorePath) {
            FreePathStringW (CompressedHandle->StorePath);
        }
        if (CompressedHandle->MainFilePattern) {
            FreePathStringW (CompressedHandle->MainFilePattern);
        }
        if ((CompressedHandle->CurrFileHandle) &&
            (CompressedHandle->CurrFileHandle != INVALID_HANDLE_VALUE)
            ) {
            CloseHandle (CompressedHandle->CurrFileHandle);
        }
        ZeroMemory (CompressedHandle, sizeof (COMPRESS_HANDLEW));
    }
}

BOOL
CompressCreateHandleA (
    IN      PCSTR StorePath,
    IN      PCSTR MainFilePattern,
    IN      UINT StartIndex,
    IN      LONGLONG MaxFileSize,
    OUT     PCOMPRESS_HANDLEA CompressedHandle
    )
{
    CHAR currFile [MAX_PATH];
    PCSTR currFullPath = NULL;
    DWORD signature = COMPRESS_SIG;
    BOOL result = FALSE;

    __try {

        ZeroMemory (CompressedHandle, sizeof (COMPRESS_HANDLEA));
        if (StartIndex == 0) {
            CompressedHandle->CurrFileIndex = 1;
        } else {
            CompressedHandle->CurrFileIndex = StartIndex;
        }
        CompressedHandle->FirstFileIndex = CompressedHandle->CurrFileIndex;
        if (MaxFileSize == 0) {
            CompressedHandle->MaxFileSize = COMPRESS_DEFAULT_SIZE;
        } else {
            CompressedHandle->MaxFileSize = MaxFileSize;
        }
        CompressedHandle->StorePath = DuplicatePathStringA (StorePath, 0);
        if (!CompressedHandle->StorePath) {
            __leave;
        }
        CompressedHandle->MainFilePattern = DuplicatePathStringA (MainFilePattern, 0);
        if (!CompressedHandle->MainFilePattern) {
            __leave;
        }
        wsprintfA (currFile, CompressedHandle->MainFilePattern, CompressedHandle->CurrFileIndex);
        currFullPath = JoinPathsA (CompressedHandle->StorePath, currFile);
        CompressedHandle->CurrFileHandle = BfCreateFileA (currFullPath);
        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }
        FreePathStringA (currFullPath);
        currFullPath = NULL;

        // write the signature
        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        // reserve room for writing how many files we stored
        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&CompressedHandle->FilesStored), sizeof (LONGLONG))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (LONGLONG);

        CompressedHandle->ReadBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->ReadBuffer) {
            __leave;
        }

        CompressedHandle->CompBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->CompBuffer) {
            __leave;
        }

        CompressedHandle->ExtraBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->ExtraBuffer) {
            __leave;
        }

        result = TRUE;
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringA (currFullPath);
            currFullPath = NULL;
        }
        if (!result) {
            CompressCleanupHandleA (CompressedHandle);
        }
        PopError ();
    }

    return result;
}

BOOL
CompressCreateHandleW (
    IN      PCWSTR StorePath,
    IN      PCWSTR MainFilePattern,
    IN      UINT StartIndex,
    IN      LONGLONG MaxFileSize,
    OUT     PCOMPRESS_HANDLEW CompressedHandle
    )
{
    WCHAR currFile [MAX_PATH];
    PCWSTR currFullPath = NULL;
    DWORD signature = COMPRESS_SIG;
    BOOL result = FALSE;

    __try {

        ZeroMemory (CompressedHandle, sizeof (COMPRESS_HANDLEW));
        if (StartIndex == 0) {
            CompressedHandle->CurrFileIndex = 1;
        } else {
            CompressedHandle->CurrFileIndex = StartIndex;
        }
        CompressedHandle->FirstFileIndex = CompressedHandle->CurrFileIndex;
        if (MaxFileSize == 0) {
            CompressedHandle->MaxFileSize = COMPRESS_DEFAULT_SIZE;
        } else {
            CompressedHandle->MaxFileSize = MaxFileSize;
        }
        CompressedHandle->StorePath = DuplicatePathStringW (StorePath, 0);
        if (!CompressedHandle->StorePath) {
            __leave;
        }
        CompressedHandle->MainFilePattern = DuplicatePathStringW (MainFilePattern, 0);
        if (!CompressedHandle->MainFilePattern) {
            __leave;
        }
        wsprintfW (currFile, CompressedHandle->MainFilePattern, CompressedHandle->CurrFileIndex);
        currFullPath = JoinPathsW (CompressedHandle->StorePath, currFile);
        CompressedHandle->CurrFileHandle = BfCreateFileW (currFullPath);
        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }
        FreePathStringW (currFullPath);
        currFullPath = NULL;

        // write the signature
        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        // reserve room for writing how many files we stored
        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&CompressedHandle->FilesStored), sizeof (LONGLONG))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (LONGLONG);

        CompressedHandle->ReadBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->ReadBuffer) {
            __leave;
        }

        CompressedHandle->CompBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->CompBuffer) {
            __leave;
        }

        CompressedHandle->ExtraBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->ExtraBuffer) {
            __leave;
        }

        result = TRUE;
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringW (currFullPath);
            currFullPath = NULL;
        }
        if (!result) {
            CompressCleanupHandleW (CompressedHandle);
        }
        PopError ();
    }

    return result;
}

BOOL
pPrepareNextFileA (
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle,
    IN      BOOL ReadOnly
    )
{
    CHAR currFile [MAX_PATH];
    PCSTR currFullPath = NULL;
    DWORD signature = COMPRESS_SIG;
    LONGLONG contSig = COMPRESS_CONT_SIG;
    BOOL result = FALSE;

    __try {

        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }

        if (!CloseHandle (CompressedHandle->CurrFileHandle)) {
            __leave;
        }

        CompressedHandle->CurrFileSize = 0;

        CompressedHandle->CurrFileIndex ++;

        wsprintfA (currFile, CompressedHandle->MainFilePattern, CompressedHandle->CurrFileIndex);
        currFullPath = JoinPathsA (CompressedHandle->StorePath, currFile);
        if (ReadOnly) {
            CompressedHandle->CurrFileHandle = BfOpenReadFileA (currFullPath);
        } else {
            CompressedHandle->CurrFileHandle = BfCreateFileA (currFullPath);
        }
        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }
        FreePathStringA (currFullPath);
        currFullPath = NULL;

        if (ReadOnly) {
            // read the signature
            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);

            if (signature != COMPRESS_SIG) {
                SetLastError (ERROR_INVALID_DATA);
                __leave;
            }

            // read special continuation signature
            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&contSig), sizeof (LONGLONG))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (LONGLONG);

            if (CompressedHandle->CurrFileIndex > 1) {
                if (contSig != COMPRESS_CONT_SIG) {
                    SetLastError (ERROR_INVALID_DATA);
                    __leave;
                }
            }
        } else {
            // write the signature
            if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);

            // write special continuation signature
            if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&contSig), sizeof (LONGLONG))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (LONGLONG);
        }

        result = TRUE;
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringA (currFullPath);
            currFullPath = NULL;
        }
        PopError ();
    }

    return result;
}

BOOL
pPrepareNextFileW (
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle,
    IN      BOOL ReadOnly
    )
{
    WCHAR currFile [MAX_PATH];
    PCWSTR currFullPath = NULL;
    DWORD signature = COMPRESS_SIG;
    LONGLONG contSig = COMPRESS_CONT_SIG;
    BOOL result = FALSE;

    __try {

        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }

        if (!CloseHandle (CompressedHandle->CurrFileHandle)) {
            __leave;
        }

        CompressedHandle->CurrFileSize = 0;

        CompressedHandle->CurrFileIndex ++;

        wsprintfW (currFile, CompressedHandle->MainFilePattern, CompressedHandle->CurrFileIndex);
        currFullPath = JoinPathsW (CompressedHandle->StorePath, currFile);
        if (ReadOnly) {
            CompressedHandle->CurrFileHandle = BfOpenReadFileW (currFullPath);
        } else {
            CompressedHandle->CurrFileHandle = BfCreateFileW (currFullPath);
        }
        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }
        FreePathStringW (currFullPath);
        currFullPath = NULL;

        if (ReadOnly) {
            // read the signature
            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);

            if (signature != COMPRESS_SIG) {
                SetLastError (ERROR_INVALID_DATA);
                __leave;
            }

            // read special continuation signature
            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&contSig), sizeof (LONGLONG))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (LONGLONG);

            if (CompressedHandle->CurrFileIndex > 1) {
                if (contSig != COMPRESS_CONT_SIG) {
                    SetLastError (ERROR_INVALID_DATA);
                    __leave;
                }
            }
        } else {
            // write the signature
            if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);

            // write special continuation signature
            if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&contSig), sizeof (LONGLONG))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (LONGLONG);
        }

        result = TRUE;
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringW (currFullPath);
            currFullPath = NULL;
        }
        PopError ();
    }

    return result;
}

BOOL
pDeleteNextFilesA (
    IN      PCOMPRESS_HANDLEA CompressedHandle,
    IN      UINT SavedIndex
    )
{
    CHAR currFile [MAX_PATH];
    PCSTR currFullPath = NULL;

    while (TRUE) {
        wsprintfA (currFile, CompressedHandle->MainFilePattern, SavedIndex);
        currFullPath = JoinPathsA (CompressedHandle->StorePath, currFile);
        if (currFullPath) {
            if (DoesFileExistA (currFullPath)) {
                DeleteFileA (currFullPath);
            } else {
                break;
            }
            FreePathStringA (currFullPath);
            currFullPath = NULL;
        }
        SavedIndex ++;
    }
    if (currFullPath) {
        FreePathStringA (currFullPath);
        currFullPath = NULL;
    }
    return TRUE;
}

BOOL
pDeleteNextFilesW (
    IN      PCOMPRESS_HANDLEW CompressedHandle,
    IN      UINT SavedIndex
    )
{
    WCHAR currFile [MAX_PATH];
    PCWSTR currFullPath = NULL;

    while (TRUE) {
        wsprintfW (currFile, CompressedHandle->MainFilePattern, SavedIndex);
        currFullPath = JoinPathsW (CompressedHandle->StorePath, currFile);
        if (currFullPath) {
            if (DoesFileExistW (currFullPath)) {
                DeleteFileW (currFullPath);
            } else {
                break;
            }
            FreePathStringW (currFullPath);
            currFullPath = NULL;
        }
        SavedIndex ++;
    }
    if (currFullPath) {
        FreePathStringW (currFullPath);
        currFullPath = NULL;
    }
    return TRUE;
}

BOOL
CompressAddFileToHandleA (
    IN      PCSTR FileName,
    IN      PCSTR StoredName,
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle
    )
{
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    LONGLONG fileSize;
    DWORD bytesRead;
    DWORD bytesWritten;
    DWORD bytesComp;
    DWORD bytesUncomp;
    DWORD signature = COMPRESS_NEWFILE;
    DWORD fileNameSize;
    DWORD headerSize;
    USHORT compType = 0;
    USHORT compSize = 0;
    PCWSTR unicodeName = NULL;
    UINT savedIndex = 0;
    LARGE_INTEGER savedSize;
    BOOL result = FALSE;

    __try {

        // save the state of the compress handle
        savedIndex = CompressedHandle->CurrFileIndex;
        savedSize.QuadPart = CompressedHandle->CurrFileSize;

        fileSize = BfGetFileSizeA (FileName);
        fileHandle = BfOpenReadFileA (FileName);
        if ((fileHandle == NULL) ||
            (fileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }

        // handle UNICODE files
        unicodeName = ConvertAtoW (StoredName);
        if (!unicodeName) {
            __leave;
        }
        fileNameSize = SizeOfStringW (unicodeName);
        headerSize = sizeof (DWORD) + sizeof (LONGLONG) + sizeof (DWORD) + fileNameSize;

        if (CompressedHandle->CurrFileSize + headerSize > CompressedHandle->MaxFileSize) {
            if (!pPrepareNextFileA (CompressedHandle, FALSE)) {
                __leave;
            }
        }

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileSize), sizeof (LONGLONG))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (LONGLONG);

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileNameSize), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(unicodeName), fileNameSize)) {
            __leave;
        }
        CompressedHandle->CurrFileSize += fileNameSize;
        FreeConvertedStr (unicodeName);
        unicodeName = NULL;

        while (fileSize) {

            ZeroMemory (CompressedHandle->ReadBuffer, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
            ZeroMemory (CompressedHandle->CompBuffer, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));

            if (!ReadFile (fileHandle, CompressedHandle->ReadBuffer + 2 * sizeof (USHORT), COMPRESS_BUFFER_SIZE, &bytesRead, NULL)) {
                __leave;
            }
            if (bytesRead == 0)
            {
                // Somehow the file points is beyond the end of the file. Probably file in use.
                SetLastError(ERROR_SHARING_VIOLATION);
                __leave;
            }

            bytesComp = CompressData (
                            CompressMrci1,
                            CompressedHandle->ReadBuffer + 2 * sizeof (USHORT),
                            bytesRead,
                            CompressedHandle->CompBuffer + 2 * sizeof (USHORT),
                            COMPRESS_BUFFER_SIZE
                            );

            if (bytesComp < bytesRead) {
                bytesUncomp = DecompressData (
                                CompressMrci1,
                                CompressedHandle->CompBuffer + 2 * sizeof (USHORT),
                                bytesComp,
                                CompressedHandle->ExtraBuffer,
                                COMPRESS_BUFFER_SIZE
                                );
                if (bytesUncomp != bytesRead) {
                    bytesComp = COMPRESS_BUFFER_SIZE;
                } else {
                    if (!TestBuffer (CompressedHandle->ReadBuffer + 2 * sizeof (USHORT), CompressedHandle->ExtraBuffer, bytesRead)) {
                        bytesComp = COMPRESS_BUFFER_SIZE;
                    }
                }
            }

            if (bytesComp >= bytesRead) {
                compType = CompressNone;
                compSize = (USHORT)bytesRead;
                CopyMemory (CompressedHandle->ReadBuffer, &compType, sizeof (USHORT));
                CopyMemory (CompressedHandle->ReadBuffer + sizeof (USHORT), &compSize, sizeof (USHORT));

                compSize += (2 * sizeof (USHORT));

                if (CompressedHandle->CurrFileSize + compSize > CompressedHandle->MaxFileSize) {
                    if (!pPrepareNextFileA (CompressedHandle, FALSE)) {
                        __leave;
                    }
                }

                if (!BfWriteFile (CompressedHandle->CurrFileHandle, CompressedHandle->ReadBuffer, compSize)) {
                    __leave;
                }
                CompressedHandle->CurrFileSize += compSize;
            } else {
                compType = CompressMrci1;
                compSize = (USHORT)bytesComp;
                CopyMemory (CompressedHandle->CompBuffer, &compType, sizeof (USHORT));
                CopyMemory (CompressedHandle->CompBuffer + sizeof (USHORT), &compSize, sizeof (USHORT));

                compSize += (2 * sizeof (USHORT));

                if (CompressedHandle->CurrFileSize + compSize > CompressedHandle->MaxFileSize) {
                    if (!pPrepareNextFileA (CompressedHandle, FALSE)) {
                        __leave;
                    }
                }

                if (!BfWriteFile (CompressedHandle->CurrFileHandle, CompressedHandle->CompBuffer, compSize)) {
                    __leave;
                }
                CompressedHandle->CurrFileSize += compSize;
            }
            fileSize -= bytesRead;
        }
        CompressedHandle->FilesStored ++;

        result = TRUE;
    }
    __finally {
        PushError ();
        if (unicodeName) {
            FreeConvertedStr (unicodeName);
            unicodeName = NULL;
        }
        if (fileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle (fileHandle);
        }
        if (!result) {
            // let's restore the state of the compress handle
            if (savedIndex == CompressedHandle->CurrFileIndex) {
                if (savedSize.QuadPart != CompressedHandle->CurrFileSize) {
                    SetFilePointer (CompressedHandle->CurrFileHandle, savedSize.LowPart, &(savedSize.HighPart), FILE_BEGIN);
                    SetEndOfFile (CompressedHandle->CurrFileHandle);
                    CompressedHandle->CurrFileSize = savedSize.QuadPart;
                }
            } else {
                CompressedHandle->CurrFileIndex = savedIndex - 1;
                pPrepareNextFileA (CompressedHandle, TRUE);
                SetFilePointer (CompressedHandle->CurrFileHandle, savedSize.LowPart, &(savedSize.HighPart), FILE_BEGIN);
                SetEndOfFile (CompressedHandle->CurrFileHandle);
                CompressedHandle->CurrFileSize = savedSize.QuadPart;
                pDeleteNextFilesA (CompressedHandle, savedIndex);
            }
        }
        PopError ();
    }

    return result;
}

BOOL
CompressAddFileToHandleW (
    IN      PCWSTR FileName,
    IN      PCWSTR StoredName,
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle
    )
{
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    LONGLONG fileSize;
    DWORD bytesRead;
    DWORD bytesWritten;
    DWORD bytesComp;
    DWORD bytesUncomp;
    DWORD signature = COMPRESS_NEWFILE;
    DWORD fileNameSize;
    DWORD headerSize;
    USHORT compType = 0;
    USHORT compSize = 0;
    UINT savedIndex = 0;
    LARGE_INTEGER savedSize;
    BOOL result = FALSE;

    __try {

        // save the state of the compress handle
        savedIndex = CompressedHandle->CurrFileIndex;
        savedSize.QuadPart = CompressedHandle->CurrFileSize;

        fileSize = BfGetFileSizeW (FileName);
        fileHandle = BfOpenReadFileW (FileName);
        if ((fileHandle == NULL) ||
            (fileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }

        fileNameSize = SizeOfStringW (StoredName);
        headerSize = sizeof (DWORD) + sizeof (LONGLONG) + sizeof (DWORD) + fileNameSize;

        if (CompressedHandle->CurrFileSize + headerSize > CompressedHandle->MaxFileSize) {
            if (!pPrepareNextFileW (CompressedHandle, FALSE)) {
                __leave;
            }
        }

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileSize), sizeof (LONGLONG))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (LONGLONG);

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileNameSize), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(StoredName), fileNameSize)) {
            __leave;
        }
        CompressedHandle->CurrFileSize += fileNameSize;

        while (fileSize) {

            ZeroMemory (CompressedHandle->ReadBuffer, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
            ZeroMemory (CompressedHandle->CompBuffer, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));

            if (!ReadFile (fileHandle, CompressedHandle->ReadBuffer + 2 * sizeof (USHORT), COMPRESS_BUFFER_SIZE, &bytesRead, NULL)) {
                __leave;
            }
            if (bytesRead == 0)
            {
                // Somehow the file points is beyond the end of the file. Probably file in use.
                SetLastError(ERROR_SHARING_VIOLATION);
                __leave;
            }

            bytesComp = CompressData (
                            CompressMrci1,
                            CompressedHandle->ReadBuffer + 2 * sizeof (USHORT),
                            bytesRead,
                            CompressedHandle->CompBuffer + 2 * sizeof (USHORT),
                            COMPRESS_BUFFER_SIZE
                            );

            if (bytesComp < bytesRead) {
                bytesUncomp = DecompressData (
                                CompressMrci1,
                                CompressedHandle->CompBuffer + 2 * sizeof (USHORT),
                                bytesComp,
                                CompressedHandle->ExtraBuffer,
                                COMPRESS_BUFFER_SIZE
                                );
                if (bytesUncomp != bytesRead) {
                    bytesComp = COMPRESS_BUFFER_SIZE;
                } else {
                    if (!TestBuffer (CompressedHandle->ReadBuffer + 2 * sizeof (USHORT), CompressedHandle->ExtraBuffer, bytesRead)) {
                        bytesComp = COMPRESS_BUFFER_SIZE;
                    }
                }
            }

            if (bytesComp >= bytesRead) {
                compType = CompressNone;
                compSize = (USHORT)bytesRead;
                CopyMemory (CompressedHandle->ReadBuffer, &compType, sizeof (USHORT));
                CopyMemory (CompressedHandle->ReadBuffer + sizeof (USHORT), &compSize, sizeof (USHORT));

                compSize += (2 * sizeof (USHORT));

                if (CompressedHandle->CurrFileSize + compSize > CompressedHandle->MaxFileSize) {
                    if (!pPrepareNextFileW (CompressedHandle, FALSE)) {
                        __leave;
                    }
                }

                if (!BfWriteFile (CompressedHandle->CurrFileHandle, CompressedHandle->ReadBuffer, compSize)) {
                    __leave;
                }
                CompressedHandle->CurrFileSize += compSize;
            } else {
                compType = CompressMrci1;
                compSize = (USHORT)bytesComp;
                CopyMemory (CompressedHandle->CompBuffer, &compType, sizeof (USHORT));
                CopyMemory (CompressedHandle->CompBuffer + sizeof (USHORT), &compSize, sizeof (USHORT));

                compSize += (2 * sizeof (USHORT));

                if (CompressedHandle->CurrFileSize + compSize > CompressedHandle->MaxFileSize) {
                    if (!pPrepareNextFileW (CompressedHandle, FALSE)) {
                        __leave;
                    }
                }

                if (!BfWriteFile (CompressedHandle->CurrFileHandle, CompressedHandle->CompBuffer, compSize)) {
                    __leave;
                }
                CompressedHandle->CurrFileSize += compSize;
            }
            fileSize -= bytesRead;
        }
        CompressedHandle->FilesStored ++;

        result = TRUE;
    }
    __finally {
        PushError ();
        if (fileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle (fileHandle);
        }
        if (!result) {
            // let's restore the state of the compress handle
            if (savedIndex == CompressedHandle->CurrFileIndex) {
                if (savedSize.QuadPart != CompressedHandle->CurrFileSize) {
                    SetFilePointer (CompressedHandle->CurrFileHandle, savedSize.LowPart, &(savedSize.HighPart), FILE_BEGIN);
                    SetEndOfFile (CompressedHandle->CurrFileHandle);
                    CompressedHandle->CurrFileSize = savedSize.QuadPart;
                }
            } else {
                CompressedHandle->CurrFileIndex = savedIndex - 1;
                pPrepareNextFileW (CompressedHandle, TRUE);
                SetFilePointer (CompressedHandle->CurrFileHandle, savedSize.LowPart, &(savedSize.HighPart), FILE_BEGIN);
                SetEndOfFile (CompressedHandle->CurrFileHandle);
                CompressedHandle->CurrFileSize = savedSize.QuadPart;
                pDeleteNextFilesW (CompressedHandle, savedIndex);
            }
        }
        PopError ();
    }

    return result;
}

BOOL
CompressFlushAndCloseHandleA (
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle
    )
{
    CHAR currFile [MAX_PATH];
    PCSTR currFullPath = NULL;
    DWORD signature = COMPRESS_SIG;
    BOOL result = FALSE;

    __try {

        if ((CompressedHandle) &&
            (CompressedHandle->CurrFileHandle) &&
            (CompressedHandle->CurrFileHandle != INVALID_HANDLE_VALUE)
            ) {
            result = CloseHandle (CompressedHandle->CurrFileHandle);
            CompressedHandle->CurrFileHandle = NULL;
            if (result) {
                // write the total number of files compressed into the first file
                result = FALSE;
                wsprintfA (currFile, CompressedHandle->MainFilePattern, CompressedHandle->FirstFileIndex);
                currFullPath = JoinPathsA (CompressedHandle->StorePath, currFile);
                CompressedHandle->CurrFileHandle = BfOpenFileA (currFullPath);
                if ((CompressedHandle->CurrFileHandle == NULL) ||
                    (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
                    ) {
                    __leave;
                }
                FreePathStringA (currFullPath);
                currFullPath = NULL;

                // write again the signature
                if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                    __leave;
                }

                // write number of files compressed
                if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&CompressedHandle->FilesStored), sizeof (LONGLONG))) {
                    __leave;
                }

                result = CloseHandle (CompressedHandle->CurrFileHandle);
                CompressedHandle->CurrFileHandle = NULL;
            }
        }
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringA (currFullPath);
            currFullPath = NULL;
        }
        CompressCleanupHandleA (CompressedHandle);
        PopError ();
    }

    return result;
}

BOOL
CompressFlushAndCloseHandleW (
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle
    )
{
    WCHAR currFile [MAX_PATH];
    PCWSTR currFullPath = NULL;
    DWORD signature = COMPRESS_SIG;
    BOOL result = FALSE;

    __try {

        if ((CompressedHandle) &&
            (CompressedHandle->CurrFileHandle) &&
            (CompressedHandle->CurrFileHandle != INVALID_HANDLE_VALUE)
            ) {
            result = CloseHandle (CompressedHandle->CurrFileHandle);
            CompressedHandle->CurrFileHandle = NULL;
            if (result) {
                // write the total number of files compressed into the first file
                result = FALSE;
                wsprintfW (currFile, CompressedHandle->MainFilePattern, CompressedHandle->FirstFileIndex);
                currFullPath = JoinPathsW (CompressedHandle->StorePath, currFile);
                CompressedHandle->CurrFileHandle = BfOpenFileW (currFullPath);
                if ((CompressedHandle->CurrFileHandle == NULL) ||
                    (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
                    ) {
                    __leave;
                }
                FreePathStringW (currFullPath);
                currFullPath = NULL;

                // write again the signature
                if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                    __leave;
                }

                // write number of files compressed
                if (!BfWriteFile (CompressedHandle->CurrFileHandle, (PBYTE)(&CompressedHandle->FilesStored), sizeof (LONGLONG))) {
                    __leave;
                }

                result = CloseHandle (CompressedHandle->CurrFileHandle);
                CompressedHandle->CurrFileHandle = NULL;
            }
        }
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringW (currFullPath);
            currFullPath = NULL;
        }
        CompressCleanupHandleW (CompressedHandle);
        PopError ();
    }

    return result;
}

BOOL
CompressOpenHandleA (
    IN      PCSTR StorePath,
    IN      PCSTR MainFilePattern,
    IN      UINT StartIndex,
    OUT     PCOMPRESS_HANDLEA CompressedHandle
    )
{
    CHAR currFile [MAX_PATH];
    PCSTR currFullPath = NULL;
    DWORD signature = 0;
    BOOL result = FALSE;

    __try {
        ZeroMemory (CompressedHandle, sizeof (COMPRESS_HANDLEA));
        if (StartIndex == 0) {
            CompressedHandle->CurrFileIndex = 1;
        } else {
            CompressedHandle->CurrFileIndex = StartIndex;
        }
        CompressedHandle->FirstFileIndex = CompressedHandle->CurrFileIndex;
        CompressedHandle->StorePath = DuplicatePathStringA (StorePath, 0);
        if (!CompressedHandle->StorePath) {
            __leave;
        }
        CompressedHandle->MainFilePattern = DuplicatePathStringA (MainFilePattern, 0);
        if (!CompressedHandle->MainFilePattern) {
            __leave;
        }
        wsprintfA (currFile, CompressedHandle->MainFilePattern, CompressedHandle->CurrFileIndex);
        currFullPath = JoinPathsA (CompressedHandle->StorePath, currFile);
        CompressedHandle->CurrFileHandle = BfOpenReadFileA (currFullPath);
        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }
        FreePathStringA (currFullPath);
        currFullPath = NULL;

        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        if (signature != COMPRESS_SIG) {
            SetLastError (ERROR_INVALID_DATA);
            __leave;
        }

        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&CompressedHandle->FilesStored), sizeof (LONGLONG))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (LONGLONG);

        CompressedHandle->ReadBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->ReadBuffer) {
            __leave;
        }

        CompressedHandle->CompBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->CompBuffer) {
            __leave;
        }

        result = TRUE;
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringA (currFullPath);
            currFullPath = NULL;
        }
        if (!result) {
            CompressCleanupHandleA (CompressedHandle);
        }
        PopError ();
    }
    return result;
}

BOOL
CompressOpenHandleW (
    IN      PCWSTR StorePath,
    IN      PCWSTR MainFilePattern,
    IN      UINT StartIndex,
    OUT     PCOMPRESS_HANDLEW CompressedHandle
    )
{
    WCHAR currFile [MAX_PATH];
    PCWSTR currFullPath = NULL;
    DWORD signature = 0;
    BOOL result = FALSE;

    __try {
        ZeroMemory (CompressedHandle, sizeof (COMPRESS_HANDLEW));
        if (StartIndex == 0) {
            CompressedHandle->CurrFileIndex = 1;
        } else {
            CompressedHandle->CurrFileIndex = StartIndex;
        }
        CompressedHandle->FirstFileIndex = CompressedHandle->CurrFileIndex;
        CompressedHandle->StorePath = DuplicatePathStringW (StorePath, 0);
        if (!CompressedHandle->StorePath) {
            __leave;
        }
        CompressedHandle->MainFilePattern = DuplicatePathStringW (MainFilePattern, 0);
        if (!CompressedHandle->MainFilePattern) {
            __leave;
        }
        wsprintfW (currFile, CompressedHandle->MainFilePattern, CompressedHandle->CurrFileIndex);
        currFullPath = JoinPathsW (CompressedHandle->StorePath, currFile);
        CompressedHandle->CurrFileHandle = BfOpenReadFileW (currFullPath);
        if ((CompressedHandle->CurrFileHandle == NULL) ||
            (CompressedHandle->CurrFileHandle == INVALID_HANDLE_VALUE)
            ) {
            __leave;
        }
        FreePathStringW (currFullPath);
        currFullPath = NULL;

        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (DWORD);

        if (signature != COMPRESS_SIG) {
            SetLastError (ERROR_INVALID_DATA);
            __leave;
        }

        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&CompressedHandle->FilesStored), sizeof (LONGLONG))) {
            __leave;
        }
        CompressedHandle->CurrFileSize += sizeof (LONGLONG);

        CompressedHandle->ReadBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->ReadBuffer) {
            __leave;
        }

        CompressedHandle->CompBuffer = MemAlloc (g_hHeap, 0, COMPRESS_BUFFER_SIZE + 2 * sizeof (USHORT));
        if (!CompressedHandle->CompBuffer) {
            __leave;
        }

        result = TRUE;
    }
    __finally {
        PushError ();
        if (currFullPath) {
            FreePathStringW (currFullPath);
            currFullPath = NULL;
        }
        if (!result) {
            CompressCleanupHandleW (CompressedHandle);
        }
        PopError ();
    }
    return result;
}

BOOL
CompressExtractAllFilesA (
    IN      PCSTR ExtractPath,
    IN OUT  PCOMPRESS_HANDLEA CompressedHandle,
    IN      PCOMPRESSNOTIFICATIONA CompressNotification OPTIONAL
    )
{
    DWORD signature;
    LONGLONG fileSize;
    LONGLONG fileSizeRead;
    DWORD fileNameSize;
    PCWSTR storedName = NULL;
    PCSTR storedNameA = NULL;
    PCSTR extractPath = NULL;
    PCSTR newFileName = NULL;
    BOOL extractFile = TRUE;
    HANDLE extractHandle = NULL;
    USHORT compType = 0;
    USHORT compSize = 0;
    DWORD bytesComp;
    LARGE_INTEGER savedSize;
    BOOL result = FALSE;

    __try {

        for (;;) {

            // read the header for this file

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                // It is possible that we continue onto the next file, let's try that.
                if (!pPrepareNextFileA (CompressedHandle, TRUE)) {
                    result = TRUE;
                    __leave;
                }
                if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                    __leave;
                }
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);
            if (signature != COMPRESS_NEWFILE) {
                SetLastError (ERROR_INVALID_DATA);
                __leave;
            }

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileSize), sizeof (LONGLONG))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (LONGLONG);
            fileSizeRead = 0;

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileNameSize), sizeof (DWORD))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);

            storedName = MemAlloc (g_hHeap, 0, fileNameSize);

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(storedName), fileNameSize)) {
                __leave;
            }
            CompressedHandle->CurrFileSize += fileNameSize;

            storedNameA = ConvertWtoA (storedName);
            if (!storedNameA) {
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                __leave;
            }

            extractPath = JoinPathsA (ExtractPath, storedNameA);
            if (!extractPath) {
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                __leave;
            }

            extractFile = TRUE;
            newFileName = NULL;
            if (CompressNotification) {
                if (!CompressNotification (extractPath, fileSize, &extractFile, &newFileName)) {
                    __leave;
                }
            }

            if (extractFile) {
                if (newFileName) {
                    // let's make sure that the directory exists
                    BfCreateDirectoryExA (newFileName, FALSE);
                }
                extractHandle = BfCreateFileA (newFileName?newFileName:extractPath);
                if ((extractHandle == NULL) ||
                    (extractHandle == INVALID_HANDLE_VALUE)
                    ) {
                    __leave;
                }
            } else {
                extractHandle = NULL;
            }

            if (newFileName) {
                FreePathStringA (newFileName);
                newFileName = NULL;
            }

            FreePathStringA (extractPath);
            extractPath = NULL;

            MemFree (g_hHeap, 0, storedName);
            storedName = NULL;

            FreeConvertedStr (storedNameA);
            storedNameA = NULL;

            if (fileSize > 0) {
                if (!extractFile && g_ErrorMode) {
                    for (;;) {
                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                            // It is possible that we continue onto the next file, let's try that.
                            if (!pPrepareNextFileA (CompressedHandle, TRUE)) {
                                // we might be at the end of the compressed file, there are no other files here
                                result = TRUE;
                                __leave;
                            }
                            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                                __leave;
                            }
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compSize), sizeof (USHORT))) {
                            __leave;
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        // let's try to see if we just read a new file signature
                        *((PUSHORT)(&signature) + 0) = compType;
                        *((PUSHORT)(&signature) + 1) = compSize;
                        if (signature == COMPRESS_NEWFILE) {
                            // this is a new file
                            CompressedHandle->CurrFileSize -= sizeof (USHORT);
                            CompressedHandle->CurrFileSize -= sizeof (USHORT);
                            // rewind the file current pointer;
                            savedSize.QuadPart = CompressedHandle->CurrFileSize;
                            SetFilePointer (CompressedHandle->CurrFileHandle, savedSize.LowPart, &(savedSize.HighPart), FILE_BEGIN);
                            // we are done with the current file
                            break;
                        } else {
                            // Let's advance the file pointer
                            if (SetFilePointer (CompressedHandle->CurrFileHandle, compSize, NULL, FILE_CURRENT) == INVALID_SET_FILE_POINTER) {
                                __leave;
                            }
                            CompressedHandle->CurrFileSize += compSize;
                        }
                    }
                } else {
                    for (;;) {
                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                            // It is possible that we continue onto the next file, let's try that.
                            if (!pPrepareNextFileA (CompressedHandle, TRUE)) {
                                __leave;
                            }
                            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                                __leave;
                            }
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compSize), sizeof (USHORT))) {
                            __leave;
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        if (!BfReadFile (CompressedHandle->CurrFileHandle, CompressedHandle->CompBuffer, compSize)) {
                            __leave;
                        }
                        CompressedHandle->CurrFileSize += compSize;

                        if (compType == CompressNone) {
                            if (extractFile) {
                                if (!BfWriteFile (extractHandle, CompressedHandle->CompBuffer, compSize)) {
                                    __leave;
                                }
                            }
                            fileSizeRead += compSize;
                        } else {
                            bytesComp = DecompressData (
                                            compType,
                                            CompressedHandle->CompBuffer,
                                            compSize,
                                            CompressedHandle->ReadBuffer,
                                            COMPRESS_BUFFER_SIZE
                                            );
                            if (bytesComp > COMPRESS_BUFFER_SIZE) {
                                SetLastError (ERROR_INVALID_DATA);
                                __leave;
                            }
                            if (extractFile) {
                                if (!BfWriteFile (extractHandle, CompressedHandle->ReadBuffer, bytesComp)) {
                                    __leave;
                                }
                            }
                            fileSizeRead += bytesComp;
                        }

                        if (fileSizeRead == fileSize) {
                            // this file is done, let's go to the next one
                            break;
                        }
                    }
                }
            }

            if (extractHandle) {
                CloseHandle (extractHandle);
                extractHandle = NULL;
            }
        }
    }
    __finally {
        if (storedName != NULL) {
            MemFree (g_hHeap, 0, storedName);
            storedName = NULL;
        }
        if (storedNameA != NULL) {
            FreeConvertedStr (storedNameA);
            storedNameA = NULL;
        }
        if (newFileName != NULL) {
            FreePathStringA (newFileName);
            newFileName = NULL;
        }
        if (extractPath != NULL) {
            FreePathStringA (extractPath);
            extractPath = NULL;
        }
        if ((extractHandle != NULL) &&
            (extractHandle != INVALID_HANDLE_VALUE)
            ) {
            CloseHandle (extractHandle);
            extractHandle = NULL;
        }
    }

    return result;
}

BOOL
CompressExtractAllFilesW (
    IN      PCWSTR ExtractPath,
    IN OUT  PCOMPRESS_HANDLEW CompressedHandle,
    IN      PCOMPRESSNOTIFICATIONW CompressNotification OPTIONAL
    )
{
    DWORD signature;
    LONGLONG fileSize;
    LONGLONG fileSizeRead;
    DWORD fileNameSize;
    PCWSTR storedName = NULL;
    PCWSTR extractPath = NULL;
    PCWSTR newFileName = NULL;
    BOOL extractFile = TRUE;
    HANDLE extractHandle = NULL;
    USHORT compType = 0;
    USHORT compSize = 0;
    DWORD bytesComp;
    LARGE_INTEGER savedSize;
    BOOL result = FALSE;

    __try {

        for (;;) {

            // read the header for this file

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                // It is possible that we continue onto the next file, let's try that.
                if (!pPrepareNextFileW (CompressedHandle, TRUE)) {
                    result = TRUE;
                    __leave;
                }
                if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                    __leave;
                }
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);
            if (signature != COMPRESS_NEWFILE) {
                SetLastError (ERROR_INVALID_DATA);
                __leave;
            }

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileSize), sizeof (LONGLONG))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (LONGLONG);
            fileSizeRead = 0;

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&fileNameSize), sizeof (DWORD))) {
                __leave;
            }
            CompressedHandle->CurrFileSize += sizeof (DWORD);

            storedName = MemAlloc (g_hHeap, 0, fileNameSize);

            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(storedName), fileNameSize)) {
                __leave;
            }
            CompressedHandle->CurrFileSize += fileNameSize;

            extractPath = JoinPathsW (ExtractPath, storedName);
            if (!extractPath) {
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                __leave;
            }

            extractFile = TRUE;
            newFileName = NULL;
            if (CompressNotification) {
                if (!CompressNotification (extractPath, fileSize, &extractFile, &newFileName)) {
                    __leave;
                }
            }

            if (extractFile) {
                if (newFileName) {
                    // let's make sure that the directory exists
                    BfCreateDirectoryExW (newFileName, FALSE);
                }
                extractHandle = BfCreateFileW (newFileName?newFileName:extractPath);
                if ((extractHandle == NULL) ||
                    (extractHandle == INVALID_HANDLE_VALUE)
                    ) {
                    __leave;
                }
            } else {
                extractHandle = NULL;
            }

            if (newFileName) {
                FreePathStringW (newFileName);
                newFileName = NULL;
            }

            FreePathStringW (extractPath);
            extractPath = NULL;

            MemFree (g_hHeap, 0, storedName);
            storedName = NULL;

            if (fileSize) {
                if (!extractFile && g_ErrorMode) {
                    for (;;) {
                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                            // It is possible that we continue onto the next file, let's try that.
                            if (!pPrepareNextFileW (CompressedHandle, TRUE)) {
                                // we might be at the end of the compressed file, there are no other files here
                                result = TRUE;
                                __leave;
                            }
                            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                                __leave;
                            }
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compSize), sizeof (USHORT))) {
                            __leave;
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        // let's try to see if we just read a new file signature
                        *((PUSHORT)(&signature + 0)) = compType;
                        *((PUSHORT)(&signature + 1)) = compSize;
                        if (signature == COMPRESS_NEWFILE) {
                            // this is a new file
                            CompressedHandle->CurrFileSize -= sizeof (USHORT);
                            CompressedHandle->CurrFileSize -= sizeof (USHORT);
                            // rewind the file current pointer;
                            savedSize.QuadPart = CompressedHandle->CurrFileSize;
                            SetFilePointer (CompressedHandle->CurrFileHandle, savedSize.LowPart, &(savedSize.HighPart), FILE_BEGIN);
                            // we are done with the current file
                            break;
                        } else {
                            // Let's advance the file pointer
                            if (SetFilePointer (CompressedHandle->CurrFileHandle, compSize, NULL, FILE_CURRENT) == INVALID_SET_FILE_POINTER) {
                                __leave;
                            }
                            CompressedHandle->CurrFileSize += compSize;
                        }
                    }
                } else {
                    for (;;) {
                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                            // It is possible that we continue onto the next file, let's try that.
                            if (!pPrepareNextFileW (CompressedHandle, TRUE)) {
                                __leave;
                            }
                            if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compType), sizeof (USHORT))) {
                                __leave;
                            }
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        if (!BfReadFile (CompressedHandle->CurrFileHandle, (PBYTE)(&compSize), sizeof (USHORT))) {
                            __leave;
                        }
                        CompressedHandle->CurrFileSize += sizeof (USHORT);

                        if (!BfReadFile (CompressedHandle->CurrFileHandle, CompressedHandle->CompBuffer, compSize)) {
                            __leave;
                        }
                        CompressedHandle->CurrFileSize += compSize;

                        if (compType == CompressNone) {
                            if (extractFile) {
                                if (!BfWriteFile (extractHandle, CompressedHandle->CompBuffer, compSize)) {
                                    __leave;
                                }
                            }
                            fileSizeRead += compSize;
                        } else {
                            bytesComp = DecompressData (
                                            compType,
                                            CompressedHandle->CompBuffer,
                                            compSize,
                                            CompressedHandle->ReadBuffer,
                                            COMPRESS_BUFFER_SIZE
                                            );
                            if (bytesComp > COMPRESS_BUFFER_SIZE) {
                                SetLastError (ERROR_INVALID_DATA);
                                __leave;
                            }
                            if (extractFile) {
                                if (!BfWriteFile (extractHandle, CompressedHandle->ReadBuffer, bytesComp)) {
                                    __leave;
                                }
                            }
                            fileSizeRead += bytesComp;
                        }

                        if (fileSizeRead == fileSize) {
                            // this file is done, let's go to the next one
                            break;
                        }
                    }
                }
            }

            if (extractHandle) {
                CloseHandle (extractHandle);
                extractHandle = NULL;
            }
        }
    }
    __finally {
        if (storedName != NULL) {
            MemFree (g_hHeap, 0, storedName);
            storedName = NULL;
        }
        if (newFileName != NULL) {
            FreePathStringW (newFileName);
            newFileName = NULL;
        }
        if (extractPath != NULL) {
            FreePathStringW (extractPath);
            extractPath = NULL;
        }
        if ((extractHandle != NULL) &&
            (extractHandle != INVALID_HANDLE_VALUE)
            ) {
            CloseHandle (extractHandle);
            extractHandle = NULL;
        }
    }

    return result;
}

BOOL
CompressSetErrorMode (
    IN      BOOL ErrorMode
    )
{
    BOOL oldErrorMode = g_ErrorMode;

    g_ErrorMode = ErrorMode;
    return oldErrorMode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\compress\mrcicode.c ===
/*
 *  Microsoft Confidential
 *  Copyright (c) 1994 Microsoft Corporation
 *  All Rights Reserved.
 *
 *  MRCICODE.C
 *
 *  MRCI 1 & MRCI 2 maxcompress and decompress functions
 */
#include "pch.h"
#include "mrcicode.h"                   /* prototype verification */

#include <assert.h>                     /* use NDEBUG to inhibit */
#include <setjmp.h>                     /* fast overflow recovery */

#define LOGCHASH        (13)            /* Log of max. no. of hash buckets */
#define CHASH           (1U << LOGCHASH) /* Reasonably large table */

#define hash(w)         ((w) & (CHASH - 1))
                                        /* Simply toss the high-order bits */
#define word(p)         ((p)[0] + (((p)[1]) << 8))
                                        /* Return word at location */

#define BITMASK(x)      ((1 << x) - 1)  /* returns lower 'x' bits set */

#define LOGDISPSMALL    (6)             /* Number of bits in small disp */
#define LOGDISPMED      (8)             /* Number of bits in medium disp */
#define LOGDISPBIG      (12)            /* Number of bits in big displacement */

#define MAXDISPSMALL    ((1 << LOGDISPSMALL) - 1)
                                        /* Maximum small displacement */
#define MAXDISPMED      ((1 << LOGDISPMED) + MAXDISPSMALL)
                                        /* Maximum medium displacement */
#define MAXDISPBIG      ((1 << LOGDISPBIG) + MAXDISPMED)
                                        /* Maximum big displacement */

#define MINDISPSMALL    (0)             /* Minimum small displacement */
#define MINDISPMED      (MAXDISPSMALL + 1)
                                        /* Minimum medium displacement */
#define MINDISPBIG      (MAXDISPMED + 1)/* Minimum big displacement */

#define DISPMAX         (MAXDISPBIG - 1)/* MAXDISPBIG is our end marker */

#define MINMATCH1       (2)             /* Minimum match length for MRCI1 */
#define MINMATCH2       (3)             /* Minimum match length for MRCI2 */
#define MAXMATCH        (512)           /* Maximum match length */

#define EOB             (0)             /* length used to mean end of block */

#define SECTOR          (512)           /* blocking factor */

#define SIG_SIZE        (4)             /* # of block type prefix bytes */


/* local variables */

static unsigned abits;                  /* Array of bits */
static unsigned cbitsleft;              /* Number of bits in abits */
static unsigned char FAR *pCompressed;  /* pointer into compressed data */
static unsigned cCompressed;            /* # bytes remaining @ pCompressed */
static jmp_buf bailout;                 /* longjmp if cCompressed exceeded */

static unsigned ahash[CHASH];           /* Hash table */
static unsigned alink[MAXDISPBIG];      /* Links */


/* compression internal functions */

static void inithash(void);
static void charbuf(unsigned c);
static void putbits(unsigned bits,unsigned cbits);
static void outlength(unsigned cb);

static void mrci1outsingle(unsigned ch);
static void mrci1outstring(unsigned disp,unsigned cb);

static void mrci2outsingle(unsigned ch);
static void mrci2outstring(unsigned disp,unsigned cb);


/* decompression internal functions */

static unsigned getbit(void);
static unsigned getbits(unsigned cbits);
static void expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb);


/*
 *  (compress) Reset the hash tables between blocks.
 */

static void inithash(void)
{
    unsigned FAR *entry;
    int i;

    entry = ahash;
    i = CHASH;

    do
    {
        *entry++ = (unsigned) -1;       /* Mark all entries as empty */
    } while (--i);
}


/*
 *  (compress) Add a character to compressed output buffer.
 */

static void charbuf(unsigned c)
{
    if (cCompressed-- == 0)             /* make sure there's room */
    {
        longjmp(bailout,1);             /* Data expanding! */
    }

    *pCompressed++ = (unsigned char) c; /* Put character into buffer */
}


/*
 *  (compress) Write n bits to the compressed bitstream.
 */

static void putbits(unsigned ab,unsigned cbits)
{
    do                                  /* Loop to emit bits */
    {
        if (cbits > cbitsleft)          /* if not enough space */
        {
            cbits -= cbitsleft;         /* doing partial */

            abits |= (ab << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            ab >>= cbitsleft;           /* clip sent bits */

            charbuf(abits);             /* Emit the buffer */
            cbitsleft = 8;              /* Reset buffer count */
            abits = 0;                  /* Reset buffer */
        }
        else                            /* can do all in one pass */
        {
            abits |= ((ab & BITMASK(cbits)) << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            cbitsleft -= cbits;         /* used up some buffer */

            if (cbitsleft == 0)         /* If buffer full */
            {
                charbuf(abits);         /* Emit the buffer */
                cbitsleft = 8;          /* Reset buffer count */
                abits = 0;              /* Reset buffer */
            }

            break;                      /* we've done all cbits */
        }
    } while (cbits);                    /* repeat until done */
}


/*
 *  (compress) Encode a length into the compressed stream.
 */

static void outlength(unsigned cb)
{
    unsigned alogbits, clogbits;
    unsigned avaluebits, cvaluebits;

    assert(cb >= 2);                    /* Length must be at least two */
    assert(cb <= MAXMATCH);

    if (cb <= 2)
    {
        alogbits = 1;
        clogbits = 1;
        cvaluebits = 0;
    }
    else if (cb <= 4)
    {
        alogbits = 1 << 1;
        clogbits = 2;
        avaluebits = cb - 3;
        cvaluebits = 1;
    }
    else if (cb <= 8)
    {
        alogbits = 1 << 2;
        clogbits = 3;
        avaluebits = cb - 5;
        cvaluebits = 2;
    }
    else if (cb <= 16)
    {
        alogbits = 1 << 3;
        clogbits = 4;
        avaluebits = cb - 9;
        cvaluebits = 3;
    }
    else if (cb <= 32)
    {
        alogbits = 1 << 4;
        clogbits = 5;
        avaluebits = cb - 17;
        cvaluebits = 4;
    }
    else if (cb <= 64)
    {
        alogbits = 1 << 5;
        clogbits = 6;
        avaluebits = cb - 33;
        cvaluebits = 5;
    }
    else if (cb <= 128)
    {
        alogbits = 1 << 6;
        clogbits = 7;
        avaluebits = cb - 65;
        cvaluebits = 6;
    }
    else if (cb <= 256)
    {
        alogbits = 1 << 7;
        clogbits = 8;
        avaluebits = cb - 129;
        cvaluebits = 7;
    }
    else /* (cb <= 512) */
    {
        alogbits = 1 << 8;
        clogbits = 9;
        avaluebits = cb - 257;
        cvaluebits = 8;
    }

    putbits(alogbits,clogbits);

    if (cvaluebits)
    {
        putbits(avaluebits,cvaluebits);
    }
}


/*
 *  (MRCI1 compress) Encode a literal into the compressed stream.
 */

static void mrci1outsingle(unsigned ch)
{
    ch = (ch << 2) | ((ch & 0x80) ? 1 : 2);

    putbits(ch,9);
}


/*
 *  (MRCI2 compress) Encode a literal into the compressed stream.
 */

static void mrci2outsingle(unsigned ch)
{
    if (ch & 0x80)
    {
        putbits((ch << 2) | 3,9);
    }
    else
    {
        putbits(ch << 1,8);
    }
}


/*
 *  (MRCI1 compress) Encode a match into the compressed stream.
 */

static void mrci1outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH1) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 2),LOGDISPSMALL + 2);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 3) | 3,LOGDISPMED + 3);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 3) | 7,LOGDISPBIG + 3);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb);                  /* Emit the match length */
    }
}


/*
 *  (MRCI2 compress) Encode a match into the compressed stream.
 */

static void mrci2outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH2) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 3) | 1,LOGDISPSMALL + 3);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 4) | 5,LOGDISPMED + 4);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 4) | 13,LOGDISPBIG + 4);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb - 1);              /* Emit the match length */
    }
}


/*
 *  (MRCI1) MaxCompress
 */

unsigned Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'D';
    *pCompressed++ = 'S';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH1)   /* If we have a string match */
            {
                mrci1outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci1outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci1outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci1outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (MRCI2) MaxCompress
 */

unsigned Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'J';
    *pCompressed++ = 'M';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH2)   /* If we have a string match */
            {
                mrci2outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci2outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci2outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci2outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (decompress) Get a single bit from the compressed input stream.
 */

static unsigned getbit(void)
{
    unsigned bit;                       /* Bit */

    if (cbitsleft)                      /* If bits available */
    {
        cbitsleft--;                    /* Decrement bit count */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }
    else                                /* no bits available */
    {
        if (cCompressed-- == 0)         /* If buffer empty */
        {
            longjmp(bailout,1);         /* input overrun */
        }

        cbitsleft = 7;                  /* Reset count */

        abits = *pCompressed++;         /* Get a byte */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }

    return(bit);                        /* Return the bit */
}


/*
 *  (decompress) Get multiple bits from the compressed input stream.
 */

static unsigned getbits(unsigned cbits)
{
    unsigned bits;                      /* Bits to return */
    unsigned cbitsdone;                 /* number of bits added so far */
    unsigned cbitsneeded;               /* number of bits still needed */

    if (cbits <= cbitsleft)             /* If we have enough bits */
    {
        bits = abits;                   /* Get the bits */
        cbitsleft -= cbits;             /* Decrement bit count */
        abits >>= cbits;                /* Remove used bits */
    }
    else                                /* If we'll need to read more bits */
    {
        bits = 0;                       /* No bits set yet */
        cbitsdone = 0;                  /* no bits added yet */
        cbitsneeded = cbits;            /* bits needed */

        do
        {
            if (cbitsleft == 0)         /* If no bits ready */
            {
                if (cCompressed-- == 0) /* count down used */
                {
                    longjmp(bailout,1); /* if input overrun */
                }

                cbitsleft = 8;          /* Reset count */

                abits = *pCompressed++;  /* Get 8 new bits */
            }

            bits |= (abits << cbitsdone);  /* copy bits for output */

            if (cbitsleft >= cbitsneeded)  /* if enough now */
            {
                cbitsleft -= cbitsneeded;  /* reduce bits remaining available */
                abits >>= cbitsneeded;  /* discard used bits */
                break;                  /* got them */
            }
            else                        /* if not enough yet */
            {
                cbitsneeded -= cbitsleft;  /* reduce bits still needed */
                cbitsdone += cbitsleft;  /* increase shift for future bits */
                cbitsleft = 0;          /* reduce bits remaining available */
            }
        } while (cbitsneeded);          /* go back if more bits needed */
    }

    return(bits & BITMASK(cbits));      /* Return the bits */
}


/*
 *  (decompress) Expand a match.
 *
 *  Note: source overwrite is required (so we can't memcpy or memmove)
 */

static void expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb)
{
    unsigned char FAR *source;
    unsigned char FAR *target;

    assert(cb != 0);

    target = *ppchout;                  /* where the bytes go */
    source = target - disp;             /* where the bytes come from */

    *ppchout += cb;                     /* Update the output pointer */

    while (cb--)
    {
        *target++ = *source++;
    }
}


/*
 *  (MRCI1) Decompress
 */

unsigned Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned b;                         /* A byte */
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'D') || (*pCompressed++ != 'S'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        b = getbits(2);                 /* get two bits */

        if (b == 1)                     /* If single byte 128..255 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) (getbits(7) | 0x80);
            continue;                   /* Next token */
        }

        if (b == 2)                     /* If single byte 0..127 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) getbits(7);
            continue;                   /* Next token */
        }

        if (b == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else  /* b == 3 */
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(b <= 15);                /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length);  /* Copy the match */
    }

    return((pchout - pchdecBase));      /* Return decompressed size */
}


/*
 *  (MRCI2) Decompress
 */

unsigned Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'J') || (*pCompressed++ != 'M'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        if (getbit() == 0)              /* literal 00..7F */
        {
            *pchout++ = (unsigned char) getbits(7);

            continue;                   /* Next token */
        }

        if (getbit() == 1)              /* literal 80..FF */
        {
            *pchout++ = (unsigned char)(getbits(7) | 0x80);

            continue;                   /* Next token */
        }

        if (getbit() == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(length <= 15);           /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length + 1);  /* Copy the match */
    }

    return((pchout - pchdecBase));      /* Return decompressed size */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\tools\utiltool\template\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.c

Abstract:

    <TODO: fill in abstract>

Author:

    TODO: <full name> (<alias>) <date>

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

#include "pch.h"
#include "wininet.h"
#include <lm.h>

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL WINAPI MigUtil_Entry (HINSTANCE, DWORD, PVOID);
BOOL g_Source = FALSE;

BOOL
pCallEntryPoints (
    DWORD Reason
    )
{
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        UtInitialize (NULL);
        break;
    case DLL_PROCESS_DETACH:
        UtTerminate ();
        break;
    }

    return TRUE;
}


BOOL
Init (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    return pCallEntryPoints (DLL_PROCESS_ATTACH);
}


VOID
Terminate (
    VOID
    )
{
    pCallEntryPoints (DLL_PROCESS_DETACH);
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    fprintf (
        stderr,
        "Command Line Syntax:\n\n"

        //
        // TODO: Describe command line syntax(es), indent 2 spaces
        //

        "  utiltool [/F:file]\n"

        "\nDescription:\n\n"

        //
        // TODO: Describe tool, indent 2 spaces
        //

        "  <Not Specified>\n"

        "\nArguments:\n\n"

        //
        // TODO: Describe args, indent 2 spaces, say optional if necessary
        //

        "  /F  Specifies optional file name\n"

        );

    exit (1);
}

HANDLE
pOpenAndSetPort (
    IN      PCTSTR ComPort
    )
{
    HANDLE result = INVALID_HANDLE_VALUE;
    COMMTIMEOUTS commTimeouts;
    DCB dcb;

    // let's open the port. If we can't we just exit with error;
    result = CreateFile (ComPort, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (result == INVALID_HANDLE_VALUE) {
        return result;
    }

    // we want 10 sec timeout for both read and write
    commTimeouts.ReadIntervalTimeout = 0;
    commTimeouts.ReadTotalTimeoutMultiplier = 0;
    commTimeouts.ReadTotalTimeoutConstant = 10000;
    commTimeouts.WriteTotalTimeoutMultiplier = 0;
    commTimeouts.WriteTotalTimeoutConstant = 10000;
    SetCommTimeouts (result, &commTimeouts);

    // let's set some comm state data
    if (GetCommState (result, &dcb)) {
        dcb.fBinary = 1;
        dcb.fParity = 1;
        dcb.ByteSize = 8;
        if (g_Source) {
            dcb.BaudRate = CBR_115200;
        } else {
            dcb.BaudRate = CBR_57600;
        }
        if (!SetCommState (result, &dcb)) {
            CloseHandle (result);
            result = INVALID_HANDLE_VALUE;
            return result;
        }
    } else {
        CloseHandle (result);
        result = INVALID_HANDLE_VALUE;
        return result;
    }

    return result;
}

#define ACK     0x16
#define NAK     0x15
#define SOH     0x01
#define EOT     0x04

BOOL
pSendFileToHandle (
    IN      HANDLE DeviceHandle,
    IN      PCTSTR FileName
    )
{
    HANDLE fileHandle = NULL;
    BOOL result = TRUE;
    BYTE buffer [132];
    BYTE signal;
    BYTE currBlock = 0;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = FALSE;
    UINT index;

    fileHandle = BfOpenReadFile (FileName);
    if (!fileHandle) {
        return FALSE;
    }

    // finally let's start the protocol

    // We are going to listen for the NAK(15h) signal.
    // As soon as we get it we are going to send a 132 bytes block having:
    // 1 byte - SOH (01H)
    // 1 byte - block number
    // 1 byte - FF - block number
    // 128 bytes of data
    // 1 byte - checksum - sum of all 128 bytes of data
    // After the block is sent, we are going to wait for ACK(16h). If we don't get
    // it after timeout or if we get something else we are going to send the block again.

    // wait for NAK
    while (!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
           (numRead != 1) ||
           (signal != NAK)
           );

    repeat = FALSE;
    while (TRUE) {
        if (!repeat) {
            // prepare the next block
            currBlock ++;
            if (currBlock == 0) {
                result = TRUE;
            }
            buffer [0] = SOH;
            buffer [1] = currBlock;
            buffer [2] = 0xFF - currBlock;
            if (!ReadFile (fileHandle, buffer + 3, 128, &numRead, NULL) ||
                (numRead == 0)
                ) {
                // we are done with data, send the EOT signal
                signal = EOT;
                WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
                break;
            }

            // compute the checksum
            buffer [sizeof (buffer) - 1] = 0;
            signal = 0;
            for (index = 0; index < sizeof (buffer) - 1; index ++) {
                signal += buffer [index];
            }
            buffer [sizeof (buffer) - 1] = signal;
        }

        // now send the block to the other side
        if (!WriteFile (DeviceHandle, buffer, sizeof (buffer), &numWritten, NULL) ||
            (numWritten != sizeof (buffer))
            ) {
            repeat = TRUE;
        } else {
            repeat = FALSE;
        }

        if (repeat) {
            // we could not send the data last time
            // let's just wait for a NAK for 10 sec and then send it again
            ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL);
        } else {
            // we sent it OK. We need to wait for an ACK to come. If we timeout
            // or we get something else, we will repeat the block.
            if (!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
                (numRead != sizeof (signal)) ||
                (signal != ACK)
                ) {
                repeat = TRUE;
            }
        }
    }

    // we are done here. However, let's listen one more timeout for a
    // potential NAK. If we get it, we'll repeat the EOT signal
    while (ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) &&
        (numRead == 1)
        ) {
        if (signal == NAK) {
            signal = EOT;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        }
    }

    CloseHandle (fileHandle);

    return result;
}

BOOL
pSendFile (
    IN      PCTSTR ComPort,
    IN      PCTSTR FileName
    )
{
    HANDLE deviceHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    deviceHandle = pOpenAndSetPort (ComPort);
    if ((!deviceHandle) || (deviceHandle == INVALID_HANDLE_VALUE)) {
        return result;
    }

    result = pSendFileToHandle (deviceHandle, FileName);

    CloseHandle (deviceHandle);

    return result;
}

BOOL
pReceiveFileFromHandle (
    IN      HANDLE DeviceHandle,
    IN      PCTSTR FileName
    )
{
    HANDLE fileHandle = NULL;
    BOOL result = TRUE;
    BYTE buffer [132];
    BYTE signal;
    BYTE currBlock = 1;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = TRUE;
    UINT index;

    fileHandle = BfCreateFile (FileName);
    if (!fileHandle) {
        return FALSE;
    }

    // finally let's start the protocol

    // We are going to send an NAK(15h) signal.
    // After that we are going to listen for a block.
    // If we don't get the block in time, or the block is wrong size
    // or it has a wrong checksum we are going to send a NAK signal,
    // otherwise we are going to send an ACK signal
    // One exception. If the block size is 1 and the block is actually the
    // EOT signal it means we are done.

    while (TRUE) {
        if (repeat) {
            // send the NAK
            signal = NAK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        } else {
            // send the ACK
            signal = ACK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        }
        repeat = TRUE;
        // let's read the data block
        if (ReadFile (DeviceHandle, buffer, sizeof (buffer), &numRead, NULL)) {
            if ((numRead == 1) &&
                (buffer [0] == EOT)
                ) {
                break;
            }
            if (numRead == sizeof (buffer)) {
                // compute the checksum
                signal = 0;
                for (index = 0; index < sizeof (buffer) - 1; index ++) {
                    signal += buffer [index];
                }
                if (buffer [sizeof (buffer) - 1] == signal) {
                    repeat = FALSE;
                    // checksum is correct, let's see if this is the right block
                    if (currBlock < buffer [1]) {
                        // this is a major error, the sender is ahead of us,
                        // we have to fail
                        result = FALSE;
                        break;
                    }
                    if (currBlock == buffer [1]) {
                        WriteFile (fileHandle, buffer + 3, 128, &numWritten, NULL);
                        currBlock ++;
                    }
                }
            }
        }
    }

    CloseHandle (fileHandle);

    return result;
}

BOOL
pReceiveFile (
    IN      PCTSTR ComPort,
    IN      PCTSTR FileName
    )
{
    HANDLE deviceHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    deviceHandle = pOpenAndSetPort (ComPort);
    if ((!deviceHandle) || (deviceHandle == INVALID_HANDLE_VALUE)) {
        return result;
    }

    result = pReceiveFileFromHandle (deviceHandle, FileName);

    CloseHandle (deviceHandle);

    return result;
}

BOOL
pPrintStuff (
    PCTSTR ComPort
    )
{
    HANDLE comPortHandle = INVALID_HANDLE_VALUE;
    COMMTIMEOUTS commTimeouts;
    DCB dcb;
    COMMPROP commProp;

    printf ("Processing %s...\n\n", ComPort);

    comPortHandle = CreateFile (ComPort, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (comPortHandle == INVALID_HANDLE_VALUE) {
        printf ("Cannot open comport. Error: %d\n", GetLastError ());
        return FALSE;
    }

    if (GetCommTimeouts (comPortHandle, &commTimeouts)) {
        printf ("Timeouts:\n");
        printf ("ReadIntervalTimeout            %d\n", commTimeouts.ReadIntervalTimeout);
        printf ("ReadTotalTimeoutMultiplier     %d\n", commTimeouts.ReadTotalTimeoutMultiplier);
        printf ("ReadTotalTimeoutConstant       %d\n", commTimeouts.ReadTotalTimeoutConstant);
        printf ("WriteTotalTimeoutMultiplier    %d\n", commTimeouts.WriteTotalTimeoutMultiplier);
        printf ("WriteTotalTimeoutConstant      %d\n", commTimeouts.WriteTotalTimeoutConstant);
        printf ("\n");
    } else {
        printf ("Cannot get CommTimeouts. Error: %d\n\n", GetLastError ());
    }

    if (GetCommState (comPortHandle, &dcb)) {
        printf ("CommState:\n");
        printf ("DCBlength              %d\n", dcb.DCBlength);
        printf ("BaudRate               %d\n", dcb.BaudRate);
        printf ("fBinary                %d\n", dcb.fBinary);
        printf ("fParity                %d\n", dcb.fParity);
        printf ("fOutxCtsFlow           %d\n", dcb.fOutxCtsFlow);
        printf ("fOutxDsrFlow           %d\n", dcb.fOutxDsrFlow);
        printf ("fDtrControl            %d\n", dcb.fDtrControl);
        printf ("fDsrSensitivity        %d\n", dcb.fDsrSensitivity);
        printf ("fTXContinueOnXoff      %d\n", dcb.fTXContinueOnXoff);
        printf ("fOutX                  %d\n", dcb.fOutX);
        printf ("fInX                   %d\n", dcb.fInX);
        printf ("fErrorChar             %d\n", dcb.fErrorChar);
        printf ("fNull                  %d\n", dcb.fNull);
        printf ("fRtsControl            %d\n", dcb.fRtsControl);
        printf ("fAbortOnError          %d\n", dcb.fAbortOnError);
        printf ("fDummy2                %d\n", dcb.fDummy2);
        printf ("wReserved              %d\n", dcb.wReserved);
        printf ("XonLim                 %d\n", dcb.XonLim);
        printf ("XoffLim                %d\n", dcb.XoffLim);
        printf ("ByteSize               %d\n", dcb.ByteSize);
        printf ("Parity                 %d\n", dcb.Parity);
        printf ("StopBits               %d\n", dcb.StopBits);
        printf ("XonChar                %d\n", dcb.XonChar);
        printf ("XoffChar               %d\n", dcb.XoffChar);
        printf ("ErrorChar              %d\n", dcb.ErrorChar);
        printf ("EofChar                %d\n", dcb.EofChar);
        printf ("EvtChar                %d\n", dcb.EvtChar);
        printf ("wReserved1             %d\n", dcb.wReserved1);
        printf ("\n");
    } else {
        printf ("Cannot get CommState. Error: %d\n\n", GetLastError ());
    }

    if (GetCommProperties (comPortHandle, &commProp)) {
        printf ("CommProperties:\n");
        printf ("wPacketLength          %d\n", commProp.wPacketLength);
        printf ("wPacketVersion         %d\n", commProp.wPacketVersion);
        printf ("dwServiceMask          %d\n", commProp.dwServiceMask);
        printf ("dwReserved1            %d\n", commProp.dwReserved1);
        printf ("dwMaxTxQueue           %d\n", commProp.dwMaxTxQueue);
        printf ("dwMaxRxQueue           %d\n", commProp.dwMaxRxQueue);
        printf ("dwMaxBaud              %d\n", commProp.dwMaxBaud);
        printf ("dwProvSubType          %d\n", commProp.dwProvSubType);
        printf ("dwProvCapabilities     %d\n", commProp.dwProvCapabilities);
        printf ("dwSettableParams       %d\n", commProp.dwSettableParams);
        printf ("dwSettableBaud         %d\n", commProp.dwSettableBaud);
        printf ("wSettableData          %d\n", commProp.wSettableData);
        printf ("wSettableStopParity    %d\n", commProp.wSettableStopParity);
        printf ("dwCurrentTxQueue       %d\n", commProp.dwCurrentTxQueue);
        printf ("dwCurrentRxQueue       %d\n", commProp.dwCurrentRxQueue);
        printf ("dwProvSpec1            %d\n", commProp.dwProvSpec1);
        printf ("dwProvSpec2            %d\n", commProp.dwProvSpec2);
        printf ("wcProvChar             %S\n", commProp.wcProvChar);
        printf ("\n");
    } else {
        printf ("Cannot get CommProperties. Error: %d\n\n", GetLastError ());
    }
    return TRUE;
}

INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    PCTSTR FileArg = NULL;
    PCTSTR comPort = NULL;
    BOOL sender = FALSE;

    //
    // TODO: Parse command line here
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {
            switch (_totlower (_tcsnextc (&argv[i][1]))) {

            case TEXT('f'):
                //
                // Sample option - /f:file
                //

                if (argv[i][2] == TEXT(':')) {
                    FileArg = &argv[i][3];
                } else if (i + 1 < argc) {
                    FileArg = argv[++i];
                } else {
                    HelpAndExit();
                }

                break;

            case TEXT('s'):
                sender = TRUE;
                g_Source = TRUE;
                break;

            case TEXT('c'):
                //
                // Sample option - /f:file
                //

                if (argv[i][2] == TEXT(':')) {
                    comPort = &argv[i][3];
                } else if (i + 1 < argc) {
                    comPort = argv[++i];
                } else {
                    HelpAndExit();
                }

                break;

            default:
                HelpAndExit();
            }
        } else {
            //
            // Parse other args that don't require / or -
            //

            // None
            HelpAndExit();
        }
    }

    //
    // Begin processing
    //

    if (!Init()) {
        return 0;
    }

    //
    // TODO: Do work here
    //
    {

        pPrintStuff (comPort);

        /*
        if (sender) {
            pSendFile (comPort, FileArg);
        } else {
            pReceiveFile (comPort, FileArg);
        }
        */
    }

    //
    // End of processing
    //

    Terminate();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\cobra\utils\file\fileenum.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    fileenum.c

Abstract:

    Implements a set of APIs to enumerate a file system using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_FILEENUM    "FileEnum"

//
// Strings
//

#define S_FILEENUM      "FILEENUM"

//
// Constants
//

// None

//
// Macros
//

#define pFileAllocateMemory(Size)   PmGetMemory (g_FileEnumPool,Size)
#define pFileFreeMemory(Buffer)     if (Buffer) PmReleaseMemory (g_FileEnumPool, (PVOID)Buffer)

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_FileEnumPool;
static INT g_FileEnumRefs;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
FileEnumInitialize (
    VOID
    )

/*++

Routine Description:

    FileEnumInitialize initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    g_FileEnumRefs++;

    if (g_FileEnumRefs == 1) {
        g_FileEnumPool = PmCreateNamedPool (S_FILEENUM);
    }

    return g_FileEnumPool != NULL;
}


VOID
FileEnumTerminate (
    VOID
    )

/*++

Routine Description:

    FileEnumTerminate is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

{
    MYASSERT (g_FileEnumRefs > 0);
    g_FileEnumRefs--;

    if (!g_FileEnumRefs) {
        if (g_FileEnumPool) {
            PmDestroyPool (g_FileEnumPool);
            g_FileEnumPool = NULL;
        }
    }
}


/*++

Routine Description:

    EnumFirstDrive enumerates the first fixed drive root

Arguments:

    DriveEnum - Receives info about the first fixed drive root

Return Value:

    TRUE if a drive root was found; FALSE if not

--*/

BOOL
EnumFirstDriveA (
    OUT     PDRIVE_ENUMA DriveEnum,
    IN      UINT WantedDriveTypes
    )
{
    DWORD len;

    len = GetLogicalDriveStringsA (0, NULL);
    if (len) {
        DriveEnum->AllLogicalDrives = pFileAllocateMemory ((len + 1) * sizeof (CHAR));
        if (DriveEnum->AllLogicalDrives) {
            GetLogicalDriveStringsA (len, DriveEnum->AllLogicalDrives);
            DriveEnum->DriveName = NULL;
            DriveEnum->WantedDriveTypes = WantedDriveTypes;
            return EnumNextDriveA (DriveEnum);
        }
    }
    return FALSE;
}

BOOL
EnumFirstDriveW (
    OUT     PDRIVE_ENUMW DriveEnum,
    IN      UINT WantedDriveTypes
    )
{
    DWORD len;

    len = GetLogicalDriveStringsW (0, NULL);
    if (len) {
        DriveEnum->AllLogicalDrives = pFileAllocateMemory ((len + 1) * sizeof (WCHAR));
        if (DriveEnum->AllLogicalDrives) {
            GetLogicalDriveStringsW (len, DriveEnum->AllLogicalDrives);
            DriveEnum->DriveName = NULL;
            DriveEnum->WantedDriveTypes = WantedDriveTypes;
            return EnumNextDriveW (DriveEnum);
        }
    }
    return FALSE;
}


/*++

Routine Description:

    EnumNextDrive enumerates the next fixed drive

Arguments:

    DriveEnum - Specifies info about the previous fixed drive root; receives updated info

Return Value:

    TRUE if a new drive root was found; FALSE if not

--*/

BOOL
EnumNextDriveA (
    IN OUT  PDRIVE_ENUMA DriveEnum
    )
{
    do {
        if (!DriveEnum->DriveName) {
            DriveEnum->DriveName = DriveEnum->AllLogicalDrives;
        } else {
            // Since DriveEnum->DriveName is not NULL, GetEndOfStringA will
            // not return NULL so...
            DriveEnum->DriveName = GetEndOfStringA (DriveEnum->DriveName) + 1;  //lint !e613
        }
        if (*DriveEnum->DriveName == 0) {
            AbortEnumDriveA (DriveEnum);
            return FALSE;
        }

        DriveEnum->DriveType = GetDriveTypeA (DriveEnum->DriveName);

        switch (DriveEnum->DriveType) {
        case DRIVE_UNKNOWN:
            DriveEnum->DriveType = DRIVEENUM_UNKNOWN;
            break;
        case DRIVE_NO_ROOT_DIR:
            DriveEnum->DriveType = DRIVEENUM_NOROOTDIR;
            break;
        case DRIVE_REMOVABLE:
            DriveEnum->DriveType = DRIVEENUM_REMOVABLE;
            break;
        case DRIVE_FIXED:
            DriveEnum->DriveType = DRIVEENUM_FIXED;
            break;
        case DRIVE_REMOTE:
            DriveEnum->DriveType = DRIVEENUM_REMOTE;
            break;
        case DRIVE_CDROM:
            DriveEnum->DriveType = DRIVEENUM_CDROM;
            break;
        case DRIVE_RAMDISK:
            DriveEnum->DriveType = DRIVEENUM_RAMDISK;
            break;
        default:
            DriveEnum->DriveType = DRIVEENUM_UNKNOWN;
        }

    } while (!(DriveEnum->DriveType & DriveEnum->WantedDriveTypes));

    return TRUE;
}

BOOL
EnumNextDriveW (
    IN OUT  PDRIVE_ENUMW DriveEnum
    )
{
    do {
        if (!DriveEnum->DriveName) {
            DriveEnum->DriveName = DriveEnum->AllLogicalDrives;
        } else {
            DriveEnum->DriveName = GetEndOfStringW (DriveEnum->DriveName) + 1;
        }
        if (*DriveEnum->DriveName == 0) {
            AbortEnumDriveW (DriveEnum);
            return FALSE;
        }

        DriveEnum->DriveType = GetDriveTypeW (DriveEnum->DriveName);

        switch (DriveEnum->DriveType) {
        case DRIVE_UNKNOWN:
            DriveEnum->DriveType = DRIVEENUM_UNKNOWN;
            break;
        case DRIVE_NO_ROOT_DIR:
            DriveEnum->DriveType = DRIVEENUM_NOROOTDIR;
            break;
        case DRIVE_REMOVABLE:
            DriveEnum->DriveType = DRIVEENUM_REMOVABLE;
            break;
        case DRIVE_FIXED:
            DriveEnum->DriveType = DRIVEENUM_FIXED;
            break;
        case DRIVE_REMOTE:
            DriveEnum->DriveType = DRIVEENUM_REMOTE;
            break;
        case DRIVE_CDROM:
            DriveEnum->DriveType = DRIVEENUM_CDROM;
            break;
        case DRIVE_RAMDISK:
            DriveEnum->DriveType = DRIVEENUM_RAMDISK;
            break;
        default:
            DriveEnum->DriveType = DRIVEENUM_UNKNOWN;
        }

    } while (!(DriveEnum->DriveType & DriveEnum->WantedDriveTypes));

    return TRUE;
}


/*++

Routine Description:

    AbortEnumDrive aborts enumeration of fixed drives

Arguments:

    DriveEnum - Specifies info about the previous fixed drive;
                receives a "clean" context

Return Value:

    none

--*/

VOID
AbortEnumDriveA (
    IN OUT  PDRIVE_ENUMA DriveEnum
    )
{
    if (DriveEnum->AllLogicalDrives) {
        pFileFreeMemory (DriveEnum->AllLogicalDrives);
        DriveEnum->AllLogicalDrives = NULL;
    }
}

VOID
AbortEnumDriveW (
    IN OUT  PDRIVE_ENUMW DriveEnum
    )
{
    if (DriveEnum->AllLogicalDrives) {
        pFileFreeMemory (DriveEnum->AllLogicalDrives);
        DriveEnum->AllLogicalDrives = NULL;
    }
}


/*++

Routine Description:

    pGetFileEnumInfo is a private function that validates and translates the enumeration info
    in an internal form that's more accessible to the enum routines

Arguments:

    FileEnumInfo - Receives the enum info
    EncodedPathPattern - Specifies the encoded dir pattern (encoded as defined by the
                         ParsedPattern functions)
    EnumDirs - Specifies TRUE if directories should be returned during the enumeration
               (if they match the pattern); a directory is returned before any of its
               subdirs or files
    ContainersFirst - Specifies TRUE if directories should be returned before any of its
                      files or subdirs; used only if EnumDirs is TRUE
    FilesFirst - Specifies TRUE if a dir's files should be returned before dir's subdirs;
                 this parameter decides the enum order between files and subdirs
                 for each directory
    DepthFirst - Specifies TRUE if the current subdir of any dir should be fully enumerated
                 before going to the next subdir; this parameter decides if the tree
                 traversal is depth-first (TRUE) or width-first (FALSE)
    MaxSubLevel - Specifies the maximum sub-level of a dir that is to be enumerated, relative to
                  the root; if -1, all sub-levels are enumerated
    UseExclusions - Specifies TRUE if exclusion APIs should be used to determine if certain
                    paths/files are excluded from enumeration; this slows down the speed

Return Value:

    TRUE if all params are valid; in this case, FileEnumInfo is filled with the corresponding
         info.
    FALSE otherwise.

--*/

BOOL
pGetFileEnumInfoA (
    OUT     PFILEENUMINFOA FileEnumInfo,
    IN      PCSTR EncodedPathPattern,
    IN      BOOL EnumDirs,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions
    )
{
    FileEnumInfo->PathPattern = ObsCreateParsedPatternA (EncodedPathPattern);
    if (!FileEnumInfo->PathPattern) {
        DEBUGMSGA ((DBG_ERROR, "pGetFileEnumInfoA: bad EncodedPathPattern: %s", EncodedPathPattern));
        return FALSE;
    }

    //
    // check for empty filename; no filename will match in this case
    //
    if (FileEnumInfo->PathPattern->Leaf && *FileEnumInfo->PathPattern->Leaf == 0) {
        DEBUGMSGA ((
            DBG_ERROR,
            "pGetFileEnumInfoA: empty filename pattern specified in EncodedPathPattern: %s",
            EncodedPathPattern
            ));
        ObsDestroyParsedPatternA (FileEnumInfo->PathPattern);
        FileEnumInfo->PathPattern = NULL;
        return FALSE;
    }

    if (FileEnumInfo->PathPattern->ExactRoot) {
        if (!GetNodePatternMinMaxLevelsA (
                FileEnumInfo->PathPattern->ExactRoot,
                NULL,
                &FileEnumInfo->RootLevel,
                NULL
                )) {
            return FALSE;
        }
    } else {
        FileEnumInfo->RootLevel = 1;
    }

    if (!FileEnumInfo->PathPattern->LeafPattern) {
        //
        // no file pattern specified; assume only directory names will be returned
        // overwrite caller's setting
        //
        DEBUGMSGA ((
            DBG_FILEENUM,
            "pGetFileEnumInfoA: no filename pattern specified; forcing EnumDirs to TRUE"
            ));
        EnumDirs = TRUE;
    }

    if (EnumDirs) {
        FileEnumInfo->Flags |= FEIF_RETURN_DIRS;
    }
    if (ContainersFirst) {
        FileEnumInfo->Flags |= FEIF_CONTAINERS_FIRST;
    }
    if (FilesFirst) {
        FileEnumInfo->Flags |= FEIF_FILES_FIRST;
    }
    if (DepthFirst) {
        FileEnumInfo->Flags |= FEIF_DEPTH_FIRST;
    }
    if (UseExclusions) {
        FileEnumInfo->Flags |= FEIF_USE_EXCLUSIONS;
    }

    FileEnumInfo->MaxSubLevel = min (MaxSubLevel, FileEnumInfo->PathPattern->MaxSubLevel);

    return TRUE;
}

BOOL
pGetFileEnumInfoW (
    OUT     PFILEENUMINFOW FileEnumInfo,
    IN      PCWSTR EncodedPathPattern,
    IN      BOOL EnumDirs,
    IN      BOOL ContainersFirst,
    IN      BOOL FilesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions
    )
{
    FileEnumInfo->PathPattern = ObsCreateParsedPatternW (EncodedPathPattern);
    if (!FileEnumInfo->PathPattern) {
        DEBUGMSGW ((DBG_ERROR, "pGetFileEnumInfoW: bad EncodedPathPattern: %s", EncodedPathPattern));
        return FALSE;
    }

    //
    // check for empty filename; no filename will match in this case
    //
    if (FileEnumInfo->PathPattern->Leaf && *FileEnumInfo->PathPattern->Leaf == 0) {
        DEBUGMSGW ((
            DBG_ERROR,
            "pGetFileEnumInfoW: empty filename pattern specified in EncodedPathPattern: %s",
            EncodedPathPattern
            ));
        ObsDestroyParsedPatternW (FileEnumInfo->PathPattern);
        FileEnumInfo->PathPattern = NULL;
        return FALSE;
    }

    if (FileEnumInfo->PathPattern->ExactRoot) {
        if (!GetNodePatternMinMaxLevelsW (
                FileEnumInfo->PathPattern->ExactRoot,
                NULL,
                &FileEnumInfo->RootLevel,
                NULL
                )) {
            return FALSE;
        }
    } else {
        FileEnumInfo->RootLevel = 1;
    }

    if (!FileEnumInfo->PathPattern->LeafPattern) {
        //
        // no file pattern specified; assume only directory names will be returned
        // overwrite caller's setting
        //
        DEBUGMSGW ((
            DBG_FILEENUM,
            "pGetFileEnumInfoW: no filename pattern specified; forcing EnumDirs to TRUE"
            ));
        EnumDirs = TRUE;
    }

    if (EnumDirs) {
        FileEnumInfo->Flags |= FEIF_RETURN_DIRS;
    }
    if (ContainersFirst) {
        FileEnumInfo->Flags |= FEIF_CONTAINERS_FIRST;
    }
    if (FilesFirst) {
        FileEnumInfo->Flags |= FEIF_FILES_FIRST;
    }
    if (DepthFirst) {
        FileEnumInfo->Flags |= FEIF_DEPTH_FIRST;
    }
    if (UseExclusions) {
        FileEnumInfo->Flags |= FEIF_USE_EXCLUSIONS;
    }

    FileEnumInfo->MaxSubLevel = min (MaxSubLevel, FileEnumInfo->PathPattern->MaxSubLevel);

    return TRUE;
}


/*++

Routine Description:

    pGetCurrentDirNode returns the current dir node to be enumerated, based on DepthFirst flag

Arguments:

    FileEnum - Specifies the context
    LastCreated - Specifies TRUE if the last created node is to be retrieved, regardless of
                  DepthFirst flag

Return Value:

    The current node if any or NULL if none remaining.

--*/

PDIRNODEA
pGetCurrentDirNodeA (
    IN      PFILETREE_ENUMA FileEnum,
    IN      BOOL LastCreated
    )
{
    PGROWBUFFER gb = &FileEnum->FileNodes;

    if (!gb->Buf || gb->End - gb->UserIndex < DWSIZEOF (DIRNODEA)) {
        return NULL;
    }

    if (LastCreated || (FileEnum->FileEnumInfo.Flags & FEIF_DEPTH_FIRST)) {
        return (PDIRNODEA)(gb->Buf + gb->End) - 1;
    } else {
        return (PDIRNODEA)(gb->Buf + gb->UserIndex);
    }
}

PDIRNODEW
pGetCurrentDirNodeW (
    IN      PFILETREE_ENUMW FileEnum,
    IN      BOOL LastCreated
    )
{
    PGROWBUFFER gb = &FileEnum->FileNodes;

    if (gb->End - gb->UserIndex < DWSIZEOF (DIRNODEW)) {
        return NULL;
    }

    if (LastCreated || (FileEnum->FileEnumInfo.Flags & FEIF_DEPTH_FIRST)) {
        return (PDIRNODEW)(gb->Buf + gb->End) - 1;
    } else {
        return (PDIRNODEW)(gb->Buf + gb->UserIndex);
    }
}


/*++

Routine Description:

    pDeleteDirNode frees the resources associated with the current dir node and destroys it

Arguments:

    FileEnum - Specifies the context
    LastCreated - Specifies TRUE if the last created node is to be deleted, regardless of
                  DepthFirst flag

Return Value:

    TRUE if there was a node to delete, FALSE if no more nodes

--*/

BOOL
pDeleteDirNodeA (
    IN OUT  PFILETREE_ENUMA FileEnum,
    IN      BOOL LastCreated
    )
{
    PDIRNODEA dirNode;
    PGROWBUFFER gb = &FileEnum->FileNodes;

    dirNode = pGetCurrentDirNodeA (FileEnum, LastCreated);
    if (!dirNode) {
        return FALSE;
    }

    if (dirNode->DirName) {
        FreeTextExA (g_FileEnumPool, dirNode->DirName);
    }

    if (dirNode->FindHandle) {
        FindClose (dirNode->FindHandle);
        dirNode->FindHandle = NULL;
    }

    if (FileEnum->LastNode == dirNode) {
        FileEnum->LastNode = NULL;
    }

    //
    // delete node
    //
    if (LastCreated || (FileEnum->FileEnumInfo.Flags & FEIF_DEPTH_FIRST)) {
        gb->End -= DWSIZEOF (DIRNODEA);
    } else {
        gb->UserIndex += DWSIZEOF (DIRNODEA);
        //
        // shift list
        //
        if (gb->Size - gb->End < DWSIZEOF (DIRNODEA)) {
            MoveMemory (gb->Buf, gb->Buf + gb->UserIndex, gb->End - gb->UserIndex);
            gb->End -= gb->UserIndex;
            gb->UserIndex = 0;
        }

    }

    return TRUE;
}

BOOL
pDeleteDirNodeW (
    IN OUT  PFILETREE_ENUMW FileEnum,
    IN      BOOL LastCreated
    )
{
    PDIRNODEW dirNode;
    PGROWBUFFER gb = &FileEnum->FileNodes;

    dirNode = pGetCurrentDirNodeW (FileEnum, LastCreated);
    if (!dirNode) {
        return FALSE;
    }

    if (dirNode->DirName) {
        FreeTextExW (g_FileEnumPool, dirNode->DirName);
    }

    if (dirNode->FindHandle) {
        FindClose (dirNode->FindHandle);
        dirNode->FindHandle = NULL;
    }

    if (FileEnum->LastNode == dirNode) {
        FileEnum->LastNode = NULL;
    }

    //
    // delete node
    //
    if (LastCreated || (FileEnum->FileEnumInfo.Flags & FEIF_DEPTH_FIRST)) {
        gb->End -= DWSIZEOF (DIRNODEW);
    } else {
        gb->UserIndex += DWSIZEOF (DIRNODEW);
        //
        // shift list
        //
        if (gb->Size - gb->End < DWSIZEOF (DIRNODEW)) {
            MoveMemory (gb->Buf, gb->Buf + gb->UserIndex, gb->End - gb->UserIndex);
            gb->End -= gb->UserIndex;
            gb->UserIndex = 0;
        }

    }

    return TRUE;
}


/*++

Routine Description:

    pCreateDirNode creates a new node given a context, a dir name or a parent node

Arguments:

    FileEnum - Specifies the context
    DirName - Specifies the dir name of the new node; may be NULL only if ParentNode is not NULL
    ParentNode - Specifies a pointer to the parent node of the new node; a pointer to the node
                 is required because the parent node location in memory may change as a result
                 of the growbuffer changing buffer location when it grows;
                 may be NULL only if DirName is not;
    Ignore - Receives a meaningful value only if NULL is returned (no node created);
             if TRUE upon return, the failure of node creation should be ignored

Return Value:

    A pointer to the new node or NULL if no node was created

--*/

PDIRNODEA
pCreateDirNodeA (
    IN OUT  PFILETREE_ENUMA FileEnum,
    IN      PCSTR DirName,              OPTIONAL
    IN      PDIRNODEA* ParentNode,      OPTIONAL
    OUT     PBOOL Ignore                OPTIONAL
    )
{
    PDIRNODEA newNode;
    PSTR newDirName;
    PSEGMENTA FirstSegment;
    LONG offset = 0;

    if (DirName) {
        newDirName = DuplicateTextExA (g_FileEnumPool, DirName, 0, NULL);
        RemoveWackAtEndA (newDirName);
    } else {
        MYASSERT (ParentNode);
        newDirName = JoinPathsInPoolExA ((
                        g_FileEnumPool,
                        (*ParentNode)->DirName,
                        (*ParentNode)->FindData.cFileName,
                        NULL
                        ));

        //
        // check if this starting path may match the pattern before continuing
        //
        if (FileEnum->FileEnumInfo.PathPattern->NodePattern) {
            FirstSegment = FileEnum->FileEnumInfo.PathPattern->NodePattern->Pattern->Segment;
        } else {
            FreeTextExA (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
        if ((FirstSegment->Type == SEGMENTTYPE_EXACTMATCH) &&
            (!StringIMatchByteCountA (
                    FirstSegment->Exact.LowerCasePhrase,
                    newDirName,
                    FirstSegment->Exact.PhraseBytes
                    ))
            ) {
            DEBUGMSGA ((
                DBG_FILEENUM,
                "Skipping tree %s\\* because it cannot match the pattern",
                newDirName
                ));

            FreeTextExA (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
        //
        // look if this dir and the whole subtree are excluded; if so, soft block creation of node
        //
        if (ElIsTreeExcluded2A (ELT_FILE, newDirName, FileEnum->FileEnumInfo.PathPattern->Leaf)) {

            DEBUGMSGA ((
                DBG_FILEENUM,
                "Skipping tree %s\\%s because it's excluded",
                newDirName,
                FileEnum->FileEnumInfo.PathPattern->Leaf
                ));

            FreeTextExA (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (ParentNode) {
        //
        // remember current offset
        //
        offset = (LONG)((PBYTE)*ParentNode - FileEnum->FileNodes.Buf);
    }
    //
    // allocate space for the new node in the growbuffer
    //
    newNode = (PDIRNODEA) GbGrow (&FileEnum->FileNodes, DWSIZEOF (DIRNODEA));
    if (!newNode) {
        FreeTextExA (g_FileEnumPool, newDirName);
        goto fail;
    }

    if (ParentNode) {
        //
        // check if the buffer moved
        //
        if (offset != (LONG)((PBYTE)*ParentNode - FileEnum->FileNodes.Buf)) {
            //
            // adjust the parent position
            //
            *ParentNode = (PDIRNODEA)(FileEnum->FileNodes.Buf + offset);
        }
    }

    //
    // initialize the newly created node
    //
    ZeroMemory (newNode, DWSIZEOF (DIRNODEA));

    newNode->DirName = newDirName;

    if (DirName) {
        newNode->DirAttributes = GetFileAttributesA (DirName);
        //
        // roots are not returned from enumeration because DNF_RETURN_DIRNAME is not set here
        //
        if ((FileEnum->FileEnumInfo.PathPattern->Leaf == NULL) &&
            (FileEnum->FileEnumInfo.PathPattern->ExactRoot) &&
            (!WildCharsPatternA (FileEnum->FileEnumInfo.PathPattern->NodePattern))
            ) {
            newNode->Flags |= DNF_RETURN_DIRNAME;
        }
    } else {
        MYASSERT (ParentNode);
        //ParentNode is not NULL (see the assert above) so...
        newNode->DirAttributes = (*ParentNode)->FindData.dwFileAttributes;  //lint !e613
        newNode->Flags |= DNF_RETURN_DIRNAME;
    }

    newNode->EnumState = DNS_ENUM_INIT;

    if ((FileEnum->FileEnumInfo.PathPattern->Flags & (OBSPF_EXACTNODE | OBSPF_NODEISROOTPLUSSTAR)) ||
        TestParsedPatternA (FileEnum->FileEnumInfo.PathPattern->NodePattern, newDirName)
        ) {
        newNode->Flags |= DNF_DIRNAME_MATCHES;
    }

    if (ParentNode) {
        newNode->SubLevel = (*ParentNode)->SubLevel + 1;
    } else {
        newNode->SubLevel = 0;
    }

    return newNode;

fail:
    if (Ignore) {
        if (FileEnum->FileEnumInfo.CallbackOnError) {
            *Ignore = (*FileEnum->FileEnumInfo.CallbackOnError)(newNode);
        } else {
            *Ignore = FALSE;
        }
    }
    return NULL;
}

PDIRNODEW
pCreateDirNodeW (
    IN OUT  PFILETREE_ENUMW FileEnum,
    IN      PCWSTR DirName,             OPTIONAL
    IN      PDIRNODEW* ParentNode,      OPTIONAL
    OUT     PBOOL Ignore                OPTIONAL
    )
{
    PDIRNODEW newNode;
    PWSTR newDirName;
    PSEGMENTW FirstSegment;
    LONG offset = 0;

    if (DirName) {
        newDirName = DuplicateTextExW (g_FileEnumPool, DirName, 0, NULL);
        RemoveWackAtEndW (newDirName);
    } else {
        MYASSERT (ParentNode);
        newDirName = JoinPathsInPoolExW ((
                        g_FileEnumPool,
                        (*ParentNode)->DirName,
                        (*ParentNode)->FindData.cFileName,
                        NULL
                        ));

        //
        // check if this starting path may match the pattern before continuing
        //
        if (FileEnum->FileEnumInfo.PathPattern->NodePattern) {
            FirstSegment = FileEnum->FileEnumInfo.PathPattern->NodePattern->Pattern->Segment;
        } else {
            FreeTextExW (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
        if ((FirstSegment->Type == SEGMENTTYPE_EXACTMATCH) &&
            (!StringIMatchByteCountW (
                    FirstSegment->Exact.LowerCasePhrase,
                    newDirName,
                    FirstSegment->Exact.PhraseBytes
                    ))
            ) {    //lint !e64
            DEBUGMSGW ((
                DBG_FILEENUM,
                "Skipping tree %s\\* because it cannot match the pattern",
                newDirName
                ));

            FreeTextExW (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (FileEnum->FileEnumInfo.Flags & FEIF_USE_EXCLUSIONS) {
        //
        // look if this dir and the whole subtree are excluded; if so, soft block creation of node
        //
        if (ElIsTreeExcluded2W (ELT_FILE, newDirName, FileEnum->FileEnumInfo.PathPattern->Leaf)) {

            DEBUGMSGW ((
                DBG_FILEENUM,
                "Skipping tree %s\\%s because it's excluded",
                newDirName,
                FileEnum->FileEnumInfo.PathPattern->Leaf
                ));

            FreeTextExW (g_FileEnumPool, newDirName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (ParentNode) {
        //
        // remember current offset
        //
        offset = (LONG)((PBYTE)*ParentNode - FileEnum->FileNodes.Buf);
    }
    //
    // allocate space for the new node in the growbuffer
    //
    newNode = (PDIRNODEW) GbGrow (&FileEnum->FileNodes, DWSIZEOF (DIRNODEW));
    if (!newNode) {
        FreeTextExW (g_FileEnumPool, newDirName);
        goto fail;
    }

    if (ParentNode) {
        //
        // check if the buffer moved
        //
        if (offset != (LONG)((PBYTE)*ParentNode - FileEnum->FileNodes.Buf)) {
            //
            // adjust the parent position
            //
            *ParentNode = (PDIRNODEW)(FileEnum->FileNodes.Buf + offset);
        }
    }

    //
    // initialize the newly created node
    //
    ZeroMemory (newNode, DWSIZEOF (DIRNODEW));

    newNode->DirName = newDirName;

    if (DirName) {
        newNode->DirAttributes = GetFileAttributesW (DirName);
        //
        // roots are not returned from enumeration because DNF_RETURN_DIRNAME is not set here
        //
        if ((FileEnum->FileEnumInfo.PathPattern->Leaf == NULL) &&
            (FileEnum->FileEnumInfo.PathPattern->ExactRoot) &&
            (!WildCharsPatternW (FileEnum->FileEnumInfo.PathPattern->NodePattern))
            ) {
            newNode->Flags |= DNF_RETURN_DIRNAME;
        }
    } else {
        MYASSERT (ParentNode);
        //ParentNode is not NULL (see the assert above) so...
        newNode->DirAttributes = (*ParentNode)->FindData.dwFileAttributes;  //lint !e613
        newNode->Flags |= DNF_RETURN_DIRNAME;
    }

    newNode->EnumState = DNS_ENUM_INIT;

    if ((FileEnum->FileEnumInfo.PathPattern->Flags & (OBSPF_EXACTNODE | OBSPF_NODEISROOTPLUSSTAR)) ||
        TestParsedPatternW (FileEnum->FileEnumInfo.PathPattern->NodePattern, newDirName)
        ) {
        newNode->Flags |= DNF_DIRNAME_MATCHES;
    }

    if (ParentNode) {
        newNode->SubLevel = (*ParentNode)->SubLevel + 1;
    } else {
        newNode->SubLevel = 0;
    }

    return newNode;

fail:
    if (Ignore) {
        if (FileEnum->FileEnumInfo.CallbackOnError) {
            *Ignore = (*FileEnum->FileEnumInfo.CallbackOnError)(newNode);
        } else {
            *Ignore = FALSE;
        }
    }
    return NULL;
}


/*++

Routine Description:

    pEnumNextFile enumerates the next file that matches caller's conditions

Arguments:

    DirNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a new file was found; FALSE if not

--*/

BOOL
pEnumNextFileA (
    IN OUT  PDIRNODEA DirNode
    )
{
    do {
        if (!FindNextFileA (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
        //
        // ignore dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            break;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}

BOOL
pEnumNextFileW (
    IN OUT  PDIRNODEW DirNode
    )
{
    do {
        if (!FindNextFileW (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
        //
        // ignore dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            break;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}


/*++

Routine Description:

    pEnumFirstFile enumerates the first file that matches caller's conditions

Arguments:

    DirNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a first file was found; FALSE if not

--*/

BOOL
pEnumFirstFileA (
    OUT     PDIRNODEA DirNode,
    IN      PFILETREE_ENUMA FileEnum
    )
{
    CHAR pattern[MAX_MBCHAR_PATH];
    PSEGMENTA FirstSegment;
    PCSTR p;

    if (FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_EXACTLEAF) {
        FirstSegment = FileEnum->FileEnumInfo.PathPattern->LeafPattern->Pattern->Segment;
        p = FirstSegment->Exact.LowerCasePhrase;
        MYASSERT (p && *p);
    } else {
        p = "*";
    }
    StringCopyA (pattern, DirNode->DirName);
    StringCopyA (AppendWackA (pattern), p);

    DirNode->FindHandle = FindFirstFileA (pattern, &DirNode->FindData);
    if (DirNode->FindHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    do {
        //
        // ignore dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            break;
        }

        if (!FindNextFileA (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}

BOOL
pEnumFirstFileW (
    OUT     PDIRNODEW DirNode,
    IN      PFILETREE_ENUMW FileEnum
    )
{
    WCHAR pattern[MAX_WCHAR_PATH];
    PSEGMENTW FirstSegment;
    PCWSTR p;

    if (FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_EXACTLEAF) {
        FirstSegment = FileEnum->FileEnumInfo.PathPattern->LeafPattern->Pattern->Segment;
        p = FirstSegment->Exact.LowerCasePhrase;
        MYASSERT (p && *p);
    } else {
        p = L"*";
    }

    StringCopyW (pattern, DirNode->DirName);
    StringCopyW (AppendWackW (pattern), p);

    DirNode->FindHandle = FindFirstFileW (pattern, &DirNode->FindData);
    if (DirNode->FindHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    do {
        //
        // ignore dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            break;
        }

        if (!FindNextFileW (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}


/*++

Routine Description:

    pIsSpecialDirName checks if the specified dir name is a special name (used by the OS)

Arguments:

    DirName - Specifies the name

Return Value:

    TRUE if it's a special dir name

--*/

BOOL
pIsSpecialDirNameA (
    IN      PCSTR DirName
    )
{
    return DirName[0] == '.' && (DirName[1] == 0 || (DirName[1] == '.' && DirName[2] == 0));
}

BOOL
pIsSpecialDirNameW (
    IN      PCWSTR DirName
    )
{
    return DirName[0] == L'.' && (DirName[1] == 0 || (DirName[1] == L'.' && DirName[2] == 0));
}


/*++

Routine Description:

    pEnumNextSubDir enumerates the next subdir that matches caller's conditions

Arguments:

    DirNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a new subdir was found; FALSE if not

--*/

BOOL
pEnumNextSubDirA (
    IN OUT  PDIRNODEA DirNode
    )
{
    do {
        if (!FindNextFileA (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
        //
        // ignore special dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            continue;
        }
        if (!pIsSpecialDirNameA (DirNode->FindData.cFileName)) {
            break;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}

BOOL
pEnumNextSubDirW (
    IN OUT  PDIRNODEW DirNode
    )
{
    do {
        if (!FindNextFileW (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
        //
        // ignore special dirs
        //
        if (!(DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            continue;
        }
        if (!pIsSpecialDirNameW (DirNode->FindData.cFileName)) {
            break;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}


/*++

Routine Description:

    pEnumFirstSubDir enumerates the first subdir that matches caller's conditions

Arguments:

    DirNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a first subdir was found; FALSE if not

--*/

BOOL
pEnumFirstSubDirA (
    OUT     PDIRNODEA DirNode
    )
{
    CHAR pattern[MAX_MBCHAR_PATH];

    StringCopyA (pattern, DirNode->DirName);
    StringCopyA (AppendWackA (pattern), "*");

    //
    // NTRAID#NTBUG9-153302-2000/08/01-jimschm this should be enhanced for NT (it supports FindFirstFileExA)
    //
    DirNode->FindHandle = FindFirstFileA (pattern, &DirNode->FindData);
    if (DirNode->FindHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    do {
        //
        // ignore special dirs
        //
        if ((DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            !pIsSpecialDirNameA (DirNode->FindData.cFileName)
            ) {
            break;
        }

        if (!FindNextFileA (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}

BOOL
pEnumFirstSubDirW (
    OUT     PDIRNODEW DirNode
    )
{
    WCHAR pattern[MAX_WCHAR_PATH];

    StringCopyW (pattern, DirNode->DirName);
    StringCopyW (AppendWackW (pattern), L"*");

    //
    // NTRAID#NTBUG9-153302-2000/08/01-jimschm this should be enhanced for NT (it supports FindFirstFileExW)
    //
    DirNode->FindHandle = FindFirstFileW (pattern, &DirNode->FindData);
    if (DirNode->FindHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    do {
        //
        // ignore special dirs
        //
        if ((DirNode->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            !pIsSpecialDirNameW (DirNode->FindData.cFileName)
            ) {
            break;
        }

        if (!FindNextFileW (DirNode->FindHandle, &DirNode->FindData)) {
            FindClose (DirNode->FindHandle);
            DirNode->FindHandle = NULL;
            return FALSE;
        }
    } while (TRUE); //lint !e506

    return TRUE;
}


/*++

Routine Description:

    pEnumNextFileInTree is a private function that enumerates the next node matching
    the specified criteria; it's implemented as a state machine that travels the dirs/files
    as specified the the caller; it doesn't check if they actually match the patterns

Arguments:

    FileEnum - Specifies the current enum context; receives updated info
    CurrentDirNode - Receives the dir node that is currently processed, if success is returned

Return Value:

    TRUE if a next match was found; FALSE if no more dirs/files match

--*/

BOOL
pEnumNextFileInTreeA (
    IN OUT  PFILETREE_ENUMA FileEnum,
    OUT     PDIRNODEA* CurrentDirNode
    )
{
    PDIRNODEA currentNode;
    PDIRNODEA newNode;
    BOOL ignore;

    while ((currentNode = pGetCurrentDirNodeA (FileEnum, FALSE)) != NULL) {

        *CurrentDirNode = currentNode;

        switch (currentNode->EnumState) {

        case DNS_FILE_FIRST:

            if (FileEnum->ControlFlags & FECF_SKIPFILES) {
                FileEnum->ControlFlags &= ~FECF_SKIPFILES;
                currentNode->EnumState = DNS_FILE_DONE;
                break;
            }

            if (pEnumFirstFileA (currentNode, FileEnum)) {
                currentNode->EnumState = DNS_FILE_NEXT;
                return TRUE;
            }
            currentNode->EnumState = DNS_FILE_DONE;
            break;

        case DNS_FILE_NEXT:

            if (FileEnum->ControlFlags & FECF_SKIPFILES) {
                FileEnum->ControlFlags &= ~FECF_SKIPFILES;
                currentNode->EnumState = DNS_FILE_DONE;
                break;
            }

            if (pEnumNextFileA (currentNode)) {
                return TRUE;
            }
            //
            // no more files for this one, go to the next
            //
            currentNode->EnumState = DNS_FILE_DONE;
            //
            // fall through
            //
        case DNS_FILE_DONE:

            if (!(FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST)) {
                //
                // done with this node
                //
                currentNode->EnumState = DNS_ENUM_DONE;
                break;
            }
            //
            // now enum subdirs
            //
            currentNode->EnumState = DNS_SUBDIR_FIRST;
            //
            // fall through
            //
        case DNS_SUBDIR_FIRST:

            if (FileEnum->ControlFlags & FECF_SKIPSUBDIRS) {
                FileEnum->ControlFlags &= ~FECF_SKIPSUBDIRS;
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            //
            // check current dir's level; if max level reached, don't recurse into subdirs
            //
            if (currentNode->SubLevel >= FileEnum->FileEnumInfo.MaxSubLevel) {
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            if (!pEnumFirstSubDirA (currentNode)) {
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            currentNode->EnumState = DNS_SUBDIR_NEXT;
            newNode = pCreateDirNodeA (FileEnum, NULL, &currentNode, &ignore);
            if (newNode) {
                //
                // look at the new node first
                //
                if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                    if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                        newNode->Flags &= ~DNF_RETURN_DIRNAME;
                        *CurrentDirNode = newNode;
                        return TRUE;
                    }
                }
                break;
            }
            if (!ignore) {
                //
                // abort enum
                //
                DEBUGMSGA ((
                    DBG_ERROR,
                    "Error encountered enumerating file system; aborting enumeration"
                    ));
                FileEnum->RootState = FES_ROOT_DONE;
                return FALSE;
            }
            //
            // fall through
            //
        case DNS_SUBDIR_NEXT:

            if (FileEnum->ControlFlags & FECF_SKIPSUBDIRS) {
                FileEnum->ControlFlags &= ~FECF_SKIPSUBDIRS;
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            if (pEnumNextSubDirA (currentNode)) {
                newNode = pCreateDirNodeA (FileEnum, NULL, &currentNode, &ignore);
                if (newNode) {
                    //
                    // look at the new node first
                    //
                    if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                        if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                            newNode->Flags &= ~DNF_RETURN_DIRNAME;
                            *CurrentDirNode = newNode;
                            return TRUE;
                        }
                    }
                    break;
                }
                //
                // did it fail because of a soft block?
                //
                if (!ignore) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "Error encountered enumerating file system; aborting enumeration"
                        ));
                    FileEnum->RootState = FES_ROOT_DONE;
                    return FALSE;
                }
                //
                // continue with next subdir
                //
                break;
            }
            //
            // this node is done
            //
            currentNode->EnumState = DNS_SUBDIR_DONE;
            //
            // fall through
            //
        case DNS_SUBDIR_DONE:

            if (!(FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST)) {
                //
                // now enum files
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = DNS_FILE_FIRST;
                    break;
                }
            }
            //
            // done with this node
            //
            currentNode->EnumState = DNS_ENUM_DONE;
            //
            // fall through
            //
        case DNS_ENUM_DONE:

            if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                if (!(FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST)) {
                    if (currentNode->Flags & DNF_RETURN_DIRNAME) {
                        currentNode->Flags &= ~DNF_RETURN_DIRNAME;
                        //
                        // before returning, set some data
                        //
                        currentNode->FindData.cFileName[0] = 0;
                        return TRUE;
                    }
                }
            }
            pDeleteDirNodeA (FileEnum, FALSE);
            break;

        case DNS_ENUM_INIT:

            if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                    if (currentNode->Flags & DNF_RETURN_DIRNAME) {
                        currentNode->Flags &= ~DNF_RETURN_DIRNAME;
                        return TRUE;
                    }
                }
            }

            if (FileEnum->ControlFlags & FECF_SKIPDIR) {
                FileEnum->ControlFlags &= ~FECF_SKIPDIR;
                currentNode->EnumState = DNS_ENUM_DONE;
                break;
            }

            if (FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST) {
                //
                // enum files
                //
                if (!(FileEnum->FileEnumInfo.PathPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = DNS_FILE_FIRST;
                    break;
                }
            }
            //
            // enum subdirs
            //
            currentNode->EnumState = DNS_SUBDIR_FIRST;
            break;

        default:
            MYASSERT (FALSE);   //lint !e506
        }
    }

    return FALSE;
}

BOOL
pEnumNextFileInTreeW (
    IN OUT  PFILETREE_ENUMW FileEnum,
    OUT     PDIRNODEW* CurrentDirNode
    )
{
    PDIRNODEW currentNode;
    PDIRNODEW newNode;
    BOOL ignore;

    while ((currentNode = pGetCurrentDirNodeW (FileEnum, FALSE)) != NULL) {

        *CurrentDirNode = currentNode;

        switch (currentNode->EnumState) {

        case DNS_FILE_FIRST:

            if (FileEnum->ControlFlags & FECF_SKIPFILES) {
                FileEnum->ControlFlags &= ~FECF_SKIPFILES;
                currentNode->EnumState = DNS_FILE_DONE;
                break;
            }

            if (pEnumFirstFileW (currentNode, FileEnum)) {
                currentNode->EnumState = DNS_FILE_NEXT;
                return TRUE;
            }
            currentNode->EnumState = DNS_FILE_DONE;
            break;

        case DNS_FILE_NEXT:

            if (FileEnum->ControlFlags & FECF_SKIPFILES) {
                FileEnum->ControlFlags &= ~FECF_SKIPFILES;
                currentNode->EnumState = DNS_FILE_DONE;
                break;
            }

            if (pEnumNextFileW (currentNode)) {
                return TRUE;
            }
            //
            // no more files for this one, go to the next
            //
            currentNode->EnumState = DNS_FILE_DONE;
            //
            // fall through
            //
        case DNS_FILE_DONE:

            if (!(FileEnum->FileEnumInfo.Flags & FEIF_FILES_FIRST)) {
                //
                // done with this node
                //
                currentNode->EnumState = DNS_ENUM_DONE;
                break;
            }
            //
            // now enum subdirs
            //
            currentNode->EnumState = DNS_SUBDIR_FIRST;
            //
            // fall through
            //
        case DNS_SUBDIR_FIRST:

            if (FileEnum->ControlFlags & FECF_SKIPSUBDIRS) {
                FileEnum->ControlFlags &= ~FECF_SKIPSUBDIRS;
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            //
            // check current dir's level; if max level reached, don't recurse into subdirs
            //
            if (currentNode->SubLevel >= FileEnum->FileEnumInfo.MaxSubLevel) {
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            if (!pEnumFirstSubDirW (currentNode)) {
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            currentNode->EnumState = DNS_SUBDIR_NEXT;
            newNode = pCreateDirNodeW (FileEnum, NULL, &currentNode, &ignore);
            if (newNode) {
                //
                // look at the new node first
                //
                if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                    if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                        newNode->Flags &= ~DNF_RETURN_DIRNAME;
                        *CurrentDirNode = newNode;
                        return TRUE;
                    }
                }
                break;
            }
            //
            // did it fail because of a soft block?
            //
            if (!ignore) {
                DEBUGMSGA ((
                    DBG_ERROR,
                    "Error encountered enumerating file system; aborting enumeration"
                    ));
                FileEnum->RootState = FES_ROOT_DONE;
                return FALSE;
            }
            //
            // fall through
            //
        case DNS_SUBDIR_NEXT:

            if (FileEnum->ControlFlags & FECF_SKIPSUBDIRS) {
                FileEnum->ControlFlags &= ~FECF_SKIPSUBDIRS;
                currentNode->EnumState = DNS_SUBDIR_DONE;
                break;
            }

            if (pEnumNextSubDirW (currentNode)) {
                newNode = pCreateDirNodeW (FileEnum, NULL, &currentNode, &ignore);
                if (newNode) {
                    //
                    // look at the new node first
                    //
                    if (FileEnum->FileEnumInfo.Flags & FEIF_RETURN_DIRS) {
                        if (FileEnum->FileEnumInfo.Flags & FEIF_CONTAINERS_FIRST) {
                            newNode->Flags &= ~DNF_RETURN_DIRNAME;
                            *CurrentDirNode = newNode;
                            return TRUE;
                        }
                    }
                    break;
                }
                //
                // did it fail because of a soft block?
                //
                if (!ignore) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "Error encountered enumerating file system; aborting enumeration"
                        ));
                    FileEnum->RootState = FES_ROOT_DONE;
                    return FALSE;
                }
                