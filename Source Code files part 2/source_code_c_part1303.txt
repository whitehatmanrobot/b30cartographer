     ReferencedDomains,
                        TrustInformation.Sid,
                        (PLONG) &OutputSids[NameNumber].DomainIndex
                        )) {

                    UnmappedNamesRemaining--;

                    if (PrefixSid != NULL) {

                        MIDL_user_free( PrefixSid );
                        PrefixSid = NULL;
                    }

                    continue;
                }

                //
                // This Domain or Prefix Sid is not currently on the
                // Referenced Domain List.  Complete a Trust Information
                // entry and add it to the List.  Copy in the Domain Name
                // (Domain Sids) or NULL string.  Note that we use
                // RtlCopyMemory to copy a UNICODE_STRING structure onto
                // a LSAPR_UNICODE_STRING structure.
                //

                RtlCopyMemory(
                    &TrustInformation.Name,
                    &WellKnownSids[WellKnownSidIndex].DomainName,
                    sizeof(UNICODE_STRING)
                    );

                //
                // Make an entry in the list of Referenced Domains.  Note
                // that in the case of well-known Sids, the Prefix Sid
                // may or may not be the Sid of a Domain.  For those well
                // known Sids whose Prefix Sid is not a domain Sid, the
                // Name field in the Trust Information has been set to the
                // NULL string.
                //

                Status = LsapDbLookupAddListReferencedDomains(
                             ReferencedDomains,
                             &TrustInformation,
                             (PLONG) &OutputSids[NameNumber].DomainIndex
                             );

                if (!NT_SUCCESS(Status)) {

                    break;
                }

                //
                // If we allocated memory for a Prefix Sid, free it.
                //

                if (PrefixSid != NULL) {

                    MIDL_user_free( PrefixSid );
                    PrefixSid = NULL;
                }

                UnmappedNamesRemaining--;
            }
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupIsolatedWellKnownNamesError;
    }

    //
    // Set the output parameters in the success case..
    //

    TranslatedSids->Sids = OutputSids;
    TranslatedSids->Entries = Count;
    *MappedCount = Count - UnmappedNamesRemaining;
    *CompletelyUnmappedCount = UnmappedNamesRemaining;

LookupIsolatedWellKnownNamesFinish:

    //
    // If we still have memory allocated for the a Prefix Sid, free it.
    //

    if (PrefixSid != NULL) {

        MIDL_user_free( PrefixSid );
        PrefixSid = NULL;
    }

    return(Status);

LookupIsolatedWellKnownNamesError:

    goto LookupIsolatedWellKnownNamesFinish;
}


BOOLEAN
LsapDbLookupIndexWellKnownName(
    IN OPTIONAL PLSAPR_UNICODE_STRING Name,
    OUT PLSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex,
    IN DWORD dwMatchType
    )

/*++

Routine Description:

    This function looks up a Name to determine if it is well-known.  If so,
    an index into the table of well-known Sids is returned.

Arguments:

    Name - Pointer to Name to be looked up.  If a NULL pointer or
        pointer to a zero length string is specified, FALSE will
        always be returned.

    WellKnownSidIndex - Pointer to variable that will receive the
        index of the Name if well known.

    dwMatchType - Constant indicating that the name's prefix matched
        a well-known hardcoded prefix or both the hardcoded and
        localized prefixes.

Return Value:

    BOOLEAN - TRUE if the Name is well-known, else FALSE

--*/

{
    LSAP_WELL_KNOWN_SID_INDEX Index;
    PLSAPR_UNICODE_STRING MatchName = NULL;
    BOOLEAN BooleanStatus = FALSE;

    if ((!ARGUMENT_PRESENT(Name)) || Name->Length == 0 ) {

        return(FALSE);
    }

    if (dwMatchType == LOOKUP_MATCH_HARDCODED
         ||
        dwMatchType == LOOKUP_MATCH_BOTH)
    {
        //
        // This means the domain name was "NT AUTHORITY" -- check
        // the suffix for LocalService, NetworkService, or System
        //

        UINT i;

        for (i = 0;
             i < NELEMENTS(LsapHardcodedNameLookupList);
             i++)
        {
            if (RtlEqualUnicodeString((PUNICODE_STRING) Name,
                                      &LsapHardcodedNameLookupList[i].KnownName,
                                      TRUE))
            {
                *WellKnownSidIndex = LsapHardcodedNameLookupList[i].LookupIndex;
                return TRUE;
            }
        }

        if (dwMatchType == LOOKUP_MATCH_HARDCODED)
        {
            //
            // No hardcoded match.  Don't check the localized names since the
            // prefix name itself didn't match the localized prefix.
            //
            *WellKnownSidIndex = LsapDummyLastSidIndex;
            return FALSE;
        }
    }

    //
    // Scan the table of well-known Sids looking for a match on Name.
    //

    for(Index = LsapNullSidIndex; Index<LsapDummyLastSidIndex; Index++) {

        //
        // Allow NULL entries in the table of well-known Sids for now.
        //

        if (WellKnownSids[Index].Sid == NULL) {

            continue;
        }

        //
        // If the current entry in the table of Well Known Sids
        // is for a Domain Sid, match the name with the DomainName
        // field.  Otherwise, match it with the Name field.
        //

        if (WellKnownSids[Index].Use == SidTypeDomain) {

            MatchName = (PLSAPR_UNICODE_STRING) &WellKnownSids[Index].DomainName;

            if (RtlEqualDomainName(
                   (PUNICODE_STRING) Name,
                   (PUNICODE_STRING) MatchName
                   )) {

                //
                // If a match is found, return the index to the caller.
                //

                BooleanStatus = TRUE;
                break;
            }

        } else {

            MatchName = (PLSAPR_UNICODE_STRING) &WellKnownSids[Index].Name;

            if (RtlEqualUnicodeString(
                   (PUNICODE_STRING) Name,
                   (PUNICODE_STRING) MatchName,
                   TRUE
                   )) {

                //
                // If a match is found, return the index to the caller.
                //

                BooleanStatus = TRUE;
                break;
            }
        }
    }

    *WellKnownSidIndex = Index;

    return(BooleanStatus);
}

BOOLEAN
LsaILookupWellKnownName(
    IN PUNICODE_STRING WellKnownName
    )
/*++

RoutineDescription:

    This routine returns TRUE if the supplied name is a well known name.

Arguments:

    WellKnownName - The name to check against the list of well known names

Return Values:

    TRUE - The supplied name is a well known name
    FALSE - The supplied name is not a well known name

--*/
{
    LSAP_WELL_KNOWN_SID_INDEX Index;

    return(LsapDbLookupIndexWellKnownName(
                (PLSAPR_UNICODE_STRING) WellKnownName,
                &Index,
                LOOKUP_MATCH_NONE
                ));

}


PUNICODE_STRING
LsapDbWellKnownSidName(
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    )

/*++

Routine Description:

    This function returns the Unicode Name of a Well Known Sid.

Arguments:

    WellKnownSidIndex - Index into the Well Known Sid information table.
    It is the caller's responsibility to ensure that the given index
    is valid.

Return Value:

    PUNICODE_STRING Pointer to the name of the Well Known Sid.

--*/

{
    //
    // If the Sid is a Domain Sid, its name is contained within the
    // DomainName field in the Well Known Sids table.  If the Sid is not a
    // Domain Sid, its name is contained within the Name field of the entry.
    //

    if (WellKnownSids[WellKnownSidIndex].Use == SidTypeDomain) {

        return(&WellKnownSids[WellKnownSidIndex].DomainName);

    } else {

        return(&WellKnownSids[WellKnownSidIndex].Name);
    }
}


NTSTATUS
LsapDbLookupIsolatedDomainNames(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX PrimaryDomainTrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function attempts to identify isolated names as the names of Domains.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.

    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is the name of one of the Primary Domain's Trusted Domains,
    then that domain's Sid will be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a structure in which the list of domains
        used in the translation is maintained.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for each
        translated name, this structure will only contain one component for
        each domain utilized in the translation.

    TranslatedSids - Pointer to a structure in which the translations to Sids
        corresponding to the Names specified on Names is maintained.  The
        nth entry in this array provides a translation (where known) for the
        nth element in the Names parameter.

    MappedCount - Pointer to location in which a count of the Names that
        have been completely translated is maintained.

    CompletelyUnmappedCount - Pointer to a location in which a count of the
        Names that have not been translated (either partially, by identification
        of a Domain Prefix, or completely) is maintained.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS, IgnoreStatus;
    LSAPR_TRUST_INFORMATION LocalTrustInfo;
    ULONG NameIndex;

    //
    // Search for Isolated Names that match the Built-In Domain Name,
    // Account Domain Name or one of the Primary Domain's Trusted Domain
    // Names.
    //


    for (NameIndex = 0;
         (NameIndex < Count);
         NameIndex++) {

        //
        // Skip this name if already mapped or partially mapped.
        //

        if (!LsapDbCompletelyUnmappedSid(&TranslatedSids->Sids[NameIndex])) {

            continue;
        }

        //
        // Skip this name if composite.
        //

        if (PrefixNames[ NameIndex ].Length != (USHORT) 0) {

            continue;
        }

        //
        // We've found an Isolated Name.  First check if it is the
        // name of the Built In Domain.
        //

        Status = LsapDbLookupIsolatedDomainName(
                     NameIndex,
                     &SuffixNames[NameIndex],
                     BuiltInDomainTrustInformation,
                     ReferencedDomains,
                     TranslatedSids,
                     MappedCount,
                     CompletelyUnmappedCount
                     );

        if (NT_SUCCESS(Status)) {

            continue;
        }

        if (Status != STATUS_NONE_MAPPED) {

            break;
        }

        Status = STATUS_SUCCESS;

        //
        // Isolated Name is not the name of the Built-in Domain.  See if
        // it is the name of the Accounts Domain.
        //
        Status = LsapDbLookupIsolatedDomainNameEx(
                     NameIndex,
                     &SuffixNames[NameIndex],
                     AccountDomainTrustInformation,
                     ReferencedDomains,
                     TranslatedSids,
                     MappedCount,
                     CompletelyUnmappedCount
                     );

        if (NT_SUCCESS(Status)) {

            continue;
        }

        Status = STATUS_SUCCESS;

        //
        // If we are configured as a member of a Work Group, there is
        // no Primary or Trusted Domain List to search, so skip to next
        // name.  We are configured as a member of a Work Group if and
        // only if out PolicyPrimaryDomainInformation contains a NULL Sid.
        //

        if (PrimaryDomainTrustInformation->Sid == NULL) {

            continue;
        }

        //
        // Isolated Name is not the name of either the Built-in or Accounts
        // Domain.  Try the Primary Domain if this is different from the
        // Accounts Domain.
        //

        if (!RtlEqualDomainName(
                 (PUNICODE_STRING) &PrimaryDomainTrustInformation->FlatName,
                 (PUNICODE_STRING) &AccountDomainTrustInformation->FlatName
                 )) {


            Status = LsapDbLookupIsolatedDomainNameEx(
                         NameIndex,
                         &SuffixNames[NameIndex],
                         PrimaryDomainTrustInformation,
                         ReferencedDomains,
                         TranslatedSids,
                         MappedCount,
                         CompletelyUnmappedCount
                         );

            if (NT_SUCCESS(Status)) {

                continue;
            }

            if (Status != STATUS_NONE_MAPPED) {

                break;
            }

            Status = STATUS_SUCCESS;
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupIsolatedDomainNamesError;
    }

LookupIsolatedDomainNamesFinish:



    return(Status);

LookupIsolatedDomainNamesError:

    goto LookupIsolatedDomainNamesFinish;
}


NTSTATUS
LsapDbLookupNamesInLocalDomains(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    IN ULONG Options
    )

/*++

Routine Description:

    This function looks up Names in the local SAM domains and attempts to
    translate them to Sids.  Currently, there are two local SAM domains,
    the Built-in domain (which has a well-known Sid and name) and the
    Account Domain (which has a configurable Sid and name).

Arguments:

    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Names - Pointer to array of Unicode Names to be translated.
        Zero or all of the Names may already have been translated
        elsewhere.  If any of the Names have been translated, the
        TranslatedSids parameter will point to a location containing a non-NULL
        array of Sid translation structures corresponding to the
        Names.  If the nth Name has been translated, the nth Sid
        translation structure will contain either a non-NULL RelativeId
        or a non-negative offset into the Referenced Domain List.  If
        the nth Name has not yet been translated, the nth Sid
        translation structure will contain SidTypeUnknown in its
        Use field.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a location containing either NULL
        or a pointer to a Referenced Domain List structure.  If an
        existing Referenced Domain List structure is supplied, it
        will be appended/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Sids.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.

    Options - Specifies optional actions.

        LSAP_DB_SEARCH_BUILT_IN_DOMAIN - Search the Built In Domain

        LSAP_DB_SEARCH_ACCOUNT_DOMAIN - Search the Account Domain

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

        STATUS_INTERNAL_DB_ERROR - A corruption has been detected in
            the LSA Database.

        STATUS_INVALID_PARAMETER - Invalid parameter

            - No handle to the Policy object was provided on a request
              to search the Account Domain.
--*/

{
    NTSTATUS
        Status = STATUS_SUCCESS,
        SecondaryStatus = STATUS_SUCCESS;

    ULONG
        UpdatedMappedCount = *MappedCount;

    LSAPR_HANDLE
        TrustedPolicyHandle = NULL;

    PLSAPR_POLICY_ACCOUNT_DOM_INFO
        PolicyAccountDomainInfo = NULL;

    LSAPR_TRUST_INFORMATION LookupInfo;


    //
    // If there are no completely unmapped Names remaining, return.
    //

    if (*CompletelyUnmappedCount == (ULONG) 0) {

        goto LookupNamesInLocalDomainsFinish;
    }


    //
    // If requested, lookup Names in the BUILT-IN Domain.
    //

    if (Options & LSAP_DB_SEARCH_BUILT_IN_DOMAIN) {

        Status = LsapDbLookupNamesInLocalDomain(
                     LSAP_DB_SEARCH_BUILT_IN_DOMAIN,
                     Count,
                     PrefixNames,
                     SuffixNames,
                     BuiltInDomainTrustInformation,
                     ReferencedDomains,
                     TranslatedSids,
                     &UpdatedMappedCount,
                     CompletelyUnmappedCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupNamesInLocalDomainsError;
        }

        //
        // If all Names are now mapped or partially mapped, finish.
        //

        if (*CompletelyUnmappedCount == (ULONG) 0) {

            goto LookupNamesInLocalDomainsFinish;
        }
    }

    //
    // If requested, search the Account Domain.
    //

    if (Options & LSAP_DB_SEARCH_ACCOUNT_DOMAIN) {

        Status = LsapDbLookupNamesInLocalDomainEx(
                     LSAP_DB_SEARCH_ACCOUNT_DOMAIN,
                     Count,
                     PrefixNames,
                     SuffixNames,
                     AccountDomainTrustInformation,
                     ReferencedDomains,
                     TranslatedSids,
                     &UpdatedMappedCount,
                     CompletelyUnmappedCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupNamesInLocalDomainsError;
        }

    }

LookupNamesInLocalDomainsFinish:


    //
    // Return the updated total count of Names mapped.
    //

    *MappedCount = UpdatedMappedCount;
    return(Status);

LookupNamesInLocalDomainsError:

    if (NT_SUCCESS(Status)) {

        Status = SecondaryStatus;
    }

    goto LookupNamesInLocalDomainsFinish;
}



NTSTATUS
LsapDbLookupNamesInLocalDomain(
    IN ULONG LocalDomain,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )
{

    LSAPR_TRUST_INFORMATION_EX ex;

    LsapConvertTrustToEx( &ex, TrustInformation );

    return LsapDbLookupNamesInLocalDomainEx( LocalDomain,
                                             Count,
                                             PrefixNames,
                                             SuffixNames,
                                             &ex,
                                             ReferencedDomains,
                                             TranslatedSids,
                                             MappedCount,
                                             CompletelyUnmappedCount );

}


NTSTATUS
LsapDbLookupNamesInLocalDomainEx(
    IN ULONG LocalDomain,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformationEx,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function looks up Names in a SAM domain on the local system and
    attempts to translate them to Sids.

Arguments:

    LocalDomain - Indicates which local domain to look in.  Valid values
        are:
                LSAP_DB_SEARCH_BUILT_IN_DOMAIN
                LSAP_DB_SEARCH_ACCOUNT_DOMAIN

    Count - Number of Names in the PrefixNames and SuffixNames arrays,
        Note that some of these may already have been mapped elsewhere, as
        specified by the MappedCount parameter.

    PrefixNames - Pointer to array of Prefix Names.  These are Domain
        Names or NULL Unicode Strings.  Only those Names whose Prefix
        Names are NULL or the same as the Domain Name specified in the
        TrustInformation parameter are eligible for the search.

    SuffixNames - Pointer to array of Terminal Names to be translated.
        Terminal Names are the last component of the name.
        Zero or all of the Names may already have been translated
        elsewhere.  If any of the Names have been translated, the
        Sids parameter will point to a location containing a non-NULL
        array of Sid translation structures corresponding to the
        Sids.  If the nth Sid has been translated, the nth Sid
        translation structure will contain either a non-NULL Sid
        or a non-negative offset into the Referenced Domain List.  If
        the nth Sid has not yet been translated, the nth name
        translation structure will contain a zero-length name string
        and a negative value for the Referenced Domain List index.

    TrustInformation - Pointer to Trust Information specifying a Domain Sid
        and Name.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to location containing NULL or a pointer to a
        array of Sid translation structures.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Sids.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS
        Status = STATUS_SUCCESS,
        SecondaryStatus = STATUS_SUCCESS,
        IgnoreStatus;

    ULONG
        UnmappedNameCount = 0,
        OutputSidsLength,
        NameLookupCount,
        NameLookupIndex,
        SidIndex;

    LONG
        DomainIndex = LSA_UNKNOWN_INDEX;

    PULONG
        SidIndices = NULL;

    PLSA_TRANSLATED_SID_EX2
        OutputSids = NULL;

    SAMPR_HANDLE
        LocalSamDomainHandle = NULL,
        LocalSamUserHandle = NULL;

    PLSAPR_UNICODE_STRING
        SamLookupSuffixNames = NULL;

    PLSAPR_SID
        DomainSid = TrustInformationEx->Sid;

    SAMPR_ULONG_ARRAY
        SamReturnedIds,
        SamReturnedUses;

    PLSAPR_TRUST_INFORMATION
        FreeTrustInformation = NULL;

    PUSER_CONTROL_INFORMATION
        UserControlInfo;

    LSAPR_TRUST_INFORMATION Dummy;
    PLSAPR_TRUST_INFORMATION TrustInformation = &Dummy;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbLookupNamesInLocalDomain\n" ));

    LsapConvertExTrustToOriginal( TrustInformation, TrustInformationEx );

    SamReturnedIds.Count = 0;
    SamReturnedIds.Element = NULL;
    SamReturnedUses.Count = 0;
    SamReturnedUses.Element = NULL;


    //
    // Make sure the SAM handles have been established.
    //

    Status = LsapOpenSam();
    ASSERT( NT_SUCCESS( Status ) );

    if ( !NT_SUCCESS( Status ) ) {

        LsapDsDebugOut(( DEB_FTRACE, "LsapDbLookupNamesInLocalDomain: 0x%lx\n", Status ));
        return( Status );
    }


    //
    // It is an internal error if the TranslatedSids or ReferencedDomains
    // parameters have not been specified.  Further, The TranslatedSids->Sids
    // pointer must be non-NULL.
    //

    ASSERT(ARGUMENT_PRESENT(TranslatedSids));
    ASSERT(TranslatedSids->Sids != NULL);
    ASSERT(ARGUMENT_PRESENT(ReferencedDomains));

    //
    // Validate the Count and MappedCount parameters.
    //


    if (*MappedCount + *CompletelyUnmappedCount > Count) {

        Status = STATUS_INVALID_PARAMETER;
        goto LookupNamesInLocalDomainError;
    }


    if (*CompletelyUnmappedCount == (ULONG) 0) {

        goto LookupNamesInLocalDomainFinish;
    }

    //
    // Not all of the Names have yet been mapped.  We'll try to map the
    // remaining names by searching the designated SAM domain on this
    // machine.
    //

    UnmappedNameCount = Count - *MappedCount;
    OutputSids = (PLSA_TRANSLATED_SID_EX2) TranslatedSids->Sids;
    OutputSidsLength = Count * sizeof (LSA_TRANSLATED_SID_EX2);

    //
    // Allocate memory for array of names to be presented to SAM.  Note
    // that, for simplicity, we allocate an array for the maximal case
    // in which all of the reamining unmapped names are eligible
    // for the search in this domain.  This avoids having to scan the
    // names array twice, once to compute the number of eligible names.
    //

    SamLookupSuffixNames = LsapAllocateLsaHeap( UnmappedNameCount * sizeof(UNICODE_STRING));


    if (SamLookupSuffixNames == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto LookupNamesInLocalDomainError;
    }

    //
    // Allocate an array to record indices of eligible names.  This is
    // used upon return from SAM to locate the entries in the
    // OutputSids array that are to be updated.  For simplicity, we
    // allocate the array with sufficient entries for all of the remaining
    // unmapped names.
    //

    SidIndices = LsapAllocateLsaHeap( UnmappedNameCount * sizeof(ULONG));

    if (SidIndices == NULL) {

        goto LookupNamesInLocalDomainError;
    }


    //
    // Scan the output array of Sid translations to locate entries for names
    // that have not yet been mapped.  For each unmapped name, check
    // eligibility of the name for the search of this domain.
    //
    // - All isolated names are eligible for the search
    // - All composite names having this domain name as prefix are
    //   eligible.
    //
    // Copy in each eligible suffix or isolated name to the SAM buffer.
    //

    for (NameLookupIndex = 0, SidIndex = 0; SidIndex < Count; SidIndex++) {

        if (OutputSids[SidIndex].Use == SidTypeUnknown) {

            //
            // Found a name that has not yet been mapped.  Check for a name
            // Prefix.  If none has been specified, the whole name may either
            // be NULL, the name of the domain itself or an isolated name.
            //

            if (PrefixNames[SidIndex].Length == 0) {

                //
                // Name is isolated.  If whole name is NULL, skip.
                //

                if (SuffixNames[SidIndex].Length == 0) {

                    continue;
                }

                //
                // If name is the name of the domain itself, use the
                // Trust Information to translate it, and fill in the
                // appropriate Translated Sids entry.  The name will
                // then be excluded from further searches.
                //

                if (RtlEqualDomainName(
                        (PUNICODE_STRING) &(TrustInformation->Name),
                        (PUNICODE_STRING) &SuffixNames[SidIndex])
                 ||  RtlEqualDomainName(
                        (PUNICODE_STRING) &(TrustInformationEx->DomainName),
                        (PUNICODE_STRING) &SuffixNames[SidIndex])
                     ) {

                    Status = LsapDbLookupTranslateNameDomain(
                                 TrustInformation,
                                 &OutputSids[SidIndex],
                                 ReferencedDomains,
                                 &DomainIndex
                                 );

                    if (!NT_SUCCESS(Status)) {

                        break;
                    }

                    continue;
                }

                //
                // Name is an isolated name not equal to the domain name and
                // so is eligible for the search.  Reference it from the SAM buffer,
                // remember its index and increment the buffer index.  The
                // SAM buffer is an IN parameter to a further lookup call.
                //

                SamLookupSuffixNames[NameLookupIndex] = SuffixNames[SidIndex];


                //
                // We should never have an index that equals or exceeds the
                // UnmappedNameCount.
                //

                ASSERT(NameLookupIndex < UnmappedNameCount);

                SidIndices[NameLookupIndex] = SidIndex;
                NameLookupIndex++;
                continue;
            }

            //
            // Name has a non-NULL Prefix Name.  Cpmpare the name with the
            // name of the Domain being searched.

            if (RtlEqualDomainName(
                    (PUNICODE_STRING) &TrustInformation->Name,
                    (PUNICODE_STRING) &PrefixNames[SidIndex])
                ||  RtlEqualDomainName(
                       (PUNICODE_STRING) &(TrustInformationEx->DomainName),
                       (PUNICODE_STRING) &PrefixNames[SidIndex])
                ) {

                //
                // Prefix name matches the name of the Domain.  If the
                // Suffix Name is NULL, the name of the domain itself
                // has been specified (in the form <DomainName> "\").
                //

                if (SuffixNames[SidIndex].Length == 0) {

                    Status = LsapDbLookupTranslateNameDomain(
                                 TrustInformation,
                                 &OutputSids[SidIndex],
                                 ReferencedDomains,
                                 &DomainIndex
                                 );

                    if (!NT_SUCCESS(Status)) {

                        break;
                    }

                    continue;
                }

                //
                // Name is composite and the Prefix name matches the name of
                // this domain.  We will at least be able to partially translate
                // name, so add this domain to the Referenced Domain List if not
                // already there.  Then reference the Suffix Name from the SAM buffer,
                // remember its index and increment the buffer index. The
                // SAM buffer is an IN parameter to a further lookup call.
                //

                if (DomainIndex == LSA_UNKNOWN_INDEX) {

                    Status = LsapDbLookupAddListReferencedDomains(
                                 ReferencedDomains,
                                 TrustInformation,
                                 &DomainIndex
                                 );

                    if (!NT_SUCCESS(Status)) {

                        break;
                    }
                }

                SamLookupSuffixNames[NameLookupIndex] = SuffixNames[SidIndex];

                SidIndices[NameLookupIndex] = SidIndex;
                OutputSids[SidIndex].DomainIndex = DomainIndex;
                NameLookupIndex++;
            }
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInLocalDomainError;
    }

    //
    // If none of the remaining Names are eligible for searching in this
    // domain, finish up.
    //

    NameLookupCount = NameLookupIndex;

    if (NameLookupCount == 0) {

        goto LookupNamesInLocalDomainFinish;
    }

    //
    //
    // Lookup the Sids in the specified SAM Domain.
    //

    if (LocalDomain == LSAP_DB_SEARCH_BUILT_IN_DOMAIN ) {
        LocalSamDomainHandle = LsapBuiltinDomainHandle;
    } else {
        ASSERT(LocalDomain == LSAP_DB_SEARCH_ACCOUNT_DOMAIN);
        LocalSamDomainHandle = LsapAccountDomainHandle;
    }

    //
    // Call SAM to lookup the Names in the Domain.
    //

    Status = SamrLookupNamesInDomain(
                 LocalSamDomainHandle,
                 NameLookupCount,
                 (PRPC_UNICODE_STRING) SamLookupSuffixNames,
                 &SamReturnedIds,
                 &SamReturnedUses
                 );

    if (!NT_SUCCESS(Status)) {

        if ( Status == STATUS_INVALID_SERVER_STATE ) {

            Status = SamrLookupNamesInDomain(
                         LocalSamDomainHandle,
                         NameLookupCount,
                         (PRPC_UNICODE_STRING) SamLookupSuffixNames,
                         &SamReturnedIds,
                         &SamReturnedUses
                         );
        }
        //
        // The only error allowed is STATUS_NONE_MAPPED.  Filter this out.
        //

        if (Status != STATUS_NONE_MAPPED) {

            goto LookupNamesInLocalDomainError;
        }

        Status = STATUS_SUCCESS;
        goto LookupNamesInLocalDomainFinish;
    }

#ifdef notdef
    //
    // Filter through the returned Ids to eliminate user accounts that are
    // not marked NORMAL.
    //

    for (NameLookupIndex = 0;
         NameLookupIndex < SamReturnedIds.Count;
         NameLookupIndex++) {

        //
        // If this account is a User Account, check its User Control
        // Information.  If the account control information indicates
        // that the account is not a Normal User Account, for example
        // it is a machine account, do not return information about
        // the account.  Mark it as unknown.
        //

        if (SamReturnedUses.Element[ NameLookupIndex ] !=  SidTypeUser) {

            continue;
        }

        Status = SamrOpenUser(
                     LocalSamDomainHandle,
                     USER_READ_ACCOUNT,
                     SamReturnedIds.Element[ NameLookupIndex ],
                     &LocalSamUserHandle
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        UserControlInfo = NULL;

        Status = SamrQueryInformationUser(
                     LocalSamUserHandle,
                     UserControlInformation,
                     (PSAMPR_USER_INFO_BUFFER *) &UserControlInfo
                     );
        IgnoreStatus = SamrCloseHandle(&LocalSamUserHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));
        LocalSamUserHandle = NULL;


        if (!NT_SUCCESS(Status)) {
            MIDL_user_free( UserControlInfo );
            break;
        }

        if (!(UserControlInfo->UserAccountControl & USER_NORMAL_ACCOUNT) &&
            !(UserControlInfo->UserAccountControl & USER_TEMP_DUPLICATE_ACCOUNT)) {
            SamReturnedUses.Element[NameLookupIndex] = SidTypeUnknown;
        }

        MIDL_user_free( UserControlInfo );
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInLocalDomainError;
    }
#endif

    //
    // SAM found at least one eligible name in the specified domain.
    // Add the domain to the Referenced Domain List.
    //

    Status = LsapDbLookupTranslateNameDomain(
                 TrustInformation,
                 NULL,
                 ReferencedDomains,
                 &DomainIndex
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInLocalDomainError;
    }

    //
    // Now copy the information returned from SAM into the output
    // Translated Sids array.
    //

    for (NameLookupIndex = 0;
         NameLookupIndex < SamReturnedIds.Count;
         NameLookupIndex++) {

        SidIndex =  SidIndices[NameLookupIndex];

        //
        // If we have newly translated a Name, increment the mapped
        // count and copy information returned by SAM.
        //

        if ((OutputSids[SidIndex].Use == SidTypeUnknown) &&
            SamReturnedUses.Element[NameLookupIndex] != (ULONG) SidTypeUnknown) {

            PSID TempSid;

            (*MappedCount)++;
            OutputSids[SidIndex].Use = (SID_NAME_USE) SamReturnedUses.Element[NameLookupIndex];
            Status = SamrRidToSid(LocalSamDomainHandle,
                                  SamReturnedIds.Element[NameLookupIndex],
                                 (PRPC_SID*) &TempSid);
            if (NT_SUCCESS(Status)) {

                Status = LsapRpcCopySid( NULL,
                                         &OutputSids[SidIndex].Sid,
                                         TempSid);

                SamIFreeVoid(TempSid);
            }

            if ( !NT_SUCCESS(Status) ) {
                goto LookupNamesInLocalDomainError;
            }

            OutputSids[SidIndex].DomainIndex = DomainIndex;
        }
    }

LookupNamesInLocalDomainFinish:

    //
    // If successful, update count of completely unmapped names provided.
    // Note that STATUS_NONE_MAPPED errors are suppressed before we get here.
    //

    if (NT_SUCCESS(Status)) {

        LsapDbUpdateCountCompUnmappedNames(TranslatedSids, CompletelyUnmappedCount);
    }

    //
    // If necessary, free the Lsa Heap buffer allocated for the
    // SamLookupSuffixNames and SidIndices arrays.
    //

    if (SamLookupSuffixNames != NULL) {
        LsapFreeLsaHeap( SamLookupSuffixNames );
    }

    if (SidIndices != NULL) {
        LsapFreeLsaHeap( SidIndices );
    }

    //
    // If necessary, free the Relative Ids array returned from SAM.
    //

    if ( SamReturnedIds.Count != 0 ) {
        SamIFree_SAMPR_ULONG_ARRAY ( &SamReturnedIds );
    }

    //
    // If necessary, free the Uses array returned from SAM.
    //

    if ( SamReturnedUses.Count != 0 ) {
        SamIFree_SAMPR_ULONG_ARRAY ( &SamReturnedUses );
    }


    LsapDsDebugOut(( DEB_FTRACE, "LsapDbLookupNamesInLocalDomain: 0x%lx\n", Status ));

    return(Status);

LookupNamesInLocalDomainError:

    //
    // If necessary, free memory for the OutputTrustInformation Domain
    // Name Buffer and Sid Buffer.
    //

    if (DomainIndex >= 0) {

        FreeTrustInformation = &ReferencedDomains->Domains[DomainIndex];

        if (FreeTrustInformation->Sid != NULL) {

            MIDL_user_free( FreeTrustInformation->Sid );
            FreeTrustInformation->Sid = NULL;
        }

        if (FreeTrustInformation->Name.Buffer != NULL) {

            MIDL_user_free( FreeTrustInformation->Name.Buffer );
            FreeTrustInformation->Name.Buffer = NULL;
            FreeTrustInformation->Name.Length = 0;
            FreeTrustInformation->Name.MaximumLength = 0;
        }
    }

    //
    // Reset the Use field for each of the entries written to back to
    // SidTypeUnknown and set the DomainIndex back to LSA_UNKNOWN_INDEX.
    //

    for (NameLookupIndex = 0;
         NameLookupIndex < SamReturnedIds.Count;
         NameLookupIndex++) {

        SidIndex =  SidIndices[NameLookupIndex];
        OutputSids[SidIndex].Use = SidTypeUnknown;
        OutputSids[SidIndex].DomainIndex = LSA_UNKNOWN_INDEX;
    }


    //
    // If the last User Account handle is still open, close it..
    //

    if (LocalSamUserHandle != NULL) {
        SecondaryStatus = SamrCloseHandle(&LocalSamUserHandle);
        LocalSamUserHandle = NULL;
    }

    goto LookupNamesInLocalDomainFinish;
}


NTSTATUS
LsapDbLookupNamesInPrimaryDomain(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformationEx,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT BOOLEAN *fDownlevelSecureChannel,
    IN NTSTATUS *NonFatalStatus
    )

/*++

Routine Description:

    This function attempts to translate Names by searching the Primary
    Domain.

Arguments:

    LookupOptions -- LSA_LOOKUP_ISOLATED_AS_LOCAL        

    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Names - Pointer to array of Names to be translated.
        Zero or all of the Names may already have been translated
        elsewhere.  If any of the Names have been translated, the
        TranslatedSids parameter will point to a location containing a non-NULL
        array of Sid translation structures corresponding to the
        Names.  If the nth Name has been translated, the nth Sid
        translation structure will contain either a non-NULL Sid
        or a non-negative offset into the Referenced Domain List.  If
        the nth Name has not yet been translated, the nth Sid
        translation structure will contain a zero-length Sid string
        and a negative value for the Referenced Domain List index.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    TrustInformation - Specifies the name and Sid of the Primary Domain.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        NOTE:  LsapLookupWksta is not valid for this parameter.
        
    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.


    NonFatalStatus - a status to indicate reasons why no names could have been
                     resolved

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SecondaryStatus = STATUS_SUCCESS;
    ULONG NextLevelCount;
    ULONG NextLevelMappedCount;
    ULONG NameIndex;
    ULONG NextLevelNameIndex;
    PLSAPR_REFERENCED_DOMAIN_LIST NextLevelReferencedDomains = NULL;
    PLSAPR_REFERENCED_DOMAIN_LIST OutputReferencedDomains = NULL;
    PLSAPR_TRANSLATED_SID_EX2 NextLevelSids = NULL;
    PLSAPR_UNICODE_STRING NextLevelNames = NULL;
    PLSAPR_UNICODE_STRING NextLevelPrefixNames = NULL;
    PLSAPR_UNICODE_STRING NextLevelSuffixNames = NULL;
    LONG FirstEntryIndex;
    PULONG NameIndices = NULL;
    BOOLEAN PartialNameTranslationsAttempted = FALSE;
    ULONG ServerRevision = 0;

    LSAPR_TRUST_INFORMATION Dummy;
    PLSAPR_TRUST_INFORMATION TrustInformation = &Dummy;

    LsapConvertExTrustToOriginal( TrustInformation, TrustInformationEx );

    *NonFatalStatus = STATUS_SUCCESS;

    //
    // If there are no completely unmapped Names remaining, just return.
    //

    if (*CompletelyUnmappedCount == (ULONG) 0) {

        goto LookupNamesInPrimaryDomainFinish;
    }

    //
    // We have successfully opened a Domain Controller's Policy
    // Database.  Now prepare to hand off a Name lookup for the
    // remaining unmapped Names to that Controller.  Here, this
    // server side of the LSA is a client of the LSA on the
    // target controller.  We will construct an array of the
    // remianing unmapped Names, look them up and then merge the
    // resulting ReferencedDomains and Translated Sids into
    // our existing list.
    //

    NextLevelCount = *CompletelyUnmappedCount;

    //
    // Allocate an array to hold the indices of unmapped Names
    // relative to the original Names and TranslatedSids->Sids
    // arrays.
    //

    NameIndices = MIDL_user_allocate(NextLevelCount * sizeof(ULONG));

    Status = STATUS_INSUFFICIENT_RESOURCES;

    if (NameIndices == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }

    //
    // Allocate an array of UNICODE_STRING structures for the
    // names to be looked up at the Domain Controller.
    //

    NextLevelNames = MIDL_user_allocate(
                         sizeof(UNICODE_STRING) * NextLevelCount
                         );

    if (NextLevelNames == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }

    //
    // Allocate an array of UNICODE_STRING structures for the
    // prefix names to be cached.
    //

    NextLevelPrefixNames = MIDL_user_allocate(
                         sizeof(UNICODE_STRING) * NextLevelCount
                         );

    if (NextLevelPrefixNames == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }
    //
    // Allocate an array of UNICODE_STRING structures for the
    // suffix names to be cached.
    //

    NextLevelSuffixNames = MIDL_user_allocate(
                         sizeof(UNICODE_STRING) * NextLevelCount
                         );

    if (NextLevelSuffixNames == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }

    Status = STATUS_SUCCESS;

    //
    // Now scan the original array of Names and its parallel
    // Translated Sids array.  Copy over any names that are completely
    // unmapped.
    //

    NextLevelNameIndex = (ULONG) 0;

    for (NameIndex = 0;
         NameIndex < Count && NextLevelNameIndex < NextLevelCount;
         NameIndex++) {

        if (LsapDbCompletelyUnmappedSid(&TranslatedSids->Sids[NameIndex])) {

            if ( (LookupOptions & LSA_LOOKUP_ISOLATED_AS_LOCAL)
              && (PrefixNames[NameIndex].Length == 0)  ) {

               //
               // Don't lookup isolated names off machine
               //
               continue;
            }

            NextLevelNames[NextLevelNameIndex] = Names[NameIndex];
            NextLevelPrefixNames[NextLevelNameIndex] = PrefixNames[NameIndex];
            NextLevelSuffixNames[NextLevelNameIndex] = SuffixNames[NameIndex];
            
            NameIndices[NextLevelNameIndex] = NameIndex;
            NextLevelNameIndex++;

        }
    }

    if (NextLevelNameIndex == 0) {

        // Nothing to do
        Status = STATUS_SUCCESS;
        goto LookupNamesInPrimaryDomainFinish;
    }

    NextLevelMappedCount = (ULONG) 0;

    Status = LsapDbLookupNameChainRequest(TrustInformationEx,
                                          NextLevelCount,
                                          (PUNICODE_STRING)NextLevelNames,
                                          (PLSA_REFERENCED_DOMAIN_LIST *)&NextLevelReferencedDomains,
                                          (PLSA_TRANSLATED_SID_EX2 * )&NextLevelSids,
                                          LookupLevel,
                                          &NextLevelMappedCount,
                                          &ServerRevision
                                          );

    if ( 0 != ServerRevision ) {
        if ( ServerRevision & LSA_CLIENT_PRE_NT5 ) {
             *fDownlevelSecureChannel = TRUE;
        }
    }

    //
    // If the callout to LsaLookupNames() was unsuccessful, disregard
    // the error and set the domain name for any Sids having this
    // domain Sid as prefix sid.
    //

    if (!NT_SUCCESS(Status) && Status != STATUS_NONE_MAPPED) {

        //
        // Let the caller know there is a trust problem
        //
        if ( LsapDbIsStatusConnectionFailure(Status) ) {
            *NonFatalStatus = Status;
        }

        Status = STATUS_SUCCESS;
        goto LookupNamesInPrimaryDomainFinish;
    }

    //
    // Cache any sids that came back
    //

    (void) LsapDbUpdateCacheWithNames(
            (PUNICODE_STRING) NextLevelSuffixNames,
            (PUNICODE_STRING) NextLevelPrefixNames,
            NextLevelCount,
            NextLevelReferencedDomains,
            NextLevelSids
            );

    //
    // The callout to LsaLookupNames() was successful.  We now have
    // an additional list of Referenced Domains containing the
    // Primary Domain and/or one or more of its Trusted Domains.
    // Merge the two Referenced Domain Lists together, noting that
    // since they are disjoint, the second list is simply
    // concatenated with the first.  The index of the first entry
    // of the second list will be used to adjust all of the
    // Domain Index entries in the Translated Names entries.
    // Note that since the memory for the graph of the first
    // Referenced Domain list has been allocated as individual
    // nodes, we specify that the nodes in this graph can be
    // referenced by the output Referenced Domain list.
    //

    Status = LsapDbLookupMergeDisjointReferencedDomains(
                 ReferencedDomains,
                 NextLevelReferencedDomains,
                 &OutputReferencedDomains,
                 LSAP_DB_USE_FIRST_MERGAND_GRAPH
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInPrimaryDomainError;
    }

    FirstEntryIndex = ReferencedDomains->Entries;

    //
    // Now update the original list of Translated Names.  We
    // update each entry that has newly been translated by copying
    // the entry from the new list and adjusting its
    // Referenced Domain List Index upwards by adding the index
    // of the first entry in the Next level List..
    //

    for( NextLevelNameIndex = 0;
         NextLevelNameIndex < NextLevelCount;
         NextLevelNameIndex++ ) {

        if ( !LsapDbCompletelyUnmappedSid(&NextLevelSids[NextLevelNameIndex]) ) {

            NameIndex = NameIndices[NextLevelNameIndex];

            TranslatedSids->Sids[NameIndex]
            = NextLevelSids[NextLevelNameIndex];

            Status = LsapRpcCopySid(NULL,
                                    &TranslatedSids->Sids[NameIndex].Sid,
                                    NextLevelSids[NextLevelNameIndex].Sid);

            if (!NT_SUCCESS(Status)) {
                goto LookupNamesInPrimaryDomainError;
            }

            TranslatedSids->Sids[NameIndex].DomainIndex =
                FirstEntryIndex +
                NextLevelSids[NextLevelNameIndex].DomainIndex;

            (*CompletelyUnmappedCount)--;
        }
    }

    //
    // Update the Referenced Domain List if a new one was produced
    // from the merge.  We retain the original top-level structure.
    //

    if (OutputReferencedDomains != NULL) {

        if (ReferencedDomains->Domains != NULL) {

            MIDL_user_free( ReferencedDomains->Domains );
            ReferencedDomains->Domains = NULL;
        }

        *ReferencedDomains = *OutputReferencedDomains;
        MIDL_user_free( OutputReferencedDomains );
        OutputReferencedDomains = NULL;
    }

    //
    // Update the Mapped Count and close the Controller Policy
    // Handle.
    //

    *MappedCount += NextLevelMappedCount;

    //
    // Any error status that has not been suppressed must be reported
    // to the caller.  Errors such as connection failures to other LSA's
    // are suppressed.
    //

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInPrimaryDomainError;
    }

LookupNamesInPrimaryDomainFinish:

    //
    // If necessary, update count of completely unmapped names.
    //

    if (*CompletelyUnmappedCount > (ULONG) 0) {

        LsapDbUpdateCountCompUnmappedNames(TranslatedSids, CompletelyUnmappedCount);
    }

    //
    // We can return partial translations for composite Names in which the
    // domain component is known.  We do this provided there has been
    // no reported error.  Errors resulting from callout to another
    // LSA will have been suppressed.
    //

    if (NT_SUCCESS(Status) &&
        (*MappedCount < Count) &&
        !PartialNameTranslationsAttempted) {

        SecondaryStatus = LsapDbLookupTranslateUnknownNamesInDomain(
                              Count,
                              Names,
                              PrefixNames,
                              SuffixNames,
                              TrustInformationEx,
                              ReferencedDomains,
                              TranslatedSids,
                              LookupLevel,
                              MappedCount,
                              CompletelyUnmappedCount
                              );

        PartialNameTranslationsAttempted = TRUE;

        if (!NT_SUCCESS(SecondaryStatus)) {

            goto LookupNamesInPrimaryDomainError;
        }
    }

    //
    // If necessary, free the Next Level Referenced Domain List.
    // Note that this structure is allocated(all_nodes) since it was
    // allocated by the client side of the Domain Controller LSA.
    //

    if (NextLevelReferencedDomains != NULL) {

        MIDL_user_free( NextLevelReferencedDomains );
        NextLevelReferencedDomains = NULL;
    }

    //
    // If necessary, free the Next Level Names array.  We only free the
    // top level, since the names therein were copied from the input
    // TranslatedNames->Names array.
    //

    if (NextLevelNames != NULL) {

        MIDL_user_free( NextLevelNames );
        NextLevelNames = NULL;
    }

    if (NextLevelPrefixNames != NULL) {

        MIDL_user_free( NextLevelPrefixNames );
        NextLevelPrefixNames = NULL;
    }

    if (NextLevelSuffixNames != NULL) {

        MIDL_user_free( NextLevelSuffixNames );
        NextLevelSuffixNames = NULL;
    }

    //
    // If necessary, free the Next Level Translated Sids array.  Note
    // that this array is allocated(all_nodes).
    //

    if (NextLevelSids != NULL) {

        MIDL_user_free( NextLevelSids );
        NextLevelSids = NULL;
    }

    //
    // If necessary, free the array that maps Name Indices from the
    // Next Level to the Current Level.
    //

    if (NameIndices != NULL) {

        MIDL_user_free( NameIndices );
        NameIndices = NULL;
    }

    return(Status);

LookupNamesInPrimaryDomainError:

    //
    // If the primary status was a success code, but the secondary
    // status was an error, propagate the secondary status.
    //

    if ((!NT_SUCCESS(SecondaryStatus)) && NT_SUCCESS(Status)) {

        Status = SecondaryStatus;
    }

    goto LookupNamesInPrimaryDomainFinish;
}


NTSTATUS
LsapDbLookupNamesInTrustedDomains(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN BOOLEAN fIncludeIntraforest,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    IN NTSTATUS   *NonFatalStatus
    )

/*++

Routine Description:

    This function attempts to lookup Names to see if they belong to
    any of the Domains that are trusted by the Domain for which this
    machine is a DC.

Arguments:

    LookupOptions - LSA_LOOKUP_ISOLATED_AS_LOCAL
    
    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.
        
    fIncludeIntraforest -- if TRUE, trusted domains in our local forest
                           are searched.

    Names - Pointer to array of Names to be translated.  Zero or all of the
        Names may already have been translated elsewhere.  If any of the
        Names have been translated, the TranslatedSids parameter will point
        to a location containing a non-NULL array of Sid translation
        structures corresponding to the Names.  If the nth Name has been
        translated, the nth Sid translation structure will contain either a
        non-NULL Sid or a non-negative offset into the Referenced Domain
        List.  If the nth Name has not yet been translated, the nth Sid
        translation structure will contain a zero-length Sid string and a
        negative value for the Referenced Domain List index.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.

        NOTE:  LsapLookupWksta is not valid for this parameter.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.

    NonFatalStatus - a status to indicate reasons why no names could have been
                    resolved

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_LOOKUP_WORK_LIST WorkList = NULL;

    *NonFatalStatus = STATUS_SUCCESS;
    //
    // Build a WorkList for this Lookup and put it on the Work Queue.
    //
    // NOTE: This routine does not need to hold the Lookup Work Queue
    //       lock to ensure validity of the WorkList pointer, because the
    //       pointer remains valid until this routine frees it via
    //       LsapDbLookupDeleteWorkList().  Although other threads may
    //       process the WorkList, do not delete it.
    //
    //       A called routine must acquire the lock in order to access
    //       the WorkList after it has been added to the Work Queue.
    //

    Status = LsapDbLookupNamesBuildWorkList(
                 LookupOptions,
                 Count,
                 fIncludeIntraforest,
                 Names,
                 PrefixNames,
                 SuffixNames,
                 ReferencedDomains,
                 TranslatedSids,
                 LookupLevel,
                 MappedCount,
                 CompletelyUnmappedCount,
                 &WorkList
                 );

    if (!NT_SUCCESS(Status)) {

        //
        // If no Work List has been built because there are no
        // eligible domains to search, exit, suppressing the error.

        if (Status == STATUS_NONE_MAPPED) {

            Status = STATUS_SUCCESS;
            goto LookupNamesInTrustedDomainsFinish;
        }

        goto LookupNamesInTrustedDomainsError;
    }

    //
    // Start the work, by dispatching one or more worker threads
    // if necessary.
    //

    Status = LsapDbLookupDispatchWorkerThreads( WorkList );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInTrustedDomainsError;
    }

    //
    // Wait for completion/termination of all items on the Work List.
    //

    Status = LsapDbLookupAwaitCompletionWorkList( WorkList );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInTrustedDomainsError;
    }

LookupNamesInTrustedDomainsFinish:


    if ( WorkList &&
         !NT_SUCCESS( WorkList->NonFatalStatus ) )
    {
        //
        // Propogate the error as non fatal
        //
        *NonFatalStatus = WorkList->NonFatalStatus;
    }

    //
    // If a Work List was created, delete it from the Work Queue
    //

    if (WorkList != NULL) {

        Status = LsapDbLookupDeleteWorkList( WorkList );
        WorkList = NULL;
    }

    return(Status);

LookupNamesInTrustedDomainsError:

    goto LookupNamesInTrustedDomainsFinish;
}


NTSTATUS
LsapDbLookupTranslateNameDomain(
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OPTIONAL PLSA_TRANSLATED_SID_EX2 TranslatedSid,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    OUT PLONG DomainIndex
    )

/*++

Routine Description:

    This function optionally produces a Translated Sid entry for Domain
    from its Name and Sid, and adds Trust Information for the Domain to
    a Referenced Domain List.  The index of the new (or existing) entry
    in the Referenced Domain List is returned.

Arguments:

    TrustInformation - Pointer to Trust Information for the Domain consisting
        of its Name and Sid.

    TranslatedSid - Optional pointer to Translated Sid entry which will
        be filled in with the translation for this Domain.  If NULL
        is specified, no entry is fiiled in.

    ReferencedDomains - Pointer to Referenced Domain List in which an
        entry consisting of the Trust Information for the Domain will be
        made if one does not already exist.

    DomainIndex - Receives the index of the existing or new entry for the
        Domain in the Referenced Domain List.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status;


    Status = LsapDbLookupAddListReferencedDomains(
                 ReferencedDomains,
                 TrustInformation,
                 DomainIndex
                 );

    if (!NT_SUCCESS(Status)) {

        goto TranslateNameDomainError;
    }

    //
    // If requested, fill in a Sid translation entry for the domain.
    //

    if (TranslatedSid != NULL) {

        Status = LsapRpcCopySid(
                     NULL,
                     (PSID) &TranslatedSid->Sid,
                     (PSID) TrustInformation->Sid
                     );
        if (!NT_SUCCESS(Status)) {
            goto TranslateNameDomainError;
        }
        TranslatedSid->Use = SidTypeDomain;
        TranslatedSid->DomainIndex = *DomainIndex;
    }

TranslateNameDomainFinish:

    return(Status);

TranslateNameDomainError:

    goto TranslateNameDomainFinish;
}


NTSTATUS
LsapDbLookupTranslateUnknownNamesInDomain(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformationEx,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function looks among the unknown Sids in the given list and
    translates the Domain Name for any whose Domain Prefix Sid matches
    the given Domain Sid.

Arguments:

    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Names - Pointer to array of Names to be translated.
        Zero or all of the Names may already have been translated
        elsewhere.  If any of the Names have been translated, the
        TranslatedSids parameter will point to a location containing a non-NULL
        array of Sid translation structures corresponding to the
        Names.  If the nth Name has been translated, the nth Sid
        translation structure will contain either a non-NULL Sid
        or a non-negative offset into the Referenced Domain List.  If
        the nth Name has not yet been translated, the nth Sid
        translation structure will contain a zero-length Sid string
        and a negative value for the Referenced Domain List index.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    TrustInformation - Pointer to Trust Information specifying a Domain Sid
        and Name.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.

        NOTE:  LsapLookupWksta is not valid for this parameter.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG RemainingCompletelyUnmappedCount;
    ULONG NameIndex;
    PLSAPR_UNICODE_STRING DomainName = &TrustInformationEx->FlatName;
    PLSAPR_UNICODE_STRING DnsDomainName = &TrustInformationEx->DomainName;
    BOOLEAN DomainAlreadyAdded = FALSE;
    LONG DomainIndex = 0;
    LSAPR_TRUST_INFORMATION Dummy;
    PLSAPR_TRUST_INFORMATION TrustInformation = &Dummy;

    LsapConvertExTrustToOriginal( TrustInformation, TrustInformationEx );


    //
    // Scan the array of Names looking for composite ones whose domain has
    // not been found.
    //

    for( NameIndex = 0,
         RemainingCompletelyUnmappedCount = *CompletelyUnmappedCount;
         (RemainingCompletelyUnmappedCount > 0) && (NameIndex < Count);
         NameIndex++) {

        //
        // Check if this Name is completely unmapped (i.e. its domain
        // has not yet been identified).
        //

        if (TranslatedSids->Sids[NameIndex].DomainIndex == LSA_UNKNOWN_INDEX) {

            //
            // Found a completely unmapped Name.  If it belongs to the
            // specified Domain, add the Domain to the Referenced Domain
            // list if we have not already done so.
            //

            if (LsapRtlPrefixName(
                    (PUNICODE_STRING) DomainName,
                    (PUNICODE_STRING) &Names[NameIndex])
             || LsapRtlPrefixName(
                    (PUNICODE_STRING) DnsDomainName,
                    (PUNICODE_STRING) &Names[NameIndex])
                    ) {

                if (!DomainAlreadyAdded) {

                    Status = LsapDbLookupAddListReferencedDomains(
                                 ReferencedDomains,
                                 TrustInformation,
                                 &DomainIndex
                                 );

                    if (!NT_SUCCESS(Status)) {

                        break;
                    }

                    DomainAlreadyAdded = TRUE;
                }

                //
                // Reference the domain from the TranslatedNames entry
                //

                TranslatedSids->Sids[NameIndex].DomainIndex = DomainIndex;

                //
                // This name is now partially translated, so reduce the
                // count of completely unmapped names.
                //

                (*CompletelyUnmappedCount)--;
            }

            //
            // Decrement count of completely unmapped Names scanned.
            //

            RemainingCompletelyUnmappedCount--;
        }
    }

    return(Status);
}


NTSTATUS
LsapDbLookupIsolatedDomainName(
    IN ULONG NameIndex,
    IN PLSAPR_UNICODE_STRING IsolatedName,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )
{
    LSAPR_TRUST_INFORMATION_EX ex;

    LsapConvertTrustToEx( &ex, TrustInformation );

    return LsapDbLookupIsolatedDomainNameEx( NameIndex,
                                             IsolatedName,
                                             &ex,
                                             ReferencedDomains,
                                             TranslatedSids,
                                             MappedCount,
                                             CompletelyUnmappedCount);
}


NTSTATUS
LsapDbLookupIsolatedDomainNameEx(
    IN ULONG NameIndex,
    IN PLSAPR_UNICODE_STRING IsolatedName,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformationEx,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function translates an Isolated Name if it matches a
    given Domain Name.

Arguments:

    NameIndex - Specifies the index of the entry for the Name within
        the TranslatedSids array, which will be updated if the Name
        matches the Domain Name contained in the TrusteInformation parameter.

    IsolatedName - Specifies the Name to be compared with the Domain Name
        contained in the TrustInformation parameter.

    TrustInformation - Specifies the Name and Sid of a Domain.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_NONE_MAPPED - The specified name is not the same as the
            name of the specified domain.

        Result codes from called routines.

--*/

{
    NTSTATUS Status = STATUS_NONE_MAPPED;

    LSAPR_TRUST_INFORMATION  Dummy;
    PLSAPR_TRUST_INFORMATION TrustInformation = &Dummy;
    ULONG Length;

    LsapConvertExTrustToOriginal( TrustInformation, TrustInformationEx );

    //
    // See if the names match.  If they don't, return error.
    //
    if (!RtlEqualDomainName(
            (PUNICODE_STRING) IsolatedName,
            (PUNICODE_STRING) &TrustInformation->Name)
     && !RtlEqualDomainName(
            (PUNICODE_STRING) IsolatedName,
            (PUNICODE_STRING) &TrustInformationEx->DomainName) )
    {
        goto LookupIsolatedDomainNameError;

    }

    //
    // Name matches the name of the given Domain.  Add that
    // Domain to the Referenced Domain List and translate it.
    //

    Status = LsapDbLookupAddListReferencedDomains(
                 ReferencedDomains,
                 TrustInformation,
                 (PLONG) &TranslatedSids->Sids[NameIndex].DomainIndex
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupIsolatedDomainNameError;
    }

    //
    // Fill in the Translated Sids entry.
    //

    TranslatedSids->Sids[NameIndex].Use = SidTypeDomain;

    Length = RtlLengthSid(TrustInformation->Sid);
    TranslatedSids->Sids[NameIndex].Sid = MIDL_user_allocate(Length);
    if (TranslatedSids->Sids[NameIndex].Sid == NULL) {
        Status = STATUS_NO_MEMORY;
        goto LookupIsolatedDomainNameError;
    }
    RtlCopySid(Length, 
               TranslatedSids->Sids[NameIndex].Sid, 
               TrustInformation->Sid);

    Status = STATUS_SUCCESS;
    (*MappedCount)++;
    (*CompletelyUnmappedCount)--;

LookupIsolatedDomainNameFinish:

    return(Status);

LookupIsolatedDomainNameError:

    goto LookupIsolatedDomainNameFinish;
}

NTSTATUS
LsarGetUserName(
    IN PLSAPR_SERVER_NAME ServerName,
    IN OUT PLSAPR_UNICODE_STRING * UserName,
    OUT OPTIONAL PLSAPR_UNICODE_STRING * DomainName
    )

/*++

Routine Description:

    This routine is the LSA Server worker routine for the LsaGetUserName
    API.


    WARNING:  This routine allocates memory for its output.  The caller is
    responsible for freeing this memory after use.  See description of the
    Names parameter.

Arguments:

    ServerName - the name of the server the client asked to execute
        this API on, or NULL for the local machine.

    UserName - Receives name of the current user.

    DomainName - Optionally receives domain name of the current user.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully and all Sids have
            been translated to names.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            such as memory to complete the call.
--*/

{
    LUID LogonId;
    LUID SystemLogonId = SYSTEM_LUID ;
    PUNICODE_STRING AccountName;
    PUNICODE_STRING AuthorityName;
    PSID UserSid;
    PSID DomainSid = NULL;
    ULONG Rid;
    PLSAP_LOGON_SESSION LogonSession = NULL ;
    PTOKEN_USER TokenUserInformation = NULL;
    NTSTATUS Status;

    LsarpReturnCheckSetup();

    //
    // Sanity check the input arguments
    //
    if ( *UserName != NULL ) {
        return STATUS_INVALID_PARAMETER;
    }


    if (ARGUMENT_PRESENT(DomainName)) {

        if ( *DomainName != NULL ) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Let's see if we're trying to look up the currently logged on
    // user.
    //
    //
    // TokenUserInformation from this call must be freed by calling
    // LsapFreeLsaHeap().
    //

    Status = LsapQueryClientInfo(
                &TokenUserInformation,
                &LogonId
                );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // If the user ID is Anonymous then there is no name and domain in the
    // logon session
    //

    if (RtlEqualSid(
            TokenUserInformation->User.Sid,
            LsapAnonymousSid
            )) {
        AccountName = &WellKnownSids[LsapAnonymousSidIndex].Name;
        AuthorityName = &WellKnownSids[LsapAnonymousSidIndex].DomainName;

    } else if (RtlEqualLuid( &LogonId, &SystemLogonId ) ) {

        AccountName = LsapDbWellKnownSidName( LsapLocalSystemSidIndex );
        AuthorityName = LsapDbWellKnownSidDescription( LsapLocalSystemSidIndex );

    } else {

        LogonSession = LsapLocateLogonSession ( &LogonId );

        //
        // During setup, we may get NULL returned for the logon session.
        //

        if (LogonSession == NULL) {

            Status = STATUS_NO_SUCH_LOGON_SESSION;
            goto Cleanup;
        }

        //
        // Got a match.  Get the username and domain information
        // from the LogonId
        //


        AccountName   = &LogonSession->AccountName;
        AuthorityName = &LogonSession->AuthorityName;

    }

    *UserName = MIDL_user_allocate(sizeof(LSAPR_UNICODE_STRING));

    if (*UserName == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LsapRpcCopyUnicodeString(
                NULL,
                (PUNICODE_STRING) *UserName,
                AccountName
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Optionally copy the domain name
    //

    if (ARGUMENT_PRESENT(DomainName)) {

        *DomainName = MIDL_user_allocate(sizeof(LSAPR_UNICODE_STRING));

        if (*DomainName == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Status = LsapRpcCopyUnicodeString(
                    NULL,
                    (PUNICODE_STRING) *DomainName,
                    AuthorityName
                    );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

    }




Cleanup:

    if ( LogonSession )
    {
        LsapReleaseLogonSession( LogonSession );
    }

    if (TokenUserInformation != NULL) {
        LsapFreeLsaHeap( TokenUserInformation );
    }

    if (!NT_SUCCESS(Status)) {
        if (*UserName != NULL) {
            if ((*UserName)->Buffer != NULL) {
                MIDL_user_free((*UserName)->Buffer);
            }
            MIDL_user_free(*UserName);
            *UserName = NULL;
        }

        if ( ARGUMENT_PRESENT(DomainName) ){
            if (*DomainName != NULL) {
                if ((*DomainName)->Buffer != NULL) {
                    MIDL_user_free((*DomainName)->Buffer);
                }
                MIDL_user_free(*DomainName);
                *DomainName = NULL;
            }
        }
    }

    LsarpReturnPrologue();

    return(Status);
}




VOID
LsapDbFreeEnumerationBuffer(
    IN PLSAP_DB_NAME_ENUMERATION_BUFFER DbEnumerationBuffer
    )
/*++

Routine Description:

    This routine will free the memory associated with an enumeration buffer

Arguments:

    DbEnumerationBuffer - Enumeration buffer to free

Return Values:

    VOID
--*/
{
    ULONG i;

    if ( DbEnumerationBuffer == NULL || DbEnumerationBuffer->EntriesRead == 0 ||
         DbEnumerationBuffer->Names == NULL ) {

         return;
    }

    for ( i = 0; i < DbEnumerationBuffer->EntriesRead; i++) {

        MIDL_user_free( DbEnumerationBuffer->Names[ i ].Buffer );
    }

    MIDL_user_free( DbEnumerationBuffer->Names );
}


NTSTATUS
LsapDbLookupNamesInGlobalCatalog(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    )
/*++

Routine Description:

    This routine looks at the list of name that have yet to be resolved.
    If the any of the names belong to domain that are stored in the DS,
    then these sids are packaged up and sent to a GC for translation.

    Note: this will resolve names from domains that we trust directly and
    indirectly

    Note: names with no domain name are also sent to the GC

Arguments:

    LookupOptions - LSA_LOOKUP_ISOLATED_AS_LOCAL        
    
    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.
        
    Names - Pointer to array of Names to be translated.  Zero or all of the
        Names may already have been translated elsewhere.  If any of the
        Names have been translated, the TranslatedSids parameter will point
        to a location containing a non-NULL array of Sid translation
        structures corresponding to the Names.  If the nth Name has been
        translated, the nth Sid translation structure will contain either a
        non-NULL Sid or a non-negative offset into the Referenced Domain
        List.  If the nth Name has not yet been translated, the nth Sid
        translation structure will contain a zero-length Sid string and a
        negative value for the Referenced Domain List index.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.


    NonFatalStatus - a status to indicate reasons why no names could have been
                      resolved

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;

    ULONG          cGcNames = 0;
    BOOLEAN        *PossibleGcNames = NULL;
    SID_NAME_USE   *GcSidNameUse = NULL;
    UNICODE_STRING *GcNames = NULL;
    ULONG          *GcNameOriginalIndex = NULL;
    PSAMPR_PSID_ARRAY SidArray = NULL;
    ULONG          *GcNamesFlags = NULL;
    ULONG           Length;

    ULONG i;

    *NonFatalStatus = STATUS_SUCCESS;

    //
    // Determine what sids are part of known nt5 domains
    // and package into an array
    //
    ASSERT( Count == TranslatedSids->Entries );

    if ( !SampUsingDsData() ) {

        //
        // Only useful if the ds is running
        //
        return STATUS_SUCCESS;

    }

    PossibleGcNames = MIDL_user_allocate( Count * sizeof(BOOLEAN) );
    if ( !PossibleGcNames ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }
    RtlZeroMemory( PossibleGcNames, Count * sizeof(BOOLEAN) );

    for ( i = 0; i < Count; i++ ) {

        if ( LsapDbCompletelyUnmappedSid(&TranslatedSids->Sids[i]) ) {

            //
            // If the name 
            //
            // 1. has a domain portion and
            // 2. the domain is not in the forest and
            // 3. the domain is a directly trusted domain
            // 
            // then don't look up at the GC -- use the direct
            // trust link instead
            //
            if ( PrefixNames[i].Length != 0 ) {

                NTSTATUS Status2;

                Status2 = LsapDomainHasDirectExternalTrust((PUNICODE_STRING)&PrefixNames[i],
                                                            NULL,
                                                            NULL,
                                                            NULL);
                if (NT_SUCCESS(Status2)) {
                    continue;
                }
            }

            //
            // If the name is isolated are we are asked not to lookup isolated
            // names, then don't send to the GC
            //

            if ((LookupOptions & LSA_LOOKUP_ISOLATED_AS_LOCAL)
             &&  PrefixNames[i].Length == 0  ) {
               continue;
            }

            //
            // Can no longer filter since some names might belog to trusted
            // forest.  Note this also fixes 196280.
            //
            cGcNames++;
            PossibleGcNames[i] = TRUE;
        }
    }

    // We should no more than the number of unmapped sids!
    ASSERT( cGcNames <= *CompletelyUnmappedCount );

    if ( 0 == cGcNames ) {
        // nothing to do
        goto Finish;
    }

    //
    // Allocate lots of space to hold the resolved names; this space will
    // be freed at the end of the routine
    //
    GcNames = MIDL_user_allocate( cGcNames * sizeof(UNICODE_STRING) );
    if ( !GcNames ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }
    RtlZeroMemory( GcNames, cGcNames * sizeof(UNICODE_STRING) );

    GcNameOriginalIndex = MIDL_user_allocate( cGcNames * sizeof(ULONG) );
    if ( !GcNameOriginalIndex ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }
    RtlZeroMemory( GcNameOriginalIndex, cGcNames * sizeof(ULONG) );

    cGcNames = 0;
    for ( i = 0; i < Count; i++ ) {

        if ( PossibleGcNames[i] ) {

            ASSERT( sizeof(GcNames[cGcNames]) == sizeof(Names[i]) );
            memcpy( &GcNames[cGcNames], &Names[i], sizeof(UNICODE_STRING) );
            GcNameOriginalIndex[cGcNames] = i;
            cGcNames++;

        }
    }

    // we are done with this
    MIDL_user_free( PossibleGcNames );
    PossibleGcNames = NULL;

    GcSidNameUse = MIDL_user_allocate( cGcNames * sizeof(SID_NAME_USE) );
    if ( !GcSidNameUse ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }
    RtlZeroMemory( GcSidNameUse, cGcNames * sizeof(SID_NAME_USE) );


    GcNamesFlags = MIDL_user_allocate( cGcNames * sizeof(ULONG) );
    if ( !GcNamesFlags ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }
    RtlZeroMemory( GcNamesFlags, cGcNames * sizeof(ULONG) );

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: Chaining a name request to a GC\n"));

    //
    // Call into SAM to resolve the sids at a GC
    //
    Status = SamIGCLookupNames( cGcNames,
                                GcNames,
                                SAMP_LOOKUP_BY_UPN,
                                GcNamesFlags,
                                GcSidNameUse,
                                &SidArray );

    if (!NT_SUCCESS(Status)) {
        LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: Chain to GC request failed  (0x%x)\n", Status));
    }

    if ( STATUS_DS_GC_NOT_AVAILABLE == Status ) {


        //
        // Ok, don't update the mapped count since no names were
        // resolved
        //
        LsapDbLookupReportEvent0( 1,
                                  EVENTLOG_WARNING_TYPE,
                                  LSAEVENT_LOOKUP_GC_FAILED,
                                  sizeof( ULONG ),
                                  &Status);
        *NonFatalStatus = Status;
        Status = STATUS_SUCCESS;
        goto Finish;

    }

    // Any other error is fatal
    if ( !NT_SUCCESS( Status ) ) {
        goto Finish;
    }

    //
    // For each name resolved, put back in the original array and update
    // the referenced domain's list
    //
    for ( i = 0; i < cGcNames; i++ ) {

        BOOLEAN fStatus;
        ULONG OriginalIndex;
        LSAPR_TRUST_INFORMATION TrustInformation;
        PSID  DomainSid = NULL;
        ULONG Rid = 0;
        ULONG DomainIndex = LSA_UNKNOWN_INDEX;

        RtlZeroMemory( &TrustInformation, sizeof(TrustInformation) );

        if (GcNamesFlags[i] & SAMP_FOUND_XFOREST_REF) {

            //
            // Flag this entry to be resolved in a trusted forest
            //
            OriginalIndex = GcNameOriginalIndex[i];
            TranslatedSids->Sids[OriginalIndex].Flags |= LSA_LOOKUP_NAME_XFOREST_REF;
       }

        if ( SidTypeUnknown == GcSidNameUse[i] ) {

            // go on to the next one right away
            goto IterationCleanup;
        }

        //
        // This name was resolved!
        //
        if ( GcSidNameUse[i] != SidTypeDomain ) {

            // This is not a domain object, so make sure there
            // is a domain reference for this object

            Status = LsapSplitSid( SidArray->Sids[i].SidPointer,
                                   &DomainSid,
                                   &Rid );

            if ( !NT_SUCCESS( Status ) ) {
                goto IterationCleanup;
            }

        } else {

            DomainSid = SidArray->Sids[i].SidPointer;
        }

        if ( LsapIsBuiltinDomain( DomainSid ) ) {
            // don't map this since all searches are implicitly
            // over the account domain, not the builtin domain
            Status = STATUS_SUCCESS;
            goto IterationCleanup;
        }

        fStatus = LsapDbLookupListReferencedDomains( ReferencedDomains,
                                                     DomainSid,
                                                     &DomainIndex );

        if ( FALSE == fStatus ) {

            //
            // No entry for this domain -- add it
            //

            // Set the sid
            TrustInformation.Sid = DomainSid;
            DomainSid = NULL;

            // Allocate and set the name
            Status = LsapGetDomainNameBySid(  TrustInformation.Sid,
                                             (PUNICODE_STRING) &TrustInformation.Name );

            if ( STATUS_NO_SUCH_DOMAIN == Status ) {
                //
                // We longer know about this domain, though we did
                // before we sent the name off to the GC.
                // Don't resolve this name, but do continue on with
                // the next name
                //
                Status = STATUS_SUCCESS;
                goto IterationCleanup;
            }

            // Any other error is a resource error
            if ( !NT_SUCCESS( Status ) ) {
                goto IterationCleanup;
            }

            //
            // Add the entry
            //
            Status = LsapDbLookupAddListReferencedDomains( ReferencedDomains,
                                                           &TrustInformation,
                                                           &DomainIndex );
            if ( !NT_SUCCESS( Status ) ) {
                goto IterationCleanup;
            }
        }

        // We should now have a domain index
        ASSERT( LSA_UNKNOWN_INDEX != DomainIndex );

        // Set the information
        OriginalIndex = GcNameOriginalIndex[i];
        TranslatedSids->Sids[OriginalIndex].Use = GcSidNameUse[i];

        Length = RtlLengthSid(SidArray->Sids[i].SidPointer);
        TranslatedSids->Sids[OriginalIndex].Sid = MIDL_user_allocate(Length);
        if (TranslatedSids->Sids[OriginalIndex].Sid == NULL) {
            Status = STATUS_NO_MEMORY;
            goto IterationCleanup;
        }
        RtlCopySid(Length,
                   TranslatedSids->Sids[OriginalIndex].Sid,
                   SidArray->Sids[i].SidPointer);

        TranslatedSids->Sids[OriginalIndex].DomainIndex = DomainIndex;
        if ( !(GcNamesFlags[i] & SAMP_FOUND_BY_SAM_ACCOUNT_NAME) ) {
            TranslatedSids->Sids[OriginalIndex].Flags |= LSA_LOOKUP_NAME_NOT_SAM_ACCOUNT_NAME;
        }
        (*MappedCount) += 1;
        (*CompletelyUnmappedCount) -= 1;

IterationCleanup:

        if (  TrustInformation.Sid
          && (VOID*)TrustInformation.Sid != (VOID*)SidArray->Sids[i].SidPointer  ) {

            MIDL_user_free( TrustInformation.Sid );
        }
        if ( TrustInformation.Name.Buffer ) {
            MIDL_user_free( TrustInformation.Name.Buffer );
        }

        if ( DomainSid && DomainSid != SidArray->Sids[i].SidPointer ) {
            MIDL_user_free( DomainSid );
        }

        if ( !NT_SUCCESS( Status ) ) {
            break;
        }

    }  // iterate over names returned from the GC search

Finish:

    SamIFreeSidArray( SidArray );

    if ( PossibleGcNames ) {
        MIDL_user_free( PossibleGcNames );
    }
    if ( GcSidNameUse ) {
        MIDL_user_free( GcSidNameUse );
    }
    if ( GcNames ) {
        MIDL_user_free( GcNames );
    }
    if ( GcNameOriginalIndex ) {
        MIDL_user_free( GcNameOriginalIndex );
    }
    if ( GcNamesFlags ) {
        MIDL_user_free( GcNamesFlags );
    }

    //
    // Note: on error, higher level should will free the memory
    // in the returned arrays
    //

    return Status;

}


NTSTATUS
LsapDbLookupNamesInGlobalCatalogWks(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    )
/*++

Routine Description:

   This routine is called from a non-DC when the secure channel DC is a pre
   windows 2000 DC and thus can't talk to a GC.  This routine finds a GC 
   and lookups up the remaining unresolved names at that GC.
   
Arguments:

    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.
        
    LookupOptions - LSA_LOOKUP_ISOLATED_AS_LOCAL        

    Names - Pointer to array of Names to be translated.  Zero or all of the
        Names may already have been translated elsewhere.  If any of the
        Names have been translated, the TranslatedSids parameter will point
        to a location containing a non-NULL array of Sid translation
        structures corresponding to the Names.  If the nth Name has been
        translated, the nth Sid translation structure will contain either a
        non-NULL Sid or a non-negative offset into the Referenced Domain
        List.  If the nth Name has not yet been translated, the nth Sid
        translation structure will contain a zero-length Sid string and a
        negative value for the Referenced Domain List index.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.


    NonFatalStatus - a status to indicate reasons why no names could have been
                      resolved

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SecondaryStatus = STATUS_SUCCESS;
    LSA_HANDLE ControllerPolicyHandle = NULL;
    ULONG NextLevelCount;
    ULONG NextLevelMappedCount;
    ULONG NameIndex;
    ULONG NextLevelNameIndex;
    PLSAPR_REFERENCED_DOMAIN_LIST NextLevelReferencedDomains = NULL;
    PLSAPR_REFERENCED_DOMAIN_LIST OutputReferencedDomains = NULL;
    PLSAPR_TRANSLATED_SID_EX2 NextLevelSids = NULL;
    PLSAPR_UNICODE_STRING NextLevelNames = NULL;
    PLSAPR_UNICODE_STRING NextLevelPrefixNames = NULL;
    PLSAPR_UNICODE_STRING NextLevelSuffixNames = NULL;
    LONG FirstEntryIndex;
    PULONG NameIndices = NULL;
    BOOLEAN PartialNameTranslationsAttempted = FALSE;
    LPWSTR ServerName = NULL;
    LPWSTR ServerPrincipalName = NULL;
    PVOID ClientContext = NULL;
    ULONG ServerRevision;

    *NonFatalStatus = STATUS_SUCCESS;

    //
    // If there are no completely unmapped Names remaining, just return.
    //

    if (*CompletelyUnmappedCount == (ULONG) 0) {

        goto LookupNamesInPrimaryDomainFinish;
    }

    //
    // Open the Policy object on some GC in the forest.
    //
    Status = LsapDbOpenPolicyGc( &ControllerPolicyHandle );

    if (!NT_SUCCESS(Status)) {

        //
        // We cannot access the Global Catalog. Suppress the error
        // and translate Domain Prefix Sids for Sids belonging to
        // the Primary Domain.
        //

        //
        // If we can't open a open a secure channel if a DC call
        // this a trust relationship problem
        //
        *NonFatalStatus =  STATUS_DS_GC_NOT_AVAILABLE;

        Status = STATUS_SUCCESS;
        goto LookupNamesInPrimaryDomainFinish;
    }

    //
    // We have successfully opened a Domain Controller's Policy
    // Database.  Now prepare to hand off a Name lookup for the
    // remaining unmapped Names to that Controller.  Here, this
    // server side of the LSA is a client of the LSA on the
    // target controller.  We will construct an array of the
    // remianing unmapped Names, look them up and then merge the
    // resulting ReferencedDomains and Translated Sids into
    // our existing list.
    //

    NextLevelCount = *CompletelyUnmappedCount;

    //
    // Allocate an array to hold the indices of unmapped Names
    // relative to the original Names and TranslatedSids->Sids
    // arrays.
    //

    NameIndices = MIDL_user_allocate(NextLevelCount * sizeof(ULONG));

    Status = STATUS_INSUFFICIENT_RESOURCES;

    if (NameIndices == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }

    //
    // Allocate an array of UNICODE_STRING structures for the
    // names to be looked up at the Domain Controller.
    //

    NextLevelNames = MIDL_user_allocate(
                         sizeof(UNICODE_STRING) * NextLevelCount
                         );

    if (NextLevelNames == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }

    //
    // Allocate an array of UNICODE_STRING structures for the
    // prefix names to be cached.
    //

    NextLevelPrefixNames = MIDL_user_allocate(
                         sizeof(UNICODE_STRING) * NextLevelCount
                         );

    if (NextLevelPrefixNames == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }
    //
    // Allocate an array of UNICODE_STRING structures for the
    // suffix names to be cached.
    //
       
    NextLevelSuffixNames = MIDL_user_allocate(
                         sizeof(UNICODE_STRING) * NextLevelCount
                         );

    if (NextLevelSuffixNames == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }

    Status = STATUS_SUCCESS;

    //
    // Now scan the original array of Names and its parallel
    // Translated Sids array.  Copy over any names that are completely
    // unmapped.
    //

    NextLevelNameIndex = (ULONG) 0;

    for (NameIndex = 0;
         NameIndex < Count && NextLevelNameIndex < NextLevelCount;
         NameIndex++) {
   
        if ( (LookupOptions & LSA_LOOKUP_ISOLATED_AS_LOCAL)
          && (PrefixNames[NameIndex].Length == 0)  ) {

           //
           // Don't lookup isolated names off machine
           //
           continue;

        }

        if (LsapDbCompletelyUnmappedSid(&TranslatedSids->Sids[NameIndex])) {


            NextLevelNames[NextLevelNameIndex] = Names[NameIndex];
            NextLevelPrefixNames[NextLevelNameIndex] = PrefixNames[NameIndex];
            NextLevelSuffixNames[NextLevelNameIndex] = SuffixNames[NameIndex];

            NameIndices[NextLevelNameIndex] = NameIndex;
            NextLevelNameIndex++;
        }
    }

    if (NameIndex == 0) {

        // Nothing to do
        Status = STATUS_SUCCESS;
        goto LookupNamesInPrimaryDomainFinish;
    }

    NextLevelMappedCount = (ULONG) 0;

    Status = LsaICLookupNames(
                 ControllerPolicyHandle,
                 0, // no flags necessary
                 NextLevelCount,
                 (PUNICODE_STRING) NextLevelNames,
                 (PLSA_REFERENCED_DOMAIN_LIST *) &NextLevelReferencedDomains,
                 (PLSA_TRANSLATED_SID_EX2 *) &NextLevelSids,
                 LsapLookupGC,
                 0,
                 &NextLevelMappedCount,
                 &ServerRevision
                 );

    //
    // If the callout to LsaLookupNames() was unsuccessful, disregard
    // the error and set the domain name for any Sids having this
    // domain Sid as prefix sid.
    //

    if (!NT_SUCCESS(Status)) {

        //
        // Let the caller know there is a trust problem
        //
        if ( (STATUS_TRUSTED_DOMAIN_FAILURE == Status)
          || (STATUS_DS_GC_NOT_AVAILABLE == Status)  ) {
            *NonFatalStatus = Status;
        }

        Status = STATUS_SUCCESS;
        goto LookupNamesInPrimaryDomainFinish;
    }

    //
    // Cache any sids that came back
    //

    (void) LsapDbUpdateCacheWithNames(
            (PUNICODE_STRING) NextLevelSuffixNames,
            (PUNICODE_STRING) NextLevelPrefixNames,
            NextLevelCount,
            NextLevelReferencedDomains,
            NextLevelSids
            );

    //
    // The callout to LsaLookupNames() was successful.  We now have
    // an additional list of Referenced Domains containing the
    // Primary Domain and/or one or more of its Trusted Domains.
    // Merge the two Referenced Domain Lists together, noting that
    // since they are disjoint, the second list is simply
    // concatenated with the first.  The index of the first entry
    // of the second list will be used to adjust all of the
    // Domain Index entries in the Translated Names entries.
    // Note that since the memory for the graph of the first
    // Referenced Domain list has been allocated as individual
    // nodes, we specify that the nodes in this graph can be
    // referenced by the output Referenced Domain list.
    //

    Status = LsapDbLookupMergeDisjointReferencedDomains(
                 ReferencedDomains,
                 NextLevelReferencedDomains,
                 &OutputReferencedDomains,
                 LSAP_DB_USE_FIRST_MERGAND_GRAPH
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInPrimaryDomainError;
    }

    FirstEntryIndex = ReferencedDomains->Entries;

    //
    // Now update the original list of Translated Names.  We
    // update each entry that has newly been translated by copying
    // the entry from the new list and adjusting its
    // Referenced Domain List Index upwards by adding the index
    // of the first entry in the Next level List..
    //

    for( NextLevelNameIndex = 0;
         NextLevelNameIndex < NextLevelCount;
         NextLevelNameIndex++ ) {

        if ( !LsapDbCompletelyUnmappedSid(&NextLevelSids[NextLevelNameIndex]) ) {

            NameIndex = NameIndices[NextLevelNameIndex];

            TranslatedSids->Sids[NameIndex]
            = NextLevelSids[NextLevelNameIndex];

            Status = LsapRpcCopySid(NULL,
                                    &TranslatedSids->Sids[NameIndex].Sid,
                                    NextLevelSids[NextLevelNameIndex].Sid);

            if (!NT_SUCCESS(Status)) {
                goto LookupNamesInPrimaryDomainError;
            }

            TranslatedSids->Sids[NameIndex].DomainIndex =
                FirstEntryIndex +
                NextLevelSids[NextLevelNameIndex].DomainIndex;

            (*CompletelyUnmappedCount)--;
        }
    }

    //
    // Update the Referenced Domain List if a new one was produced
    // from the merge.  We retain the original top-level structure.
    //

    if (OutputReferencedDomains != NULL) {

        if (ReferencedDomains->Domains != NULL) {

            MIDL_user_free( ReferencedDomains->Domains );
            ReferencedDomains->Domains = NULL;
        }

        *ReferencedDomains = *OutputReferencedDomains;
        MIDL_user_free( OutputReferencedDomains );
        OutputReferencedDomains = NULL;
    }

    //
    // Update the Mapped Count and close the Controller Policy
    // Handle.
    //

    *MappedCount += NextLevelMappedCount;
    SecondaryStatus = LsaClose( ControllerPolicyHandle );
    ControllerPolicyHandle = NULL;

    //
    // Any error status that has not been suppressed must be reported
    // to the caller.  Errors such as connection failures to other LSA's
    // are suppressed.
    //

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInPrimaryDomainError;
    }

LookupNamesInPrimaryDomainFinish:

    //
    // If necessary, update count of completely unmapped names.
    //

    if (*CompletelyUnmappedCount > (ULONG) 0) {

        LsapDbUpdateCountCompUnmappedNames(TranslatedSids, CompletelyUnmappedCount);
    }

    //
    // If necessary, free the Next Level Referenced Domain List.
    // Note that this structure is allocated(all_nodes) since it was
    // allocated by the client side of the Domain Controller LSA.
    //

    if (NextLevelReferencedDomains != NULL) {

        MIDL_user_free( NextLevelReferencedDomains );
        NextLevelReferencedDomains = NULL;
    }

    //
    // If necessary, free the Next Level Names array.  We only free the
    // top level, since the names therein were copied from the input
    // TranslatedNames->Names array.
    //

    if (NextLevelNames != NULL) {

        MIDL_user_free( NextLevelNames );
        NextLevelNames = NULL;
    }

    if (NextLevelPrefixNames != NULL) {

        MIDL_user_free( NextLevelPrefixNames );
        NextLevelPrefixNames = NULL;
    }

    if (NextLevelSuffixNames != NULL) {

        MIDL_user_free( NextLevelSuffixNames );
        NextLevelSuffixNames = NULL;
    }

    //
    // If necessary, free the Next Level Translated Sids array.  Note
    // that this array is allocated(all_nodes).
    //

    if (NextLevelSids != NULL) {

        MIDL_user_free( NextLevelSids );
        NextLevelSids = NULL;
    }

    //
    // If necessary, free the array that maps Name Indices from the
    // Next Level to the Current Level.
    //

    if (NameIndices != NULL) {

        MIDL_user_free( NameIndices );
        NameIndices = NULL;
    }

    //
    // If necessary, close the Controller Policy Handle.
    //

    if ( ControllerPolicyHandle != NULL) {

        SecondaryStatus = LsaClose( ControllerPolicyHandle );
        ControllerPolicyHandle = NULL;

        if (!NT_SUCCESS(SecondaryStatus)) {

            goto LookupNamesInPrimaryDomainError;
        }
    }

    return(Status);

LookupNamesInPrimaryDomainError:

    //
    // If the primary status was a success code, but the secondary
    // status was an error, propagate the secondary status.
    //

    if ((!NT_SUCCESS(SecondaryStatus)) && NT_SUCCESS(Status)) {

        Status = SecondaryStatus;
    }

    goto LookupNamesInPrimaryDomainFinish;
}


NTSTATUS
LsapDbLookupNamesInTrustedForests(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    )
/*++

Routine Description:

    This routine looks at the list of name that have yet to be resolved.
    If the any of the names are marked as belowing to outside of the
    current forest, package up these entries and sent off to the root via
    the trust chain.
    
    N.B. Isolated names not are resolved at this point.
    
    N.B. This routine must be called after the names have been resolved
    at a GC, since it is this call to the GC that marks the names as
    exisiting outside of the local forest.

Arguments:

    LookupOptions - LSA_LOOKUP_ISOLATED_AS_LOCAL
                               
    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Names - Pointer to array of Names to be translated.  Zero or all of the
        Names may already have been translated elsewhere.  If any of the
        Names have been translated, the TranslatedSids parameter will point
        to a location containing a non-NULL array of Sid translation
        structures corresponding to the Names.  If the nth Name has been
        translated, the nth Sid translation structure will contain either a
        non-NULL Sid or a non-negative offset into the Referenced Domain
        List.  If the nth Name has not yet been translated, the nth Sid
        translation structure will contain a zero-length Sid string and a
        negative value for the Referenced Domain List index.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.


    NonFatalStatus - a status to indicate reasons why no names could have been
                      resolved

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS NextLevelSecondaryStatus = STATUS_SUCCESS;
    ULONG NextLevelCount;
    ULONG NextLevelMappedCount;
    ULONG NameIndex;
    ULONG NextLevelNameIndex;
    PLSAPR_REFERENCED_DOMAIN_LIST NextLevelReferencedDomains = NULL;
    PLSAPR_REFERENCED_DOMAIN_LIST OutputReferencedDomains = NULL;
    PLSAPR_TRANSLATED_SID_EX2 NextLevelSids = NULL;
    LSAPR_TRANSLATED_SIDS_EX2 NextLevelSidsStruct;
    PLSAPR_UNICODE_STRING NextLevelNames = NULL;
    LONG FirstEntryIndex;
    PULONG NameIndices = NULL;
    PLSAPR_UNICODE_STRING NextLevelPrefixNames = NULL;
    PLSAPR_UNICODE_STRING NextLevelSuffixNames = NULL;
    BOOLEAN fAllocateAllNodes = FALSE;


    *NonFatalStatus = STATUS_SUCCESS;

    //
    // Get a count of how many names need to be passed on
    //
    NextLevelCount = 0;
    ASSERT(Count == TranslatedSids->Entries);
    for (NameIndex = 0; NameIndex < Count; NameIndex++) {

        if ( (LookupOptions & LSA_LOOKUP_ISOLATED_AS_LOCAL)
          && (PrefixNames[NameIndex].Length == 0)  ) {
           //
           // Don't lookup isolated names off machine
           //
           continue;
        }
        if (TranslatedSids->Sids[NameIndex].Flags & LSA_LOOKUP_NAME_XFOREST_REF) {
            NextLevelCount++;
        }
    }

    if (0 == NextLevelCount) {
        //
        // There is nothing to resolve
        //
        goto LookupNamesInTrustedForestsFinish;
    }

    //
    // Allocate an array to hold the indices of unmapped Names
    // relative to the original Names and TranslatedSids->Sids
    // arrays.
    //
    NameIndices = MIDL_user_allocate(NextLevelCount * sizeof(ULONG));
    if (NameIndices == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto LookupNamesInTrustedForestsError;
    }

    //
    // Allocate an array of UNICODE_STRING structures for the
    // names to be looked up at the Domain Controller.
    //

    NextLevelNames = MIDL_user_allocate(
                         sizeof(UNICODE_STRING) * NextLevelCount
                         );

    if (NextLevelNames == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto LookupNamesInTrustedForestsError;
    }

    NextLevelPrefixNames = MIDL_user_allocate( NextLevelCount * sizeof( UNICODE_STRING ));

    if (NextLevelPrefixNames == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto LookupNamesInTrustedForestsError;
    }

    NextLevelSuffixNames = MIDL_user_allocate( NextLevelCount * sizeof( UNICODE_STRING ));

    if (NextLevelSuffixNames == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto LookupNamesInTrustedForestsError;
    }

    //
    // Now scan the original array of Names and its parallel
    // Translated Sids array.  Copy over any names that need to be resolved
    // in an ex-forest.
    //

    NextLevelNameIndex = (ULONG) 0;
    for (NameIndex = 0;
         NameIndex < Count && NextLevelNameIndex < NextLevelCount;
         NameIndex++) {

        if ( (LookupOptions & LSA_LOOKUP_ISOLATED_AS_LOCAL)
          && (PrefixNames[NameIndex].Length == 0)  ) {
           //
           // Don't lookup isolated names off machine
           //
           continue;
        }

        if (TranslatedSids->Sids[NameIndex].Flags & LSA_LOOKUP_NAME_XFOREST_REF) {

            NextLevelNames[NextLevelNameIndex] = Names[NameIndex];
            NextLevelPrefixNames[NextLevelNameIndex] = PrefixNames[NameIndex];
            NextLevelSuffixNames[NextLevelNameIndex] = SuffixNames[NameIndex];
            NameIndices[NextLevelNameIndex] = NameIndex;
            NextLevelNameIndex++;
        }
    }

    NextLevelMappedCount = (ULONG) 0;
    NextLevelSidsStruct.Entries = 0;
    NextLevelSidsStruct.Sids = NULL;


    Status = LsapDbLookupNamesInTrustedForestsWorker(NextLevelCount,
                                                     NextLevelNames,
                                                     NextLevelPrefixNames,
                                                     NextLevelSuffixNames,
                                                     &NextLevelReferencedDomains,
                                                     &NextLevelSidsStruct,
                                                     &fAllocateAllNodes,
                                                     &NextLevelMappedCount,
                                                     0, // no options,
                                                     &NextLevelSecondaryStatus);

    if (NextLevelSidsStruct.Sids) {
        NextLevelSids = NextLevelSidsStruct.Sids;
        NextLevelSidsStruct.Sids = NULL;
        NextLevelSidsStruct.Entries = 0;
    }

    if (!NT_SUCCESS(Status)
     && LsapDbIsStatusConnectionFailure(Status)) {

        *NonFatalStatus = Status;
        Status = STATUS_SUCCESS;
        goto LookupNamesInTrustedForestsFinish;

    } else if (NT_SUCCESS(Status)
            && !NT_SUCCESS(NextLevelSecondaryStatus)) {

        *NonFatalStatus = NextLevelSecondaryStatus;
        goto LookupNamesInTrustedForestsFinish;

    } else if (!NT_SUCCESS(Status) 
            && Status != STATUS_NONE_MAPPED) {
        //
        // Unhandled error; STATUS_NONE_MAPPED is handled to get
        // partially resolved names.
        //
        goto LookupNamesInTrustedForestsError;
    }
    ASSERT(NT_SUCCESS(Status) || Status == STATUS_NONE_MAPPED);
    Status = STATUS_SUCCESS;


    //
    // Merge the results back in
    //
    Status = LsapDbLookupMergeDisjointReferencedDomains(
                 ReferencedDomains,
                 NextLevelReferencedDomains,
                 &OutputReferencedDomains,
                 LSAP_DB_USE_FIRST_MERGAND_GRAPH
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInTrustedForestsError;
    }

    FirstEntryIndex = ReferencedDomains->Entries;

    //
    // Now update the original list of Translated Names.  We
    // update each entry that has newly been translated by copying
    // the entry from the new list and adjusting its
    // Referenced Domain List Index upwards by adding the index
    // of the first entry in the Next level List.
    //

    for( NextLevelNameIndex = 0;
         NextLevelNameIndex < NextLevelCount;
         NextLevelNameIndex++ ) {

        if ( !LsapDbCompletelyUnmappedSid(&NextLevelSids[NextLevelNameIndex]) ) {

            NameIndex = NameIndices[NextLevelNameIndex];

            TranslatedSids->Sids[NameIndex]
            = NextLevelSids[NextLevelNameIndex];

            Status = LsapRpcCopySid(NULL,
                                    &TranslatedSids->Sids[NameIndex].Sid,
                                    NextLevelSids[NextLevelNameIndex].Sid);

            if (!NT_SUCCESS(Status)) {
                goto LookupNamesInTrustedForestsError;
            }

            TranslatedSids->Sids[NameIndex].DomainIndex =
                FirstEntryIndex +
                NextLevelSids[NextLevelNameIndex].DomainIndex;

            (*CompletelyUnmappedCount)--;
        }
    }

    //
    // Update the Referenced Domain List if a new one was produced
    // from the merge.  We retain the original top-level structure.
    //

    if (OutputReferencedDomains != NULL) {

        if (ReferencedDomains->Domains != NULL) {

            MIDL_user_free( ReferencedDomains->Domains );
            ReferencedDomains->Domains = NULL;
        }

        *ReferencedDomains = *OutputReferencedDomains;
        MIDL_user_free( OutputReferencedDomains );
        OutputReferencedDomains = NULL;
    }

    //
    // Update the Mapped Count
    //

    *MappedCount += NextLevelMappedCount;

    //
    // Any error status that has not been suppressed must be reported
    // to the caller.  Errors such as connection failures to other LSA's
    // are suppressed.
    //

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInTrustedForestsError;
    }

LookupNamesInTrustedForestsFinish:

    //
    // If necessary, update count of completely unmapped names.
    //

    if (*CompletelyUnmappedCount > (ULONG) 0) {

        LsapDbUpdateCountCompUnmappedNames(TranslatedSids, CompletelyUnmappedCount);
    }

    //
    // If necessary, free the Next Level Referenced Domain List.
    // Note the structure is not allocate_all_nodes
    //
    if (NextLevelReferencedDomains != NULL) {
        if (!fAllocateAllNodes) {
            if (NextLevelReferencedDomains->Domains) {
                for (NextLevelNameIndex = 0; 
                        NextLevelNameIndex < NextLevelReferencedDomains->Entries; 
                            NextLevelNameIndex++) {
                    if (NextLevelReferencedDomains->Domains[NextLevelNameIndex].Name.Buffer) {
                        MIDL_user_free(NextLevelReferencedDomains->Domains[NextLevelNameIndex].Name.Buffer);
                    }
                    if (NextLevelReferencedDomains->Domains[NextLevelNameIndex].Sid) {
                        MIDL_user_free(NextLevelReferencedDomains->Domains[NextLevelNameIndex].Sid);
                    }
                }
                MIDL_user_free(NextLevelReferencedDomains->Domains);
            }
        }
        MIDL_user_free( NextLevelReferencedDomains );
        NextLevelReferencedDomains = NULL;
    }

    //
    // If necessary, free the Next Level Names array.  We only free the
    // top level, since the names therein were copied from the input
    // TranslatedNames->Names array.
    //

    if (NextLevelNames != NULL) {

        MIDL_user_free( NextLevelNames );
        NextLevelNames = NULL;
    }

    //
    // If necessary, free the Next Level Translated Sids array.  Note
    // the structure is not allocate_all_nodes
    //
    if (NextLevelSids != NULL) {
        if (!fAllocateAllNodes) {
            for (NextLevelNameIndex = 0; 
                    NextLevelNameIndex < NextLevelCount; 
                        NextLevelNameIndex++) {
                if (NextLevelSids[NextLevelNameIndex].Sid) {
                    MIDL_user_free(NextLevelSids[NextLevelNameIndex].Sid);
                }
            }
        }
        MIDL_user_free( NextLevelSids );
        NextLevelSids = NULL;
    }

    if (NextLevelPrefixNames != NULL) {

        MIDL_user_free( NextLevelPrefixNames );
        NextLevelSids = NULL;
    }

    if (NextLevelSuffixNames != NULL) {

        MIDL_user_free( NextLevelSuffixNames );
        NextLevelSids = NULL;
    }

    //
    // If necessary, free the array that maps Name Indices from the
    // Next Level to the Current Level.
    //

    if (NameIndices != NULL) {

        MIDL_user_free( NameIndices );
        NameIndices = NULL;
    }

    return(Status);

LookupNamesInTrustedForestsError:

    goto LookupNamesInTrustedForestsFinish;
    
}

NTSTATUS
LsapDbLookupNamesInTrustedForestsWorker(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2  TranslatedSids,
    OUT BOOLEAN * fAllocateAllNodes,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    OUT NTSTATUS *NonFatalStatus
    )
/*++

Routine Description:

    This routine takes a set of names that are to be resolved at an 
    external forest and either 1) sends of to the external forest if
    this is the root of a domain or 2) sends to request of to a DC
    in the root of domain (via the trust path).
    
    N.B.  This routine is called from the LsarLookupName request of levels
    LsapLookupXForestReferral and LsaLookupPDC.
    
    N.B. Both ReferencedDomains and TranslatedSids.Sids are allocated
    on output.

Arguments:

    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Names - Pointer to array of Names to be translated.  Zero or all of the
        Names may already have been translated elsewhere.  If any of the
        Names have been translated, the TranslatedSids parameter will point
        to a location containing a non-NULL array of Sid translation
        structures corresponding to the Names.  If the nth Name has been
        translated, the nth Sid translation structure will contain either a
        non-NULL Sid or a non-negative offset into the Referenced Domain
        List.  If the nth Name has not yet been translated, the nth Sid
        translation structure will contain a zero-length Sid string and a
        negative value for the Referenced Domain List index.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    fAllocateAllNodes -- describes how ReferencedDomains and TranslatesSids are
        allocated.
    
    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.


    NonFatalStatus - a status to indicate reasons why no names could have been
                      resolved

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_LOOKUP_LEVEL LookupLevel;
    ULONG i;
    PLSAP_DB_LOOKUP_WORK_LIST WorkList = NULL;


    *NonFatalStatus = STATUS_SUCCESS;
    *fAllocateAllNodes = FALSE;

    if (!LsapDbDcInRootDomain()) {

        //
        // We are not at the root domain -- forward request
        //
        PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
        LSAPR_TRUST_INFORMATION_EX TrustInfoEx;

        //
        // Get our forest name
        //
        Status = LsapDbLookupGetDomainInfo(NULL,
                                           &DnsDomainInfo);
        if (!NT_SUCCESS(Status)) {
            goto LookupNamesInTrustedForestFinish;
        }

        RtlZeroMemory(&TrustInfoEx, sizeof(TrustInfoEx));
        TrustInfoEx.DomainName = *((LSAPR_UNICODE_STRING*)&DnsDomainInfo->DnsForestName);
        Status = LsapDbLookupNameChainRequest(&TrustInfoEx,
                                              Count,
                                              (PUNICODE_STRING)Names,
                                              (PLSA_REFERENCED_DOMAIN_LIST *)ReferencedDomains,
                                              (PLSA_TRANSLATED_SID_EX2 * )&TranslatedSids->Sids,
                                              LsapLookupXForestReferral,
                                              MappedCount,
                                              NULL);

        if (TranslatedSids->Sids) {
            TranslatedSids->Entries = Count;
            *fAllocateAllNodes = TRUE;
        }

        if (!NT_SUCCESS(Status)) {

            //
            // The attempt to chain failed; record the error
            // if it is interesting
            //
            if (LsapDbIsStatusConnectionFailure(Status)) {
                *NonFatalStatus = Status;
            }

            //
            // This should not fail the overall request
            //
            Status = STATUS_SUCCESS;
        }

    } else {

        //
        // Split the names up into different forests and issue a work
        // request for each one
        //
        ULONG i;
        ULONG CompletelyUnmappedCount = Count;

        TranslatedSids->Sids = MIDL_user_allocate(Count * sizeof(LSA_TRANSLATED_SID_EX2));
        if (TranslatedSids->Sids == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto LookupNamesInTrustedForestFinish;
        }
        TranslatedSids->Entries = Count;
    
        //
        // Initialize the Output Sids array.  Zeroise all fields, then
        // Mark all of the Output Sids as being unknown initially and
        // set the DomainIndex fields to a negative number meaning
        // "no domain"
        //
    
        RtlZeroMemory( TranslatedSids->Sids, Count * sizeof(LSA_TRANSLATED_SID_EX2));
        for (i = 0; i < Count; i++) {
            TranslatedSids->Sids[i].Use = SidTypeUnknown;
            TranslatedSids->Sids[i].DomainIndex = LSA_UNKNOWN_INDEX;
        }
    
        //
        // Create an empty Referenced Domain List.
        //
        Status = LsapDbLookupCreateListReferencedDomains( ReferencedDomains, 0 );
        if (!NT_SUCCESS(Status)) {
    
            goto LookupNamesInTrustedForestFinish;
        }

        //
        // Build a WorkList for this Lookup and put it on the Work Queue.
        //
        // NOTE: This routine does not need to hold the Lookup Work Queue
        //       lock to ensure validity of the WorkList pointer, because the
        //       pointer remains valid until this routine frees it via
        //       LsapDbLookupDeleteWorkList().  Although other threads may
        //       process the WorkList, do not delete it.
        //
        //       A called routine must acquire the lock in order to access
        //       the WorkList after it has been added to the Work Queue.
        //
    
        Status = LsapDbLookupXForestNamesBuildWorkList(
                     Count,
                     Names,
                     PrefixNames,
                     SuffixNames,
                     *ReferencedDomains,
                     TranslatedSids,
                     LsapLookupXForestResolve,
                     MappedCount,
                     &CompletelyUnmappedCount,
                     &WorkList
                     );
    
        if (!NT_SUCCESS(Status)) {
    
            //
            // If no Work List has been built because there are no
            // eligible domains to search, exit, suppressing the error.
    
            if (Status == STATUS_NONE_MAPPED) {
    
                Status = STATUS_SUCCESS;
                goto LookupNamesInTrustedForestFinish;
            }
    
            goto LookupNamesInTrustedForestFinish;
        }
    
        //
        // Start the work, by dispatching one or more worker threads
        // if necessary.
        //
    
        Status = LsapDbLookupDispatchWorkerThreads( WorkList );
    
        if (!NT_SUCCESS(Status)) {
    
            goto LookupNamesInTrustedForestFinish;
        }
    
        //
        // Wait for completion/termination of all items on the Work List.
        //
    
        Status = LsapDbLookupAwaitCompletionWorkList( WorkList );
    
        if (!NT_SUCCESS(Status)) {
    
            goto LookupNamesInTrustedForestFinish;
        }

        if ( !NT_SUCCESS(WorkList->NonFatalStatus) ) {
            //
            // Propogate the error as non fatal
            //
            *NonFatalStatus = WorkList->NonFatalStatus;
        }

    }

LookupNamesInTrustedForestFinish:

    //
    // If a Work List was created, delete it from the Work Queue
    //

    if (WorkList != NULL) {

        Status = LsapDbLookupDeleteWorkList( WorkList );
        WorkList = NULL;
    }

    return Status;
}



NTSTATUS
LsapDbLookupNamesAsDomainNames(
    IN ULONG Flags,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount
    )
/*++

Routine Description:

    This routine tries to match entries in Names to domain names of 
    trusted domains.
    
    There are three kinds of trusted domains:
    
    1) domains we directly trusts (both in and out of forest).  The LSA TDL
    is used for this.
    
    2) domains we trust transitively.  The DS cross-ref is used for this.
    
    3) domains we trust via a forest trust. The LSA TDL is used
    for this.
          
Arguments:

    Flags -- LSAP_LOOKUP_TRUSTED_DOMAIN_DIRECT
             LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE
             LSAP_LOOKUP_TRUSTED_DOMAIN_FOREST_NAMES

    Count -- the number of entries in Names
    
    Names/PrefixNames/SuffixName  -- the requested Names
    
    ReferencedDomains -- the domains of Names
    
    TranslatedSids -- the SIDs and characteristics of Names
    
    MappedCount -- the number of names that have been fully mapped
    
Return Values:

    STATUS_SUCCESS, or resource error otherwise
    
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG    NameIndex;
    BOOLEAN               fTDLLock = FALSE;
    LSA_TRUST_INFORMATION TrustInfo;

    RtlZeroMemory(&TrustInfo, sizeof(TrustInfo));
    for (NameIndex = 0; NameIndex < Count; NameIndex++) {

        PLSAPR_TRUST_INFORMATION_EX TrustInfoEx = NULL;
        LSAPR_TRUST_INFORMATION_EX  TrustInfoBuffer;
        PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY   TrustEntry = NULL;


        RtlZeroMemory(&TrustInfo, sizeof(TrustInfo));
        RtlZeroMemory(&TrustInfoBuffer, sizeof(TrustInfoBuffer));

        if (!LsapDbCompletelyUnmappedSid(&TranslatedSids->Sids[NameIndex])) {
            // Already resolved
            continue;
        }
        
        if (PrefixNames[NameIndex].Length != 0) {
            // Not in isolated name, so can't be just a domain name
            continue;
        }

        if (Flags & LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE) {

            Status = LsapDomainHasTransitiveTrust((PUNICODE_STRING)&SuffixNames[NameIndex],
                                                   NULL,
                                                  &TrustInfo);

            if (NT_SUCCESS(Status)) {
                TrustInfoEx = &TrustInfoBuffer;
                TrustInfoEx->FlatName = *(LSAPR_UNICODE_STRING*)&TrustInfo.Name;
                TrustInfoEx->Sid = TrustInfo.Sid;
            } else if (Status == STATUS_NO_SUCH_DOMAIN) {
                Status = STATUS_SUCCESS;
            } else {
                // This is fatal
                goto Exit;
            }
        }

        if ((NULL == TrustInfoEx)
         && (Flags & LSAP_LOOKUP_TRUSTED_DOMAIN_DIRECT)) {

            Status = LsapDomainHasDirectTrust((PUNICODE_STRING)&SuffixNames[NameIndex],
                                               NULL,
                                               &fTDLLock,
                                               &TrustEntry);

            if (NT_SUCCESS(Status)) {
                TrustInfoEx = &TrustInfoBuffer;
                TrustInfoEx->FlatName = TrustEntry->TrustInfoEx.FlatName;
                TrustInfoEx->Sid = TrustEntry->TrustInfoEx.Sid;
            } else if (Status == STATUS_NO_SUCH_DOMAIN) {
                Status = STATUS_SUCCESS;
            } else {
                // This is fatal
                goto Exit;
            }
        }

        if ((NULL == TrustInfoEx)
         && (Flags & LSAP_LOOKUP_TRUSTED_FOREST_ROOT) ) {

            Status = LsapDomainHasForestTrust((PUNICODE_STRING)&SuffixNames[NameIndex],
                                              NULL,
                                              &fTDLLock,
                                              &TrustEntry);

            if (NT_SUCCESS(Status)) {
                TrustInfoEx = &TrustInfoBuffer;
                TrustInfoEx->FlatName = TrustEntry->TrustInfoEx.FlatName;
                TrustInfoEx->Sid = TrustEntry->TrustInfoEx.Sid;
            } else if (Status == STATUS_NO_SUCH_DOMAIN) {
                Status = STATUS_SUCCESS;
            } else {
                // This is fatal
                goto Exit;
            }
        }

        if (TrustInfoEx) {

            BOOLEAN fStatus;
            ULONG DomainIndex;

            fStatus = LsapDbLookupListReferencedDomains( ReferencedDomains,
                                                         TrustInfoEx->Sid,
                                                         &DomainIndex );
            if ( FALSE == fStatus ) {

                LSA_TRUST_INFORMATION TempTrustInfo;

                //
                // No entry for this domain -- add it
                //
                RtlZeroMemory(&TempTrustInfo, sizeof(TempTrustInfo));

                // Set the sid
                TempTrustInfo.Sid = TrustInfoEx->Sid;
                TempTrustInfo.Name = *(PUNICODE_STRING)&TrustInfoEx->FlatName;

                //
                // Add the entry
                //
                Status = LsapDbLookupAddListReferencedDomains( ReferencedDomains,
                                                               (PLSAPR_TRUST_INFORMATION) &TempTrustInfo,
                                                               &DomainIndex );
                if ( !NT_SUCCESS( Status ) ) {
                    goto Exit;
                }
            }

            // We should now have a domain index
            ASSERT( LSA_UNKNOWN_INDEX != DomainIndex );

            // Set the information in the returned array
            TranslatedSids->Sids[NameIndex].Use = SidTypeDomain;
            TranslatedSids->Sids[NameIndex].DomainIndex = DomainIndex;
            Status = LsapRpcCopySid(NULL,
                                   &TranslatedSids->Sids[NameIndex].Sid,
                                    TrustInfoEx->Sid);
            if ( !NT_SUCCESS( Status ) ) {
                goto Exit;
            }

            //
            // Increment the number of items mapped
            //
            (*MappedCount) += 1;

        }

        if (fTDLLock) {
            LsapDbReleaseLockTrustedDomainList();
            fTDLLock = FALSE;
        }

        if (TrustInfo.Name.Buffer) {
            midl_user_free(TrustInfo.Name.Buffer);
            TrustInfo.Name.Buffer = NULL;
        }
        if (TrustInfo.Sid) {
            midl_user_free(TrustInfo.Sid);
            TrustInfo.Sid = NULL;
        }

        if (!NT_SUCCESS(Status)) {
            goto Exit;
        }
    }

Exit:

    if (fTDLLock) {
        LsapDbReleaseLockTrustedDomainList();
        fTDLLock = FALSE;
    }

    if (TrustInfo.Name.Buffer) {
        midl_user_free(TrustInfo.Name.Buffer);
        TrustInfo.Name.Buffer = NULL;
    }
    if (TrustInfo.Sid) {
        midl_user_free(TrustInfo.Sid);
        TrustInfo.Sid = NULL;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbinstac.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbinstac.c

Abstract:

    LSA Protected Subsystem - Account object Initialization.

    This module sets up account objects to establish the default
    Microsoft policy regarding privilege assignment, system access
    rights (interactive, network, service), and abnormal quotas.

Author:

    Jim Kelly   (JimK)  May 3, 1992.

Environment:

    User mode - Does not depend on Windows.

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"


NTSTATUS
LsapDbInitializeAccount(
    IN PSID AccountSid,
    IN PLSAPR_PRIVILEGE_SET Privileges,
    IN ULONG SystemAccess
    );

OLD_LARGE_INTEGER
ConvertLongToOldLargeInteger(
    ULONG u
    )
/*++

Routine Description:

    Coverts a long to old style large interger


Arguments:

    u - unsigned long.


Return Value:

    converted old style large integer.


--*/
{
    LARGE_INTEGER NewLargeInteger;
    OLD_LARGE_INTEGER OldLargeInteger;

    NewLargeInteger = RtlConvertLongToLargeInteger(u);

    NEW_TO_OLD_LARGE_INTEGER(
        NewLargeInteger,
        OldLargeInteger );

    return( OldLargeInteger );

}




NTSTATUS
LsapDbInstallAccountObjects(
    VOID
    )

/*++

Routine Description:

    This function establishes ACCOUNT objects and initializes them
    to contain the default Microsoft policy.

Arguments:

    None.


Return Value:


--*/

{

    NTSTATUS
        Status = STATUS_SUCCESS;

    ULONG
        i,
        Index,
        SystemAccess;


    SID_IDENTIFIER_AUTHORITY
        WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY,
        NtAuthority = SECURITY_NT_AUTHORITY;

    PSID
        WorldSid = NULL,
        BuiltinAccountSid = NULL ;

    PLSAPR_PRIVILEGE_SET
        Privileges;

    UCHAR
        PrivilegesBuffer[ sizeof(LSAPR_PRIVILEGE_SET) +
                          20 * sizeof(LUID_AND_ATTRIBUTES)];






    //
    // Initialize our privilege set buffer
    // (Room for 100 privileges)
    //

    Privileges = (PLSAPR_PRIVILEGE_SET)(&PrivilegesBuffer);
    Privileges->Control = 0;  //Not used here.
    for (i=0; i<20; i++) {
        Privileges->Privilege[i].Attributes = 0; //Disabled, DisabledByDefault
    }



    //
    // Set up the SIDs we need.
    // All builtin domain sids are the same length.  We'll just create
    // one and change its RID as necessary.
    //


    if (NT_SUCCESS(Status)) {
        Status = RtlAllocateAndInitializeSid(
                     &WorldSidAuthority,
                     1,                      //Sub authority count
                     SECURITY_WORLD_RID,     //Sub authorities (up to 8)
                     0, 0, 0, 0, 0, 0, 0,
                     &WorldSid
                     );
    }

    if (NT_SUCCESS(Status)) {
        Status = RtlAllocateAndInitializeSid(
                     &NtAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0, 0, 0, 0, 0, 0,
                     &BuiltinAccountSid
                     );
    }








    //
    // Now create each account and assign the appropriate set of privileges
    // And logon capabilities.  Some of these are product type-specific.
    //


    if (NT_SUCCESS(Status)) {

        //
        // World account
        //      Logon types: Network
        //      Privileges:
        //          ChangeNotify    (ENABLED)
        //

        Privileges->Privilege[0].Luid =
            ConvertLongToOldLargeInteger(SE_CHANGE_NOTIFY_PRIVILEGE);
        Privileges->Privilege[0].Attributes = SE_PRIVILEGE_ENABLED |
                                              SE_PRIVILEGE_ENABLED_BY_DEFAULT;

        Privileges->PrivilegeCount = 1;

        SystemAccess = SECURITY_ACCESS_NETWORK_LOGON;

        //
        // If a WinNt installation, give WORLD Interactive logon in
        // and SHUTDOWN privilege in addition to Network Logon.
        //

        if (LsapProductType == NtProductWinNt) {

            SystemAccess |= SECURITY_ACCESS_INTERACTIVE_LOGON |
                            SECURITY_ACCESS_REMOTE_INTERACTIVE_LOGON ;

            Privileges->Privilege[1].Luid =
                ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);
            Privileges->Privilege[1].Attributes =
                SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT;
            Privileges->PrivilegeCount = 2;

        }

        Status = LsapDbInitializeAccount(WorldSid, Privileges, SystemAccess);

        Privileges->Privilege[0].Attributes = 0;
    }

    if (NT_SUCCESS(Status)) {

        //
        // Admin Alias account
        //      Logon types: Interactive, Network
        //      Privileges:
        //          Security
        //          Backup
        //          Restore
        //          SetTime
        //          Shutdown
        //          RemoteShutdown
        //          Debug
        //          TakeOwnership
        //          SystemEnvironment
        //          SystemProfile
        //          SingleProcessProfile
        //          LoadDriver
        //          CreatePagefile
        //          IncreaseQuota
        //


        SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON |
                       SECURITY_ACCESS_NETWORK_LOGON;
        Index = 0;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_SECURITY_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_BACKUP_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_RESTORE_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_SYSTEMTIME_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_REMOTE_SHUTDOWN_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_TAKE_OWNERSHIP_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_DEBUG_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_SYSTEM_ENVIRONMENT_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_SYSTEM_PROFILE_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_PROF_SINGLE_PROCESS_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_INC_BASE_PRIORITY_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_LOAD_DRIVER_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_CREATE_PAGEFILE_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_INCREASE_QUOTA_PRIVILEGE);
        Index++;

        // to add another privilege, and add another group of lines ^^^

        Privileges->PrivilegeCount    = Index;

        (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_ADMINS;
        Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);
        if (!NT_SUCCESS(Status)) {
            KdPrint(("LSA DB INSTALL: Creation of Administrators privileged account failed.\n"
                     "                Status: 0x%lx\n", Status));
        }

    }

    if (NT_SUCCESS(Status)) {

        //
        // Backup Operators Alias account
        //      Logon types: Interactive
        //      Privileges:
        //          Backup
        //          Restore
        //          Shutdown
        //


        SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON;

        Privileges->Privilege[0].Luid =
            ConvertLongToOldLargeInteger(SE_BACKUP_PRIVILEGE);

        Privileges->Privilege[1].Luid =
            ConvertLongToOldLargeInteger(SE_RESTORE_PRIVILEGE);

        Privileges->Privilege[2].Luid =
            ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);

        // to add another privilege, vvvv increment this, and add a line ^^^

        Privileges->PrivilegeCount    = 3;

        (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_BACKUP_OPS;
        Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);

    }

    if (LsapProductType == NtProductLanManNt) {

        if (NT_SUCCESS(Status)) {

            //
            // System Operators Alias account
            //      Logon types: Interactive
            //      Privileges:
            //          Backup
            //          Restore
            //          SetTime
            //          Shutdown
            //          RemoteShutdown
            //


            SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON;

            Privileges->Privilege[0].Luid =
                ConvertLongToOldLargeInteger(SE_BACKUP_PRIVILEGE);

            Privileges->Privilege[1].Luid =
                ConvertLongToOldLargeInteger(SE_RESTORE_PRIVILEGE);

            Privileges->Privilege[2].Luid =
                ConvertLongToOldLargeInteger(SE_SYSTEMTIME_PRIVILEGE);

            Privileges->Privilege[3].Luid =
                ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);

            Privileges->Privilege[4].Luid =
                ConvertLongToOldLargeInteger(SE_REMOTE_SHUTDOWN_PRIVILEGE);

            // to add another privilege, vvvv increment this, and add a line ^^^

            Privileges->PrivilegeCount    = 5;

            (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_SYSTEM_OPS;
            Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);

        }

        if (NT_SUCCESS(Status)) {

            //
            // Account Operators Alias account
            //      Logon types: Interactive
            //      Privileges:
            //          Shutdown
            //


            SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON;

            Privileges->Privilege[0].Luid =
                ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);

            // to add another privilege, vvvv increment this, and add a line ^^^

            Privileges->PrivilegeCount    = 1;

            (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_ACCOUNT_OPS;
            Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);

        }

        if (NT_SUCCESS(Status)) {

            //
            // Print Operators Alias account
            //      Logon types: Interactive
            //      Privileges:
            //          Shutdown
            //


            SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON;

            Privileges->Privilege[0].Luid =
                ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);

            // to add another privilege, vvvv increment this, and add a line ^^^

            Privileges->PrivilegeCount    = 1;

            (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_PRINT_OPS;
            Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);

        }



    } else {


        if (NT_SUCCESS(Status)) {

            //
            // Power Users Alias account
            //      Logon types: Interactive, Network
            //      Privileges:
            //          Shutdown
            //          Set System Time
            //          SystemProfile
            //          SingleProcessProfile
            //          Debug (for developer installs ONLY!).
            //


            SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON |
                           SECURITY_ACCESS_NETWORK_LOGON |
                           SECURITY_ACCESS_REMOTE_INTERACTIVE_LOGON ;

            Privileges->Privilege[0].Luid =
                ConvertLongToOldLargeInteger(SE_SYSTEMTIME_PRIVILEGE);

            Privileges->Privilege[1].Luid =
                ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);

            Privileges->Privilege[2].Luid =
                ConvertLongToOldLargeInteger(SE_REMOTE_SHUTDOWN_PRIVILEGE);

            Privileges->Privilege[3].Luid =
                ConvertLongToOldLargeInteger(SE_SYSTEM_PROFILE_PRIVILEGE);

            Privileges->Privilege[3].Luid =
                ConvertLongToOldLargeInteger(SE_PROF_SINGLE_PROCESS_PRIVILEGE);

            Privileges->Privilege[4].Luid =
                ConvertLongToOldLargeInteger(SE_INC_BASE_PRIORITY_PRIVILEGE);

            // to add another privilege, vvvv increment this, and add a line ^^^

            Privileges->PrivilegeCount    = 5;


            //
            // Add privileges assigned for developer install
            //
            if (LsapSetupWasRun != TRUE) {

                Privileges->Privilege[Privileges->PrivilegeCount].Luid =
                    ConvertLongToOldLargeInteger(SE_DEBUG_PRIVILEGE);
                    Privileges->PrivilegeCount++;
            }



            (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_POWER_USERS;
            Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);

        }

        if (NT_SUCCESS(Status)) {

            //
            // Users Alias account
            //      Logon types: Interactive
            //      Privileges:
            //          Shutdown
            //


            SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON;

            Privileges->Privilege[0].Luid =
                ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);

            // to add another privilege, vvvv increment this, and add a line ^^^

            Privileges->PrivilegeCount    = 1;

            (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_USERS;
            Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);

        }


        if (NT_SUCCESS(Status)) {

            //
            // Guests Alias account
            //      Logon types: Interactive
            //      Privileges:
            //          None
            //


            SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON;

            // to add another privilege, vvvv increment this, and add a line ^^^

            Privileges->PrivilegeCount    = 0;

            (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_GUESTS;
            Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);

        }


    }






    //
    // Free up SID buffers
    //

    RtlFreeSid( WorldSid );
    RtlFreeSid( BuiltinAccountSid );




    return(Status);


}




NTSTATUS
LsapDbInitializeAccount(
    IN PSID AccountSid,
    IN PLSAPR_PRIVILEGE_SET Privileges,
    IN ULONG SystemAccess
    )

/*++

Routine Description:

    This function creates a single ACCOUNT object and assigns it the
    privileges and system access specified.

Arguments:

    AccountSid - The SID of the account to create.

    Privileges - The privileges, if any, to assign to the account.

    SystemAccess - The logon capabilities, if any, to assign to the account.


Return Value:


--*/

{

    NTSTATUS
        Status = STATUS_SUCCESS,
        LocalStatus;

    LSAPR_HANDLE
        AccountHandle = NULL;

    if ((Privileges->PrivilegeCount == 0) &&
        (NT_SUCCESS(Status) && SystemAccess == 0) ) {
        return(STATUS_SUCCESS);
    }


    Status = LsarCreateAccount( LsapDbHandle, AccountSid, 0, &AccountHandle);

    if (NT_SUCCESS(Status)) {

        if (Privileges->PrivilegeCount > 0) {
            Status = LsarAddPrivilegesToAccount( AccountHandle, Privileges );
        }

        if (NT_SUCCESS(Status) && SystemAccess != 0) {
            Status = LsarSetSystemAccessAccount( AccountHandle, SystemAccess);
        }

        LocalStatus = LsapCloseHandle( &AccountHandle, Status );
    }

    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbftrust.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dbftrust.cxx

Abstract:

    LSA Forest Trust Manager - Routines for managing forest trust information

    These routines manipulate information associated with the forest trust
    attribute of trusted domain objects

--*/

extern "C" {
#include <lsapch2.h>
#include "dbp.h"
#include <ntdsapip.h>
}
#include <smbgtpt.h>
#include <wmistr.h>
#include <evntrace.h>
#include <lsawmi.h>
#include "dbftrust.h"
#include <dnsapi.h>
#include <ftnfoctx.h>
#include <malloc.h>
#include <alloca.h>

//
// Blob version # (in case we want to overhaul the format entirely at a later time
//

#define LSAP_FOREST_TRUST_BLOB_VERSION_1    (( ULONG ) 1)

#define LSAP_FOREST_TRUST_BLOB_VERSION      LSAP_FOREST_TRUST_BLOB_VERSION_1

//
// Forest trust cache debug-only statistics
//

#if DBG

DWORD FTCache::sm_TdoEntries = 0;
DWORD FTCache::sm_TlnEntries = 0;
DWORD FTCache::sm_DomainInfoEntries = 0;
DWORD FTCache::sm_BinaryEntries = 0;
DWORD FTCache::sm_TlnKeys = 0;
DWORD FTCache::sm_SidKeys = 0;
DWORD FTCache::sm_DnsNameKeys = 0;
DWORD FTCache::sm_NetbiosNameKeys = 0;

#endif

//
// Notification handle for code running on global catalog
//

static DWORD NotificationHandle = NULL;


///////////////////////////////////////////////////////////////////////////////
//
// Helper routines
//
///////////////////////////////////////////////////////////////////////////////



template<class T>
BOOLEAN
XOR( const T& t1, const T& t2 )
{
    return ( !t1 != !t2 );
}



USHORT
DnsNameComponents(
    IN const UNICODE_STRING * const Name
    )
/*++

Routine Description:

    Counts the number of components of a DNS name

Arguments:

    Name            something of the form "NY.acme.com"

Returns:

    Number of components (at least 1)

--*/
{
    USHORT Result = 1;
    USHORT Index;

    ASSERT( Name );
    ASSERT( Name->Length > 0 );
    ASSERT( Name->Buffer != NULL );

    for ( Index = 0 ; Index <= Name->Length ; Index += sizeof( WCHAR )) {

        if ( Name->Buffer[Index/2] == L'.' ) {

            Result += 1;
        }
    }

    return Result;
}



void
NextDnsComponent(
    IN UNICODE_STRING * Name
    )
/*++

Routine Description:

    Changes the given name to point to the next component of a DNS name.
    The Buffer component of the name must NOT be dynamically allocated,
    since this code will change the Buffer pointer.
    The name must have at least two components, else an assert will fire.

    "acme.com" is valid
    "acmecom" or "" are both invalid inputs

Arguments:

    Name         name to modify

Returns:

    Nothing

--*/
{
    USHORT Index;
    BOOLEAN Found = FALSE;

    ASSERT( Name );
    ASSERT( Name->Length > 0 );
    ASSERT( Name->Buffer != NULL );

    for ( Index = 0 ; Index < Name->Length ; Index += sizeof( WCHAR )) {

        if ( Name->Buffer[Index/2] == L'.' ) {

            Found = TRUE;
            Index += sizeof( WCHAR );
            break;
        }
    }

    //
    // Somebody else should take care of passing valid data to this routine
    //

    ASSERT( !Found || Index < Name->Length );

    Name->Buffer += Index / sizeof( WCHAR );
    Name->Length -= Index;
    Name->MaximumLength -= Index;

    ASSERT( Found || Name->Length == 0 );

    return;
}



BOOLEAN
IsSubordinate(
    IN const UNICODE_STRING * Subordinate,
    IN const UNICODE_STRING * Superior
    )
/*++

Routine Description:

    Determines if Subordinate string is indeed subordinate to Superior
    For example, "NY.acme.com" is subordinate to "acme.com", but
    "NY.acme.com" is NOT subordinate to "me.com" or "NY.acme.com"

Arguments:

    Subordinate    name to test for subordinate status

    Superior       name to test for superior status

Returns:

    TRUE is Subordinate is subordinate to Superior

    FALSE otherwise

--*/
{
    USHORT SubIndex, SupIndex;
    UNICODE_STRING Temp;

    ASSERT( Subordinate && Subordinate->Buffer );
    ASSERT( Superior && Superior->Buffer );

    ASSERT( LsapValidateLsaUnicodeString( Subordinate ));
    ASSERT( LsapValidateLsaUnicodeString( Superior ));

    //
    // A subordinate name must be longer than the superior name
    //

    if ( Subordinate->Length <= Superior->Length ) {

        return FALSE;
    }

    //
    // Subordinate name must be separated from the superior part by a period
    //

    if ( Subordinate->Buffer[( Subordinate->Length - Superior->Length ) / sizeof( WCHAR ) - 1] != L'.' ) {

        return FALSE;
    }

    //
    // The last part of two names must match exactly (but not case sensitively)
    //

    Temp = *Subordinate;
    Temp.Buffer += ( Subordinate->Length - Superior->Length ) / sizeof( WCHAR );
    Temp.Length = Superior->Length;
    Temp.MaximumLength = Temp.Length;

    if ( !RtlEqualUnicodeString( &Temp, Superior, TRUE )) {

        return FALSE;
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//
// Memory management code
//
///////////////////////////////////////////////////////////////////////////////

#define FtcAllocate( size ) MIDL_user_allocate( size )
#define FtcFree( buffer )   MIDL_user_free( buffer )



PVOID
FtcReallocate(
    IN OPTIONAL void * OldPointer,
    IN size_t OldByteCount,
    IN size_t NewByteCount
    )
{
    void * Result = MIDL_user_allocate( NewByteCount );

    if ( Result == NULL ) {

        return NULL;
    }

    if ( OldPointer != NULL ) {

        RtlCopyMemory( Result, OldPointer, OldByteCount );
        MIDL_user_free( OldPointer );
    }

    return Result;
}



BOOLEAN
FtcCopyUnicodeString(
    IN UNICODE_STRING * Destination,
    IN UNICODE_STRING * Source,
    IN PWSTR Buffer = NULL
    )
/*++

Routine Description:

    Copies the contents of one Unicode string to another

Arguments:

    Destination        destination string

    Source             source string

    Buffer             (optional) address of the buffer for destination data

Returns:

    FALSE if operation failed (out of memory)
    TRUE otherwise

--*/
{
    ASSERT( Destination );
    ASSERT( Source && LsapValidateLsaUnicodeString( Source ));

    if ( Buffer != NULL && Source->Length > 0 ) {

        Destination->Buffer = Buffer;

    } else if ( Source->Length > 0 ) {

        Destination->Buffer = ( PWSTR )FtcAllocate( Source->Length + sizeof( WCHAR ));

        if ( Destination->Buffer == NULL ) {

            return FALSE;
        }

    } else {

        Destination->Buffer = NULL;
    }

    Destination->MaximumLength = Source->Length + sizeof( WCHAR );

    RtlCopyUnicodeString(
        Destination,
        Source
        );

    return TRUE;
}



void
LsapFreeForestTrustInfo(
    IN LSA_FOREST_TRUST_INFORMATION * ForestTrustInfo
    )
/*++

Routine Description:

    Deallocates memory taken up by the ForestTrustInfo structure

Arguments:

    ForestTrustInfo     structure to free

Returns:

    Nothing

--*/
{
    ULONG i;

    if ( ForestTrustInfo == NULL ) {

        return;
    }

    i = ForestTrustInfo->RecordCount;

    while ( i > 0 ) {

        LSA_FOREST_TRUST_RECORD * Record = ForestTrustInfo->Entries[--i];

        if ( Record == NULL ) {

            continue;
        }

        switch ( Record->ForestTrustType ) {

        case ForestTrustTopLevelName:
        case ForestTrustTopLevelNameEx:

            FtcFree( Record->ForestTrustData.TopLevelName.Buffer );
            break;

        case ForestTrustDomainInfo:

            FtcFree( Record->ForestTrustData.DomainInfo.Sid );
            FtcFree( Record->ForestTrustData.DomainInfo.DnsName.Buffer );
            FtcFree( Record->ForestTrustData.DomainInfo.NetbiosName.Buffer );
            break;

        default:

            FtcFree( Record->ForestTrustData.Data.Buffer );
            break;
        }

        FtcFree( Record );
    }

    FtcFree( ForestTrustInfo->Entries );

    ForestTrustInfo->RecordCount = 0;
    ForestTrustInfo->Entries = NULL;

    return;
}



void
LsapFreeCollisionInfo(
    IN OUT PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo
    )
/*++

Routine Description:

    Deallocates memory taken up by the CollisionInfo structure

Arguments:

    CollisionInfo       structure to free

Returns:

    Nothing

--*/
{
    ASSERT( CollisionInfo );

    if ( *CollisionInfo == NULL ) {

        return;
    }

    ULONG i = (*CollisionInfo)->RecordCount;

    while ( i > 0 ) {

        LSA_FOREST_TRUST_COLLISION_RECORD * Record = (*CollisionInfo)->Entries[--i];

        if ( Record == NULL ) {

            continue;
        }

        switch ( Record->Type ) {

        case CollisionTdo:
            FtcFree( Record->Name.Buffer );
            break;

        default:
            ASSERT( FALSE ); // NYI
        }

        FtcFree( Record );
    }

    FtcFree( (*CollisionInfo)->Entries );
    FtcFree( *CollisionInfo );
    *CollisionInfo = NULL;

    return;
}



PVOID
NTAPI
FtcAllocateRoutine(
    struct _RTL_AVL_TABLE * Table,
    CLONG ByteSize
    )
{
    UNREFERENCED_PARAMETER( Table );

    return RtlAllocateHeap( RtlProcessHeap(), 0, ByteSize );
}



void
NTAPI
FtcFreeRoutine(
    struct _RTL_AVL_TABLE * Table,
    PVOID Buffer
    )
{
    UNREFERENCED_PARAMETER( Table );

    RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
}


///////////////////////////////////////////////////////////////////////////////
//
// Comparison and matching routines
//
///////////////////////////////////////////////////////////////////////////////



template<class T>
inline
RTL_GENERIC_COMPARE_RESULTS
FtcGenericCompare(
    IN const T& a,
    IN const T& b
    )
/*++

Routine Description:

    Compares two values and returns one of

        GenericEqual
        GenericGreaterThan
        GenericLessThan

Arguments:

    a, b   numbers to compare

--*/
{
    if ( a < b ) {

        return GenericLessThan;

    } else if ( a > b ) {

        return GenericGreaterThan;

    } else {

        return GenericEqual;
    }
}



inline
RTL_GENERIC_COMPARE_RESULTS
FtcGenericCompareMemory(
    IN BYTE * Buffer1,
    IN BYTE * Buffer2,
    IN ULONG Length
    )
/*++

Routine Description:

    Compares two buffers and returns one of

        GenericEqual
        GenericGreaterThan
        GenericLessThan

Arguments:

    Buffer1, Buffer2   buffers to compare
    Length             length of buffers

--*/
{
    RTL_GENERIC_COMPARE_RESULTS Result = GenericEqual;

    for ( ULONG i = 0 ; i < Length ; i++ ) {

        const BYTE& b1 = Buffer1[i];
        const BYTE& b2 = Buffer2[i];

        if ( b1 == b2 ) {

            continue;

        } else if ( b1 < b2 ) {

            Result = GenericLessThan;

        } else {

            Result = GenericGreaterThan;
        }

        break;
    }

    return Result;
}



RTL_GENERIC_COMPARE_RESULTS
NTAPI
SidCompareRoutine(
    struct _RTL_AVL_TABLE * Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )
/*++

Routine description:

    SID comparison callback for AVL tree management

Arguments:

    Table              table for which this comparison takes place (ignored)

    FirstStruct, SecondStruct   points to SID*'s to compare

Returns:

    equal/greater-than/less-than

NOTE:

    1. the code relies on the fact that SID* is the first entry inside the
       SID_KEY structure.  this way, a pointer to a SID* can be passed
       to AVL management routines (Lookup/Insert/Delete)

    2. this is the same code as RtlEqualSid, except it returns
       RTL_GENERIC_COMPARE_RESULTS

--*/
{
    SID *Sid1, *Sid2;
    RTL_GENERIC_COMPARE_RESULTS Result;
    PSID_IDENTIFIER_AUTHORITY Authority1, Authority2;
    DWORD DomainSubAuthCount1, DomainSubAuthCount2;
    ULONG i;

    UNREFERENCED_PARAMETER( Table );

    ASSERT( FirstStruct );
    ASSERT( SecondStruct );

    Sid1 = *( PISID * )FirstStruct;
    Sid2 = *( PISID * )SecondStruct;

    ASSERT( Sid1 && RtlValidSid( Sid1 ));
    ASSERT( Sid2 && RtlValidSid( Sid2 ));

    if ( GenericEqual != ( Result = FtcGenericCompare<UCHAR>(
                                        Sid1->Revision,
                                        Sid2->Revision ))) {

        return Result;

    } else if ( GenericEqual != ( Result = FtcGenericCompare<UCHAR>(
                                               *RtlSubAuthorityCountSid( Sid1 ),
                                               *RtlSubAuthorityCountSid( Sid2 )))) {

        return Result;

    } else {

        return FtcGenericCompareMemory(
                   ( BYTE * )Sid1,
                   ( BYTE * )Sid2,
                   RtlLengthSid( Sid1 )
                   );
    }
}



RTL_GENERIC_COMPARE_RESULTS
NTAPI
UnicodeStringCompareRoutine(
    struct _RTL_AVL_TABLE * Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )
/*++

Routine Description:

    Unicode string comparison routine for AVL tables

Arguments:

    Table           Table used in comparison (ignored)

    FirstStruct     Pointer to first unicode string

    SecondStruct    Pointer to second unicode string

Returns:

    equal/greater-than/less-than

--*/
{
    INT Result;
    UNICODE_STRING *String1, *String2;

    UNREFERENCED_PARAMETER( Table );

    ASSERT( FirstStruct );
    ASSERT( SecondStruct );

    String1 = ( UNICODE_STRING * )FirstStruct;
    String2 = ( UNICODE_STRING * )SecondStruct;

    Result = RtlCompareUnicodeString(
                 String1,
                 String2,
                 TRUE
                 );

    if ( Result < 0 ) {

        return GenericLessThan;

    } else if ( Result > 0 ) {

        return GenericGreaterThan;

    } else {

        return GenericEqual;
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// Global forest trust cache object
//
///////////////////////////////////////////////////////////////////////////////

FTCache * g_FTCache = NULL;


///////////////////////////////////////////////////////////////////////////////
//
// Validation code
//
///////////////////////////////////////////////////////////////////////////////



BOOLEAN
LsapValidateForestTrustInfo(
    IN LSA_FOREST_TRUST_INFORMATION * ForestTrustInfo
    )
/*++

Routine Description:

    Runs a validation algorithm on the ForestTrustInfo structure passed in.
    Strips trailing periods from names where appropriate.

Arguments:

    ForestTrustInfo     data to validate

Returns:

    TRUE if ForestTrustInfo checks out, FALSE otherwise

--*/
{
    ULONG i;

    if ( ForestTrustInfo == NULL ) {

        return TRUE;
    }

    if ( ForestTrustInfo->RecordCount > 0 &&
         ForestTrustInfo->Entries == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "LsapValidateForestTrustInfo: ForestTrustInfo->Entries is NULL (%s:%d)\n", __FILE__, __LINE__ ));
        return FALSE;
    }

    for ( i = 0 ; i < ForestTrustInfo->RecordCount ; i++ ) {

        LSA_FOREST_TRUST_RECORD * Record;

        Record = ForestTrustInfo->Entries[i];

        if ( Record == NULL ) {

            LsapDsDebugOut(( DEB_FTINFO, "LsapValidateForestTrustInfo: Record %d is invalid (%s:%d)\n", i, __FILE__, __LINE__ ));
            return FALSE;
        }

        switch ( Record->ForestTrustType ) {

        case ForestTrustTopLevelName:
        case ForestTrustTopLevelNameEx: {

            BOOLEAN Valid;

            if ( !LsapValidateLsaUnicodeString( &Record->ForestTrustData.TopLevelName )) {

                LsapDsDebugOut(( DEB_FTINFO, "LsapValidateForestTrustInfo: Record %d is invalid (%s:%d)\n", i, __FILE__, __LINE__ ));
                return FALSE;
            }

            //
            // DNS names have additional tests applied to them
            //

            LsapValidateDnsName(( UNICODE_STRING * )&Record->ForestTrustData.TopLevelName, &Valid );

            if ( !Valid ) {

                LsapDsDebugOut(( DEB_FTINFO, "LsapValidateForestTrustInfo: Record %d is invalid (%s:%d)\n", i, __FILE__, __LINE__ ));
                return FALSE;
            }

            //
            // DNS names must have their trailing period stripped. Now is a good time
            //

            LsapRemoveTrailingDot(( UNICODE_STRING * )&Record->ForestTrustData.TopLevelName, FALSE );

            //
            // Exclusion entries must have more than one DNS name component
            // (e.g. "acme.com" is valid but "acme" is not)
            //

            if ( Record->ForestTrustType == ForestTrustTopLevelNameEx &&
                 DnsNameComponents( &Record->ForestTrustData.TopLevelName ) < 2 ) {

                LsapDsDebugOut(( DEB_FTINFO, "LsapValidateForestTrustInfo: Record %d is invalid (%s:%d)\n", i, __FILE__, __LINE__ ));
                return FALSE;
            }

            break;
        }

        case ForestTrustDomainInfo: {

            //
            // ISSUE-2000/07/28-markpu
            // are NULL SIDs allowed?
            //

            BYTE DomainSid[1024];
            DWORD cbSid = sizeof( DomainSid );
            BOOLEAN Valid;

            if ( !RtlValidSid(( SID * )Record->ForestTrustData.DomainInfo.Sid ) ||
                 !LsapValidateLsaUnicodeString( &Record->ForestTrustData.DomainInfo.DnsName ) ||
                 !LsapValidateLsaUnicodeString( &Record->ForestTrustData.DomainInfo.NetbiosName )) {

                LsapDsDebugOut(( DEB_FTINFO, "LsapValidateForestTrustInfo: Record %d is invalid (%s:%d)\n", i, __FILE__, __LINE__ ));
                return FALSE;
            }

            //
            // Prevent suspiciously long SIDs and NetbiosNames
            //

            if ( RtlLengthSid(( SID * )Record->ForestTrustData.DomainInfo.Sid ) > 1024 ) {

                LsapDsDebugOut(( DEB_FTINFO, "LsapValidateForestTrustInfo: Record %d is invalid (%s:%d)\n", i, __FILE__, __LINE__ ));
                return FALSE;
            }

            if ( Record->ForestTrustData.DomainInfo.NetbiosName.Length > DNS_MAX_NAME_LENGTH * sizeof( WCHAR )) {

                LsapDsDebugOut(( DEB_FTINFO, "LsapValidateForestTrustInfo: Record %d is invalid (%s:%d)\n", i, __FILE__, __LINE__ ));
                return FALSE;
            }

            //
            // SIDs passed in should be valid domain SIDs
            //

            if ( FALSE == GetWindowsAccountDomainSid(
                              ( SID * )Record->ForestTrustData.DomainInfo.Sid,
                              ( PSID )DomainSid,
                              &cbSid )) {

                ASSERT( GetLastError() != ERROR_INVALID_SID ); // RtlValidSid check already performed

                LsapDsDebugOut(( DEB_FTINFO, "LsapValidateForestTrustInfo: Record %d is invalid, Error 0x%lx (%s:%d)\n", i, GetLastError(), __FILE__, __LINE__ ));
                return FALSE;

            } else {

                //
                // For domain SIDs, GetWindowsAccountDomainSid returns a SID equal to the one passed in.
                // If the two SIDs are not equal, the SID passed in is not a true domain SID
                //

                if ( !RtlEqualSid(
                          ( PSID )DomainSid,
                          ( PSID )Record->ForestTrustData.DomainInfo.Sid )) {

                    LsapDsDebugOut(( DEB_FTINFO, "LsapValidateForestTrustInfo: Record %d is invalid (%s:%d)\n", i, __FILE__, __LINE__ ));
                    return FALSE;
                }
            }

            //
            // DNS and NetBIOS names have additional tests applied to them
            //

            LsapValidateNetbiosName(( UNICODE_STRING * )&Record->ForestTrustData.DomainInfo.NetbiosName, &Valid );

            if ( !Valid ) {

                LsapDsDebugOut(( DEB_FTINFO, "LsapValidateForestTrustInfo: Record %d is invalid (%s:%d)\n", i, __FILE__, __LINE__ ));
                return FALSE;
            }

            LsapValidateDnsName(( UNICODE_STRING * )&Record->ForestTrustData.DomainInfo.DnsName, &Valid );

            if ( !Valid ) {

                LsapDsDebugOut(( DEB_FTINFO, "LsapValidateForestTrustInfo: Record %d is invalid (%s:%d)\n", i, __FILE__, __LINE__ ));
                return FALSE;
            }

            //
            // DNS names must have their trailing period stripped. Now is a good time
            //

            LsapRemoveTrailingDot(( UNICODE_STRING * )&Record->ForestTrustData.DomainInfo.DnsName, FALSE );

            break;
        }

        default:

            //
            // ISSUE-2000/07/21-markpu
            // add some binary blob checking
            //

            break;
        }
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//
// C Wrappers around the FTCache class
//
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
LsapForestTrustCacheInitialize()
{
    NTSTATUS Status;

    LsapDsDebugOut(( DEB_FTINFO, "Forest trust cache being initialized\n" ));

    ASSERT( g_FTCache == NULL );

    g_FTCache = new FTCache;

    if ( g_FTCache == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapForestTrustCacheInitialize (%s:%d)\n", __FILE__, __LINE__ ));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = g_FTCache->Initialize();

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInitialize: FTCache::Initialize returned 0x%x\n", Status ));
        delete g_FTCache;
        g_FTCache = NULL;
    }

    return Status;
}



inline void
LsapForestTrustCacheSetValid()
{
    LsapDsDebugOut(( DEB_FTINFO, "Forest trust cache set \"valid\"\n" ));

    ASSERT( LsapDbIsLockedTrustedDomainList());

    g_FTCache->SetValid();
}



inline void
LsapForestTrustCacheSetInvalid()
{
    LsapDsDebugOut(( DEB_FTINFO, "Forest trust cache set \"invalid\"\n" ));

    ASSERT( LsapDbIsLockedTrustedDomainList());

    g_FTCache->SetInvalid();
}



inline BOOLEAN
LsapForestTrustCacheIsValid()
{
    ASSERT( LsapDbIsLockedTrustedDomainList());

    return g_FTCache->IsValid();
}



NTSTATUS
LsapForestTrustCacheInsert(
    IN UNICODE_STRING * TrustedDomainName,
    IN OPTIONAL PSID TrustedDomainSid,
    IN LSA_FOREST_TRUST_INFORMATION * ForestTrustInfo,
    IN BOOLEAN LocalForestEntry
    )
/*++

Routine Description:

    Inserts forest trust information for particular trusted domain
    name into the cache.
    This routine gets called as a result of

      * the system preloading the cache or
      * replication traffic

    As a result, the data coming in can not be assumed to be collision-free.
    Collisions are resolved, and on the root domain PDC, the resulting forest
    trust data is written back out to the DS.

Arguments:

    TrustedDomainName         name of the TDO

    TrustedDomainSid          SID of the TDO (can be NULL)

    ForestTrustInfo           forest trust information

    LocalForestEntry          does this data correspond to the local forest?

Returns:

    STATUS_SUCCESS                   success

    STATUS_INTERNAL_ERROR

    STATUS_INSUFFICIENT_RESOURCES    out of memory

    STATUS_INVALID_PARAMETER         data passed in is inconsistent

--*/
{
    NTSTATUS Status;
    FTCache::TDO_ENTRY TdoEntryOld = {0};
    FTCache::TDO_ENTRY * TdoEntryNew = NULL;
    FTCache::CONFLICT_PAIR * ConflictPairs = NULL;
    ULONG ConflictPairsTotal = 0;
    BOOLEAN ObjectReferenced = FALSE;
    DOMAIN_SERVER_ROLE ServerRole = DomainServerRoleBackup;

    ASSERT( LsapDbIsLockedTrustedDomainList());

#ifdef XFOREST_CIRCUMVENT

    //
    // If the backdoor is open for cross-forest support without
    // all domain controllers being upgraded to Whistler,
    // and the switch is off, then just claim that the insert operation
    // was successful.  This way the cache will remain empty
    // and all match calls will fail with STATUS_NOT_FOUND
    //

    if( !LsapDbNoMoreWin2K()) {

        LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsert: X-forest circumvent short-cutting processing\n" ));
        return STATUS_SUCCESS;
    }

#endif

    LsarpReturnCheckSetup();
    LsapEnterFunc( "LsapForestTrustCacheInsert" );
    LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsert called\n" ));

    if ( !LsapValidateForestTrustInfo( ForestTrustInfo )) {

        LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustCacheInsert (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    Status = g_FTCache->Insert(
                 TrustedDomainName,
                 TrustedDomainSid,
                 ForestTrustInfo,
                 LocalForestEntry,
                 &TdoEntryOld,
                 &TdoEntryNew,
                 &ConflictPairs,
                 &ConflictPairsTotal
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsert: FTCache::Insert returned 0x%x\n", Status ));
        goto Error;
    }

    if ( ConflictPairs ) {

        g_FTCache->ReconcileConflictPairs(
            NULL, // let the winner be determined algorithmically
            ConflictPairs,
            ConflictPairsTotal
            );
    }

    //
    // If we are in the root domain, there is a chance
    // that this DC is a PDC and thus reconciled changes
    // need to be written out
    //

    if ( ConflictPairs &&          // conflicts were detected
         LsapDbDcInRootDomain() && // this is a root domain DC
         LsapSamOpened ) {         // SAM is started (a must to call SamI APIs)

        //
        // Query the server role, PDC/BDC
        //

        ASSERT( LsapAccountDomainHandle );

        Status = SamIQueryServerRole(
                    LsapAccountDomainHandle,
                    &ServerRole
                    );

        if ( !NT_SUCCESS(Status)) {

            LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsert: SamIQueryServerRole returned 0x%x\n", Status ));
            goto Error;
        }

        if ( ServerRole == DomainServerRolePrimary ) {

            ULONG TdoNamesCount = 0;
            PUNICODE_STRING * TdoNames = NULL;
            ULONG i, j;

            for ( i = 0 ; i < ConflictPairsTotal ; i++ ) {

                PUNICODE_STRING String1 = NULL;
                PUNICODE_STRING String2 = NULL;

                //
                // Get trusted domain names corresponding to conflicting entries
                //

                switch ( ConflictPairs[i].EntryType1 ) {

                case ForestTrustTopLevelName:
                    String1 = &ConflictPairs[i].TlnEntry1->TdoEntry->TrustedDomainName;
                    break;

                case ForestTrustDomainInfo:
                    String1 = &ConflictPairs[i].DomainInfoEntry1->TdoEntry->TrustedDomainName;
                    break;
                }

                switch ( ConflictPairs[i].EntryType2 ) {

                case ForestTrustTopLevelName:
                    String2 = &ConflictPairs[i].TlnEntry2->TdoEntry->TrustedDomainName;
                    break;

                case ForestTrustDomainInfo:
                    String2 = &ConflictPairs[i].DomainInfoEntry2->TdoEntry->TrustedDomainName;
                    break;
                }

                //
                // No point continuing if neither name can be found
                //

                if ( !String1 && !String2 ) {

                    continue;
                }

                //
                // Append the names to the array, uniquely
                //

                for ( j = 0 ; j < TdoNamesCount ; j++ ) {

                    if ( String1 && RtlEqualUnicodeString(
                                        String1,
                                        TdoNames[j],
                                        TRUE )) {

                        break;
                    }
                }

                if ( j == TdoNamesCount ) {

                    PUNICODE_STRING * TdoNamesT;

                    TdoNamesT = ( TdoNames ?
                                    ( PUNICODE_STRING * )LocalReAlloc(
                                        TdoNames,
                                        ( TdoNamesCount + 1 ) * sizeof( PUNICODE_STRING ),
                                        0 ) :
                                    ( PUNICODE_STRING * )LocalAlloc(
                                        0,
                                        sizeof( PUNICODE_STRING )));

                    if ( TdoNamesT == NULL ) {

                        if ( TdoNames ) {

                            LocalFree( TdoNames );
                        }

                        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapForestTrustCacheInsert (%s:%d)\n", __FILE__, __LINE__ ));
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Error;
                    }

                    TdoNames = TdoNamesT;
                    TdoNames[TdoNamesCount] = String1;
                    TdoNamesCount += 1;
                }

                for ( j = 0 ; j < TdoNamesCount ; j++ ) {

                    if ( String2 && RtlEqualUnicodeString(
                                        String2,
                                        TdoNames[j],
                                        TRUE )) {

                        break;
                    }
                }

                if ( j == TdoNamesCount ) {

                    PUNICODE_STRING * TdoNamesT;

                    TdoNamesT = ( TdoNames ?
                                    ( PUNICODE_STRING * )LocalReAlloc(
                                        TdoNames,
                                        ( TdoNamesCount + 1 ) * sizeof( PUNICODE_STRING ),
                                        0 ) :
                                    ( PUNICODE_STRING * )LocalAlloc(
                                        0,
                                        sizeof( PUNICODE_STRING )));

                    if ( TdoNamesT == NULL ) {

                        if ( TdoNames ) {

                            LocalFree( TdoNames );
                        }

                        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapForestTrustCacheInsert (%s:%d)\n", __FILE__, __LINE__ ));
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Error;
                    }

                    TdoNames = TdoNamesT;
                    TdoNames[TdoNamesCount] = String2;
                    TdoNamesCount += 1;
                }
            }

            ASSERT( TdoNamesCount > 0 );
            ASSERT( TdoNames != NULL );

            Status = LsapDbReferenceObject(
                         LsapPolicyHandle,
                         0,
                         PolicyObject,
                         TrustedDomainObject,
                         LSAP_DB_DS_OP_TRANSACTION // no lock acquired (must be done outside the routine)
                         );

            if ( !NT_SUCCESS( Status )) {

                LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsert: LsapDbReferenceObject returned 0x%x\n", Status ));
                LocalFree( TdoNames );
                goto Error;
            }

            ObjectReferenced = TRUE;

            //
            // Write every affected TDO out to disk
            //

            for ( i = 0 ; i < TdoNamesCount ; i++ ) {

                LSAP_DB_OBJECT_INFORMATION ObjInfo;
                LSAP_DB_ATTRIBUTE Attributes[LSAP_DB_ATTRS_INFO_CLASS_DOMAIN];
                LSAP_DB_ATTRIBUTE * NextAttribute;
                ULONG AttributeCount = 0;
                LSAPR_HANDLE TrustedDomainHandle = NULL;
                ULONG BlobLength = 0;
                BYTE * BlobData = NULL;
                FTCache::TDO_ENTRY * TdoEntry;
                LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY * TrustInfoForName;

                //
                // Get the right name
                //

                Status = LsapDbLookupNameTrustedDomainListEx(
                             ( LSAPR_UNICODE_STRING * )TdoNames[i],
                             &TrustInfoForName
                             );

                if ( !NT_SUCCESS( Status )) {

                    LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsert: No trust entry found for %wZ: 0x%lx (%s:%d)\n", ( UNICODE_STRING * )TrustedDomainName, Status, __FILE__, __LINE__ ));
                    LocalFree( TdoNames );
                    goto Error;
                }

                //
                // Build a temporary handle
                //

                RtlZeroMemory( &ObjInfo, sizeof( ObjInfo ));
                ObjInfo.ObjectTypeId = TrustedDomainObject;
                ObjInfo.ContainerTypeId = NullObject;
                ObjInfo.Sid = NULL;
                ObjInfo.DesiredObjectAccess = TRUSTED_SET_AUTH;

                InitializeObjectAttributes(
                    &ObjInfo.ObjectAttributes,
                    ( UNICODE_STRING * )&TrustInfoForName->TrustInfoEx.Name,
                    0L,
                    LsapPolicyHandle,
                    NULL
                    );

                //
                // Get a handle to the TDO
                //

                Status = LsapDbOpenObject(
                             &ObjInfo,
                             TRUSTED_SET_AUTH,
                             0,
                             &TrustedDomainHandle
                             );

                if ( !NT_SUCCESS( Status )) {

                    LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsert: LsapDbOpenObject returned 0x%x\n", Status ));
                    LocalFree( TdoNames );
                    goto Error;
                }

                //
                // Locate the cache entry corresponding to this TDO
                //

                TdoEntry = ( FTCache::TDO_ENTRY * )RtlLookupElementGenericTableAvl(
                                                       &g_FTCache->m_TdoTable,
                                                       TdoNames[i]
                                                       );

                if ( TdoEntry == NULL ) {

                    //
                    // What do you mean "not there"???
                    //

                    Status = STATUS_NOT_FOUND;
                    LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsert: RtlLookupElementGenericTableAvl returned 0x%x\n", Status ));
                    ASSERT( FALSE );
                    LocalFree( TdoNames );
                    LsapDbCloseHandle( TrustedDomainHandle );
                    goto Error;
                }

                Status = g_FTCache->MarshalBlob(
                             TdoEntry,
                             &BlobLength,
                             &BlobData
                             );

                if ( !NT_SUCCESS( Status )) {

                    LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsert: FTCache::MarshalBlob returned 0x%x\n", Status ));
                    LocalFree( TdoNames );
                    LsapDbCloseHandle( TrustedDomainHandle );
                    goto Error;
                }

                NextAttribute = Attributes;

                LsapDbInitializeAttributeDs(
                    NextAttribute,
                    TrDmForT,
                    BlobData,
                    BlobLength,
                    FALSE
                    );

                AttributeCount++;

                ASSERT( AttributeCount <= LSAP_DB_ATTRS_INFO_CLASS_DOMAIN );

                //
                // Write the attributes to the DS.
                //

                Status = LsapDbWriteAttributesObject(
                             TrustedDomainHandle,
                             Attributes,
                             AttributeCount
                             );

                if ( !NT_SUCCESS( Status )) {

                    LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsert: LsapDbWriteAttributesObject returned 0x%x\n", Status ));
                    LocalFree( TdoNames );
                    LsapDbCloseHandle( TrustedDomainHandle );
                    FtcFree( BlobData );
                    goto Error;
                }

                LsapDbCloseHandle( TrustedDomainHandle );
                FtcFree( BlobData );
            }

            LocalFree( TdoNames );
        }
    }

Cleanup:

    if ( ObjectReferenced ) {

        Status = LsapDbDereferenceObject(
                     &LsapPolicyHandle,
                     PolicyObject,
                     TrustedDomainObject,
                     LSAP_DB_DS_OP_TRANSACTION |
                        LSAP_DB_OMIT_REPLICATOR_NOTIFICATION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    //
    // If operation completed successfully on a PDC,
    // audit conflict resolution information here
    //

    if ( NT_SUCCESS( Status ) &&
         ConflictPairs &&
         ServerRole == DomainServerRolePrimary ) {

         g_FTCache->AuditCollisions(
             ConflictPairs,
             ConflictPairsTotal
             );
    }

    if ( TdoEntryOld.RecordCount > 0 ) {

        g_FTCache->PurgeTdoEntry( &TdoEntryOld );
    }

    FtcFree( ConflictPairs );

    LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsert returning, Status: 0x%x\n", Status ));
    LsapExitFunc( "LsapForestTrustCacheInsert", Status );
    LsarpReturnPrologue();

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));

    //
    // Rollback the changes made to the cache
    //

    if ( TdoEntryNew ) {

        g_FTCache->RollbackChanges( TdoEntryNew, &TdoEntryOld );
        TdoEntryNew = NULL;
    }

    goto Cleanup;
}



inline NTSTATUS
LsapForestTrustCacheRemove(
    IN UNICODE_STRING * TrustedDomainName
    )
{
    ASSERT( LsapDbIsLockedTrustedDomainList());

    return g_FTCache->Remove( TrustedDomainName );
}



inline NTSTATUS
LsapForestTrustCacheRetrieve(
    IN UNICODE_STRING * TrustedDomainName,
    OUT LSA_FOREST_TRUST_INFORMATION * * ForestTrustInfo
    )
{
    ASSERT( LsapDbIsLockedTrustedDomainList());

    return g_FTCache->Retrieve(
                TrustedDomainName,
                ForestTrustInfo
                );
}



NTSTATUS
LsapAddToCollisionInfo(
    IN OUT PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo,
    IN ULONG Index,
    IN LSA_FOREST_TRUST_COLLISION_RECORD_TYPE Type,
    IN ULONG Flags,
    IN OPTIONAL UNICODE_STRING * Name
    )
/*++

Routine Description:

    Apends the given index and trusted domain name to the
    provided collision information structure.

Arguments:

    CollisionInfo        structure to append to

    Index                new entry's index

    Type                 type of collision

    Flags                new flags set as result of collision

    Name                 name (only for certain types of collisions)

Returns:

    STATUS_SUCCESS       operation completed successfully
                         this routine takes ownership of ForestTrustRecord

    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS Status;
    LSA_FOREST_TRUST_COLLISION_RECORD * CollisionRecord;
    PLSA_FOREST_TRUST_COLLISION_RECORD * EntriesT;
    BOOLEAN CollisionInfoAllocated = FALSE;

    ASSERT( CollisionInfo != NULL );

    //
    // First, see if collision information for this index already exists,
    // and if so, update the existing entry
    //

    if ( *CollisionInfo != NULL ) {

        for ( ULONG i = 0 ; i < (*CollisionInfo)->RecordCount ; i += 1 ) {

            PLSA_FOREST_TRUST_COLLISION_RECORD Record = (*CollisionInfo)->Entries[i];

            if ( Record->Index == Index &&
                 Record->Type == Type &&
                 (( Name == NULL && Record->Name.Length == 0 ) ||
                  ( Name != NULL && RtlEqualUnicodeString(
                                        Name,
                                        &Record->Name,
                                        TRUE )))) {

                //
                // This seems like an additional conflict for the same
                // entry.  Just add the new flags into the mix and get out.
                //

                Record->Flags |= Flags;
                return STATUS_SUCCESS;
            }
        }
    }

    CollisionRecord = ( LSA_FOREST_TRUST_COLLISION_RECORD * )
                          FtcAllocate( sizeof( LSA_FOREST_TRUST_COLLISION_RECORD ));

    if ( CollisionRecord == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapAddToCollisionInfo (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    CollisionRecord->Index = Index;
    CollisionRecord->Type = Type;
    CollisionRecord->Flags = Flags;

    if ( Name != NULL ) {

        if ( FALSE == FtcCopyUnicodeString(
                          ( UNICODE_STRING * )&CollisionRecord->Name,
                          Name )) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapAddToCollisionInfo (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }
    }

    if ( *CollisionInfo == NULL ) {

        *CollisionInfo = ( LSA_FOREST_TRUST_COLLISION_INFORMATION * )
                             FtcAllocate( sizeof( LSA_FOREST_TRUST_COLLISION_INFORMATION ));

        if ( *CollisionInfo == NULL ) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapAddToCollisionInfo (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        ZeroMemory( *CollisionInfo, sizeof( LSA_FOREST_TRUST_COLLISION_INFORMATION ));

        CollisionInfoAllocated = TRUE;
    }

    EntriesT = ( LSA_FOREST_TRUST_COLLISION_RECORD * * )FtcReallocate(
                   (*CollisionInfo)->Entries,
                   (*CollisionInfo)->RecordCount * sizeof( LSA_FOREST_TRUST_COLLISION_RECORD * ),
                   ((*CollisionInfo)->RecordCount + 1) * sizeof( LSA_FOREST_TRUST_COLLISION_RECORD * )
                   );

    if ( EntriesT == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapAddToCollisionInfo (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    (*CollisionInfo)->Entries = EntriesT;
    (*CollisionInfo)->Entries[(*CollisionInfo)->RecordCount] = CollisionRecord;

    (*CollisionInfo)->RecordCount += 1;

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));

    if ( CollisionRecord ) {

        FtcFree( CollisionRecord->Name.Buffer );
        FtcFree( CollisionRecord );
    }

    if ( CollisionInfoAllocated ) {

        FtcFree( *CollisionInfo );
        *CollisionInfo = NULL;
    }

    goto Cleanup;
}


///////////////////////////////////////////////////////////////////////////////
//
// FTCache public interface
//
///////////////////////////////////////////////////////////////////////////////



FTCache::FTCache()
/*++

Routine Description:

    FTCache constructor

Arguments:

    None

Returns:

    Nothing

NOTE: FTCache::Initialize() must be called before the object is usable

--*/
{
    m_Initialized = FALSE;
    m_Valid = FALSE;
}



FTCache::~FTCache()
/*++

Routine Description:

    FTCache destructor
    Removes all cache contents as part of the destruction process

Arguments:

    None

Returns:

    Nothing

--*/
{
    if ( m_Initialized ) {

        Purge();
    }
}



NTSTATUS
FTCache::Initialize()
/*++

Routine Description:

    Initializes the forest trust cache.
    The initialized cache is not populated and its Valid
    bit is set to FALSE

Arguments:

    None

Returns:

    STATUS_SUCCESS          cache initialized successfully

--*/
{
    ASSERT( !m_Initialized );

    RtlInitializeGenericTableAvl(
        &m_TdoTable,
        UnicodeStringCompareRoutine,
        FtcAllocateRoutine,
        FtcFreeRoutine,
        NULL
        );

    RtlInitializeGenericTableAvl(
        &m_TopLevelNameTable,
        UnicodeStringCompareRoutine,
        FtcAllocateRoutine,
        FtcFreeRoutine,
        NULL
        );

    RtlInitializeGenericTableAvl(
        &m_DomainSidTable,
        SidCompareRoutine,
        FtcAllocateRoutine,
        FtcFreeRoutine,
        NULL
        );

    RtlInitializeGenericTableAvl(
        &m_DnsNameTable,
        UnicodeStringCompareRoutine,
        FtcAllocateRoutine,
        FtcFreeRoutine,
        NULL
        );

    RtlInitializeGenericTableAvl(
        &m_NetbiosNameTable,
        UnicodeStringCompareRoutine,
        FtcAllocateRoutine,
        FtcFreeRoutine,
        NULL
        );

    m_Initialized = TRUE;

    return STATUS_SUCCESS;
}



void
FTCache::SetInvalid()
/*++

Routine Description:

    Sets the cache to the "invalid" state and purges its contents

Arguments:

    None

Returns:

    Nothing

--*/
{
    //
    // GC Notifications have got to go
    //

    if ( NotificationHandle != NULL ) {

        NTSTATUS Status = 0;
        BOOLEAN CloseTransaction = FALSE;

        //
        //  See if we already have a transaction going
        //

        Status = LsapDsInitAllocAsNeededEx(
                     LSAP_DB_READ_ONLY_TRANSACTION |
                        LSAP_DB_NO_LOCK |
                        LSAP_DB_DS_OP_TRANSACTION,
                     TrustedDomainObject,
                     &CloseTransaction
                     );
 
        if ( NT_SUCCESS( Status )) {

            ULONG DirResult;

            DirResult = DirNotifyUnRegister(
                            NotificationHandle,
                            NULL // DirNotifyUnRegister does not use its second parameter anyway
                            );

            ASSERT( 0 == DirResult );

            LsapDsDeleteAllocAsNeededEx(
                LSAP_DB_READ_ONLY_TRANSACTION |
                   LSAP_DB_NO_LOCK |
                   LSAP_DB_DS_OP_TRANSACTION,
                TrustedDomainObject,
                CloseTransaction
                );
        }

        //
        // Clear the notification handle even if there was an error
        // Got no choice, here, really.
        //

        NotificationHandle = NULL;
    }

    //
    // Mark the cache as invalid
    //

    m_Valid = FALSE;

    //
    // And since it's invalid, blow away its contents -- they need to be rebuilt anyway
    //

    Purge();
}



NTSTATUS
FTCache::Insert(
    IN UNICODE_STRING * TrustedDomainName,
    IN OPTIONAL PSID TrustedDomainSid,
    IN LSA_FOREST_TRUST_INFORMATION * ForestTrustInfo,
    IN BOOLEAN LocalForestEntry,
    OUT TDO_ENTRY * TdoEntryOldOut,
    OUT TDO_ENTRY * * TdoEntryNewOut,
    OUT CONFLICT_PAIR * * ConflictPairs,
    OUT ULONG * ConflictPairsTotal
    )
/*++

Routine Description:

    Inserts entries corresponding to the given TDO into the cache

Arguments:

    TrustedDomainName       Name of the TDO that the enries correspond to

    TrustedDomainSid        Sid of the TDO

    ForestTrustInfo         Entries to insert

    LocalForestEntry        Does this entry correspond to the local forest?

    TdoEntryOldOut          Used to return old TDO entry

    TdoEntryNewOut          Used to return new TDO entry

    ConflictPairs           Used to return conflict information
    ConflictPairsTotal

Returns:

    STATUS_SUCCESS                  Entry added successfully

    STATUS_INSUFFICIENT_RESOURCES   Ran out of memory; entry not added

    STATUS_INVALID_PARAMETER        Parameters were somehow incorrect

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    TDO_ENTRY * TdoEntryNew = NULL;
    LIST_ENTRY * ListEntry;
    LARGE_INTEGER CurrentTime;

    ASSERT( m_Initialized );

    if ( TrustedDomainName == NULL ||
         ForestTrustInfo == NULL ||
         TdoEntryNewOut == NULL ||
         TdoEntryOldOut == NULL ||
         ConflictPairs == NULL ||
         ConflictPairsTotal == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
        ASSERT( FALSE ); // should not happen in released code
        return STATUS_INVALID_PARAMETER;
    }

    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Insert called, TDO: %wZ, Entries: %d\n", TrustedDomainName, ForestTrustInfo ? ForestTrustInfo->RecordCount : 0 ));

    ZeroMemory( TdoEntryOldOut, sizeof( TDO_ENTRY ));
    *ConflictPairs = NULL;
    *ConflictPairsTotal = 0;

    //
    // Figure out if the cache contains information for this TDO already.
    // If so, save off the existing info in case the changes need to
    // be reverted later.
    //

    TdoEntryNew = ( TDO_ENTRY * )RtlLookupElementGenericTableAvl(
                                     &m_TdoTable,
                                     TrustedDomainName
                                     );

    if ( TdoEntryNew == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Cache does not contain current information for %wZ\n", TrustedDomainName ));

        CLONG EntrySize = sizeof( TDO_ENTRY ) + TrustedDomainName->Length + sizeof( WCHAR );
        TDO_ENTRY * TdoEntry;

        SafeAllocaAllocate( TdoEntry, EntrySize );

        if ( TdoEntry == NULL ) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        TdoEntry->RecordCount = 0;
        TdoEntry->TrustedDomainSid = NULL; // filled in later

        //
        // Initialize a cache entry for this TDO
        //

        FtcCopyUnicodeString(
            &TdoEntry->TrustedDomainName,
            TrustedDomainName,
            TdoEntry->TrustedDomainNameBuffer
            );

        TdoEntryNew = ( TDO_ENTRY * )RtlInsertElementGenericTableAvl(
                                         &m_TdoTable,
                                         TdoEntry,
                                         EntrySize,
                                         NULL
                                         );

        SafeAllocaFree( TdoEntry );
        TdoEntry = NULL;

        if ( TdoEntryNew == NULL ) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        TdoEntryNew->TrustedDomainName.Buffer = TdoEntryNew->TrustedDomainNameBuffer;

        ASSERT( ++sm_TdoEntries > 0 );

    } else {

        ASSERT( RtlEqualUnicodeString(
                    &TdoEntryNew->TrustedDomainName,
                    TrustedDomainName,
                    TRUE ));

        LsapDsDebugOut(( DEB_FTINFO, "FTCache::Insert: Cache already contains information for %wZ\n", TrustedDomainName ));

        //
        // Replacing a local forest entry with a non-local forest entry
        // (or vice versa) is clearly bogus
        //

        if ( TdoEntryNew->LocalForestEntry != LocalForestEntry ) {

            LsapDsDebugOut(( DEB_FTINFO, "FTCache::Insert: LocalForestEntry flags mismatched (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            ASSERT( FALSE );    // not sure if this is even possible
            TdoEntryNew = NULL; // ensure no rollback at cleanup time
            goto Error;
        }

        CopyTdoEntry( TdoEntryOldOut, TdoEntryNew );
    }

    ASSERT( TdoEntryNew != NULL );

    //
    // All InitializeListHead calls must take place AFTER
    // the entry has been inserted into the table
    // since they use self-referencing pointers
    //

    TdoEntryNew->RecordCount = 0;
    TdoEntryNew->LocalForestEntry = LocalForestEntry;
    InitializeListHead( &TdoEntryNew->TlnList );
    InitializeListHead( &TdoEntryNew->DomainInfoList );
    InitializeListHead( &TdoEntryNew->BinaryList );

    //
    // Store the SID with the entry
    //

    if ( TrustedDomainSid ) {

        ULONG SidLength = RtlLengthSid( TrustedDomainSid );

        TdoEntryNew->TrustedDomainSid = ( PSID )FtcAllocate( SidLength );

        if ( TdoEntryNew->TrustedDomainSid == NULL ) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        RtlCopySid(
            SidLength,
            TdoEntryNew->TrustedDomainSid,
            TrustedDomainSid
            );

    } else {

        TdoEntryNew->TrustedDomainSid = NULL;
    }

    //
    // All "new" entries will be given the same timestamp
    //

    GetSystemTimeAsFileTime(( LPFILETIME )&CurrentTime );

    //
    // Populate the forest trust cache with the information from ForestTrustInfo
    // This is done without regard to collisions.  A collision check follows.
    //

    for ( ULONG Current = 0 ; Current < ForestTrustInfo->RecordCount ; Current++ ) {

        LSA_FOREST_TRUST_RECORD * Record = ForestTrustInfo->Entries[Current];
        BOOLEAN Duplicate = FALSE;

        switch ( Record->ForestTrustType ) {

        case ForestTrustTopLevelName: {

            UNICODE_STRING TopLevelName = Record->ForestTrustData.TopLevelName;
            TLN_ENTRY * SubordinateEntry = NULL;
            TLN_KEY * * TlnKeys;
            TLN_ENTRY * * TlnEntries;
            USHORT DnsComponents;
            USHORT Component;

            //
            // If these asserts fire, you forgot to validate the
            // data before passing it in.  Use LsapValidateForestTrustInfo().
            //

            ASSERT( TopLevelName.Length > 0 );
            ASSERT( TopLevelName.Buffer != NULL );

            DnsComponents = DnsNameComponents( &TopLevelName );

            SafeAllocaAllocate( TlnKeys, sizeof( TLN_KEY * ) * DnsComponents );
            SafeAllocaAllocate( TlnEntries, sizeof( TLN_ENTRY * ) * DnsComponents );

            if ( TlnKeys == NULL ||
                 TlnEntries == NULL ) {

                LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto TlnError;
            }

            RtlZeroMemory( TlnKeys, sizeof( TLN_KEY * ) * DnsComponents );
            RtlZeroMemory( TlnEntries, sizeof( TLN_ENTRY * ) * DnsComponents );

            for ( Component = 0 ; Component < DnsComponents ; Component++ ) {

                //
                // Move to the next component (except on first iteration through the loop)
                //

                if ( Component > 0 ) {

                    NextDnsComponent( &TopLevelName );
                }

                //
                // Locate a match for this TLN in the cache
                //

                TlnKeys[Component] = ( TLN_KEY * )RtlLookupElementGenericTableAvl(
                                                      &m_TopLevelNameTable,
                                                      &TopLevelName
                                                      );

                if ( TlnKeys[Component] == NULL ) {

                    //
                    // Nothing matching this top level name was found;
                    // Initialize and insert a new entry into the tree
                    //

                    CLONG KeySize = sizeof( TLN_KEY ) + TopLevelName.Length + sizeof( WCHAR );
                    TLN_KEY * TlnKeyNew;

                    SafeAllocaAllocate( TlnKeyNew, KeySize );

                    if ( TlnKeyNew == NULL ) {

                        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto TlnError;
                    }

                    TlnKeyNew->Count = 0;

                    FtcCopyUnicodeString(
                        &TlnKeyNew->TopLevelName,
                        &TopLevelName,
                        TlnKeyNew->TopLevelNameBuffer
                        );

                    TlnKeys[Component] = ( TLN_KEY * )RtlInsertElementGenericTableAvl(
                                                          &m_TopLevelNameTable,
                                                          TlnKeyNew,
                                                          KeySize,
                                                          NULL
                                                          );

                    SafeAllocaFree( TlnKeyNew );
                    TlnKeyNew = NULL;

                    if ( TlnKeys[Component] == NULL ) {

                        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto TlnError;
                    }

                    TlnKeys[Component]->TopLevelName.Buffer = TlnKeys[Component]->TopLevelNameBuffer;

                    ASSERT( ++sm_TlnKeys > 0 );

                    //
                    // All InitializeListHead calls must take place AFTER
                    // the entry has been inserted into the table
                    // since they use self-referential pointers
                    //

                    InitializeListHead( &TlnKeys[Component]->List );

                } else {

                    //
                    // This name is known inside the cache.
                    // This could be duplicate, invalid parameter or a conflict.
                    // For now, check for duplicates and invalid
                    // parameter conditions only.
                    //

                    for ( ListEntry = TlnKeys[Component]->List.Flink;
                          ListEntry != &TlnKeys[Component]->List;
                          ListEntry = ListEntry->Flink ) {

                        TLN_ENTRY * TlnEntry;

                        TlnEntry = TLN_ENTRY::EntryFromAvlEntry( ListEntry );

                        if ( TlnEntry->TdoEntry != TdoEntryNew ) {

                            continue;
                        }

                        if ( TlnEntry->Excluded ) {

                            //
                            // Having both a top level name and an exclusion
                            // record for the same name is clearly invalid.
                            //
                            // Also, a top level name can not be subordinate
                            // to an exclusion record for the same TLN.
                            //

                            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                            Status = STATUS_INVALID_PARAMETER;
                            goto TlnError;

                        } else if ( TlnEntry->SubordinateEntry != NULL &&
                                    SubordinateEntry == NULL ) {

                            //
                            // If we're looking at a subordinate entry
                            // (e.g. acme.com subordinate to NY.acme.com)
                            // and we're trying to insert a top level entry
                            // of acme.com, then the existece of the other
                            // top level entry is invalid (the namespace would
                            // be claimed by acme.com and NY.acme.com is redundant)
                            //

                            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                            Status = STATUS_INVALID_PARAMETER;
                            goto TlnError;

                        } else if ( TlnEntry->SubordinateEntry == NULL &&
                                    SubordinateEntry != NULL ) {

                            //
                            // If we're looking at a top-level entry (e.g. acme.com)
                            // and we're trying to insert a superior entry of another
                            // top level name that matches it (say "acme.com" for
                            // a TLN of "NY.acme.com") then we're doing something
                            // wrong.
                            //

                            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                            Status = STATUS_INVALID_PARAMETER;
                            goto TlnError;

                        } else if ( TlnEntry->SubordinateEntry != NULL &&
                                    SubordinateEntry != NULL ) {

                            //
                            // Both entries are superior entries.  This will happen
                            // if both "WA.acme.com" and "NY.acme.com" are claimed
                            // by this TDO, so both "acme.com" entries must exist
                            // in the cache and it's not a problem.
                            //
                            // Do nothing
                            //

                        } else {

                            ASSERT( TlnEntry->SubordinateEntry == NULL );
                            ASSERT( SubordinateEntry == NULL );

                            //
                            // Found two identical top-level entries for the same
                            // TDO.  Second entry is a duplicate and can be dropped.
                            //
                            // Note that the disabled status of the two can be
                            // different.  Too bad.  The later entry is ignored.
                            // Alternatively, this can be considered as invalid parameter.
                            //

                            LsapDsDebugOut(( DEB_FTINFO, "Record %d is a duplicate of entry %p (%s:%d)\n", Current, TlnEntry, __FILE__, __LINE__ ));

                            Duplicate = TRUE;
                            break;
                        }
                    }

                    if ( Duplicate ) {

                        break;
                    }
                }

                ASSERT( TlnKeys[Component] != NULL );

                TlnEntries[Component] = ( TLN_ENTRY * )FtcAllocate( sizeof( TLN_ENTRY ));

                if ( TlnEntries[Component] == NULL ) {

                    LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto TlnError;
                }

                ASSERT( ++sm_TlnEntries > 0 );

                //
                // Associate this item with the TDO cache entry
                //

                InsertHeadList( &TdoEntryNew->TlnList, &TlnEntries[Component]->TdoListEntry );

                //
                // ... and also with the AVL tree entry
                //

                TlnKeys[Component]->Count += 1;
                InsertHeadList( &TlnKeys[Component]->List, &TlnEntries[Component]->AvlListEntry );

                //
                // Initialize the rest of TLN_ENTRY fields
                //

                if ( Record->Time.LowPart == 0 && Record->Time.HighPart == 0 ) {

                    TlnEntries[Component]->Time = CurrentTime;

                } else {

                    TlnEntries[Component]->Time = Record->Time;
                }

                TlnEntries[Component]->Excluded = FALSE;
                TlnEntries[Component]->Index = Current;
                TlnEntries[Component]->TdoEntry = TdoEntryNew;
                TlnEntries[Component]->SubordinateEntry = SubordinateEntry;
                TlnEntries[Component]->TlnKey = TlnKeys[Component];
                TlnEntries[Component]->SetFlags( Record->Flags );

                //
                // Prepare for next iteration
                //

                SubordinateEntry = TlnEntries[Component];
            }

            SafeAllocaFree( TlnKeys );
            SafeAllocaFree( TlnEntries );

            break;

TlnError:

            //
            // Blow away all the entries and keys inserted in this round
            //

            for ( Component = 0 ; Component < DnsComponents ; Component++ ) {

                if ( TlnEntries[Component] != NULL ) {

                    ASSERT( sm_TlnEntries-- > 0 );

                    RemoveEntryList( &TlnEntries[Component]->TdoListEntry );
                    RemoveEntryList( &TlnEntries[Component]->AvlListEntry );

                    TlnEntries[Component]->TlnKey->Count -= 1;

                    FtcFree( TlnEntries[Component] );
                }

                if ( TlnKeys[Component] != NULL && TlnKeys[Component]->Count == 0 ) {

                    BOOLEAN Found;

                    Found = RtlDeleteElementGenericTableAvl(
                                &m_TopLevelNameTable,
                                TlnKeys[Component]
                                );

                    ASSERT( sm_TlnKeys-- > 0 );
                    ASSERT( Found );
                }
            }

            SafeAllocaFree( TlnKeys );
            SafeAllocaFree( TlnEntries );

            goto Error;
        }

        case ForestTrustTopLevelNameEx: {

            UNICODE_STRING TopLevelName = Record->ForestTrustData.TopLevelName;
            TLN_ENTRY * TlnEntry;
            TLN_KEY * TlnKey;

            //
            // If these asserts fire, you forgot to validate the
            // data before passing it in.  Use LsapValidateForestTrustInfo().
            //

            ASSERT( TopLevelName.Length > 0 );
            ASSERT( TopLevelName.Buffer != NULL );

            //
            // An exclusion record claims part of the namespace, and
            // so must contain at least 2 DNS name components.
            // e.g. 'acme.com' is valid but 'com' is not
            //

            if ( 1 >= DnsNameComponents( &TopLevelName )) {

                LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                Status = STATUS_INVALID_PARAMETER;
                goto Error;
            }

            TlnKey = ( TLN_KEY * )RtlLookupElementGenericTableAvl(
                                      &m_TopLevelNameTable,
                                      &TopLevelName
                                      );

            if ( TlnKey == NULL ) {

                //
                // Nothing matching this top level name was found;
                // Initialize and insert a new entry into the tree
                //

                CLONG KeySize = sizeof( TLN_KEY ) + TopLevelName.Length + sizeof( WCHAR );
                TLN_KEY * TlnKeyNew;

                SafeAllocaAllocate( TlnKeyNew, KeySize );

                if ( TlnKeyNew == NULL ) {

                    LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Error;
                }

                TlnKeyNew->Count = 0;

                FtcCopyUnicodeString(
                    &TlnKeyNew->TopLevelName,
                    &TopLevelName,
                    TlnKeyNew->TopLevelNameBuffer
                    );

                TlnKey = ( TLN_KEY * )RtlInsertElementGenericTableAvl(
                                          &m_TopLevelNameTable,
                                          TlnKeyNew,
                                          KeySize,
                                          NULL
                                          );

                SafeAllocaFree( TlnKeyNew );
                TlnKeyNew = NULL;

                if ( TlnKey == NULL ) {

                    LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Error;
                }

                TlnKey->TopLevelName.Buffer = TlnKey->TopLevelNameBuffer;

                ASSERT( ++sm_TlnKeys > 0 );

                //
                // All InitializeListHead calls must take place AFTER
                // the entry has been inserted into the table
                // since they use self-referential pointers
                //

                InitializeListHead( &TlnKey->List );

            } else {

                //
                // This name is known inside the cache.
                // This could be duplicate, invalid parameter or a conflict.
                // For now, check for duplicates and invalid
                // parameter conditions only.
                //

                for ( ListEntry = TlnKey->List.Flink;
                      ListEntry != &TlnKey->List;
                      ListEntry = ListEntry->Flink ) {

                    TLN_ENTRY * TlnEntry;

                    TlnEntry = TLN_ENTRY::EntryFromAvlEntry( ListEntry );

                    if ( TlnEntry->TdoEntry != TdoEntryNew ) {

                        continue;
                    }

                    if ( TlnEntry->Excluded != TRUE ) {

                        //
                        // Having both a top level and an exclusion
                        // record for the same name is clearly broken.
                        //

                        LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                        Status = STATUS_INVALID_PARAMETER;
                        goto Error;
                    }

                    //
                    // If the other entry is for the same TDO as this one,
                    // this is bogus input.  Ignore this record.
                    //

                    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Insert: Record %d is a duplicate of entry %p (%s:%d)\n", Current, TlnEntry, __FILE__, __LINE__ ));

                    Duplicate = TRUE;
                    break;
                }

                if ( Duplicate ) {

                    break;
                }
            }

            ASSERT( TlnKey != NULL );

            TlnEntry = ( TLN_ENTRY * )FtcAllocate( sizeof( TLN_ENTRY ));

            if ( TlnEntry == NULL && TlnKey->Count == 0 ) {

                BOOLEAN Found;

                Found = RtlDeleteElementGenericTableAvl(
                            &m_TopLevelNameTable,
                            TlnKey
                            );

                ASSERT( sm_TlnKeys-- > 0 );
                ASSERT( Found );
            }

            ASSERT( ++sm_TlnEntries > 0 );

            //
            // Associate this item with the TDO cache entry
            //

            InsertHeadList( &TdoEntryNew->TlnList, &TlnEntry->TdoListEntry );

            //
            // ... and alsow ith the AVL tree entry
            //

            TlnKey->Count += 1;
            InsertHeadList( &TlnKey->List, &TlnEntry->AvlListEntry );

            //
            // Initialize the rest of TLN_ENTRY fields
            //

            TlnEntry->Excluded = TRUE;
            TlnEntry->Index = Current;
            TlnEntry->TdoEntry = TdoEntryNew;
            TlnEntry->SuperiorEntry = NULL;
            TlnEntry->TlnKey = TlnKey;
            TlnEntry->SetFlags( Record->Flags ); // value ignored for exclusion entries

            if ( Record->Time.LowPart == 0 && Record->Time.HighPart == 0 ) {

                TlnEntry->Time = CurrentTime;

            } else {

                TlnEntry->Time = Record->Time;
            }

            break;
        }

        case ForestTrustDomainInfo: {

            SID * Sid = ( SID * )Record->ForestTrustData.DomainInfo.Sid;
            UNICODE_STRING * DnsName = &Record->ForestTrustData.DomainInfo.DnsName;
            UNICODE_STRING * NetbiosName = &Record->ForestTrustData.DomainInfo.NetbiosName;
            DOMAIN_INFO_ENTRY * DomainInfoEntry;
            DOMAIN_SID_KEY * SidKey;
            DNS_NAME_KEY * DnsKey;
            NETBIOS_NAME_KEY * NetbiosKey;
            BOOLEAN NetbiosPresent = ( NetbiosName->Length > 0 && NetbiosName->Buffer != NULL );
            ULONG SidLength;
            BOOLEAN SidKeyAllocated = FALSE;
            BOOLEAN DnsKeyAllocated = FALSE;
            BOOLEAN NetbiosKeyAllocated = FALSE;

            //
            // If these asserts fire, you forgot to validate the
            // data before passing it in.  Use LsapValidateForestTrustInfo().
            //

            ASSERT( Sid );
            ASSERT( DnsName->Length > 0 );
            ASSERT( DnsName->Buffer != NULL );

            if ( !RtlValidSid( Sid )) {

                LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                Status = STATUS_INVALID_PARAMETER;
                goto Error;
            }

            SidLength = RtlLengthSid( Sid );

            ASSERT( SidLength > 0 );

            SidKey = ( DOMAIN_SID_KEY * )RtlLookupElementGenericTableAvl(
                                             &m_DomainSidTable,
                                             &Sid
                                             );

            DnsKey = ( DNS_NAME_KEY * )RtlLookupElementGenericTableAvl(
                                           &m_DnsNameTable,
                                           DnsName
                                           );

            if ( NetbiosPresent ) {

                NetbiosKey = (NETBIOS_NAME_KEY * )RtlLookupElementGenericTableAvl(
                                                      &m_NetbiosNameTable,
                                                      NetbiosName
                                                      );

            } else {

                NetbiosKey = NULL;
            }

            if ( SidKey == NULL ) {

                //
                // Nothing matching this domain SID was found;
                // Initialize and insert a new entry into the tree
                //

                CLONG KeySize = sizeof( DOMAIN_SID_KEY ) + SidLength;
                DOMAIN_SID_KEY * SidKeyNew;

                SafeAllocaAllocate( SidKeyNew, KeySize );

                if ( SidKeyNew == NULL ) {

                    LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto DomainInfoError;
                }

                SidKeyNew->Count = 0;
                SidKeyNew->DomainSid = ( SID * )SidKeyNew->SidBuffer;
                RtlCopySid( SidLength, SidKeyNew->DomainSid, Sid );

                SidKey = ( DOMAIN_SID_KEY * )RtlInsertElementGenericTableAvl(
                                                 &m_DomainSidTable,
                                                 SidKeyNew,
                                                 KeySize,
                                                 NULL
                                                 );

                SafeAllocaFree( SidKeyNew );
                SidKeyNew = NULL;

                if ( SidKey == NULL ) {

                    LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto DomainInfoError;
                }

                SidKey->DomainSid = ( SID * )SidKey->SidBuffer;

                SidKeyAllocated = TRUE;
                ASSERT( ++sm_SidKeys > 0 );

                //
                // All InitializeListHead calls must take place AFTER
                // the entry has been inserted into the table
                // since they use self-referential pointers
                //

                InitializeListHead( &SidKey->List );

            } else {

                //
                // This SID is known inside the cache.
                // Check for duplicates here, for conflicts later.
                //

                for ( ListEntry = SidKey->List.Flink;
                      ListEntry != &SidKey->List;
                      ListEntry = ListEntry->Flink ) {

                    DOMAIN_INFO_ENTRY * DomainInfoEntry;

                    DomainInfoEntry = DOMAIN_INFO_ENTRY::EntryFromSidEntry( ListEntry );

                    if ( DomainInfoEntry->TdoEntry != TdoEntryNew ) {

                        continue;
                    }

                    LsapDsDebugOut(( DEB_FTINFO, "Record %d is a duplicate of entry %p (%s:%d)\n", Current, DomainInfoEntry, __FILE__, __LINE__ ));

                    Duplicate = TRUE;
                    break;
                }

                if ( Duplicate ) {

                    goto DuplicateEntry;
                }
            }

            ASSERT( SidKey != NULL );

            if ( DnsKey == NULL ) {

                //
                // Nothing matches this DNS name
                // Initialize and insert a new entry into the tree
                //

                CLONG KeySize = sizeof( DNS_NAME_KEY ) + DnsName->Length + sizeof( WCHAR );
                DNS_NAME_KEY * DnsKeyNew;

                SafeAllocaAllocate( DnsKeyNew, KeySize );

                if ( DnsKeyNew == NULL ) {

                    LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto DomainInfoError;
                }

                DnsKeyNew->Count = 0;

                FtcCopyUnicodeString(
                    &DnsKeyNew->DnsName,
                    DnsName,
                    DnsKeyNew->DnsNameBuffer
                    );

                DnsKey = ( DNS_NAME_KEY * )RtlInsertElementGenericTableAvl(
                                               &m_DnsNameTable,
                                               DnsKeyNew,
                                               KeySize,
                                               NULL
                                               );

                SafeAllocaFree( DnsKeyNew );
                DnsKeyNew = NULL;

                if ( DnsKey == NULL ) {

                    LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto DomainInfoError;
                }

                DnsKey->DnsName.Buffer = DnsKey->DnsNameBuffer;

                DnsKeyAllocated = TRUE;
                ASSERT( ++sm_DnsNameKeys > 0 );

                //
                // All InitializeListHead calls must take place AFTER
                // the entry has been inserted into the table
                // since they use self-referential pointers
                //

                InitializeListHead( &DnsKey->List );

            } else {

                //
                // This name is known inside the cache.
                // Check for duplicates here, for coflicts later.
                //

                for ( ListEntry = DnsKey->List.Flink;
                      ListEntry != &DnsKey->List;
                      ListEntry = ListEntry->Flink ) {

                    DOMAIN_INFO_ENTRY * DomainInfoEntry;

                    DomainInfoEntry = DOMAIN_INFO_ENTRY::EntryFromDnsEntry( ListEntry );

                    if ( DomainInfoEntry->TdoEntry != TdoEntryNew ) {

                        continue;
                    }

                    LsapDsDebugOut(( DEB_FTINFO, "Record %d is a duplicate of entry %p (%s:%d)\n", Current, DomainInfoEntry, __FILE__, __LINE__ ));

                    Duplicate = TRUE;
                    break;
                }

                if ( Duplicate ) {

                    goto DuplicateEntry;
                }
            }

            ASSERT( DnsKey != NULL );

            if ( NetbiosPresent && NetbiosKey == NULL ) {

                //
                // Nothing matches this NetbiosName
                // Initialize and insert a new entry into the tree
                //

                CLONG KeySize = sizeof( NETBIOS_NAME_KEY ) + NetbiosName->Length + sizeof( WCHAR );
                NETBIOS_NAME_KEY * NetbiosKeyNew;

                SafeAllocaAllocate( NetbiosKeyNew, KeySize );

                if ( NetbiosKeyNew == NULL ) {

                    LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto DomainInfoError;
                }

                NetbiosKeyNew->Count = 0;

                FtcCopyUnicodeString(
                    &NetbiosKeyNew->NetbiosName,
                    NetbiosName,
                    NetbiosKeyNew->NetbiosNameBuffer
                    );

                NetbiosKey = ( NETBIOS_NAME_KEY * )RtlInsertElementGenericTableAvl(
                                                       &m_NetbiosNameTable,
                                                       NetbiosKeyNew,
                                                       KeySize,
                                                       NULL
                                                       );

                SafeAllocaFree( NetbiosKeyNew );
                NetbiosKeyNew = NULL;

                if ( NetbiosKey == NULL ) {

                    LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto DomainInfoError;
                }

                NetbiosKey->NetbiosName.Buffer = NetbiosKey->NetbiosNameBuffer;

                NetbiosKeyAllocated = TRUE;
                ASSERT( ++sm_NetbiosNameKeys > 0 );

                //
                // All InitializeListHead calls must take place AFTER
                // the entry has been inserted into the table
                // since they use self-referential pointers
                //

                InitializeListHead( &NetbiosKey->List );

            } else if ( NetbiosKey != NULL ) {

                //
                // This name is known inside the cache.
                // Check for duplicates here, for coflicts later.
                //

                for ( ListEntry = NetbiosKey->List.Flink;
                      ListEntry != &NetbiosKey->List;
                      ListEntry = ListEntry->Flink ) {

                    DOMAIN_INFO_ENTRY * DomainInfoEntry;

                    DomainInfoEntry = DOMAIN_INFO_ENTRY::EntryFromNetbiosEntry( ListEntry );

                    if ( DomainInfoEntry->TdoEntry != TdoEntryNew ) {

                        continue;
                    }

                    LsapDsDebugOut(( DEB_FTINFO, "Record %d is a duplicate of entry %p (%s:%d)\n", Current, DomainInfoEntry, __FILE__, __LINE__ ));

                    Duplicate = TRUE;
                    break;
                }

                if ( Duplicate ) {

                    goto DuplicateEntry;
                }
            }

            ASSERT( !NetbiosPresent || NetbiosKey != NULL );

            DomainInfoEntry = ( DOMAIN_INFO_ENTRY * )FtcAllocate( sizeof( DOMAIN_INFO_ENTRY ));

            if ( DomainInfoEntry == NULL ) {

                LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto DomainInfoError;
            }

            DomainInfoEntry->Sid = ( SID * )FtcAllocate( SidLength );

            if ( DomainInfoEntry->Sid == NULL ) {

                LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                FtcFree( DomainInfoEntry );
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto DomainInfoError;
            }

            ASSERT( ++sm_DomainInfoEntries > 0 );

            //
            // Associate this item with the TDO cache entry
            //

            InsertHeadList( &TdoEntryNew->DomainInfoList, &DomainInfoEntry->TdoListEntry );

            //
            // And also with the AVL list entries
            //

            SidKey->Count += 1;
            InsertHeadList( &SidKey->List, &DomainInfoEntry->SidAvlListEntry );

            DnsKey->Count += 1;
            InsertHeadList( &DnsKey->List, &DomainInfoEntry->DnsAvlListEntry );

            if ( NetbiosPresent ) {

                NetbiosKey->Count += 1;
                InsertHeadList( &NetbiosKey->List, &DomainInfoEntry->NetbiosAvlListEntry );

            } else {

                InitializeListHead( &DomainInfoEntry->NetbiosAvlListEntry );
            }

            //
            // Initialize the rest of DomainInfoEntry fields
            //

            if ( Record->Time.LowPart == 0 && Record->Time.HighPart == 0 ) {

                DomainInfoEntry->Time = CurrentTime;

            } else {

                DomainInfoEntry->Time = Record->Time;
            }

            DomainInfoEntry->Index = Current;
            RtlCopySid( SidLength, DomainInfoEntry->Sid, Sid );
            DomainInfoEntry->TdoEntry = TdoEntryNew;
            DomainInfoEntry->SubordinateTo = NULL;
            DomainInfoEntry->SidKey = SidKey;
            DomainInfoEntry->DnsKey = DnsKey;
            DomainInfoEntry->NetbiosKey = NetbiosKey;
            DomainInfoEntry->SetFlags( Record->Flags );

            break;

DuplicateEntry:

            //
            // Duplicates aren't errors!
            //

            ASSERT( NT_SUCCESS( Status ));

DomainInfoError:

            if ( SidKeyAllocated ) {

                BOOLEAN Found;

                Found = RtlDeleteElementGenericTableAvl(
                            &m_DomainSidTable,
                            &Sid
                            );

                ASSERT( sm_SidKeys-- > 0 );
            }

            if ( DnsKeyAllocated ) {

                BOOLEAN Found;

                Found = RtlDeleteElementGenericTableAvl(
                            &m_DnsNameTable,
                            &DnsName
                            );

                ASSERT( sm_DnsNameKeys-- > 0 );
                ASSERT( Found );
            }

            if ( NetbiosKeyAllocated ) {

                BOOLEAN Found;

                Found = RtlDeleteElementGenericTableAvl(
                            &m_NetbiosNameTable,
                            &NetbiosName
                            );

                ASSERT( sm_NetbiosNameKeys-- > 0 );
                ASSERT( Found );
            }

            if ( !NT_SUCCESS( Status )) {

                goto Error;

            } else {

                break;
            }
        }

        default: {

            BINARY_ENTRY * BinaryEntry;

            BinaryEntry = ( BINARY_ENTRY * )FtcAllocate( sizeof( BINARY_ENTRY ));

            if ( BinaryEntry == NULL ) {

                LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }

            BinaryEntry->Data.Length = Record->ForestTrustData.Data.Length;

            if ( BinaryEntry->Data.Length > 0 ) {

                BinaryEntry->Data.Buffer = ( BYTE * )FtcAllocate( BinaryEntry->Data.Length );

                if ( BinaryEntry->Data.Buffer ) {

                    FtcFree( BinaryEntry );
                    LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Error;
                }

                RtlCopyMemory(
                    BinaryEntry->Data.Buffer,
                    Record->ForestTrustData.Data.Buffer,
                    BinaryEntry->Data.Length
                    );

            } else {

                BinaryEntry->Data.Buffer = NULL;
            }

            ASSERT( ++sm_BinaryEntries > 0 );

            //
            // Associate this item with the TDO cache entry
            //

            InsertHeadList( &TdoEntryNew->BinaryList, &BinaryEntry->TdoListEntry );

            //
            // Initialize the rest of BinaryEntry fields
            //

            BinaryEntry->Type = Record->ForestTrustType;
            BinaryEntry->SetFlags( Record->Flags );

            break;
        }
        }

        if ( !Duplicate ) {

            TdoEntryNew->RecordCount += 1;
        }
    }

    ASSERT( TdoEntryNew->RecordCount <= ForestTrustInfo->RecordCount );

    //
    // Before testing for conflicts, validate the records for internal
    // consistency.  Lack of consistency is an invalid parameter, not a conflict.
    //

    //
    // First validate top-level and excluded entries
    //

    for ( ListEntry = TdoEntryNew->TlnList.Flink;
          ListEntry != &TdoEntryNew->TlnList;
          ListEntry = ListEntry->Flink ) {

        TLN_ENTRY * TlnEntry;

        TlnEntry = TLN_ENTRY::EntryFromTdoEntry( ListEntry );

        if ( TlnEntry->Excluded ) {

            ASSERT( TlnEntry->SuperiorEntry == NULL );

            //
            // An excluded entry must be subordinate to a top level name
            // for the same TDO
            //

            UNICODE_STRING ExcludedName = TlnEntry->TlnKey->TopLevelName;

            //
            // The name was validated prior to inserting it into the tree
            //

            ASSERT( 1 < DnsNameComponents( &ExcludedName ));

            for ( NextDnsComponent( &ExcludedName );
                  ExcludedName.Length > 0;
                  NextDnsComponent( &ExcludedName )) {

                TLN_KEY * TlnKeySup = ( TLN_KEY * )RtlLookupElementGenericTableAvl(
                                                       &m_TopLevelNameTable,
                                                       &ExcludedName
                                                       );

                if ( TlnKeySup == NULL ) {

                    continue;
                }

                for ( LIST_ENTRY * ListEntrySup = TlnKeySup->List.Flink;
                      ListEntrySup != &TlnKeySup->List;
                      ListEntrySup = ListEntrySup->Flink ) {

                    TLN_ENTRY * TlnEntrySup;

                    TlnEntrySup = TLN_ENTRY::EntryFromAvlEntry( ListEntrySup );

                    //
                    // Only interested in the entries for the same TDO here
                    //

                    if ( TlnEntrySup->TdoEntry != TdoEntryNew ) {

                        continue;
                    }

                    //
                    // Another entry for the same TDO excludes a superior namespace.
                    // UI wants to retain both (in case sales.redmond.microsoft.com is
                    // already excluded and now the admin wants to exclude
                    // redmond.microsoft.com also)
                    //

                    if ( TlnEntrySup->Excluded ) {

                        continue;
                    }

                    //
                    // Skip over superior entries -- they do not participate
                    // in consistency checking because they just point to
                    // real top level entries
                    //

                    if ( TlnEntrySup->SubordinateEntry != NULL ) {

                        continue;
                    }

                    //
                    // Found our superior entry!  Remember it.
                    //

                    TlnEntry->SuperiorEntry = TlnEntrySup;
                    break;
                }

                if ( TlnEntry->SuperiorEntry != NULL ) {

                    break;
                }
            }

            if ( TlnEntry->SuperiorEntry == NULL ) {

                //
                // This excluded top-level name entry does not have
                // a superior TLN, thus it is invalid.
                //

                LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
                Status = STATUS_INVALID_PARAMETER;
                goto Error;
            }
        }
    }

    //
    // Now validate domain info entries.
    // Each domain info entry must be subordinate to a top level name.
    //
    // An exception is made for domain info entries that have the
    // "administratively disabled" bits set and are not subordinate
    // to any top level name.  Such entries are treated as "store and ignore"
    // to prevent rogue trusted domains from making the trusting side
    // forget about administratively disabled entries.
    //

    for ( ListEntry = TdoEntryNew->DomainInfoList.Flink;
          ListEntry != &TdoEntryNew->DomainInfoList;
          ListEntry = ListEntry->Flink ) {

        DOMAIN_INFO_ENTRY * DomainInfoEntry;

        DomainInfoEntry = DOMAIN_INFO_ENTRY::EntryFromTdoEntry( ListEntry );

        //
        // DomainInfoEntry->SubordinateTo is the field we seek to fill in
        //

        ASSERT( DomainInfoEntry->SubordinateTo == NULL );

        for ( UNICODE_STRING SuperiorName = DomainInfoEntry->DnsKey->DnsName;
              SuperiorName.Length > 0;
              NextDnsComponent( &SuperiorName )) {

            TLN_KEY * TlnKeySup = ( TLN_KEY * )RtlLookupElementGenericTableAvl(
                                                   &m_TopLevelNameTable,
                                                   &SuperiorName
                                                   );

            if ( TlnKeySup == NULL ) {

                continue;
            }

            for ( LIST_ENTRY * ListEntrySup = TlnKeySup->List.Flink;
                  ListEntrySup != &TlnKeySup->List;
                  ListEntrySup = ListEntrySup->Flink ) {

                 TLN_ENTRY * TlnEntrySup;

                 TlnEntrySup = TLN_ENTRY::EntryFromAvlEntry( ListEntrySup );

                 if ( TlnEntrySup->TdoEntry != TdoEntryNew ) {

                     continue;
                 }

                 if ( TlnEntrySup->Excluded ) {

                     continue;
                 }

                 if ( TlnEntrySup->SubordinateEntry == NULL ) {

                     DomainInfoEntry->SubordinateTo = TlnEntrySup;
                     break;
                 }
            }

            if ( DomainInfoEntry->SubordinateTo != NULL ) {

                break;
            }
        }

        if ( DomainInfoEntry->SubordinateTo == NULL &&
             !DomainInfoEntry->IsAdminDisabled()) {

            //
            // This name is not admin-disabled and
            // does not have a superior TLN.
            // Thus it is invalid.
            //

            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::Insert (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            goto Error;
        }
    }

    //
    // At this point, the newly inserted trusted domain entry is internally
    // consistent.  Code that follows fully assumes this fact.
    //

    //
    // Rules for an enabled top level name record:
    //
    // * Must not be equal to an enabled TLN for another TDO
    // * Must not be subordinate to an enabled TLN for another TDO
    //   unless the other TDO has a corresponding exclusion record
    // * Must not be superior to an enabled TLN for another TDO
    //   unless this TDO has a corresponding exclusion record
    //

    for ( ListEntry = TdoEntryNew->TlnList.Flink;
          ListEntry != &TdoEntryNew->TlnList;
          ListEntry = ListEntry->Flink ) {

        TLN_ENTRY * ThisEntry;

        ThisEntry = TLN_ENTRY::EntryFromTdoEntry( ListEntry );

        if ( ThisEntry->Excluded ) {

            //
            // Nothing to check at the moment (validity was verified above)
            //

            continue;
        }

        //
        // Records that are not enabled are not considered for collision detection
        //

        if ( !ThisEntry->Enabled()) {

            continue;
        }

        for ( LIST_ENTRY * ListEntrySup = ThisEntry->TlnKey->List.Flink;
              ListEntrySup != &ThisEntry->TlnKey->List;
              ListEntrySup = ListEntrySup->Flink ) {

            TLN_ENTRY * OtherEntry;
            TLN_ENTRY * ConflictEntry = NULL;

            OtherEntry = TLN_ENTRY::EntryFromAvlEntry( ListEntrySup );

            //
            // Only interested in entries corresponding to other TDOs
            //

            if ( OtherEntry->TdoEntry == TdoEntryNew ||
                 OtherEntry->TdoEntry == TdoEntryOldOut ) {

                continue;
            }

            //
            // Not interested in excluded entries
            //

            if ( OtherEntry->Excluded ) {

                continue;
            }

            //
            // Not interested in disabled entries
            //

            if ( !OtherEntry->Enabled()) {

                continue;
            }

            //
            // Several types of conflicts are possible:
            //

            //
            // - this forest claims "acme.com"
            // - the other forest also claims "acme.com"
            //

            if ( ThisEntry->SubordinateEntry == NULL &&
                 OtherEntry->SubordinateEntry == NULL ) {

                ConflictEntry = OtherEntry;
            }

            //
            // - this forest claims "acme.com"
            // - the other forest claims "foo.ny.acme.com"
            // - this forest does not disown
            //   either "ny.acme.com" or "foo.ny.acme.com"
            //

            else if ( ThisEntry->SubordinateEntry == NULL &&
                      OtherEntry->SubordinateEntry != NULL ) {

                TLN_ENTRY * SubEntry;

                for ( SubEntry = OtherEntry->SubordinateEntry;
                      SubEntry != NULL;
                      SubEntry = SubEntry->SubordinateEntry ) {

                    if ( ThisEntry->TdoEntry->Excludes( &SubEntry->TlnKey->TopLevelName )) {

                        break;
                    }
                }

                //
                // SubEntry == NULL means the above loop has terminated
                // without having found a matching exclusion record.
                // Hence, this entry is in conflict
                //

                if ( SubEntry == NULL ) {

                    ConflictEntry = OtherEntry;
                }
            }

            //
            // - this forest claims "foo.ny.acme.com"
            // - the other forest claims "acme.com"
            // - the other forest does not disown
            //   either "ny.acme.com" or "foo.ny.acme.com"
            //

            else if ( ThisEntry->SubordinateEntry != NULL &&
                      OtherEntry->SubordinateEntry == NULL ) {

                TLN_ENTRY * SubEntry;

                for ( SubEntry = ThisEntry->SubordinateEntry;
                      SubEntry != NULL;
                      SubEntry = SubEntry->SubordinateEntry ) {

                    if ( OtherEntry->TdoEntry->Excludes( &SubEntry->TlnKey->TopLevelName )) {

                        break;
                    }
                }

                //
                // SubEntry == NULL means the above loop has terminated
                // without having found a matching exclusion record.
                // Hence, this entry is in conflict
                //

                if ( SubEntry == NULL ) {

                    ConflictEntry = OtherEntry;
                }
            }

            if ( ConflictEntry != NULL ) {

                TLN_ENTRY * ConflictThis = ThisEntry;
                TLN_ENTRY * ConflictOther = OtherEntry;

                while ( ConflictThis->SubordinateEntry != NULL ) {

                    ConflictThis = ConflictThis->SubordinateEntry;
                }

                while ( ConflictOther->SubordinateEntry != NULL ) {

                    ConflictOther = ConflictOther->SubordinateEntry;
                }

                Status = AddConflictPair(
                             ConflictPairs,
                             ConflictPairsTotal,
                             ForestTrustTopLevelName,
                             ConflictThis,
                             LSA_TLN_DISABLED_CONFLICT,
                             ForestTrustTopLevelName,
                             ConflictOther,
                             LSA_TLN_DISABLED_CONFLICT
                             );

                if ( !NT_SUCCESS( Status )) {

                    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Insert: AddConflictPair returned 0x%x\n", Status ));
                    goto Error;
                }

                LsapDsDebugOut(( DEB_FTINFO, "Entry %p (index %d) is in conflict with entry %p (%s:%d)\n", ConflictThis, ConflictThis->Index, ConflictOther, __FILE__, __LINE__ ));
            }
        }
    }

    //
    // Rules for an enabled domain information record:
    //
    // * No part of the DNS name must be equal to that of an enabled
    //   top level name corresponding to a different TDO unless the other
    //   TDO explicitly disowns the DNS name of this record
    // * No part must be equal to that of an enabled domain info entry
    //   corresponding to a different TDO
    //

    for ( ListEntry = TdoEntryNew->DomainInfoList.Flink;
          ListEntry != &TdoEntryNew->DomainInfoList;
          ListEntry = ListEntry->Flink ) {

        DOMAIN_INFO_ENTRY * ThisEntry;

        ThisEntry = DOMAIN_INFO_ENTRY::EntryFromTdoEntry( ListEntry );

        //
        // Skip over store-and-ignore entries
        //

        if ( ThisEntry->SubordinateTo == NULL ) {

            ASSERT( ThisEntry->IsAdminDisabled());
            continue;
        }

        //
        // Only consider enabled entries
        //

        if ( !ThisEntry->SubordinateTo->Enabled()) {

            continue;
        }

        //
        // Entries excluded by this TDO are not considered either
        //

        if ( ThisEntry->TdoEntry->Excludes( &ThisEntry->DnsKey->DnsName )) {

            continue;
        }

        //
        // Check for SID conflicts
        //

        if ( ThisEntry->SidEnabled()) {

            for ( LIST_ENTRY * ListEntrySid = ThisEntry->SidKey->List.Flink;
                  ListEntrySid != &ThisEntry->SidKey->List;
                  ListEntrySid = ListEntrySid->Flink ) {

                DOMAIN_INFO_ENTRY * OtherEntry;

                OtherEntry = DOMAIN_INFO_ENTRY::EntryFromSidEntry( ListEntrySid );

                //
                // Skip over store-and-ignore entries
                //

                if ( OtherEntry->SubordinateTo == NULL ) {

                    ASSERT( OtherEntry->IsAdminDisabled());
                    continue;
                }

                //
                // Only interested in entries corresponding to other TDOs
                //

                if ( OtherEntry->TdoEntry == TdoEntryNew ||
                     OtherEntry->TdoEntry == TdoEntryOldOut ) {

                    continue;
                }

                //
                // Only interested in enabled entries
                //

                if ( !OtherEntry->SidEnabled() ||
                     !OtherEntry->SubordinateTo->Enabled()) {

                    continue;
                }

                //
                // Conflict! SID claimed by two forests!
                //

                Status = AddConflictPair(
                             ConflictPairs,
                             ConflictPairsTotal,
                             ForestTrustDomainInfo,
                             ThisEntry,
                             LSA_SID_DISABLED_CONFLICT,
                             ForestTrustDomainInfo,
                             OtherEntry,
                             LSA_SID_DISABLED_CONFLICT
                             );

                if ( !NT_SUCCESS( Status )) {

                    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Insert: AddConflictPair returned 0x%x\n", Status ));
                    goto Error;
                }

                LsapDsDebugOut(( DEB_FTINFO, "FTCache::Insert: Entry %p (index %d) is in conflict with entry %p (%s:%d)\n", ThisEntry, ThisEntry->Index, OtherEntry, __FILE__, __LINE__ ));
            }

            //
            // Cross-check DNS names with Netbios names
            //

            NETBIOS_NAME_KEY * NetbiosKey = ( NETBIOS_NAME_KEY * )RtlLookupElementGenericTableAvl(
                                                                      &m_NetbiosNameTable,
                                                                      &ThisEntry->DnsKey->DnsName
                                                                      );

            if ( NetbiosKey != NULL ) {

                for ( LIST_ENTRY * ListEntryNB = NetbiosKey->List.Flink;
                      ListEntryNB != &NetbiosKey->List;
                      ListEntryNB = ListEntryNB->Flink ) {

                    DOMAIN_INFO_ENTRY * OtherEntry;

                    OtherEntry = DOMAIN_INFO_ENTRY::EntryFromNetbiosEntry( ListEntryNB );

                    //
                    // Skip over store-and-ignore entries
                    //

                    if ( OtherEntry->SubordinateTo == NULL ) {

                        ASSERT( OtherEntry->IsAdminDisabled());
                        continue;
                    }

                    //
                    // Only interested in entries corresponding to other TDOs
                    //

                    if ( OtherEntry->TdoEntry == TdoEntryNew ||
                         OtherEntry->TdoEntry == TdoEntryOldOut ) {

                        continue;
                    }

                    //
                    // Only interested in enabled entries
                    //

                    if ( !OtherEntry->NetbiosEnabled() ||
                         !OtherEntry->SubordinateTo->Enabled()) {

                        continue;
                    }

                    //
                    // Conflict! DNS name claimed by a Netbios name in another forest!
                    //

                    Status = AddConflictPair(
                                 ConflictPairs,
                                 ConflictPairsTotal,
                                 ForestTrustDomainInfo,
                                 ThisEntry,
                                 LSA_SID_DISABLED_CONFLICT,
                                 ForestTrustDomainInfo,
                                 OtherEntry,
                                 LSA_NB_DISABLED_CONFLICT
                                 );

                    if ( !NT_SUCCESS( Status )) {

                        LsapDsDebugOut(( DEB_FTINFO, "FTCache::Insert: AddConflictPair returned 0x%x\n", Status ));
                        goto Error;
                    }

                    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Insert: Entry %p (index %d) is in conflict with entry %p (%s:%d)\n", ThisEntry, ThisEntry->Index, OtherEntry, __FILE__, __LINE__ ));
                }
            }
        }

        //
        // Check for NETBIOS conflicts
        //

        if ( ThisEntry->NetbiosEnabled()) {

            for ( LIST_ENTRY * ListEntryNB = ThisEntry->NetbiosKey->List.Flink;
                  ListEntryNB != &ThisEntry->NetbiosKey->List;
                  ListEntryNB = ListEntryNB->Flink ) {

                DOMAIN_INFO_ENTRY * OtherEntry;

                OtherEntry = DOMAIN_INFO_ENTRY::EntryFromNetbiosEntry( ListEntryNB );

                //
                // Skip over store-and-ignore entries
                //

                if ( OtherEntry->SubordinateTo == NULL ) {

                    ASSERT( OtherEntry->IsAdminDisabled());
                    continue;
                }

                //
                // Only interested in entries corresponding to other TDOs
                //

                if ( OtherEntry->TdoEntry == TdoEntryNew ||
                     OtherEntry->TdoEntry == TdoEntryOldOut ) {

                    continue;
                }

                //
                // Only interested in enabled entries
                //

                if ( !OtherEntry->NetbiosEnabled() ||
                     !OtherEntry->SubordinateTo->Enabled()) {

                    continue;
                }

                //
                // Conflict! Netbios name claimed by two forests!
                //

                Status = AddConflictPair(
                             ConflictPairs,
                             ConflictPairsTotal,
                             ForestTrustDomainInfo,
                             ThisEntry,
                             LSA_NB_DISABLED_CONFLICT,
                             ForestTrustDomainInfo,
                             OtherEntry,
                             LSA_NB_DISABLED_CONFLICT
                             );

                if ( !NT_SUCCESS( Status )) {

                    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Insert: AddConflictPair returned 0x%x\n", Status ));
                    goto Error;
                }

                LsapDsDebugOut(( DEB_FTINFO, "FTCache::Insert: Entry %p (index %d) is in conflict with entry %p (%s:%d)\n", ThisEntry, ThisEntry->Index, OtherEntry, __FILE__, __LINE__ ));
            }

            //
            // Cross-check Netbios names with DNS names
            //

            DNS_NAME_KEY * DnsKey = ( DNS_NAME_KEY * )RtlLookupElementGenericTableAvl(
                                                          &m_DnsNameTable,
                                                          &ThisEntry->NetbiosKey->NetbiosName
                                                          );

            if ( DnsKey != NULL ) {

                for ( LIST_ENTRY * ListEntryDns = DnsKey->List.Flink;
                      ListEntryDns != &DnsKey->List;
                      ListEntryDns = ListEntryDns->Flink ) {

                    DOMAIN_INFO_ENTRY * OtherEntry;

                    OtherEntry = DOMAIN_INFO_ENTRY::EntryFromDnsEntry( ListEntryDns );

                    //
                    // Skip over store-and-ignore entries
                    //

                    if ( OtherEntry->SubordinateTo == NULL ) {

                        ASSERT( OtherEntry->IsAdminDisabled());
                        continue;
                    }

                    //
                    // Only interested in entries corresponding to other TDOs
                    //

                    if ( OtherEntry->TdoEntry == TdoEntryNew ||
                         OtherEntry->TdoEntry == TdoEntryOldOut ) {

                        continue;
                    }

                    //
                    // Only interested in enabled entries
                    //

                    if ( !OtherEntry->SidEnabled() ||
                         !OtherEntry->SubordinateTo->Enabled()) {

                        continue;
                    }

                    //
                    // Conflict! Netbios name claimed by a DNS name in another forest!
                    //

                    Status = AddConflictPair(
                                 ConflictPairs,
                                 ConflictPairsTotal,
                                 ForestTrustDomainInfo,
                                 ThisEntry,
                                 LSA_NB_DISABLED_CONFLICT,
                                 ForestTrustDomainInfo,
                                 OtherEntry,
                                 LSA_SID_DISABLED_CONFLICT
                                 );

                    if ( !NT_SUCCESS( Status )) {

                        LsapDsDebugOut(( DEB_FTINFO, "FTCache::Insert: AddConflictPair returned 0x%x\n", Status ));
                        goto Error;
                    }

                    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Insert: Entry %p (index %d) is in conflict with entry %p (%s:%d)\n", ThisEntry, ThisEntry->Index, OtherEntry, __FILE__, __LINE__ ));
                }
            }
        }
    }

    //
    // At this time, ConflictPairs array contains a
    // complete list of pairs of entries that conflicted
    //

    Status = STATUS_SUCCESS;

Cleanup:

    *TdoEntryNewOut = TdoEntryNew;

    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Insert returning, Status: 0x%x\n", Status ));

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));

    if ( TdoEntryNew ) {

        RollbackChanges( TdoEntryNew, TdoEntryOldOut );
        TdoEntryNew = NULL;
    }

    //
    // Make sure no "old entry" nonsense is returned
    // to the caller in case of error
    //

    ASSERT( TdoEntryOldOut->RecordCount == 0 );

    if ( *ConflictPairs != NULL ) {

        FtcFree( *ConflictPairs );
        *ConflictPairs = NULL;
        *ConflictPairsTotal = 0;
    }

    goto Cleanup;
}



NTSTATUS
FTCache::Remove(
    IN UNICODE_STRING * TrustedDomainName
    )
/*++

Routine Description:

    Removes all entires corresponding to the given trusted domain information
    name from the forest trust cache

Arguments:

    TrustedDomainName     name of the TDO to be wiped from the cache

Returns:

    STATUS_SUCCESS        entries corresponding to the given TDO have been
                          successfully removed

    STATUS_NOT_FOUND      there was no entry by this name in the cache

    STATUS_INVALID_PARAMETER  name of the TDO was invalid

--*/
{
    NTSTATUS Status;
    TDO_ENTRY * TdoEntry = NULL;

    ASSERT( m_Initialized );

    if ( TrustedDomainName == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::Remove\n" ));
        return STATUS_INVALID_PARAMETER;
    }

    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Remove called, TDO: %wZ\n", TrustedDomainName ));

    //
    // Locate the cache entry corresponding to this TDO
    //

    TdoEntry = ( TDO_ENTRY * )RtlLookupElementGenericTableAvl(
                                  &m_TdoTable,
                                  TrustedDomainName
                                  );

    if ( TdoEntry == NULL ) {

        Status = STATUS_NOT_FOUND;
        goto Error;
    }

    RemoveTdoEntry( TdoEntry );

    Status = STATUS_SUCCESS;

Cleanup:

    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Remove returning, Status: 0x%x\n", Status ));

    return Status;

Error:
    ASSERT( !NT_SUCCESS( Status ));
    goto Cleanup;
}



NTSTATUS
FTCache::Retrieve(
    IN UNICODE_STRING * TrustedDomainName,
    OUT LSA_FOREST_TRUST_INFORMATION * * ForestTrustInfo
    )
/*++

Routine Description:

    Retrieves forest trust information corresponding to a given TDO name
    from the forest trust cache

Arguments:

    TrustedDomainName     name of the TDO to be queried

    ForestTrustInfo       used to return forest trust information data
                          for that TDO

Returns:

    STATUS_SUCCESS                 entries corresponding to the given TDO have been
                                   successfully returned

    STATUS_NOT_FOUND               this TDO is not in the cache

    STATUS_INSUFFICIENT_RESOURCES  out of memory

    STATUS_INVALID_PARAMETER       name of the TDO was invalid

    STATUS_INTERNAL_ERROR          the cache is in an inconsistent state

--*/
{
    NTSTATUS Status;
    LIST_ENTRY * ListEntry;
    TDO_ENTRY * TdoEntry = NULL;

    if ( TrustedDomainName == NULL ||
         ForestTrustInfo == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::Retrieve (%s:%d)\n", __FILE__, __LINE__ ));
        return STATUS_INVALID_PARAMETER;
    }

    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Retrieve called, TDO: %wZ\n", TrustedDomainName ));

    *ForestTrustInfo = NULL;

    //
    // If the cache is not valid, do not even bother to proceed
    //

    if ( !IsValid()) {

        LsapDsDebugOut(( DEB_FTINFO, "FTCache::Retrieve called on an invalid cache\n" ));
        Status = STATUS_INTERNAL_ERROR;
        goto Error;
    }

    //
    // Locate the cache entry corresponding to this TDO
    //

    TdoEntry = ( TDO_ENTRY * )RtlLookupElementGenericTableAvl(
                                  &m_TdoTable,
                                  TrustedDomainName
                                  );

    if ( TdoEntry == NULL ) {

        Status = STATUS_NOT_FOUND;
        goto Error;

    } else if ( TdoEntry->LocalForestEntry ) {

        //
        // The caller should ensure that local forest info is not retrieved
        //

        LsapDsDebugOut(( DEB_FTINFO, "FTCache::Retrieve called asking for local trust information\n" ));
        Status = STATUS_NOT_FOUND;
        ASSERT( FALSE );
        goto Error;
    }

    *ForestTrustInfo = ( LSA_FOREST_TRUST_INFORMATION * )FtcAllocate(
                           sizeof( LSA_FOREST_TRUST_INFORMATION )
                           );

    if ( *ForestTrustInfo == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Retrieve (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    (*ForestTrustInfo)->RecordCount = 0;

    (*ForestTrustInfo)->Entries = ( LSA_FOREST_TRUST_RECORD * * )FtcAllocate(
                                      TdoEntry->RecordCount * sizeof( LSA_FOREST_TRUST_RECORD * )
                                      );

    if ( (*ForestTrustInfo)->Entries == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Retrieve (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // Read top level name entries for this TDO
    //

    for ( ListEntry = TdoEntry->TlnList.Flink;
          ListEntry != &TdoEntry->TlnList;
          ListEntry = ListEntry->Flink ) {

        TLN_ENTRY * TlnEntry;
        LSA_FOREST_TRUST_RECORD * Record;

        TlnEntry = TLN_ENTRY::EntryFromTdoEntry( ListEntry );

        if ( TlnEntry->Excluded ||
             TlnEntry->SubordinateEntry == NULL ) {

            Record = RecordFromTopLevelNameEntry( TlnEntry );

            if ( Record == NULL ) {

                LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Retrieve (%s:%d)\n", __FILE__, __LINE__ ));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }

            ASSERT( (*ForestTrustInfo)->RecordCount < TdoEntry->RecordCount );

            (*ForestTrustInfo)->Entries[(*ForestTrustInfo)->RecordCount] = Record;
            (*ForestTrustInfo)->RecordCount += 1;
        }
    }

    //
    // Read domain info entries for this TDO
    //

    for ( ListEntry = TdoEntry->DomainInfoList.Flink;
          ListEntry != &TdoEntry->DomainInfoList;
          ListEntry = ListEntry->Flink ) {

        DOMAIN_INFO_ENTRY * DomainInfoEntry;
        LSA_FOREST_TRUST_RECORD * Record;

        DomainInfoEntry = DOMAIN_INFO_ENTRY::EntryFromTdoEntry( ListEntry );

        Record = RecordFromDomainInfoEntry( DomainInfoEntry );

        if ( Record == NULL ) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Retrieve (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        ASSERT( (*ForestTrustInfo)->RecordCount < TdoEntry->RecordCount );

        (*ForestTrustInfo)->Entries[(*ForestTrustInfo)->RecordCount] = Record;
        (*ForestTrustInfo)->RecordCount += 1;
    }

    //
    // Read binary entries for this TDO
    //

    for ( ListEntry = TdoEntry->BinaryList.Flink;
          ListEntry != &TdoEntry->BinaryList;
          ListEntry = ListEntry->Flink ) {

        BINARY_ENTRY * BinaryEntry;
        LSA_FOREST_TRUST_RECORD * Record;

        BinaryEntry = BINARY_ENTRY::EntryFromTdoEntry( ListEntry );

        Record = RecordFromBinaryEntry( BinaryEntry );

        if ( Record == NULL ) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::Retrieve (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        ASSERT( (*ForestTrustInfo)->RecordCount < TdoEntry->RecordCount );

        (*ForestTrustInfo)->Entries[(*ForestTrustInfo)->RecordCount] = Record;
        (*ForestTrustInfo)->RecordCount += 1;
    }

    ASSERT( (*ForestTrustInfo)->RecordCount == TdoEntry->RecordCount );

    Status = STATUS_SUCCESS;

Cleanup:

    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Retrieve returning, Status: 0x%x\n", Status ));

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));

    LsapFreeForestTrustInfo( *ForestTrustInfo );
    FtcFree( *ForestTrustInfo );
    *ForestTrustInfo = NULL;

    goto Cleanup;
}



NTSTATUS
FTCache::Match(
    IN LSA_ROUTING_MATCH_TYPE Type,
    IN PVOID Data,
    OUT UNICODE_STRING * TrustedDomainName,
    OUT OPTIONAL BOOLEAN * IsLocal
    )
/*++

Routine Description:

    Finds match for given data in the cache

Arguments:

    Type                        Type of Data parameter

    Data                        Data to match

    TrustedDomainName           Used to return the match, if one was found.
                                Caller must use MIDL_user_free.

    IsLocal                     Used to report if the match is a name within
                                the local forest

Returns:

    STATUS_SUCCESS              Match was found

    STATUS_NO_MATCH             Match was not found

    STATUS_INVALID_PARAMETER    Check the inputs

    STATUS_INTERNAL_ERROR       Cache is internally inconsistent

    STATUS_INSUFFICIENT_RESOURCES  Out of memory

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SID * Sid = NULL;
    UNICODE_STRING * String = NULL;

    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Match called\n" ));

    if ( Data == NULL ||
         TrustedDomainName == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::Match (%s:%d)\n", __FILE__, __LINE__ ));
        return STATUS_INVALID_PARAMETER;
    }

    if ( IsLocal ) {

        *IsLocal = FALSE;
    }

    switch ( Type ) {

    case RoutingMatchDomainSid:

        Sid = ( SID * )Data;

        if ( !RtlValidSid( Sid )) {

            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::Match (%s:%d)\n", __FILE__, __LINE__ ));
            return STATUS_INVALID_PARAMETER;
        }

        break;

    case RoutingMatchDomainName:
    case RoutingMatchUpn:
    case RoutingMatchSpn:

        String = ( UNICODE_STRING * )Data;

        if ( !LsapValidateLsaUnicodeString( String )) {

            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::Match (%s:%d)\n", __FILE__, __LINE__ ));
            return STATUS_INVALID_PARAMETER;
        }

        //
        // ISSUE-2000/07/24-markpu
        // is it appopriate to modify UPNs and SPNs prior to matching?
        //

        LsapRemoveTrailingDot( String, FALSE );
        break;

    default:

        LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::Match (%s:%d)\n", __FILE__, __LINE__ ));
        return STATUS_INVALID_PARAMETER;
    }

    LsapDbAcquireReadLockTrustedDomainList();

    if ( !IsValid()) {

        //
        // Cache is invalid - attempt to rebuild
        //

        if ( LsapDbDcInRootDomain()) {

            LsapDbConvertReadLockTrustedDomainListToExclusive();

            Status = LsapDbBuildTrustedDomainCache();

            LsapDbConvertWriteLockTrustedDomainListToShared();

        } else if ( SamIAmIGC()) {

            LsapDbConvertReadLockTrustedDomainListToExclusive();

            Status = LsapRebuildFtCacheGC();

            LsapDbConvertWriteLockTrustedDomainListToShared();
        }

        if ( !NT_SUCCESS( Status )) {

            LsapDsDebugOut(( DEB_FTINFO, "FTCache::Retrieve: attempt to rebuild the cache failed with 0x%x\n", Status ));
            goto Error;
        }
    }

    //
    // Guard against stack overflows and such
    //

    __try {

        switch ( Type ) {

        case RoutingMatchDomainSid:

            Status = MatchSid( Sid, TrustedDomainName, IsLocal );
            break;

        case RoutingMatchDomainName:

            Status = MatchDnsName( String, TrustedDomainName, IsLocal );

            if ( Status == STATUS_NO_MATCH ) {

                Status = MatchNetbiosName( String, TrustedDomainName, IsLocal );
            }

            break;

        case RoutingMatchUpn:

            Status = MatchUpn( String, TrustedDomainName, IsLocal );
            break;

        case RoutingMatchSpn:

            Status = MatchSpn( String, TrustedDomainName, IsLocal );
            break;

        default:
            ASSERT( FALSE );
        }

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

        Status = GetExceptionCode();
        goto Error;
    }

Cleanup:

    LsapDbReleaseLockTrustedDomainList();

    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Match returning, Status: 0x%lx\n", Status ));

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));
    goto Cleanup;
}


///////////////////////////////////////////////////////////////////////////////
//
// FTCache private methods
//
///////////////////////////////////////////////////////////////////////////////



void
FTCache::Purge()
/*++

Routine Description:

    Removes the contents of the cache

Arguments:

    None

Returns:

    Nothing

--*/
{
    TDO_ENTRY * TdoEntry;

    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Purge called\n" ));

    for ( TdoEntry = ( TDO_ENTRY * )RtlEnumerateGenericTableAvl( &m_TdoTable, TRUE );
          TdoEntry != NULL;
          TdoEntry = ( TDO_ENTRY * )RtlEnumerateGenericTableAvl( &m_TdoTable, TRUE )) {

        RemoveTdoEntry( TdoEntry );
    }

    LsapDsDebugOut(( DEB_FTINFO, "FTCache::Purge returning\n" ));
}



void
FTCache::RollbackChanges(
    IN TDO_ENTRY * TdoEntryNew,
    IN TDO_ENTRY * TdoEntryOld
    )
/*++

Routine Description:


Arguments:

    TdoEntryNew    result of inserting new data into the cache

    TdoEntryOld    old contents of the cache
                   (Record count of 0 indicates no previous contents)

Returns:

    Nothing

--*/
{
    ASSERT( TdoEntryNew );
    ASSERT( TdoEntryOld );

    if ( TdoEntryOld->RecordCount > 0 ) {

        //
        // Reinstate old contents of the entry
        // if the old entry is non-empty
        //

        PurgeTdoEntry( TdoEntryNew );
        CopyTdoEntry( TdoEntryNew, TdoEntryOld );

    } else {

        //
        // Altogether remove the node from the tree
        // if there is nothing to reinstate
        //

        RemoveTdoEntry( TdoEntryNew );
    }

    //
    // We've taken over the old entry.
    // Leave it in an invalid state.
    //

    ZeroMemory( TdoEntryOld, sizeof( TDO_ENTRY ));
}



void
FTCache::PurgeTdoEntry(
    IN TDO_ENTRY * TdoEntry
    )
/*++

Routine Description:

    Cleans up all entries associated with a given TDO entry
    but leaves the other fields alone

Arguments:

    TdoEntry      entry to purge

Returns:

    Nothing

--*/
{
    //
    // Remove TDO entries from the top level name table
    //

    while ( !IsListEmpty( &TdoEntry->TlnList )) {

        TLN_ENTRY * TlnEntry;

        TlnEntry = TLN_ENTRY::EntryFromTdoEntry( TdoEntry->TlnList.Flink );

        RemoveEntryList( &TlnEntry->TdoListEntry );
        RemoveEntryList( &TlnEntry->AvlListEntry );

        ASSERT( TlnEntry->TlnKey );
        TlnEntry->TlnKey->Count -= 1;

        //
        // If this is the last entry for this top level name in the tree,
        // remove the associated key from the list
        //

        if ( IsListEmpty( &TlnEntry->TlnKey->List )) {

            BOOLEAN Found;

            ASSERT( TlnEntry->TlnKey->Count == 0 );

            Found = RtlDeleteElementGenericTableAvl(
                        &m_TopLevelNameTable,
                        &TlnEntry->TlnKey->TopLevelName
                        );

            ASSERT( sm_TlnKeys-- > 0 );
            ASSERT( Found ); // better be there!!!
        }

        FtcFree( TlnEntry );

        ASSERT( sm_TlnEntries-- > 0 );
    }

    //
    // Remove TDO entries from the DomainInfo-related tables
    //

    while ( !IsListEmpty( &TdoEntry->DomainInfoList )) {

        DOMAIN_INFO_ENTRY * DomainInfoEntry;

        DomainInfoEntry = DOMAIN_INFO_ENTRY::EntryFromTdoEntry( TdoEntry->DomainInfoList.Flink );

        RemoveEntryList( &DomainInfoEntry->TdoListEntry );
        RemoveEntryList( &DomainInfoEntry->SidAvlListEntry );
        RemoveEntryList( &DomainInfoEntry->DnsAvlListEntry );
        RemoveEntryList( &DomainInfoEntry->NetbiosAvlListEntry );

        ASSERT( DomainInfoEntry->SidKey );
        DomainInfoEntry->SidKey->Count -= 1;

        //
        // If this is the last entry for the domain SID in the tree,
        // remove the associated key from the list
        //

        if ( IsListEmpty( &DomainInfoEntry->SidKey->List )) {

            BOOLEAN Found;

            ASSERT( DomainInfoEntry->SidKey->Count == 0 );

            Found = RtlDeleteElementGenericTableAvl(
                        &m_DomainSidTable,
                        &DomainInfoEntry->SidKey->DomainSid
                        );

            ASSERT( sm_SidKeys-- > 0 );
            ASSERT( Found ); // better be there!
        }

        ASSERT( DomainInfoEntry->DnsKey );
        DomainInfoEntry->DnsKey->Count -= 1;

        //
        // If this is the last entry for the DNS name in the tree,
        // remove the associated key from the list
        //

        if ( IsListEmpty( &DomainInfoEntry->DnsKey->List )) {

            BOOLEAN Found;

            ASSERT( DomainInfoEntry->DnsKey->Count == 0 );

            Found = RtlDeleteElementGenericTableAvl(
                        &m_DnsNameTable,
                        &DomainInfoEntry->DnsKey->DnsName
                        );

            ASSERT( sm_DnsNameKeys-- > 0 );
            ASSERT( Found ); // better be there!
        }

        if ( DomainInfoEntry->NetbiosKey != NULL ) {

            DomainInfoEntry->NetbiosKey->Count -= 1;

            //
            // If this is the last entry for the DNS name in the tree,
            // remove the associated key from the list
            //

            if ( IsListEmpty( &DomainInfoEntry->NetbiosKey->List )) {

                BOOLEAN Found;

                ASSERT( DomainInfoEntry->NetbiosKey->Count == 0 );

                Found = RtlDeleteElementGenericTableAvl(
                            &m_NetbiosNameTable,
                            &DomainInfoEntry->NetbiosKey->NetbiosName
                            );

                ASSERT( sm_NetbiosNameKeys-- > 0 );
                ASSERT( Found ); // better be there!
            }
        }

        FtcFree( DomainInfoEntry->Sid );
        FtcFree( DomainInfoEntry );

        ASSERT( sm_DomainInfoEntries-- > 0 );
    }

    //
    // Remove binary entries for this TDO
    //

    while ( !IsListEmpty( &TdoEntry->BinaryList )) {

        BINARY_ENTRY * BinaryEntry;

        BinaryEntry = BINARY_ENTRY::EntryFromTdoEntry( TdoEntry->BinaryList.Flink );

        RemoveEntryList( &BinaryEntry->TdoListEntry );

        FtcFree( BinaryEntry->Data.Buffer );
        FtcFree( BinaryEntry );

        ASSERT( sm_BinaryEntries-- > 0 );
    }

    //
    // This entry no longer contains anything of interest
    //

    TdoEntry->RecordCount = 0;

    FtcFree( TdoEntry->TrustedDomainSid );
    TdoEntry->TrustedDomainSid = NULL;

    ASSERT( IsListEmpty( &TdoEntry->TlnList ));
    ASSERT( IsListEmpty( &TdoEntry->DomainInfoList ));
    ASSERT( IsListEmpty( &TdoEntry->BinaryList ));
}



void
FTCache::RemoveTdoEntry(
    IN TDO_ENTRY * TdoEntry
    )
/*++

Routine Description:

    Removes the corresponding TdoEntry and all its associated data from the cache

Arguments:

    TdoEntry        Entry to remove

Returns:

    Nothing

--*/
{
    BOOLEAN Found;

    ASSERT( TdoEntry );

    LsapDsDebugOut(( DEB_FTINFO, "FTCache::RemoveTdoEntry called, TdoEntry is %p\n", TdoEntry ));

    PurgeTdoEntry( TdoEntry );

    //
    // Remove the cache entry from the list and free it
    //

    Found = RtlDeleteElementGenericTableAvl(
                &m_TdoTable,
                &TdoEntry->TrustedDomainName
                );

    ASSERT( sm_TdoEntries-- > 0 );
    ASSERT( Found );

    LsapDsDebugOut(( DEB_FTINFO, "FTCache::RemoveTdoEntry returning\n" ));
}



void
FTCache::CopyTdoEntry(
    IN TDO_ENTRY * Destination,
    IN TDO_ENTRY * Source
    )
/*++

Routine Description:

    Creates a temporary copy of a TDO entry, the copy is used in rollback code.
    No new memory is allocated, the data is merely stored away for a while.

Arguments:

    Destination       Entry to fill in

    Source            Entry to get the data from

Returns:

    Nothing

--*/
{
    LIST_ENTRY * ListEntry;

    *Destination = *Source;

    //
    // Make the list entries point to the backup copy of the TDO entry
    // (we're about to reuse the contents of *Source)
    //

    if ( IsListEmpty( &Source->TlnList )) {

        InitializeListHead( &Destination->TlnList );

    } else {

        Destination->TlnList.Flink->Blink = &Destination->TlnList;
        Destination->TlnList.Blink->Flink = &Destination->TlnList;
    }

    if ( IsListEmpty( &Source->DomainInfoList )) {

        InitializeListHead( &Destination->DomainInfoList );

    } else {

        Destination->DomainInfoList.Flink->Blink = &Destination->DomainInfoList;
        Destination->DomainInfoList.Blink->Flink = &Destination->DomainInfoList;
    }

    if ( IsListEmpty( &Source->BinaryList )) {

        InitializeListHead( &Destination->BinaryList );

    } else {

        Destination->BinaryList.Flink->Blink = &Destination->BinaryList;
        Destination->BinaryList.Blink->Flink = &Destination->BinaryList;
    }

    //
    // Point all the "TdoEntry" member variables of all components to
    // Destination so there is no confusion when testing for duplicates
    //

    for ( ListEntry = Destination->TlnList.Flink;
          ListEntry != &Destination->TlnList;
          ListEntry = ListEntry->Flink ) {

        TLN_ENTRY * TlnEntry;

        TlnEntry = TLN_ENTRY::EntryFromTdoEntry( ListEntry );

        TlnEntry->TdoEntry = Destination;
    }

    for ( ListEntry = Destination->DomainInfoList.Flink;
          ListEntry != &Destination->DomainInfoList;
          ListEntry = ListEntry->Flink ) {

        DOMAIN_INFO_ENTRY * DomainInfoEntry;

        DomainInfoEntry = DOMAIN_INFO_ENTRY::EntryFromTdoEntry( ListEntry );

        DomainInfoEntry->TdoEntry = Destination;
    }
}



LSA_FOREST_TRUST_RECORD *
FTCache::RecordFromTopLevelNameEntry(
    IN TLN_ENTRY * Entry
    )
/*++

Routine Description:

    Creates a forest trust record structure from a top level name entry

Arguments:

    Entry       top level name entry to convert

Returns:

    Allocated top level name record or NULL if out of memory

--*/
{
    LSA_FOREST_TRUST_RECORD * Record;

    ASSERT( Entry->Excluded ||
            Entry->SubordinateEntry == NULL );

    Record = ( LSA_FOREST_TRUST_RECORD * )FtcAllocate(
                 sizeof( LSA_FOREST_TRUST_RECORD )
                 );

    if ( Record == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::RecordFromTopLevelEntry (%s:%d)\n", __FILE__, __LINE__ ));
        goto Error;
    }

    Record->Time = Entry->Time;
    Record->Flags = Entry->Flags();
    Record->ForestTrustType = Entry->Excluded ?
                                 ForestTrustTopLevelNameEx :
                                 ForestTrustTopLevelName;

    if ( FALSE == FtcCopyUnicodeString(
                      &Record->ForestTrustData.TopLevelName,
                      &Entry->TlnKey->TopLevelName )) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::RecordFromTopLevelEntry (%s:%d)\n", __FILE__, __LINE__ ));
        goto Error;
    }

Cleanup:

    return Record;

Error:

    FtcFree( Record );
    Record = NULL;
    goto Cleanup;
}



LSA_FOREST_TRUST_RECORD *
FTCache::RecordFromDomainInfoEntry(
    IN DOMAIN_INFO_ENTRY * Entry
    )
/*++

Routine Description:

    Creates a forest trust record structure from a domain info entry

Arguments:

    Entry       domain info entry to convert

Returns:

    Allocated domain info record or NULL if out of memory

--*/
{
    LSA_FOREST_TRUST_RECORD * Record;
    ULONG SidLength;

    Record = ( LSA_FOREST_TRUST_RECORD * )FtcAllocate(
                 sizeof( LSA_FOREST_TRUST_RECORD )
                 );

    if ( Record == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::RecordFromDomainInfoEntry (%s:%d)\n", __FILE__, __LINE__ ));
        goto Error;
    }

    ASSERT( RtlValidSid( Entry->Sid ));

    SidLength = RtlLengthSid( Entry->Sid );

    ASSERT( SidLength > 0 );

    Record->Time = Entry->Time;
    Record->Flags = Entry->Flags();
    Record->ForestTrustType = ForestTrustDomainInfo;

    Record->ForestTrustData.DomainInfo.Sid = ( SID * )FtcAllocate( SidLength );

    if ( Record->ForestTrustData.DomainInfo.Sid == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::RecordFromDomainInfoEntry (%s:%d)\n", __FILE__, __LINE__ ));
        goto Error;
    }

    RtlCopySid( SidLength, ( SID * )Record->ForestTrustData.DomainInfo.Sid, Entry->Sid );

    if ( FALSE == FtcCopyUnicodeString(
                      ( UNICODE_STRING * )&Record->ForestTrustData.DomainInfo.DnsName,
                      &Entry->DnsKey->DnsName )) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::RecordFromDomainInfoEntry (%s:%d)\n", __FILE__, __LINE__ ));
        FtcFree( Record->ForestTrustData.DomainInfo.Sid );
        goto Error;
    }

    if ( Entry->NetbiosKey != NULL ) {

        if ( FALSE == FtcCopyUnicodeString(
                          ( UNICODE_STRING * )&Record->ForestTrustData.DomainInfo.NetbiosName,
                          &Entry->NetbiosKey->NetbiosName )) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::RecordFromDomainInfoEntry (%s:%d)\n", __FILE__, __LINE__ ));
            FtcFree( Record->ForestTrustData.DomainInfo.DnsName.Buffer );
            FtcFree( Record->ForestTrustData.DomainInfo.Sid );
            goto Error;
        }

    } else {

        Record->ForestTrustData.DomainInfo.NetbiosName.Buffer = NULL;
        Record->ForestTrustData.DomainInfo.NetbiosName.Length = 0;
        Record->ForestTrustData.DomainInfo.NetbiosName.MaximumLength = 0;
    }

Cleanup:

    return Record;

Error:

    FtcFree( Record );
    Record = NULL;
    goto Cleanup;
}



LSA_FOREST_TRUST_RECORD *
FTCache::RecordFromBinaryEntry(
    IN BINARY_ENTRY * Entry
    )
/*++

Routine Description:

    Creates a forest trust record structure from a binary entry

Arguments:

    Entry       binary entry to convert

Returns:

    Allocated binary record or NULL if out of memory

--*/
{
    LSA_FOREST_TRUST_RECORD * Record;

    Record = ( LSA_FOREST_TRUST_RECORD * )FtcAllocate(
                 sizeof( LSA_FOREST_TRUST_RECORD )
                 );

    if ( Record == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::RecordFromBinaryEntry (%s:%d)\n", __FILE__, __LINE__ ));
        goto Error;
    }

    Record->Flags = Entry->Flags();
    Record->ForestTrustType = Entry->Type;

    Record->ForestTrustData.Data.Length = Entry->Data.Length;

    if ( Entry->Data.Length > 0 ) {

        Record->ForestTrustData.Data.Buffer = ( BYTE * )FtcAllocate( Entry->Data.Length );

        if ( Record->ForestTrustData.Data.Buffer == NULL ) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::RecordFromBinaryEntry (%s:%d)\n", __FILE__, __LINE__ ));
            goto Error;
        }

        RtlCopyMemory(
            Record->ForestTrustData.Data.Buffer,
            Entry->Data.Buffer,
            Entry->Data.Length
            );

    } else {

        Record->ForestTrustData.Data.Buffer = NULL;
    }

Cleanup:

    return Record;

Error:

    FtcFree( Record );
    Record = NULL;
    goto Cleanup;
}



NTSTATUS
FTCache::MatchSid(
    IN SID * Sid,
    OUT UNICODE_STRING * TrustedDomainName,
    OUT OPTIONAL BOOLEAN * IsLocal
    )
/*++

Routine Description:

    Locates a match for the given SID in the cache

Arguments:

    Sid                   SID to match

    TrustedDomainName     Used to return the name of the trusted domain name

    IsLocal               Used to report if the match is a name within
                          the local forest

Returns:

    STATUS_SUCCESS                 Match was found

    STATUS_NO_MATCH                Match was not found

    STATUS_INSUFFICIENT_RESOURCES  Out of memory

    STATUS_INVALID_PARAMETER       Sid passed in not valid

    STATUS_INVALID_SID             Sid passed in not a valid account SID

    STATUS_BUFFER_OVERFLOW         Sid too long

--*/
{
    NTSTATUS Status;
    DOMAIN_SID_KEY * SidKey;
    UNICODE_STRING * Match = NULL;
    DWORD SidBuffer[256];
    DWORD cbSid = sizeof( SidBuffer );
    PSID DomainSid = ( PSID )SidBuffer;

    //
    // Caller must validate parameters
    //

    ASSERT( Sid );
    ASSERT( RtlValidSid( Sid ));
    ASSERT( IsValid());

    if ( FALSE == GetWindowsAccountDomainSid(
                      Sid,
                      SidBuffer,
                      &cbSid )) {

        DWORD ErrorCode = GetLastError();

        switch( ErrorCode ) {

        case ERROR_INVALID_SID:

            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::MatchSid (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            break;

        case ERROR_INVALID_PARAMETER:

            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::MatchSid (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            break;

        case ERROR_NON_ACCOUNT_SID:

            Status = STATUS_INVALID_SID;
            break;

        case ERROR_INSUFFICIENT_BUFFER:

            Status = STATUS_BUFFER_OVERFLOW;
            break;

        default:

            ASSERT( FALSE ); // map the error code
            Status = ErrorCode;
            break;
        }

        goto Error;
    }

    SidKey = ( DOMAIN_SID_KEY * )RtlLookupElementGenericTableAvl(
                                     &m_DomainSidTable,
                                     &DomainSid
                                     );

    if ( SidKey == NULL ) {

        Status = STATUS_NO_MATCH;
        goto Error;
    }

    for ( LIST_ENTRY * ListEntry = SidKey->List.Flink;
          ListEntry != &SidKey->List;
          ListEntry = ListEntry->Flink ) {

        DOMAIN_INFO_ENTRY * DomainInfoEntry;

        DomainInfoEntry = DOMAIN_INFO_ENTRY::EntryFromSidEntry( ListEntry );

        //
        // Skip over store-and-ignore entries
        //

        if ( DomainInfoEntry->SubordinateTo == NULL ) {

            ASSERT( DomainInfoEntry->IsAdminDisabled());
            continue;
        }

        //
        // Conditions for an entry to be considered a match:
        //
        // - Entry must be enabled
        // - corresponding top-level entry must be enabled
        // - this entry must not be disowned by its TDO
        //

        if ( DomainInfoEntry->SidEnabled() &&
             DomainInfoEntry->SubordinateTo->Enabled() &&
             !DomainInfoEntry->TdoEntry->Excludes( &DomainInfoEntry->DnsKey->DnsName )) {

            ASSERT( Match == NULL ); // ensure only 1 match (see below)

            Match = &DomainInfoEntry->TdoEntry->TrustedDomainName;

            if ( IsLocal ) {

                *IsLocal = DomainInfoEntry->TdoEntry->LocalForestEntry;
            }

#if !DBG // DBG builds should continue through the loop to ensure only 1 match
            break;
#endif
        }
    }

    if ( Match == NULL ) {

        Status = STATUS_NO_MATCH;
        goto Error;

    } else if ( !FtcCopyUnicodeString( TrustedDomainName, Match )) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::MatchSid (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));
    goto Cleanup;
}



NTSTATUS
FTCache::MatchDnsName(
    IN UNICODE_STRING * Name,
    OUT UNICODE_STRING * TrustedDomainName,
    OUT OPTIONAL BOOLEAN * IsLocal
    )
/*++

Routine Description:

    Locates a match for the given DNS in the cache

Arguments:

    Name                           DNS name to match

    TrustedDomainName              Used to return the name of the trusted domain name

    IsLocal                        Used to report if the match is a name within
                                   the local forest

Returns:

    STATUS_SUCCESS                 Match was found

    STATUS_NO_MATCH                Match was not found

    STATUS_INSUFFICIENT_RESOURCES  Out of memory

--*/
{
    NTSTATUS Status;
    DNS_NAME_KEY * DnsKey;
    UNICODE_STRING * Match = NULL;

    //
    // Caller must validate parameters
    //

    ASSERT( Name );
    ASSERT( LsapValidateLsaUnicodeString( Name ));
    ASSERT( IsValid());

    DnsKey = ( DNS_NAME_KEY * )RtlLookupElementGenericTableAvl(
                                   &m_DnsNameTable,
                                   Name
                                   );

    if ( DnsKey == NULL ) {

        Status = STATUS_NO_MATCH;
        goto Error;
    }

    for ( LIST_ENTRY * ListEntry = DnsKey->List.Flink;
          ListEntry != &DnsKey->List;
          ListEntry = ListEntry->Flink ) {

        DOMAIN_INFO_ENTRY * DomainInfoEntry;

        DomainInfoEntry = DOMAIN_INFO_ENTRY::EntryFromDnsEntry( ListEntry );

        //
        // Conditions for an entry to be considered a match:
        //
        // - Entry must be enabled
        // - corresponding top-level entry must be enabled
        // - this entry must not be disowned by its TDO
        //

        if ( DomainInfoEntry->SidEnabled() &&
             DomainInfoEntry->SubordinateTo->Enabled() &&
             !DomainInfoEntry->TdoEntry->Excludes( &DomainInfoEntry->DnsKey->DnsName )) {

            ASSERT( Match == NULL ); // ensure only 1 match (see below)

            Match = &DomainInfoEntry->TdoEntry->TrustedDomainName;

            if ( IsLocal ) {

                *IsLocal = DomainInfoEntry->TdoEntry->LocalForestEntry;
            }

#if !DBG // DBG builds should continue through the loop to ensure only 1 match
            break;
#endif
        }
    }

    if ( Match == NULL ) {

        Status = STATUS_NO_MATCH;
        goto Error;

    } else if ( !FtcCopyUnicodeString( TrustedDomainName, Match )) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::MatchDnsName (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));
    goto Cleanup;
}



NTSTATUS
FTCache::MatchNetbiosName(
    IN UNICODE_STRING * Name,
    OUT UNICODE_STRING * TrustedDomainName,
    OUT OPTIONAL BOOLEAN * IsLocal
    )
/*++

Routine Description:

    Locates a match for the given NetBios name in the cache

Arguments:

    Name                           NetBios name to match

    TrustedDomainName              Used to return the name of the trusted domain name

    IsLocal                        Used to report if the match is a name within
                                   the local forest

Returns:

    STATUS_SUCCESS                 Match was found

    STATUS_NO_MATCH                Match was not found

    STATUS_INSUFFICIENT_RESOURCES  Out of memory

--*/
{
    NTSTATUS Status;
    NETBIOS_NAME_KEY * NetbiosKey;
    UNICODE_STRING * Match = NULL;

    //
    // Caller must validate parameters
    //

    ASSERT( Name );
    ASSERT( LsapValidateLsaUnicodeString( Name ));
    ASSERT( IsValid());

    NetbiosKey = ( NETBIOS_NAME_KEY * )RtlLookupElementGenericTableAvl(
                                           &m_NetbiosNameTable,
                                           Name
                                           );

    if ( NetbiosKey == NULL ) {

        Status = STATUS_NO_MATCH;
        goto Error;
    }

    for ( LIST_ENTRY * ListEntry = NetbiosKey->List.Flink;
          ListEntry != &NetbiosKey->List;
          ListEntry = ListEntry->Flink ) {

        DOMAIN_INFO_ENTRY * DomainInfoEntry;

        DomainInfoEntry = DOMAIN_INFO_ENTRY::EntryFromNetbiosEntry( ListEntry );

        //
        // Skip over store-and-ignore entries
        //

        if ( DomainInfoEntry->SubordinateTo == NULL ) {

            ASSERT( DomainInfoEntry->IsAdminDisabled());
            continue;
        }

        //
        // Conditions for a netbios entry to be considered a match:
        //
        // - Entry must be enabled
        // - Netbios portion must be enabled
        // - corresponding top-level entry must be enabled
        // - this entry must not be disowned by its TDO
        //

        if ( DomainInfoEntry->NetbiosEnabled() &&
             DomainInfoEntry->SubordinateTo->Enabled() &&
             !DomainInfoEntry->TdoEntry->Excludes( &DomainInfoEntry->DnsKey->DnsName )) {

            ASSERT( Match == NULL ); // ensure only 1 match (see below)

            Match = &DomainInfoEntry->TdoEntry->TrustedDomainName;

            if ( IsLocal ) {

                *IsLocal = DomainInfoEntry->TdoEntry->LocalForestEntry;
            }

#if !DBG // DBG builds should continue through the loop to ensure only 1 match
            break;
#endif
        }
    }

    if ( Match == NULL ) {

        Status = STATUS_NO_MATCH;
        goto Error;

    } else if ( !FtcCopyUnicodeString( TrustedDomainName, Match )) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::MatchNetbiosName (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));
    goto Cleanup;
}



NTSTATUS
FTCache::MatchUpn(
    IN UNICODE_STRING * Name,
    OUT UNICODE_STRING * TrustedDomainName,
    OUT OPTIONAL BOOLEAN * IsLocal
    )
/*++

Routine Description:

    Locates a match for the given UPN in the cache.

    UPNs are parsed to select the suffix to the right of the rightmost "@" symbol.
    Suffix is compared with the NscValue from FTInfo records of type TLN.
    A substring comparision is performed.

    o The suffix must be equal to, or subordinate to, the value in the TLN record.
    o The suffix must be compared against all external TLN records and the
      longest substring match wins.
    o If the suffix is equal to, or subordinate to, a TlnExclusion record, no
      match is possible for that particular forest TDO.

Arguments:

    Name                           UPN to match

    TrustedDomainName              Used to return the name of the trusted domain name

    IsLocal                        Used to report if the match is a name within
                                   the local forest

Returns:

    STATUS_SUCCESS                 Match was found

    STATUS_NO_MATCH                Match was not found

    STATUS_INSUFFICIENT_RESOURCES  Out of memory

    STATUS_INVALID_PARAMETER       The UPN is malformed

--*/
{
    NTSTATUS Status;
    TLN_KEY * TlnKey = NULL;
    UNICODE_STRING Suffix = { 0 };
    TLN_ENTRY * MatchingTln;
    SHORT Index;

    //
    // Caller must validate parameters
    //

    ASSERT( Name );
    ASSERT( LsapValidateLsaUnicodeString( Name ));
    ASSERT( IsValid());

    //
    // Extract the suffix from the UPN
    //

    for ( Index = Name->Length / 2 - 1;
          Index >= 0;
          Index -= 1 ) {

        if ( Name->Buffer[Index] == L'@' ) {

            Index += 1;
            Suffix.Length = Name->Length - Index * sizeof( WCHAR );
            Suffix.MaximumLength = Suffix.Length;
            Suffix.Buffer = &Name->Buffer[Index];
            break;
        }
    }

    //
    // Reject '@' at beginning or end of UPN, or UPNs with missing '@'
    //

    if ( Index == 0 || Index == 1 || Index == Name->Length / 2 ) {

        LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::MatchUpn (%s:%d)\n", __FILE__, __LINE__ ));
        return STATUS_INVALID_PARAMETER;
    }

    MatchingTln = LongestSubstringMatchTln( &Suffix, IsLocal );

    if ( MatchingTln == NULL ) {

        Status = STATUS_NO_MATCH;
        goto Error;

    } else if ( !FtcCopyUnicodeString(
                     TrustedDomainName,
                     &MatchingTln->TdoEntry->TrustedDomainName )) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::MatchUpn (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));
    goto Cleanup;
}



NTSTATUS
FTCache::MatchSpn(
    IN UNICODE_STRING * Name,
    OUT UNICODE_STRING * TrustedDomainName,
    OUT OPTIONAL BOOLEAN * IsLocal
    )
/*++

Routine Description:

    Locates a match for the given SPN in the cache

    SPNs are the most complicated name form to parse and match.  The matching
    function parses the name starting from the right and proceeds in the
    following order until it gets the first match, or exhausts all possibilities.

   >Domain component is found:  Either the Kerberos client or the KDC will
    probably be able to route the request.  If not, the matching function is
    called.

    The suffix to the right of the "@" is compared against FTInfo records of
    type TLN, using a substring comparison.

    o The suffix must be equal to, or subordinate to, the value in the TLN record.
    o The suffix must be compared against all external TLN records and the
      longest substring match wins.
    o If the suffix is equal to, or subordinate to, a TlnExclusion record, no
      match is possible for that particular forest TDO.

    The next component to the left, ServiceName or InstanceName, is subjected
    to the same substring comparison.

    Both tests must generate a match, and both results must point to the same
    forest TDO.  Otherwise, no match is returned to the caller.

   >ServiceName component is found first:  Uses same substring comparison
    described above.

    The entire ServiceName value is compared against FTInfo records of type TLN.

   >InstanceName component is found first: Uses same substring comparison
    described above.

    The entire InstanceName value is compared against FTInfo records of type TLN.

Arguments:

    Name                           SPN to match

    TrustedDomainName              Used to return the name of the trusted domain name

    IsLocal                        Used to report if the match is a name within
                                   the local forest

Returns:

    STATUS_SUCCESS                 Match was found

    STATUS_NO_MATCH                Match was not found

    STATUS_INSUFFICIENT_RESOURCES  Out of memory

--*/
{
    NTSTATUS Status;
    UNICODE_STRING * Match = NULL;
    WCHAR InstanceBuffer[ DNS_MAX_NAME_LENGTH + 1 ];
    WCHAR DomainBuffer[ DNS_MAX_NAME_LENGTH + 1 ];
    WCHAR RealmBuffer[ DNS_MAX_NAME_LENGTH + 1 ];
    DWORD InstanceLength = DNS_MAX_NAME_LENGTH + 1;
    DWORD DomainLength = DNS_MAX_NAME_LENGTH + 1;
    DWORD RealmLength = DNS_MAX_NAME_LENGTH + 1;

    UNICODE_STRING Instance = {0};
    UNICODE_STRING Domain = {0};
    UNICODE_STRING Realm = {0};

    //
    // Caller must validate parameters
    //

    ASSERT( Name );
    ASSERT( LsapValidateLsaUnicodeString( Name ));
    ASSERT( IsValid());

    //
    // Dissect the SPN into its constituent components
    //

    Status = DsCrackSpn3W(
                 Name->Buffer,
                 Name->Length / sizeof( WCHAR ),
                 NULL,            // service class (don't care)
                 NULL,            // service class (don't care)
                 &InstanceLength,
                 InstanceBuffer,
                 NULL,            // instance port (don't care)
                 &DomainLength,
                 DomainBuffer,
                 &RealmLength,
                 RealmBuffer
                 );

    if ( Status == ERROR_INVALID_PARAMETER ) {

        LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::MatchSpn (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INVALID_PARAMETER;

    } else if ( Status == ERROR_BUFFER_OVERFLOW ) {

        Status = STATUS_BUFFER_OVERFLOW;

    } else if ( Status != ERROR_SUCCESS ) {

        //
        // This assert will fire if DsCrackSpn3W returns
        // an unrecognized ERROR_ code (need to map to STATUS_ code)
        //

        ASSERT( FALSE );
    }

    if ( Status != STATUS_SUCCESS ) {

        goto Error;
    }

    //
    // Instance name and service name lengths include terminators
    //

    ASSERT( InstanceLength > 0 );
    ASSERT( DomainLength > 0 );
    ASSERT( RealmLength > 0 );

    InstanceLength--;
    DomainLength--;
    RealmLength--;

    Instance.Length = ( USHORT )InstanceLength * sizeof( WCHAR );
    Instance.MaximumLength = Instance.Length + sizeof( WCHAR );
    Instance.Buffer = InstanceBuffer;

    Domain.Length = ( USHORT )DomainLength * sizeof( WCHAR );
    Domain.MaximumLength = Domain.Length + sizeof( WCHAR );
    Domain.Buffer = DomainBuffer;

    Realm.Length = ( USHORT )RealmLength * sizeof( WCHAR );
    Realm.MaximumLength = Realm.Length + sizeof( WCHAR );
    Realm.Buffer = RealmBuffer;

    //
    // Case 1: Domain name (realm) is present
    //

    if ( Realm.Length > 0 ) {

        TLN_ENTRY * MatchRealm;  // match for realm name component
        TLN_ENTRY * MatchOther;  // match for the other (domain or instance) component

        MatchRealm = LongestSubstringMatchTln( &Realm, IsLocal );

        if ( MatchRealm == NULL ) {

            Status = STATUS_NO_MATCH;
            goto Error;

        } else if ( Domain.Length > 0 ) {

            MatchOther = LongestSubstringMatchTln( &Domain, IsLocal );

        } else if ( Instance.Length > 0 ) {

            MatchOther = LongestSubstringMatchTln( &Instance, IsLocal );

        } else {

            MatchOther = NULL;
        }

        if ( MatchOther == NULL ) {

            Status = STATUS_NO_MATCH;
            goto Error;

        } else if ( MatchRealm->TdoEntry != MatchOther->TdoEntry ) {

            Status = STATUS_NO_MATCH;
            goto Error;

        } else if ( !FtcCopyUnicodeString(
                         TrustedDomainName,
                         &MatchRealm->TdoEntry->TrustedDomainName )) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::MatchSpn (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        ASSERT( TrustedDomainName->Buffer );

    } else if ( Domain.Length > 0 ) {

        TLN_ENTRY * Match;

        Match = LongestSubstringMatchTln( &Domain, IsLocal );

        if ( Match == NULL ) {

            Status = STATUS_NO_MATCH;
            goto Error;

        } else if ( !FtcCopyUnicodeString(
                         TrustedDomainName,
                         &Match->TdoEntry->TrustedDomainName )) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::MatchSpn (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        ASSERT( TrustedDomainName->Buffer );

    } else if ( Instance.Length > 0 ) {

        TLN_ENTRY * Match;

        Match = LongestSubstringMatchTln( &Instance, IsLocal );

        if ( Match == NULL ) {

            Status = STATUS_NO_MATCH;
            goto Error;

        } else if ( !FtcCopyUnicodeString(
                         TrustedDomainName,
                         &Match->TdoEntry->TrustedDomainName )) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::MatchSpn (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        ASSERT( TrustedDomainName->Buffer );
    }

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));
    goto Cleanup;
}



FTCache::TLN_ENTRY *
FTCache::LongestSubstringMatchTln(
    IN UNICODE_STRING * String,
    OUT OPTIONAL BOOLEAN * IsLocal
    )
/*++

Routine Description:

    Finds a longest substring match to a given string
    among all the enabled TLN records.

Arguments:

    String           string to match.  must not be NULL.

    IsLocal          Used to report if the match is a name within
                     the local forest

Returns:

    NULL if no match,
    a pointer to a TLN entry otherwise

--*/
{
    TLN_ENTRY * Match = NULL;

    ASSERT( String );

    for ( UNICODE_STRING Temp = *String;
          Temp.Length > 0;
          NextDnsComponent( &Temp )) {

        TLN_KEY * TlnKey = ( TLN_KEY * )RtlLookupElementGenericTableAvl(
                                            &m_TopLevelNameTable,
                                            &Temp
                                            );

        if ( TlnKey == NULL ) {

            continue;
        }

        for ( LIST_ENTRY * ListEntry = TlnKey->List.Flink;
              ListEntry != &TlnKey->List;
              ListEntry = ListEntry->Flink ) {

            TLN_ENTRY * TlnEntry;

            TlnEntry = TLN_ENTRY::EntryFromAvlEntry( ListEntry );

            //
            // Skip over excluded entries
            //

            if ( TlnEntry->Excluded ) {

                continue;
            }

            //
            // Conditions for a top level entry to be considered a match:
            //
            // - Entry must be enabled
            // - Entry must not be a pseudo entry
            // - the string must not be disowned by the entry's TDO
            //

            if ( TlnEntry->Enabled() &&
                 TlnEntry->SubordinateEntry == NULL &&
                 !TlnEntry->TdoEntry->Excludes( String )) {

                ASSERT( Match == NULL ); // ensure only 1 match (see below)

                Match = TlnEntry;

                if ( IsLocal ) {

                    *IsLocal = TlnEntry->TdoEntry->LocalForestEntry;
                }

#if !DBG // DBG builds should continue through the loop to ensure only 1 match
                break;
#endif
            }
        }

        if ( Match != NULL ) {

            break;
        }
    }

    return Match;
}



NTSTATUS
FTCache::AddConflictPair(
    IN OUT FTCache::CONFLICT_PAIR * * ConflictPairs,
    IN OUT ULONG * ConflictPairsTotal,
    IN LSA_FOREST_TRUST_RECORD_TYPE Type1,
    IN void * Conflict1,
    IN ULONG Flag1,
    IN LSA_FOREST_TRUST_RECORD_TYPE Type2,
    IN void * Conflict2,
    IN ULONG Flag2
    )
/*++

Routine Description:

    Adds a given pair of records to an array of such pairs

Arguments:

    ConflictPairs       an array of conflict pairs to add to

    ConflictPairsCount  number of entries in ConflictPairs

    Type1               type of the first side of conflict

    Conflict1           first side of conflict

    Flag1               flags of the first side of conflict

    Type2               type of the second side of conflict

    Conflict2           second side of conflict

    Flag2               flags of the second side of conflict

Returns:

    STATUS_SUCCESS if happy

    STATUS_INSUFFICIENT_RESOURCES if out of memory

--*/
{
    NTSTATUS Status;

    ASSERT( ConflictPairs );
    ASSERT( ConflictPairsTotal );
    ASSERT( Conflict1 );
    ASSERT( Conflict2 );

    if ( *ConflictPairs == NULL ) {

        *ConflictPairs = ( CONFLICT_PAIR * )FtcAllocate( sizeof( CONFLICT_PAIR ));

        if ( ConflictPairs == NULL ) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::AddConflictPair (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

    } else {

        CONFLICT_PAIR * ConflictPairsT;

        ConflictPairsT = ( CONFLICT_PAIR * )FtcReallocate(
                                                *ConflictPairs,
                                                sizeof( CONFLICT_PAIR ) * ( *ConflictPairsTotal ),
                                                sizeof( CONFLICT_PAIR ) * ( *ConflictPairsTotal + 1 ));

        if ( ConflictPairsT == NULL ) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::AddConflictPair (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        *ConflictPairs = ConflictPairsT;
    }

    ASSERT( *ConflictPairs );

    (*ConflictPairs)[*ConflictPairsTotal].EntryType1 = Type1;
    (*ConflictPairs)[*ConflictPairsTotal].Entry1 = Conflict1;
    (*ConflictPairs)[*ConflictPairsTotal].Flag1 = Flag1;
    (*ConflictPairs)[*ConflictPairsTotal].EntryType2 = Type2;
    (*ConflictPairs)[*ConflictPairsTotal].Entry2 = Conflict2;
    (*ConflictPairs)[*ConflictPairsTotal].Flag2 = Flag2;

    *ConflictPairsTotal += 1;

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));
    goto Cleanup;
}



void
FTCache::ReconcileConflictPairs(
    IN OPTIONAL const TDO_ENTRY * TdoEntry,
    IN CONFLICT_PAIR * ConflictPairs,
    IN ULONG ConflictPairsTotal
    )
/*++

Routine Description:

    Iterates through an array of conflict pairs and marks
    entries corresponding to a given TDO entry as disabled

Arguments:

    TdoEntry         entry to be reconciled:
                     every conflict pair matching this entry
                     will be marked as disabled due to conflict

                     if NULL, the side of the conflict belonging
                     to a TDO with an alphabetically smaller name wins
                     unless it is the local forest entry, which always wins

    ConflictPairs    array of conflict pair records
    ConflictPairsTotal

Returns:

    Nothing

--*/
{
    ASSERT( ConflictPairs );

    for ( ULONG i = 0 ; i < ConflictPairsTotal ; i++ ) {

        CONFLICT_PAIR& Pair = ConflictPairs[i];

        if ( TdoEntry == NULL ) {

            //
            // Extract TDO entries corresponding to each
            // side of the conflict so we can compare the
            // TDO names and decide who wins
            //

            RTL_GENERIC_COMPARE_RESULTS Result;
            TDO_ENTRY * TdoEntry1 = Pair.TdoEntry1();
            TDO_ENTRY * TdoEntry2 = Pair.TdoEntry2();

            if ( TdoEntry1->LocalForestEntry ) {

                //
                // A local forest entry can not lose
                //

                Pair.DisableEntry2();

            } else if ( TdoEntry2->LocalForestEntry ) {

                Pair.DisableEntry1();

            } else {

                //
                // Compare TDO names of the conflicting entries
                // Alphabetically smaller name wins
                // This algorithm is deterministic
                //

                Result = UnicodeStringCompareRoutine(
                             NULL,
                             &TdoEntry1->TrustedDomainName,
                             &TdoEntry2->TrustedDomainName
                             );

                if ( Result == GenericGreaterThan ) {

                    Pair.DisableEntry1();

                } else if ( Result == GenericLessThan ) {

                    Pair.DisableEntry2();

                } else {

                    ASSERT( FALSE ); // two TDO names can not be equal!!!
                }
            }

        } else {

            if ( TdoEntry == Pair.TdoEntry1()) {

                Pair.DisableEntry1();
            }

            if ( TdoEntry == Pair.TdoEntry2()) {

                Pair.DisableEntry2();
            }
        }
    }
}



NTSTATUS
FTCache::GenerateConflictInfo(
    IN CONFLICT_PAIR * ConflictPairs,
    IN ULONG ConflictPairsTotal,
    IN TDO_ENTRY * TdoEntry,
    OUT PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo
    )
/*++

Routine Description:

    Generates conflict information in the format expected by the
    caller from the conflict pairs array

Arguments:

    ConflictPairs           array of entries representing conflict information

    ConflictPairsTotal      count of entries in the "ConflitPairs" array

    TdoEntry                TDO entry in conflict

    CollisionInfo           used to return generated collision data

Returns:

    STATUS_SUCCESS                 happy

    STATUS_INSUFFICIENT_RESOURCES  ran out of memory generated collision data

    STATUS_INVALID_PARAMETER       will also assert if invalid data encountered

--*/
{
    NTSTATUS Status;

    ASSERT( ConflictPairs );
    ASSERT( TdoEntry );
    ASSERT( CollisionInfo && *CollisionInfo == NULL );

    for ( ULONG i = 0 ; i < ConflictPairsTotal ; i++ ) {

        CONFLICT_PAIR& Pair = ConflictPairs[i];
        ULONG Index;
        ULONG Flags;
        UNICODE_STRING * String;

        switch ( Pair.EntryType1 ) {

        case ForestTrustTopLevelName:
        case ForestTrustTopLevelNameEx: {

            ASSERT( Pair.TlnEntry1 );
            ASSERT( Pair.TlnEntry1->TdoEntry == TdoEntry );
            Index = Pair.TlnEntry1->Index;
            Flags = Pair.TlnEntry1->Flags() | Pair.Flag1;
            break;
        }

        case ForestTrustDomainInfo: {

            ASSERT( Pair.DomainInfoEntry1 );
            ASSERT( Pair.DomainInfoEntry1->TdoEntry == TdoEntry );
            Index = Pair.DomainInfoEntry1->Index;
            Flags = Pair.DomainInfoEntry1->Flags() | Pair.Flag1;
            break;
        }

        default:

            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::GenerateConflictInfo (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            ASSERT( FALSE );
            goto Error;
        }

        switch ( Pair.EntryType2 ) {

        case ForestTrustTopLevelName:
        case ForestTrustTopLevelNameEx: {

            ASSERT( Pair.TlnEntry2 );
            ASSERT( Pair.TlnEntry2->TdoEntry != TdoEntry );
            String = &Pair.TlnEntry2->TdoEntry->TrustedDomainName;
            break;
        }

        case ForestTrustDomainInfo: {

            ASSERT( Pair.DomainInfoEntry2 );
            ASSERT( Pair.DomainInfoEntry2->TdoEntry != TdoEntry );
            String = &Pair.DomainInfoEntry2->TdoEntry->TrustedDomainName;
            break;
        }

        default:

            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::GenerateConflictInfo (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            ASSERT( FALSE );
            goto Error;
        }

        Status = LsapAddToCollisionInfo(
                     CollisionInfo,
                     Index,
                     CollisionTdo,
                     Flags,
                     String
                     );

        if ( !NT_SUCCESS( Status )) {

            goto Error;
        }
    }

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));

    //
    // Cleanup generated conflict info
    //

    LsapFreeCollisionInfo( CollisionInfo );
    ASSERT( *CollisionInfo == NULL );

    goto Cleanup;
}



BOOLEAN
FTCache::TDO_ENTRY::Excludes(
    IN const UNICODE_STRING * Name
    )
/*++

Routine Description:

    Determines if the given unicode name is disowned by this TDO_ENTRY

Arguments:

    Name       name to check

Returns:

    TRUE if name is identical to one of the namespaces disowned by this tdo
         or if it is subordinate to one of the disowned namespaces

    FALSE otherwise

--*/
{

    BOOLEAN Result = FALSE;

    for ( LIST_ENTRY * ListEntry = TlnList.Flink;
          ListEntry != &TlnList;
          ListEntry = ListEntry->Flink ) {

        TLN_ENTRY * TlnEntry;

        TlnEntry = TLN_ENTRY::EntryFromTdoEntry( ListEntry );

        if ( !TlnEntry->Excluded ) {

            continue;
        }

        //
        // Only those exclusion entries that have a superior TLN are considered,
        // the rest are "stored and ignored"
        //

        if ( TlnEntry->SuperiorEntry == NULL ) {

            continue;
        }

        if ( RtlEqualUnicodeString(
                 &TlnEntry->TlnKey->TopLevelName,
                 Name,
                 TRUE )) {

            Result = TRUE;
            break;

        } else if ( IsSubordinate( Name, &TlnEntry->TlnKey->TopLevelName )) {

            Result = TRUE;
            break;
        }
    }

    return Result;
}



void
FTCache::AuditChanges(
    IN OPTIONAL const TDO_ENTRY * TdoEntryOld,
    IN OPTIONAL const TDO_ENTRY * TdoEntryNew
    )
/*++

Routine Description:

    Computes differences between two TDO_ENTRY structures
    and calls the corresponding auditing routines

Arguments:

    TdoEntryOld      old data (can be NULL in case of addition)

    TdoEntryNew      new data (can be NULL in case of deletion)

Returns:

    Nothing (auditing failures are ignored)

--*/
{
    NTSTATUS Status;
    LUID OperationId;

    if ( TdoEntryOld == NULL &&
         TdoEntryNew == NULL ) {

        //
        // Give us at least something!
        //

        return;
    }

    //
    // No auditing is performed on local forest entries
    //

    if ( TdoEntryOld && TdoEntryOld->LocalForestEntry ) {

        return;
    }

    if ( TdoEntryNew && TdoEntryNew->LocalForestEntry ) {

        return;
    }

    //
    // The ensuing algorithm is expensive, so it only makes
    // sense to execute it if auditing is enabled
    //

    if ( !LsapAdtIsAuditingEnabledForCategory(
              AuditCategoryPolicyChange,
              EVENTLOG_AUDIT_SUCCESS )) {

        LsapDsDebugOut(( DEB_FTINFO, "FTCache::AuditChanges: Auditing of x-forest trust changes skipped\n" ));
        return;
    }

    Status = NtAllocateLocallyUniqueId( &OperationId );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "FTCache::AuditChanges: Can not allocate a LUID for auditing (0x%lx)\n", Status ));
        return;
    }

    if ( TdoEntryOld == NULL || TdoEntryNew == NULL ) {

        LIST_ENTRY * ListEntry;

        //
        // This is an add or remove operation
        // Figure out which one it is and apply to every entry
        //

        typedef NTSTATUS
        (*PFNAUDITFN)(
              IN PUNICODE_STRING ForestName,
              IN PSID            ForestSid,
              IN PLUID           OperationId,
              IN LSA_FOREST_TRUST_RECORD_TYPE EntryType,
              IN ULONG           Flags,
              IN PUNICODE_STRING TopLevelName,
              IN PUNICODE_STRING DnsName,
              IN PUNICODE_STRING NetbiosName,
              IN PSID            Sid
              );

        const TDO_ENTRY * Entry = ( TdoEntryOld ? TdoEntryOld : TdoEntryNew );

        PFNAUDITFN AuditChangeFn = ( TdoEntryOld ?
                                        LsapAdtTrustedForestInfoEntryRem :
                                        LsapAdtTrustedForestInfoEntryAdd );

        //
        // New data is being added to the cache
        //

        for ( ListEntry = Entry->TlnList.Flink;
              ListEntry != &Entry->TlnList;
              ListEntry = ListEntry->Flink ) {

            TLN_ENTRY * TlnEntry;

            TlnEntry = TLN_ENTRY::EntryFromTdoEntry( ListEntry );

            //
            // Skip over "pseudo" entries
            //

            if ( !( TlnEntry->Excluded ||
                    TlnEntry->SubordinateEntry == NULL )) {

                continue;
            }

            Status = AuditChangeFn(
                         ( PUNICODE_STRING )&Entry->TrustedDomainName,
                         Entry->TrustedDomainSid,
                         &OperationId,
                         TlnEntry->Excluded ?
                            ForestTrustTopLevelNameEx :
                            ForestTrustTopLevelName,
                         TlnEntry->Flags(),
                         &TlnEntry->TlnKey->TopLevelName,
                         NULL,
                         NULL,
                         NULL
                         );

            if ( !NT_SUCCESS( Status )) {

                LsapDsDebugOut(( DEB_FTINFO, "FTCache::AuditChanges: Auditing failure 0x%lx on entry %p\n (%s:%d)", Status, TlnEntry, __FILE__, __LINE__ ));
                goto Cleanup;
            }
        }

        for ( ListEntry = Entry->DomainInfoList.Flink;
              ListEntry != &Entry->DomainInfoList;
              ListEntry = ListEntry->Flink ) {

            DOMAIN_INFO_ENTRY * DomainInfoEntry;

            DomainInfoEntry = DOMAIN_INFO_ENTRY::EntryFromTdoEntry( ListEntry );

            Status = AuditChangeFn(
                         ( PUNICODE_STRING )&Entry->TrustedDomainName,
                         Entry->TrustedDomainSid,
                         &OperationId,
                         ForestTrustDomainInfo,
                         DomainInfoEntry->Flags(),
                         NULL,
                         &DomainInfoEntry->DnsKey->DnsName,
                         DomainInfoEntry->NetbiosKey ?
                            &DomainInfoEntry->NetbiosKey->NetbiosName :
                            NULL,
                         DomainInfoEntry->SidKey->DomainSid
                         );

            if ( !NT_SUCCESS( Status )) {

                LsapDsDebugOut(( DEB_FTINFO, "FTCache::AuditChanges: Auditing failure 0x%lx on entry %p (%s:%d)\n", Status, DomainInfoEntry, __FILE__, __LINE__ ));
                goto Cleanup;
            }
        }

        for ( ListEntry = Entry->BinaryList.Flink;
              ListEntry != &Entry->BinaryList;
              ListEntry = ListEntry->Flink ) {

            BINARY_ENTRY * BinaryEntry;

            BinaryEntry = BINARY_ENTRY::EntryFromTdoEntry( ListEntry );

            Status = AuditChangeFn(
                         ( PUNICODE_STRING )&Entry->TrustedDomainName,
                         Entry->TrustedDomainSid,
                         &OperationId,
                         BinaryEntry->Type,
                         BinaryEntry->Flags(),
                         NULL,
                         NULL,
                         NULL,
                         NULL
                         );

            if ( !NT_SUCCESS( Status )) {

                LsapDsDebugOut(( DEB_FTINFO, "FTCache::AuditChanges: Auditing failure 0x%lx on entry %p (%s:%d)\n", Status, BinaryEntry, __FILE__, __LINE__ ));
                goto Cleanup;
            }
        }

    } else {

        //
        // Data is being modified
        //

        LIST_ENTRY * ListEntry;
        const TDO_ENTRY * TdoEntry = TdoEntryNew; // have to pick one for auditing

        ASSERT( RtlEqualUnicodeString(
                    &TdoEntryOld->TrustedDomainName,
                    &TdoEntryNew->TrustedDomainName,
                    TRUE ));

        //
        // Go through new TLN entries, see if they are present in the old list
        // If not, they're additions
        // If yes, check for modifications
        //

        for ( ListEntry = TdoEntryNew->TlnList.Flink;
              ListEntry != &TdoEntryNew->TlnList;
              ListEntry = ListEntry->Flink ) {

            TLN_ENTRY * TlnEntryNew;
            BOOLEAN Found = FALSE;
            BOOLEAN Modified = FALSE;

            TlnEntryNew = TLN_ENTRY::EntryFromTdoEntry( ListEntry );

            //
            // Skip over "pseudo" entries
            //

            if ( !( TlnEntryNew->Excluded ||
                    TlnEntryNew->SubordinateEntry == NULL )) {

                continue;
            }

            for ( LIST_ENTRY * ListEntryAvl = TlnEntryNew->TlnKey->List.Flink;
                  ListEntryAvl != &TlnEntryNew->TlnKey->List;
                  ListEntryAvl = ListEntryAvl->Flink ) {

                TLN_ENTRY * TlnEntryOld;

                TlnEntryOld = TLN_ENTRY::EntryFromAvlEntry( ListEntryAvl );

                //
                // Specifically looking for old entries
                //

                if ( TlnEntryOld->TdoEntry != TdoEntryOld ) {

                    continue;
                }

                //
                // Skip over "pseudo" entries
                //

                if ( !( TlnEntryOld->Excluded ||
                        TlnEntryOld->SubordinateEntry == NULL )) {

                    continue;
                }

                if ( TlnEntryNew->Excluded != TlnEntryOld->Excluded ) {

                    continue;
                }

                Found = TRUE;

                //
                // The only thing that can change on a top level name entry
                // is its flags
                //

                if ( TlnEntryOld->Flags() != TlnEntryNew->Flags()) {

                    Status = LsapAdtTrustedForestInfoEntryMod(
                                 ( PUNICODE_STRING )&TdoEntry->TrustedDomainName,
                                 TdoEntry->TrustedDomainSid,
                                 &OperationId,
                                 TlnEntryOld->Excluded ?
                                    ForestTrustTopLevelNameEx :
                                    ForestTrustTopLevelName,
                                 TlnEntryOld->Flags(),
                                 &TlnEntryOld->TlnKey->TopLevelName,
                                 NULL,
                                 NULL,
                                 NULL,
                                 TlnEntryNew->Flags(),
                                 &TlnEntryNew->TlnKey->TopLevelName,
                                 NULL,
                                 NULL,
                                 NULL
                                 );

                    if ( !NT_SUCCESS( Status )) {

                        LsapDsDebugOut(( DEB_FTINFO, "FTCache::AuditChanges: Auditing failure 0x%lx on entries %p (old) and %p (new) (%s:%d)\n", Status, TlnEntryOld, TlnEntryNew, __FILE__, __LINE__ ));
                    }

                    Modified = TRUE;
                }

                //
                // The Index field of the entry is reused here to aid performance.
                // Index contains the ordinal number the entry had in the original
                // array of FTInfo entries.  This is necessary in order to report
                // conflict information during insertion, and the data is NOT
                // used anywhere afterwards.
                // We set this field to '-1' here.  Later, when looking for
                // old entries that are being removed, the algorithm is simply to
                // pick those whose index field is not -1 and report them as removals.
                //

                ASSERT( TlnEntryOld->Index != 0xFFFFFFFF );
                TlnEntryOld->Index = 0xFFFFFFFF;

                break;
            }

            //
            // If an entry wasn't a modification, it's an addition
            //

            if ( !Found && !Modified ) {

                Status = LsapAdtTrustedForestInfoEntryAdd(
                             ( PUNICODE_STRING )&TdoEntry->TrustedDomainName,
                             TdoEntry->TrustedDomainSid,
                             &OperationId,
                             TlnEntryNew->Excluded ?
                                ForestTrustTopLevelNameEx :
                                ForestTrustTopLevelName,
                             TlnEntryNew->Flags(),
                             &TlnEntryNew->TlnKey->TopLevelName,
                             NULL,
                             NULL,
                             NULL
                             );

                if ( !NT_SUCCESS( Status )) {

                    LsapDsDebugOut(( DEB_FTINFO, "FTCache::AuditChanges: Auditing failure 0x%lx on entry %p (%s:%d)\n", Status, TlnEntryNew, __FILE__, __LINE__ ));
                }
            }
        }

        //
        // Go through old entries, see if they have been marked as
        // found.  If not, audit them as removals.
        //

        for ( ListEntry = TdoEntryOld->TlnList.Flink;
              ListEntry != &TdoEntryOld->TlnList;
              ListEntry = ListEntry->Flink ) {

            TLN_ENTRY * TlnEntryOld;

            TlnEntryOld = TLN_ENTRY::EntryFromTdoEntry( ListEntry );

            //
            // Skip over "pseudo" entries
            //

            if ( !( TlnEntryOld->Excluded ||
                    TlnEntryOld->SubordinateEntry == NULL )) {

                continue;
            }

            //
            // Entries marked with index of 0xFFFFFFFF have been
            // found when looking for modifications.  Skip over those here.
            //

            if ( TlnEntryOld->Index == 0xFFFFFFFF ) {

                TlnEntryOld->Index = 0; // no need to keep the special value around
                continue;
            }

            Status = LsapAdtTrustedForestInfoEntryRem(
                         ( PUNICODE_STRING )&TdoEntry->TrustedDomainName,
                         TdoEntry->TrustedDomainSid,
                         &OperationId,
                         TlnEntryOld->Excluded ?
                            ForestTrustTopLevelNameEx :
                            ForestTrustTopLevelName,
                         TlnEntryOld->Flags(),
                         &TlnEntryOld->TlnKey->TopLevelName,
                         NULL,
                         NULL,
                         NULL
                         );

            if ( !NT_SUCCESS( Status )) {

                LsapDsDebugOut(( DEB_FTINFO, "FTCache::AuditChanges: Auditing failure 0x%x on entry %p (%s:%d)\n", Status, TlnEntryOld, __FILE__, __LINE__ ));
            }
        }

        //
        // Go through new domain info entries, see if they are present in the old list
        // If not, they're additions
        // If yes, check for modifications
        //

        for ( ListEntry = TdoEntryNew->DomainInfoList.Flink;
              ListEntry != &TdoEntryNew->DomainInfoList;
              ListEntry = ListEntry->Flink ) {

            DOMAIN_INFO_ENTRY * DomainInfoEntryNew;
            BOOLEAN Found = FALSE;
            BOOLEAN Modified = FALSE;

            DomainInfoEntryNew = DOMAIN_INFO_ENTRY::EntryFromTdoEntry( ListEntry );

            //
            // The invariant of any entry is its SID
            // The assumption is that for a given SID, the DNS name and Netbios
            // name may change, as well as flags
            //

            for ( LIST_ENTRY * ListEntrySid = DomainInfoEntryNew->SidKey->List.Flink;
                  ListEntrySid != &DomainInfoEntryNew->SidKey->List;
                  ListEntrySid = ListEntrySid->Flink ) {

                DOMAIN_INFO_ENTRY * DomainInfoEntryOld;

                DomainInfoEntryOld = DOMAIN_INFO_ENTRY::EntryFromSidEntry( ListEntrySid );

                //
                // Specifically looking for old entries
                //

                if ( DomainInfoEntryOld->TdoEntry != TdoEntryOld ) {

                    continue;
                }

                Found = TRUE;

                if ( DomainInfoEntryOld->Flags() != DomainInfoEntryNew->Flags()) {

                    Modified = TRUE;

                } else if ( !RtlEqualUnicodeString(
                                 &DomainInfoEntryOld->DnsKey->DnsName,
                                 &DomainInfoEntryNew->DnsKey->DnsName,
                                 TRUE )) {

                    Modified = TRUE;

                } else if ( XOR<NETBIOS_NAME_KEY*>(
                                DomainInfoEntryOld->NetbiosKey,
                                DomainInfoEntryNew->NetbiosKey )) {

                    Modified = TRUE;

                } else if ( DomainInfoEntryOld->NetbiosKey &&
                            DomainInfoEntryNew->NetbiosKey &&
                            !RtlEqualUnicodeString(
                                 &DomainInfoEntryOld->NetbiosKey->NetbiosName,
                                 &DomainInfoEntryNew->NetbiosKey->NetbiosName,
                                 TRUE )) {

                    Modified = TRUE;
                }

                if ( Modified ) {

                    Status = LsapAdtTrustedForestInfoEntryMod(
                                 ( PUNICODE_STRING )&TdoEntry->TrustedDomainName,
                                 TdoEntry->TrustedDomainSid,
                                 &OperationId,
                                 ForestTrustDomainInfo,
                                 DomainInfoEntryOld->Flags(),
                                 NULL,
                                 &DomainInfoEntryOld->DnsKey->DnsName,
                                 DomainInfoEntryOld->NetbiosKey ?
                                    &DomainInfoEntryOld->NetbiosKey->NetbiosName :
                                    NULL,
                                 DomainInfoEntryOld->Sid,
                                 DomainInfoEntryNew->Flags(),
                                 NULL,
                                 &DomainInfoEntryNew->DnsKey->DnsName,
                                 DomainInfoEntryNew->NetbiosKey ?
                                    &DomainInfoEntryNew->NetbiosKey->NetbiosName :
                                    NULL,
                                 DomainInfoEntryNew->Sid
                                 );

                    if ( !NT_SUCCESS( Status )) {

                        LsapDsDebugOut(( DEB_FTINFO, "FTCache::AuditChanges: Auditing failure 0x%lx on entries %p (old) and %p (new) (%s:%d)\n", Status, DomainInfoEntryOld, DomainInfoEntryNew, __FILE__, __LINE__ ));
                    }
                }

                //
                // The Index field of the entry is reused here to aid performance.
                // Index contains the ordinal number the entry had in the original
                // array of FTInfo entries.  This is necessary in order to report
                // conflict information during insertion, and the data is NOT
                // used anywhere afterwards.
                // We set this field to '-1' here.  Later, when looking for
                // old entries that are being removed, the algorithm is simply to
                // pick those whose index field is not -1 and report them as removals.
                //

                ASSERT( DomainInfoEntryOld->Index != 0xFFFFFFFF );
                DomainInfoEntryOld->Index = 0xFFFFFFFF;

                break;
            }

            //
            // If an entry wasn't a modification, it's an addition
            //

            if ( !Found && !Modified ) {

                Status = LsapAdtTrustedForestInfoEntryAdd(
                             ( PUNICODE_STRING )&TdoEntry->TrustedDomainName,
                             TdoEntry->TrustedDomainSid,
                             &OperationId,
                             ForestTrustDomainInfo,
                             DomainInfoEntryNew->Flags(),
                             NULL,
                             &DomainInfoEntryNew->DnsKey->DnsName,
                             DomainInfoEntryNew->NetbiosKey ?
                                &DomainInfoEntryNew->NetbiosKey->NetbiosName :
                                NULL,
                             DomainInfoEntryNew->Sid
                             );

                if ( !NT_SUCCESS( Status )) {

                    LsapDsDebugOut(( DEB_FTINFO, "FTCache::AuditChanges: Auditing failure 0x%lx on entry %p (%s:%d)\n", Status, DomainInfoEntryNew, __FILE__, __LINE__ ));
                }
            }
        }

        //
        // Go through old entries, see if they have been marked as
        // modified.  If not, audit them as removals.
        //

        for ( ListEntry = TdoEntryOld->DomainInfoList.Flink;
              ListEntry != &TdoEntryOld->DomainInfoList;
              ListEntry = ListEntry->Flink ) {

            DOMAIN_INFO_ENTRY * DomainInfoEntryOld;

            DomainInfoEntryOld = DOMAIN_INFO_ENTRY::EntryFromTdoEntry( ListEntry );

            //
            // Entries marked with index of 0xFFFFFFFF have been
            // found when looking for modifications.  Skip over those here.
            //

            if ( DomainInfoEntryOld->Index == 0xFFFFFFFF ) {

                DomainInfoEntryOld->Index = 0; // no need to keep the special value around
                continue;
            }

            Status = LsapAdtTrustedForestInfoEntryRem(
                         ( PUNICODE_STRING )&TdoEntry->TrustedDomainName,
                         TdoEntry->TrustedDomainSid,
                         &OperationId,
                         ForestTrustDomainInfo,
                         DomainInfoEntryOld->Flags(),
                         NULL,
                         &DomainInfoEntryOld->DnsKey->DnsName,
                         DomainInfoEntryOld->NetbiosKey ?
                            &DomainInfoEntryOld->NetbiosKey->NetbiosName :
                            NULL,
                         DomainInfoEntryOld->Sid
                         );

            if ( !NT_SUCCESS( Status )) {

                LsapDsDebugOut(( DEB_FTINFO, "FTCache::AuditChanges: Auditing failure 0x%lx on entry %p (%s:%d)\n", Status, TdoEntry, __FILE__, __LINE__ ));
            }
        }

        //
        // Binary entries are audited as replacements
        //

        for ( ListEntry = TdoEntryOld->BinaryList.Flink;
              ListEntry != &TdoEntryOld->BinaryList;
              ListEntry = ListEntry->Flink ) {

            BINARY_ENTRY * BinaryEntry;

            BinaryEntry = BINARY_ENTRY::EntryFromTdoEntry( ListEntry );

            Status = LsapAdtTrustedForestInfoEntryRem(
                         ( PUNICODE_STRING )&TdoEntryOld->TrustedDomainName,
                         TdoEntryOld->TrustedDomainSid,
                         &OperationId,
                         BinaryEntry->Type,
                         BinaryEntry->Flags(),
                         NULL,
                         NULL,
                         NULL,
                         NULL
                         );

            if ( !NT_SUCCESS( Status )) {

                LsapDsDebugOut(( DEB_FTINFO, "FTCache::AuditChanges: Auditing failure 0x%lx on entry %p (%s:%d)\n", Status, TdoEntryOld, __FILE__, __LINE__ ));
                goto Cleanup;
            }
        }

        for ( ListEntry = TdoEntryNew->BinaryList.Flink;
              ListEntry != &TdoEntryNew->BinaryList;
              ListEntry = ListEntry->Flink ) {

            BINARY_ENTRY * BinaryEntry;

            BinaryEntry = BINARY_ENTRY::EntryFromTdoEntry( ListEntry );

            Status = LsapAdtTrustedForestInfoEntryAdd(
                         ( PUNICODE_STRING )&TdoEntryNew->TrustedDomainName,
                         TdoEntryNew->TrustedDomainSid,
                         &OperationId,
                         BinaryEntry->Type,
                         BinaryEntry->Flags(),
                         NULL,
                         NULL,
                         NULL,
                         NULL
                         );

            if ( !NT_SUCCESS( Status )) {

                LsapDsDebugOut(( DEB_FTINFO, "FTCache::AuditChanges: Auditing failure 0x%lx on entry %p (%s:%d)\n", Status, TdoEntryNew, __FILE__, __LINE__ ));
                goto Cleanup;
            }
        }
    }

Cleanup:

    return;
}



void
FTCache::AuditCollisions(
    IN CONFLICT_PAIR * ConflictPairs,
    IN ULONG ConflictPairsTotal
    )
/*++

Routine description:

    Generates audits for collisions

Arguments:

    ConflictPairs        array of conflict pairs

    ConflictPairsTotal   number of elements in ConflictPairs

Returns:

    Nothing

--*/
{
    for ( ULONG i = 0 ; i < ConflictPairsTotal ; i++ ) {

        NTSTATUS Status;
        CONFLICT_PAIR& Pair = ConflictPairs[i];
        TDO_ENTRY * TdoEntry1 = Pair.TdoEntry1();
        TDO_ENTRY * TdoEntry2 = Pair.TdoEntry2();
        LSA_FOREST_TRUST_COLLISION_RECORD_TYPE CollisionTargetType;
        PUNICODE_STRING CollisionTargetName;
        PUNICODE_STRING ForestRootDomainName;
        PUNICODE_STRING TopLevelName;
        PUNICODE_STRING DnsName;
        PUNICODE_STRING NetbiosName;
        PSID Sid;
        ULONG NewFlags;

        if ( TdoEntry1->LocalForestEntry ) {

            CollisionTargetType  = CollisionXref;
            CollisionTargetName  = &TdoEntry1->TrustedDomainName;
            ForestRootDomainName = &TdoEntry2->TrustedDomainName;
            TopLevelName         = ( Pair.EntryType2 == ForestTrustTopLevelName ) ?
                                        &Pair.TlnEntry2->TlnKey->TopLevelName : NULL;
            DnsName              = ( Pair.EntryType2 == ForestTrustDomainInfo ) ?
                                        &Pair.DomainInfoEntry2->DnsKey->DnsName : NULL;
            NetbiosName          = ( Pair.EntryType2 == ForestTrustDomainInfo &&
                                     Pair.DomainInfoEntry2->NetbiosKey ) ?
                                        &Pair.DomainInfoEntry2->NetbiosKey->NetbiosName : NULL;
            Sid                  = ( Pair.EntryType2 == ForestTrustDomainInfo ) ?
                                        Pair.DomainInfoEntry2->SidKey->DomainSid : NULL;
            NewFlags             = Pair.Flag2;

        } else if ( TdoEntry2->LocalForestEntry ) {

            CollisionTargetType  = CollisionXref;
            CollisionTargetName  = &TdoEntry2->TrustedDomainName;
            ForestRootDomainName = &TdoEntry1->TrustedDomainName;
            TopLevelName         = ( Pair.EntryType1 == ForestTrustTopLevelName ) ?
                                        &Pair.TlnEntry1->TlnKey->TopLevelName : NULL;
            DnsName              = ( Pair.EntryType1 == ForestTrustDomainInfo ) ?
                                        &Pair.DomainInfoEntry1->DnsKey->DnsName : NULL;
            NetbiosName          = ( Pair.EntryType1 == ForestTrustDomainInfo &&
                                     Pair.DomainInfoEntry1->NetbiosKey ) ?
                                        &Pair.DomainInfoEntry1->NetbiosKey->NetbiosName : NULL;
            Sid                  = ( Pair.EntryType1 == ForestTrustDomainInfo ) ?
                                        Pair.DomainInfoEntry1->SidKey->DomainSid : NULL;
            NewFlags             = Pair.Flag1;

        } else {

            CollisionTargetType  = CollisionTdo;
            CollisionTargetName  = &TdoEntry2->TrustedDomainName;
            ForestRootDomainName = &TdoEntry1->TrustedDomainName;
            TopLevelName         = ( Pair.EntryType2 == ForestTrustTopLevelName ) ?
                                        &Pair.TlnEntry2->TlnKey->TopLevelName : NULL;
            DnsName              = ( Pair.EntryType2 == ForestTrustDomainInfo ) ?
                                        &Pair.DomainInfoEntry2->DnsKey->DnsName : NULL;
            NetbiosName          = ( Pair.EntryType2 == ForestTrustDomainInfo &&
                                     Pair.DomainInfoEntry2->NetbiosKey ) ?
                                        &Pair.DomainInfoEntry2->NetbiosKey->NetbiosName : NULL;
            Sid                  = ( Pair.EntryType2 == ForestTrustDomainInfo ) ?
                                        Pair.DomainInfoEntry2->SidKey->DomainSid : NULL;
            NewFlags             = Pair.Flag2;
        }

        Status = LsapAdtTrustedForestNamespaceCollision(
                     CollisionTargetType,
                     CollisionTargetName,
                     ForestRootDomainName,
                     TopLevelName,
                     DnsName,
                     NetbiosName,
                     Sid,
                     NewFlags
                     );
    }

    return;
}


///////////////////////////////////////////////////////////////////////////////
//
// Marshaling routines
//
///////////////////////////////////////////////////////////////////////////////



ULONG
LsapMarshalSid(
    IN BYTE * Blob,
    IN SID * Sid
    )
/*++

Routine Description:

    Writes the internal representation of a SID into the buffer
    If buffer is NULL, returns the number of bytes needed
    NOTE: The buffer, if not NULL, is assumed to be big enough!!!

Arguments:

    Blob      address of the target buffer

    Sid       SID to marshal

Returns:

    if Blob != NULL, number of bytes written into the buffer
    if Blob == NULL, number of bytes needed to represent the SID

--*/
{
    ULONG Index = 0;
    UCHAR i;

    ASSERT( RtlValidSid( Sid ));

    if ( Blob != NULL ) {

        //
        // Leave space for the length
        //

        Index += sizeof( ULONG );

        Blob[Index] = Sid->Revision;
        Index += sizeof( UCHAR );

        Blob[Index] = Sid->SubAuthorityCount;
        Index += sizeof( UCHAR );

        ASSERT( sizeof( SID_IDENTIFIER_AUTHORITY ) == 6 ); // or all hell will break loose
        RtlCopyMemory( &Blob[Index], Sid->IdentifierAuthority.Value, sizeof( SID_IDENTIFIER_AUTHORITY ));
        Index += sizeof( SID_IDENTIFIER_AUTHORITY );

        for ( i = 0 ; i < Sid->SubAuthorityCount ; i++ ) {

            SmbPutUlong( &Blob[Index], Sid->SubAuthority[i] );
            Index += sizeof( ULONG );
        }

        //
        // Now that we know the length, prepend it at the beginning of the blob
        //

        SmbPutUlong( &Blob[0], Index - sizeof( ULONG ));

    } else {

        Index = sizeof( ULONG ) +                         // length of data that follows
                sizeof( UCHAR ) +                         // revision
                sizeof( UCHAR ) +                         // subauthority count
                sizeof( SID_IDENTIFIER_AUTHORITY ) +      // identifier authority
                Sid->SubAuthorityCount * sizeof( ULONG ); // subauthority data
    }

    return Index;
}



ULONG
LsapUnmarshalSid(
    IN BYTE * Blob,
    OUT PISID * Sid
    )
/*++

Routine Description:

    Decodes the internal representation of a SID
    Caller must use FtcFree to free the generated SID

Arguments:

    Blob      address of the buffer containing internal representation
              of the SID

    Sid       used ot return the generated SID

Returns:

    Number of bytes read from the blob
    If memory could not be allocated or there was an error reading
    data from the blob, raises an exception.  The caller must be
    prepared to handle this exception and use GetExceptionCode() to
    obtain the reason for failure.

--*/
{
    NTSTATUS Status;
    ULONG Index = 0;
    ULONG Length;

    ASSERT( Blob );
    ASSERT( Sid );

    *Sid = NULL;

    __try {

        UCHAR Revision, SubAuthorityCount;
        UCHAR i;

        //
        // Ignore the length field
        //

        Length = SmbGetUlong( &Blob[Index] );
        Index += sizeof( ULONG );

        Revision = ( UCHAR )Blob[Index];
        Index += sizeof( BYTE );

        SubAuthorityCount = ( UCHAR )Blob[Index];
        Index += sizeof( BYTE );

        *Sid = ( SID * )FtcAllocate(
                   sizeof( SID ) + SubAuthorityCount * sizeof( ULONG )
                   );

        if ( *Sid == NULL ) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::MatchSpn (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        (*Sid)->Revision = Revision;
        (*Sid)->SubAuthorityCount = SubAuthorityCount;

        ASSERT( sizeof( SID_IDENTIFIER_AUTHORITY ) == 6 ); // or all hell will break loose
        RtlCopyMemory( (*Sid)->IdentifierAuthority.Value, &Blob[Index], sizeof( SID_IDENTIFIER_AUTHORITY ));
        Index += sizeof( SID_IDENTIFIER_AUTHORITY );

        for ( i = 0 ; i < SubAuthorityCount ; i++ ) {

            (*Sid)->SubAuthority[i] = SmbGetUlong( &Blob[Index] );
            Index += sizeof( ULONG );
        }

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

        ASSERT( FALSE );
        Status = GetExceptionCode();
        goto Error;
    }

    //
    // Verify the correctness of the length field
    //

    ASSERT( Length == Index - sizeof( ULONG ));

    return Index;

Error:
    FtcFree( *Sid );
    *Sid = NULL;
    RaiseException( Status, 0, 0, NULL );
    return 0; // so the compiler doesn't complain
}



ULONG
LsapMarshalString(
    IN BYTE * Blob,
    IN UNICODE_STRING * String
    )
/*++

Routine Description:

    Writes an internal representation of a Unicode string into the buffer
    If buffer is NULL, returns the number of bytes needed
    NOTE: The buffer, if not NULL, is assumed to be big enough!!!

Arguments:

    Blob     address of the target buffer

    String   address of a UNICODE_STRING structure to marshal

Returns:

    if Blob != NULL, number of bytes written into the buffer
    if Blob == NULL, number of bytes needed to represent the string

    If conversion to internal representation fails, will raise an
    exception.  Caller should be prepared to handle this exception and
    use GetExceptionCode() to obtain the reason for failure.

--*/
{
    ULONG Index = 0;
    ULONG Length;

    ASSERT( String );

    //
    // Leave space for the length
    //

    Index += sizeof( ULONG );

    Length = WideCharToMultiByte(
                 CP_UTF8,
                 0,
                 String->Buffer,
                 String->Length / sizeof( WCHAR ),
                 Blob ? ( LPSTR )&Blob[Index] : NULL,
                 Blob ? MAXLONG : 0,
                 NULL,
                 NULL
                 );

    if ( Length == 0 && String->Length > 0 ) {

        RaiseException( GetLastError(), 0, 0, NULL );
    }

    //
    // Now that we know the length, prepend it at the beginning of the blob
    //

    if ( Blob != NULL ) {

        SmbPutUlong( &Blob[0], Length );
    }

    Index += Length;

    return Index;
}



ULONG
LsapUnmarshalString(
    IN BYTE * Blob,
    OUT UNICODE_STRING * String
    )
/*++

Routine Description:

    Decodes the internal representation of a Unicode string
    Caller must use FtcFree to free the generated string

Arguments:

    Blob      address of the buffer containing internal representation
              of the Unicode string

    String    used to return the generated string

Returns:

    Number of bytes read from the blob
    If memory could not be allocated or there was an error during
    conversion, raises an exception.  The caller must be
    prepared to handle this exception and use GetExceptionCode() to
    obtain the reason for failure.

--*/
{
    NTSTATUS Status;
    ULONG Index = 0;

    ASSERT( Blob );
    ASSERT( String );

    String->Buffer = NULL;

    __try {

        ULONG Length;

        //
        // Obtain the length of the UTF-8 encoded unicode string
        //

        Length = SmbGetUlong( &Blob[Index] );
        Index += sizeof( ULONG );

        //
        // See how big the buffer should be for the decoded string
        //

        if ( Length > 0 ) {

            String->Length = ( USHORT )MultiByteToWideChar(
                                           CP_UTF8,
                                           0,
                                           ( LPSTR )&Blob[Index],
                                           Length,
                                           NULL,
                                           0
                                           ) * sizeof( WCHAR );

            if ( String->Length == 0 ) {

                Status = GetLastError();
                LsapDsDebugOut(( DEB_FTINFO, "LsapUnmarshalString: MultiByteToWideChar returned 0x%x\n", Status ));
                goto Error;
            }

        } else {

            String->Length = 0;
        }

        //
        // Prepare to have the string NULL-terminated
        //

        String->MaximumLength = String->Length + sizeof( WCHAR );

        String->Buffer = ( PWSTR )FtcAllocate( String->MaximumLength );

        if ( String->Buffer == NULL ) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapUnmarshalString (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Now perform the actual conversion.  Note that we don't care
        // what the return value is anymore, as long as it's non-zero
        //

        if ( Length > 0 ) {

            if (0 == MultiByteToWideChar(
                         CP_UTF8,
                         0,
                         ( LPSTR )&Blob[Index],
                         Length,
                         String->Buffer,
                         String->Length / sizeof( WCHAR ))) {

                Status = GetLastError();
                ASSERT( FALSE ); // certainly not expecting this to fail (it just succeeded, above)
                goto Error;
            }

            Index += Length;
        }

        //
        // NULL-terminate the string for future convenience
        //

        (String->Buffer)[String->Length / sizeof( WCHAR )] = L'\0';

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

        ASSERT( FALSE );
        Status = GetExceptionCode();
        goto Error;
    }

    return Index;

Error:

    FtcFree( String->Buffer );
    String->Buffer = NULL;
    RaiseException( Status, 0, 0, NULL );
    return 0; // so the compiler doesn't complain
}



ULONG
LsapUnmarshalData(
    IN BYTE * Blob,
    IN ULONG Length,
    OUT LSA_FOREST_TRUST_BINARY_DATA * Data
    )
/*++

Routine Description:

    Decodes the internal representation of a binary data blob
    Caller must use FtcFree to free the generated structure

Arguments:

    Blob      address of the buffer containing internal representation
              of the binary blob

    Data      used to return the generated blob

Returns:

    Number of bytes read from the blob
    If memory could not be allocated, raises an exception.
    The caller must be prepared to handle this exception and use
    GetExceptionCode() to obtain the reason for failure.

--*/
{
    NTSTATUS Status;
    ULONG Index = 0;

    ASSERT( Blob );
    ASSERT( Data );

    Data->Buffer = NULL;

    __try {

        Data->Length = Length;

        if ( Data->Length > 0 ) {

            Data->Buffer = ( BYTE * )FtcAllocate( Data->Length );

            if ( Data->Buffer == NULL ) {

                LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapUnmarshalData (%s:%d)\n", __FILE__, __LINE__ ));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }

            RtlCopyMemory( Data->Buffer, &Blob[Index], Data->Length );
            Index += Data->Length;
        }

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

        Status = GetExceptionCode();
        ASSERT( FALSE );
        goto Error;
    }

    return Index;

Error:

    FtcFree( Data->Buffer );
    Data->Buffer = NULL;
    RaiseException( Status, 0, 0, NULL );
    return 0; // so the compiler doesn't complain
}



NTSTATUS
FTCache::MarshalBlob(
    IN TDO_ENTRY * TdoEntry,
    OUT ULONG * MarshaledSize,
    OUT PBYTE * MarshaledBlob
    )
/*++

Routine Description:

    Marshals the given ForestTrustInfo structure into a string of bytes

Arguments:

    TdoEntry            Entry in the cache containing data to marshal

    MarshaledSize       Used to return the number of bytes in MarshaledBlob

    MarshaledBlob       Used to return the marshaled data

Returns:

    STATUS_SUCCESS

    STATUS_INVALID_PARAMETER

    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Length = 0;
    BYTE * Blob = NULL;
    ULONG Index;
    ULONG Records = 0;
    LIST_ENTRY * ListEntry;

    if ( TdoEntry == NULL ||
         MarshaledSize == NULL ||
         MarshaledBlob == NULL ) {

         LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in FTCache::MarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
         return STATUS_INVALID_PARAMETER;
    }

    //
    // First figure out how big the blob is going to be
    //

    //
    // Version number is at the beginning of every blob
    //

    Length = sizeof( ULONG );

    //
    // Number of entries follows the version # of the blob
    //

    Length += sizeof( ULONG );

    //
    // Every record has certain common elements.  Count them here.
    //

    Length += TdoEntry->RecordCount * (

        //
        // Length of the record
        //

        sizeof( ULONG ) +

        //
        // "Flags"
        //

        sizeof( ULONG ) +

        //
        // Timestamp
        //

        2 * sizeof( ULONG ) +

        //
        // Record type (no more tha 256 different values allowed)
        //

        sizeof( BYTE )
        );

    //
    // Iterate over top level name entries
    //

    for ( ListEntry = TdoEntry->TlnList.Flink;
          ListEntry != &TdoEntry->TlnList;
          ListEntry = ListEntry->Flink ) {

        TLN_ENTRY * TlnEntry;

        TlnEntry = TLN_ENTRY::EntryFromTdoEntry( ListEntry );

        //
        // Ignore artifically inserted "pseudo" entries
        //

        if ( !( TlnEntry->Excluded ||
                TlnEntry->SubordinateEntry == NULL )) {

            continue;
        }

        ASSERT( Records < TdoEntry->RecordCount );
        Records += 1;

        __try {

            Length += LsapMarshalString( NULL, &TlnEntry->TlnKey->TopLevelName );

        } __except ( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
            break;
        }
    }

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    //
    // Iterate over domain info entries
    //

    for ( ListEntry = TdoEntry->DomainInfoList.Flink;
          ListEntry != &TdoEntry->DomainInfoList;
          ListEntry = ListEntry->Flink ) {

        DOMAIN_INFO_ENTRY * DomainInfoEntry;

        DomainInfoEntry = DOMAIN_INFO_ENTRY::EntryFromTdoEntry( ListEntry );

        ASSERT( Records < TdoEntry->RecordCount );
        Records += 1;

        __try {

            Length += LsapMarshalSid( NULL, DomainInfoEntry->Sid );
            Length += LsapMarshalString( NULL, &DomainInfoEntry->DnsKey->DnsName );
            Length += LsapMarshalString( NULL, &DomainInfoEntry->NetbiosKey->NetbiosName );

        } __except ( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
            break;
        }
    }

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    //
    // Iterate over binary entries
    //

    for ( ListEntry = TdoEntry->BinaryList.Flink;
          ListEntry != &TdoEntry->BinaryList;
          ListEntry = ListEntry->Flink ) {

        BINARY_ENTRY * BinaryEntry;

        BinaryEntry = BINARY_ENTRY::EntryFromTdoEntry( ListEntry );

        ASSERT( Records < TdoEntry->RecordCount );
        Records += 1;

        Length += BinaryEntry->Data.Length;
    }

    ASSERT( NT_SUCCESS( Status ));
    ASSERT( Records == TdoEntry->RecordCount );

    //
    // Now, allocate space and populate it
    //

    ASSERT( Length > 0 );
    Blob = ( BYTE * )FtcAllocate( Length );

    if ( Blob == NULL ) {

         LsapDsDebugOut(( DEB_FTINFO, "Out of memory in FTCache::MarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
         Status = STATUS_INSUFFICIENT_RESOURCES;
         goto Error;
    }

    //
    // Start with the version # of the blob
    //

    Index = 0;
    SmbPutUlong( &Blob[Index], LSAP_FOREST_TRUST_BLOB_VERSION );
    Index += sizeof( ULONG );
    ASSERT( Index <= Length );

    //
    // Number of entries follows the version # of the blob
    //

    SmbPutUlong( &Blob[Index], TdoEntry->RecordCount );
    Index += sizeof( ULONG );
    ASSERT( Index <= Length );

    //
    // Iterate over top level name entries
    //

    for ( ListEntry = TdoEntry->TlnList.Flink;
          ListEntry != &TdoEntry->TlnList;
          ListEntry = ListEntry->Flink ) {

        TLN_ENTRY * TlnEntry;
        ULONG StartingIndex;

        TlnEntry = TLN_ENTRY::EntryFromTdoEntry( ListEntry );

        //
        // Ignore artifically inserted "pseudo" entries
        //

        if ( !( TlnEntry->Excluded ||
                TlnEntry->SubordinateEntry == NULL )) {

            continue;
        }

        //
        // Reserve space for the length
        //

        StartingIndex = Index;
        Index += sizeof( ULONG );

        //
        // "Flags"
        //

        SmbPutUlong( &Blob[Index], TlnEntry->Flags());
        Index += sizeof( ULONG );
        ASSERT( Index <= Length );

        //
        // Timestamp
        //

        SmbPutUlong( &Blob[Index], TlnEntry->Time.HighPart );
        Index += sizeof( ULONG );
        ASSERT( Index <= Length );

        SmbPutUlong( &Blob[Index], TlnEntry->Time.LowPart );
        Index += sizeof( ULONG );
        ASSERT( Index <= Length );

        //
        // Record type
        //

        Blob[Index] = ( BYTE )( TlnEntry->Excluded ?
                                   ForestTrustTopLevelNameEx :
                                   ForestTrustTopLevelName );
        Index += sizeof( BYTE );
        ASSERT( Index <= Length );

        __try {

            Index += LsapMarshalString( &Blob[Index], &TlnEntry->TlnKey->TopLevelName );
            ASSERT( Index <= Length );

        } __except ( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
            break;
        }

        //
        // Remember the length
        //

        SmbPutUlong( &Blob[StartingIndex], Index - ( StartingIndex + sizeof( ULONG )));
    }

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    //
    // Iterate over domain info entries
    //

    for ( ListEntry = TdoEntry->DomainInfoList.Flink;
          ListEntry != &TdoEntry->DomainInfoList;
          ListEntry = ListEntry->Flink ) {

        DOMAIN_INFO_ENTRY * DomainInfoEntry;
        ULONG StartingIndex;

        DomainInfoEntry = DOMAIN_INFO_ENTRY::EntryFromTdoEntry( ListEntry );

        //
        // Reserve space for the length
        //

        StartingIndex = Index;
        Index += sizeof( ULONG );

        //
        // "Flags"
        //

        SmbPutUlong( &Blob[Index], DomainInfoEntry->Flags());
        Index += sizeof( ULONG );
        ASSERT( Index <= Length );

        //
        // Timestamp
        //

        SmbPutUlong( &Blob[Index], DomainInfoEntry->Time.HighPart );
        Index += sizeof( ULONG );
        ASSERT( Index <= Length );

        SmbPutUlong( &Blob[Index], DomainInfoEntry->Time.LowPart );
        Index += sizeof( ULONG );
        ASSERT( Index <= Length );

        //
        // Record type
        //

        Blob[Index] = ( BYTE )( ForestTrustDomainInfo );
        Index += sizeof( BYTE );
        ASSERT( Index <= Length );

        __try {

            Index += LsapMarshalSid( &Blob[Index], DomainInfoEntry->Sid );
            ASSERT( Index <= Length );

            Index += LsapMarshalString( &Blob[Index], &DomainInfoEntry->DnsKey->DnsName );
            ASSERT( Index <= Length );

            Index += LsapMarshalString( &Blob[Index], &DomainInfoEntry->NetbiosKey->NetbiosName );
            ASSERT( Index <= Length );

        } __except ( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
            break;
        }

        //
        // Remember the length
        //

        SmbPutUlong( &Blob[StartingIndex], Index - ( StartingIndex + sizeof( ULONG )));
    }

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    //
    // Iterate over binary entries
    //

    for ( ListEntry = TdoEntry->BinaryList.Flink;
          ListEntry != &TdoEntry->BinaryList;
          ListEntry = ListEntry->Flink ) {

        BINARY_ENTRY * BinaryEntry;
        ULONG StartingIndex;

        BinaryEntry = BINARY_ENTRY::EntryFromTdoEntry( ListEntry );

        //
        // Every unrecognized entry must have the high bit set
        //

        ASSERT( ((INT)BinaryEntry->Type) & LSA_FOREST_TRUST_RECORD_TYPE_UNRECOGNIZED );

        //
        // Reserve space for the length
        //

        StartingIndex = Index;
        Index += sizeof( ULONG );

        //
        // "Flags"
        //

        SmbPutUlong( &Blob[Index], BinaryEntry->Flags());
        Index += sizeof( ULONG );
        ASSERT( Index <= Length );

        //
        // Timestamp
        //

        SmbPutUlong( &Blob[Index], BinaryEntry->Time.HighPart );
        Index += sizeof( ULONG );
        ASSERT( Index <= Length );

        SmbPutUlong( &Blob[Index], BinaryEntry->Time.LowPart );
        Index += sizeof( ULONG );
        ASSERT( Index <= Length );

        //
        // Record type
        //

        Blob[Index] = ( BYTE )( BinaryEntry->Type );
        Index += sizeof( BYTE );
        ASSERT( Index <= Length );

        RtlCopyMemory( &Blob[Index], BinaryEntry->Data.Buffer, BinaryEntry->Data.Length );
        Index += BinaryEntry->Data.Length;
        ASSERT( Index <= Length );

        //
        // Remember the length
        //

        SmbPutUlong( &Blob[StartingIndex], Index - ( StartingIndex + sizeof( ULONG )));
    }

    ASSERT( Status == STATUS_SUCCESS );

Cleanup:

    *MarshaledSize = Length;
    *MarshaledBlob = Blob;

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));

    FtcFree( Blob );

    Blob = NULL;
    Length = 0;

    goto Cleanup;
}



NTSTATUS
LsapForestTrustUnmarshalBlob(
    IN ULONG Length,
    IN BYTE * Blob,
    IN LSA_FOREST_TRUST_RECORD_TYPE HighestRecordType,
    OUT LSA_FOREST_TRUST_INFORMATION * ForestTrustInfo
    )
/*++

Routine Description:

    Takes a marshalled blob and makes sense of it by extracting a coherent
    forest trust information structure

Arguments:

    Length              Length of the buffer pointed to by Blob

    Blob                Marshaled data

    HighestRecordType   Highest record type the client understands

    ForestTrustInfo     Used to return the unmarshaled information

Returns:

    STATUS_SUCCESS

    STATUS_INVALID_PARAMETER

    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS Status;
    ULONG Index = 0;
    ULONG i = 0;

    //
    // ISSUE-2000/07/21-markpu
    // highest record type is as yet unused
    //

    UNREFERENCED_PARAMETER( HighestRecordType );

    if ( Blob == NULL ||
         ForestTrustInfo == NULL ) {

         LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
         return STATUS_INVALID_PARAMETER;
    }

    ForestTrustInfo->RecordCount = 0;
    ForestTrustInfo->Entries = NULL;

    __try {

        ULONG Version;

        //
        // Retrieve and check the version # of the blob
        //

        Version = SmbGetUlong( &Blob[Index] );
        Index += sizeof( ULONG );
        if ( Index > Length ) {

            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            ASSERT( FALSE );
            goto Error;
        }

        if ( Version != LSAP_FOREST_TRUST_BLOB_VERSION ) {

            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            goto Error;
        }

        //
        // Retrieve the number of entries and allocate space for the array
        //

        ForestTrustInfo->RecordCount = SmbGetUlong( &Blob[Index] );
        Index += sizeof( ULONG );
        ASSERT( Index <= Length );
        if ( Index > Length ) {

            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            ASSERT( FALSE );
            goto Error;
        }

        if ( ForestTrustInfo->RecordCount > 0 ) {

            ForestTrustInfo->Entries = ( LSA_FOREST_TRUST_RECORD * * )FtcAllocate(
                                           ForestTrustInfo->RecordCount *
                                           sizeof( LSA_FOREST_TRUST_RECORD * )
                                           );

            if ( ForestTrustInfo->Entries == NULL ) {

                LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }
        }

        for ( i = 0 ; i < ForestTrustInfo->RecordCount ; i++ ) {

            LSA_FOREST_TRUST_RECORD * Record;
            ULONG RecordLength;
            ULONG StartingIndex;

            Record = ForestTrustInfo->Entries[i] = ( LSA_FOREST_TRUST_RECORD * )FtcAllocate(
                                                       sizeof( LSA_FOREST_TRUST_RECORD )
                                                       );

            if ( Record == NULL ) {

                LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }

            StartingIndex = Index;

            RecordLength = SmbGetUlong( &Blob[Index] );
            Index += sizeof( ULONG );
            if ( Index > Length ) {

                LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
                Status = STATUS_INVALID_PARAMETER;
                ASSERT( FALSE );
                goto Error;
            }

            Record->Flags = SmbGetUlong( &Blob[Index] );
            Index += sizeof( ULONG );
            if ( Index > Length ) {

                LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
                Status = STATUS_INVALID_PARAMETER;
                ASSERT( FALSE );
                goto Error;
            }

            Record->Time.HighPart = SmbGetUlong( &Blob[Index] );
            Index += sizeof( ULONG );
            if ( Index > Length ) {

                LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
                Status = STATUS_INVALID_PARAMETER;
                ASSERT( FALSE );
                goto Error;
            }

            Record->Time.LowPart = SmbGetUlong( &Blob[Index] );
            Index += sizeof( ULONG );
            if ( Index > Length ) {

                LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
                Status = STATUS_INVALID_PARAMETER;
                ASSERT( FALSE );
                goto Error;
            }

            Record->ForestTrustType = ( LSA_FOREST_TRUST_RECORD_TYPE )Blob[Index];
            Index += sizeof( BYTE );
            if ( Index > Length ) {

                LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
                Status = STATUS_INVALID_PARAMETER;
                ASSERT( FALSE );
                goto Error;
            }

            switch ( Record->ForestTrustType ) {

            case ForestTrustTopLevelName:
            case ForestTrustTopLevelNameEx:

                Index += LsapUnmarshalString( &Blob[Index], &Record->ForestTrustData.TopLevelName );
                if ( Index > Length ) {

                    LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
                    Status = STATUS_INVALID_PARAMETER;
                    ASSERT( FALSE );
                    goto Error;
                }

                break;

            case ForestTrustDomainInfo:

                Index += LsapUnmarshalSid( &Blob[Index], ( PISID * )&Record->ForestTrustData.DomainInfo.Sid );
                if ( Index > Length ) {

                    LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
                    Status = STATUS_INVALID_PARAMETER;
                    ASSERT( FALSE );
                    goto Error;
                }

                Index += LsapUnmarshalString( &Blob[Index], &Record->ForestTrustData.DomainInfo.DnsName );
                if ( Index > Length ) {

                    LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
                    Status = STATUS_INVALID_PARAMETER;
                    ASSERT( FALSE );
                    goto Error;
                }

                Index += LsapUnmarshalString( &Blob[Index], &Record->ForestTrustData.DomainInfo.NetbiosName );
                if ( Index > Length ) {

                    LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
                    Status = STATUS_INVALID_PARAMETER;
                    ASSERT( FALSE );
                    goto Error;
                }

                break;

            default:

                //
                // Funky typecast to get around limitations on assigning
                // integer values to enums
                //

                *( INT * )&Record->ForestTrustType = ( INT )Record->ForestTrustType | LSA_FOREST_TRUST_RECORD_TYPE_UNRECOGNIZED;

                Index += LsapUnmarshalData(
                             &Blob[Index],
                             Length,
                             &Record->ForestTrustData.Data
                             );

                if ( Index > Length ) {

                    LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
                    Status = STATUS_INVALID_PARAMETER;
                    ASSERT( FALSE );
                    goto Error;
                }

                break;
            }

            //
            // Cross-check the reported record length
            //

            ASSERT( RecordLength == Index - ( StartingIndex + sizeof( ULONG )));
        }

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

        Status = GetExceptionCode();

        if ( Status == STATUS_ACCESS_VIOLATION ) {

            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            ASSERT( FALSE ); // this indicates a bug
        }

        goto Error;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));

    if ( ForestTrustInfo != NULL ) {

        ForestTrustInfo->RecordCount = i;
        LsapFreeForestTrustInfo( ForestTrustInfo );
    }

    goto Cleanup;
}


///////////////////////////////////////////////////////////////////////////////
//
// Routines for manipulating local forest information
//
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
LsapAddTreeTrustInfo(
    IN OUT PNL_FTINFO_CONTEXT Context,
    IN PLSAPR_TREE_TRUST_INFO Tti
    )
/*++

Routine Description:

    Adds information about the subtree described by 'Tti' to the given context
    Calls itself recursively for child trees of 'Tti'

Arguments:

    Context        context to add to

    Tti            structure describing a domain subtree

Returns:

    STATUS_SUCCESS

    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS Status;
    ULONG i;

    ASSERT( Context );
    ASSERT( Tti );

    //
    // Add a TLN entry.
    // Subordinate TLN entries are expunged as necessary
    //

    if ( FALSE == NetpAddTlnFtinfoEntry(
                      Context,
                      &Tti->DnsDomainName )) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapAddTreeTrustInfo (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // Add a domain entry
    //

    if ( Tti->DomainSid == NULL ) {

        //
        // "Young" X-Ref objects might exist without a SID (because a new
        // child domain X-Ref is created without a SID, a SID is added later.
        // Domain info entries without SIDs are not considered valid, so for
        // the time being, do not insert the domain info entry for this X-Ref.
        // Later, the X-Ref will have the SID added to it, at which point
        // replication will take care of inserting the proper information into
        // the tree.
        //

        LsapDsDebugOut(( DEB_FTINFO, "LsapAddTreeTrustInfo: skipping domain info entry for %wZ\n", &Tti->DnsDomainName, __FILE__, __LINE__ ));

    } else if ( FALSE == NetpAllocFtinfoEntry(
                             Context,
                             ForestTrustDomainInfo,
                             &Tti->DnsDomainName,
                             Tti->DomainSid,
                             &Tti->FlatName )) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapAddTreeTrustInfo (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // Call ourselves recursively for every child domain
    //

    for ( i = 0 ; i < Tti->Children ; i++ ) {

        Status = LsapAddTreeTrustInfo(
                     Context,
                     &Tti->ChildDomains[i]
                     );

        if ( !NT_SUCCESS( Status )) {

            LsapDsDebugOut(( DEB_FTINFO, "LsapAddTreeTrustInfo: LslapAddTreeTrustInfo returned 0x%x\n", Status ));
            goto Error;
        }
    }

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));
    goto Cleanup;
}


NTSTATUS
LsaIGetForestTrustInformation(
    OUT PLSA_FOREST_TRUST_INFORMATION *ForestTrustInfo
    )

/*++

Routine Description:

    Worker routine to get the ForestTrustInformation array for the local domain.

Arguments:

    ForestTrustInfo - Returns a pointer to a structure containing a count and an
        array of FTInfo records describing the namespaces claimed by the
        domain specified by TrustedDomainName. The Accepted field and Time
        field of all returned records will be zero.  The buffer should be freed
        by calling MIDL_user_free.

Return Value:

    STATUS_SUCCESS

    STATUS_INSUFFICIENT_RESOURCES    out of memory

    STATUS_INVALID_DOMAIN_STATE      must be called on a DC in a root domain

--*/
{
    NTSTATUS Status;
    ULONG i;
    PLSAP_UPN_SUFFIXES UpnSuffixes = NULL;
    PLSAPR_FOREST_TRUST_INFO Fti = NULL;
    NL_FTINFO_CONTEXT Context;

    //
    // Initialization
    //

    *ForestTrustInfo = NULL;
    NetpInitFtinfoContext( &Context );

    //
    // First get a list of all the domains in the forest.
    //

    Status = LsaIQueryForestTrustInfo(
                 LsapPolicyHandle,
                 &Fti
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsaIGetForestTrustInformation: LsaIQueryForestTrustInfo returned 0x%x\n", Status ));
        goto Error;
    }

    //
    // Operation only allowed on the root domain of the forest
    // If parent domain reference exists, we are not the root domain
    //

    if ( Fti->ParentDomainReference != NULL ) {

        Status = STATUS_INVALID_DOMAIN_STATE;
        goto Error;
    }

    //
    // Add TLN entries and domain info entries from the forest
    //

    Status = LsapAddTreeTrustInfo(
                 &Context,
                 &Fti->RootTrust
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsaIGetForestTrustInformation: LsapAddTreeTrustInfo returned 0x%x\n", Status ));
        goto Error;
    }

    //
    // Get the list of UPN and SPN suffixes
    //

    Status = LsaIQueryUpnSuffixes( &UpnSuffixes );

    if ( !NT_SUCCESS(Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsaIGetForestTrustInformation: LsaIQueryUpnSuffixes returned 0x%x\n", Status ));
        goto Error;
    }

    //
    // Add each UPN/SPN suffix as a TLN
    //

    for ( i = 0 ; i < UpnSuffixes->SuffixCount ; i++ ) {

        UNICODE_STRING * UpnSuffix = &UpnSuffixes->Suffixes[i];
        BOOLEAN Valid;

        //
        // All sorts of strings can claim to be UPN suffixes.
        // Only allow those that pass our validation checking.
        //

        LsapValidateDnsName( UpnSuffix, &Valid );

        if ( !Valid ) {

            continue;
        }

        if ( !NetpAddTlnFtinfoEntry(
                  &Context,
                  UpnSuffix )) {

            LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsaIGetForestTrustInformation (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }
    }

    //
    // Return the collected entries to the caller.
    //

    *ForestTrustInfo = NetpCopyFtinfoContext( &Context );

    if ( *ForestTrustInfo == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsaIGetForestTrustInformation (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;

    } else if ( !LsapValidateForestTrustInfo( *ForestTrustInfo )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsaIGetForestTrustInformation: Generated forest trust information internally inconsistent\n" ));
        Status = STATUS_INTERNAL_DB_ERROR;
        goto Error;
    }

Cleanup:

    NetpCleanFtinfoContext( &Context );
    LsaIFree_LSAP_UPN_SUFFIXES( UpnSuffixes );

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));
    goto Cleanup;
}



NTSTATUS
LsaIUpdateForestTrustInformation(
    IN LSAPR_HANDLE PolicyHandle,
    IN UNICODE_STRING * TrustedDomainName,
    IN PLSA_FOREST_TRUST_INFORMATION NewForestTrustInfo
    )
/*++

Routine Description:

    This function write the specified NewForestTrustInfo onto the named TDO.

    The NewForestTrustInfo is merged with the exsiting information using the following algorithm:

    The FTinfo records written are described in the NetpMergeFTinfo routine.

Arguments:

    PolicyHandle      - open policy handle

    TrustedDomainName - Trusted domain that is to be updated.  This domain must have the
        TRUST_ATTRIBUTE_FOREST_TRANSITIVE bit set.

    NewForestTrustInfo - Specified the new array of FTinfo records as returned from the
        trusted domain.

Return Value:

    STATUS_SUCCESS: Success.

    STATUS_INVALID_PARAMETER   NewForestTrustInfo passed in is incorrect

--*/
{
    NTSTATUS Status;
    PLSA_FOREST_TRUST_INFORMATION OldForestTrustInfo = NULL;
    PLSA_FOREST_TRUST_INFORMATION MergedForestTrustInfo = NULL;
    PLSA_FOREST_TRUST_COLLISION_INFORMATION CollisionInfo = NULL;

    if ( !LsapValidateForestTrustInfo( NewForestTrustInfo )) {

        LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsaIUpdateForestTrustInformation (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    Status = LsarQueryForestTrustInformation(
                 PolicyHandle,
                 TrustedDomainName,
                 ForestTrustRecordTypeLast,
                 &OldForestTrustInfo
                 );

    if ( Status == STATUS_NOT_FOUND ) {

        //
        // If there's no FTinfo on the TDO,
        //  that's OK.
        //

        OldForestTrustInfo = NULL;
        Status = STATUS_SUCCESS;

    } else if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsaIUpdateForestTrustInformation: %wZ: LsarQueryForestTrustInformation returned 0x%lx\n", TrustedDomainName, Status));
        goto Error;
    }

    //
    // Compute the merged FTINFO
    //

    Status = NetpMergeFtinfo(
                 TrustedDomainName,
                 NewForestTrustInfo,
                 OldForestTrustInfo,
                 &MergedForestTrustInfo
                 );

    if ( !NT_SUCCESS(Status) ) {

        LsapDsDebugOut(( DEB_FTINFO, "LsaIUpdateForestTrustInformation: %wZ: NetpMergeTrustInformation returned 0x%lx\n", TrustedDomainName, Status));
        goto Error;
    }

    ASSERT( LsapValidateForestTrustInfo( MergedForestTrustInfo ));

    //
    // Write the merge FTINFO back to the LSA
    //

    Status = LsarSetForestTrustInformation(
                 PolicyHandle,
                 TrustedDomainName,
                 ForestTrustRecordTypeLast,
                 MergedForestTrustInfo,
                 FALSE,       // Don't just check for collisions
                 &CollisionInfo
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsaIUpdateForestTrustInformation: %wZ: LsarSetForestTrustInformation returned 0x%lx\n", TrustedDomainName, Status));
        goto Error;
    }

Cleanup:

    LsaIFree_LSA_FOREST_TRUST_INFORMATION( &OldForestTrustInfo );
    LsaIFree_LSA_FOREST_TRUST_COLLISION_INFORMATION( &CollisionInfo );
    MIDL_user_free( MergedForestTrustInfo );

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));
    goto Cleanup;
}



NTSTATUS
LsapForestTrustInsertLocalInfo(
    )
/*++

Routine Description:

    Inserts information about the local forest into the cache

Arguments:

    None

Returns:

    NTSTATUS - Standard Nt Result Code

--*/
{
    NTSTATUS Status;
    PLSA_FOREST_TRUST_INFORMATION LocalForestTrustInfo = NULL;
    PPOLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfo = NULL;

    //
    // Insert the data for the local forest into the cache
    //

    Status = LsaIGetForestTrustInformation(
                 &LocalForestTrustInfo
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustInsertLocalInfo: LsaIGetForestTrustInformation returned 0x%x\n", Status ));
        goto Error;
    }

    //
    // Need the local domain SID and DNS domain name
    //

    Status = LsapDbQueryInformationPolicy(
                 LsapPolicyHandle,
                 PolicyDnsDomainInformation,
                 ( PLSAPR_POLICY_INFORMATION *)&PolicyDnsDomainInfo
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustInsertLocalInfo: LsapDbQueryInformationPolicy returned 0x%x\n", Status ));
        goto Error;
    }

    Status = LsapForestTrustCacheInsert(
                 &PolicyDnsDomainInfo->DnsDomainName,
                 PolicyDnsDomainInfo->Sid,
                 LocalForestTrustInfo,
                 TRUE
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustInsertLocalInfo: LsapForestTrustCacheInsert returned 0x%x\n", Status ));
        goto Error;
    }

Cleanup:

    LsaIFree_LSAPR_POLICY_INFORMATION(
        PolicyDnsDomainInformation,
        ( PLSAPR_POLICY_INFORMATION )PolicyDnsDomainInfo
        );

    MIDL_user_free( LocalForestTrustInfo );

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));
    goto Cleanup;
}


///////////////////////////////////////////////////////////////////////////////
//
// Exported set/query/match routines
//
///////////////////////////////////////////////////////////////////////////////



BOOLEAN
LsapHavingForestTrustMakesSense(
    IN ULONG TrustDirection,
    IN ULONG TrustType,
    IN ULONG TrustAttributes
    )
/*++

Routine Description:

    Determines whether the TDO is of the kind that may contain
    forest trust information

Arguments:

    TrustDirection

    TrustType

    TrustAttributes

Returns:

    TRUE/FALSE

--*/
{
    UNREFERENCED_PARAMETER( TrustDirection );
    UNREFERENCED_PARAMETER( TrustType );

#ifdef XFOREST_CIRCUMVENT

    if ( !LsapDbNoMoreWin2K()) {

        //
        // The backdoor is present, but cross-forest trust is not enabled,
        // so behave as if the forest transitive bit was not set
        //

        TrustAttributes &= ~TRUST_ATTRIBUTE_FOREST_TRANSITIVE;
    }
#endif

    return ( 0 != ( TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE ));
}



NTSTATUS
LsarQueryForestTrustInformation(
    IN LSAPR_HANDLE PolicyHandle,
    IN LSA_UNICODE_STRING * TrustedDomainName,
    IN LSA_FOREST_TRUST_RECORD_TYPE HighestRecordType,
    OUT PLSA_FOREST_TRUST_INFORMATION * ForestTrustInfo
    )
/*++

Routine Description

    The LsarQueryForestTrustInformation API returns forest trust information
    for the given trusted domain object.

Arguments:

    PolicyHandle - An open handle to a Policy object

    TrustedDomainName - Name of the trusted domain object

    HighestRecordType - Highest enum value recognized by the client

    ForestTrustInfo - Used to return forest trust information

Returns:

    NTSTATUS - Standard Nt Result Code

    STATUS_SUCCESS

    STATUS_INVALID_PARAMETER          Parameters were somehow invalid
                                      Most likely, the TRUST_ATTRIBUTE_FOREST_TRANSITIVE
                                      trust attribute bit is not set on the TDO

    STATUS_NOT_FOUND                  Forest trust information does not exist for this TDO

    STATUS_NO_SUCH_DOMAIN             The specified TDO does not exist

    STATUS_INSUFFICIENT_RESOURCES     Ran out of memory

    STATUS_INVALID_DOMAIN_STATE       Operation is only legal on domain controllers in root domain

--*/
{
    NTSTATUS Status;
    LSAP_DB_OBJECT_INFORMATION ObjInfo;
    LSAPR_HANDLE TrustedDomainHandle = NULL;
    BOOLEAN CacheLocked = FALSE;
    BOOLEAN ObjectReferenced = FALSE;
    BOOLEAN TrustedDomainListLocked = FALSE;
    LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY * TrustInfoForName;

    LsarpReturnCheckSetup();
    LsapEnterFunc( "LsarQueryForestTrustInformation" );
    LsapTraceEvent( EVENT_TRACE_TYPE_START, LsaTraceEvent_QueryForestTrustInformation );

    //
    // Validate the input buffer
    //

    if ( ForestTrustInfo == NULL ||
         !LsapValidateLsaUnicodeString( TrustedDomainName )) {

        LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsarQueryForestTrustInformation (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    *ForestTrustInfo = NULL;

    //
    // Under current design, only domains in the root domain of the forest
    // can have forest trust information
    //

    if ( !LsapDbDcInRootDomain()) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarQueryForestTrustInformation: must be a DC in the root domain\n" ));
        Status = STATUS_INVALID_DOMAIN_STATE;
        goto Error;
    }

    //
    // Cross-forest trust will not work until all domain controllerss
    //  in the forest have been upgraded to Whistler
    //

    if ( !LsapDbNoMoreWin2K()) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarQueryForestTrustInformation: must have an all-Whistler forest\n" ));
        Status = STATUS_INVALID_DOMAIN_STATE;
        goto Error;
    }

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 0,
                 PolicyObject,
                 TrustedDomainObject,
                 LSAP_DB_LOCK |
                    LSAP_DB_READ_ONLY_TRANSACTION |
                    LSAP_DB_DS_OP_TRANSACTION
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarQueryForestTrustInformation: LsapDbReferenceObject returned 0x%x\n", Status ));
        goto Error;
    }

    ObjectReferenced = TRUE;

    //
    // Get the right name.  Entries in the forest trust cache
    // are located by full name name, NOT flat name
    //

    Status = LsapDbAcquireReadLockTrustedDomainList();

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarQueryForestTrustInformation: LsapDbAcquireReadLockTrustedDomainList returned 0x%x\n", Status ));
        goto Error;
    }

    TrustedDomainListLocked = TRUE;

    //
    // Get the right name
    //

    Status = LsapDbLookupNameTrustedDomainListEx(
                 ( LSAPR_UNICODE_STRING * )TrustedDomainName,
                 &TrustInfoForName
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarQueryForestTrustInformation: No trust entry found for %wZ: 0x%lx\n", ( UNICODE_STRING * )TrustedDomainName, Status ));
        goto Error;
    }

    if ( !LsapHavingForestTrustMakesSense(
              TrustInfoForName->TrustInfoEx.TrustDirection,
              TrustInfoForName->TrustInfoEx.TrustType,
              TrustInfoForName->TrustInfoEx.TrustAttributes )) {

        LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsarQueryForestTrustInformation (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    //
    // Build a temporary handle
    //
    // ISSUE-2000/07/27-markpu
    //         do we need to open the object?
    //         we don't use the handle for anything
    //         except verifying access (TRUSTED_QUERY_AUTH)
    //

    //
    // For purposes of forest trust, entries are identified by full name only
    //

    RtlZeroMemory( &ObjInfo, sizeof( ObjInfo ));
    ObjInfo.ObjectTypeId = TrustedDomainObject;
    ObjInfo.ContainerTypeId = NullObject;
    ObjInfo.Sid = NULL;
    ObjInfo.DesiredObjectAccess = TRUSTED_QUERY_AUTH;

    InitializeObjectAttributes(
        &ObjInfo.ObjectAttributes,
        ( UNICODE_STRING * )&TrustInfoForName->TrustInfoEx.Name,
        0L,
        PolicyHandle,
        NULL
        );

    //
    // Get a handle to the TDO
    //

    Status = LsapDbOpenObject(
                 &ObjInfo,
                 TRUSTED_QUERY_AUTH,
                 0,
                 &TrustedDomainHandle
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarQueryForestTrustInformation: LsapDbOpenObject returned 0x%x\n", Status ));
        goto Error;
    }

    Status = LsapForestTrustCacheRetrieve(
                 ( UNICODE_STRING * )&TrustInfoForName->TrustInfoEx.Name,
                 ForestTrustInfo
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarQueryForestTrustInformation: LsapForestTrustCacheRetrieve returned 0x%x\n", Status ));
        goto Error;
    }

    ASSERT( LsapValidateForestTrustInfo( *ForestTrustInfo ));

Cleanup:

    if ( TrustedDomainHandle != NULL ) {

        LsapDbCloseObject(
            &TrustedDomainHandle,
            0,
            Status
            );
    }

    if ( TrustedDomainListLocked ) {

        LsapDbReleaseLockTrustedDomainList();
    }

    //
    // Dereference the object
    //

    if ( ObjectReferenced ) {

        Status = LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     TrustedDomainObject,
                     LSAP_DB_LOCK |
                        LSAP_DB_READ_ONLY_TRANSACTION |
                        LSAP_DB_DS_OP_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    LsapTraceEvent( EVENT_TRACE_TYPE_END, LsaTraceEvent_QueryForestTrustInformation );
    LsapExitFunc( "LsarQueryForestTrustInformation", Status );
    LsarpReturnPrologue();

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));

    goto Cleanup;
}



NTSTATUS
LsarSetForestTrustInformation(
    IN LSAPR_HANDLE PolicyHandle,
    IN LSA_UNICODE_STRING * TrustedDomainName,
    IN LSA_FOREST_TRUST_RECORD_TYPE HighestRecordType,
    IN LSA_FOREST_TRUST_INFORMATION * ForestTrustInfo,
    IN BOOLEAN CheckOnly,
    OUT PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo
    )
/*++

Routine Description

    The LsarSetForestTrustInformation API sets forest trust information
    on the given trusted domain object.

    In case if it fails the operation due to a collision, it will return
    the list of entries that conflicted.

Arguments:

    PolicyHandle - An open handle to a Policy object

    TrustedDomainName - Name of the trusted domain object

    HighestRecordType - Highest enum value recognized by the client

    ForestTrustInfo - Contains forest trust information to set
                      If RecordCount is 0, current forest trust information
                      will be deleted

    CheckOnly       - if TRUE, perform collision detection only without actually
                      committing anything to permanent storage

    CollisionInfo   - In case of collision error, used to return collision info

Returns:

    STATUS_SUCCESS

    STATUS_INVALID_PARAMETER          Parameters were somehow invalid

    STATUS_INSUFFICIENT_RESOURCES     Ran out of memory

    STATUS_INVALID_DOMAIN_STATE       Operation is only legal on domain controllers in root domain

    STATUS_INVALID_DOMAIN_ROLE        Operation is only legal on the primary domain controller

    STATUS_INVALID_SERVER_STATE       The server is shutting down and can not
                                      process the request
--*/
{
    NTSTATUS Status;
    LSAP_DB_OBJECT_INFORMATION ObjInfo;
    LSAPR_HANDLE TrustedDomainHandle = NULL;
    BOOLEAN ObjectReferenced = FALSE;
    BOOLEAN TrustedDomainListLocked = FALSE;
    LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY * TrustInfoForName = NULL;
    LSAP_DB_ATTRIBUTE Attributes[LSAP_DB_ATTRS_INFO_CLASS_DOMAIN];
    LSAP_DB_ATTRIBUTE * NextAttribute;
    ULONG AttributeCount = 0;
    ULONG BlobLength = 0;
    BYTE * BlobData = NULL;
    FTCache::TDO_ENTRY TdoEntryOld = {0};
    FTCache::TDO_ENTRY * TdoEntryNew = NULL;
    FTCache::CONFLICT_PAIR * ConflictPairs = NULL;
    ULONG ConflictPairsTotal = 0;
    DOMAIN_SERVER_ROLE ServerRole;

    LsarpReturnCheckSetup();
    LsapEnterFunc( "LsarSetForestTrustInformation" );
    LsapTraceEvent( EVENT_TRACE_TYPE_START, LsaTraceEvent_SetForestTrustInformation );

    //
    // Top level pointers defer to [ref] and can not be NULL
    //

    ASSERT( ForestTrustInfo != NULL );
    ASSERT( CollisionInfo != NULL );

    //
    // Validate the input data
    //

    if ( !LsapValidateLsaUnicodeString( TrustedDomainName ) ||
         !LsapValidateForestTrustInfo( ForestTrustInfo )) {

        LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsarSetForestTrustInformation (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    *CollisionInfo = NULL;

    //
    // Under current design, only domains in the root domain of the forest
    // can have forest trust information set on them.
    //

    if ( !LsapDbDcInRootDomain()) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarSetForestTrustInformation: must be a DC in the root domain\n" ));
        Status = STATUS_INVALID_DOMAIN_STATE;
        goto Error;
    }

    //
    // Furthermore, forest trust information can only be set on the primary
    // domain controller 
    //

    ASSERT( LsapAccountDomainHandle );

    Status = SamIQueryServerRole(
                 LsapAccountDomainHandle,
                 &ServerRole
                 );

    if ( !NT_SUCCESS(Status)) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarSetForestTrustInformation: SamIQueryServerRole returned 0x%x\n", Status ));
        goto Error;

    } else if ( ServerRole != DomainServerRolePrimary ) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarSetForestTrustInformation: must be a PDC in the root domain\n" ));
        Status = STATUS_INVALID_DOMAIN_ROLE;
        goto Error;
    }

    //
    // Cross-forest trust will not work until all domain controllerss
    //  in the forest have been upgraded to Whistler
    //

    if ( !LsapDbNoMoreWin2K()) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarSetForestTrustInformation: must have an all-Whistler forest\n" ));
        Status = STATUS_INVALID_DOMAIN_STATE;
        goto Error;
    }

    //
    // The client should not understand more than we do:
    // the RPC interface should've stopped them
    //

    ASSERT( HighestRecordType <= ForestTrustRecordTypeLast );

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 0,
                 PolicyObject,
                 TrustedDomainObject,
                 LSAP_DB_LOCK
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarSetForestTrustInformation: LsapDbReferenceObject returned 0x%x\n", Status ));
        goto Error;
    }

    ObjectReferenced = TRUE;

    //
    // Lock the Trusted Domain List for the duration of the operation,
    // since we'll be making changes to it here
    //

    Status = LsapDbAcquireWriteLockTrustedDomainList();

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarSetForestTrustInformation: LsapDbAcquireWriteLockTrustedDomainList returned 0x%x\n", Status ));
        goto Error;
    }

    TrustedDomainListLocked = TRUE;

    //
    // Get the right name
    //

    Status = LsapDbLookupNameTrustedDomainListEx(
                 ( LSAPR_UNICODE_STRING * )TrustedDomainName,
                 &TrustInfoForName
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarSetForestTrustInformation: No trust entry found for %wZ: 0x%lx\n", ( UNICODE_STRING * )TrustedDomainName, Status ));
        goto Error;
    }

    //
    // Build a temporary handle
    //

    RtlZeroMemory( &ObjInfo, sizeof( ObjInfo ));
    ObjInfo.ObjectTypeId = TrustedDomainObject;
    ObjInfo.ContainerTypeId = NullObject;
    ObjInfo.Sid = NULL;
    ObjInfo.DesiredObjectAccess = TRUSTED_SET_AUTH;

    InitializeObjectAttributes(
        &ObjInfo.ObjectAttributes,
        ( UNICODE_STRING * )&TrustInfoForName->TrustInfoEx.Name,
        0L,
        PolicyHandle,
        NULL
        );

    //
    // Get a handle to the TDO
    //

    Status = LsapDbOpenObject(
                 &ObjInfo,
                 TRUSTED_SET_AUTH,
                 0,
                 &TrustedDomainHandle
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarSetForestTrustInformation: LsapDbOpenObject returned 0x%x\n", Status ));
        goto Error;
    }

    if ( ForestTrustInfo->RecordCount > 0 ) {

        if ( !LsapHavingForestTrustMakesSense(
                  TrustInfoForName->TrustInfoEx.TrustDirection,
                  TrustInfoForName->TrustInfoEx.TrustType,
                  TrustInfoForName->TrustInfoEx.TrustAttributes )) {

            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsarSetForestTrustInformation (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            goto Error;
        }

        //
        // Insert the entry into the cache.
        // This is the first part of the insert operation:
        //  -- conflicts are not resolved
        //  -- old copy of the data is preserved in case
        //     the operation needs to be rolled back later
        //

        Status = g_FTCache->Insert(
                     ( UNICODE_STRING * )&TrustInfoForName->TrustInfoEx.Name,
                     ( PSID )TrustInfoForName->TrustInfoEx.Sid,
                     ForestTrustInfo,
                     FALSE,
                     &TdoEntryOld,
                     &TdoEntryNew,
                     &ConflictPairs,
                     &ConflictPairsTotal
                     );

        if ( !NT_SUCCESS( Status )) {

            LsapDsDebugOut(( DEB_FTINFO, "LsarSetForestTrustInformation: FTCache::Insert returned 0x%x\n", Status ));
            goto Error;
        }

        ASSERT( TdoEntryNew );

        //
        // The client wants to know what the deal is with conflicts
        //

        if ( ConflictPairs != NULL ) {

            Status = FTCache::GenerateConflictInfo(
                         ConflictPairs,
                         ConflictPairsTotal,
                         TdoEntryNew,
                         CollisionInfo
                         );

            if ( !NT_SUCCESS( Status )) {

                LsapDsDebugOut(( DEB_FTINFO, "LsarSetForestTrustInformation: FTCache::GenerateConflictInfo returned 0x%x\n", Status ));
                goto Error;
            }
        }

        //
        // Don't waste cycles marking entries as disabled or
        // marshalling the blob if we are not going to write it
        //

        if ( !CheckOnly ) {

            if ( ConflictPairs != NULL ) {

                FTCache::ReconcileConflictPairs(
                    TdoEntryNew,
                    ConflictPairs,
                    ConflictPairsTotal
                    );
            }

            //
            // Marshal the data in preparation for writing it to the DS
            //

            Status = FTCache::MarshalBlob(
                         TdoEntryNew,
                         &BlobLength,
                         &BlobData
                         );

            if ( !NT_SUCCESS( Status )) {

                LsapDsDebugOut(( DEB_FTINFO, "LsarSetForestTrustInformation: FTCache::MarshalBlob returned 0x%x\n", Status ));
                goto Error;
            }
        }
    }

    //
    // if only a collision check was requested, bail here
    //

    if ( CheckOnly ) {

        //
        // Rollback the changes made to the forest trust cache
        //

        if ( TdoEntryNew ) {

            g_FTCache->RollbackChanges( TdoEntryNew, &TdoEntryOld );
            TdoEntryNew = NULL;
        }

        goto Cleanup;
    }

    NextAttribute = Attributes;

    LsapDbInitializeAttributeDs(
        NextAttribute,
        TrDmForT,
        BlobData,
        BlobLength,
        FALSE
        );

    AttributeCount++;

    ASSERT( AttributeCount <= LSAP_DB_ATTRS_INFO_CLASS_DOMAIN );

    //
    // Write the attributes to the DS.
    //

    Status = LsapDbWriteAttributesObject(
                 TrustedDomainHandle,
                 Attributes,
                 AttributeCount
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsarSetForestTrustInformation: LsapDbWriteAttributesObject returned 0x%x\n", Status ));
        goto Error;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    //
    // DS write was successful - can now complete the cache transaction
    // While at it, if this wasn't a probing (CheckOnly) call, audit the changes
    //

    if ( NT_SUCCESS( Status ) && !CheckOnly) {

        if ( TdoEntryNew != NULL ) {

            ASSERT( ForestTrustInfo->RecordCount > 0 );

            g_FTCache->AuditChanges(
                TdoEntryOld.RecordCount > 0 ?
                   &TdoEntryOld : NULL,
                TdoEntryNew
                );

            //
            // Do not audit the collisions -- the collisions here only affect
            // the information passed in by the caller, and the caller is being
            // informed of them.
            //

        } else if ( ForestTrustInfo->RecordCount == 0 ) {

            FTCache::TDO_ENTRY * TdoEntry;

            //
            // ForestTrustInfo->RecordCount == 0 indicates a request for removal
            //

            TdoEntry = ( FTCache::TDO_ENTRY * )RtlLookupElementGenericTableAvl(
                                                   &g_FTCache->m_TdoTable,
                                                   ( UNICODE_STRING * )&TrustInfoForName->TrustInfoEx.Name
                                                   );

            if ( TdoEntry != NULL ) {

                g_FTCache->AuditChanges( TdoEntry, NULL );
            }

            Status = g_FTCache->Remove(( UNICODE_STRING * )&TrustInfoForName->TrustInfoEx.Name );

            if ( Status == STATUS_NOT_FOUND ) {

                Status = STATUS_SUCCESS;
            }

            //
            // Only a bug in the code would cause a deletion to fail
            //

            ASSERT( NT_SUCCESS( Status ));
        }
    }

    if ( TrustedDomainHandle != NULL ) {

        LsapDbCloseObject(
            &TrustedDomainHandle,
            0,
            Status
            );
    }

    FtcFree( BlobData );
    FtcFree( ConflictPairs );

    if ( TdoEntryOld.RecordCount > 0 ) {

        g_FTCache->PurgeTdoEntry( &TdoEntryOld );
    }

    if ( TrustedDomainListLocked ) {

        LsapDbReleaseLockTrustedDomainList();
    }

    if ( ObjectReferenced ) {

        Status = LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     TrustedDomainObject,
                     LSAP_DB_LOCK |
                        LSAP_DB_OMIT_REPLICATOR_NOTIFICATION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    LsapTraceEvent( EVENT_TRACE_TYPE_END, LsaTraceEvent_SetForestTrustInformation );
    LsapExitFunc( "LsarSetForestTrustInformation", Status );
    LsarpReturnPrologue();

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));

    LsapFreeCollisionInfo( CollisionInfo );
    ASSERT( *CollisionInfo == NULL );

    //
    // Rollback the changes made to the forest trust cache
    //

    if ( TdoEntryNew ) {

        g_FTCache->RollbackChanges( TdoEntryNew, &TdoEntryOld );
        TdoEntryNew = NULL;
    }

    goto Cleanup;
}



NTSTATUS
LsapForestTrustFindMatch(
    IN LSA_ROUTING_MATCH_TYPE Type,
    IN PVOID Data,
    OUT PLSA_UNICODE_STRING Match,
    OUT OPTIONAL BOOLEAN * IsLocal
    )
/*++

Routine Description:

    Finds match for given data in the cache

Arguments:

    Type                        Type of Data parameter

    Data                        Data to match

    Match                       Used to return the match, if found.
                                Caller must use LsaIFree_LSAPR_UNICODE_STRING_BUFFER

    IsLocal                     Used to report if the match is a name within
                                the local forest

Returns:

    STATUS_SUCCESS              Match was found

    STATUS_NO_MATCH             Match was not found

    STATUS_INVALID_DOMAIN_STATE Machine must be a GC or a DC in the root domain

    STATUS_INVALID_PARAMETER    Check the inputs

    STATUS_INTERNAL_ERROR       Cache is internally inconsistent

    STATUS_INSUFFICIENT_RESOURCES  Out of memory

--*/
{
    if ( !LsapDbDcInRootDomain()) {

        //
        // Bummer.  This domain controller is not part of the root DC.
        // We can only perform matching if this DC is also a GC
        //

        if ( !SamIAmIGC()) {

            //
            // Just in case: if there is data in the cache, throw it away
            //

            if ( g_FTCache != NULL ) {

                if ( NT_SUCCESS( LsapDbAcquireReadLockTrustedDomainList())) {

                    if ( g_FTCache->IsValid()) {

                        LsapDbConvertReadLockTrustedDomainListToExclusive();
                        g_FTCache->SetInvalid();
                    }

                    LsapDbReleaseLockTrustedDomainList();
                }
            }

            return STATUS_INVALID_DOMAIN_STATE;
        }
    }

    if ( g_FTCache == NULL ) {

        return STATUS_INTERNAL_ERROR;
    }

    return g_FTCache->Match( Type, Data, ( UNICODE_STRING * )Match, IsLocal );
}


///////////////////////////////////////////////////////////////////////////////
//
// Code required when running on a GC outside of the root domain
//
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
LsapForestTrustCacheInsertEntInf(
    IN ENTINF * EntInf
    )
/*++

Routine Description:

    Checks the trusted domain object corresponding to the given EntInf structure
    and. if appropriate, inserts the forest trust data into the forest trust cache

Arguments:

    EntInf                   result of a DS search

Returns:

    STATUS_SUCCESS           entry added OK

    STATUS_INTERNAL_ERROR    should never see this, really

    STATUS_INSUFFICIENT_RESOURCES     out of memory

    STATUS_NOT_FOUND         not all required attributes present

--*/
{
    NTSTATUS Status;
    UNICODE_STRING TrustedDomainName = {0};
    PSID TrustedDomainSid = NULL;
    ULONG TrustAttributes = 0, TrustDirection = 0, TrustType = 0;
    ULONG ForestTrustLength = 0;
    PBYTE ForestTrustData = NULL;
    LSA_FOREST_TRUST_INFORMATION ForestTrustInfo = {0};
    const USHORT TotalRequiredAttributes = 0x1 | 0x2 | 0x4 | 0x8;
    USHORT FoundRequiredAttributes = 0;
    BOOL IsDeleted = FALSE;
    BOOL ForestTrustDataPresent = FALSE;

    ASSERT( EntInf );
    ASSERT( LsapDbIsLockedTrustedDomainList());

    if ( g_FTCache == NULL ) {

        ASSERT( FALSE );
        return STATUS_INTERNAL_ERROR;
    }

    for ( ULONG i = 0 ; i < EntInf->AttrBlock.attrCount ; i++ ) {

        switch ( EntInf->AttrBlock.pAttr[i].attrTyp ) {

        case ATT_TRUST_PARTNER:

            FoundRequiredAttributes |= 0x1;

            TrustedDomainName.Buffer =  LSAP_DS_GET_DS_ATTRIBUTE_AS_PWSTR( &EntInf->AttrBlock.pAttr[i] );
            TrustedDomainName.Length = ( USHORT) LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( &EntInf->AttrBlock.pAttr[i] );
            TrustedDomainName.MaximumLength =  TrustedDomainName.Length;

            break;

        case ATT_SECURITY_IDENTIFIER: // optional

            TrustedDomainSid = ( PSID )LSAP_DS_GET_DS_ATTRIBUTE_AS_PWSTR( &EntInf->AttrBlock.pAttr[i] );
            break;

        case ATT_TRUST_ATTRIBUTES:

            FoundRequiredAttributes |= 0x2;

            TrustAttributes = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &EntInf->AttrBlock.pAttr[i] );
            break;

        case ATT_TRUST_DIRECTION:

            FoundRequiredAttributes |= 0x4;

            TrustDirection = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &EntInf->AttrBlock.pAttr[i] );
            break;

        case ATT_TRUST_TYPE:

            FoundRequiredAttributes |= 0x8;

            TrustType = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &EntInf->AttrBlock.pAttr[i] );
            break;

        case ATT_MS_DS_TRUST_FOREST_TRUST_INFO: // optional

            ForestTrustLength = ( ULONG )LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( &EntInf->AttrBlock.pAttr[i] );
            ForestTrustData = LSAP_DS_GET_DS_ATTRIBUTE_AS_PBYTE( &EntInf->AttrBlock.pAttr[i] );

            ForestTrustDataPresent = ( ForestTrustLength > 0 && ForestTrustData != NULL );

            break;

        case ATT_IS_DELETED: // optional

            IsDeleted = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &EntInf->AttrBlock.pAttr[i] );
            break;

        default:

            LsapDsDebugOut(( DEB_FTINFO, "Invalid parameter in LsapForestTrustUnmarshalBlob (%s:%d)\n", __FILE__, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            ASSERT( FALSE );
            goto Error;
        }
    }

    if ( FoundRequiredAttributes != TotalRequiredAttributes ) {

        LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsertEntInf: not all required parameters found 0x%lx (%s:%d)\n", FoundRequiredAttributes, __FILE__, __LINE__ ));
        Status = STATUS_NOT_FOUND;
        goto Error;
    }

    if ( IsDeleted || !ForestTrustDataPresent ) {

        LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsertEntInf: removing an entry for %wZ\n", &TrustedDomainName ));

        Status = LsapForestTrustCacheRemove( &TrustedDomainName );

        if ( Status == STATUS_NOT_FOUND ) {

            Status = STATUS_SUCCESS;
        }

        ASSERT( Status == STATUS_SUCCESS );

        LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsertEntInf: the entry for %wZ successfully removed\n", &TrustedDomainName ));

    } else if ( ForestTrustDataPresent &&
                LsapHavingForestTrustMakesSense(
                    TrustDirection,
                    TrustType,
                    TrustAttributes )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsertEntInf: adding an entry for %wZ\n", &TrustedDomainName ));

        Status = LsapForestTrustUnmarshalBlob(
                     ForestTrustLength,
                     ForestTrustData,
                     ForestTrustRecordTypeLast,
                     &ForestTrustInfo
                     );

        if ( !NT_SUCCESS( Status )) {

            LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsertEntInf: LsapForestTrustUnmarshalBlob returned 0x%x\n", Status ));
            goto Error;
        }

        Status = LsapForestTrustCacheInsert(
                     &TrustedDomainName,
                     TrustedDomainSid,
                     &ForestTrustInfo,
                     FALSE
                     );

        LsapFreeForestTrustInfo( &ForestTrustInfo );

        if ( !NT_SUCCESS( Status )) {

            LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsertEntInf: LsapForestTrustCacheInsert returned 0x%x\n", Status ));
            goto Error;
        }

        LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustCacheInsertEntInf: the entry for %wZ successfully added\n", &TrustedDomainName ));
    }

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));
    goto Cleanup;
}



BOOL
LsapForestTrustOnGcPrepareToImpersonate(
    ULONG Client,
    ULONG Server,
    VOID **ImpersonateData
    )
/*++

Routine Description:

    Called before DS notification fires.

Arguments:

    Client, Server, ImpersonateData -- forwarded to DirPrepareForImpersonate

Returns:

    TRUE if everything went fine,
    FALSE if ran out of memory allocating resources

--*/
{
    return DirPrepareForImpersonate(
               Client,
               Server,
               ImpersonateData
               );
}

VOID
LsapForestTrustOnGcTransmitData(
    ULONG hClient,
    ULONG hServer,
    ENTINF *EntInf
    )
/*++

Routine Description:

    Notification callback for changes to trusted domain objects

Arguments:

    hClient            ignored
    hServer            ignored
    EntInf             <fill in>

Returns:

    Nothing

--*/
{
    NTSTATUS Status;

    UNREFERENCED_PARAMETER( hClient );
    UNREFERENCED_PARAMETER( hServer );

    LsapDbAcquireWriteLockTrustedDomainList();

    if ( g_FTCache == NULL ) {

        ASSERT( FALSE ); // how is this possible???

        LsapDbReleaseLockTrustedDomainList();
        return;
    }

    Status = LsapForestTrustCacheInsertEntInf( EntInf );

    if ( Status == STATUS_NOT_FOUND ) {

        Status = STATUS_SUCCESS;

    } else if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsapForestTrustOnGcTransmitData: LsapForestTrustCacheInsertEntInf returned 0x%x\n", Status ));
        LsapForestTrustCacheSetInvalid();
    }

    LsapDbReleaseLockTrustedDomainList();
}



VOID
LsapForestTrustOnGcStopImpersonating(
    ULONG Client,
    ULONG Server,
    VOID *ImpersonateData
    )
/*++

Routine Description:

    Called after DS notification fires.

Arguments:

    Client, Server, ImpersonateData - forwarded to DirStopImpersonating

Returns:

    Nothing

--*/
{
    DirStopImpersonating(
        Client,
        Server,
        ImpersonateData
        );
}



NTSTATUS
LsapRebuildFtCacheGC()
/*++

Routine Description:

    Rebuilds the forest trust cache on a global catalog server
    which is outside the root domain of the forest

Arguments:

    None

Returns:

    STATUS_SUCCESS                  OK

    STATUS_INTERNAL_ERROR           no forest trust cache object

    STATUS_INVALID_DOMAIN_STATE     must be a GC outside of the root domain

    STATUS_INSUFFICIENT_RESOURCES   out of memory

--*/
{
    NTSTATUS Status;
    ULONG DirResult;
    ULONG NameLen, RootLen, SystemLen;
    PDSNAME RootName = NULL, SystemName = NULL;
    FILTER Filter = {0};
    ENTINFSEL Selection = {0};
    SEARCHARG SearchArg = {0};
    NOTIFYARG NotifyArg = {0};
    NOTIFYRES * NotifyRes = NULL;
    SEARCHRES * SearchRes = NULL;

    //
    // List of attributes we care about for forest trust.
    // If you change this list, change the switch statement
    // inside LsapForestTrustCacheInsertEntInf.
    //

    ATTR AttrArray[] = {
        { ATT_TRUST_PARTNER,                 { 0, NULL }},
        { ATT_SECURITY_IDENTIFIER,           { 0, NULL }},
        { ATT_TRUST_ATTRIBUTES,              { 0, NULL }},
        { ATT_TRUST_DIRECTION,               { 0, NULL }},
        { ATT_TRUST_TYPE,                    { 0, NULL }},
        { ATT_MS_DS_TRUST_FOREST_TRUST_INFO, { 0, NULL }},
        { ATT_IS_DELETED,                    { 0, NULL }}};

    LsapDsDebugOut(( DEB_FTINFO, "Rebuilding forest trust cache on the GC (%s:%d)\n", __FILE__, __LINE__ ));

    LsapDbAcquireWriteLockTrustedDomainList();

    if ( g_FTCache == NULL ) {

        ASSERT( FALSE ); // how is this possible???

        Status = STATUS_INTERNAL_ERROR;
        LsapDbReleaseLockTrustedDomainList();

        LsapDsDebugOut(( DEB_FTINFO, "LsapRebuildFtCacheGC: Error 0x%lx (%s:%d)\n", Status, __FILE__, __LINE__ ));
        return Status;
    }

    if ( LsapDbDcInRootDomain() || !SamIAmIGC()) {

        LsapDbReleaseLockTrustedDomainList();

        LsapDsDebugOut(( DEB_FTINFO, "LsapRebuildFtCacheGC: Must be called on a GC outside of root domain\n" ));
        Status = STATUS_INVALID_DOMAIN_STATE;
        return Status;
    }

    if ( g_FTCache->IsValid()) {

        LsapDbReleaseLockTrustedDomainList();

        LsapDsDebugOut(( DEB_FTINFO, "LsapRebuildFtCacheGC: No need to rebuild, returning OK (%s:%d)\n", __FILE__, __LINE__ ));
        return STATUS_SUCCESS;
    }

    //
    // See if we already have a transaction going and open one if necessary
    //

    Status = LsapDsOpenTransaction( 0 );

    if ( !NT_SUCCESS( Status )) {

        LsapDbReleaseLockTrustedDomainList();

        LsapDsDebugOut(( DEB_FTINFO, "LsapRebuildFtCacheGC: LsapDsOpenTransaction returned 0x%x\n", Status ));
        return Status;
    }

    //
    // Find the name of the root NC
    //

    RootLen = 0;
    Status = GetConfigurationName(
                 DSCONFIGNAME_ROOT_DOMAIN,
                 &RootLen,
                 NULL
                 );

    ASSERT( Status == STATUS_BUFFER_TOO_SMALL );

    RootName = ( PDSNAME )LsapAllocateLsaHeap( RootLen );

    if ( RootName == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapRebuildFtCacheGC (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    Status = GetConfigurationName(
                 DSCONFIGNAME_ROOT_DOMAIN,
                 &RootLen,
                 RootName
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsapRebuildFtCacheGC: GetConfigurationName returned 0x%x\n", Status ));
        goto Error;
    }

    //
    // Construct the SYSTEM container name
    //

    NameLen = 10 +                   // wcslen( L"CN=System," )
              wcslen( RootName->StringName );

    SystemLen = DSNameSizeFromLen( NameLen );
    SystemName = ( PDSNAME )LsapAllocateLsaHeap( SystemLen );

    if ( SystemName == NULL ) {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapRebuildFtCacheGC (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    SystemName->structLen = SystemLen;
    SystemName->NameLen = NameLen;

    //
    // Access the systems container by well-known GUID rather than by name
    //

    swprintf(
        SystemName->StringName,
        L"CN=System,%ws",
        RootName->StringName
        );

    //
    // Register for notifications on the system container
    // Sadly, filters can not be applied to notifications
    //

    Filter.choice = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_TRUE;

    Selection.attSel = EN_ATTSET_LIST;
    Selection.AttrTypBlock.attrCount = sizeof( AttrArray ) / sizeof( AttrArray[0] );
    Selection.AttrTypBlock.pAttr = AttrArray;
    Selection.infoTypes = EN_INFOTYPES_TYPES_VALS;

    SearchArg.pObject = SystemName;
    SearchArg.choice = SE_CHOICE_IMMED_CHLDRN;
    SearchArg.bOneNC = TRUE;
    SearchArg.pFilter = &Filter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = &Selection;
    SearchArg.pSelectionRange = NULL;
    SearchArg.fPutResultsInSortedTable = FALSE;
    InitCommarg( &SearchArg.CommArg );
    SearchArg.pResObj = NULL;

    NotifyArg.pfPrepareForImpersonate = LsapForestTrustOnGcPrepareToImpersonate;
    NotifyArg.pfTransmitData = LsapForestTrustOnGcTransmitData;
    NotifyArg.pfStopImpersonating = LsapForestTrustOnGcStopImpersonating;
    NotifyArg.hClient = 0;

    DirResult = DirNotifyRegister(
                    &SearchArg,
                    &NotifyArg,
                    &NotifyRes
                    );

    if ( NotifyRes ) {

        Status = LsapDsMapDsReturnToStatusEx( &( NotifyRes->CommRes ));

    } else {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapRebuildFtCacheGC (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsapRebuildFtCacheGC: DirNotifyRegister returned 0x%x\n", Status ));
        goto Error;
    }

    //
    // Remember the notification handle
    //

    ASSERT( NotificationHandle == NULL );
    NotificationHandle = NotifyRes->hServer;

    //
    // One schema per forest means that the name of the TDO object category
    // will be the same as in the root NC, so it's safe to use LsaDsStateInfo.
    //

    ASSERT( NULL != LsaDsStateInfo.SystemContainerItems.TrustedDomainObject );

    //
    // Unlike notifications, searches support filters.  So use them.
    //

    RtlZeroMemory( &Filter, sizeof( Filter ));
    Filter.choice = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    Filter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = LsaDsStateInfo.SystemContainerItems.TrustedDomainObject->structLen;
    Filter.FilterTypes.Item.FilTypes.ava.Value.pVal = ( BYTE * ) LsaDsStateInfo.SystemContainerItems.TrustedDomainObject;

    RtlZeroMemory( &Selection, sizeof( Selection ));
    Selection.attSel = EN_ATTSET_LIST;
    Selection.AttrTypBlock.attrCount = sizeof( AttrArray ) / sizeof( AttrArray[0] );
    Selection.AttrTypBlock.pAttr = AttrArray;
    Selection.infoTypes = EN_INFOTYPES_TYPES_VALS;

    RtlZeroMemory( &SearchArg, sizeof( SearchArg ));
    SearchArg.pObject = SystemName;
    SearchArg.choice = SE_CHOICE_IMMED_CHLDRN;
    SearchArg.bOneNC = TRUE;
    SearchArg.pFilter = &Filter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = &Selection;
    SearchArg.pSelectionRange = NULL;
    SearchArg.fPutResultsInSortedTable = FALSE;
    InitCommarg( &SearchArg.CommArg );
    SearchArg.pResObj = NULL;

    //
    // Now that we're registered for notifications,
    // read out the trusted domain objects
    //

    DirResult = DirSearch(
                    &SearchArg,
                    &SearchRes
                    );

    if ( SearchRes ) {

        Status = LsapDsMapDsReturnToStatusEx( &( SearchRes->CommRes ));

    } else {

        LsapDsDebugOut(( DEB_FTINFO, "Out of memory in LsapRebuildFtCacheGC (%s:%d)\n", __FILE__, __LINE__ ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_FTINFO, "LsapRebuildFtCacheGC: DirSearch returned 0x%x\n", Status ));
        goto Error;
    }

    //
    // Voila! All that's left is to take those search results
    // and populate our cache with them
    //

    if ( SearchRes->count > 0 ) {

        for ( ENTINFLIST * Current = &( SearchRes->FirstEntInf );
              Current != NULL;
              Current = Current->pNextEntInf ) {

            Status = LsapForestTrustCacheInsertEntInf( &Current->Entinf );

            if ( Status == STATUS_NOT_FOUND ) {

                Status = STATUS_SUCCESS;

            } else if ( !NT_SUCCESS( Status )) {

                LsapDsDebugOut(( DEB_FTINFO, "LsapRebuildFtCacheGC: LsapForestTrustCacheInsertEntInf returned 0x%x\n", Status ));
                goto Error;
            }
        }
    }

    //
    // Cache has been successfully rebuilt
    //

    LsapForestTrustCacheSetValid();

    Status = STATUS_SUCCESS;

    LsapDsDebugOut(( DEB_FTINFO, "LsapRebuildFtCacheGC: Cache rebuilt OK (%s:%d)\n", __FILE__, __LINE__ ));

Cleanup:

    LsapDsApplyTransaction( 0 );

    LsapDbReleaseLockTrustedDomainList();

    LsapFreeLsaHeap( RootName );
    LsapFreeLsaHeap( SystemName );

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));

    //
    // Undo everything we've accomplished,
    // unregister notifications, etc.
    //

    LsapForestTrustCacheSetInvalid();

    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dblusid.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dblookup.c

Abstract:

    LSA Database - Lookup Sid and Name routines

    NOTE:  This module should remain as portable code that is independent
           of the implementation of the LSA Database.  As such, it is
           permitted to use only the exported LSA Database interfaces
           contained in db.h and NOT the private implementation
           dependent functions in dbp.h.
           
Author:

    Scott Birrell       (ScottBi)      November 27, 1992

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"
#include <sidcache.h>
#include <bndcache.h>
#include <malloc.h>

#include <ntdsa.h>
#include <ntdsapi.h>
#include <ntdsapip.h>
#include "lsawmi.h"

#include <lmapibuf.h>
#include <dsgetdc.h>


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Lsa Lookup Sid and Name Private Global State Variables               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

//
// See comment in dbluutil.c
//
extern BOOLEAN LsapReturnSidTypeDeleted;

//
// The shortcut list is meant for well known security principals
// whose SidTypeUse is WellKnownGroup, not User
//

struct {
    LUID  LogonId;
    LSAP_WELL_KNOWN_SID_INDEX LookupIndex;
} LsapShortcutLookupList[] =  {
    { SYSTEM_LUID, LsapLocalSystemSidIndex },
    { ANONYMOUS_LOGON_LUID, LsapAnonymousSidIndex },
    { LOCALSERVICE_LUID, LsapLocalServiceSidIndex },
    { NETWORKSERVICE_LUID, LsapNetworkServiceSidIndex }
};

//
// Handy macros for iterating over static arrays
//
#define NELEMENTS(x) (sizeof(x)/sizeof(x[0]))

NTSTATUS
LsapDbLookupSidsInTrustedForests(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapDbLookupSidsInTrustedForestsWorker(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST * ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    OUT BOOLEAN *fAllocateAllNodes,
    IN OUT PULONG MappedCount,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapLookupSids(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID_ENUM_BUFFER SidEnumBuffer,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    IN ULONG ClientRevision
    );


NTSTATUS
LsapDomainHasForestTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    IN OUT  BOOLEAN   *fTDLLock,   OPTIONAL
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustEntryOut OPTIONAL
    );

NTSTATUS
LsapDomainHasDirectTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    IN OUT  BOOLEAN   *fTDLLock,   OPTIONAL
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustEntryOut OPTIONAL
    );

NTSTATUS
LsapDomainHasTransitiveTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    OUT LSA_TRUST_INFORMATION *TrustInfo OPTIONAL
    );

NTSTATUS
LsapDomainHasDirectExternalTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    IN OUT  BOOLEAN   *fTDLLock,   OPTIONAL
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustEntryOut OPTIONAL
    );

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Lsa Lookup Sid Routines                                              //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

NTSTATUS
LsarLookupSids(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID_ENUM_BUFFER SidEnumBuffer,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount
    )
/*++

Routine Description:

    See LsapLookupSids.  LsarLookupSids is called by NT4 and below clients
    
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Size;
    LSAPR_TRANSLATED_NAMES_EX TranslatedNamesEx = {0, NULL};

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupSids(%ws) start\n", LsapDbLookupGetLevel(LookupLevel)) );

    //
    // Note that due to the IN/OUT nature of TranslatedSids, it is
    // possible that a client can pass something into the Sids field.
    // However, NT clients do not so it is safe, and correct to free
    // any values at this point.  Not doing so would mean a malicious
    // client could cause starve the server.
    //
    if ( TranslatedNames->Names ) {
        MIDL_user_free( TranslatedNames->Names );
        TranslatedNames->Names = NULL;
    }

    //
    // Allocate the TranslatedName buffer to return
    //
    TranslatedNames->Entries = 0;
    Size = SidEnumBuffer->Entries * sizeof(LSAPR_TRANSLATED_NAME);
    TranslatedNames->Names = midl_user_allocate( Size );
    if ( !TranslatedNames->Names ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlZeroMemory( TranslatedNames->Names, Size );
    TranslatedNames->Entries = SidEnumBuffer->Entries;

    Status = LsapLookupSids( PolicyHandle,
                              SidEnumBuffer,
                              ReferencedDomains,
                              (PLSAPR_TRANSLATED_NAMES_EX) &TranslatedNamesEx,
                              LookupLevel,
                              MappedCount,
                              0,
                              LSA_CLIENT_PRE_NT5 );

    if ( TranslatedNamesEx.Names != NULL ) {

        //
        // Map the new data structure back to the old one
        //
        ULONG i;

        ASSERT( TranslatedNamesEx.Entries == TranslatedNames->Entries );

        for (i = 0; i < TranslatedNamesEx.Entries; i++ ) {

            if (LsapReturnSidTypeDeleted
            &&  TranslatedNamesEx.Names[i].Use == SidTypeUnknown
            &&  TranslatedNamesEx.Names[i].DomainIndex != LSA_UNKNOWN_INDEX) {

                //
                // A domain was found, but the SID couldn't be resolved
                // assume it has been deleted
                //
                TranslatedNames->Names[i].Use = SidTypeDeletedAccount;
            } else {
                TranslatedNames->Names[i].Use = TranslatedNamesEx.Names[i].Use;
            }

            TranslatedNames->Names[i].Name = TranslatedNamesEx.Names[i].Name;
            TranslatedNames->Names[i].DomainIndex = TranslatedNamesEx.Names[i].DomainIndex;
        }

        //
        // Free the Ex structure
        //
        midl_user_free( TranslatedNamesEx.Names );

    } else {

        TranslatedNames->Entries = 0;
        midl_user_free( TranslatedNames->Names );
        TranslatedNames->Names = NULL;

    }

Cleanup:

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupSids(%ws) end (0x%x)\n", LsapDbLookupGetLevel(LookupLevel), Status) );
    return Status;

}


NTSTATUS
LsarLookupSids2(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID_ENUM_BUFFER SidEnumBuffer,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    IN ULONG ClientRevision
    )
/*++

Routine Description:

    This routine is the server entry point for the IDL LsarLookupSids2.
    
    See LsapLookupSids.  This API is used by win2k clients.

Arguments:

    RpcHandle -- an RPC binding handle
    
    Rest -- See LsarLookupSids2
    
Return Values:

    See LsarLookupSids2
    
--*/
{
    NTSTATUS Status;

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupSids2(%ws) start\n", LsapDbLookupGetLevel(LookupLevel)) );

    Status = LsapLookupSids(PolicyHandle,
                            SidEnumBuffer,
                            ReferencedDomains,
                            TranslatedNames,
                            LookupLevel,
                            MappedCount,
                            LookupOptions,
                            ClientRevision);

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupSids2(%ws) end (0x%x)\n", LsapDbLookupGetLevel(LookupLevel), Status) );

    return Status;
}



NTSTATUS
LsarLookupSids3(
    IN handle_t RpcHandle,
    IN PLSAPR_SID_ENUM_BUFFER SidEnumBuffer,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    IN ULONG ClientRevision
    )
/*++

Routine Description:

    This routine is the server entry point for the IDL LsarLookupSids3.
    
    It accepts an RPC binding handle, instead of a LSA context handle; otherwise
    it behaves identically to LsarLookupSids2

Arguments:

    RpcHandle -- an RPC binding handle
    
    Rest -- See LsapLookupSids
    
Return Values:

    See LsapLookupSids
    
--*/
{
    NTSTATUS Status;


    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupSids3(%ws) start\n", LsapDbLookupGetLevel(LookupLevel)) );

    Status = LsapLookupSids(NULL,
                            SidEnumBuffer,
                            ReferencedDomains,
                            TranslatedNames,
                            LookupLevel,
                            MappedCount,
                            LookupOptions,
                            ClientRevision);

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupSids3(%ws) end (0x%x)\n", LsapDbLookupGetLevel(LookupLevel), Status) );

    return Status;
}




NTSTATUS
LsapLookupSids(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID_ENUM_BUFFER SidEnumBuffer,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    IN ULONG ClientRevision
    )

/*++

Routine Description:

    This routine is the LSA Server worker routine for the LsaLookupSids
    API.

    The LsaLookupSids API attempts to find names corresponding to Sids.
    If a name can not be mapped to a Sid, the Sid is converted to character
    form.  The caller must have POLICY_LOOKUP_NAMES access to the Policy
    object.

    WARNING:  This routine allocates memory for its output.  The caller is
    responsible for freeing this memory after use.  See description of the
    Names parameter.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    SidEnumBuffer - Pointer to an enumeration buffer containing a count
        and a pointer to an array of Count pointers to Sids to be mapped
        to names.  The Sids may be well_known SIDs, SIDs of User accounts
        Group Accounts, Alias accounts, or Domains.

    ReferencedDomains - Receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the structure returned via the Names parameter.
        Unlike the Names parameter, which contains an array entry
        for (each translated name, this strutcure will only contain
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    TranslatedNames - Pointer to a structure which will reference an array
        records describing each translated name.  The nth entry in this array
        provides a translation for the nth entry in the Sids parameter.

        All of the returned names will be isolated names or NULL strings
        (domain names are returned as NULL strings).  If the caller needs
        composite names, they can be generated by prepending the
        isolated name with the domain name and a backslash.  For example,
        if (the name Sally is returned, and it is from the domain Manufact,
        then the composite name would be "Manufact" + "\" + "Sally" or
        "Manufact\Sally".

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

        If a Sid is not translatable, then the following will occur:

        1) If the SID's domain is known, then a reference domain record
           will be generated with the domain's name.  In this case, the
           name returned via the Names parameter is a Unicode representation
           of the relative ID of the account, such as "(3cmd14)" or the null
           string, if the Sid is that of a domain.  So, you might end up
           with a resultant name of "Manufact\(314) for the example with
           Sally above, if Sally's relative id is 314.

        2) If not even the SID's domain could be located, then a full
           Unicode representation of the SID is generated and no domain
           record is referenced.  In this case, the returned string might
           be something like: "(S-1-672194-21-314)".

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupWksta - First Level Lookup performed on a workstation
            normally configured for Windows-Nt.   The lookup searches the
            Well-Known Sids/Names, and the Built-in Domain and Account Domain
            in the local SAM Database.  If not all Sids or Names are
            identified, performs a "handoff" of a Second level Lookup to the
            LSA running on a Controller for the workstation's Primary Domain
            (if any).

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Sids or Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.

    MappedCount - Pointer to location that contains a count of the Sids
        mapped so far. On exit, this will be updated.

    LookupOptions - flags to control the lookup.  Currently non defined

    ClientRevision -- the version of the client

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully and all Sids have
            been translated to names.

        STATUS_SOME_NOT_MAPPED - At least one of the Sids provided was
            translated to a Name, but not all Sids could be translated. This
            is a success status.

        STATUS_NONE_MAPPED - None of the Sids provided could be translated
            to names.  This is an error status, but output is returned.  Such
            output includes partial translations of Sids whose domain could
            be identified, together with their Relative Id in Unicode format,
            and character representations of Sids whose domain could not
            be identified.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_DOMAIN_CTRLR_CONFIG_ERROR - Target machine not configured
            as a DC when expected.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            such as memory to complete the call.
--*/

{
    NTSTATUS Status, SecondaryStatus, TempStatus;
    PLSAPR_SID *Sids = (PLSAPR_SID *) SidEnumBuffer->SidInfo;
    ULONG Count = SidEnumBuffer->Entries;
    BOOLEAN PolicyHandleReferencedHere = FALSE;
    PPOLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfo = NULL;
    PTRUSTED_CONTROLLERS_INFO TrustedControllersInfo = NULL;
    LSA_HANDLE ControllerPolicyHandle = NULL;
    ULONG DomainIndex;
    ULONG SidIndex;
    LSAPR_TRUST_INFORMATION TrustInformation;
    PLSAPR_TRANSLATED_NAME_EX OutputNames = NULL;
    ULONG OutputNamesLength;
    PLSAPR_TRUST_INFORMATION Domains = NULL;
    ULONG CompletelyUnmappedCount = Count;
    ULONG LocalDomainsToSearch = 0;
    BOOLEAN AlreadyTranslated = FALSE;
    LUID LogonId;
    ULONG DomainLookupScope;
    ULONG PreviousMappedCount;

    //
    // Set to FALSE when the client is less than nt5
    //
    BOOLEAN fDoExtendedLookups = TRUE;

    LsarpReturnCheckSetup();

    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_LookupSids);

    SecondaryStatus = STATUS_SUCCESS;

    //
    // Parameter checks
    //
    if ( NULL == Sids ) {

        Status = STATUS_INVALID_PARAMETER;
        goto LookupSidsError;

    }

    //
    // Perform an access check
    //
    Status =  LsapDbLookupAccessCheck( PolicyHandle );
    if (!NT_SUCCESS(Status)) {
        goto LookupSidsError;
    }

    //
    // Determine what scope of resolution to use
    //
    DomainLookupScope = LsapGetDomainLookupScope(LookupLevel,
                                                 ClientRevision);

    //
    // Init out parameters
    //
    TranslatedNames->Entries = SidEnumBuffer->Entries;
    TranslatedNames->Names = NULL;
    *ReferencedDomains = NULL;


    //
    // Verify that all of the Sids passed in are syntactically valid.
    //

    for (SidIndex = 0; SidIndex < Count; SidIndex++) {

        if ((Sids[SidIndex] != NULL) && RtlValidSid( (PSID) Sids[SidIndex])) {

            continue;
        }

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS( Status )) {

        goto LookupSidsError;
    }

    ASSERT( (LookupLevel == LsapLookupWksta)
         || (LookupLevel == LsapLookupPDC)
         || (LookupLevel == LsapLookupTDL)
         || (LookupLevel == LsapLookupGC)
         || (LookupLevel == LsapLookupXForestReferral)
         || (LookupLevel == LsapLookupXForestResolve) );

    //
    // Access and parameter checks are done -- fork off if this is a
    // referral
    //
    if (LookupLevel == LsapLookupXForestReferral) {

        NTSTATUS Status2;
        BOOLEAN  fAllocateAllNodes = FALSE;

        *MappedCount = 0;

        Status = LsapDbLookupSidsInTrustedForestsWorker(Count,
                                                        Sids,
                                                        ReferencedDomains,
                                                        TranslatedNames,
                                                        &fAllocateAllNodes,
                                                        MappedCount,
                                                        &SecondaryStatus);

        if (fAllocateAllNodes) {

            //
            // Reallocate the memory in a form the server can return to RPC
            //
            Status2 = LsapLookupReallocateTranslations((PLSA_REFERENCED_DOMAIN_LIST*)ReferencedDomains,
                                                       Count,
                                                       (PLSA_TRANSLATED_NAME_EX*)&TranslatedNames->Names,
                                                       NULL);
            if (!NT_SUCCESS(Status2)) {
                //
                // This is a fatal resource error - free the memory that 
                // was returned to us by the chaining call
                //
                if (*ReferencedDomains) {
                    midl_user_free(*ReferencedDomains);
                    *ReferencedDomains = NULL;
                }
    
                if (TranslatedNames->Names) {
                    midl_user_free(TranslatedNames->Names);
                    TranslatedNames->Names = NULL;
                    TranslatedNames->Entries = 0;
                }
                Status = Status2;
            }
        }

        //
        // There is nothing more to do
        //
        goto LookupSidsFinish;
    }

    //
    // Allocate Output Names array buffer.  For now don't place its address on
    // the Free List as this buffer contains others that will be placed on
    // that list and the order of freeing is unknown.
    //

    OutputNamesLength = Count * sizeof(LSA_TRANSLATED_NAME_EX);
    OutputNames = MIDL_user_allocate(OutputNamesLength);

    Status = STATUS_INSUFFICIENT_RESOURCES;

    if (OutputNames == NULL) {

        goto LookupSidsError;
    }

    Status = STATUS_SUCCESS;

    TranslatedNames->Entries = SidEnumBuffer->Entries;
    TranslatedNames->Names = OutputNames;


    //
    // Initialize Output Names array, marking Sid Use as unknown and
    // specifying negative DomainIndex.
    //

    RtlZeroMemory( OutputNames, OutputNamesLength);

    for (SidIndex = 0; SidIndex < Count; SidIndex++) {

        OutputNames[SidIndex].Use = SidTypeUnknown;
        OutputNames[SidIndex].DomainIndex = LSA_UNKNOWN_INDEX;
        OutputNames[SidIndex].Flags = 0;
    }

    //
    // Create an empty Referenced Domain List.
    //

    Status = LsapDbLookupCreateListReferencedDomains( ReferencedDomains, 0 );

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsError;
    }

    if ( Count == 1 ) {

        PUNICODE_STRING AccountName;
        PUNICODE_STRING AuthorityName;
        PSID UserSid;
        PSID DomainSid = NULL;
        ULONG Rid;
        PLSAP_LOGON_SESSION LogonSession;
        PTOKEN_USER TokenUserInformation;

        //
        // Let's see if we're trying to look up the currently logged on
        // user.
        //
        //
        // TokenUserInformation from this call must be freed by calling
        // LsapFreeLsaHeap().
        //

        Status = LsapQueryClientInfo(
                     &TokenUserInformation,
                     &LogonId
                     );

        if ( !NT_SUCCESS( Status )) {

            goto NormalLookupPath;
        }

        if ( RtlEqualSid( TokenUserInformation->User.Sid, Sids[0] )) {


            ULONG i;
            LSAP_WELL_KNOWN_SID_INDEX ShortcutIndex = LsapDummyLastSidIndex;

            LsapFreeLsaHeap( TokenUserInformation );

            //
            // Got a match.  Get the username and domain information
            // from the LogonId
            //

            LogonSession = LsapLocateLogonSession ( &LogonId );

            //
            // During setup, we may get NULL returned for the logon session.
            //

            if (LogonSession == NULL) {

                goto NormalLookupPath;
            }

            UserSid       = LogonSession->UserSid;

            for (i = 0; i < NELEMENTS(LsapShortcutLookupList); i++ ) {
                if (RtlEqualLuid(&LogonId, &LsapShortcutLookupList[i].LogonId)) {
                    ShortcutIndex = LsapShortcutLookupList[i].LookupIndex;
                }
            }

            if (ShortcutIndex != LsapDummyLastSidIndex) {
                AccountName = LsapDbWellKnownSidName( ShortcutIndex );
                AuthorityName = LsapDbWellKnownSidDescription( ShortcutIndex );
            } else {
                AccountName   = &LogonSession->AccountName;
                AuthorityName = &LogonSession->AuthorityName;
            }
            //
            // N.B. To maintain app compatibility, return SidTypeUser for
            // the case of a single SID being looked up that is also the
            // SID of the caller.  See bug 90589
            //
            OutputNames[0].Use = SidTypeUser;

            //
            // DomainSid will be allocated for us, free with MIDL_user_free
            //

            Status = LsapSplitSid( UserSid, &DomainSid, &Rid );

            if ( !NT_SUCCESS(Status)) {
                LsapReleaseLogonSession( LogonSession );
                goto NormalLookupPath;
            }

            RtlCopyMemory(
                &TrustInformation.Name,
                AuthorityName,
                sizeof( UNICODE_STRING )
                );

            TrustInformation.Sid = DomainSid;

            //
            // Fill in the Output Translated Name structure.  Note that the
            // buffers for the SID and Unicode Name must be allocated via
            // MIDL_user_allocate() since they will be freed by the calling
            // RPC server stub routine lsarpc_LsarLookupSids() after marshalling.
            //

            OutputNames[0].DomainIndex = 0;

            Status = LsapRpcCopyUnicodeString(
                         NULL,
                         (PUNICODE_STRING) &OutputNames[0].Name,
                         AccountName
                         );

            //
            // Username, AccountName, and UserSid have all been copied
            // from the LogonSession structure, so we can release the AuLock now.
            //

            LsapReleaseLogonSession( LogonSession );

            if (!NT_SUCCESS(Status)) {

                MIDL_user_free(DomainSid);
                goto LookupSidsError;
            }

            //
            // Make an entry in the list of Referenced Domains.
            //

            Status = LsapDbLookupAddListReferencedDomains(
                         *ReferencedDomains,
                         &TrustInformation,
                         (PLONG) &OutputNames[0].DomainIndex
                         );


            //
            // DomainSid has been copied, free it now
            //

            MIDL_user_free( DomainSid );

            if (!NT_SUCCESS(Status)) {
                goto NormalLookupPath;
            }

            ASSERT( OutputNames[0].DomainIndex == 0 );

            *MappedCount = 1;

            return( STATUS_SUCCESS );

        } else {

            LsapFreeLsaHeap( TokenUserInformation );
        }
    }

NormalLookupPath:

    //
    // The local domains to be searched always include the Accounts
    // domain.  For initial lookup targets only, the BUILT_IN domain is
    // also searched.
    //

    if ( LookupLevel != LsapLookupGC ) {
        
        LocalDomainsToSearch = LSAP_DB_SEARCH_ACCOUNT_DOMAIN;
    
        if (LookupLevel == LsapLookupWksta) {
    
            LocalDomainsToSearch |= LSAP_DB_SEARCH_BUILT_IN_DOMAIN;
    
            //
            // This is the lowest Lookup Level, normally targeted at a
            // Workstation but possibly targeted at a DC.  Make a first pass of
            // the array of Sids to identify any well-known Isolated Sids.  These
            // are Well Known Sids that do not belong to a real domain.
            //
    
            Status = LsapDbLookupIsolatedWellKnownSids(
                         Count,
                         Sids,
                         *ReferencedDomains,
                         TranslatedNames,
                         MappedCount,
                         &CompletelyUnmappedCount
                         );
    
            if (!NT_SUCCESS(Status)) {
    
                goto LookupSidsError;
            }
    
            //
            // If all Sids are now mapped or partially mapped, finish.
            //
    
            if (CompletelyUnmappedCount == (ULONG) 0) {
                goto LookupSidsFinish;
            }
        }

        ASSERT( (LookupLevel == LsapLookupWksta)
             || (LookupLevel == LsapLookupPDC)
             || (LookupLevel == LsapLookupTDL)
             || (LookupLevel == LsapLookupXForestResolve) );
    
        //
        // There are some remaining completely unmapped Sids.  They may belong to
        // a local SAM Domain.  Currently, there are two such domains, the
        // Built-in Domain and the Accounts Domain.  For initial Lookup Level
        // we search both of these domains.  For higher Lookup Levels we search
        // only the Accounts domain.
        //
    
        Status = LsapDbLookupSidsInLocalDomains(
                     Count,
                     Sids,
                     *ReferencedDomains,
                     TranslatedNames,
                     MappedCount,
                     &CompletelyUnmappedCount,
                     LocalDomainsToSearch
                     );
    
        if (!NT_SUCCESS(Status)) {
            goto LookupSidsError;
        }
    }

    //
    // If all Sids are now mapped or partially mapped, finish.
    //

    if (CompletelyUnmappedCount == (ULONG) 0) {
        goto LookupSidsFinish;
    }

    //
    // Not all of the Sids have been identified in the local domains(s).
    // The next step in the search depends on the level of this lookup
    // and how we are configured as follows:
    //
    // Lookup Level         Configuration       Lookup search next
    //
    // LsapLookupWksta      Win Nt              Primary Domain
    //                      LanMan Nt           Trusted Domains
    //
    // LsapLookupPDC        Win Nt              error
    //                      LanMan Nt           Trusted Domains
    //
    // LsaLookupTDL         Win Nt              error
    //                      LanMan Nt           none
    //

    if (LookupLevel == LsapLookupWksta) {

        if (LsapProductType != NtProductLanManNt) {

            ULONG MappedByCache = 0;

            //
            // This boolean indicates whether a post nt4 server
            // processed our remote lookups.  This will be set
            // to TRUE when the current machine is part of a domain and
            // the secure channel is to a post nt4 DC
            //
            BOOLEAN fDownlevelSecureChannel = FALSE;


            MappedByCache = *MappedCount;

            //
            // Try the cache first
            //

            Status = LsapDbMapCachedSids(
                        Sids,
                        Count,
                        FALSE,          // don't use old entries
                        *ReferencedDomains,
                        TranslatedNames,
                        MappedCount
                        );
            if (!NT_SUCCESS(Status)) {
                goto LookupSidsError;
            }

            //
            // Note: we must update the CompletelyUnmappedCount here since
            // we may have potentially incremented the MappedCount
            //
            MappedByCache = *MappedCount - MappedByCache;
            CompletelyUnmappedCount -= MappedByCache;

            if (*MappedCount == Count) {
                goto LookupSidsFinish;
            }


            Status = LsapDbLookupGetDomainInfo(NULL,
                                              &PolicyDnsDomainInfo);

            if (!NT_SUCCESS(Status)) {

                goto LookupSidsError;
            }

            //
            // If there is no Primary Domain as in the case of a WORKGROUP,
            // just finish up.  Set a default result code STATUS_SUCCESS.  This
            // will be translated to STATUS_SOME_NOT_MAPPED or STATUS_NONE_MAPPED
            // as appropriate.
            //

            Status = STATUS_SUCCESS;

            if (PolicyDnsDomainInfo->Sid == NULL) {
                goto LookupSidsFinish;
            }

            //
            // There is a Primary Domain.  Search it for Sids.  Since a
            // Primary Domain is also a Trusted Domain, we use the
            // Trusted Domain search routine.  This routine will "hand off"
            // the search to a Domain Controller's LSA.
            //

            RtlCopyMemory(
                &TrustInformation.Name,
                &PolicyDnsDomainInfo->Name,
                sizeof( UNICODE_STRING)
                );

            TrustInformation.Sid = (PSID) PolicyDnsDomainInfo->Sid;

            Status = LsapDbLookupSidsInPrimaryDomain(
                         Count,
                         Sids,
                         &TrustInformation,
                         *ReferencedDomains,
                         TranslatedNames,
                         LsapLookupPDC,
                         MappedCount,
                         &CompletelyUnmappedCount,
                         &TempStatus,
                         &fDownlevelSecureChannel
                         );


            if (!NT_SUCCESS(Status)) {

                goto LookupSidsError;
            }

            if (TempStatus == STATUS_TRUSTED_RELATIONSHIP_FAILURE) {

                MappedByCache = *MappedCount;

                Status = LsapDbMapCachedSids(
                            Sids,
                            Count,
                            TRUE,           // Use old entries
                            *ReferencedDomains,
                            TranslatedNames,
                            MappedCount
                            );
                if (!NT_SUCCESS(Status)) {
                    goto LookupSidsError;
                }

                MappedByCache = *MappedCount - MappedByCache;
                CompletelyUnmappedCount -= MappedByCache;

            }

            if ( !NT_SUCCESS( TempStatus ) && NT_SUCCESS( SecondaryStatus ) ) {

                SecondaryStatus = TempStatus;
            }

            if (*MappedCount == Count) {
                goto LookupSidsFinish;
            }

            //
            // Now, search by sid history if we are a member of an DS aware
            // domain and our secure channel DC is not DS aware
            //
            if (  fDownlevelSecureChannel
              && (PolicyDnsDomainInfo->DnsDomainName.Length > 0) ) {

                Status = LsapDbLookupSidsInGlobalCatalogWks(
                             Count,
                             Sids,
                             (PLSAPR_REFERENCED_DOMAIN_LIST) *ReferencedDomains,
                             TranslatedNames,
                             MappedCount,
                             &CompletelyUnmappedCount,
                             &TempStatus
                             );

                if (!NT_SUCCESS(Status)) {

                    goto LookupSidsError;
                }

                if ( !NT_SUCCESS( TempStatus ) && NT_SUCCESS( SecondaryStatus ) ) {
                    SecondaryStatus = TempStatus;
                }
            }

            goto LookupSidsFinish;
        }
    }

    //
    // We reach here in two cases:
    //
    // * Initial Level lookups targeted at DC's
    // * Higher Level Lookups (must be targeted at DC's)
    //
    // For the highest level lookup, that on an individual TDC, there
    // is no more searching to do, since we have already searched the
    // Accounts Domain and we do not follow trust relationships on DC's
    // beyond one level.
    //

    if (LookupLevel == LsapLookupTDL) {

        goto LookupSidsFinish;
    }

    ASSERT( (LookupLevel == LsapLookupWksta)
         || (LookupLevel == LsapLookupPDC)
         || (LookupLevel == LsapLookupGC)
         || (LookupLevel == LsapLookupXForestResolve) );

    //
    // We are either the initial target of the lookup but not configured
    // as a workstation, or we are the target of a Primary Domain
    // level lookup.  In either case, we must be configured as a DC.
    //

    if (LsapProductType != NtProductLanManNt) {

        Status = STATUS_DOMAIN_CTRLR_CONFIG_ERROR;
        goto LookupSidsError;
    }


    if (DomainLookupScope & LSAP_LOOKUP_RESOLVE_ISOLATED_DOMAINS) {

        //
        // Lookup the items as domain SID's
        //
        PreviousMappedCount = *MappedCount;
        Status = LsapDbLookupSidsAsDomainSids(DomainLookupScope,
                                              Count,
                                              Sids,
                                             (PLSAPR_REFERENCED_DOMAIN_LIST) *ReferencedDomains,
                                              TranslatedNames,
                                              MappedCount);
    
        if (!NT_SUCCESS(Status)) {
    
            goto LookupSidsError;
        }
        CompletelyUnmappedCount -= (*MappedCount - PreviousMappedCount);
    }
    
    
    if (DomainLookupScope & LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE) {

        //
        // Next, check the global catalog for sids that belong to post nt4 domains
        //
        Status = LsapDbLookupSidsInGlobalCatalog(
                     Count,
                     Sids,
                     (PLSAPR_REFERENCED_DOMAIN_LIST) *ReferencedDomains,
                     TranslatedNames,
                     MappedCount,
                     &CompletelyUnmappedCount,
                     TRUE,
                     &TempStatus
                     );
    
        if (!NT_SUCCESS(Status)) {
    
            goto LookupSidsError;
        }
    
        if ( !NT_SUCCESS( TempStatus ) && NT_SUCCESS( SecondaryStatus ) ) {
            SecondaryStatus = TempStatus;
        }
    }

    if (DomainLookupScope & LSAP_LOOKUP_TRUSTED_FOREST) {

        ASSERT( (LookupLevel == LsapLookupWksta)
             || (LookupLevel == LsapLookupPDC)
             || (LookupLevel == LsapLookupGC));

        //
        // Next check for trusted forest SID's
        //
        Status = LsapDbLookupSidsInTrustedForests(
                     Count,
                     Sids,
                     (PLSAPR_REFERENCED_DOMAIN_LIST) *ReferencedDomains,
                     TranslatedNames,
                     MappedCount,
                     &CompletelyUnmappedCount,
                     &TempStatus
                     );

        if (!NT_SUCCESS(Status)) {
    
            goto LookupSidsError;
        }
    
        if ( !NT_SUCCESS( TempStatus ) && NT_SUCCESS( SecondaryStatus ) ) {
            SecondaryStatus = TempStatus;
        }

    }

    if (DomainLookupScope & LSAP_LOOKUP_TRUSTED_DOMAIN_DIRECT) {

        ASSERT((LookupLevel == LsapLookupWksta)
            || (LookupLevel == LsapLookupPDC));

        //
        // Obtain the Trusted Domain List and search all Trusted Domains
        // except ourselves.
        //
        Status = LsapDbLookupSidsInTrustedDomains(
                     Count,
                     Sids,
                     !(DomainLookupScope & LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE), 
                                          // if we didn't go the GC, then 
                                          // include intraforest trusts
                     (PLSAPR_REFERENCED_DOMAIN_LIST) *ReferencedDomains,
                     TranslatedNames,
                     LsapLookupTDL,
                     MappedCount,
                     &CompletelyUnmappedCount,
                     &TempStatus
                     );
    
        if (!NT_SUCCESS(Status)) {
    
            goto LookupSidsError;
        }
    
        if ( !NT_SUCCESS( TempStatus ) && NT_SUCCESS( SecondaryStatus ) ) {
            SecondaryStatus = TempStatus;
        }
    }

LookupSidsFinish:

    //
    // If there are any unknown Sids (including partially mapped Sids)
    // we need to translate them to character form.  We do this translation
    // at the lowest lookup level in all non-error cases and also in the
    // error case where none were mapped.
    //

    if (NT_SUCCESS(Status)) {

        if ((LookupLevel == LsapLookupWksta) &&
            (CompletelyUnmappedCount != 0) &&
            (AlreadyTranslated == FALSE)) {

            AlreadyTranslated = TRUE;

            //
            // The remaining unmapped Sids are unknown.  They are either
            // completely unmapped, i.e. their domain is unknown, or
            // partially unmapped, their domain being known but their Rid
            // not being recognized. For completely unmapped Sids, translate
            // the entire Sid to character form.  For partially unmapped
            // Sids, translate the Relative Id only to character form.
            //

            Status = LsapDbLookupTranslateUnknownSids(
                         Count,
                         Sids,
                         *ReferencedDomains,
                         TranslatedNames,
                         *MappedCount
                         );

            if (!NT_SUCCESS(Status)) {

                goto LookupSidsError;
            }
        }
    }

    //
    // If some but not all Sids were mapped, return informational status
    // STATUS_SOME_NOT_MAPPED.  If no Sids were mapped, return error
    // STATUS_NONE_MAPPED.
    //

    if (NT_SUCCESS(Status)) {

        if (*MappedCount < Count) {

            Status = STATUS_SOME_NOT_MAPPED;

            if (*MappedCount == 0) {

                Status = STATUS_NONE_MAPPED;
            }
        }
    }

    //
    // If no sids could be mapped it is likely due to the
    // secondary status
    //
    if (  (STATUS_NONE_MAPPED == Status)
       && (STATUS_NONE_MAPPED != SecondaryStatus)
       && LsapRevisionCanHandleNewErrorCodes( ClientRevision )
       && !NT_SUCCESS( SecondaryStatus ) ) {

        Status = SecondaryStatus;

        goto LookupSidsError;
    }

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_LookupSids);

    LsarpReturnPrologue();

    return(Status);

LookupSidsError:

    //
    // If the LookupLevel is the lowest (Workstation Level, free up
    // the Names and Referenced Domains arrays.
    //

    if (LookupLevel == LsapLookupWksta) {

        //
        // If necessary, free the Names array.
        //

        if (TranslatedNames->Names != NULL) {

            OutputNames = TranslatedNames->Names;

            for (SidIndex = 0; SidIndex < Count; SidIndex++ ) {

                if (OutputNames[SidIndex].Name.Buffer != NULL) {

                    MIDL_user_free( OutputNames[SidIndex].Name.Buffer );
                    OutputNames[SidIndex].Name.Buffer = NULL;
                }
            }

            MIDL_user_free( TranslatedNames->Names );
            TranslatedNames->Names = NULL;
        }

        //
        // If necessary, free the Referenced Domain List.
        //

        if (*ReferencedDomains != NULL) {

            Domains = (*ReferencedDomains)->Domains;

            if (Domains != NULL) {

                for (DomainIndex = 0;
                     DomainIndex < (*ReferencedDomains)->Entries;
                     DomainIndex++) {

                    if (Domains[ DomainIndex ].Name.Buffer != NULL) {

                        MIDL_user_free( Domains[ DomainIndex ].Name.Buffer );
                        Domains[ DomainIndex ].Name.Buffer = NULL;
                    }

                    if (Domains[ DomainIndex ].Sid != NULL) {

                        MIDL_user_free( Domains[ DomainIndex ].Sid );
                        Domains[ DomainIndex ].Sid = NULL;
                    }
                }

                MIDL_user_free( ( *ReferencedDomains)->Domains );
            }

            MIDL_user_free( *ReferencedDomains );
            *ReferencedDomains = NULL;
        }
    }

    //
    // If the primary status was a success code, but the secondary
    // status was an error, propagate the secondary status.
    //

    if ((!NT_SUCCESS(SecondaryStatus)) && NT_SUCCESS(Status)) {

        Status = SecondaryStatus;
    }

    goto LookupSidsFinish;
}


NTSTATUS
LsapDbEnumerateSids(
    IN LSAPR_HANDLE ContainerHandle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAP_DB_SID_ENUMERATION_BUFFER DbEnumerationBuffer,
    IN ULONG PreferedMaximumLength
    )

/*++

Routine Description:

    This function enumerates Sids of objects of a given type within a container
    object.  Since there may be more information than can be returned in a
    single call of the routine, multiple calls can be made to get all of the
    information.  To support this feature, the caller is provided with a
    handle that can be used across calls.  On the initial call,
    EnumerationContext should point to a variable that has been initialized
    to 0.

Arguments:

    ContainerHandle -  Handle to a container object.

    ObjectTypeId - Type of object to be enumerated.  The type must be one
        for which all objects have Sids.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    DbEnumerationBuffer - Receives a pointer to a structure that will receive
        the count of entries returned in an enumeration information array, and
        a pointer to the array.  Currently, the only information returned is
        the object Sids.  These Sids may be used together with object type to
        open the objects and obtain any further information available.

    PreferedMaximumLength - prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

    CountReturned - Pointer to variable which will receive a count of the
        entries returned.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if no objects have been enumerated because the
            EnumerationContext value passed in is too high.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_ENUMERATION_ELEMENT LastElement;
    PLSAP_DB_ENUMERATION_ELEMENT FirstElement, NextElement = NULL, FreeElement;
    ULONG DataLengthUsed;
    ULONG ThisBufferLength;
    PSID *Sids = NULL;
    BOOLEAN PreferedMaximumReached = FALSE;
    ULONG EntriesRead;
    ULONG Index, EnumerationIndex;
    BOOLEAN TrustedClient = ((LSAP_DB_HANDLE) ContainerHandle)->Trusted;

    LastElement.Next = NULL;
    FirstElement = &LastElement;

    //
    // If no enumeration buffer provided, return an error.
    //


    if ( !ARGUMENT_PRESENT(DbEnumerationBuffer) ||
         !ARGUMENT_PRESENT(EnumerationContext )    ) {

        return(STATUS_INVALID_PARAMETER);
    }


    //
    // Enumerate objects, stopping when the length of data to be returned
    // reaches or exceeds the Prefered Maximum Length, or reaches the
    // absolute maximum allowed for LSA object enumerations.  We allow
    // the last object enumerated to bring the total amount of data to
    // be returned beyond the Prefered Maximum Length, but not beyond the
    // absolute maximum length.
    //

    EnumerationIndex = *EnumerationContext;

    for(DataLengthUsed = 0, EntriesRead = 0;
        DataLengthUsed < PreferedMaximumLength;
        DataLengthUsed += ThisBufferLength, EntriesRead++) {

        //
        // If the absolute maximum length has been exceeded, back off
        // the last object enumerated.
        //

        if ((DataLengthUsed > LSA_MAXIMUM_ENUMERATION_LENGTH) &&
            (!TrustedClient)) {

            //
            // If preferred length was zero, NextElement may be NULL
            //

            if (NextElement != NULL) {

                FirstElement = NextElement->Next;
                MIDL_user_free( NextElement->Sid );
                MIDL_user_free( NextElement );
            }
            break;
        }

        //
        // Allocate memory for next enumeration element.  Set the Sid
        // field to NULL for cleanup purposes.
        //

        NextElement = MIDL_user_allocate(sizeof (LSAP_DB_ENUMERATION_ELEMENT));

        if (NextElement == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Find the next object's Sid, and fill in its object information.
        // Note that memory will be allocated via MIDL_user_allocate
        // and must be freed when no longer required.
        //

        Status = LsapDbFindNextSid(
                     ContainerHandle,
                     &EnumerationIndex,
                     ObjectTypeId,
                     (PLSAPR_SID *) &NextElement->Sid
                     );

        //
        // Stop the enumeration if any error or warning occurs.  Note
        // that the warning STATUS_NO_MORE_ENTRIES will be returned when
        // we've gone beyond the last index.
        //

        if (Status != STATUS_SUCCESS) {

            //
            // Since NextElement is not on the list, it will not get
            // freed at the end so we must free it here.
            //

            MIDL_user_free( NextElement );
            break;
        }

        //
        // Get the length of the data allocated for the object's Sid
        //

        ThisBufferLength = RtlLengthSid( NextElement->Sid );

        //
        // Link the object just found to the front of the enumeration list
        //

        NextElement->Next = FirstElement;
        FirstElement = NextElement;
    }

    //
    // If an error other than STATUS_NO_MORE_ENTRIES occurred, return it.
    // If STATUS_NO_MORE_ENTRIES was returned, we have enumerated all of the
    // entries.  In this case, return STATUS_SUCCESS if we enumerated at
    // least one entry, otherwise propagate STATUS_NO_MORE_ENTRIES back to
    // the caller.
    //

    if (!NT_SUCCESS(Status)) {

        if (Status != STATUS_NO_MORE_ENTRIES) {

            goto EnumerateSidsError;
        }

        if (EntriesRead == 0) {

            goto EnumerateSidsError;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // Some entries were read, allocate an information buffer for returning
    // them.
    //

    Sids = (PSID *) MIDL_user_allocate( sizeof (PSID) * EntriesRead );

    if (Sids == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto EnumerateSidsError;
    }

    //
    // Memory was successfully allocated for the return buffer.
    // Copy in the enumerated Sids.
    //

    for (NextElement = FirstElement, Index = 0;
        NextElement != &LastElement;
        NextElement = NextElement->Next, Index++) {

        ASSERT(Index < EntriesRead);

        Sids[Index] = NextElement->Sid;
    }

EnumerateSidsFinish:

    //
    // Free the enumeration element structures (if any).
    //

    for (NextElement = FirstElement; NextElement != &LastElement;) {

        //
        // If an error has occurred, dispose of memory allocated
        // for any Sids.
        //

        if (!(NT_SUCCESS(Status) || (Status == STATUS_NO_MORE_ENTRIES))) {

            if (NextElement->Sid != NULL) {

                MIDL_user_free(NextElement->Sid);
            }
        }

        //
        // Free the memory allocated for the enumeration element.
        //

        FreeElement = NextElement;
        NextElement = NextElement->Next;

        MIDL_user_free(FreeElement);
    }

    //
    // Fill in return enumeration structure (0 and NULL in error case).
    //

    DbEnumerationBuffer->EntriesRead = EntriesRead;
    DbEnumerationBuffer->Sids = Sids;
    *EnumerationContext = EnumerationIndex;

    return(Status);

EnumerateSidsError:

    //
    // If necessary, free memory allocated for returning the Sids.
    //

    if (Sids != NULL) {

        MIDL_user_free( Sids );
        Sids = NULL;
    }

    goto EnumerateSidsFinish;
}


NTSTATUS
LsapDbFindNextSid(
    IN LSAPR_HANDLE ContainerHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    OUT PLSAPR_SID *NextSid
    )

/*++

Routine Description:

    This function finds the next Sid of object of a given type within a
    container object.  The given object type must be one where objects
    have Sids.  The Sids returned can be used on subsequent open calls to
    access the objects.

Arguments:

    ContainerHandle - Handle to container object.

    EnumerationContext - Pointer to a variable containing the index of
        the object to be found.  A zero value indicates that the first
        object is to be found.

    ObjectTypeId - Type of the objects whose Sids are being enumerated.

    NextSid - Receives a pointer to the next Sid found.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - Invalid ContainerHandle specified

        STATUS_NO_MORE_ENTRIES - Warning that no more entries exist.
--*/

{
    NTSTATUS Status, SecondaryStatus;
    ULONG SidKeyValueLength = 0;
    UNICODE_STRING SubKeyNameU;
    UNICODE_STRING SidKeyNameU;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ContDirKeyHandle = NULL;
    HANDLE SidKeyHandle = NULL;
    PSID ObjectSid = NULL;

    //
    // Zeroise pointers for cleanup routine
    //

    SidKeyNameU.Buffer = NULL;
    SubKeyNameU.Buffer = NULL;

    //
    // Setup object attributes for opening the appropriate Containing
    // Directory.  For example, if we're looking for Account objects,
    // the containing Directory is "Accounts".  The Unicode strings for
    // containing Directories are set up during Lsa Initialization.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &LsapDbContDirs[ObjectTypeId],
        OBJ_CASE_INSENSITIVE,
        ((LSAP_DB_HANDLE) ContainerHandle)->KeyHandle,
        NULL
        );

    Status = RtlpNtOpenKey(
                 &ContDirKeyHandle,
                 KEY_READ,
                 &ObjectAttributes,
                 0
                 );

    if (!NT_SUCCESS(Status)) {

        ContDirKeyHandle = NULL;  // For error processing
        goto FindNextError;
    }

    //
    // Initialize the Unicode String in which the next object's Logical Name
    // will be returned.  The Logical Name of an object equals its Registry
    // Key relative to its Containing Directory, and is also equal to
    // the Relative Id of the object represented in character form as an
    // 8-digit number with leading zeros.
    //
    // NOTE: The size of buffer allocated for the Logical Name must be
    // calculated dynamically when the Registry supports long names, because
    // it is possible that the Logical Name of an object will be equal to a
    // character representation of the full Sid, not just the Relative Id
    // part.
    //

    SubKeyNameU.MaximumLength = (USHORT) LSAP_DB_LOGICAL_NAME_MAX_LENGTH;
    SubKeyNameU.Length = 0;
    SubKeyNameU.Buffer = LsapAllocateLsaHeap(SubKeyNameU.MaximumLength);

    if (SubKeyNameU.Buffer == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FindNextError;
    }

    //
    // Now enumerate the next subkey.
    //

    Status = RtlpNtEnumerateSubKey(
                 ContDirKeyHandle,
                 &SubKeyNameU,
                 *EnumerationContext,
                 NULL
                 );

    if (!NT_SUCCESS(Status)) {

        goto FindNextError;
    }

    //
    // Construct a path to the Sid attribute of the object relative to
    // the containing directory.  This path has the form
    //
    // <Object Logical Name>"\Sid"
    //
    // The Logical Name of the object has just been returned by the
    // above call to RtlpNtEnumerateSubKey.
    //

    Status = LsapDbJoinSubPaths(
                 &SubKeyNameU,
                 &LsapDbNames[Sid],
                 &SidKeyNameU
                 );

    if (!NT_SUCCESS(Status)) {

        goto FindNextError;
    }

    //
    // Setup object attributes for opening the Sid attribute
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &SidKeyNameU,
        OBJ_CASE_INSENSITIVE,
        ContDirKeyHandle,
        NULL
        );

    //
    // Open the Sid attribute
    //

    Status = RtlpNtOpenKey(
                 &SidKeyHandle,
                 KEY_READ,
                 &ObjectAttributes,
                 0
                 );

    if (!NT_SUCCESS(Status)) {

        SidKeyHandle = NULL;
        goto FindNextError;
    }

    //
    // Now query the size of the buffer required to read the Sid
    // attribute's value.
    //

    SidKeyValueLength = 0;

    Status = RtlpNtQueryValueKey(
                 SidKeyHandle,
                 NULL,
                 NULL,
                 &SidKeyValueLength,
                 NULL
                 );

    //
    // We expect buffer overflow to be returned from a query buffer size
    // call.
    //

    if (Status == STATUS_BUFFER_OVERFLOW) {

        Status = STATUS_SUCCESS;

    } else {

        goto FindNextError;
    }

    //
    // Allocate memory for reading the Sid attribute.
    //

    ObjectSid = MIDL_user_allocate(SidKeyValueLength);

    if (ObjectSid == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FindNextError;
    }

    //
    // Supplied buffer is large enough to hold the SubKey's value.
    // Query the value.
    //

    Status = RtlpNtQueryValueKey(
                 SidKeyHandle,
                 NULL,
                 ObjectSid,
                 &SidKeyValueLength,
                 NULL
                 );

    if (!NT_SUCCESS(Status)) {

        goto FindNextError;
    }

    (*EnumerationContext)++;

    //
    // Return the Sid.
    //

    *NextSid = ObjectSid;

FindNextFinish:

    //
    // If necessary, close the Sid key handle
    //

    if (SidKeyHandle != NULL) {

        SecondaryStatus = NtClose(SidKeyHandle);

#if DBG

        if (!NT_SUCCESS(SecondaryStatus)) {

            DbgPrint("LsapDbFindNextSid: NtClose failed 0x%lx\n", Status);
        }

#endif // DBG

    }

    //
    // If necessary, close the containing directory handle
    //

    if (ContDirKeyHandle != NULL) {

        SecondaryStatus = NtClose(ContDirKeyHandle);

#if DBG
        if (!NT_SUCCESS(SecondaryStatus)) {

            DbgPrint(
                "LsapDbFindNextSid: NtClose failed 0x%lx\n",
                Status
                );
        }

#endif // DBG

    }

    //
    // If necessary, free the Unicode String buffer allocated by
    // LsapDbJoinSubPaths for the Registry key name of the Sid attribute
    // relative to the containing directory Registry key.
    //

    if (SidKeyNameU.Buffer != NULL) {

        RtlFreeUnicodeString( &SidKeyNameU );
    }

    //
    // If necessary, free the Unicode String buffer allocated for
    // Registry key name of the object relative to its containing
    // directory.
    //

    if (SubKeyNameU.Buffer != NULL) {

        LsapFreeLsaHeap( SubKeyNameU.Buffer );
    }

    return(Status);

FindNextError:

    //
    // If necessary, free the memory allocated for the object's Sid.
    //

    if (ObjectSid != NULL) {

        MIDL_user_free(ObjectSid);
        *NextSid = NULL;
    }

    goto FindNextFinish;
}


NTSTATUS
LsapDbLookupIsolatedWellKnownSids(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function attempts to identify Sids as Isolated Well-Known Sids
    (Well-Known Sids that do not belong to a domain) and translate them to
    names.  Note that Domain Sids for the Well Known domains themselves
    (e.g the Sid of the Built-in Domain) will be identified.

    WARNING:  This function allocates memory for translated names.  The
    caller is responsible for freeing this memory after it is no longer
    required.

Arguments:

    Count - Specifies the count of Sids provided in the array Sids.

    Sids - Pointer to an array of Sids to be examined.

    TranslatedNames - Pointer to structure that will be initialized to
        references an array of Name translations for the Sids.

    ReferencedDomains - Pointer to a structure that will be initialized to
        reference a list of the domains used for the translation.

        The entries in this structure are referenced by the
        structure returned via the Names parameter.  Unlike the Names
        parameter, which contains an array entry for (each translated name,
        this structure will only contain one component for each domain
        utilized in the translation.

        If the specified location contains NULL, a structure will be allocated
        via MIDL_user_allocate.

    MappedCount - Pointer to location that contains on entry, the number
        of Sids in Sids that have been translated so far.  This number
        is updated if any further Sids are translated by this call.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Sids.  A Sid is completely unmapped
        if it is unknown and also its Domain Prefix Sid is not recognized.
        This count is updated on exit, the number of completely unmapped
        Sids whose Domain Prefices are identified by this routine being
        subtracted from the input value.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Sids may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            such as memory to complete the call.

        STATUS_INVALID_PARAMETER - Invalid parameter or parameter combination.
            - *MappedCount > Count

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SidNumber;
    ULONG UnmappedSidsRemaining;
    PLSAPR_TRANSLATED_NAME_EX OutputNames = NULL;
    ULONG PrefixSidLength;
    UCHAR SubAuthorityCount;
    LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex;
    LSAPR_TRUST_INFORMATION TrustInformation;
    PLSAPR_SID Sid = NULL;
    PLSAPR_SID PrefixSid = NULL;

    OutputNames = TranslatedNames->Names;

    UnmappedSidsRemaining = Count;

    //
    // Attempt to identify Sids as Well Known Isolated Sids
    //

    for (SidNumber = 0; SidNumber < Count; SidNumber++) {

        Sid = Sids[SidNumber];

        //
        // Attempt to identify the next Sid using the Well Known Sids table,
        // excluding those Sids that are also in the Built In domain.  For
        // those, we drop through to the Built in Domain search.
        //

        if (LsapDbLookupIndexWellKnownSid( Sid, &WellKnownSidIndex ) &&
            !SID_IS_RESOLVED_BY_SAM(WellKnownSidIndex)) {

            //
            // Sid is identified.  Copy its Well Known Name field
            // UNICODE_STRING  structure.  Note that not all Well Known
            // Sids have Well Known Names.  For those Sids without a
            // Well Known Name, this UNICODE_STRING structure specifies
            // the NULL string.
            //

            Status = LsapRpcCopyUnicodeString(
                         NULL,
                         (PUNICODE_STRING) &(OutputNames[SidNumber].Name),
                         LsapDbWellKnownSidName(WellKnownSidIndex)
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            //
            // Get the Sid's Use.
            //

            OutputNames[SidNumber].Use = LsapDbWellKnownSidNameUse(WellKnownSidIndex);

            PrefixSid = NULL;

            //
            // If the Sid is a Domain Sid, store pointer to
            // it in the Trust Information.
            //

            if (OutputNames[SidNumber].Use == SidTypeDomain) {

                TrustInformation.Sid = Sid;

            } else {

                //
                // The Sid is not a domain Sid.  Construct the
                // Prefix Sid.  This is equal to the original Sid
                // excluding the lowest subauthority (Relative Id).
                //

                SubAuthorityCount = *RtlSubAuthorityCountSid((PSID) Sid);

                PrefixSidLength = RtlLengthRequiredSid(SubAuthorityCount - 1);

                Status = STATUS_INSUFFICIENT_RESOURCES;

                PrefixSid = MIDL_user_allocate( PrefixSidLength );

                if (PrefixSid == NULL) {

                    break;
                }

                Status = STATUS_SUCCESS;

                RtlCopyMemory( PrefixSid, Sid, PrefixSidLength );

                (*RtlSubAuthorityCountSid( (PSID) PrefixSid ))--;

                TrustInformation.Sid = PrefixSid;
            }

            //
            // Lookup this Domain Sid or Prefix Sid in the Referenced Domain
            // List.  If it is already there, return the DomainIndex for the
            // existing entry and free up the memory allocated for the
            // Prefix Sid (if any).
            //

            if (LsapDbLookupListReferencedDomains(
                    ReferencedDomains,
                    TrustInformation.Sid,
                    (PLONG) &(OutputNames[SidNumber].DomainIndex)
                    )) {

                if ((OutputNames[SidNumber].Use == SidTypeDomain) ||
                    (OutputNames[SidNumber].Name.Buffer != NULL)) {

                    UnmappedSidsRemaining--;
                }

                if (PrefixSid != NULL) {

                    MIDL_user_free(PrefixSid);
                    PrefixSid = NULL;
                }

                continue;
            }

            //
            // This Domain or Prefix Sid is not currently on the
            // Referenced Domain List.  Complete a Trust Information
            // entry and add it to the List.  Copy in the Domain Name
            // (Domain Sids) or NULL string.  Note that we use
            // RtlCopyMemory to copy a UNICODE_STRING structure onto
            // a LSAPR_UNICODE_STRING structure.
            //

            RtlCopyMemory(
                &TrustInformation.Name,
                &WellKnownSids[WellKnownSidIndex].DomainName,
                sizeof(UNICODE_STRING)
                );

            //
            // If the Sid has been recognized as a Well Known Sid and
            // is either a Domain Sid or has a well-known name, count
            // it as being mapped and add the Built-in Domain to the
            // Referenced Domain List.
            //

            if ((OutputNames[SidNumber].Use == SidTypeDomain) ||
                (OutputNames[SidNumber].Name.Length != 0)) {

                UnmappedSidsRemaining--;

                //
                // Make an entry in the list of Referenced Domains.  Note
                // that in the case of well-known Sids, the Prefix Sid
                // may or may not be the Sid of a Domain.  For those well
                // known Sids whose prefix Sid is not a domain Sid, the
                // Name field in the Trust Information has been set to the
                // NULL string.
                //

                Status = LsapDbLookupAddListReferencedDomains(
                             ReferencedDomains,
                             &TrustInformation,
                             (PLONG) &OutputNames[SidNumber].DomainIndex
                             );

                if (!NT_SUCCESS(Status)) {

                    break;
                }

            } else {

                //
                // The Sid is recognized as a Well Known Sid, but is
                // not a Domain Sid and does not have a Well Known Name
                // (signified by a zero length name string).  Filter this
                // out.
                //

                OutputNames[SidNumber].Use = SidTypeUnknown;
                OutputNames[SidNumber].Name.Length = (USHORT) 0;
                OutputNames[SidNumber].Name.MaximumLength = (USHORT) 0;
                OutputNames[SidNumber].Name.Buffer = NULL;
            }

            //
            // If memory was allocated for a Prefix Sid, free it.  Note that
            // the LsapDbLookupAddListTrustedDomains routine will have made
            // a copy of the Sid.
            //

            if (PrefixSid != NULL) {

                MIDL_user_free(PrefixSid);
                PrefixSid = NULL;
            }
        }
    }

    if (!NT_SUCCESS( Status )) {

        goto LookupIsolatedWellKnownSidsError;
    }

LookupIsolatedWellKnownSidsFinish:

    //
    // If there is a final PrefixSid buffer, free it.
    //

    if (PrefixSid != NULL) {

        MIDL_user_free(PrefixSid);
        PrefixSid = NULL;
    }

    //
    // Return output parameters.
    //

    *MappedCount = Count - UnmappedSidsRemaining;
    *CompletelyUnmappedCount = UnmappedSidsRemaining;
    return(Status);

LookupIsolatedWellKnownSidsError:

    goto LookupIsolatedWellKnownSidsFinish;
}


BOOLEAN
LsapDbLookupIndexWellKnownSid(
    IN PLSAPR_SID Sid,
    OUT PLSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    )

/*++

Routine Description:

    This function looks up a Sid to determine if it is well-known.  If so,
    an index into the table of well-known Sids is returned.

Arguments:

    Sid - Pointer to Sid to be looked up.

    WellKnownSidIndex - Pointer to variable that will receive the
        index of the Sid if well known.

Return Value:

    BOOLEAN - TRUE if the Sid is well-known, else FALSE

--*/

{
    LSAP_WELL_KNOWN_SID_INDEX Index;

    //
    // Scan the table of well-known Sids looking for a match.
    //

    for(Index = LsapNullSidIndex; Index<LsapDummyLastSidIndex; Index++) {

        //
        // Allow NULL entries in the table of well-known Sids for now.
        //

        if (WellKnownSids[Index].Sid == NULL) {

            continue;
        }

        //
        // If a match is found, return the index to the caller.
        //

        if (RtlEqualSid((PSID) Sid, WellKnownSids[Index].Sid)) {

            *WellKnownSidIndex = Index;
            return TRUE;
        }
    }

    //
    // The Sid is not a well-known Sid.  Return FALSE.
    //

    return FALSE;
}


ULONG LsapDbGetSizeTextSid(
    IN PSID Sid
    )

/*++

Routine Description:

    This function computes the size of ASCIIZ buffer required for a
    Sid in character form.  Temporarily, the size returned is an over-
    estimate, because 9 digits are allowed for the decimal equivalent
    of each 32-bit SubAuthority value.

Arguments:

    Sid - Pointer to Sid to be sized

Return Value:

    ULONG - The required size of buffer is returned.

--*/

{
    ULONG TextSidSize = 0;

    //
    // Count the Sid prefix and revision "S-rev-".  The revision is
    // assumed to not exceed 2 digits.
    //

    TextSidSize = sizeof("S-nn-");

    //
    // Add in the size of the identifier authority
    //

    TextSidSize += 15;   // log base 10 of 48 (= 6-byte number)

    //
    // If the Sid has SubAuthorities, count 9 bytes for each one
    //

    if (((PLSAPR_SID) Sid)->SubAuthorityCount > 0) {

        TextSidSize += (ULONG)
           (9 * ((PLSAPR_SID) Sid)->SubAuthorityCount);
    }

    return TextSidSize;
}


NTSTATUS
LsapDbSidToTextSid(
    IN PSID Sid,
    OUT PSZ TextSid
    )

/*++

Routine Description:

    This function converts a Sid to character text and places it in the
    supplied buffer.  The buffer is assumed to be of sufficient size, as
    can be computed by calling LsapDbGetSizeTextSid().

Arguments:

    Sid - Pointer to Sid to be converted.

    TextSid - Optional pointer to the buffer in which the converted
        Sid will be placed as an ASCIIZ.  A NULL pointer ma

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    PLSAPR_SID ISid = Sid;
    ULONG Index;
    ULONG IdentifierAuthorityValue;
    UCHAR Buffer[LSAP_MAX_SIZE_TEXT_SID];

    sprintf(Buffer, "S-%u-", (USHORT) ISid->Revision );
    strcpy(TextSid, Buffer);

    if ((ISid->IdentifierAuthority.Value[0] != 0) ||
        (ISid->IdentifierAuthority.Value[1] != 0)) {

        sprintf(Buffer, "0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)ISid->IdentifierAuthority.Value[0],
                    (USHORT)ISid->IdentifierAuthority.Value[1],
                    (USHORT)ISid->IdentifierAuthority.Value[2],
                    (USHORT)ISid->IdentifierAuthority.Value[3],
                    (USHORT)ISid->IdentifierAuthority.Value[4],
                    (USHORT)ISid->IdentifierAuthority.Value[5] );
        strcat(TextSid, Buffer);

    } else {

        IdentifierAuthorityValue =
            (ULONG)ISid->IdentifierAuthority.Value[5]          +
            (ULONG)(ISid->IdentifierAuthority.Value[4] <<  8)  +
            (ULONG)(ISid->IdentifierAuthority.Value[3] << 16)  +
            (ULONG)(ISid->IdentifierAuthority.Value[2] << 24);
        sprintf(Buffer, "%lu", IdentifierAuthorityValue);
        strcat(TextSid, Buffer);
    }

    //
    // Now format the Sub Authorities (if any) as text.
    //

    for (Index = 0; Index < (ULONG) ISid->SubAuthorityCount; Index++ ) {

        sprintf(Buffer, "-%lu", ISid->SubAuthority[Index]);
        strcat(TextSid, Buffer);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
LsapDbSidToUnicodeSid(
    IN PSID Sid,
    OUT PUNICODE_STRING SidU,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This function converts a Sid to Unicode form and optionally allocates
    (via MIDL_user_allocate) memory for the string buffer.

Arguments:

    Sid - Pointer to Sid to be translated.

    SidU - Pointer to Unicode string that will receive the Unicode
        Sid text.

    AllocateDestinationString - If TRUE, the buffer for the destination
        string will be allocated.  If FALSE, it is assummed that the
        destination Unicode string references a buffer of sufficient size.

Return Value:

--*/

{
    NTSTATUS Status;
    ULONG TextSidSize;
    PSZ TextSid = NULL;
    ANSI_STRING SidAnsi;

    if (AllocateDestinationString) {
        SidU->Buffer = NULL;
    }

    //
    // First, query the amount of memory required for a buffer that
    // will hold the Sid as an ASCIIZ character string.
    //

    TextSidSize = LsapDbGetSizeTextSid(Sid);

    //
    // Now allocate a buffer for the Text Sid.
    //

    TextSid = LsapAllocateLsaHeap(TextSidSize);

    if (TextSid == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Convert the Sid to ASCIIZ and place in the buffer.
    //

    Status = LsapDbSidToTextSid(Sid, TextSid);

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Now convert the text Sid to Unicode form via ANSI string form.
    // If we are to allocate the output buffer, do so via the
    // midl_USER_allocate routine.
    //

    RtlInitString(&SidAnsi, TextSid);

    if (AllocateDestinationString) {

        SidU->MaximumLength = (USHORT) RtlAnsiStringToUnicodeSize(&SidAnsi);
        SidU->Buffer = MIDL_user_allocate( SidU->MaximumLength );
        if ( SidU->Buffer == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        SidU->Length = 0;
    }

    //
    // Now convert the Ansi String to a Unicode string.  The buffer is
    // already allocated.  Free Text Sid buffer before checking conversion
    // status.
    //

    Status = RtlAnsiStringToUnicodeString(SidU, &SidAnsi, FALSE);

Cleanup:
    if ( TextSid != NULL) {
        LsapFreeLsaHeap(TextSid);
    }

    if (!NT_SUCCESS(Status)) {

        if (AllocateDestinationString) {

            if ( SidU->Buffer != NULL ) {
                MIDL_user_free(SidU->Buffer);
                SidU->Buffer = NULL;
            }
        }
    }

    return Status;
}


NTSTATUS
LsapDbLookupTranslateUnknownSids(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN ULONG MappedCount
    )

/*++

Routine Description:

    This function translates unmapped Sids to a character representation.
    If the Domain of a Sid is unknown, the entire Sid is translated,
    otherwise the Relative Id only is translated.

Parameters:

    Count - Specifies the number of Sids in the array.

    Sids - Pointer to an array of Sids.  Some of these will already
        have been translated.

    ReferencedDomains - Pointer to Referenced Domains List header.

    TranslatedNames - Pointer to structure that references the array of
        translated names.  The nth element of the referenced array
        corresponds to the nth Sid in the Sids array.  Some of the
        Sids may be already translated and will be ignored.  Those that are
        not yet translated have zero length Unicode structures with NULL
        buffer pointers.  Already translated Sids are ignored.

    MappedCount - Specifies the number of Sids that have already been
        translated.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    ULONG SidIndex;
    ULONG UnmappedCount;
    PSID Sid;
    UNICODE_STRING NameU;
    PLSA_TRANSLATED_NAME_EX Names = (PLSA_TRANSLATED_NAME_EX) TranslatedNames->Names;
    ULONG CleanupFreeListOptions = (ULONG) 0;
    UnmappedCount = Count - MappedCount;

    //
    // Examine the array of Sids, looking for Unknown ones to translate.
    // Translate any Unknown ones found to character representations,
    // and stop either when all of them have been accounted for, or when
    // the end of the array is reached.
    //

    if (MappedCount == Count) {

        goto TranslateUnknownSidsFinish;
    }

    if (MappedCount > Count) {

        goto TranslateUnknownSidsError;
    }

    for (SidIndex = 0, UnmappedCount = Count - MappedCount;
         (SidIndex < Count) && (UnmappedCount > 0);
         SidIndex++) {

        Sid = Sids[SidIndex];

        //
        // If the Sid has already been mapped, ignore it.
        //

        if (Names[SidIndex].Use != SidTypeUnknown) {

            continue;
        }

        //
        // Found an unmapped Sid.  If the domain is known, convert the
        // Relative Id of the Sid to a Unicode String, limited to 8
        // characters and with leading zeros.
        //

        if (Names[SidIndex].DomainIndex >= 0) {

            //
            // Convert the Relative Id to a Unicode Name and store in
            // the Translation.
            //

            Status = LsapRtlSidToUnicodeRid( Sid, &NameU );

            if (!NT_SUCCESS(Status)) {

                goto TranslateUnknownSidsError;
            }

        } else {

            //
            // The Domain is unknown.  In this case, convert the whole Sid
            // to the standard character representation.
            //

            Status = RtlConvertSidToUnicodeString( &NameU, Sid, TRUE );

            if (!NT_SUCCESS(Status)) {

                goto TranslateUnknownSidsError;
            }
        }

        //
        // Copy the Unicode Name to the output, allocating memory for
        // its buffer via MIDL_user_allocate
        //

        Status = LsapRpcCopyUnicodeString(
                     NULL,
                     &Names[SidIndex].Name,
                     &NameU
                     );

        RtlFreeUnicodeString(&NameU);

        if (!NT_SUCCESS(Status)) {

            goto TranslateUnknownSidsError;
        }

        //
        // Decrement the remaining Unmapped Count
        //

        UnmappedCount--;
    }

TranslateUnknownSidsFinish:

    return(Status);

TranslateUnknownSidsError:

    goto TranslateUnknownSidsFinish;
}


NTSTATUS
LsapDbLookupSidsInLocalDomains(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    IN ULONG Options
    )

/*++

Routine Description:

    This function looks up Sids in the local SAM domains and attempts to
    translate them to names.  Currently, there are two local SAM domains,
    the Built-in domain (which has a well-known Sid and name) and the
    Account Domain (which has a configurable Sid and name).

Arguments:

    Count - Number of Sids in the Sids array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Sids - Pointer to array of pointers to Sids to be translated.
        Zero or all of the Sids may already have been translated
        elsewhere.  If any of the Sids have been translated, the
        Names parameter will point to a location containing a non-NULL
        array of Name translation structures corresponding to the
        Sids.  If the nth Sid has been translated, the nth name
        translation structure will contain either a non-NULL name
        or a non-negative offset into the Referenced Domain List.  If
        the nth Sid has not yet been translated, the nth name
        translation structure will contain a zero-length name string
        and a negative value for the Referenced Domain List index.

    ReferencedDomains - Pointer to a structure in which the list of domains
        used in the translation is maintained.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for each
        translated name, this structure will only contain one component for
        each domain utilized in the translation.

    TranslatedNames - Pointer to a structure in which the translations to Names
        corresponding to the Sids specified on Sids is maintained.  The
        nth entry in this array provides a translation (where known) for the
        nth element in the Sids parameter.

    MappedCount - Pointer to location in which a count of the Names that
        have been completely translated is maintained.

    CompletelyUnmappedCount - Pointer to a location in which a count of the
        Names that have not been translated (either partially, by identification
        of a Domain Prefix, or completely) is maintained.

    Options - Specifies optional actions.

        LSAP_DB_SEARCH_BUILT_IN_DOMAIN - Search the Built In Domain

        LSAP_DB_SEARCH_ACCOUNT_DOMAIN - Search the Account Domain

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Sids may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

        STATUS_INTERNAL_DB_ERROR - A corruption has been detected in
            the LSA Database.

        STATUS_INVALID_PARAMETER - Invalid parameter

            - No handle to the Policy object was provided on a request
              to search the Account Domain.
--*/

{
    NTSTATUS
        Status = STATUS_SUCCESS,
        SecondaryStatus = STATUS_SUCCESS;

    LSAPR_TRUST_INFORMATION
        TrustInformation;

    ULONG
        UpdatedMappedCount = *MappedCount;

    LSAPR_HANDLE
        TrustedPolicyHandle = NULL;

    LSAP_WELL_KNOWN_SID_INDEX
        WellKnownSidIndex;

    PLSAPR_POLICY_ACCOUNT_DOM_INFO
        PolicyAccountDomainInfo = NULL;


    //
    // If there are no completely unmapped Sids remaining, return.
    //

    if (*CompletelyUnmappedCount == (ULONG) 0) {

        goto LookupSidsInLocalDomainsFinish;
    }



    //
    // If requested, lookup Sids in the BUILT-IN Domain.
    //

    if (Options & LSAP_DB_SEARCH_BUILT_IN_DOMAIN) {

        //
        // Set up the Trust Information structure for this domain.
        //

        TrustInformation.Sid = LsapBuiltInDomainSid;

        Status = STATUS_INTERNAL_DB_ERROR;

        if (!LsapDbLookupIndexWellKnownSid(
                LsapBuiltInDomainSid,
                &WellKnownSidIndex
                )) {

            goto LookupSidsInLocalDomainsError;
        }

        Status = STATUS_SUCCESS;

        //
        // Obtain the name of the Built In Domain from the table of
        // Well Known Sids.  It suffices to copy the Unicode structures
        // since we do not need a separate copy of the name buffer.
        //

        TrustInformation.Name = *((PLSAPR_UNICODE_STRING)
                                 LsapDbWellKnownSidName(WellKnownSidIndex));

        Status = LsapDbLookupSidsInLocalDomain(
                     LSAP_DB_SEARCH_BUILT_IN_DOMAIN,
                     Count,
                     Sids,
                     &TrustInformation,
                     ReferencedDomains,
                     TranslatedNames,
                     &UpdatedMappedCount,
                     CompletelyUnmappedCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupSidsInLocalDomainsError;
        }

        //
        // If all Sids are now mapped or partially mapped, finish.
        //

        if (*CompletelyUnmappedCount == (ULONG) 0) {

            goto LookupSidsInLocalDomainsFinish;
        }
    }

    //
    // If requested, search the Account Domain.
    //

    if (Options & LSAP_DB_SEARCH_ACCOUNT_DOMAIN) {

        //
        // The Sid and Name of the Account Domain are both configurable, and
        // we need to obtain them from the Policy Object.  Now obtain the
        // Account Domain Sid and Name by querying the appropriate
        // Policy Information Class.
        //

        Status = LsapDbLookupGetDomainInfo((PPOLICY_ACCOUNT_DOMAIN_INFO *) &PolicyAccountDomainInfo,
                                           NULL);

        if (!NT_SUCCESS(Status)) {

            goto LookupSidsInLocalDomainsError;
        }

        //
        // Set up the Trust Information structure for the Account Domain.
        //

        TrustInformation.Sid = PolicyAccountDomainInfo->DomainSid;

        RtlCopyMemory(
            &TrustInformation.Name,
            &PolicyAccountDomainInfo->DomainName,
            sizeof (UNICODE_STRING)
            );

        //
        // Now search the Account Domain for more Sid translations.
        //

        Status = LsapDbLookupSidsInLocalDomain(
                     LSAP_DB_SEARCH_ACCOUNT_DOMAIN,
                     Count,
                     Sids,
                     &TrustInformation,
                     ReferencedDomains,
                     TranslatedNames,
                     &UpdatedMappedCount,
                     CompletelyUnmappedCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupSidsInLocalDomainsError;
        }
    }

LookupSidsInLocalDomainsFinish:

    //
    // Return the updated total count of Sids mapped.
    //

    *MappedCount = UpdatedMappedCount;
    return(Status);

LookupSidsInLocalDomainsError:


    if (NT_SUCCESS(Status)) {

        Status = SecondaryStatus;
    }

    goto LookupSidsInLocalDomainsFinish;
}


NTSTATUS
LsapDbLookupSidsInLocalDomain(
    IN ULONG LocalDomain,
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function looks up Sids in a SAM domain on the local system
    attempts to translate them to names.

Arguments:

    LocalDomain - Indicates which local domain to look in.  Valid values
        are:
                LSAP_DB_SEARCH_BUILT_IN_DOMAIN
                LSAP_DB_SEARCH_ACCOUNT_DOMAIN

    Count - Number of Sids in the Sids array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Sids - Pointer to array of pointers to Sids to be translated.
        Zero or all of the Sids may already have been translated
        elsewhere.  If any of the Sids have been translated, the
        Names parameter will point to a location containing a non-NULL
        array of Name translation structures corresponding to the
        Sids.  If the nth Sid has been translated, the nth name
        translation structure will contain either a non-NULL name
        or a non-negative offset into the Referenced Domain List.  If
        the nth Sid has not yet been translated, the nth name
        translation structure will contain a zero-length name string
        and a negative value for the Referenced Domain List index.

    TrustInformation - Pointer to Trust Information specifying a Domain Sid
        and Name.

    ReferencedDomains - Pointer to a structure in which the list of domains
        used in the translation is maintained.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for each
        translated name, this structure will only contain one component for
        each domain utilized in the translation.

    TranslatedNames - Pointer to a structure in which the translations to Names
        corresponding to the Sids specified on Sids is maintained.  The
        nth entry in this array provides a translation (where known) for the
        nth element in the Sids parameter.

    MappedCount - Pointer to location in which a count of the Names that
        have been completely translated is maintained.

    CompletelyUnmappedCount - Pointer to a location in which a count of the
        Names that have not been translated (either partially, by identification
        of a Domain Prefix, or completely) is maintained.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Sids may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS
        Status,
        SecondaryStatus;

    PLSA_TRANSLATED_NAME_EX
        OutputNames = NULL;

    SAMPR_HANDLE
        LocalSamDomainHandle = NULL;

    PLSAPR_UNICODE_STRING
        Names = NULL;

    PSID_NAME_USE
        Use = NULL;

    ULONG
        RelativeIdCount,
        RelativeIdIndex,
        SidIndex,
        LocalMappedCount = (ULONG) 0,
        DomainSidCount = (ULONG) 0;

    LONG
        DomainIndex = LSA_UNKNOWN_INDEX,
        DomainSidIndexList,
        NextIndex,
        TmpIndex;

    PULONG
        RelativeIds = NULL,
        SidIndices = NULL;

    PLSAPR_SID
        DomainSid = TrustInformation->Sid;

    SAMPR_RETURNED_USTRING_ARRAY
        SamReturnedNames;

    SAMPR_ULONG_ARRAY
        SamReturnedUses;

    UCHAR
        SubAuthorityCountDomain;

    PLSAPR_TRUST_INFORMATION
        FreeTrustInformation = NULL;



    //
    // Make sure the SAM handles have been established.
    //

    Status = LsapOpenSam();
    ASSERT(NT_SUCCESS(Status));
    if ( !NT_SUCCESS( Status ) ) {

        return( Status );
    }


    SamReturnedNames.Count = 0;
    SamReturnedNames.Element = NULL;
    SamReturnedUses.Count = 0;
    SamReturnedUses.Element = NULL;

    OutputNames = (PLSA_TRANSLATED_NAME_EX) TranslatedNames->Names;

    SecondaryStatus = STATUS_SUCCESS;

    if (*MappedCount + *CompletelyUnmappedCount > Count) {
        Status = STATUS_INVALID_PARAMETER;
        goto LookupSidsInLocalDomainError;
    }

    Status = STATUS_SUCCESS;

    if (*CompletelyUnmappedCount == (ULONG) 0) {
        goto LookupSidsInLocalDomainFinish;
    }

    //
    // Now construct a list of Relative Ids to be looked up.  Any Sids that
    // do not belong to the specified domain are ignored.  Any Sids that
    // are not marked as having unknown Use are ignored, except for certain
    // Well Known Sids that do not have a Well Known Name.  These Sids
    // have known Use and a name string length of 0.
    //
    // First, scan the array of Sids looking for completely unmapped ones
    // that have the same domain prefix as the local domain we are dealing
    // with.  Note that we can omit any Sid whose Translated Name entry
    // contains a non-zero DomainIndex since the domain of that Sid has
    // already been identified.  Once the number of Sids is known, allocate
    // memory for an array of Relative Ids and a parallel array of indices
    // into the original Sids array.  The latter array will be used to locate
    // entries in the TranslatedNames array to which information returned by
    // the SamrLookupIdsInDomain() call will be copied.
    //

    for (RelativeIdCount = 0, SidIndex = 0, DomainSidIndexList = -1;
         SidIndex < Count;
         SidIndex++) {

        if ((OutputNames[SidIndex].Use == SidTypeUnknown) &&
            (OutputNames[SidIndex].DomainIndex == LSA_UNKNOWN_INDEX)) {

            if (LsapRtlPrefixSid( (PSID) DomainSid, (PSID) Sids[SidIndex])) {
                RelativeIdCount++;
            } else if (RtlEqualSid( (PSID)DomainSid, (PSID)Sids[SidIndex])) {

                //
                // This is the domain sid itself.  Update
                // the output information directly, but don't add
                // it to the list of RIDs to be looked up by SAM.
                //
                // NOTE that we don't yet know what our domain index
                // is.  So, just link these entries together and we'll
                // set the index later.
                //

                OutputNames[SidIndex].DomainIndex = DomainSidIndexList;
                DomainSidIndexList = SidIndex;
                OutputNames[SidIndex].Use         = SidTypeDomain;
                OutputNames[SidIndex].Name.Buffer = NULL;
                OutputNames[SidIndex].Name.Length = 0;
                OutputNames[SidIndex].Name.MaximumLength = 0;

                LocalMappedCount++;
                DomainSidCount++;
            }
        }
    }

    //
    // If we have any SIDs in this domain, then add it to the
    // referenced domain list.
    //

    if ((RelativeIdCount != 0) || (DomainSidCount != 0)) {

        //
        // At least one Sid has the domain Sid as prefix (or is the
        // domain SID).  Add the domain to the list of Referenced
        // Domains and obtain a Domain Index back.
        //

        Status = LsapDbLookupAddListReferencedDomains(
                     ReferencedDomains,
                     TrustInformation,
                     &DomainIndex
                     );

        if (!NT_SUCCESS(Status)) {
            goto LookupSidsInLocalDomainError;
        }

        //
        // If any of the sids were this domain's sid, then they
        // already have their OutputNames[] entry filled in except
        // that the DomainIndex was unkown.  It is now known, so
        // fill it in.  Any such entries to change have been linked
        // together using DomainSidIndexList as a listhead.
        //

        for (NextIndex = DomainSidIndexList;
             NextIndex != -1;
             NextIndex = TmpIndex ) {


            TmpIndex = OutputNames[NextIndex].DomainIndex;
            OutputNames[NextIndex].DomainIndex = DomainIndex;
        }
    }

    //
    // If any of the remaining Sids have the specified Local
    // domain Sid as prefix Sid, look them up
    //

    if (RelativeIdCount != 0) {

        //
        // Allocate memory for the Relative Id and cross reference arrays
        //

        RelativeIds = LsapAllocateLsaHeap( RelativeIdCount * sizeof(ULONG));


        Status = STATUS_INSUFFICIENT_RESOURCES;

        if (RelativeIds == NULL) {
            goto LookupSidsInLocalDomainError;
        }

        SidIndices = LsapAllocateLsaHeap( RelativeIdCount * sizeof(ULONG));

        if (SidIndices == NULL) {
            goto LookupSidsInLocalDomainError;
        }

        Status = STATUS_SUCCESS;

        //
        // Obtain the SubAuthorityCount for the Domain Sid
        //

        SubAuthorityCountDomain = *RtlSubAuthorityCountSid( (PSID) DomainSid );

        //
        // Now setup the array of Relative Ids to be looked up, recording
        // in the SidIndices array the index of the corresponding Sid within the
        // original Sids array.  Set the DomainIndex field for those Sids
        // eligible for the SAM lookup.
        //

        for (RelativeIdIndex = 0, SidIndex = 0;
             (RelativeIdIndex < RelativeIdCount) && (SidIndex < Count);
             SidIndex++) {

            if ((OutputNames[SidIndex].Use == SidTypeUnknown) &&
                (OutputNames[SidIndex].DomainIndex == LSA_UNKNOWN_INDEX)) {

                if (LsapRtlPrefixSid( (PSID) DomainSid, (PSID) Sids[SidIndex] )) {

                    SidIndices[RelativeIdIndex] = SidIndex;
                    RelativeIds[RelativeIdIndex] =
                        *RtlSubAuthoritySid(
                             (PSID) Sids[SidIndex],
                             SubAuthorityCountDomain
                             );

                    OutputNames[SidIndex].DomainIndex = DomainIndex;
                    RelativeIdIndex++;

                }
            }
        }

        //
        // Lookup the Sids in the specified SAM Domain.
        //

        if (LocalDomain == LSAP_DB_SEARCH_BUILT_IN_DOMAIN ) {
            LocalSamDomainHandle = LsapBuiltinDomainHandle;
        } else {
            ASSERT(LocalDomain == LSAP_DB_SEARCH_ACCOUNT_DOMAIN);
            LocalSamDomainHandle = LsapAccountDomainHandle;
        }

        //
        // Call SAM to lookup the Relative Id's
        //

        Status = SamrLookupIdsInDomain(
                     LocalSamDomainHandle,
                     RelativeIdCount,
                     RelativeIds,
                     &SamReturnedNames,
                     &SamReturnedUses
                     );

        if (!NT_SUCCESS(Status)) {

            if ( Status == STATUS_INVALID_SERVER_STATE ) {
                Status = SamrLookupIdsInDomain(
                             LocalSamDomainHandle,
                             RelativeIdCount,
                             RelativeIds,
                             &SamReturnedNames,
                             &SamReturnedUses
                             );
            }

            //
            // The only error allowed is STATUS_NONE_MAPPED.  Filter this out.
            //

            if (Status != STATUS_NONE_MAPPED) {
                goto LookupSidsInLocalDomainError;
            }

            Status = STATUS_SUCCESS;
        }

        //
        // Now copy the information returned from SAM into the output
        // Translated Sids array.  As we go, compute a count of the names
        // mapped by SAM.
        //

        for (RelativeIdIndex = 0;
             RelativeIdIndex < SamReturnedNames.Count;
             RelativeIdIndex++) {

            SidIndex =  SidIndices[RelativeIdIndex];

            //
            // Copy the Sid Use.  If the Sid was mapped by this SAM call, copy
            // its Name and increment the count of Sids mapped by this SAM call.
            // Note that we don't need to set the DomainIndex since we did so
            // earlier.
            //

            OutputNames[SidIndex].Use = SamReturnedUses.Element[RelativeIdIndex];

            if (OutputNames[SidIndex].Use != SidTypeUnknown) {

                Status = LsapRpcCopyUnicodeString(
                             NULL,
                             &OutputNames[SidIndex].Name,
                             (PUNICODE_STRING) &SamReturnedNames.Element[RelativeIdIndex]
                             );

                if (!NT_SUCCESS(Status)) {
                    break;
                }

                LocalMappedCount++;
            } else {

                //
                // This sid doesn't exist; if this search is on a domain
                // controller, then we must consider that this sid maybe
                // part of a sid history, thus we shouldn't map it
                //
                if ( (LsapProductType == NtProductLanManNt)
                  && (LocalDomain == LSAP_DB_SEARCH_ACCOUNT_DOMAIN) ) {
                    RelativeIdCount--;
                }
            }
        }

        if (!NT_SUCCESS(Status)) {

            goto LookupSidsInLocalDomainError;
        }

    }


    //
    // Update the Mapped and Completely Unmapped Counts.  To the Mapped Count
    // add in the number of Sids that SAM completely identified.  From the
    // Completely Unmapped Count subtract the number of Sids presented to
    // Sam, since all of these will be at least partially translated.
    //

    *MappedCount += LocalMappedCount;
    *CompletelyUnmappedCount -= (RelativeIdCount + DomainSidCount);

LookupSidsInLocalDomainFinish:

    //
    // If necessary, free the Lsa Heap buffer allocated for the RelativeIds
    // and SidIndices arrays.
    //

    if (RelativeIds != NULL) {

        LsapFreeLsaHeap( RelativeIds );
        RelativeIds = NULL;
    }

    if (SidIndices != NULL) {

        LsapFreeLsaHeap( SidIndices );
        SidIndices = NULL;
    }

    //
    // If necessary, free the Names array returned from SAM.
    //

    if ( SamReturnedNames.Count != 0 ) {

        SamIFree_SAMPR_RETURNED_USTRING_ARRAY ( &SamReturnedNames );
        SamReturnedNames.Count = 0;
    }

    //
    // If necessary, free the Uses array returned from SAM.
    //

    if ( SamReturnedUses.Count != 0 ) {

        SamIFree_SAMPR_ULONG_ARRAY ( &SamReturnedUses );
        SamReturnedUses.Count = 0;
    }


    return(Status);

LookupSidsInLocalDomainError:

    //
    // If necessary, free memory for the OutputTrustInformation Domain
    // Name Buffer and Sid Buffer.
    //

    if (DomainIndex >= 0) {

        FreeTrustInformation = &ReferencedDomains->Domains[DomainIndex];

        if (FreeTrustInformation->Sid != NULL) {

            MIDL_user_free( FreeTrustInformation->Sid );
            FreeTrustInformation->Sid = NULL;
        }

        if (FreeTrustInformation->Name.Buffer != NULL) {

            MIDL_user_free( FreeTrustInformation->Name.Buffer );
            FreeTrustInformation->Name.Buffer = NULL;
            FreeTrustInformation->Name.Length = 0;
            FreeTrustInformation->Name.MaximumLength = 0;
        }
    }

    //
    // If necessary, free the Name buffer in each of the OutputNames entries
    // written by this routine and set the Name slot to NULL.
    //

    for (RelativeIdIndex = 0;
         RelativeIdIndex < SamReturnedNames.Count;
         RelativeIdIndex++) {

        SidIndex =  SidIndices[RelativeIdIndex];

        if (OutputNames[SidIndex].Name.Buffer != NULL) {

            MIDL_user_free( OutputNames[SidIndex].Name.Buffer );
            OutputNames[SidIndex].Name.Buffer = NULL;
            OutputNames[SidIndex].Name.Length = 0;
            OutputNames[SidIndex].Name.MaximumLength = 0;
        }
    }

    //
    // Restore the Use field for each entry we wrote to back to SidType
    // Unknown.
    //

    for (RelativeIdIndex = 0;
         RelativeIdIndex < SamReturnedNames.Count;
         RelativeIdIndex++) {

        SidIndex =  SidIndices[RelativeIdIndex];

        if (OutputNames[SidIndex].Name.Buffer != NULL) {

            MIDL_user_free( OutputNames[SidIndex].Name.Buffer );
            OutputNames[SidIndex].Name.Buffer = NULL;
            OutputNames[SidIndex].Name.Length = 0;
            OutputNames[SidIndex].Name.MaximumLength = 0;
        }

        OutputNames[SidIndex].Use = SidTypeUnknown;
        OutputNames[SidIndex].DomainIndex = LSA_UNKNOWN_INDEX;
    }

    if (NT_SUCCESS(Status)) {

        Status = SecondaryStatus;
    }

    goto LookupSidsInLocalDomainFinish;
}


NTSTATUS
LsapDbLookupSidsInPrimaryDomain(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus,
    OUT BOOLEAN  *fDownlevelSecureChannel
    )

/*++

Routine Description:

    This function attempts to translate Sids in a Primary Domain.  A
    Trusted Domain object must exist for the domain in the local Policy
    Database.  This object will be used to access the Domain's list of
    Controllers and one or more callouts will be made to access the LSA
    Policy Databases on these Controllers.

Arguments:

    Count - Number of Sids in the Sids array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Sids - Pointer to array of pointers to Sids to be translated.
        Zero or all of the Sids may already have been translated
        elsewhere. dd esp la If any of the Sids have been translated, the

        Names parameter will point to a location containing a non-NULL
        array of Name translation structures corresponding to the
        Sids.  If the nth Sid has been translated, the nth name
        translation structure will contain either a non-NULL name
        or a non-negative offset into the Referenced Domain List.  If
        the nth Sid has not yet been translated, the nth name
        translation structure will contain a zero-length name string
        and a negative value for the Referenced Domain List index.

    TrustInformation - Specifies the name and Sid of the Primary Domain.

    ReferencedDomains - Pointer to a structure in which the list of domains
        used in the translation is maintained.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for each
        translated name, this structure will only contain one component for
        each domain utilized in the translation.

    TranslatedNames - Pointer to a structure in which the translations to Names
        corresponding to the Sids specified on Sids is maintained.  The
        nth entry in this array provides a translation (where known) for the
        nth element in the Sids parameter.

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Sids or Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.

        NOTE:  LsapLookupWksta is not valid for this parameter.

    MappedCount - Pointer to location in which a count of the Names that
        have been completely translated is maintained.

    CompletelyUnmappedCount - Pointer to a location in which a count of the
        Names that have not been translated (either partially, by identification
        of a Domain Prefix, or completely) is maintained.


    NonFatalStatus - a status to indicate reasons why no sids could have been
                     resolved

    fDownlevelSecureChannel - TRUE if secure channel DC is nt4 or below; FALSE
                              otherwise

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Sids may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SecondaryStatus = STATUS_SUCCESS;
    ULONG NextLevelCount;
    ULONG NextLevelMappedCount;
    ULONG SidIndex;
    ULONG NextLevelSidIndex;
    PLSAPR_REFERENCED_DOMAIN_LIST NextLevelReferencedDomains = NULL;
    PLSAPR_REFERENCED_DOMAIN_LIST OutputReferencedDomains = NULL;
    PLSA_TRANSLATED_NAME_EX NextLevelNames = NULL;
    PLSAPR_SID *NextLevelSids = NULL;
    LONG FirstEntryIndex;
    PULONG SidIndices = NULL;
    BOOLEAN PartialSidTranslationsAttempted = FALSE;
    ULONG ServerRevision = 0;
    LSAPR_TRUST_INFORMATION_EX TrustInfoEx;

    LsapConvertTrustToEx(&TrustInfoEx, TrustInformation);

    *NonFatalStatus = STATUS_SUCCESS;

    // Assume we don't go to the GC
    *fDownlevelSecureChannel = FALSE;

    //
    // If there are no completely unmapped Sids remaining, just return.
    //

    if (*CompletelyUnmappedCount == (ULONG) 0) {

        goto LookupSidsInPrimaryDomainFinish;
    }

    NextLevelCount = *CompletelyUnmappedCount;

    //
    // Allocate an array to hold the indices of unmapped Sids
    // relative to the original Sids and TranslatedNames->Names
    // arrays.
    //

    SidIndices = MIDL_user_allocate(NextLevelCount * sizeof(ULONG));

    Status = STATUS_INSUFFICIENT_RESOURCES;

    if (SidIndices == NULL) {

        goto LookupSidsInPrimaryDomainError;
    }

    //
    // Allocate an array for the Sids to be looked up at the Domain
    // Controller.
    //

    NextLevelSids = MIDL_user_allocate( sizeof(PSID) * NextLevelCount );

    if (NextLevelSids == NULL) {

        goto LookupSidsInPrimaryDomainError;
    }

    Status = STATUS_SUCCESS;

    //
    // Now scan the original array of Names and its parallel
    // Translated Sids array.  Copy over any Sids that are
    // completely unmapped.
    //

    NextLevelSidIndex = (ULONG) 0;

    for (SidIndex = 0;
         SidIndex < Count && NextLevelSidIndex < NextLevelCount;
         SidIndex++) {

        if (LsapDbCompletelyUnmappedName(&TranslatedNames->Names[SidIndex])) {

            NextLevelSids[NextLevelSidIndex] = Sids[SidIndex];
            SidIndices[NextLevelSidIndex] = SidIndex;
            NextLevelSidIndex++;
        }
    }

    NextLevelMappedCount = (ULONG) 0;

    Status = LsaDbLookupSidChainRequest(&TrustInfoEx,
                                        NextLevelCount,
                                        (PSID *) NextLevelSids,
                                        (PLSA_REFERENCED_DOMAIN_LIST *) &NextLevelReferencedDomains,
                                        &NextLevelNames,
                                        LookupLevel,
                                        &NextLevelMappedCount,
                                        &ServerRevision
                                        );

    //
    // If the callout to LsaLookupSids() was unsuccessful, disregard
    // the error and set the domain name for any Sids having this
    // domain Sid as prefix sid.  We still want to return translations
    // of Sids we have so far even if we are unable to callout to another
    // LSA.
    //

    //
    // Make sure we note the server revision
    //
    if ( 0 != ServerRevision ) {
        if ( ServerRevision & LSA_CLIENT_PRE_NT5 ) {
             *fDownlevelSecureChannel = TRUE;
        }
    }

    if (!NT_SUCCESS(Status) && Status != STATUS_NONE_MAPPED) {

        //
        // Let the caller know there is a trust problem
        //
        if ( LsapDbIsStatusConnectionFailure(Status) ) {
            *NonFatalStatus = Status;
        }

        Status = STATUS_SUCCESS;
        goto LookupSidsInPrimaryDomainFinish;
    }

    //
    // Cache any sids that came back
    //

    (void) LsapDbUpdateCacheWithSids(
            NextLevelSids,
            NextLevelCount,
            NextLevelReferencedDomains,
            NextLevelNames
            );

    //
    // The callout to LsaLookupSids() was successful.  We now have
    // an additional list of Referenced Domains containing the
    // Primary Domain and/or one or more of its Trusted Domains.
    // Merge the two Referenced Domain Lists together, noting that
    // since they are disjoint, the second list is simply
    // concatenated with the first.  The index of the first entry
    // of the second list will be used to adjust all of the
    // Domain Index entries in the Translated Names entries.
    // Note that since the memory for the graph of the first
    // Referenced Domain list has been allocated as individual
    // nodes, we specify that the nodes in this graph can be
    // referenced by the output Referenced Domain list.
    //

    Status = LsapDbLookupMergeDisjointReferencedDomains(
                 ReferencedDomains,
                 NextLevelReferencedDomains,
                 &OutputReferencedDomains,
                 LSAP_DB_USE_FIRST_MERGAND_GRAPH
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsInPrimaryDomainError;
    }

    FirstEntryIndex = ReferencedDomains->Entries;

    //
    // Now update the original list of Translated Names.  We
    // update each entry that has newly been translated by copying
    // the entry from the new list and adjusting its Referenced
    // Domain List Index upwards by adding the index of the first
    // entry in the Next level List..
    //

    for( NextLevelSidIndex = 0;
         NextLevelSidIndex < NextLevelCount;
         NextLevelSidIndex++ ) {

        if ( !LsapDbCompletelyUnmappedName(&NextLevelNames[NextLevelSidIndex]) ) {

            SidIndex = SidIndices[NextLevelSidIndex];

            if (NextLevelNames[NextLevelSidIndex].Use != SidTypeUnknown) {

                TranslatedNames->Names[SidIndex].Use
                = NextLevelNames[NextLevelSidIndex].Use;

                Status = LsapRpcCopyUnicodeString(
                             NULL,
                             (PUNICODE_STRING) &TranslatedNames->Names[SidIndex].Name,
                             &NextLevelNames[NextLevelSidIndex].Name
                             );

                if (!NT_SUCCESS(Status)) {

                    break;
                }
            }

            TranslatedNames->Names[SidIndex].DomainIndex =
                FirstEntryIndex +
                NextLevelNames[NextLevelSidIndex].DomainIndex;

            //
            // Update the count of completely unmapped Sids.
            //
            (*CompletelyUnmappedCount)--;

        }
    }

    //
    // Update the Referenced Domain List if a new one was produced
    // from the merge.  We retain the original top-level structure.
    // We do this regardless of whether we succeeded or failed, so
    // that we are guarenteed to get it cleaned up.
    //

    if (OutputReferencedDomains != NULL) {

        if (ReferencedDomains->Domains != NULL) {

            MIDL_user_free( ReferencedDomains->Domains );
            ReferencedDomains->Domains = NULL;
        }

        *ReferencedDomains = *OutputReferencedDomains;
        MIDL_user_free( OutputReferencedDomains );
        OutputReferencedDomains = NULL;
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsInPrimaryDomainError;
    }

    //
    // Update the Mapped Count and close the Controller Policy
    // Handle.
    //

    *MappedCount += NextLevelMappedCount;


LookupSidsInPrimaryDomainFinish:

    //
    // We can return partial translations for Sids that have the specified
    // Domain Sid as Prefix Sid.  We do this provided there has been
    // no reported error.  Errors resulting from callout to another
    // LSA will have been suppressed.
    //

    if (NT_SUCCESS(Status) &&
        (*MappedCount < Count) &&
        !PartialSidTranslationsAttempted) {


        SecondaryStatus = LsapDbLookupTranslateUnknownSidsInDomain(
                              Count,
                              Sids,
                              TrustInformation,
                              ReferencedDomains,
                              TranslatedNames,
                              LookupLevel,
                              MappedCount,
                              CompletelyUnmappedCount
                              );

        PartialSidTranslationsAttempted = TRUE;

        if (!NT_SUCCESS(SecondaryStatus)) {

            goto LookupSidsInPrimaryDomainError;
        }
    }

    //
    // If necessary, free the Next Level Referenced Domain List.
    // Note that this structure is allocated(all_nodes) since it was
    // allocated by the client side of the Domain Controller LSA.
    //

    if (NextLevelReferencedDomains != NULL) {

        MIDL_user_free( NextLevelReferencedDomains );
        NextLevelReferencedDomains = NULL;
    }

    //
    // If necessary, free the Next Level Sids array.  We only free the
    // top level.
    //

    if (NextLevelSids != NULL) {

        MIDL_user_free( NextLevelSids );
        NextLevelSids = NULL;
    }

    //
    // If necessary, free the Next Level Translated Names array.
    // Note that this array is allocated(all_nodes).
    //

    if (NextLevelNames != NULL) {

        MIDL_user_free( NextLevelNames );
        NextLevelNames = NULL;
    }

    //
    // If necessary, free the array that maps Sid Indices from the
    // Next Level to the Current Level.
    //

    if (SidIndices != NULL) {

        MIDL_user_free( SidIndices );
        SidIndices = NULL;
    }

    return(Status);

LookupSidsInPrimaryDomainError:

    //
    // If the primary status was a success code, but the secondary
    // status was an error, propagate the secondary status.
    //

    if ((!NT_SUCCESS(SecondaryStatus)) && NT_SUCCESS(Status)) {

        Status = SecondaryStatus;
    }

    goto LookupSidsInPrimaryDomainFinish;
}


NTSTATUS
LsapDbLookupSidsInTrustedDomains(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN BOOLEAN fIncludeIntraforest,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS  *NonFatalStatus
    )

/*++

Routine Description:

    This function attempts to lookup Sids to see if they belong to
    any of the Domains that are trusted by the Domain for which this
    machine is a DC.

Arguments:

    Sids - Pointer to an array of Sids to be looked up.

    Count - Number of Sids in the Sids array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.
        
    fIncludeIntraforest -- if TRUE, trusted domains in our local forest
                           are searched.

    ReferencedDomains - Pointer to a Referenced Domain List structure.
        The structure references an array of zero or more Trust Information
        entries, one per referenced domain.  This array will be appended to
        or reallocated if necessary.

    TranslatedNames - Pointer to structure that optionally references a list
        of name translations for some of the Sids in the Sids array.

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Sids or Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.

        NOTE:  LsapLookupWksta is not valid for this parameter.

    MappedCount - Pointer to location containing the number of Sids
        in the Sids array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Sids.  A Sid is completely unmapped
        if it is unknown and also its Domain Prefix Sid is not recognized.
        This count is updated on exit, the number of completely unmapped
        Sids whose Domain Prefices are identified by this routine being
        subtracted from the input value.

    NonFatalStatus - a status to indicate reasons why no sids could have been
                     resolved

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that
            some or all of the Sids may remain unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_LOOKUP_WORK_LIST WorkList = NULL;

    *NonFatalStatus = STATUS_SUCCESS;

    //
    // Build a WorkList for this Lookup and put it on the Work Queue.
    //
    // NOTE: This routine does not need to hold the Lookup Work Queue
    //       lock to ensure validity of the WorkList pointer, because the
    //       pointer remains valid until this routine frees it via
    //       LsapDbLookupDeleteWorkList().  Although other threads may
    //       process the WorkList, do not delete it.
    //
    //       A called routine must acquire the lock in order to access
    //       the WorkList after it has been added to the Work Queue.
    //

    Status = LsapDbLookupSidsBuildWorkList(
                 Count,
                 Sids,
                 fIncludeIntraforest,
                 ReferencedDomains,
                 TranslatedNames,
                 LookupLevel,
                 MappedCount,
                 CompletelyUnmappedCount,
                 &WorkList
                 );

    if (!NT_SUCCESS(Status)) {

        //
        // If no Work List has been built because there are no
        // eligible domains to search, exit, suppressing the error.

        if (Status == STATUS_NONE_MAPPED) {

            Status = STATUS_SUCCESS;
            goto LookupSidsInTrustedDomainsFinish;
        }

        goto LookupSidsInTrustedDomainsError;
    }

    //
    // Start the work, by dispatching one or more worker threads
    // if necessary.
    //

    Status = LsapDbLookupDispatchWorkerThreads( WorkList );

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsInTrustedDomainsError;
    }

    //
    // Wait for completion/termination of all items on the Work List.
    //

    Status = LsapDbLookupAwaitCompletionWorkList( WorkList );

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsInTrustedDomainsError;
    }

LookupSidsInTrustedDomainsFinish:

    if ( WorkList &&
         !NT_SUCCESS( WorkList->NonFatalStatus ) )
    {

        //
        // Propogate the error as non fatal
        //
        //
        *NonFatalStatus = WorkList->NonFatalStatus;
    }

    //
    // If a Work List was created, delete it from the Work Queue
    //

    if (WorkList != NULL) {

        Status = LsapDbLookupDeleteWorkList( WorkList );
        WorkList = NULL;
    }

    return(Status);

LookupSidsInTrustedDomainsError:

    goto LookupSidsInTrustedDomainsFinish;
}


NTSTATUS
LsapDbLookupTranslateUnknownSidsInDomain(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function looks among the unknown Sids in the given list and
    translates the Domain Name for any whose Domain Prefix Sid matches
    the given Domain Sid.

Arguments:

    Count - Number of Sids in the Sids array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Sids - Pointer to array of pointers to Sids to be translated.
        Zero or all of the Sids may already have been translated
        elsewhere.  If any of the Sids have been translated, the
        Names parameter will point to a location containing a non-NULL
        array of Name translation structures corresponding to the
        Sids.  If the nth Sid has been translated, the nth name
        translation structure will contain either a non-NULL name
        or a non-negative offset into the Referenced Domain List.  If
        the nth Sid has not yet been translated, the nth name
        translation structure will contain a zero-length name string
        and a negative value for the Referenced Domain List index.

    TrustInformation - Pointer to Trust Information specifying a Domain Sid
        and Name.

    ReferencedDomains - Pointer to a Referenced Domain List structure.
        The structure references an array of zero or more Trust Information
        entries, one per referenced domain.  This array will be appended to
        or reallocated if necessary.

    TranslatedNames - Pointer to structure that optionally references a list
        of name translations for some of the Sids in the Sids array.

    MappedCount - Pointer to location containing the number of Sids
        in the Sids array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Sids.  A Sid is completely unmapped
        if it is unknown and also its Domain Prefix Sid is not recognized.
        This count is updated on exit, the number of completely unmapped
        Sids whose Domain Prefices are identified by this routine being
        subtracted from the input value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Sids may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG RemainingCompletelyUnmappedCount;
    ULONG SidIndex;
    PSID DomainSid = TrustInformation->Sid;
    BOOLEAN DomainAlreadyAdded = FALSE;
    LONG DomainIndex = 0;

    //
    // Scan the array of Sids looking for ones whose domain has not been
    // found.
    //

    for( SidIndex = 0,
         RemainingCompletelyUnmappedCount = *CompletelyUnmappedCount;
         (RemainingCompletelyUnmappedCount > 0) && (SidIndex < Count);
         SidIndex++) {

        //
        // Check if this Sid is completely unmapped (i.e. its domain
        // has not yet been identified.
        //

        if (LsapDbCompletelyUnmappedName(&TranslatedNames->Names[SidIndex])) {

            //
            // Found a completely unmapped Sid.  If it belongs to the
            // specified Domain, add the Domain to the Referenced Domain
            // list if we have not already done so.
            //

            if (LsapRtlPrefixSid( DomainSid, (PSID) Sids[SidIndex])) {

                if (!DomainAlreadyAdded) {

                    Status = LsapDbLookupAddListReferencedDomains(
                                 ReferencedDomains,
                                 TrustInformation,
                                 &DomainIndex
                                 );

                    if (!NT_SUCCESS(Status)) {

                        break;
                    }

                    DomainAlreadyAdded = TRUE;
                }

                //
                // Reference the domain from the TranslatedNames entry
                //

                TranslatedNames->Names[SidIndex].DomainIndex = DomainIndex;

                //
                // This Sid is now partially translated, so reduce the
                // count of completely unmapped Sids.
                //

                (*CompletelyUnmappedCount)--;
            }

            //
            // Decrement count of completely unmapped Sids scanned.
            //

            RemainingCompletelyUnmappedCount--;
        }
    }

    return(Status);
}


NTSTATUS
LsapDbLookupSidsInGlobalCatalog(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    IN BOOLEAN    fDoSidHistory,
    OUT NTSTATUS *NonFatalStatus
    )
/*++


Routine Description:

    This routine looks the list of sids that have yet to be resolved.
    If the any of the sids belong to domain that are stored in the DS,
    then therse sids are packages up and sent to a GC for translation.

    Note: this will resolve sids from domains that we trust directly and
    indirectly

Arguments:

    Sids - Pointer to an array of Sids to be looked up.

    Count - Number of Sids in the Sids array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    ReferencedDomains - Pointer to a Referenced Domain List structure.
        The structure references an array of zero or more Trust Information
        entries, one per referenced domain.  This array will be appended to
        or reallocated if necessary.

    TranslatedNames - Pointer to structure that optionally references a list
        of name translations for some of the Sids in the Sids array.

    MappedCount - Pointer to location containing the number of Sids
        in the Sids array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Sids.  A Sid is completely unmapped
        if it is unknown and also its Domain Prefix Sid is not recognized.
        This count is updated on exit, the number of completely unmapped
        Sids whose Domain Prefices are identified by this routine being
        subtracted from the input value.

    fDoSidHistory - if TRUE then the sids will try to be resolved via sid history

    NonFatalStatus - a status to indicate reasons why no sids could have been
                      resolved

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that
            some or all of the Sids may remain unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    ULONG          cGcSids = 0;
    PSID           *GcSidArray = NULL;
    BOOLEAN        *PossibleGcSidArray = NULL;
    SID_NAME_USE   *GcSidNameUse = NULL;
    ULONG          *GcSidFlags = NULL;
    UNICODE_STRING *GcNames = NULL;
    ULONG          *GcSidOriginalIndex = NULL;
    SAMPR_RETURNED_USTRING_ARRAY NameArray;

    UNICODE_STRING DomainName, UserName;
    UNICODE_STRING BackSlash;



    ULONG i;

    // Parameter check
    ASSERT( Count == TranslatedNames->Entries );

    *NonFatalStatus = STATUS_SUCCESS;

    if ( !SampUsingDsData() ) {

        //
        // Only useful if the ds is running
        //
        return STATUS_SUCCESS;

    }

    RtlZeroMemory( &NameArray, sizeof(NameArray) );
    RtlInitUnicodeString( &BackSlash, L"\\" );

    //
    // Determine what sids are part of known nt5 domains
    // and package into an array
    //
    PossibleGcSidArray = MIDL_user_allocate( Count * sizeof(BOOLEAN) );
    if ( !PossibleGcSidArray ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }
    RtlZeroMemory( PossibleGcSidArray, Count * sizeof(BOOLEAN) );

    for ( i = 0; i < Count; i++ ) {

        PSID  DomainSid = NULL;
        ULONG Rid;



        //
        // Note: we want names that have just "unknown" set; they could be
        // partially mapped, this is fine.
        //
        if (  (TranslatedNames->Names[i].Use == SidTypeUnknown) ) {

            Status = LsapSplitSid( Sids[i],
                                   &DomainSid,
                                   &Rid );

            if ( !NT_SUCCESS( Status ) ) {
                goto Finish;
            }

            //
            // OPTIMIZE -- if DomainSid is current sid and we don't look up
            // by sid history then we shouldn't include the sid here
            //
            cGcSids++;
            PossibleGcSidArray[i] = TRUE;

            MIDL_user_free( DomainSid );
        }

    }

    if ( 0 == cGcSids ) {
        // nothing to do
        goto Finish;
    }

    //
    // Allocate lots of space to hold the resolved sids; this space will
    // be freed at the end of the routine
    //
    GcSidArray = MIDL_user_allocate( cGcSids * sizeof(PSID) );
    if ( !GcSidArray ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }
    RtlZeroMemory( GcSidArray, cGcSids * sizeof(PSID) );

    GcSidOriginalIndex = MIDL_user_allocate( cGcSids * sizeof(ULONG) );
    if ( !GcSidOriginalIndex ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }
    RtlZeroMemory( GcSidOriginalIndex, cGcSids * sizeof(ULONG) );

    //
    // Package up the sids
    //
    cGcSids = 0;
    for ( i = 0; i < Count; i++ ) {

        if ( PossibleGcSidArray[i] ) {
            GcSidArray[cGcSids] = Sids[i];
            GcSidOriginalIndex[cGcSids] = i;
            cGcSids++;
        }
    }

    // we are done with this
    MIDL_user_free( PossibleGcSidArray );
    PossibleGcSidArray = NULL;

    GcSidNameUse = MIDL_user_allocate( cGcSids * sizeof(SID_NAME_USE) );
    if ( !GcSidNameUse ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }
    GcSidFlags = MIDL_user_allocate( cGcSids * sizeof(ULONG) );
    if ( !GcSidFlags ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }
    for ( i = 0; i < cGcSids; i++ ) {
        GcSidNameUse[i] = SidTypeUnknown;
        GcSidFlags[i] = 0;
    }

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: Chaining a SID request to a GC\n"));

    //
    // Call into SAM to resolve the sids at a GC
    //
    Status = SamIGCLookupSids( cGcSids,
                               GcSidArray,
                               fDoSidHistory ? SAMP_LOOKUP_BY_SID_HISTORY : 0,
                               GcSidFlags,
                               GcSidNameUse,
                               &NameArray );


    if (!NT_SUCCESS(Status)) {
        LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: Chain to GC request failed  (0x%x)\n", Status));
    }

    if ( STATUS_DS_GC_NOT_AVAILABLE == Status ) {

        //
        // Ok, don't update the mapped count since no names were
        // resolved
        //
        LsapDbLookupReportEvent0( 1,
                                  EVENTLOG_WARNING_TYPE,
                                  LSAEVENT_LOOKUP_GC_FAILED,
                                  sizeof( ULONG ),
                                  &Status);

        *NonFatalStatus = Status;
        Status = STATUS_SUCCESS;
        goto Finish;

    }

    // Any other error is fatal
    if ( !NT_SUCCESS( Status ) ) {
        goto Finish;
    }

    //
    // For each name resolved, put back in the original array and update
    // the referenced domain's list
    //
    for ( i = 0; i < cGcSids; i++ ) {

        BOOLEAN fStatus;
        ULONG OriginalIndex;
        PSID  DomainSid = NULL;
        LSAPR_TRUST_INFORMATION TrustInformation;
        ULONG Rid;
        ULONG DomainIndex = LSA_UNKNOWN_INDEX;
        USHORT Length;

        RtlZeroMemory( &TrustInformation, sizeof(TrustInformation) );
        RtlZeroMemory( &DomainName, sizeof(DomainName) );
        RtlZeroMemory( &UserName, sizeof(UserName) );

        if (GcSidFlags[i] & SAMP_FOUND_XFOREST_REF) {

            //
            // Flag this entry to be resolved in a trusted forest
            //
            OriginalIndex = GcSidOriginalIndex[i];
            TranslatedNames->Names[OriginalIndex].Flags |= LSA_LOOKUP_SID_XFOREST_REF;

        }

        if ( SidTypeUnknown == GcSidNameUse[i] ) {

            //
            // Move on to the next one, right away
            //
            goto IterationCleanup;
        }

        //
        // This name was resolved! Find the domain reference element
        //
        if ( GcSidNameUse[i] != SidTypeDomain ) {

            //
            // Get downlevel domain name and then get sid
            //

            LsapRtlSplitNames( (UNICODE_STRING*) &NameArray.Element[i],
                                1,
                               &BackSlash,
                               &DomainName,
                               &UserName );

            if ( DomainName.Length > 0 ) {
                ASSERT( DomainName.Buffer );

                DomainName.Buffer[DomainName.Length/2] = L'\0';
                Status = LsapGetDomainSidByNetbiosName( DomainName.Buffer,
                                                       &DomainSid );

                DomainName.Buffer[DomainName.Length/2] = L'\\';

            } else {

                Status = STATUS_NO_SUCH_DOMAIN;
            }

            if ( STATUS_NO_SUCH_DOMAIN == Status ) {

                //
                // We don't know about this domain, thus we can't resolve
                // this name so move on to the next one
                // This can occur by either the returned name does not have
                // domain embedded in it, or we can't find the domain locally
                //
                Status = STATUS_SUCCESS;
                goto IterationCleanup;
            }

            if ( !NT_SUCCESS( Status ) ) {
                // This is fatal
                goto IterationCleanup;
            }

        } else {

            DomainSid =  GcSidArray[i];
        }

        fStatus = LsapDbLookupListReferencedDomains( ReferencedDomains,
                                                     DomainSid,
                                                     &DomainIndex );

        if ( FALSE == fStatus ) {

            //
            // No entry for this domain -- add it
            //

            // Set the sid
            TrustInformation.Sid = DomainSid;
            DomainSid = NULL;

            // Allocate and set the name
            Status = LsapGetDomainNameBySid(  TrustInformation.Sid,
                                             (PUNICODE_STRING) &TrustInformation.Name );

            if ( STATUS_NO_SUCH_DOMAIN == Status ) {
                //
                // We longer know about this domain, though we did
                // before we sent the name off to the GC.
                // Don't resolve this name, but do continue on with
                // the next name
                //
                Status = STATUS_SUCCESS;
                goto IterationCleanup;
            }

            // Any other error is a resource error
            if ( !NT_SUCCESS( Status ) ) {
                goto IterationCleanup;
            }

            //
            // Add the entry
            //
            Status = LsapDbLookupAddListReferencedDomains( ReferencedDomains,
                                                           &TrustInformation,
                                                           &DomainIndex );
            if ( !NT_SUCCESS( Status ) ) {
                goto IterationCleanup;
            }

        }

        // We should now have a domain index
        ASSERT( LSA_UNKNOWN_INDEX != DomainIndex );

        // Set the information in the returned array
        OriginalIndex = GcSidOriginalIndex[i];

        TranslatedNames->Names[OriginalIndex].Flags = ((GcSidFlags[i] & SAMP_FOUND_BY_SID_HISTORY) ? LSA_LOOKUP_SID_FOUND_BY_HISTORY : 0);
        TranslatedNames->Names[OriginalIndex].Use = GcSidNameUse[i];
        TranslatedNames->Names[OriginalIndex].DomainIndex = DomainIndex;

        // Copy over the name
        Length = UserName.MaximumLength;
        if ( Length > 0 ) {
            TranslatedNames->Names[OriginalIndex].Name.Buffer = MIDL_user_allocate( Length );
            if ( !TranslatedNames->Names[OriginalIndex].Name.Buffer ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto IterationCleanup;
            }
            RtlZeroMemory( TranslatedNames->Names[OriginalIndex].Name.Buffer, Length );
            TranslatedNames->Names[OriginalIndex].Name.MaximumLength = UserName.MaximumLength;
            TranslatedNames->Names[OriginalIndex].Name.Length = UserName.Length;
            RtlCopyMemory( TranslatedNames->Names[OriginalIndex].Name.Buffer, UserName.Buffer, UserName.Length );
        }

        (*MappedCount) += 1;
        (*CompletelyUnmappedCount) -= 1;

IterationCleanup:

        if ( TrustInformation.Sid
          && TrustInformation.Sid != GcSidArray[i]  ) {
            MIDL_user_free( TrustInformation.Sid );
        }

        if ( TrustInformation.Name.Buffer ) {
            MIDL_user_free( TrustInformation.Name.Buffer );
        }

        if ( DomainSid && DomainSid != GcSidArray[i] ) {
            MIDL_user_free( DomainSid );
        }

        if ( !NT_SUCCESS( Status ) ) {
            break;
        }


    }  // iterate over names returned from the GC search

Finish:

    // Release any memory SAM allocated for us
    SamIFree_SAMPR_RETURNED_USTRING_ARRAY( &NameArray );

    if ( GcSidOriginalIndex ) {
        MIDL_user_free( GcSidOriginalIndex );
    }
    if ( PossibleGcSidArray ) {
        MIDL_user_free( PossibleGcSidArray );
    }
    if ( GcSidArray ) {
        MIDL_user_free( GcSidArray );
    }
    if ( GcSidNameUse ) {
        MIDL_user_free( GcSidNameUse );
    }
    if ( GcSidFlags ) {
        MIDL_user_free( GcSidFlags );
    }

    if ( !NT_SUCCESS(Status) ) {

        // Any memory we've allocated that hasn't been placed in the
        // returned arrays here will get freed at a higher level on error.
        // So don't try to free it here
        NOTHING;
    }

    return Status;

}

NTSTATUS
LsapDbLookupSidsInGlobalCatalogWks(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SecondaryStatus = STATUS_SUCCESS;
    LSA_HANDLE ControllerPolicyHandle = NULL;
    PLSAPR_UNICODE_STRING ControllerNames = NULL;
    ULONG NextLevelCount;
    ULONG NextLevelMappedCount;
    ULONG SidIndex;
    ULONG NextLevelSidIndex;
    PLSAPR_REFERENCED_DOMAIN_LIST NextLevelReferencedDomains = NULL;
    PLSAPR_REFERENCED_DOMAIN_LIST OutputReferencedDomains = NULL;
    PLSA_TRANSLATED_NAME_EX NextLevelNames = NULL;
    PLSAPR_SID *NextLevelSids = NULL;
    LONG FirstEntryIndex;
    PULONG SidIndices = NULL;
    BOOLEAN PartialSidTranslationsAttempted = FALSE;
    LPWSTR ServerName = NULL;
    LPWSTR ServerPrincipalName = NULL;
    PVOID ClientContext = NULL;
    ULONG ServerRevision = 0;

    *NonFatalStatus = STATUS_SUCCESS;

    //
    // If there are no completely unmapped Sids remaining, just return.
    //

    if (*CompletelyUnmappedCount == (ULONG) 0) {

        goto LookupSidsInPrimaryDomainFinish;
    }

    //
    // Open the Policy object on some GC in the forest.
    //
    Status = LsapDbOpenPolicyGc( &ControllerPolicyHandle );

    if (!NT_SUCCESS(Status)) {

        //
        // We cannot access the Global Catalog. Suppress the error
        // and translate Domain Prefix Sids for Sids belonging to
        // the Primary Domain.
        //

        //
        // If we can't open a open a secure channel if a DC call
        // this a trust relationship problem
        //
        *NonFatalStatus =  STATUS_DS_GC_NOT_AVAILABLE;

        Status = STATUS_SUCCESS;
        goto LookupSidsInPrimaryDomainFinish;
    }

    //
    // We have successfully opened a Domain Controller's Policy
    // Database.  Now prepare to hand off a Sid lookup for the
    // remaining unmapped Sids to that Controller.  Here, this
    // server side of the LSA is a client of the LSA on the
    // target controller.  We will construct an array of the
    // remianing unmapped Sids, look them up and then merge the
    // resulting ReferencedDomains and Translated Names into
    // our existing list.
    //

    NextLevelCount = *CompletelyUnmappedCount;

    //
    // Allocate an array to hold the indices of unmapped Sids
    // relative to the original Sids and TranslatedNames->Names
    // arrays.
    //

    SidIndices = MIDL_user_allocate(NextLevelCount * sizeof(ULONG));

    Status = STATUS_INSUFFICIENT_RESOURCES;

    if (SidIndices == NULL) {

        goto LookupSidsInPrimaryDomainError;
    }

    //
    // Allocate an array for the Sids to be looked up at the Domain
    // Controller.
    //

    NextLevelSids = MIDL_user_allocate( sizeof(PSID) * NextLevelCount );

    if (NextLevelSids == NULL) {

        goto LookupSidsInPrimaryDomainError;
    }

    Status = STATUS_SUCCESS;

    //
    // Now scan the original array of Names and its parallel
    // Translated Sids array.  Copy over any Sids that are
    // completely unmapped.
    //

    NextLevelSidIndex = (ULONG) 0;

    for (SidIndex = 0;
         SidIndex < Count && NextLevelSidIndex < NextLevelCount;
         SidIndex++) {

        if (LsapDbCompletelyUnmappedName(&TranslatedNames->Names[SidIndex])) {

            NextLevelSids[NextLevelSidIndex] = Sids[SidIndex];
            SidIndices[NextLevelSidIndex] = SidIndex;
            NextLevelSidIndex++;
        }
    }

    NextLevelMappedCount = (ULONG) 0;

    Status = LsaICLookupSids(
                 ControllerPolicyHandle,
                 NextLevelCount,
                 (PSID *) NextLevelSids,
                 (PLSA_REFERENCED_DOMAIN_LIST *) &NextLevelReferencedDomains,
                 &NextLevelNames,
                 LsapLookupGC,
                 0,
                 &NextLevelMappedCount,
                 &ServerRevision
                 );

    //
    // If the callout to LsaLookupSids() was unsuccessful, disregard
    // the error and set the domain name for any Sids having this
    // domain Sid as prefix sid.  We still want to return translations
    // of Sids we have so far even if we are unable to callout to another
    // LSA.
    //

    if (!NT_SUCCESS(Status)) {

        //
        // Let the caller know there is a trust problem
        //
        if ( (STATUS_TRUSTED_DOMAIN_FAILURE == Status)
          || (STATUS_DS_GC_NOT_AVAILABLE == Status)  ) {
            *NonFatalStatus = Status;
        }

        Status = STATUS_SUCCESS;
        goto LookupSidsInPrimaryDomainFinish;
    }

    //
    // Cache any sids that came back
    //

    (void) LsapDbUpdateCacheWithSids(
            NextLevelSids,
            NextLevelCount,
            NextLevelReferencedDomains,
            NextLevelNames
            );

    //
    // The callout to LsaLookupSids() was successful.  We now have
    // an additional list of Referenced Domains containing the
    // Primary Domain and/or one or more of its Trusted Domains.
    // Merge the two Referenced Domain Lists together, noting that
    // since they are disjoint, the second list is simply
    // concatenated with the first.  The index of the first entry
    // of the second list will be used to adjust all of the
    // Domain Index entries in the Translated Names entries.
    // Note that since the memory for the graph of the first
    // Referenced Domain list has been allocated as individual
    // nodes, we specify that the nodes in this graph can be
    // referenced by the output Referenced Domain list.
    //

    Status = LsapDbLookupMergeDisjointReferencedDomains(
                 ReferencedDomains,
                 NextLevelReferencedDomains,
                 &OutputReferencedDomains,
                 LSAP_DB_USE_FIRST_MERGAND_GRAPH
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsInPrimaryDomainError;
    }

    FirstEntryIndex = ReferencedDomains->Entries;

    //
    // Now update the original list of Translated Names.  We
    // update each entry that has newly been translated by copying
    // the entry from the new list and adjusting its Referenced
    // Domain List Index upwards by adding the index of the first
    // entry in the Next level List..
    //

    for( NextLevelSidIndex = 0;
         NextLevelSidIndex < NextLevelCount;
         NextLevelSidIndex++ ) {

        if ( !LsapDbCompletelyUnmappedName(&NextLevelNames[NextLevelSidIndex]) ) {

            SidIndex = SidIndices[NextLevelSidIndex];

            if (NextLevelNames[NextLevelSidIndex].Use != SidTypeUnknown) {

                TranslatedNames->Names[SidIndex].Use
                = NextLevelNames[NextLevelSidIndex].Use;

                Status = LsapRpcCopyUnicodeString(
                             NULL,
                             (PUNICODE_STRING) &TranslatedNames->Names[SidIndex].Name,
                             &NextLevelNames[NextLevelSidIndex].Name
                             );

                if (!NT_SUCCESS(Status)) {

                    break;
                }
            }

            TranslatedNames->Names[SidIndex].DomainIndex =
                FirstEntryIndex +
                NextLevelNames[NextLevelSidIndex].DomainIndex;

            //
            // Update the count of completely unmapped Sids.
            //
            (*CompletelyUnmappedCount)--;

        }
    }

    //
    // Update the Referenced Domain List if a new one was produced
    // from the merge.  We retain the original top-level structure.
    // We do this regardless of whether we succeeded or failed, so
    // that we are guarenteed to get it cleaned up.
    //

    if (OutputReferencedDomains != NULL) {

        if (ReferencedDomains->Domains != NULL) {

            MIDL_user_free( ReferencedDomains->Domains );
            ReferencedDomains->Domains = NULL;
        }

        *ReferencedDomains = *OutputReferencedDomains;
        MIDL_user_free( OutputReferencedDomains );
        OutputReferencedDomains = NULL;
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsInPrimaryDomainError;
    }

    //
    // Update the Mapped Count and close the Controller Policy
    // Handle.
    //

    *MappedCount += NextLevelMappedCount;
    SecondaryStatus = LsaClose( ControllerPolicyHandle );
    ControllerPolicyHandle = NULL;


LookupSidsInPrimaryDomainFinish:

    //
    // If necessary, free the Next Level Referenced Domain List.
    // Note that this structure is allocated(all_nodes) since it was
    // allocated by the client side of the Domain Controller LSA.
    //

    if (NextLevelReferencedDomains != NULL) {

        MIDL_user_free( NextLevelReferencedDomains );
        NextLevelReferencedDomains = NULL;
    }

    //
    // If necessary, free the Next Level Sids array.  We only free the
    // top level.
    //

    if (NextLevelSids != NULL) {

        MIDL_user_free( NextLevelSids );
        NextLevelSids = NULL;
    }

    //
    // If necessary, free the Next Level Translated Names array.
    // Note that this array is allocated(all_nodes).
    //

    if (NextLevelNames != NULL) {

        MIDL_user_free( NextLevelNames );
        NextLevelNames = NULL;
    }

    //
    // If necessary, free the array that maps Sid Indices from the
    // Next Level to the Current Level.
    //

    if (SidIndices != NULL) {

        MIDL_user_free( SidIndices );
        SidIndices = NULL;
    }

    //
    // If necessary, close the Controller Policy Handle.
    //

    if ( ControllerPolicyHandle != NULL) {

        SecondaryStatus = LsaClose( ControllerPolicyHandle );
        ControllerPolicyHandle = NULL;

        if (!NT_SUCCESS(SecondaryStatus)) {

            goto LookupSidsInPrimaryDomainError;
        }
    }

    return(Status);

LookupSidsInPrimaryDomainError:

    //
    // If the primary status was a success code, but the secondary
    // status was an error, propagate the secondary status.
    //

    if ((!NT_SUCCESS(SecondaryStatus)) && NT_SUCCESS(Status)) {

        Status = SecondaryStatus;
    }

    goto LookupSidsInPrimaryDomainFinish;
}


NTSTATUS
LsapDbLookupSidsInTrustedForests(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    )
/*++

Routine Description:

    This routine is called during a LsapLookupPDC lookup.  It takes all of the
    SID's that have been marked as belonging to cross forest domains and
    chains to request to either 1) a DC in the root domain of this forest, or
    2) a DC in ex-forest if the local DC is a DC in the root domain.

Arguments:

    Count -- the number of entries in Sids
    
    Sids  -- the total collection of SIDs for the LsapLookupPDC request
    
    ReferencedDomains -- the domains of Sids
    
    TranslatedNames -- the names and characteristics of Sids
    
    Mapped -- the number of Sids that have been fully mapped
    
    CompletelyUnmappedCount -- the number of Sids whose domain portions haven't
                               been identified.
                               
    NonFatalStatus -- a connectivity problem, if any while chaining the request.                               
    
Return Values:

    STATUS_SUCCESS, or resource error otherwise
    
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS NextLevelSecondaryStatus = STATUS_SUCCESS;
    ULONG NextLevelCount = 0;
    ULONG NextLevelMappedCount;
    ULONG SidIndex;
    ULONG NextLevelSidIndex;
    PLSAPR_REFERENCED_DOMAIN_LIST NextLevelReferencedDomains = NULL;
    PLSAPR_REFERENCED_DOMAIN_LIST OutputReferencedDomains = NULL;
    PLSA_TRANSLATED_NAME_EX NextLevelNames = NULL;
    LSA_TRANSLATED_NAMES_EX NextLevelNamesStruct;
    PLSAPR_SID *NextLevelSids = NULL;
    LONG FirstEntryIndex;
    PULONG SidIndices = NULL;
    LPWSTR ServerName = NULL;
    LPWSTR ServerPrincipalName = NULL;
    PVOID ClientContext = NULL;
    ULONG ServerRevision = 0;
    BOOLEAN *PossibleXForestSids = NULL;
    BOOLEAN fAllocateAllNodes = FALSE;

    *NonFatalStatus = STATUS_SUCCESS;

    //
    // If there are no completely unmapped Sids remaining, just return.
    //

    if (*CompletelyUnmappedCount == (ULONG) 0) {

        goto LookupSidsInTrustedForestsFinish;
    }

    //
    // Allocate an array to keep track of which SID's are going to 
    // be sent off
    //
    PossibleXForestSids = midl_user_allocate(Count * sizeof(BOOLEAN));
    if (NULL == PossibleXForestSids) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto LookupSidsInTrustedForestsError;
    }
    RtlZeroMemory( PossibleXForestSids, Count * sizeof(BOOLEAN) );

    NextLevelCount = 0;
    for (SidIndex = 0; SidIndex < Count; SidIndex++) {

        if (TranslatedNames->Names[SidIndex].Flags & LSA_LOOKUP_SID_XFOREST_REF) {

            ULONG Buffer[SECURITY_MAX_SID_SIZE/sizeof( ULONG ) + 1 ];
            PSID DomainSid = (PSID)Buffer;
            DWORD Size = sizeof(Buffer);

            ASSERT( sizeof( Buffer ) >= SECURITY_MAX_SID_SIZE );

            if (GetWindowsAccountDomainSid(Sids[SidIndex], DomainSid, &Size)) {

                NTSTATUS Status2;

                Status2 = LsapDomainHasDirectExternalTrust(NULL,
                                                           DomainSid,
                                                           NULL,
                                                           NULL);
                if (NT_SUCCESS(Status2)) {
                    //
                    // Don't send of for xforest resolution, since we 
                    // can do it locally instead
                    //
                    continue;

                } else if ( Status2 != STATUS_NO_SUCH_DOMAIN ) {

                    goto LookupSidsInTrustedForestsError;
                }
            }

            PossibleXForestSids[SidIndex] = TRUE;
            NextLevelCount++;

        }
    }

    if (NextLevelCount == 0) {
        goto LookupSidsInTrustedForestsFinish;
    }

    //
    // Allocate an array to hold the indices of unmapped Sids
    // relative to the original Sids and TranslatedNames->Names
    // arrays.
    //

    SidIndices = MIDL_user_allocate(NextLevelCount * sizeof(ULONG));


    if (SidIndices == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto LookupSidsInTrustedForestsError;
    }

    //
    // Allocate an array for the Sids to be looked up at the Domain
    // Controller.
    //

    NextLevelSids = MIDL_user_allocate( sizeof(PSID) * NextLevelCount );

    if (NextLevelSids == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto LookupSidsInTrustedForestsError;
    }

    //
    // Now scan the original array of Names and its parallel
    // Translated Sids array.  Copy over any Sids that are
    // completely unmapped.
    //

    NextLevelSidIndex = (ULONG) 0;

    for (SidIndex = 0;
         SidIndex < Count && NextLevelSidIndex < NextLevelCount;
         SidIndex++) {

        if (PossibleXForestSids[SidIndex]) {
            NextLevelSids[NextLevelSidIndex] = Sids[SidIndex];
            SidIndices[NextLevelSidIndex] = SidIndex;
            NextLevelSidIndex++;
        }
    }

    NextLevelMappedCount = (ULONG) 0;

    NextLevelNamesStruct.Entries = 0;
    NextLevelNamesStruct.Names = NULL;

    Status = LsapDbLookupSidsInTrustedForestsWorker(NextLevelCount,
                                                    (PLSAPR_SID *) NextLevelSids,
                                                    (PLSAPR_REFERENCED_DOMAIN_LIST *) &NextLevelReferencedDomains,
                                                    (PLSAPR_TRANSLATED_NAMES_EX)&NextLevelNamesStruct,
                                                     &fAllocateAllNodes,
                                                    &NextLevelMappedCount,
                                                    &NextLevelSecondaryStatus);


    NextLevelNames = NextLevelNamesStruct.Names;

    if (!NT_SUCCESS(Status)
     && LsapDbIsStatusConnectionFailure(Status)) {

        *NonFatalStatus = Status;
        Status = STATUS_SUCCESS;
        goto LookupSidsInTrustedForestsFinish;

    } else if (NT_SUCCESS(Status)
            && !NT_SUCCESS(NextLevelSecondaryStatus)) {

        *NonFatalStatus = NextLevelSecondaryStatus;
        goto LookupSidsInTrustedForestsFinish;

    } else if (!NT_SUCCESS(Status) 
            && Status != STATUS_NONE_MAPPED) {
        //
        // Unhandled error; STATUS_NONE_MAPPED is handled to get
        // partially resolved names.
        //
        goto LookupSidsInTrustedForestsError;
    }
    ASSERT(NT_SUCCESS(Status) || Status == STATUS_NONE_MAPPED);
    Status = STATUS_SUCCESS;

    //
    // The callout to LsaLookupSids() was successful.  We now have
    // an additional list of Referenced Domains containing the
    // Primary Domain and/or one or more of its Trusted Domains.
    // Merge the two Referenced Domain Lists together, noting that
    // since they are disjoint, the second list is simply
    // concatenated with the first.  The index of the first entry
    // of the second list will be used to adjust all of the
    // Domain Index entries in the Translated Names entries.
    // Note that since the memory for the graph of the first
    // Referenced Domain list has been allocated as individual
    // nodes, we specify that the nodes in this graph can be
    // referenced by the output Referenced Domain list.
    //

    Status = LsapDbLookupMergeDisjointReferencedDomains(
                 ReferencedDomains,
                 NextLevelReferencedDomains,
                 &OutputReferencedDomains,
                 LSAP_DB_USE_FIRST_MERGAND_GRAPH
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsInTrustedForestsError;
    }

    FirstEntryIndex = ReferencedDomains->Entries;

    //
    // Now update the original list of Translated Names.  We
    // update each entry that has newly been translated by copying
    // the entry from the new list and adjusting its Referenced
    // Domain List Index upwards by adding the index of the first
    // entry in the Next level List..
    //

    for( NextLevelSidIndex = 0;
         NextLevelSidIndex < NextLevelCount;
         NextLevelSidIndex++ ) {

        if ( !LsapDbCompletelyUnmappedName(&NextLevelNames[NextLevelSidIndex]) ) {

            SidIndex = SidIndices[NextLevelSidIndex];

            if (NextLevelNames[NextLevelSidIndex].Use != SidTypeUnknown) {

                TranslatedNames->Names[SidIndex].Use
                = NextLevelNames[NextLevelSidIndex].Use;

                Status = LsapRpcCopyUnicodeString(
                             NULL,
                             (PUNICODE_STRING) &TranslatedNames->Names[SidIndex].Name,
                             &NextLevelNames[NextLevelSidIndex].Name
                             );

                if (!NT_SUCCESS(Status)) {

                    break;
                }
            }

            TranslatedNames->Names[SidIndex].DomainIndex =
                FirstEntryIndex +
                NextLevelNames[NextLevelSidIndex].DomainIndex;

            //
            // Update the count of completely unmapped Sids.
            //
            (*CompletelyUnmappedCount)--;

        }
    }

    //
    // Update the Referenced Domain List if a new one was produced
    // from the merge.  We retain the original top-level structure.
    // We do this regardless of whether we succeeded or failed, so
    // that we are guarenteed to get it cleaned up.
    //

    if (OutputReferencedDomains != NULL) {

        if (ReferencedDomains->Domains != NULL) {

            MIDL_user_free( ReferencedDomains->Domains );
            ReferencedDomains->Domains = NULL;
        }

        *ReferencedDomains = *OutputReferencedDomains;
        MIDL_user_free( OutputReferencedDomains );
        OutputReferencedDomains = NULL;
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsInTrustedForestsError;
    }

    //
    // Update the Mapped Count and close the Controller Policy
    // Handle.
    //

    *MappedCount += NextLevelMappedCount;


LookupSidsInTrustedForestsFinish:

    //
    // If necessary, free the Next Level Referenced Domain List.
    // Note the structure is not allocate_all_nodes
    //
    if (NextLevelReferencedDomains != NULL) {
        if (!fAllocateAllNodes) {
            if (NextLevelReferencedDomains->Domains) {
                for (NextLevelSidIndex = 0; 
                        NextLevelSidIndex < NextLevelReferencedDomains->Entries; 
                            NextLevelSidIndex++) {
                    if (NextLevelReferencedDomains->Domains[NextLevelSidIndex].Name.Buffer) {
                        MIDL_user_free(NextLevelReferencedDomains->Domains[NextLevelSidIndex].Name.Buffer);
                    }
                    if (NextLevelReferencedDomains->Domains[NextLevelSidIndex].Sid) {
                        MIDL_user_free(NextLevelReferencedDomains->Domains[NextLevelSidIndex].Sid);
                    }
                }
                MIDL_user_free(NextLevelReferencedDomains->Domains);
            }
        }
        MIDL_user_free( NextLevelReferencedDomains );
        NextLevelReferencedDomains = NULL;
    }

    //
    // If necessary, free the Next Level Sids array.  We only free the
    // top level.
    //

    if (NextLevelSids != NULL) {

        MIDL_user_free( NextLevelSids );
        NextLevelSids = NULL;
    }

    //
    // If necessary, free the Next Level Translated Names array.
    // Note that this array is !allocated(all_nodes).
    //
    if ( NextLevelNames != NULL ) {
        if (!fAllocateAllNodes) {
            for (NextLevelSidIndex = 0; 
                    NextLevelSidIndex < NextLevelCount; 
                        NextLevelSidIndex++) {
                if (NextLevelNames[NextLevelSidIndex].Name.Buffer) {
                    MIDL_user_free(NextLevelNames[NextLevelSidIndex].Name.Buffer);
                }
            }
        }
        MIDL_user_free( NextLevelNames );
        NextLevelNames = NULL;
    }

    //
    // If necessary, free the array that maps Sid Indices from the
    // Next Level to the Current Level.
    //

    if (SidIndices != NULL) {

        MIDL_user_free( SidIndices );
        SidIndices = NULL;
    }

    if (PossibleXForestSids != NULL) {

        MIDL_user_free( PossibleXForestSids );
        PossibleXForestSids = NULL;
    }

    return(Status);

LookupSidsInTrustedForestsError:

    goto LookupSidsInTrustedForestsFinish;

}


NTSTATUS
LsapDbLookupSidsInTrustedForestsWorker(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST * ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    OUT BOOLEAN* fAllocateAllNodes,        
    IN OUT PULONG MappedCount,
    OUT NTSTATUS *NonFatalStatus
    )
/*++

Routine Description:

    This routine is called during a LsapLookupPDC lookup or a 
    LsapLookupXForestReferral.  This routine assumes all of Sids belong
    to cross forest domains and either resolves them if this DC is in the
    root domain, or chains them to a DC in the root domain.

Arguments:

    Count -- the number of entries in Sids
    
    Sids  -- the SID's belonging to a XForest domain
    
    ReferencedDomains -- the domains of Sids
    
    TranslatedNames -- the names and characteristics of Sids
    
    fAllocateAllNodes -- describes how ReferencedDomains and TranslatesSids are
         allocated.
    
    Mapped -- the number of Sids that have been fully mapped
    
    NonFatalStatus -- a connectivity problem, if any while chaining the request.                               
    
Return Values:

    STATUS_SUCCESS, or resource error otherwise
    
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_LOOKUP_WORK_LIST WorkList = NULL;

    *NonFatalStatus = STATUS_SUCCESS;
    *fAllocateAllNodes = FALSE;

    if (!LsapDbDcInRootDomain()) {

        //
        // We are not at the root domain -- forward request
        //
        PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
        LSAPR_TRUST_INFORMATION_EX TrustInfoEx;

        //
        // Get our forest name
        //
        Status = LsapDbLookupGetDomainInfo(NULL,
                                           &DnsDomainInfo);
        if (!NT_SUCCESS(Status)) {
            goto LookupSidsInTrustedForestFinish;
        }

        RtlZeroMemory(&TrustInfoEx, sizeof(TrustInfoEx));
        TrustInfoEx.DomainName = *((LSAPR_UNICODE_STRING*)&DnsDomainInfo->DnsForestName);

        Status = LsaDbLookupSidChainRequest(&TrustInfoEx,
                                        Count,
                                        (PSID*)Sids,
                                        (PLSA_REFERENCED_DOMAIN_LIST *)ReferencedDomains,
                                        (PLSA_TRANSLATED_NAME_EX * )&TranslatedNames->Names,
                                        LsapLookupXForestReferral,
                                        MappedCount,
                                        NULL);

        if (TranslatedNames->Names) {
            TranslatedNames->Entries = Count;
            *fAllocateAllNodes = TRUE;
        }

        if (!NT_SUCCESS(Status)) {

            //
            // The attempt to chain failed; record the error
            // if it is interesting
            //
            if (LsapDbIsStatusConnectionFailure(Status)) {
                *NonFatalStatus = Status;
            }

            //
            // This should not fail the overall request
            //
            Status = STATUS_SUCCESS;
        }

    } else {

        //
        // Split the names up into different forests and issue a work
        // request for each one
        //
        ULONG i;
        ULONG CompletelyUnMapped = Count;


        TranslatedNames->Names = MIDL_user_allocate(Count * sizeof(LSA_TRANSLATED_NAME_EX));
        if (TranslatedNames->Names == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto LookupSidsInTrustedForestFinish;
        }
        TranslatedNames->Entries = Count;
    
        //
        // Initialize the Output Sids array.  Zeroise all fields, then
        // Mark all of the Output Sids as being unknown initially and
        // set the DomainIndex fields to a negative number meaning
        // "no domain"
        //
    
        RtlZeroMemory( TranslatedNames->Names, Count * sizeof(LSA_TRANSLATED_NAME_EX));
        for (i = 0; i < Count; i++) {
            TranslatedNames->Names[i].Use = SidTypeUnknown;
            TranslatedNames->Names[i].DomainIndex = LSA_UNKNOWN_INDEX;
        }
    
        //
        // Create an empty Referenced Domain List.
        //
        Status = LsapDbLookupCreateListReferencedDomains( ReferencedDomains, 0 );
        if (!NT_SUCCESS(Status)) {
    
            goto LookupSidsInTrustedForestFinish;
        }

        //
        // Build a WorkList for this Lookup and put it on the Work Queue.
        //
        // NOTE: This routine does not need to hold the Lookup Work Queue
        //       lock to ensure validity of the WorkList pointer, because the
        //       pointer remains valid until this routine frees it via
        //       LsapDbLookupDeleteWorkList().  Although other threads may
        //       process the WorkList, do not delete it.
        //
        //       A called routine must acquire the lock in order to access
        //       the WorkList after it has been added to the Work Queue.
        //
    
        Status = LsapDbLookupXForestSidsBuildWorkList(
                     Count,
                     Sids,
                     *ReferencedDomains,
                     TranslatedNames,
                     LsapLookupXForestResolve,
                     MappedCount,
                     &CompletelyUnMapped,
                     &WorkList
                     );
    
        if (!NT_SUCCESS(Status)) {
    
            //
            // If no Work List has been built because there are no
            // eligible domains to search, exit, suppressing the error.
    
            if (Status == STATUS_NONE_MAPPED) {
                Status = STATUS_SUCCESS;
            }
    
            goto LookupSidsInTrustedForestFinish;
        }
    
        //
        // Start the work, by dispatching one or more worker threads
        // if necessary.
        //
    
        Status = LsapDbLookupDispatchWorkerThreads( WorkList );
    
        if (!NT_SUCCESS(Status)) {
    
            goto LookupSidsInTrustedForestFinish;
        }
    
        //
        // Wait for completion/termination of all items on the Work List.
        //
    
        Status = LsapDbLookupAwaitCompletionWorkList( WorkList );
    
        if (!NT_SUCCESS(Status)) {
    
            goto LookupSidsInTrustedForestFinish;
        }

        if ( !NT_SUCCESS(WorkList->NonFatalStatus) ) {
            //
            // Propogate the error as non fatal
            //
            *NonFatalStatus = WorkList->NonFatalStatus;
        }

    }

LookupSidsInTrustedForestFinish:

    //
    // If a Work List was created, delete it from the Work Queue
    //

    if (WorkList != NULL) {

        Status = LsapDbLookupDeleteWorkList( WorkList );
        WorkList = NULL;
    }


    return Status;
}




NTSTATUS
LsapDbLookupSidsAsDomainSids(
    IN ULONG Flags,
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount
    )
/*++

Routine Description:

    This routine tries to match entries in Sids to domain Sids of 
    trusted domains.
    
    There are three kinds of trusted domains:
    
    1) domains we directly trusts (both in and out of forest).  The LSA TDL
    is used for this.
    
    2) domains we trust transitively.  The DS cross-ref is used for this.
    
    3) domains we trust via a forest trust. The LSA TDL is used
    for this.
    
Arguments:

    Flags -- LSAP_LOOKUP_TRUSTED_DOMAIN_DIRECT
             LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE
             LSAP_LOOKUP_TRUSTED_DOMAIN_FOREST_NAMES

    Count -- the number of entries in Sids
    
    Sids  -- the SID's belonging to a XForest domain
    
    ReferencedDomains -- the domains of Sids
    
    TranslatedNames -- the names and characteristics of Sids
    
    Mapped -- the number of Sids that have been fully mapped
    
Return Values:

    STATUS_SUCCESS, or resource error otherwise
    
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SidIndex;
    BOOLEAN               fTDLLock = FALSE;
    LSA_TRUST_INFORMATION TrustInfo;

    RtlZeroMemory(&TrustInfo, sizeof(TrustInfo));
    for (SidIndex = 0; SidIndex < Count; SidIndex++) {

        LSAPR_TRUSTED_DOMAIN_INFORMATION_EX *TrustInfoEx = NULL;
        LSAPR_TRUSTED_DOMAIN_INFORMATION_EX  TrustInfoBuffer;
        PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY   TrustEntry = NULL;
        PBYTE Buffer[SECURITY_MAX_SID_SIZE];
        PSID DomainSid = (PSID)Buffer;
        ULONG Length;
        ULONG DomainIndex;
        BOOLEAN fStatus;

        RtlZeroMemory(&TrustInfo, sizeof(TrustInfo));

        if (!LsapDbCompletelyUnmappedName(&TranslatedNames->Names[SidIndex])) {
            // Already resolved
            continue;
        }

        //
        // If this isn't a domain SID, bail
        //
        Length = sizeof(Buffer);
        if (!GetWindowsAccountDomainSid(Sids[SidIndex],
                                        DomainSid,
                                        &Length)) {
            continue;
        }
        if (!EqualSid(DomainSid, Sids[SidIndex])) {
            continue;
        }

        if (Flags & LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE) {

            Status = LsapDomainHasTransitiveTrust(NULL,
                                                  Sids[SidIndex],
                                                  &TrustInfo);

            if (NT_SUCCESS(Status)) {
                TrustInfoEx = &TrustInfoBuffer;
                RtlZeroMemory(&TrustInfoBuffer, sizeof(TrustInfoBuffer));
                TrustInfoEx->FlatName = *(LSAPR_UNICODE_STRING*)&TrustInfo.Name;
                TrustInfoEx->Sid = TrustInfo.Sid;
            } else if (Status == STATUS_NO_SUCH_DOMAIN) {
                Status = STATUS_SUCCESS;
            } else {
                // This is fatal
                goto Exit;
            }
        }

        if ((NULL == TrustInfoEx)
         && (Flags & LSAP_LOOKUP_TRUSTED_DOMAIN_DIRECT)) {

            Status = LsapDomainHasDirectTrust(NULL,
                                              Sids[SidIndex],
                                              &fTDLLock,
                                              &TrustEntry);

            if (NT_SUCCESS(Status)) {
                TrustInfoEx = &TrustEntry->TrustInfoEx;
            } else if (Status == STATUS_NO_SUCH_DOMAIN) {
                Status = STATUS_SUCCESS;
            } else {
                // This is fatal
                goto Exit;
            }
        }

        if ((NULL == TrustInfoEx)
         && (Flags & LSAP_LOOKUP_TRUSTED_FOREST_ROOT) ) {

            Status = LsapDomainHasForestTrust(NULL,
                                              Sids[SidIndex],
                                              &fTDLLock,
                                              &TrustEntry);

            if (NT_SUCCESS(Status)) {
                TrustInfoEx = &TrustEntry->TrustInfoEx;
            } else if (Status == STATUS_NO_SUCH_DOMAIN) {
                Status = STATUS_SUCCESS;
            } else {
                // This is fatal
                goto Exit;
            }
        }

        if (TrustInfoEx) {

            //
            // Match -- add it to the list of resolved SID's
            //

            fStatus = LsapDbLookupListReferencedDomains( ReferencedDomains,
                                                         Sids[SidIndex],
                                                         &DomainIndex );

            if ( FALSE == fStatus ) {

                LSA_TRUST_INFORMATION TempTrustInfo;

                //
                // No entry for this domain -- add it
                //
                RtlZeroMemory(&TempTrustInfo, sizeof(TempTrustInfo));

                // Set the sid
                TempTrustInfo.Sid = TrustInfoEx->Sid;
                TempTrustInfo.Name = *(PUNICODE_STRING)&TrustInfoEx->FlatName;

                //
                // Add the entry
                //
                Status = LsapDbLookupAddListReferencedDomains( ReferencedDomains,
                                                               (PLSAPR_TRUST_INFORMATION) &TempTrustInfo,
                                                               &DomainIndex );
                if ( !NT_SUCCESS( Status ) ) {
                    goto Exit;
                }
            }

            // We should now have a domain index
            ASSERT( LSA_UNKNOWN_INDEX != DomainIndex );

            // Set the information in the returned array
            TranslatedNames->Names[SidIndex].Use = SidTypeDomain;
            TranslatedNames->Names[SidIndex].DomainIndex = DomainIndex;
            RtlZeroMemory( &TranslatedNames->Names[SidIndex].Name, sizeof(UNICODE_STRING) );

            //
            // Increment the number of items mapped
            //
            (*MappedCount) += 1;

        }

        if (fTDLLock) {
            LsapDbReleaseLockTrustedDomainList();
            fTDLLock = FALSE;
        }

        if (TrustInfo.Name.Buffer) {
            midl_user_free(TrustInfo.Name.Buffer);
            TrustInfo.Name.Buffer = NULL;
        }
        if (TrustInfo.Sid) {
            midl_user_free(TrustInfo.Sid);
            TrustInfo.Sid = NULL;
        }

        if (!NT_SUCCESS(Status)) {
            goto Exit;
        }
    }

Exit:

    if (fTDLLock) {
        LsapDbReleaseLockTrustedDomainList();
        fTDLLock = FALSE;
    }

    if (TrustInfo.Name.Buffer) {
        midl_user_free(TrustInfo.Name.Buffer);
        TrustInfo.Name.Buffer = NULL;
    }
    if (TrustInfo.Sid) {
        midl_user_free(TrustInfo.Sid);
        TrustInfo.Sid = NULL;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbp.h

Abstract:

    LSA Database Private Functions, Datatypes and Defines

Author:

    Scott Birrell       (ScottBi)       May 29, 1991

Environment:

Revision History:

--*/

#ifndef _LSADBP_
#define _LSADBP_

#ifndef DBP_TYPES_ONLY
#include <dsp.h>
#endif

#include <safelock.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// LSA revisions
//
//      NT 1.0  (3.1)    ==> 1.0
//      NT 1.0A (3.5)    ==> 1.1
//      NT 4.0, SP 4     ==> 1.2
//      Win2K B3         ==> 1.4
//      Win2K            ==> 1.5
//      Whistler Preview ==> 1.6
//      Whistler Preview ==> 1.7
//

#define LSAP_DB_REVISION_1_0            0x00010000
#define LSAP_DB_REVISION_1_1            0x00010001
#define LSAP_DB_REVISION_1_2            0x00010002
#define LSAP_DB_REVISION_1_3            0x00010003
#define LSAP_DB_REVISION_1_4            0x00010004
#define LSAP_DB_REVISION_1_5            0x00010005
#define LSAP_DB_REVISION_1_6            0x00010006
#define LSAP_DB_REVISION_1_7            0x00010007
#define LSAP_DB_REVISION                LSAP_DB_REVISION_1_7


#ifndef RPC_C_AUTHN_NETLOGON
#define RPC_C_AUTHN_NETLOGON 0x44
#endif // RPC_C_AUTHN_NETLOGON

//
// Uncomment the define LSA_SAM_ACCOUNTS_DOMAIN_TEST to enable the
// code needed for the ctsamdb test program.  Recompile dbsamtst.c,
// dbpolicy.c.  rebuild lsasrv.dll and nmake UMTYPE=console UMTEST=ctsamdb.
//
// #define LSA_SAM_ACCOUNTS_DOMAIN_TEST
//

//
// Prefered Maximum Length of data used for internal enumerations.
//

#define LSAP_DB_ENUM_DOMAIN_LENGTH      ((ULONG) 0x00000100L)

//
// Write operations are not allowed on Backup controllers (except
// for trusted clients).
//

#define LSAP_POLICY_WRITE_OPS           (DELETE                           |\
                                         WRITE_OWNER                      |\
                                         WRITE_DAC                        |\
                                         POLICY_TRUST_ADMIN               |\
                                         POLICY_CREATE_ACCOUNT            |\
                                         POLICY_CREATE_SECRET             |\
                                         POLICY_CREATE_PRIVILEGE          |\
                                         POLICY_SET_DEFAULT_QUOTA_LIMITS  |\
                                         POLICY_SET_AUDIT_REQUIREMENTS    |\
                                         POLICY_AUDIT_LOG_ADMIN           |\
                                         POLICY_SERVER_ADMIN)

#define LSAP_ACCOUNT_WRITE_OPS          (DELETE                           |\
                                         WRITE_OWNER                      |\
                                         WRITE_DAC                        |\
                                         ACCOUNT_ADJUST_PRIVILEGES        |\
                                         ACCOUNT_ADJUST_QUOTAS            |\
                                         ACCOUNT_ADJUST_SYSTEM_ACCESS)

#define LSAP_TRUSTED_WRITE_OPS          (DELETE                           |\
                                         WRITE_OWNER                      |\
                                         WRITE_DAC                        |\
                                         TRUSTED_SET_CONTROLLERS          |\
                                         TRUSTED_SET_POSIX                |\
                                         TRUSTED_SET_AUTH )

#define LSAP_SECRET_WRITE_OPS           (DELETE                           |\
                                         WRITE_OWNER                      |\
                                         WRITE_DAC                        |\
                                         SECRET_SET_VALUE)

//
// Maximum number of attributes an object can have
//

#define LSAP_DB_MAX_ATTRIBUTES   (0x00000020)

//
// LSA Absolute Minimum and Maximum Quota Limit values
//
// These values represent the endpoints of the range of permitted values
// which a quota limit may be set via the LsaSetQuotaLimitsForLsa() API
//
// FIX, FIX - get real values from Loup
//


#define LSAP_DB_WINNT_PAGED_POOL            (0x02000000L)
#define LSAP_DB_WINNT_NON_PAGED_POOL        (0x00100000L)
#define LSAP_DB_WINNT_MIN_WORKING_SET       (0x00010000L)
#define LSAP_DB_WINNT_MAX_WORKING_SET       (0x0f000000L)
#define LSAP_DB_WINNT_PAGEFILE              (0x0f000000L)

#define LSAP_DB_LANMANNT_PAGED_POOL         (0x02000000L)
#define LSAP_DB_LANMANNT_NON_PAGED_POOL     (0x00100000L)
#define LSAP_DB_LANMANNT_MIN_WORKING_SET    (0x00010000L)
#define LSAP_DB_LANMANNT_MAX_WORKING_SET    (0x0f000000L)
#define LSAP_DB_LANMANNT_PAGEFILE           (0x0f000000L)

#define LSAP_DB_ABS_MIN_PAGED_POOL          (0x00010000L)
#define LSAP_DB_ABS_MIN_NON_PAGED_POOL      (0x00010000L)
#define LSAP_DB_ABS_MIN_MIN_WORKING_SET     (0x00000001L)
#define LSAP_DB_ABS_MIN_MAX_WORKING_SET     (0x00001000L)
#define LSAP_DB_ABS_MIN_PAGEFILE            (0x00001000L)

#define LSAP_DB_ABS_MAX_PAGED_POOL          (0xffffffffL)
#define LSAP_DB_ABS_MAX_NON_PAGED_POOL      (0xffffffffL)
#define LSAP_DB_ABS_MAX_MIN_WORKING_SET     (0xffffffffL)
#define LSAP_DB_ABS_MAX_MAX_WORKING_SET     (0xffffffffL)
#define LSAP_DB_ABS_MAX_PAGEFILE            (0xffffffffL)

//
// Flags that determine some of the behavior of the EnumerateTrustedDomainsEx call
//
#define LSAP_DB_ENUMERATE_NO_OPTIONS        0x00000000
#define LSAP_DB_ENUMERATE_AS_NT4            0x00000001
#define LSAP_DB_ENUMERATE_NULL_SIDS         0x00000002

//
// Flags that determine some of the behavior of the CreateHandle call
//
#define LSAP_DB_CREATE_OPEN_EXISTING        0x00000001
#define LSAP_DB_CREATE_HANDLE_MORPH         0x00000002

#if defined(REMOTE_BOOT)
//
// On disked remote boot machines, the redirector needs to track changes to
// the machine account password. These flags indicate what state this machine
// is in with respect to that. The choices are:
// - no notification, the machine is not remote boot, or is diskless.
// - can't notify, machine is disked remote boot but the redir can't
//   handle a password change notification on this boot.
// - notify, the redir should be told of changes
// NOTE: These values are stored in a CHAR value in LSAP_DB_STATE.
//
#define LSAP_DB_REMOTE_BOOT_NO_NOTIFICATION       0x01
#define LSAP_DB_REMOTE_BOOT_CANT_NOTIFY           0x02
#define LSAP_DB_REMOTE_BOOT_NOTIFY                0x03
#endif // defined(REMOTE_BOOT)

//
// The order of this enum is the order in which locks
// must be acquired.  Violating this order will result
// in asserts firing in debug builds.
//
// Do not change the order of this enum without first verifying
// thoroughly that the change is safe.
//

typedef enum {
    POLICY_CHANGE_NOTIFICATION_LOCK_ENUM,
    POLICY_LOCK_ENUM,
    TRUST_LOCK_ENUM,
    ACCOUNT_LOCK_ENUM,
    SECRET_LOCK_ENUM,
    REGISTRY_LOCK_ENUM,
    HANDLE_TABLE_LOCK_ENUM,
    LSAP_FIXUP_LOCK_ENUM,
    LOOKUP_WORK_QUEUE_LOCK_ENUM,
    THREAD_INFO_LIST_LOCK_ENUM,
    POLICY_CACHE_LOCK_ENUM,
} LSAP_LOCK_ENUM;

//
// NOTES on Logical and Physical Names
//
// LogicalName - Unicode String containing the Logical Name of the object.
//     The Logical Name of an object is the name by which it is known
//     to the outside world, e.g, SCOTTBI might be a typical name for
//     a user account object
// PhysicalName - Unicode String containing the Physical name of the object.
//     This is a name internal to the Lsa Database and is dependent on the
//     implementation.  For the current implementation of the LSA Database
//     as a subtree of keys within the Configuration Registry, the
//     PhysicalName is the name of the Registry Key for the object relative
//     to the container object, e.g, ACCOUNTS\SCOTTBI is the Physical Name
//     for the user account object with Logical Name SCOTTBI.
//

//
// LSA Database Object Containing Directories
//

UNICODE_STRING LsapDbContDirs[DummyLastObject];


typedef enum _LSAP_DB_CACHE_STATE {

    LsapDbCacheNotSupported = 1,
    LsapDbCacheInvalid,
    LsapDbCacheBuilding,
    LsapDbCacheValid

} LSAP_DB_CACHE_STATE, *PLSAP_DB_CACHE_STATE;

//
// LSA Database Object Type Structure
//

typedef struct _LSAP_DB_OBJECT_TYPE {

     GENERIC_MAPPING GenericMapping;
     ULONG ObjectCount;
     NTSTATUS ObjectCountError;
     ULONG MaximumObjectCount;
     ACCESS_MASK WriteOperations;
     ACCESS_MASK AliasAdminsAccess;
     ACCESS_MASK WorldAccess;
     ACCESS_MASK AnonymousLogonAccess;
     ACCESS_MASK LocalServiceAccess;
     ACCESS_MASK NetworkServiceAccess;
     ACCESS_MASK InvalidMappedAccess;
     PSID InitialOwnerSid;
     BOOLEAN ObjectCountLimited;
     BOOLEAN AccessedBySid;
     BOOLEAN AccessedByName;
     LSAP_DB_CACHE_STATE CacheState;
     PVOID ObjectCache;

} LSAP_DB_OBJECT_TYPE, *PLSAP_DB_OBJECT_TYPE;

//
// LSA Database Object Name types
//

typedef enum _LSAP_DB_OBJECT_NAME_TYPE {

    LsapDbObjectPhysicalName = 1,
    LsapDbObjectLogicalName

} LSAP_DB_OBJECT_NAME_TYPE, *PLSAP_DB_OBJECT_NAME_TYPE;

#define LsapDbMakeCacheUnsupported( ObjectTypeId )                                 \
                                                                             \
    {                                                                        \
        LsapDbState.DbObjectTypes[ ObjectTypeId ].CacheState = LsapDbCacheNotSupported;   \
    }

#define LsapDbMakeCacheSupported( ObjectTypeId )                             \
                                                                             \
    {                                                                        \
        LsapDbState.DbObjectTypes[ ObjectTypeId ].CacheState = LsapDbCacheInvalid;      \
    }

#define LsapDbMakeCacheInvalid( ObjectTypeId )                               \
                                                                             \
    {                                                                        \
        LsapDbState.DbObjectTypes[ ObjectTypeId ].CacheState = LsapDbCacheInvalid;  \
    }

#define LsapDbMakeCacheBuilding( ObjectTypeId )                                 \
                                                                             \
    {                                                                        \
        LsapDbState.DbObjectTypes[ ObjectTypeId ].CacheState = LsapDbCacheBuilding;   \
    }


#define LsapDbMakeCacheValid( ObjectTypeId )                                 \
                                                                             \
    {                                                                        \
        LsapDbState.DbObjectTypes[ ObjectTypeId ].CacheState = LsapDbCacheValid;   \
    }

#define LsapDbIsCacheValid( ObjectTypeId )                                 \
    (LsapDbState.DbObjectTypes[ ObjectTypeId ].CacheState == LsapDbCacheValid)

#define LsapDbIsCacheSupported( ObjectTypeId )                                 \
    (LsapDbState.DbObjectTypes[ ObjectTypeId ].CacheState != LsapDbCacheNotSupported)

#define LsapDbIsCacheBuilding( ObjectTypeId )                                 \
    (LsapDbState.DbObjectTypes[ ObjectTypeId ].CacheState == LsapDbCacheBuilding)

#define LsapDbLockAcquire( lock ) \
    SafeEnterCriticalSection( (lock) )

#define LsapDbLockRelease( lock ) \
    SafeLeaveCriticalSection( (lock) )

BOOLEAN
LsapDbIsLocked(
    IN PSAFE_CRITICAL_SECTION CritSect
    );

BOOLEAN
LsapDbResourceIsLocked(
    IN PSAFE_RESOURCE Resource
    );

VOID
LsapDbAcquireLockEx(
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN ULONG Options
    );

VOID
LsapDbReleaseLockEx(
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN ULONG Options
    );

NTSTATUS
LsapDbSetStates(
    IN ULONG DesiredStates,
    IN LSAPR_HANDLE ObjectHandle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId
    );

NTSTATUS
LsapDbResetStates(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN SECURITY_DB_DELTA_TYPE SecurityDbDeltaType,
    IN NTSTATUS PreliminaryStatus
    );

//
// LSA Database Local State Information.  This structure contains various
// global variables containing dynamic state information.
//

typedef struct _LSAP_DB_STATE {

    //
    //
    // LSA's NT 4 replication serial number
    //
    // Access serialized by RegistryLock.
    POLICY_MODIFICATION_INFO PolicyModificationInfo;

    //
    // Lsa Database Root Dir Reg Key Handle
    //
    // Initialized at startup (not serialized)
    //
    HANDLE DbRootRegKeyHandle;    // Lsa Database Root Dir Reg Key Handle


    // Access serialized by HandleTableLock
    ULONG OpenHandleCount;


    // Initialized at startup (not serialized)
    BOOLEAN DbServerInitialized;
    BOOLEAN ReplicatorNotificationEnabled;

    // Access serialized by RegistryLock
    BOOLEAN RegistryTransactionOpen;

#if defined(REMOTE_BOOT)
    CHAR RemoteBootState;               // holds LSAP_DB_REMOTE_BOOT_XXX values
#endif // defined(REMOTE_BOOT)


    //
    // Critical Sections.
    //
    // These are the crit sects that protect global data.
    //
    // The order below is the required locking order..
    //

    SAFE_CRITICAL_SECTION PolicyLock;
    SAFE_CRITICAL_SECTION AccountLock;
    SAFE_CRITICAL_SECTION SecretLock;
    SAFE_CRITICAL_SECTION RegistryLock;     // Used to control access to registry transactioning
    SAFE_CRITICAL_SECTION HandleTableLock;
    SAFE_RESOURCE PolicyCacheLock;
    RTL_RESOURCE ScePolicyLock;
    HANDLE SceSyncEvent;
    // TrustedDomainList->Resource         // Locking order comment


    // Access serialized by RegistryLock
    PRTL_RXACT_CONTEXT RXactContext;

    // Access serialized by RegistryLock
    ULONG RegistryModificationCount;

    // Access not serialized
    BOOLEAN EmulateNT4;

    //
    // Access serialized by object type specific lock.
    //
    LSAP_DB_OBJECT_TYPE DbObjectTypes[LSAP_DB_OBJECT_TYPE_COUNT];


} LSAP_DB_STATE, *PLSAP_DB_STATE;

//
// Maximum number of SCE policy writers allowed at the same time
//

#define MAX_SCE_WAITING_SHARED 500

extern LSAP_DB_STATE LsapDbState;

#ifdef DBG
extern BOOL g_ScePolicyLocked;
#endif

extern BOOLEAN LsapDbReturnAuthData;

extern BOOLEAN DcInRootDomain;

//
// LSA Database Private Data.  This Data is eligible for replication,
// unlike the Local State Information above which is meaningful on
// the local machine only.
//

typedef struct _LSAP_DB_POLICY_PRIVATE_DATA {

    ULONG NoneDefinedYet;

} LSAP_DB_POLICY_PRIVATE_DATA, *PLSAP_DB_POLICY_PRIVATE_DATA;

//
// structure for storing secret encryption keys
//

#include  <pshpack1.h>

typedef struct _LSAP_DB_ENCRYPTION_KEY {
    ULONG   Revision;
    ULONG   BootType;
    ULONG   Flags;
    GUID    Authenticator;
    UCHAR   Key [16];//128 bit key
    UCHAR   OldSyskey[16]; // for recovery
    UCHAR   Salt[16];//128 bit Salt
} LSAP_DB_ENCRYPTION_KEY, *PLSAP_DB_ENCRYPTION_KEY;

#include <poppack.h>

#define LSAP_DB_ENCRYPTION_KEY_VERSION      0x1
extern  PLSAP_CR_CIPHER_KEY LsapDbCipherKey;
extern PLSAP_CR_CIPHER_KEY LsapDbSecretCipherKeyRead;
extern PLSAP_CR_CIPHER_KEY LsapDbSecretCipherKeyWrite;
extern  PLSAP_CR_CIPHER_KEY LsapDbSP4SecretCipherKey;
extern  PVOID   LsapDbSysKey;
extern  PVOID   LsapDbOldSysKey;


//
// Flag to let us know that the secret has been encrypted with syskey, instead of the normal
// cipher key.  We store this in the high order of the maximum length of the key
//
#define LSAP_DB_SECRET_SP4_SYSKEY_ENCRYPTED     0x10000000
#define LSAP_DB_SECRET_WIN2K_SYSKEY_ENCRYPTED   0x20000000

#define LsapDbSP4CipheredSecretLength( len ) ( ( len ) & ~LSAP_DB_SECRET_SYSKEY_ENCRYPTED )
#define LsapDbCipheredSecretLength( len )    ( ( len ) & ~(0xF0000000))  // consider top nibble reserved for encryption type.

#define LSAP_BOOT_KEY_RETRY_COUNT 3
#define LSAP_SYSKEY_SIZE          16



//
// Object Enumeration Element Structure
//

typedef struct _LSAP_DB_ENUMERATION_ELEMENT {

    struct _LSAP_DB_ENUMERATION_ELEMENT *Next;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    PSID Sid;
    UNICODE_STRING Name;

} LSAP_DB_ENUMERATION_ELEMENT, *PLSAP_DB_ENUMERATION_ELEMENT;

//
// Handle Table Handle Entry
//
typedef struct _LSAP_DB_HANDLE_TABLE_USER_ENTRY {

    LIST_ENTRY Next;
    LIST_ENTRY PolicyHandles;
    LIST_ENTRY ObjectHandles;
    ULONG PolicyHandlesCount;
    ULONG MaxPolicyHandles ;
    LUID  LogonId;
    HANDLE  UserToken;

} LSAP_DB_HANDLE_TABLE_USER_ENTRY, *PLSAP_DB_HANDLE_TABLE_USER_ENTRY;

//
// Handle Table Header Block
//
// One of these structures exists for each Handle Table
//
#define LSAP_DB_HANDLE_FREE_LIST_SIZE   6
typedef struct _LSAP_DB_HANDLE_TABLE {

    ULONG UserCount;
    LIST_ENTRY UserHandleList;
    ULONG FreedUserEntryCount;
    PLSAP_DB_HANDLE_TABLE_USER_ENTRY FreedUserEntryList[ LSAP_DB_HANDLE_FREE_LIST_SIZE ];

} LSAP_DB_HANDLE_TABLE, *PLSAP_DB_HANDLE_TABLE;

//
// Conditions on a TDO under which forest trust information may exist
//

BOOLEAN
LsapHavingForestTrustMakesSense(
    IN ULONG TrustDirection,
    IN ULONG TrustType,
    IN ULONG TrustAttributes
    );

NTSTATUS
LsapForestTrustInsertLocalInfo(
    );

NTSTATUS
LsapForestTrustUnmarshalBlob(
    IN ULONG Length,
    IN BYTE * Blob,
    IN LSA_FOREST_TRUST_RECORD_TYPE HighestRecordType,
    OUT PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo
    );

NTSTATUS
LsapForestTrustCacheInitialize(
    );

NTSTATUS
LsapForestTrustCacheInsert(
    IN UNICODE_STRING * TrustedDomainName,
    IN PSID TrustedDomainSid OPTIONAL,
    IN LSA_FOREST_TRUST_INFORMATION * ForestTrustInfo,
    IN BOOLEAN LocalForestEntry
    );

NTSTATUS
LsapForestTrustCacheRemove(
    IN UNICODE_STRING * TrustedDomainName
    );

VOID
LsapFreeForestTrustInfo(
    IN PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo
    );

VOID
LsapFreeCollisionInfo(
    IN OUT PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo
    );

VOID
LsapForestTrustCacheSetValid();

VOID
LsapForestTrustCacheSetInvalid();

BOOLEAN
LsapForestTrustCacheIsValid();

NTSTATUS
LsapRebuildFtCacheGC();

NTSTATUS
LsapValidateNetbiosName(
    IN const UNICODE_STRING * Name,
    OUT BOOLEAN * Valid
    );

NTSTATUS
LsapValidateDnsName(
    IN const UNICODE_STRING * Name,
    OUT BOOLEAN * Valid
    );

#ifdef __cplusplus
}
#endif // __cplusplus

///////////////////////////////////////////////////////////////////////////////
//
//  End of Forest Trust Cache definitions
//
///////////////////////////////////////////////////////////////////////////////


//
// Trusted Domain List.  This list caches the Trust Information for
// all Trusted Domains in the Policy Database, and enables lookup
// operations to locate Trusted Domains by Sid or Name without recourse
// to the Trusted Domain objects themselves.
//

typedef struct _LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY {

    LIST_ENTRY NextEntry;
    LSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustInfoEx;
    LSAPR_TRUST_INFORMATION ConstructedTrustInfo;
    ULONG SequenceNumber;
    ULONG PosixOffset;
    GUID ObjectGuidInDs;

} LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY, *PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY;

//
// Information used to manage and build the trust tree
//
typedef struct _LSAPDS_FOREST_TRUST_BLOB {

    LIST_ENTRY Next;
    UNICODE_STRING DomainName;
    UNICODE_STRING FlatName;
    GUID ObjectGuid;
    GUID Parent;
    GUID DomainGuid;
    PSID DomainSid;
    BOOLEAN ForestRoot;     // Object is at the root of the forest
    BOOLEAN TreeRoot;       // Object is at root of a tree
    BOOLEAN DomainGuidSet;
    BOOLEAN ParentTrust ;   // Object is a child of another object

} LSAPDS_FOREST_TRUST_BLOB, *PLSAPDS_FOREST_TRUST_BLOB;

#define LSAPDS_FOREST_MAX_SEARCH_ITEMS      100

//
// List of trusted domains
//
typedef struct _LSAP_DB_TRUSTED_DOMAIN_LIST {

    ULONG TrustedDomainCount;
    ULONG CurrentSequenceNumber;
    LIST_ENTRY ListHead;
    SAFE_RESOURCE Resource;

} LSAP_DB_TRUSTED_DOMAIN_LIST, *PLSAP_DB_TRUSTED_DOMAIN_LIST;

//
// Account List.  This list caches the Account Information for
// all Account Objects in the Policy database, and enables accounts
// to queried by Sid without recourse to teh Account objects themselves.
//

typedef struct _LSAP_DB_ACCOUNT {

    LIST_ENTRY Links;
    PLSAPR_SID Sid;
    LSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO Info;

} LSAP_DB_ACCOUNT, *PLSAP_DB_ACCOUNT;

typedef struct _LSAP_DB_ACCOUNT_LIST {

    LIST_ENTRY Links;
    ULONG AccountCount;

} LSAP_DB_ACCOUNT_LIST, *PLSAP_DB_ACCOUNT_LIST;

//
// Cached information for the Policy Object.
//

typedef struct _LSAP_DB_POLICY_ENTRY {

    ULONG AttributeLength;
    PLSAPR_POLICY_INFORMATION Attribute;

} LSAP_DB_POLICY_ENTRY, *PLSAP_DB_POLICY_ENTRY;

//
// Cached policy Object - Initially only Quota Limits is cached.
//

typedef struct _LSAP_DB_POLICY {

    LSAP_DB_POLICY_ENTRY Info[ PolicyDnsDomainInformationInt + 1];

} LSAP_DB_POLICY, *PLSAP_DB_POLICY;

extern LSAP_DB_POLICY LsapDbPolicy;

//
// Notification list
//
typedef struct _LSAP_POLICY_NOTIFICATION_ENTRY {

    LIST_ENTRY List;
    pfLsaPolicyChangeNotificationCallback NotificationCallback;
    HANDLE NotificationEvent;
    ULONG OwnerProcess;
    HANDLE OwnerEvent;
    BOOLEAN HandleInvalid;

} LSAP_POLICY_NOTIFICATION_ENTRY, *PLSAP_POLICY_NOTIFICATION_ENTRY;

typedef struct _LSAP_POLICY_NOTIFICATION_LIST {

    LIST_ENTRY List;
    ULONG Callbacks;

} LSAP_POLICY_NOTIFICATION_LIST, *PLSAP_POLICY_NOTIFICATION_LIST;

extern pfLsaTrustChangeNotificationCallback LsapKerberosTrustNotificationFunction;

//
// Types of secrets
//
#define LSAP_DB_SECRET_CLIENT           0x00000000
#define LSAP_DB_SECRET_LOCAL            0x00000001
#define LSAP_DB_SECRET_GLOBAL           0x00000002
#define LSAP_DB_SECRET_SYSTEM           0x00000004
#define LSAP_DB_SECRET_TRUSTED_DOMAIN   0x00000008

typedef struct _LSAP_DB_SECRET_TYPE_LOOKUP {

    PWSTR SecretPrefix;
    ULONG SecretType;

} LSAP_DB_SECRET_TYPE_LOOKUP, *PLSAP_DB_SECRET_TYPE_LOOKUP;

typedef struct _LSAP_DS_OBJECT_ACCESS_MAP {

    ULONG DesiredAccess;
    ULONG DsAccessRequired;
    USHORT Level;
    GUID *ObjectGuid;
} LSAP_DS_OBJECT_ACCESS_MAP, *PLSAP_DS_OBJECT_ACCESS_MAP;


#ifndef DBP_TYPES_ONLY

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

NTSTATUS
LsapDbQueryInformationPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN OUT PLSAPR_POLICY_INFORMATION *Buffer
    );

NTSTATUS
LsapDbSetInformationPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation
    );


NTSTATUS
LsapDbSlowQueryInformationPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN OUT PLSAPR_POLICY_INFORMATION *Buffer
    );

NTSTATUS
LsapDbQueryInformationPolicyEx(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    IN OUT PVOID *Buffer
    );

NTSTATUS
LsapDbSlowQueryInformationPolicyEx(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    IN OUT PVOID *Buffer
    );

NTSTATUS
LsapDbSetInformationPolicyEx(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    IN PVOID PolicyInformation
    );


NTSTATUS
LsapDbBuildPolicyCache(
    );

NTSTATUS
LsapDbBuildAccountCache(
    );

NTSTATUS
LsapDbBuildTrustedDomainCache(
    );

VOID
LsapDbPurgeTrustedDomainCache(
    );

NTSTATUS
LsapDbBuildSecretCache(
    );

NTSTATUS
LsapDbRebuildCache(
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId
    );

NTSTATUS
LsapDbCreateAccount(
    IN PLSAPR_SID AccountSid,
    OUT OPTIONAL PLSAP_DB_ACCOUNT *Account
    );

NTSTATUS
LsapDbDeleteAccount(
    IN PLSAPR_SID AccountSid
    );

NTSTATUS
LsapDbSlowEnumerateTrustedDomains(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    IN TRUSTED_INFORMATION_CLASS InfoClass,
    OUT PLSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength
    );

NTSTATUS
LsapDbLookupSidTrustedDomainList(
    IN PLSAPR_SID DomainSid,
    OUT PLSAPR_TRUST_INFORMATION *TrustInformation
    );

NTSTATUS
LsapDbLookupSidTrustedDomainListEx(
    IN PSID DomainSid,
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustedDomainListEntry
    );

NTSTATUS
LsapDbLookupNameTrustedDomainList(
    IN PLSAPR_UNICODE_STRING DomainName,
    OUT PLSAPR_TRUST_INFORMATION *TrustInformation
    );

NTSTATUS
LsapDbLookupNameTrustedDomainListEx(
    IN PLSAPR_UNICODE_STRING DomainName,
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustedDomainListEntry
    );

NTSTATUS
LsapDbLookupEntryTrustedDomainList(
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustedDomainEntry
    );

NTSTATUS
LsapDbTraverseTrustedDomainList(
    IN OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustedDomainEntry,
    OUT OPTIONAL PLSAPR_TRUST_INFORMATION *TrustInformation
    );

NTSTATUS
LsapDbLocateEntryNumberTrustedDomainList(
    IN ULONG EntryNumber,
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustedDomainEntry,
    OUT OPTIONAL PLSAPR_TRUST_INFORMATION *TrustInformation
    );

NTSTATUS
LsapDbEnumerateTrustedDomainList(
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG InfoLevel,
    IN BOOLEAN AllowNullSids
    );

NTSTATUS
LsapDbInitializeTrustedDomainListEntry(
    IN PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustListEntry,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 DomainInfo,
    IN ULONG PosixOffset
    );

NTSTATUS
LsapDbInsertTrustedDomainList(
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 DomainInfo,
    IN ULONG PosixOffset
    );

NTSTATUS
LsapDbFixupTrustedDomainListEntry(
    IN PSID TrustedDomainSid OPTIONAL,
    IN PLSAPR_UNICODE_STRING Name OPTIONAL,
    IN PLSAPR_UNICODE_STRING FlatName OPTIONAL,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 NewTrustInfo OPTIONAL,
    IN PULONG PosixOffset OPTIONAL
    );

NTSTATUS
LsapDbDeleteTrustedDomainList(
    IN PLSAPR_TRUST_INFORMATION TrustInformation
    );

extern LSAP_DB_TRUSTED_DOMAIN_LIST LsapDbTrustedDomainList;

#ifdef DBG
BOOLEAN
LsapDbIsValidTrustedDomainList(
    );
#else

#define LsapDbIsValidTrustedDomainList() \
         (( LsapDbIsCacheValid( TrustedDomainObject ) || \
          ( LsapDbIsCacheBuilding( TrustedDomainObject )) ? TRUE : FALSE ))

#endif

#define LsapDbIsLockedTrustedDomainList() \
         ( LsapDbResourceIsLocked( &LsapDbTrustedDomainList.Resource ))

#define LsapDbAcquireWriteLockTrustedDomainList() \
         ( SafeAcquireResourceExclusive( \
               &LsapDbTrustedDomainList.Resource, \
               TRUE ) ? \
           STATUS_SUCCESS : STATUS_UNSUCCESSFUL )

#define LsapDbAcquireReadLockTrustedDomainList() \
         ( SafeAcquireResourceShared( \
               &LsapDbTrustedDomainList.Resource, \
               TRUE ) ? \
           STATUS_SUCCESS : STATUS_UNSUCCESSFUL )

#define LsapDbReleaseLockTrustedDomainList() \
         ( SafeReleaseResource( &LsapDbTrustedDomainList.Resource ))

#define LsapDbConvertReadLockTrustedDomainListToExclusive() \
         ( SafeConvertSharedToExclusive( &LsapDbTrustedDomainList.Resource ))

#define LsapDbConvertWriteLockTrustedDomainListToShared() \
         ( SafeConvertExclusiveToShared( &LsapDbTrustedDomainList.Resource ))

NTSTATUS
LsapDbAllocatePosixOffsetTrustedDomainList(
    OUT PULONG PosixOffset
    );

//
// Return TRUE if a TDO with the passed in attributes should have a Posix Offset
//

#define LsapNeedPosixOffset( _TrustDirection, _TrustType ) \
    (( ((_TrustDirection) & TRUST_DIRECTION_OUTBOUND) != 0 ) && \
        ((_TrustType) == TRUST_TYPE_UPLEVEL || (_TrustType) == TRUST_TYPE_DOWNLEVEL ) )

//
// Return TRUE if TDO is to be replicated to NT 4.
//

#define LsapReplicateTdoNt4( _TrustDirection, _TrustType ) \
    LsapNeedPosixOffset( _TrustDirection, _TrustType )


NTSTATUS
LsapDbOpenPolicyTrustedDomain(
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE ControllerPolicyHandle,
    OUT LPWSTR * ServerName,
    OUT LPWSTR * ServerPrincipalName,
    OUT PVOID * ClientContext
    );

NTSTATUS
LsapDbInitHandleTables(
    VOID
    );

NTSTATUS
LsapDbInitializeWellKnownPrivs(
    );

NTSTATUS
LsapDbInitializeCipherKey(
    IN PUNICODE_STRING CipherSeed,
    IN PLSAP_CR_CIPHER_KEY *CipherKey
    );

NTSTATUS
LsapDbCreateHandle(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ULONG Options,
    IN ULONG CreateHandleOptions,
    OUT LSAPR_HANDLE *CreatedHandle
    );

BOOLEAN
LsapDbFindIdenticalHandleInTable(
    IN OUT PLSAPR_HANDLE OriginalHandle
    );

BOOLEAN LsapDbLookupHandle(
    IN LSAPR_HANDLE ObjectHandle
    );

NTSTATUS
LsapDbCloseHandle(
    IN LSAPR_HANDLE ObjectHandle
    );

BOOLEAN
LsapDbDereferenceHandle(
    IN LSAPR_HANDLE ObjectHandle
    );

NTSTATUS
LsapDbMarkDeletedObjectHandles(
    IN LSAPR_HANDLE ObjectHandle,
    IN BOOLEAN MarkSelf
    );

/*++

BOOLEAN
LsapDbIsTrustedHandle(
    IN LSAPR_HANDLE ObjectHandle
    )

Routine Description:

    This macro function checks if a given handle is Trusted and returns
    the result.

Arguments:

    ObjectHandle - Valid handle.  It is the caller's responsibility
       to verify that the given handle is valid.

Return Value:

    BOOLEAN - TRUE if handle is Trusted, else FALSE.

--*/

#define LsapDbIsTrustedHandle(ObjectHandle)                                   \
    (((LSAP_DB_HANDLE) ObjectHandle)->Trusted)

#define LsapDbSidFromHandle(ObjectHandle)                                     \
    ((PLSAPR_SID)(((LSAP_DB_HANDLE)(ObjectHandle))->Sid))

#define LsapDbObjectTypeIdFromHandle(ObjectHandle)                            \
    (((LSAP_DB_HANDLE)(ObjectHandle))->ObjectTypeId)

#define LsapDbRegKeyFromHandle(ObjectHandle)                                  \
    (((LSAP_DB_HANDLE)(ObjectHandle))->KeyHandle)

#define LsapDbContainerFromHandle(ObjectHandle)                               \
    (((LSAP_DB_HANDLE) ObjectHandle)->ContainerHandle)

#define LsapDbSetStatusFromSecondary( status, secondary )   \
if ( NT_SUCCESS( status ) ) {                               \
                                                            \
    status = secondary;                                     \
}

NTSTATUS
LsapDbRequestAccessObject(
    IN OUT LSAPR_HANDLE ObjectHandle,
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Options
    );

NTSTATUS
LsapDbRequestAccessNewObject(
    IN OUT LSAPR_HANDLE ObjectHandle,
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Options
    );

NTSTATUS
LsapDbInitializeObjectTypes();

NTSTATUS
LsapDbInitializeUnicodeNames();

NTSTATUS
LsapDbInitializeObjectLinkList();

NTSTATUS
LsapDbInitializeContainingDirs();

NTSTATUS
LsapDbInitializeDefaultQuotaLimits();

NTSTATUS
LsapDbInitializeReplication();

NTSTATUS
LsapDbInitializeObjectTypes();

NTSTATUS
LsapDbInitializePrivilegeObject();

NTSTATUS
LsapDbInitializeLock();

NTSTATUS
LsapDbOpenRootRegistryKey();

NTSTATUS
LsapDbInstallLsaDatabase(
    IN ULONG Pass
    );

NTSTATUS
LsapDbInstallPolicyObject(
    IN ULONG Pass
    );

NTSTATUS
LsapDbInstallAccountObjects(
    VOID
    );

NTSTATUS
LsapDbBuildObjectCaches(
    );

NTSTATUS
LsapDbNotifyChangeObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN SECURITY_DB_DELTA_TYPE SecurityDbDeltaType
    );

NTSTATUS
LsapDbLogicalToPhysicalNameU(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    OUT PUNICODE_STRING PhysicalNameU
    );

NTSTATUS
LsapDbLogicalToPhysicalSubKey(
    IN LSAPR_HANDLE ObjectHandle,
    OUT PUNICODE_STRING PhysicalSubKeyNameU,
    IN PUNICODE_STRING LogicalSubKeyNameU
    );

NTSTATUS
LsapDbJoinSubPaths(
    IN PUNICODE_STRING MajorSubPath,
    IN PUNICODE_STRING MinorSubPath,
    OUT PUNICODE_STRING JoinedPath
    );

VOID
LsapDbFreePhysicalSubKeyObject(
    IN PUNICODE_STRING PhysicalSubKeyNameU
    );

NTSTATUS
LsapDbGetNamesObject(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ULONG CreateHandleOptions,
    OUT OPTIONAL PUNICODE_STRING LogicalNameU,
    OUT OPTIONAL PUNICODE_STRING PhysicalNameU,
    OUT OPTIONAL PUNICODE_STRING PhysicalNameDs
    );

NTSTATUS
LsapDbCheckCountObject(
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId
    );

#define LsapDbIncrementCountObject(ObjectTypeId)                     \
    {                                                                \
        LsapDbState.DbObjectTypes[ObjectTypeId].ObjectCount++;       \
    }

#define LsapDbDecrementCountObject(ObjectTypeId)                     \
    {                                                                \
        LsapDbState.DbObjectTypes[ObjectTypeId].ObjectCount--;       \
    }

NTSTATUS
LsapDbCreateSDObject(
    IN LSAPR_HANDLE ContainerHandle,
    IN LSAPR_HANDLE ObjectHandle,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor
    );

NTSTATUS
LsapDbCreateSDAttributeObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation
    );


/*++

Routine Description:

    This macro function determines if a given Object Type Id requires
    a Sid to be specified in ObjectInformation describing it.

Arguments:

    ObjectTypeId - Object Type Id which must be valid.

Return Values:

    BOOLEAN - TRUE if objects of the given type require a Sid, else FALSE.

#define LsapDbRequiresSidObject(ObjectTypeId)                            \
            (LsapDbRequiresSidInfo[ObjectTypeId])
--*/

/*++

Routine Description:

    This macro function determines if a given Object Type Id requires
    a name to be specified in ObjectInformation describing it.

Arguments:

    ObjectTypeId - Object Type Id which must be valid.

Return Values:

    BOOLEAN - TRUE if objects of the given type require a name, else FALSE.

#define LsapDbRequiresNameObject(ObjectTypeId)                            \
            (LsapDbRequiresNameInfo[ObjectTypeId])
--*/

NTSTATUS
LsapDbSetSidNameValue(
    IN ULONG SidIndex,
    IN PANSI_STRING AnsiName,
    IN PANSI_STRING AnsiDomainName,
    OUT PUNICODE_STRING Name,
    OUT OPTIONAL PUNICODE_STRING DomainName
    );

NTSTATUS
LsapDbQueryValueSecret(
    IN LSAPR_HANDLE SecretHandle,
    IN LSAP_DB_NAMES ValueIndex,
    IN OPTIONAL PLSAP_CR_CIPHER_KEY SessionKey,
    OUT PLSAP_CR_CIPHER_VALUE *CipherValue
    );

NTSTATUS
LsapDbGetScopeSecret(
    IN PLSAPR_UNICODE_STRING SecretName,
    OUT PBOOLEAN GlobalSecret
    );

VOID
LsapDbResetStatesError(
    IN LSAPR_HANDLE ObjectHandle,
    IN NTSTATUS PreliminaryStatus,
    IN ULONG DesiredStatesReset,
    IN SECURITY_DB_DELTA_TYPE SecurityDbDeltaType,
    IN ULONG StatesResetAttempted
    );

VOID
LsapDbMakeInvalidInformationPolicy(
    IN ULONG InformationClass
    );

NTSTATUS
LsapDbObjectNameFromHandle(
    IN LSAPR_HANDLE ObjectHandle,
    IN BOOLEAN MakeCopy,
    IN LSAP_DB_OBJECT_NAME_TYPE ObjectNameType,
    OUT PLSAPR_UNICODE_STRING ObjectName
    );

NTSTATUS
LsapDbPhysicalNameFromHandle(
    IN LSAPR_HANDLE ObjectHandle,
    IN BOOLEAN MakeCopy,
    OUT PLSAPR_UNICODE_STRING ObjectName
    );

NTSTATUS
LsapEnumerateTrustedDomainsEx(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    IN TRUSTED_INFORMATION_CLASS InfoClass,
    OUT PLSAPR_TRUSTED_DOMAIN_INFO *TrustedDomainInformation,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned,
    IN ULONG EnumerationFlags
    );

VOID
LsapFreeTrustedDomainsEx(
    IN TRUSTED_INFORMATION_CLASS InfoClass,
    IN PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation,
    IN ULONG TrustedDomainCount
    );

NTSTATUS
LsapNotifyNetlogonOfTrustChange(
    IN  PSID pChangeSid,
    IN  SECURITY_DB_DELTA_TYPE ChangeType
    );

BOOLEAN
LsapDbSecretIsMachineAcc(
    IN LSAPR_HANDLE SecretHandle
    );



PLSADS_PER_THREAD_INFO
LsapCreateThreadInfo(
    VOID
    );



VOID
LsapClearThreadInfo(
    VOID
    );

VOID
LsapSaveDsThreadState(
    VOID
    );

VOID
LsapRestoreDsThreadState(
    VOID
    );

extern LSADS_INIT_STATE LsaDsInitState ;

ULONG
LsapDbGetSecretType(
    IN PLSAPR_UNICODE_STRING SecretName
    );

NTSTATUS
LsapDbUpgradeSecretForKeyChange(
    VOID
    );


NTSTATUS
LsapDbUpgradeRevision(
    IN BOOLEAN  SyskeyUpgrade,
    IN BOOLEAN  GenerateNewSyskey
    );

VOID
LsapDbEnableReplicatorNotification();

VOID
LsapDbDisableReplicatorNotification();

BOOLEAN
LsapDbDcInRootDomain();

BOOLEAN
LsapDbNoMoreWin2K();

//
// Routines related to Syskey'ing of the LSA Database
//

NTSTATUS
LsapDbGenerateNewKey(
    IN LSAP_DB_ENCRYPTION_KEY * NewEncryptionKey
    );

VOID
LsapDbEncryptKeyWithSyskey(
    OUT LSAP_DB_ENCRYPTION_KEY * KeyToEncrypt,
    IN PVOID                    Syskey,
    IN ULONG                    SyskeyLength
    );

NTSTATUS
LsapDbDecryptKeyWithSyskey(
    IN LSAP_DB_ENCRYPTION_KEY * KeyToDecrypt,
    IN PVOID                    Syskey,
    IN ULONG                    SyskeyLength
    );

NTSTATUS
LsapDbSetupInitialSyskey(
    OUT PULONG  SyskeyLength,
    OUT PVOID   *Syskey
    );

VOID
LsapDbSetSyskey(PVOID Syskey, ULONG SyskeyLength);

NTSTATUS
LsapDbGetSyskeyFromWinlogon();

NTSTATUS
LsapForestTrustFindMatch(
    IN LSA_ROUTING_MATCH_TYPE Type,
    IN PVOID Data,
    OUT PLSA_UNICODE_STRING Match,
    OUT OPTIONAL BOOLEAN * IsLocal
    );

NTSTATUS
LsapDeleteObject(
    IN OUT LSAPR_HANDLE *ObjectHandle,
    IN BOOL LockSce
    );

NTSTATUS
LsapSetSystemAccessAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ULONG SystemAccess,
    IN BOOL LockSce
    );

NTSTATUS
LsapAddPrivilegesToAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN PLSAPR_PRIVILEGE_SET Privileges,
    IN BOOL LockSce
    );

NTSTATUS
LsapRemovePrivilegesFromAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN BOOLEAN AllPrivileges,
    IN OPTIONAL PLSAPR_PRIVILEGE_SET Privileges,
    IN BOOL LockSce
    );

NTSTATUS
LsapSidOnFtInfo(
    IN PUNICODE_STRING TrustedDomainName,
    IN PSID Sid
    );

BOOLEAN
LsapIsRunningOnPersonal(
    VOID
    );

NTSTATUS
LsapNotifyNetlogonOfTrustWithParent(
    VOID
    );

//
// Commenting out the following #define will remove the backdoor
// through which cross-forest can be enabled before
// behavior-version requirements are satisfied
//

#define XFOREST_CIRCUMVENT

#ifdef XFOREST_CIRCUMVENT

NTSTATUS
LsapDbLookupEnableXForestSwitch(
    OUT BOOLEAN * Result
    );

#endif // XFOREST_CIRCUMVENT

VOID
LsapDbInitializeSecretCipherKeyRead(
       PLSAP_DB_ENCRYPTION_KEY PassedInEncryptionKeyData
       );

VOID
LsapDbInitializeSecretCipherKeyWrite(
       PLSAP_DB_ENCRYPTION_KEY PassedInEncryptionKeyData
       );

#ifdef __cplusplus
}
#endif // __cplusplus

#endif
#endif //_LSADBP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbnotify.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dbnotify.c

Abstract:

    Implemntation of the LSA routines for notifying in processes callers when data changes

Author:

    Mac McLain          (MacM)       May 22, 1997

Environment:

    User Mode

Revision History:

--*/
#include <lsapch2.h>
#include <dbp.h>

//
// Global notification list
//
LSAP_POLICY_NOTIFICATION_LIST LsaPolicyChangeNotificationList[ PolicyNotifyMachineAccountPasswordInformation + 1 ];
SAFE_RESOURCE LsaPolicyChangeNotificationLock;

#define LSAP_NOTIFY_MAXIMUM_PER_CLASS   1000

//
// Local prototypes
//
DWORD
WINAPI LsapNotifyChangeNotificationThread(
    LPVOID Parameter
    );


NTSTATUS
LsapInitializeNotifiyList(
    VOID
    )
/*++

Routine Description:

    Intializes the list of policy notification lists


Arguments:

    VOID


Return Value:

    VOID

--*/
{
    ULONG i;
    NTSTATUS Status ;

    for ( i = 0;
          i < sizeof( LsaPolicyChangeNotificationList ) / sizeof( LSAP_POLICY_NOTIFICATION_LIST );
          i++ ) {

        InitializeListHead( &( LsaPolicyChangeNotificationList[ i ].List ) );
        LsaPolicyChangeNotificationList[ i ].Callbacks = 0;
    }

    try 
    {
        SafeInitializeResource( &LsaPolicyChangeNotificationLock, ( DWORD )POLICY_CHANGE_NOTIFICATION_LOCK_ENUM );
        Status = STATUS_SUCCESS ;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }

    return Status ;
}



NTSTATUS
LsapNotifyAddCallbackToList(
    IN PLSAP_POLICY_NOTIFICATION_LIST List,
    IN pfLsaPolicyChangeNotificationCallback Callback, OPTIONAL
    IN HANDLE NotificationEvent, OPTIONAL
    IN ULONG OwnerProcess, OPTIONAL
    IN HANDLE OwnerEvent OPTIONAL
    )
/*++

Routine Description:

    This function inserts a new callback node into the existing list.

    It is assumed that the list is locked at this point in time

Arguments:

    List -- Existing list

    Callback -- Callback function pointer.  Can be NULL if NotificationEvent is provided

    NotificationEvent - Handle to an event to be signalled for notification.  Can be NULL if
        Callback is provided.


Return Value:

    STATUS_SUCCESS -- Success

    STATUS_INSUFFICIENT_RESOURCES -- A memory allocation failed.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_POLICY_NOTIFICATION_ENTRY NewEntry = NULL;



    if ( !SafeAcquireResourceExclusive( &LsaPolicyChangeNotificationLock, TRUE ) ) {

        return( STATUS_UNSUCCESSFUL );
    }

    NewEntry = LsapAllocateLsaHeap( sizeof( LSAP_POLICY_NOTIFICATION_ENTRY ) );

    if ( !NewEntry ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        if ( List->Callbacks < LSAP_NOTIFY_MAXIMUM_PER_CLASS ) {

            InsertTailList( &List->List, &NewEntry->List );

            NewEntry->NotificationCallback = Callback;
            NewEntry->NotificationEvent = NotificationEvent;
            NewEntry->HandleInvalid = FALSE;
            NewEntry->OwnerProcess = OwnerProcess;
            NewEntry->OwnerEvent = OwnerEvent;

            List->Callbacks++;

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            LsapFreeLsaHeap( NewEntry );
        }

    }

    SafeReleaseResource( &LsaPolicyChangeNotificationLock );

    return( Status );
}


NTSTATUS
LsapNotifyRemoveCallbackFromList(
    IN PLSAP_POLICY_NOTIFICATION_LIST List,
    IN pfLsaPolicyChangeNotificationCallback Callback, OPTIONAL
    IN HANDLE NotificationEvent, OPTIONAL
    IN ULONG OwnerProcess, OPTIONAL
    IN HANDLE OwnerEvent OPTIONAL
    )
/*++

Routine Description:

    This function inserts a new callback node into the existing list.

    It is assumed that the list is locked at this point in time

Arguments:

    List -- Existing list

    Callback -- Callback function pointer.  Can be NULL if a notification event is provided

    NotificationEvent -- Notification event handle to be revomed.  Can be NULL if a callback
        is provided


Return Value:

    STATUS_SUCCESS -- Success

    STATUS_NOT_FOUND -- The supplied callback was not found in the specified list

--*/
{
    NTSTATUS Status = STATUS_NOT_FOUND;
    ULONG i;
    PLSAP_POLICY_NOTIFICATION_ENTRY Entry =
                (PLSAP_POLICY_NOTIFICATION_ENTRY)List->List.Flink;

    if ( !SafeAcquireResourceExclusive( &LsaPolicyChangeNotificationLock, TRUE ) ) {

        return( STATUS_UNSUCCESSFUL );
    }

    for ( i = 0; i < List->Callbacks; i++ ) {

        if ( Entry->NotificationCallback == Callback &&
             Entry->OwnerProcess == OwnerProcess &&
             Entry->OwnerEvent == OwnerEvent ) {

            List->Callbacks--;
            RemoveEntryList( &Entry->List );
            LsapFreeLsaHeap( Entry );
            Status = STATUS_SUCCESS;
            break;
        }

        Entry = (PLSAP_POLICY_NOTIFICATION_ENTRY)Entry->List.Flink;
    }

    SafeReleaseResource( &LsaPolicyChangeNotificationLock );

    return( Status );
}


NTSTATUS
LsaINotifyChangeNotification(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InfoClass
    )
/*++

Routine Description:

    This function processes a notification list by making the appropriate
    callback calls when a policy object has changed

Arguments:

    InfoClass -- Policy information that has changed


Return Value:

    STATUS_SUCCESS -- Success

    STATUS_UNSUCCESSFUL -- Failed to lock the list for access

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT( InfoClass  <=
            sizeof( LsaPolicyChangeNotificationList ) / sizeof( LSAP_POLICY_NOTIFICATION_LIST ) );

    if ( LsaIRegisterNotification( LsapNotifyChangeNotificationThread,
                                   ( PVOID ) InfoClass,
                                   NOTIFIER_TYPE_IMMEDIATE,
                                   0,
                                   NOTIFIER_FLAG_ONE_SHOT,
                                   0,
                                   0 ) == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return( Status );
}



DWORD
WINAPI
LsapNotifyChangeNotificationThread(
    LPVOID Parameter
    )
/*++

Routine Description:

    This function processes a notification list by making the appropriate
    callback calls when a policy object has changed

Arguments:

    Parameter -- Policy information that has changed


Return Value:

    STATUS_SUCCESS -- Success

    STATUS_UNSUCCESSFUL -- Failed to lock the list for access

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    ULONG i;
    POLICY_NOTIFICATION_INFORMATION_CLASS InfoClass =
                                            ( POLICY_NOTIFICATION_INFORMATION_CLASS ) ( ( ULONG_PTR ) Parameter );
    PLSAP_POLICY_NOTIFICATION_ENTRY Entry =
        (PLSAP_POLICY_NOTIFICATION_ENTRY)LsaPolicyChangeNotificationList[ InfoClass ].List.Flink;

    ASSERT( InfoClass <=
            sizeof( LsaPolicyChangeNotificationList ) / sizeof( LSAP_POLICY_NOTIFICATION_LIST ) );

    if ( !SafeAcquireResourceShared( &LsaPolicyChangeNotificationLock, TRUE ) ) {

        Status = STATUS_UNSUCCESSFUL;

    } else {

        for ( i = 0; i < LsaPolicyChangeNotificationList[ InfoClass ].Callbacks; i++ ) {

            ASSERT( Entry->NotificationCallback || Entry->NotificationEvent );

            if ( Entry->NotificationCallback ) {

                (*Entry->NotificationCallback)( InfoClass );

            } else if ( Entry->NotificationEvent ) {

                if ( !Entry->HandleInvalid ) {

                    Status = NtSetEvent( Entry->NotificationEvent, NULL );

                    if ( Status == STATUS_INVALID_HANDLE ) {

                        Entry->HandleInvalid = TRUE;
                    }

                }

            } else {

                LsapDsDebugOut(( DEB_ERROR,
                                 "NULL callback found for info level %lu\n",
                                 InfoClass ));
            }

            Entry = (PLSAP_POLICY_NOTIFICATION_ENTRY)Entry->List.Flink;
        }

        SafeReleaseResource( &LsaPolicyChangeNotificationLock );
    }

    return( Status );

}




NTSTATUS
LsaIRegisterPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    )
/*++

Routine Description:

    This function registers a callback with the Lsa server such that a change to the
    specified policy items results in the callback being called.  These callbacks are
    informational only, such that a client must return instantly, not doing an Lsa
    calls in their callback.

    Multiple callbacks can be specified for the same policy information.

Arguments:

    Callback -- Callback function pointer.

    MonitorInfoClass -- Policy information to watch for


Return Value:

    STATUS_SUCCESS -- Success

    STATUS_INVALID_PARAMETER -- A bad callback pointer was specified

    STATUS_UNSUCCESSFUL -- Failed to lock the list for access

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if ( !Callback ) {

        Status = STATUS_INVALID_PARAMETER;

    } else  {


        if ( !SafeAcquireResourceExclusive( &LsaPolicyChangeNotificationLock, TRUE ) ) {

            Status = STATUS_UNSUCCESSFUL;

        } else {

            ASSERT( MonitorInfoClass <=
                    sizeof( LsaPolicyChangeNotificationList ) /
                                                    sizeof( LSAP_POLICY_NOTIFICATION_LIST ) );

            Status = LsapNotifyAddCallbackToList(
                         &LsaPolicyChangeNotificationList[ MonitorInfoClass ],
                         Callback,
                         NULL, 0, NULL );

            LsapDsDebugOut(( DEB_NOTIFY,
                             "Insertion of callback 0x%lx for %lu returned 0x%lx\n",
                             Callback,
                             MonitorInfoClass,
                             Status ));

            SafeReleaseResource( &LsaPolicyChangeNotificationLock );
        }

    }
    return( Status );
}




NTSTATUS
LsaIUnregisterPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    )
/*++

Routine Description:

    This function unregisters a callback from the Lsa server such that a change to the
    specified policy items do not result in a call to the client callback function.

Arguments:

    Callback -- Callback function pointer to remove.

    MonitorInfoClass -- Policy information to remove the callback for


Return Value:

    STATUS_SUCCESS -- Success

    STATUS_INVALID_PARAMETER -- A bad callback pointer was specified

    STATUS_UNSUCCESSFUL -- Failed to lock the list for access

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if ( !Callback ) {

        Status =  STATUS_INVALID_PARAMETER;

    } else {

        if ( !SafeAcquireResourceExclusive( &LsaPolicyChangeNotificationLock, TRUE ) ) {

            Status = STATUS_UNSUCCESSFUL;

        } else {

            Status = LsapNotifyRemoveCallbackFromList(
                         &LsaPolicyChangeNotificationList[ MonitorInfoClass ],
                         Callback,
                         NULL, 0, NULL );

            LsapDsDebugOut(( DEB_NOTIFY,
                             "Removal of callback 0x%lx for %lu returned 0x%lx\n",
                             Callback,
                             MonitorInfoClass,
                             Status ));

            SafeReleaseResource( &LsaPolicyChangeNotificationLock );
        }

    }

    return( Status );
}



NTSTATUS
LsaIUnregisterAllPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback
    )
/*++

Routine Description:

    This function unregisters the specified callback function from all associated policy.
    This function is the equivalent of calling LsaIUnregisterPolicyChangeNotificationCallback
    for each InfoClass that was being watched.

Arguments:

    Callback -- Callback function pointer to remove.

Return Value:

    STATUS_SUCCESS -- Success

    STATUS_INVALID_PARAMETER -- A bad callback pointer was specified

    STATUS_UNSUCCESSFUL -- Failed to lock the list for access

    STATUS_NOT_FOUND -- No matching entries were found

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i, Removed = 0;

    if ( !Callback ) {

        Status =  STATUS_INVALID_PARAMETER;

    } else {

        if ( !SafeAcquireResourceExclusive( &LsaPolicyChangeNotificationLock, TRUE ) ) {

            Status = STATUS_UNSUCCESSFUL;

        } else {

            Removed = 0;

            for ( i = 0;
                  i < sizeof( LsaPolicyChangeNotificationList ) /
                                sizeof( LSAP_POLICY_NOTIFICATION_LIST ) && NT_SUCCESS( Status );
                  i++ ) {

                Status = LsapNotifyRemoveCallbackFromList(
                             &LsaPolicyChangeNotificationList[ i ],
                             Callback,
                             NULL, 0, NULL );

                LsapDsDebugOut(( DEB_NOTIFY,
                                 "Removal of callback 0x%lx for %lu returned 0x%lx\n",
                                 Callback,
                                 i,
                                 Status ));

                if ( Status == STATUS_NOT_FOUND ) {

                    Status = STATUS_SUCCESS;

                } else if ( Status == STATUS_SUCCESS ) {

                    Removed++;
                }
            }

            SafeReleaseResource( &LsaPolicyChangeNotificationLock );
        }

    }


    //
    // Make sure we removed at least one
    //
    if ( NT_SUCCESS( Status ) ) {

        if ( Removed == 0 ) {

            Status = STATUS_NOT_FOUND;
        }
    }

    return( Status );
}


NTSTATUS
LsapNotifyProcessNotificationEvent(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    IN HANDLE EventHandle,
    IN ULONG OwnerProcess,
    IN HANDLE OwnerEventHandle,
    IN BOOLEAN Register
    )
/*++

Routine Description:

    This function registers / unregisters the specified Notification event handle for the
    specified information class

Arguments:

    InformationClass -- Information class to add/remove the notification for

    EventHandle -- Event handle to register/deregister

    Register -- If TRUE, the event is being registered.  If FALSE, it is unregistered

Return Value:

    STATUS_SUCCESS -- Success

    STATUS_INVALID_HANDLE -- A bad event handle was specified

    STATUS_ACCESS_DENIED -- The opened policy handle does not have the requried permissions

    STATUS_INSUFFICIENT_RESOURCES -- A memory allocation failed

    STATUS_INVALID_INFO_CLASS -- An invalid information class was provided.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    POBJECT_TYPE_INFORMATION ObjTypeInfo = NULL;
    ULONG Length = 0, ReturnLength = 0;
    UNICODE_STRING EventString;
    LSAPR_HANDLE PolicyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;


    //
    // Make sure we are given a valid info class
    //
    if ( InformationClass < PolicyNotifyAuditEventsInformation ||
         InformationClass > PolicyNotifyMachineAccountPasswordInformation ) {

         return( STATUS_INVALID_INFO_CLASS );
    }

    //
    // Make sure the caller has the proper privileges.
    //
    // We're already impersonating our caller so LsapDbOpenPolicy doesn't need to.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL );

    Status = LsapDbOpenPolicy(
                    NULL,
                    (PLSAPR_OBJECT_ATTRIBUTES) &ObjectAttributes,
                    POLICY_NOTIFICATION,
                    LSAP_DB_USE_LPC_IMPERSONATE,
                    &PolicyHandle,
                    FALSE );    // Not a trusted client

    if ( NT_SUCCESS( Status ) ) {

        //
        // Verify that the handle is one for an Event
        //
        Status = NtQueryObject( EventHandle,
                                ObjectTypeInformation,
                                ObjTypeInfo,
                                Length,
                                &ReturnLength );

        if ( Status == STATUS_INFO_LENGTH_MISMATCH ) {

            ObjTypeInfo = LsapAllocateLsaHeap( ReturnLength );

            if ( ObjTypeInfo == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                Length = ReturnLength;
                Status = NtQueryObject( EventHandle,
                                        ObjectTypeInformation,
                                        ObjTypeInfo,
                                        Length,
                                        &ReturnLength );

                if ( NT_SUCCESS( Status ) ) {

                    //
                    // See if it's actually an event
                    //
                    RtlInitUnicodeString( &EventString, L"Event" );
                    if ( !RtlEqualUnicodeString( &EventString, &ObjTypeInfo->TypeName, FALSE ) ) {

                        Status = STATUS_INVALID_HANDLE;
                    }

                }

                LsapFreeLsaHeap( ObjTypeInfo );
            }

        } else if ( Status == STATUS_SUCCESS ) {

            LsapDsDebugOut(( DEB_ERROR, "NtQueryObject returned success on a NULL buffer\n" ));
            Status = STATUS_UNSUCCESSFUL;
        }

        //
        // Now, add or remove the information from the list
        //
        if ( NT_SUCCESS( Status ) ) {

            if ( Register ) {

                Status = LsapNotifyAddCallbackToList(
                             &LsaPolicyChangeNotificationList[ InformationClass ],
                             NULL,
                             EventHandle,
                             OwnerProcess,
                             OwnerEventHandle );

            } else {

                Status = LsapNotifyRemoveCallbackFromList(
                             &LsaPolicyChangeNotificationList[ InformationClass ],
                             NULL,
                             EventHandle,
                             OwnerProcess,
                             OwnerEventHandle );

            }
        }
    }

    if ( PolicyHandle != NULL ) {
        LsapCloseHandle( &PolicyHandle, Status );
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbluutil.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dblookup.c

Abstract:

    LSA Database - Lookup Sid and Name routines

    NOTE:  This module should remain as portable code that is independent
           of the implementation of the LSA Database.  As such, it is
           permitted to use only the exported LSA Database interfaces
           contained in db.h and NOT the private implementation
           dependent functions in dbp.h.
           
Author:

    Scott Birrell       (ScottBi)      November 27, 1992

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"
#include <sidcache.h>
#include <bndcache.h>
#include <alloca.h>

#include <ntdsa.h>
#include <ntdsapi.h>
#include <ntdsapip.h>
#include "lsawmi.h"
#include <sddl.h>

#include <lmapibuf.h>
#include <dsgetdc.h>

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Lsa Lookup Sid and Name Private Global State Variables               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

LARGE_INTEGER LsapDbLookupTimeout;
HANDLE LsapDbLookupStartedEvent = NULL;

//
// This global is set to TRUE when a particular registry key is set
// (see the lookup init routine).  It means that when a 
// downlevel client is making a request return the current features of
// lookup (search by UPN, transitive trust, etc) all of which are
// performed by doing a GC search.  By default this feature is 
// turned off.
//
BOOLEAN LsapAllowExtendedDownlevelLookup = FALSE;


//
// This variable, settable in the registry, indicates what events
// should be logged.
//
DWORD LsapLookupLogLevel = 0;

//
// This global makes LsarLookupSids return SidTypeDeleted for SID's that
// otherwise would be returned as SidTypeUnknown. This is to prevent NT4
// wksta's from AV'ing.  See WinSERaid bug 11298 for more details.
//
BOOLEAN LsapReturnSidTypeDeleted = FALSE;


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Forwards for this module                                             //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

NTSTATUS
LsapRtlValidateControllerTrustedDomainByHandle(
    IN LSA_HANDLE DcPolicyHandle,
    IN PLSAPR_TRUST_INFORMATION TrustInformation
    );

NTSTATUS
LsapDbLookupInitPolicyCache(
    VOID
    );

#define LSAP_LOOKUP_CONNECTION_GET_HANDLE 0x00000001

NTSTATUS
LsapDbLookupGetServerConnection(
    IN  LSAPR_TRUST_INFORMATION_EX *TrustInfo,
    IN  DWORD             Flags,
    IN  LSAP_LOOKUP_LEVEL LookupLevel,
    OUT LPWSTR        *ServerName,
    OUT NL_OS_VERSION *ServerOsVersion,
    OUT LPWSTR        *ServerPrincipalName,
    OUT PVOID         *ClientContext,
    OUT ULONG         *AuthnLevel,
    OUT LSA_HANDLE    *PolicyHandle,
    OUT PLSAP_BINDING_CACHE_ENTRY * ControllerPolicyEntry
    );

//
// Flags for LsapDomainHasDomainTrust
//

//
// Lookup domains that we trust that are external to our forest
//
#define LSAP_LOOKUP_DOMAIN_TRUST_DIRECT_EXTERNAL   0x00000001

//
// Lookup domains that are within our forest and that we directly trust
//
#define LSAP_LOOKUP_DOMAIN_TRUST_DIRECT_INTRA      0x00000002

//
// Lookup forest trusts
//
#define LSAP_LOOKUP_DOMAIN_TRUST_FOREST            0x00000004

NTSTATUS
LsapDomainHasDomainTrust(
    IN ULONG           Flags,
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    IN OUT  BOOLEAN   *fTDLLock,   OPTIONAL
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustEntryOut OPTIONAL
    );

VOID
LsapLookupSamAccountNameToUPN(
    IN OUT PUNICODE_STRING Name
    );

VOID
LsapLookupUPNToSamAccountName(
    IN OUT PUNICODE_STRING Name
    );
                             
BOOL
LsapLookupIsUPN(
    OUT PUNICODE_STRING Name
    );

VOID
LsapLookupCrackName(
    IN PUNICODE_STRING Prefix,
    IN PUNICODE_STRING Suffix,
    OUT PUNICODE_STRING SamAccountName,
    OUT PUNICODE_STRING DomainName
    );

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Lsa Lookup Helper routines                                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

ULONG
LsapLookupGetChainingFlags(
    IN NL_OS_VERSION ServerOsVersion
    )
/*++

Routine Description:

    Based on the OsVersion, this routine determines what flags to 
    pass into LsaIC* to help route the version of the Lsar* routine
    to call.

Arguments:

    OsVersion -- the version of the secure channel DC
    
Return Values:

--*/
{
    ULONG Flags = 0;

    if ( ServerOsVersion == NlWin2000 ) {
        Flags |= LSAIC_WIN2K_TARGET;
    } else if (ServerOsVersion <= NlNt40) {
        Flags |= LSAIC_NT4_TARGET;
    }

    return Flags;

}


NTSTATUS
LsapDbLookupAddListReferencedDomains(
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    OUT PLONG DomainIndex
    )

/*++

Routine Description:

    This function searches a Referenced Domain List for an entry for a
    given domain and, if no entry exists, adds new entry.  If an entry
    id added, its index into the Referenced Domain List is returned,
    otherwise the index of the existing entry is returned.  If an entry
    needs to be added and there is insufficient room in the list provided
    for the new entry, the list will be created or grown as necessary.

Arguments:

    ReferencedDomains - Pointer to a structure in which the list of domains
        used in the translation is maintained.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for each
        translated name, this structure will only contain one component for
        each domain utilized in the translation.

    TrustInformation - Points to Trust Information for the domain being
        added to the list.  On exit, the DomainIndex parameter will be set to the
        index of the entry on the Referenced Domain List; a negative
        value will be stored in the error case.

    DomainIndex - Pointer to location that receives the index of the
        newly added or existing entry for the domain within the
        Referenced Domain List.  In the error case, a negative value
        is returned.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status;
    ULONG NextIndex;
    LSAPR_TRUST_INFORMATION OutputTrustInformation;

    OutputTrustInformation.Name.Buffer = NULL;
    OutputTrustInformation.Sid = NULL;

    Status = STATUS_INVALID_PARAMETER;

    if (ReferencedDomains == NULL) {

        goto AddListReferencedDomainsError;
    }

    Status = STATUS_SUCCESS;

    //
    // Search the existing list, trying to match the Domain Sid in the
    // provided Trust Information with the Domain Sid in a Referenced Domain
    // List entry.  If an entry is found with matching Sid, just return
    // that entry's index.
    //

    if (LsapDbLookupListReferencedDomains(
            ReferencedDomains,
            TrustInformation->Sid,
            DomainIndex
            )) {

        goto AddListReferencedDomainsFinish;
    }

    //
    // Check that there is enough room in the List provided for one more
    // entry.  If not, grow the list, copying and freeing the old.
    //

    Status = STATUS_SUCCESS;

    if (ReferencedDomains->Entries >= ReferencedDomains->MaxEntries) {

        Status = LsapDbLookupGrowListReferencedDomains(
                     ReferencedDomains,
                     ReferencedDomains->MaxEntries +
                     LSAP_DB_REF_DOMAIN_DELTA
                     );

        if (!NT_SUCCESS(Status)) {

            goto AddListReferencedDomainsError;
        }
    }

    //
    // We now have a Referenced Domain List with room for at least one more
    // entry.  Copy in the Trust Information.
    //

    NextIndex = ReferencedDomains->Entries;


    Status = LsapRpcCopyUnicodeString(
                 NULL,
                 (PUNICODE_STRING) &OutputTrustInformation.Name,
                 (PUNICODE_STRING) &TrustInformation->Name
                 );

    if (!NT_SUCCESS(Status)) {

        goto AddListReferencedDomainsError;
    }

    if ( TrustInformation->Sid ) {

        Status = LsapRpcCopySid(
                     NULL,
                     (PSID) &OutputTrustInformation.Sid,
                     (PSID) TrustInformation->Sid
                     );

        if (!NT_SUCCESS(Status)) {

            goto AddListReferencedDomainsError;
        }
    }

    ReferencedDomains->Domains[NextIndex] = OutputTrustInformation;
    *DomainIndex = (LONG) NextIndex;
    ReferencedDomains->Entries++;

AddListReferencedDomainsFinish:

    return(Status);

AddListReferencedDomainsError:

    //
    // Cleanup buffers allocated for Output Trust Information structure.
    //

    if (OutputTrustInformation.Name.Buffer != NULL) {

        MIDL_user_free( OutputTrustInformation.Name.Buffer );
    }

    if (OutputTrustInformation.Sid != NULL) {

        MIDL_user_free( OutputTrustInformation.Sid );
    }

    goto AddListReferencedDomainsFinish;
}


NTSTATUS
LsapDbLookupCreateListReferencedDomains(
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN ULONG InitialMaxEntries
    )

/*++

Routine Description:

    This function creates an empty Referenced Domain List.  The caller
    is responsible for cleaning up this list when no longer required.

Arguments:

    ReferencedDomains - Receives a pointer to the newly created empty
        Referenced Domain List.

    InitialMaxEntries - Initial maximum number of entries desired.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient System Resources
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG DomainsLength;
    PLSAPR_TRUST_INFORMATION Domains = NULL;
    PVOID Buffers[2];
    ULONG BufferCount;
    ULONG Index;
    PLSAPR_REFERENCED_DOMAIN_LIST OutputReferencedDomains = NULL;

    //
    // Allocate the Referenced Domain List header.
    //

    BufferCount = 0;

    OutputReferencedDomains = MIDL_user_allocate(
                                  sizeof(LSAP_DB_REFERENCED_DOMAIN_LIST)
                                  );

    if (OutputReferencedDomains == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto CreateListReferencedDomainsError;
    }

    Buffers[BufferCount] = OutputReferencedDomains;
    BufferCount++;

    //
    // If a non-zero initial entry count, allocate an array of Trust Information
    // entries.
    //

    if (InitialMaxEntries > 0) {

        DomainsLength = sizeof(LSA_TRUST_INFORMATION) * InitialMaxEntries;
        Domains = MIDL_user_allocate( DomainsLength );

        Status = STATUS_INSUFFICIENT_RESOURCES;

        if (Domains == NULL) {

            goto CreateListReferencedDomainsError;
        }

        Status = STATUS_SUCCESS;

        Buffers[BufferCount] = Domains;
        BufferCount++;

        RtlZeroMemory( Domains, DomainsLength );
    }

    //
    // Initialize the Referenced Domain List Header
    //

    OutputReferencedDomains->Entries = 0;
    OutputReferencedDomains->MaxEntries = InitialMaxEntries;
    OutputReferencedDomains->Domains = Domains;

CreateListReferencedDomainsFinish:

    *ReferencedDomains = OutputReferencedDomains;
    return(Status);

CreateListReferencedDomainsError:

    //
    // Free up buffers allocated bu this routine.
    //

    for (Index = 0; Index < BufferCount; Index++) {

        MIDL_user_free(Buffers[Index]);
    }

    goto CreateListReferencedDomainsFinish;
}


NTSTATUS
LsapDbLookupGrowListReferencedDomains(
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN ULONG MaxEntries
    )

/*++

Routine Description:

    This function expands a Referenced Domain List to contain the
    specified maximum number of entries.  The memory for the old Domains
    array is released.

Arguments:

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    MaxEntries - New maximum number of entries.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources to
            complete the call.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_TRUST_INFORMATION NewDomainsInfo = NULL;
    PLSAPR_TRUST_INFORMATION OldDomainsInfo = NULL;
    ULONG OldDomainsInfoLength, NewDomainsInfoLength;

    if (ReferencedDomains->MaxEntries < MaxEntries) {

        NewDomainsInfoLength = MaxEntries * sizeof (LSA_TRUST_INFORMATION);
        OldDomainsInfoLength =
            ReferencedDomains->MaxEntries * sizeof (LSA_TRUST_INFORMATION);

        NewDomainsInfo = MIDL_user_allocate( NewDomainsInfoLength );

        Status = STATUS_INSUFFICIENT_RESOURCES;

        if (NewDomainsInfo == NULL) {

            goto GrowListReferencedDomainsError;
        }

        Status = STATUS_SUCCESS;

        //
        // If there was an existing Trust Information Array, copy it
        // to the newly allocated one and free it.
        //

        OldDomainsInfo = ReferencedDomains->Domains;

        if (OldDomainsInfo != NULL) {

            RtlCopyMemory( NewDomainsInfo, OldDomainsInfo, OldDomainsInfoLength );
            MIDL_user_free( OldDomainsInfo );
        }

        ReferencedDomains->Domains = NewDomainsInfo;
        ReferencedDomains->MaxEntries = MaxEntries;
    }

GrowListReferencedDomainsFinish:

    return(Status);

GrowListReferencedDomainsError:

    goto GrowListReferencedDomainsFinish;
}


BOOLEAN
LsapDbLookupListReferencedDomains(
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_SID DomainSid,
    OUT PLONG DomainIndex
    )

/*++

Routine Description:

    This function searches a Referenced Domain List for a given domain
    and, if found, returns the index of the domain's entry in the list.
    If the domain is not found an error is returned and a negative value
    is returned.

Arguments:

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    DomainSid - Information containing the Domain's Sid.

    DomainIndex - Pointer to location that receives the index of the domain
        in the Referenced Domain List if the domin is found, otherwise
        a negative value.

Return Values:

    BOOLEAN - TRUE if entry found, else FALSE.

--*/

{
    BOOLEAN BooleanStatus = FALSE;
    LONG Index;
    LONG Entries;
    PLSAPR_TRUST_INFORMATION DomainsInfo;

    //
    // Search the Referenced Domain List by Sid or by Name
    //

    Entries = (LONG) ReferencedDomains->Entries;
    DomainsInfo = ReferencedDomains->Domains;
    *DomainIndex = LSA_UNKNOWN_INDEX;

    for (Index = 0; Index < (LONG) Entries && DomainSid; Index++) {

        if ( DomainsInfo[Index].Sid &&
             RtlEqualSid( ( PSID )DomainsInfo[Index].Sid, ( PSID )DomainSid ) ) {

            BooleanStatus = TRUE;
            *DomainIndex = Index;
            break;
        }
    }

    return(BooleanStatus);
}


NTSTATUS
LsapDbLookupMergeDisjointReferencedDomains(
    IN OPTIONAL PLSAPR_REFERENCED_DOMAIN_LIST FirstReferencedDomainList,
    IN OPTIONAL PLSAPR_REFERENCED_DOMAIN_LIST SecondReferencedDomainList,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *OutputReferencedDomainList,
    IN ULONG Options
    )

/*++

Routine Description:

    This function merges disjoint Referenced Domain Lists, producing a third
    list.  The output list is always produced in non allocate(all_nodes) form.

Arguments:

    FirstReferencedDomainList - Pointer to first mergand.

    SecondReferencedDomainList - Pointer to second mergand.

    OutputReferencedDomainList - Receives a pointer to the output list.

    Options - Specifies optional actions

        LSAP_DB_USE_FIRST_MERGAND_GRAPH - Specifies that the resulting
            merged Referenced Domain List may reference the graph of
            pointers in the first Referenced Domain list.  This option
            is normally selected, since that graph has been allocated
            as individual nodes.

        LSAP_DB_USE_SECOND_MERGAND_GRAPH - Specifies that the resulting
            merged Referenced Domain List may reference the graph of
            pointers in the first Referenced Domain list.  This option
            is normally not selected, since that graph is usually allocated
            as all_nodes.

Return Values:

    NTSTATUS - Standard Nt Result Code.

--*/

{
    NTSTATUS Status;
    ULONG TotalEntries;
    ULONG FirstReferencedDomainListLength;
    ULONG SecondReferencedDomainListLength;
    ULONG FirstEntries, SecondEntries;
    LSAP_MM_FREE_LIST FreeList;
    ULONG NextEntry;
    ULONG MaximumFreeListEntries;
    ULONG CleanupFreeListOptions = (ULONG) 0;

    //
    // Calculate Size of output Referenced Domain List.
    //

    FirstEntries = (ULONG) 0;

    if (FirstReferencedDomainList != NULL) {

        FirstEntries = FirstReferencedDomainList->Entries;
    }

    SecondEntries = (ULONG) 0;

    if (SecondReferencedDomainList != NULL) {

        SecondEntries = SecondReferencedDomainList->Entries;
    }

    TotalEntries = FirstEntries + SecondEntries;

    //
    // Allocate a Free List for error cleanup.  We need two entries
    // per Referenced Domain List entry, one for the Domain Name buffer
    // and one for the Domain Sid.
    //

    MaximumFreeListEntries = (ULONG) 0;

    if (!(Options & LSAP_DB_USE_FIRST_MERGAND_GRAPH)) {

        MaximumFreeListEntries += 2*FirstEntries;
    }

    if (!(Options & LSAP_DB_USE_SECOND_MERGAND_GRAPH)) {

        MaximumFreeListEntries += 2*SecondEntries;
    }

    Status = LsapMmCreateFreeList( &FreeList, MaximumFreeListEntries );

    if (!NT_SUCCESS(Status)) {

        goto MergeDisjointDomainsError;
    }

    Status = LsapDbLookupCreateListReferencedDomains(
                 OutputReferencedDomainList,
                 TotalEntries
                 );

    if (!NT_SUCCESS(Status)) {

        goto MergeDisjointDomainsError;
    }

    //
    // Set the number of entries used.  We will use all of the entries,
    // so set this value to the Maximum number of Entries.
    //

    (*OutputReferencedDomainList)->Entries = TotalEntries;

    if ( 0 == TotalEntries ) {

        //
        // There is not much to do
        //

        // This ASSERT is to understand conditions underwhich we might hit this
        // scenario.  There is likely a coding bug else if we are asking
        // two empty lists to be merged.
        //
        ASSERT( 0 == TotalEntries );

        ASSERT( NT_SUCCESS(Status) );
        goto MergeDisjointDomainsFinish;

    }

    //
    // Copy in the entries (if any) from the first list.
    //

    FirstReferencedDomainListLength =
        FirstEntries * sizeof(LSA_TRUST_INFORMATION);

    if (FirstReferencedDomainListLength > (ULONG) 0) {

        if (Options & LSAP_DB_USE_FIRST_MERGAND_GRAPH) {

            RtlCopyMemory(
                (*OutputReferencedDomainList)->Domains,
                FirstReferencedDomainList->Domains,
                FirstReferencedDomainListLength
                );

        } else {

            //
            // The graph of the first Referenced Domain List must be
            // copied to separately allocated memory buffers.
            // Copy each of the Trust Information entries, allocating
            // individual memory buffers for each Domain Name and Sid.
            //

            for (NextEntry = 0; NextEntry < FirstEntries; NextEntry++) {

                Status = LsapRpcCopyUnicodeString(
                             &FreeList,
                             (PUNICODE_STRING) &((*OutputReferencedDomainList)->Domains[NextEntry].Name),
                             (PUNICODE_STRING) &FirstReferencedDomainList->Domains[NextEntry].Name
                             );

                if (!NT_SUCCESS(Status)) {

                    break;
                }

                if ( FirstReferencedDomainList->Domains[NextEntry].Sid ) {

                    Status = LsapRpcCopySid(
                                 &FreeList,
                                 (PSID) &((*OutputReferencedDomainList)->Domains[NextEntry].Sid),
                                 (PSID) FirstReferencedDomainList->Domains[NextEntry].Sid
                                 );
                } else {

                    (*OutputReferencedDomainList)->Domains[NextEntry].Sid = NULL;
                }

                if (!NT_SUCCESS(Status)) {

                    break;
                }
            }

            if (!NT_SUCCESS(Status)) {

                goto MergeDisjointDomainsError;
            }
        }
    }

    //
    // Copy in the entries (if any) from the second list.
    //

    SecondReferencedDomainListLength =
        SecondEntries * sizeof(LSA_TRUST_INFORMATION);

    if (SecondReferencedDomainListLength > (ULONG) 0) {

        if (Options & LSAP_DB_USE_SECOND_MERGAND_GRAPH) {

            RtlCopyMemory(
                (*OutputReferencedDomainList)->Domains + FirstReferencedDomainList->Entries,
                SecondReferencedDomainList->Domains,
                SecondReferencedDomainListLength
                );

        } else {

            //
            // Copy each of the Trust Information entries, allocating
            // individual memory buffers for each Domain Name and Sid.
            //

            for (NextEntry = 0; NextEntry < SecondEntries; NextEntry++) {

                Status = LsapRpcCopyUnicodeString(
                             &FreeList,
                             (PUNICODE_STRING) &((*OutputReferencedDomainList)->Domains[FirstEntries +NextEntry].Name),
                             (PUNICODE_STRING) &SecondReferencedDomainList->Domains[NextEntry].Name
                             );

                if (!NT_SUCCESS(Status)) {

                    break;
                }

                Status = LsapRpcCopySid(
                             &FreeList,
                             (PSID) &((*OutputReferencedDomainList)->Domains[FirstEntries +NextEntry].Sid),
                             (PSID) SecondReferencedDomainList->Domains[NextEntry].Sid
                             );

                if (!NT_SUCCESS(Status)) {

                    break;
                }
            }

            if (!NT_SUCCESS(Status)) {

                goto MergeDisjointDomainsError;
            }
        }
    }

MergeDisjointDomainsFinish:

    //
    // Delete the Free List, freeing buffers on the list if an error
    // occurred.
    //

    LsapMmCleanupFreeList( &FreeList, CleanupFreeListOptions );
    return(Status);

MergeDisjointDomainsError:

    //
    // Delete the output referenced domain list
    //
    MIDL_user_free( *OutputReferencedDomainList );
    *OutputReferencedDomainList = NULL;


    //
    // Specify that buffers on Free List are to be freed.
    //

    CleanupFreeListOptions |= LSAP_MM_FREE_BUFFERS;
    goto MergeDisjointDomainsFinish;
}


NTSTATUS
LsapDbLookupDispatchWorkerThreads(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    )

/*++

Routine Description:

    This function dispatches sufficient worker threads to handle a
    Lookup operation.  The worker threads can handle work items
    on any Lookup's Work List, so the number of existing active
    threads is taken into account.  Note that the total number of
    active Lookup Worker Threads may exceed the guide maximum number of
    threads, in situations where an active thread terminates during
    the dispatch cycle.  This strategy saves having to recheck the
    active thread count each time a thread is dispatched.

    NOTE:  This routine expects the specified pointer to a Work List to be
           valid.  A Work List pointer always remains valid until its
           Primary thread detects completion of the Work List via this
           routine and then deletes it via LsapDbLookupDeleteWorkList().

Arguments:

    WorkList - Pointer to a Work List describing a Lookup Sid or Lookup Name
        operation.


Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS DispatchThreadStatus = STATUS_SUCCESS;
    ULONG AdvisoryChildThreadCount;
    ULONG DispatchThreadCount;
    ULONG MaximumDispatchChildThreadCount;
    ULONG ThreadNumber;
    HANDLE Thread = NULL;
    DWORD Ignore;
    BOOLEAN AcquiredWorkQueueLock = FALSE;

    //
    // Acquire the Lookup Work Queue Lock.
    //

    Status = LsapDbLookupAcquireWorkQueueLock();

    if (!NT_SUCCESS(Status)) {

        goto LookupDispatchWorkerThreadsError;
    }

    AcquiredWorkQueueLock = TRUE;

    //
    // Calculate the number of Worker Threads to dispatch (if any).  If
    // the WorkList has an Advisory Child Thread Count of 0, we will
    // not dispatch any threads, but instead will perform this Lookup
    // within this thread.  If the WorkList has an Advisory Child Thread
    // Count > 0, we will dispatch additional threads.  The number of
    // additional child threads dispatched is given by the formula:
    //
    // ThreadsToDispatch =
    //     min (MaximumChildThreadCount - ActiveChildThreadCount,
    //          AdvisoryChildThreadCount)
    //

    AdvisoryChildThreadCount = WorkList->AdvisoryChildThreadCount;

    if (AdvisoryChildThreadCount > 0) {

        MaximumDispatchChildThreadCount =
            LookupWorkQueue.MaximumChildThreadCount -
            LookupWorkQueue.ActiveChildThreadCount;

        if (AdvisoryChildThreadCount <= MaximumDispatchChildThreadCount) {

            DispatchThreadCount = AdvisoryChildThreadCount;

        } else {

            DispatchThreadCount = MaximumDispatchChildThreadCount;
        }

        //
        // Release the Lookup Work Queue Lock
        //

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;

        //
        // Signal the event that indicates that a new Work List is initiated.
        //

        Status = NtSetEvent( LsapDbLookupStartedEvent, NULL );

        if (!NT_SUCCESS(Status)) {

            LsapDiagPrint( DB_LOOKUP_WORK_LIST,
                          ("LsapDbLookupDispatchWorkList... NtSetEvent failed 0x%lx\n",Status));
            goto LookupDispatchWorkerThreadsError;
        }

        //
        // Dispatch the computed number of threads.
        //

        for (ThreadNumber = 0; ThreadNumber < DispatchThreadCount; ThreadNumber++) {

            Thread = CreateThread(
                         NULL,
                         0L,
                         (LPTHREAD_START_ROUTINE) LsapDbLookupWorkerThreadStart,
                         NULL,
                         0L,
                         &Ignore
                         );

            if (Thread == NULL) {

                Status = GetLastError();

                KdPrint(("LsapDbLookupDispatchWorkerThreads: CreateThread failed 0x%lx\n"));

                break;

            } else {

                CloseHandle( Thread );
            }
        }

        if (!NT_SUCCESS(Status)) {

            DispatchThreadStatus = Status;
        }
    }

    //
    // Unlock the queue so this thread doesn't hog it while doing a lookup
    //

    if (AcquiredWorkQueueLock) {

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;
    }

    //
    // Do some work in the main thread too.
    //

    LsapDbLookupWorkerThread( TRUE);

LookupDispatchWorkerThreadsFinish:

    if (AcquiredWorkQueueLock) {

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;
    }

    return(Status);

LookupDispatchWorkerThreadsError:

    goto LookupDispatchWorkerThreadsFinish;
}


NTSTATUS
LsapDbGetCachedHandleTrustedDomain(
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN ACCESS_MASK DesiredAccess,
    IN OUT LPWSTR *ServerName,
    IN OUT LPWSTR *ServerPrincipalName,
    IN OUT PVOID  *ClientContext,
    OUT PLSAP_BINDING_CACHE_ENTRY * ControllerPolicyEntry
    )

/*++

Routine Description:

    This routine looks for a cached handle to the LSA on a trusted domain.
    If one is not present, it will open & cache a new handle. The handle
    is opened for POLICY_LOOKUP_NAMES.
    
    N.B. ServerName, ServerPrincipalName, and ClientContext are IN/OUT
    parameters -- if a new handle is created, the memory is transferred
    to the cache and so the values are NULL'ed on return. 
    
    If a value is found in the cache then the values are also freed (and 
    NULL'ed), so that the interface is consistent (on success, *ServerName,
    *ServerPrincipalName, *ClientContext are freed).

Arguments:

    TrustInformation - Specifies the Sid and/or Name of the Trusted Domain
        whose Policy database is to be opened.
        
    DesiredAccess -- if a new handle is required, what to ask for
    
    ServerName -- in, out; if a new handle is required the server to get one
                  from
                  
    ServerPrincipalName -- in, out; if a new handle is required this is used
                  to authenticate. 
                  
    ClientContext -- in, out; if a new handle is required, this is used to 
                  authenticate. 
        
    ControllerPolicyEntry - Receives binding cache entry to the LSA Policy
        Object for the Lsa Policy database located on some DC for the
        specified Trusted Domain.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_NO_MORE_ENTRIES - The DC list for the specified domain
            is null.

        Result codes from called routines.
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING DomainName = NULL;
    PLSAPR_TRUST_INFORMATION OutputTrustInformation = NULL;
    LSA_HANDLE PolicyHandle = NULL;
    PLSAP_BINDING_CACHE_ENTRY CacheEntry = NULL;
    UNICODE_STRING DomainControllerName;

    *ControllerPolicyEntry = NULL;

    //
    // If the caller didn't provide a domain name, look it up now
    //

    if ((TrustInformation->Name.Length == 0) ||
        (TrustInformation->Name.Buffer == NULL)) {

        Status = STATUS_INVALID_PARAMETER;

        if (TrustInformation->Sid == NULL) {

            goto Cleanup;
        }

        Status = LsapDbLookupSidTrustedDomainList(
                     TrustInformation->Sid,
                     &OutputTrustInformation
                     );

        if (!NT_SUCCESS(Status)) {

            goto Cleanup;
        }

        DomainName = (PUNICODE_STRING) &OutputTrustInformation->Name;
        TrustInformation = OutputTrustInformation;

    } else {

        DomainName = (PUNICODE_STRING) &TrustInformation->Name;
    }

    //
    // Look in the cache for a binding handle
    //


    CacheEntry = LsapLocateBindingCacheEntry(
                    DomainName,
                    FALSE                       // don't remove
                    );

    if (CacheEntry != NULL) {

        //
        // Validate the handle to make sure the DC is still there.
        //

        Status = LsapRtlValidateControllerTrustedDomainByHandle(
                    CacheEntry->PolicyHandle,
                    TrustInformation
                    );
        if (!NT_SUCCESS(Status)) {

            LsapReferenceBindingCacheEntry(
                CacheEntry,
                TRUE            // unlink
                );
            LsapDereferenceBindingCacheEntry(
                CacheEntry
                );
            LsapDereferenceBindingCacheEntry(
                CacheEntry
                );
            CacheEntry = NULL;
        }
        else
        {
            *ControllerPolicyEntry = CacheEntry;
            goto Cleanup;
        }
    }

    //
    // There was nothing in the cache, so open a new handle
    //
    RtlInitUnicodeString(&DomainControllerName, *ServerName);
    Status = LsapRtlValidateControllerTrustedDomain( (PLSAPR_UNICODE_STRING)&DomainControllerName,
                                                     TrustInformation,
                                                     POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,
                                                     *ServerPrincipalName,
                                                     *ClientContext,
                                                     &PolicyHandle
                                                     );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    //
    // Create a binding cache entry from the handle
    //

    //
    // Note: this routine sets ServerName, ServerPrincipalName and
    // ClientContext to NULL on success.
    //
    Status = LsapCacheBinding(
                DomainName,
                &PolicyHandle,
                ServerName,
                ServerPrincipalName,
                ClientContext,
                ControllerPolicyEntry
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

Cleanup:

    if (PolicyHandle != NULL) {
        LsaClose(PolicyHandle);
    }

    if (NT_SUCCESS(Status)) {
        //
        // On success, always free the IN/OUT parameters to provide
        // a consistent interface
        // 
        if (*ServerName) {
            LocalFree(*ServerName);
            *ServerName = NULL;
        }
        if (*ServerPrincipalName) {
            I_NetLogonFree(*ServerPrincipalName);
            *ServerPrincipalName = NULL;
        }
        if (*ClientContext) {
            I_NetLogonFree(*ClientContext);
            *ClientContext = NULL;
        }

        //
        // We should have a cache entry to return
        //
        ASSERT(NULL != *ControllerPolicyEntry);
    }




    return(Status);
}


NTSTATUS
LsapRtlValidateControllerTrustedDomain(
    IN PLSAPR_UNICODE_STRING DomainControllerName,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN ACCESS_MASK OriginalDesiredAccess,
    IN LPWSTR ServerPrincipalName,
    IN PVOID ClientContext,
    OUT PLSA_HANDLE ControllerPolicyHandle
    )

/*++

Routine Description:

    This function verifies that a specified computer is a DC for
    a specified Domain and opens the LSA Policy Object with the
    desired accesses.

Arguments:

    DomainControllerName - Pointer to Unicode String computer name.

    TrustInformation - Domain Trust Information.  Only the Sid is
        used.

    OriginalDesiredAccess - Specifies the accesses desired to the
        target machine's Lsa Policy Database.

    ServerPrincipalName - RPC server principal name.

    ClientContext - RPC client context information.

    PolicyHandle - Receives handle to the Lsa Policy object on the target
        machine.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_OBJECT_NAME_NOT_FOUND - The specified computer is not a
        Domain Controller for the specified Domain.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS Status2 = STATUS_SUCCESS;
    NTSTATUS SecondaryStatus = STATUS_SUCCESS;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE OutputControllerPolicyHandle = NULL;
    ACCESS_MASK DesiredAccess;

    //
    // Open a handle to the Policy Object on the target DC.
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // For authenticated clients, the server adds in the POLICY_LOOKUP_NAMES
    // access
    //

Retry:

    if (ClientContext != NULL) {
        DesiredAccess = OriginalDesiredAccess & ~POLICY_LOOKUP_NAMES;

    } else {
        DesiredAccess = OriginalDesiredAccess;
    }

    Status = LsaOpenPolicy(
                 (PUNICODE_STRING) DomainControllerName,
                 &ObjectAttributes,
                 DesiredAccess,
                 &OutputControllerPolicyHandle
                 );


    if (!NT_SUCCESS(Status)) {

        goto ValidateControllerTrustedDomainError;
    }

    if (ClientContext != NULL) {

        ULONG RpcErr;
        RPC_BINDING_HANDLE RpcBindingHandle;

        //
        // Setup the the RPC authenticated channel
        //

        RpcErr = RpcSsGetContextBinding(
                    OutputControllerPolicyHandle,
                    &RpcBindingHandle
                    );

        //
        // Note: the handle returned by RpcSsGetContextBinding is valid for the lifetime
        //       of OutputControllerPolicyHanlde; it does not need to be closed.
        //

        Status = I_RpcMapWin32Status(RpcErr);

        if (!NT_SUCCESS(Status)) {

            goto ValidateControllerTrustedDomainError;
        }

        RpcErr = RpcBindingSetAuthInfo(
                    RpcBindingHandle,
                    ServerPrincipalName,
                    RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                    RPC_C_AUTHN_NETLOGON,
                    ClientContext,
                    RPC_C_AUTHZ_NONE
                    );

        Status = I_RpcMapWin32Status(RpcErr);

        if (!NT_SUCCESS(Status)) {

            goto ValidateControllerTrustedDomainError;
        }
        //
        // Perform a validation on the handle to make sure the new auth info
        // is supported on the called server.
        //
        // N.B.  The locator will always return a valid DC so this check is not
        // to validate that the server is a DC, rather it is used to validate
        // that the connection we've created is valid. This check is only
        // necessary when setting up secure RPC.
        //
        Status = LsapRtlValidateControllerTrustedDomainByHandle( OutputControllerPolicyHandle,
                                                                 TrustInformation );
    
    
        if (!NT_SUCCESS(Status)) {
    
            //
            // If the server didn't recognize the authn service, try again
            // without authenticated RPC
            //
    
            if ((Status == RPC_NT_UNKNOWN_AUTHN_SERVICE) ||
                (Status == STATUS_ACCESS_DENIED)) {
                Status = STATUS_SUCCESS;
    
                LsaClose( OutputControllerPolicyHandle );
                OutputControllerPolicyHandle = NULL;
    
                ClientContext = NULL;
                goto Retry;
            }
    
            goto ValidateControllerTrustedDomainError;
        }
    }

    Status = STATUS_SUCCESS;

ValidateControllerTrustedDomainFinish:

    //
    // Return Controller Policy handle or NULL.
    //

    *ControllerPolicyHandle = OutputControllerPolicyHandle;

    return(Status);

ValidateControllerTrustedDomainError:

    //
    // Close the last Controller's Policy Handle.
    //

    if (OutputControllerPolicyHandle != NULL) {

        SecondaryStatus = LsaClose( OutputControllerPolicyHandle );
        OutputControllerPolicyHandle = NULL;
    }

    goto ValidateControllerTrustedDomainFinish;
}



NTSTATUS
LsapRtlValidateControllerTrustedDomainByHandle(
    IN LSA_HANDLE DcPolicyHandle,
    IN PLSAPR_TRUST_INFORMATION TrustInformation
    )
/*++

Routine Description:

    This function validates that the given policy handle refers to a valid domain controller

Arguments:

    DcPolicyHandle - Handle to the policy on the machine to verify

    TrustInformation - Information regarding this Dc's domain

Return Value:

    STATUS_SUCCESS - Success

    Otherwise, the handle isn't valid

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_POLICY_ACCOUNT_DOM_INFO PolicyAccountDomainInfo = NULL;

    Status = LsaQueryInformationPolicy( DcPolicyHandle,
                                        PolicyAccountDomainInformation,
                                        ( PVOID * )&PolicyAccountDomainInfo );
    //
    // Now compare the Domain Name and Sid stored for the Controller's
    // Account Domain with the Domain Name and Sid provided.
    //
    if ( NT_SUCCESS( Status ) ) {

        if ( !RtlEqualDomainName( ( PUNICODE_STRING ) &TrustInformation->Name,
                                  ( PUNICODE_STRING ) &PolicyAccountDomainInfo->DomainName ) ) {

            Status = STATUS_OBJECT_NAME_NOT_FOUND;

        } else if ( TrustInformation->Sid &&
                    !RtlEqualSid( ( PSID )TrustInformation->Sid,
                                  ( PSID ) PolicyAccountDomainInfo->DomainSid ) ) {

            Status = STATUS_OBJECT_NAME_NOT_FOUND;

        }
    }

    //
    // Free up the Policy Account Domain Info.
    //
    if ( PolicyAccountDomainInfo != NULL ) {

        LsaFreeMemory( (PVOID) PolicyAccountDomainInfo );

    }

    return(Status);
}



NTSTATUS
LsapDbLookupAcquireWorkQueueLock(
    )

/*++

Routine Description:

    This function acquires the LSA Database Lookup Sids/Names Work Queue Lock.
    This lock serializes additions or deletions of work lists to/from the
    queue, and sign-in/sign-out of work items by worker threads.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code.

--*/

{
    NTSTATUS Status;

    Status = SafeEnterCriticalSection(&LookupWorkQueue.Lock);

    return(Status);
}


VOID
LsapDbLookupReleaseWorkQueueLock(
    )

/*++

Routine Description:

    This function releases the LSA Database Lookup Sids/Names Work Queue Lock.

Arguments:

    None.

Return Value:

    None.  Any error occurring within this routine is an internal error.

--*/

{
    SafeLeaveCriticalSection(&LookupWorkQueue.Lock);
}


NTSTATUS
LsapDbLookupNamesBuildWorkList(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN BOOLEAN fIncludeIntraforest,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList
    )

/*++

Routine Description:

    This function constructs a Work List for an LsarLookupNames call.  The
    Work List contains the parameters of the call, and an array of Work Items.
    Each Work Item specifies either all of the Names to be looked up
    in a given domain.

    Qualified names (i.e. those of the form DomainName\UserName) are
    sorted into different Work Items, one for each DomainName specifed.
    Unqualified names (i.e. those of the form UserName) are added to
    every Work Item.

Arguments:

                           
    LookupOptions - LSA_LOOKUP_ISOLATED_AS_LOCAL
    
    Count - Specifies the number of names to be translated.

    fIncludeIntraforest -- if TRUE, trusted domains in our local forest
                           are searched.
                                           
    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for
        each translated name, this structure will only contain one
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    TranslatedSids - Pointer to a structure which will (or already) references an array of
        records describing each translated Sid.  The nth entry in this array
        provides a translation for the nth element in the Names parameter.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupWksta - First Level Lookup performed on a workstation
            normally configured for Windows-Nt.   The lookup searches the
            Well-Known Sids/Names, and the Built-in Domain and Account Domain
            in the local SAM Database.  If not all Sids or Names are
            identified, performs a "handoff" of a Second level Lookup to the
            LSA running on a Controller for the workstation's Primary Domain
            (if any).

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Sids or Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.

        MappedCount - Pointer to location that contains a count of the Names
            mapped so far. On exit, this will be updated.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.

    WorkList - Receives pointer to completed Work List if successfully built.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_NONE_MAPPED - All of the Names specified were composite,
            but none of their Domains appear in the Trusted Domain List.
            No Work List has been generated.  Note that this is not a
            fatal error.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS, IgnoreStatus = STATUS_SUCCESS;
    PLSAP_DB_LOOKUP_WORK_LIST OutputWorkList = NULL;
    ULONG NameIndex;
    PLSAP_DB_LOOKUP_WORK_ITEM AnchorWorkItem = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM NextWorkItem = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM WorkItemToUpdate = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM NewWorkItem = NULL;
    PLSAPR_TRUST_INFORMATION TrustInformation = NULL;
    LONG DomainIndex = 0;
    PLSAP_DB_LOOKUP_WORK_ITEM IsolatedNamesWorkItem = NULL;
    BOOLEAN AcquiredTrustedDomainListReadLock = FALSE;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustedDomainEntry = NULL;
    LSAPR_UNICODE_STRING DomainNameBuffer;
    PLSAPR_UNICODE_STRING DomainName = &DomainNameBuffer;
    LSAPR_UNICODE_STRING TerminalNameBuffer;
    PLSAPR_UNICODE_STRING TerminalName = &TerminalNameBuffer;

    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry = NULL;
    LSAPR_TRUST_INFORMATION TrustInfo;
    LPWSTR ClientNetworkAddress = NULL;


    //
    // Get the client's address for logging purposes
    //
    ClientNetworkAddress = LsapGetClientNetworkAddress();

    //
    // Create an empty Work List.
    //

    Status = LsapDbLookupCreateWorkList(&OutputWorkList);

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesBuildWorkListError;
    }

    //
    // Initialize the Work List Header.
    //

    OutputWorkList->Status = STATUS_SUCCESS;
    OutputWorkList->State = InactiveWorkList;
    OutputWorkList->LookupType = LookupNames;
    OutputWorkList->Count = Count;
    OutputWorkList->LookupLevel = LookupLevel;
    OutputWorkList->ReferencedDomains = ReferencedDomains;
    OutputWorkList->MappedCount = MappedCount;
    OutputWorkList->CompletelyUnmappedCount = CompletelyUnmappedCount;
    OutputWorkList->LookupNamesParams.Names = Names;
    OutputWorkList->LookupNamesParams.TranslatedSids = TranslatedSids;

    //
    // Construct the array of Work Items.  Each Work Item will
    // contain all the Names for a given domain, so we will scan
    // all of the Names, sorting them into Work Items as we go.
    // For each Name, follow the steps detailed below.
    //

    for (NameIndex = 0; NameIndex < Count; NameIndex++) {

        //
        // If this Name's Domain is already marked as known, skip.
        //

        if (TranslatedSids->Sids[NameIndex].DomainIndex != LSA_UNKNOWN_INDEX) {

            continue;
        }

        //
        // Name is completely unknown.  See if there is already a Work Item
        // for its Domain.
        //

        AnchorWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM) OutputWorkList->AnchorWorkItem;
        NextWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM) AnchorWorkItem->Links.Flink;;
        WorkItemToUpdate = NULL;
        NewWorkItem = NULL;

        //
        // If this is a qualified name (e.g. "NtDev\ScottBi") proceed
        // to search for its Domain.
        //
        // Also, crack names of the format user@dns.domain.name
        //

        LsapLookupCrackName((PUNICODE_STRING)&PrefixNames[ NameIndex ], 
                            (PUNICODE_STRING)&SuffixNames[ NameIndex ],
                            (PUNICODE_STRING)TerminalName,
                            (PUNICODE_STRING)DomainName);

        if (DomainName->Length != 0) {

            while (NextWorkItem != AnchorWorkItem) {

                if (RtlEqualDomainName(
                        (PUNICODE_STRING) &NextWorkItem->TrustInformation.Name,
                        (PUNICODE_STRING) DomainName
                        ))  {

                    //
                    // A Work Item already exists for the Name's Trusted Domain.
                    // Select that Work Item for update.
                    //

                    WorkItemToUpdate = NextWorkItem;

                    break;
                }

                //
                // Name's domain not found among existing Work Items.  Skip to
                // next Work Item.
                //

                NextWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM) NextWorkItem->Links.Flink;
            }

            if (WorkItemToUpdate == NULL) {

                //
                // No Work Item exists for the Name's Domain.  See if the
                // Name belongs to one of the Trusted Domains.  If not, skip
                // to the next Name.
                //
                ULONG Flags = LSAP_LOOKUP_DOMAIN_TRUST_DIRECT_EXTERNAL;
                if (fIncludeIntraforest) {
                    Flags = LSAP_LOOKUP_DOMAIN_TRUST_DIRECT_INTRA;
                }

                Status = LsapDomainHasDomainTrust(Flags,
                                                  (PUNICODE_STRING)DomainName,
                                                  NULL,
                                                  &AcquiredTrustedDomainListReadLock,
                                                  &TrustEntry);

                if (!NT_SUCCESS(Status)) {

                    if (Status == STATUS_NO_SUCH_DOMAIN) {
                        //
                        // No Match!
                        //
                        Status = STATUS_SUCCESS;
                        continue;
                    }
                    break;
                }

                RtlZeroMemory( &TrustInfo, sizeof(TrustInfo) );
                TrustInfo.Name = TrustEntry->TrustInfoEx.FlatName;
                TrustInfo.Sid = TrustEntry->TrustInfoEx.Sid;
                TrustInformation = &TrustInfo;

                //
                // Name belongs to a Trusted Domain for which there is
                // no Work Item.  Add the Domain to the Referenced Domain List
                // and obtain a Domain Index.
                //

                Status = LsapDbLookupAddListReferencedDomains(
                             ReferencedDomains,
                             TrustInformation,
                             &DomainIndex
                             );

                if (!NT_SUCCESS(Status)) {

                    break;
                }

                //
                // Create a new Work Item for this domain.
                //

                Status = LsapDbLookupCreateWorkItem(
                             TrustInformation,
                             DomainIndex,
                             (ULONG) LSAP_DB_LOOKUP_WORK_ITEM_GRANULARITY + (ULONG) 1,
                             &NewWorkItem
                             );

                if (!NT_SUCCESS(Status)) {

                    break;
                }

                //
                // Add the Work Item to the List.
                //

                Status = LsapDbAddWorkItemToWorkList( OutputWorkList, NewWorkItem );

                if (!NT_SUCCESS(Status)) {

                    break;
                }

                WorkItemToUpdate = NewWorkItem;
            }

            //
            // Add the Name Index to the Work Item.
            //

            Status = LsapDbLookupAddIndicesToWorkItem(
                         WorkItemToUpdate,
                         (ULONG) 1,
                         &NameIndex
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            //
            // Store the Domain Index in the Translated Sids array entry for
            // the Name.
            //

            OutputWorkList->LookupNamesParams.TranslatedSids->Sids[NameIndex].DomainIndex = WorkItemToUpdate->DomainIndex;

            if (!NT_SUCCESS(Status)) {

                goto LookupNamesBuildWorkListError;
            }

        } else {

            //
            // This is an Isolated Name.  We know that it is not the name
            // of any Domain on the lookup path, because all of these
            // have been translated earlier.  We will add the name to a
            // temporary work item and later transfer all the Isolated Names
            // to every Work Item on the Work List.  If we don't already
            // have a temporary Work Item for the Isolated Names, create one.
            //
            //
            // N.B. Only build this list if we want to perform isolated 
            // name lookup across the directly trusted forest boundary.
            //

            if ( (LookupOptions & LSA_LOOKUP_ISOLATED_AS_LOCAL) == 0) {

                UNICODE_STRING Items[2];

                //
                // Event the fact we are looking up this isolated name
                //
                Items[0] = *(PUNICODE_STRING)TerminalName;
                RtlInitUnicodeString(&Items[1], ClientNetworkAddress);
                LsapTraceEventWithData(EVENT_TRACE_TYPE_INFO,
                                       LsaTraceEvent_LookupIsolatedNameInTrustedDomains,
                                       2,
                                       Items);

                if (IsolatedNamesWorkItem == NULL) {

    
                    //
                    // Create a new Work Item for the Isolated Names.
                    // This is temporary.
                    //
    
                    Status = LsapDbLookupCreateWorkItem(
                                 NULL,
                                 DomainIndex,
                                 (ULONG) LSAP_DB_LOOKUP_WORK_ITEM_GRANULARITY + (ULONG) 1,
                                 &IsolatedNamesWorkItem
                                 );
    
                    if (!NT_SUCCESS(Status)) {
    
                        break;
                    }


                }
    
                //
                // Mark this Work Item as having Isolated Names only.
                //
    
                IsolatedNamesWorkItem->Properties = LSAP_DB_LOOKUP_WORK_ITEM_ISOL;
    
                //
                // Add the Name index to the Isolated Names Work Item
                //
    
                Status = LsapDbLookupAddIndicesToWorkItem(
                             IsolatedNamesWorkItem,
                             (ULONG) 1,
                             &NameIndex
                             );
    
                if (!NT_SUCCESS(Status)) {
    
                    break;
                }
            }
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesBuildWorkListError;
    }

    //
    // If we have any unmapped Isolated Names, we know at this stage that they are
    // not the Names of Trusted Domains.  Therefore, we need to arrange
    // for them to be looked up in every Trusted Domain.  We need to
    // traverse the list of Trusted Domains and for each Domain, either
    // create a new Work Item to lookup all of the Names in that Domain,
    // or add the Names to the existing Work Item generated for that
    // Domain (because there are some Qualified Names which reference
    // the Domain.  We do this Work Item Generation in 2 stages.  First,
    // we will scan the Work List, adding the Isolated Names to every Work
    // Item found therein.  Second, we will create a Work Item for each
    // of the Trusted Domains that we don't already have a Work Item.
    //

    //
    // Stage (1) - Scan the Work List, adding the Isolated Names to
    //             every Work Item found therein
    //

    if (IsolatedNamesWorkItem != NULL) {

        //
        // Stage (1) - Scan the Work List, adding the Isolated Names to
        //             every Work Item found therein
        //

        NextWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM)
            OutputWorkList->AnchorWorkItem->Links.Flink;

        while (NextWorkItem != OutputWorkList->AnchorWorkItem) {

            //
            // Add the Isolated Name indices to this Work Item
            //

            Status = LsapDbLookupAddIndicesToWorkItem(
                         NextWorkItem,
                         IsolatedNamesWorkItem->UsedCount,
                         IsolatedNamesWorkItem->Indices
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            NextWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM)
                NextWorkItem->Links.Flink;
        }

        if (!NT_SUCCESS(Status)) {

            goto LookupNamesBuildWorkListError;
        }

        //
        // Stage (2) - Now create Work Items to look up all the Isolated Names
        // in every Trusted Domain that does not presently have a Work Item.
        // The Domains for all existing Work Items are already present
        // on the Referenced Domains List because they all specify at least one
        // Qualified Name, so we can lookup that list to determine whether a
        // Work Item exists for a Domain.
        //
        for (;;) {
            //
            // Grab the lock on the TrustedDomainList.
            //

            if (!AcquiredTrustedDomainListReadLock) {

                Status = LsapDbAcquireReadLockTrustedDomainList();

                if (!NT_SUCCESS(Status)) {

                    break;
                }

                AcquiredTrustedDomainListReadLock = TRUE;
            }

            NewWorkItem = NULL;

            Status = LsapDbTraverseTrustedDomainList(
                         &TrustedDomainEntry,
                         &TrustInformation
                         );

            if (!NT_SUCCESS(Status)) {

                if (Status == STATUS_NO_MORE_ENTRIES) {

                    Status = STATUS_SUCCESS;
                }

                break;
            }

            //
            // Use only trusts to trusted domains
            //
            if (!LsapOutboundTrustedDomain(TrustedDomainEntry)) {
                continue;
            }

            //
            // Found Next Trusted Domain.  Check if this domain is already
            // present on the Referenced Domain List.  If so, skip to the
            // next domain, because we have a Work Item for this domain.
            //
            // If the Domain is not present on the Referenced Domain List,
            // we need to create a Work Item for this Domain and add all
            // of the unmapped Isolated Names indices to it.
            //

            if (LsapDbLookupListReferencedDomains(
                    ReferencedDomains,
                    TrustInformation->Sid,
                    &DomainIndex
                    )) {

                continue;
            }

            //
            // We don't have a Work Item for this Trusted Domain.  Create
            // one, and add all of the remaining Isolated Names to it.
            // Mark the Domain Index as unknown.  This is picked up
            // later when the Work Item is processed.  If any Names
            // were translated, the Domain to which the Work Item
            // relates will be added to the Referenced Domain List.
            //

            Status = LsapDbLookupCreateWorkItem(
                         TrustInformation,
                         LSA_UNKNOWN_INDEX,
                         (ULONG) LSAP_DB_LOOKUP_WORK_ITEM_GRANULARITY + (ULONG) 1,
                         &NewWorkItem
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            //
            // Mark this Work Item as having Isolated Names only.
            //

            NewWorkItem->Properties = LSAP_DB_LOOKUP_WORK_ITEM_ISOL;

            //
            // Add the Isolated Name indices to this Work Item
            //

            Status = LsapDbLookupAddIndicesToWorkItem(
                         NewWorkItem,
                         IsolatedNamesWorkItem->UsedCount,
                         IsolatedNamesWorkItem->Indices
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            //
            // Add the Work Item to the List.
            //

            Status = LsapDbAddWorkItemToWorkList( OutputWorkList, NewWorkItem );

            if (!NT_SUCCESS(Status)) {

                break;
            }

        }

        if (!NT_SUCCESS(Status)) {

            goto LookupNamesBuildWorkListError;
        }
    }

    //
    // If the Work List has no Work Items, this means that all of the
    // Names were composite, but none of the Domain Names specified
    // could be found on the Trusted Domain List.  In this case,
    // we discard the Work List.
    //

    Status = STATUS_NONE_MAPPED;

    if (OutputWorkList->WorkItemCount == 0) {

        goto LookupNamesBuildWorkListError;
    }

    //
    // Compute the Advisory Thread Count for this lookup.
    //

    Status = LsapDbLookupComputeAdvisoryChildThreadCount( OutputWorkList );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesBuildWorkListError;
    }

    Status = LsapDbLookupInsertWorkList(OutputWorkList);

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesBuildWorkListError;
    }

    //
    // Update the Mapped Counts
    //

    LsapDbUpdateMappedCountsWorkList( OutputWorkList );

LookupNamesBuildWorkListFinish:

    //
    // If necessary, release the Trusted Domain List Read Lock.
    //

    if (AcquiredTrustedDomainListReadLock) {

        LsapDbReleaseLockTrustedDomainList();
        AcquiredTrustedDomainListReadLock = FALSE;
    }

    //
    // If we have an Isolated Names Work Item, free it.
    //

    if (IsolatedNamesWorkItem != NULL) {

        MIDL_user_free( IsolatedNamesWorkItem->Indices);
        IsolatedNamesWorkItem->Indices = NULL;
        MIDL_user_free( IsolatedNamesWorkItem );
        IsolatedNamesWorkItem = NULL;
    }

    if (ClientNetworkAddress) {
        RpcStringFreeW(&ClientNetworkAddress);
    }

    *WorkList = OutputWorkList;
    return(Status);

LookupNamesBuildWorkListError:

    //
    // Discard the Work List.
    //

    if (OutputWorkList != NULL) {

        IgnoreStatus = LsapDbLookupDeleteWorkList(OutputWorkList);
        OutputWorkList = NULL;
    }

    goto LookupNamesBuildWorkListFinish;
}


NTSTATUS
LsapDbLookupXForestNamesBuildWorkList(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList
    )

/*++

Routine Description:

    This function constructs a Work List for an LsarLookupNames call.  The
    Work List contains the parameters of the call, and an array of Work Items.
    Each Work Item specifies either all of the Names to be looked up
    in a given forest.
    
    N.B.  The trust information of the WorkList is the DNS name of the
    target forest, not the DNS name of domain (we don't know what domain
    the item belongs to yet).

Arguments:

    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for
        each translated name, this structure will only contain one
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    TranslatedSids - Pointer to a structure which will (or already) references an array of
        records describing each translated Sid.  The nth entry in this array
        provides a translation for the nth element in the Names parameter.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.

    WorkList - Receives pointer to completed Work List if successfully built.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_NONE_MAPPED - All of the Names specified were composite,
            but none of their Domains appear in the Trusted Domain List.
            No Work List has been generated.  Note that this is not a
            fatal error.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS, IgnoreStatus = STATUS_SUCCESS;
    PLSAP_DB_LOOKUP_WORK_LIST OutputWorkList = NULL;
    ULONG NameIndex;
    PLSAP_DB_LOOKUP_WORK_ITEM AnchorWorkItem = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM NextWorkItem = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM WorkItemToUpdate = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM NewWorkItem = NULL;
    PLSAPR_TRUST_INFORMATION TrustInformation = NULL;
    LONG DomainIndex = 0;
    PLSAPR_UNICODE_STRING DomainName = NULL;
    PLSAPR_UNICODE_STRING TerminalName = NULL;

    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry = NULL;
    LSAPR_TRUST_INFORMATION TrustInfo;
    UNICODE_STRING XForestName = {0, 0, NULL};

    //
    // Create an empty Work List.
    //

    Status = LsapDbLookupCreateWorkList(&OutputWorkList);

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesBuildWorkListError;
    }

    //
    // Initialize the Work List Header.
    //

    OutputWorkList->Status = STATUS_SUCCESS;
    OutputWorkList->State = InactiveWorkList;
    OutputWorkList->LookupType = LookupNames;
    OutputWorkList->Count = Count;
    OutputWorkList->LookupLevel = LookupLevel;
    OutputWorkList->ReferencedDomains = ReferencedDomains;
    OutputWorkList->MappedCount = MappedCount;
    OutputWorkList->CompletelyUnmappedCount = CompletelyUnmappedCount;
    OutputWorkList->LookupNamesParams.Names = Names;
    OutputWorkList->LookupNamesParams.TranslatedSids = TranslatedSids;

    //
    // Construct the array of Work Items.  Each Work Item will
    // contain all the Names for a given domain, so we will scan
    // all of the Names, sorting them into Work Items as we go.
    // For each Name, follow the steps detailed below.
    //

    for (NameIndex = 0; NameIndex < Count; NameIndex++) {

        //
        // Name is completely unknown.  See if there is already a Work Item
        // for its Forest.
        //
        AnchorWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM) OutputWorkList->AnchorWorkItem;
        NextWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM) AnchorWorkItem->Links.Flink;
        WorkItemToUpdate = NULL;
        NewWorkItem = NULL;

        //
        // If this is a qualified name match by domain name
        //

        DomainName = &PrefixNames[ NameIndex ];
        TerminalName = &SuffixNames[ NameIndex ];

        if (DomainName->Length == 0) {

            //
            // This is a UPN -- get the XForest trust if any
            //
            Status = LsaIForestTrustFindMatch(RoutingMatchUpn,
                                              (PLSA_UNICODE_STRING)TerminalName,
                                              &XForestName);

            if (!NT_SUCCESS(Status)) {
                //
                // Perhaps this is an islolated domain name
                //
                Status = LsaIForestTrustFindMatch(RoutingMatchDomainName,
                                                  (PLSA_UNICODE_STRING)TerminalName,
                                                  &XForestName);
            }
            if (!NT_SUCCESS(Status)) {
                //
                // Can't find match? Continue
                //
                Status = STATUS_SUCCESS;
                continue;
            }

        } else {

            //
            // The name has a domain portion -- get the XForest trust if any
            //
            Status = LsaIForestTrustFindMatch(RoutingMatchDomainName,
                                              (PLSA_UNICODE_STRING)DomainName,
                                              &XForestName);
            if (!NT_SUCCESS(Status)) {
                //
                // Can't find match? Continue
                //
                Status = STATUS_SUCCESS;
                continue;
            }
        }

        //
        // We must have found a match
        //
        ASSERT(XForestName.Length > 0);

        //
        // See if any entry already exists for us
        //
        while (NextWorkItem != AnchorWorkItem) {

            if (RtlEqualDomainName(
                    (PUNICODE_STRING) &NextWorkItem->TrustInformation.Name,
                    (PUNICODE_STRING) &XForestName
                    ))  {

                //
                // A Work Item already exists for the Name's Trusted Domain.
                // Select that Work Item for update.
                //

                WorkItemToUpdate = NextWorkItem;

                break;
            }

            //
            // Name's domain not found among existing Work Items.  Skip to
            // next Work Item.
            //
            NextWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM) NextWorkItem->Links.Flink;
        }

        if (WorkItemToUpdate == NULL) {

            RtlZeroMemory( &TrustInfo, sizeof(TrustInfo) );
            TrustInfo.Name.Length = XForestName.Length;
            TrustInfo.Name.MaximumLength = XForestName.MaximumLength;
            TrustInfo.Name.Buffer = XForestName.Buffer;
            TrustInfo.Sid = NULL;
            TrustInformation = &TrustInfo;

            //
            // Create a new Work Item for this domain.
            //

            Status = LsapDbLookupCreateWorkItem(
                         TrustInformation,
                         LSA_UNKNOWN_INDEX,
                         (ULONG) LSAP_DB_LOOKUP_WORK_ITEM_GRANULARITY + (ULONG) 1,
                         &NewWorkItem
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            //
            // Add the Work Item to the List.
            //

            Status = LsapDbAddWorkItemToWorkList( OutputWorkList, NewWorkItem );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            WorkItemToUpdate = NewWorkItem;

            //
            // Mark the item as a xforest item
            //
            NewWorkItem->Properties |= LSAP_DB_LOOKUP_WORK_ITEM_XFOREST;
        }

        LsaIFree_LSAPR_UNICODE_STRING_BUFFER( (LSAPR_UNICODE_STRING*)&XForestName);
        XForestName.Buffer = NULL;

        if (!NT_SUCCESS(Status)) {

            break;
        }

        //
        // Add the Name Index to the Work Item.
        //

        Status = LsapDbLookupAddIndicesToWorkItem(
                     WorkItemToUpdate,
                     (ULONG) 1,
                     &NameIndex
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

    }

    if (XForestName.Buffer) {
        LsaIFree_LSAPR_UNICODE_STRING_BUFFER( (LSAPR_UNICODE_STRING*)&XForestName);
        XForestName.Buffer = NULL;
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesBuildWorkListError;
    }

    //
    // If the Work List has no Work Items, bail
    //

    if (OutputWorkList->WorkItemCount == 0) {

        Status = STATUS_NONE_MAPPED;
        goto LookupNamesBuildWorkListError;
    }

    //
    // Compute the Advisory Thread Count for this lookup.
    //

    Status = LsapDbLookupComputeAdvisoryChildThreadCount( OutputWorkList );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesBuildWorkListError;
    }

    Status = LsapDbLookupInsertWorkList(OutputWorkList);

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesBuildWorkListError;
    }

    //
    // Update the Mapped Counts
    //

    LsapDbUpdateMappedCountsWorkList( OutputWorkList );

LookupNamesBuildWorkListFinish:

    *WorkList = OutputWorkList;
    return(Status);

LookupNamesBuildWorkListError:

    //
    // Discard the Work List.
    //

    if (OutputWorkList != NULL) {

        IgnoreStatus = LsapDbLookupDeleteWorkList(OutputWorkList);
        OutputWorkList = NULL;
    }

    goto LookupNamesBuildWorkListFinish;
}


NTSTATUS
LsapDbLookupSidsBuildWorkList(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN BOOLEAN fIncludeIntraforest,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList
    )

/*++

Routine Description:

    This function constructs a Work List for an LsarLookupSids call.  The
    Work List contains the parameters of the call, and an array of Work Items.
    Each Work Item specifies all of the Sids belonging to a given Domain
    and is the minimal unit of work that a worker thread will undertake.

    Count - Number of Sids in the Sids array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Sids - Pointer to array of pointers to Sids to be translated.
        Zero or all of the Sids may already have been translated
        elsewhere.  If any of the Sids have been translated, the

        Names parameter will point to a location containing a non-NULL
        array of Name translation structures corresponding to the
        Sids.  If the nth Sid has been translated, the nth name
        translation structure will contain either a non-NULL name
        or a non-negative offset into the Referenced Domain List.  If
        the nth Sid has not yet been translated, the nth name
        translation structure will contain a zero-length name string
        and a negative value for the Referenced Domain List index.
        
    fIncludeIntraforest -- if TRUE, trusted domains in our local forest
                            are searched.

    TrustInformation - Pointer to Trust Information specifying a Domain Sid
        and Name.

    ReferencedDomains - Pointer to a Referenced Domain List structure.
        The structure references an array of zero or more Trust Information
        entries, one per referenced domain.  This array will be appended to
        or reallocated if necessary.

    TranslatedNames - Pointer to structure that optionally references a list
        of name translations for some of the Sids in the Sids array.

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Sids or Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.

        NOTE:  LsapLookupWksta is not valid for this parameter.

    MappedCount - Pointer to location containing the number of Sids
        in the Sids array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Sids.  A Sid is completely unmapped
        if it is unknown and also its Domain Prefix Sid is not recognized.
        This count is updated on exit, the number of completely unmapped
        Sids whose Domain Prefices are identified by this routine being
        subtracted from the input value.

    WorkList - Receives pointer to completed Work List if successfully built.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_NONE_MAPPED - None of the Sids specified belong to any of
            the Trusted Domains.  No Work List has been generated.  Note
            that this is not a fatal error.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus = STATUS_SUCCESS;
    PLSAP_DB_LOOKUP_WORK_LIST OutputWorkList = NULL;
    ULONG SidIndex;
    PSID DomainSid = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM AnchorWorkItem = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM NextWorkItem = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM WorkItemToUpdate = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM NewWorkItem = NULL;
    PLSAPR_TRUST_INFORMATION TrustInformation = NULL;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry = NULL;
    LONG DomainIndex;
    PSID Sid = NULL;
    BOOLEAN AcquiredReadLockTrustedDomainList = FALSE;

    //
    // Create an empty Work List
    //

    Status = LsapDbLookupCreateWorkList(&OutputWorkList);

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsBuildWorkListError;
    }

    //
    // Initialize the rest of the Work List Header fields.  Some fields
    // were initialized upon creation to fixed values.  The ones set here
    // depend on parameter values passed into this routine.
    //

    OutputWorkList->LookupType = LookupSids;
    OutputWorkList->Count = Count;
    OutputWorkList->LookupLevel = LookupLevel;
    OutputWorkList->ReferencedDomains = ReferencedDomains;
    OutputWorkList->MappedCount = MappedCount;
    OutputWorkList->CompletelyUnmappedCount = CompletelyUnmappedCount;
    OutputWorkList->LookupSidsParams.Sids = Sids;
    OutputWorkList->LookupSidsParams.TranslatedNames = TranslatedNames;

    //
    // Construct the array of Work Items.  Each Work Item will
    // contain all the Sids for a given domain, so we will scan
    // all of the Sids, sorting them into Work Items as we go.
    // For each Sid, follow the steps detailed below.
    //

    for (SidIndex = 0; SidIndex < Count; SidIndex++) {

        //
        // If this Sid's Domain is already marked as known, skip.
        //

        if (TranslatedNames->Names[SidIndex].DomainIndex != LSA_UNKNOWN_INDEX) {

            continue;
        }

        //
        // Sid is completely unknown.  Extract its Domain Sid and see if
        // there is already a Work Item for its Domain.
        //

        Sid = Sids[SidIndex];

        Status = LsapRtlExtractDomainSid( Sid, &DomainSid );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        NextWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM) OutputWorkList->AnchorWorkItem->Links.Flink;
        AnchorWorkItem = OutputWorkList->AnchorWorkItem;
        WorkItemToUpdate = NULL;
        NewWorkItem = NULL;

        while (NextWorkItem != AnchorWorkItem) {

            if (RtlEqualSid((PSID) NextWorkItem->TrustInformation.Sid,DomainSid)) {

                //
                // A Work Item already exists for the Sid's Trusted Domain.
                // Select that Work Item for update.
                //

                MIDL_user_free(DomainSid);
                DomainSid = NULL;
                WorkItemToUpdate = NextWorkItem;
                break;
            }

            //
            // Sid's domain not found among existing Work Items.  Skip to
            // next Work Item.
            //

            NextWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM) NextWorkItem->Links.Flink;
        }

        if (WorkItemToUpdate == NULL) {

            //
            // No Work Item exists for the Sid's Domain.  See if the
            // Sid belongs to one of the Trusted Domains.  If not, skip
            // to the next Sid.
            //
            ULONG Flags = LSAP_LOOKUP_DOMAIN_TRUST_DIRECT_EXTERNAL;
            if (fIncludeIntraforest) {
                Flags = LSAP_LOOKUP_DOMAIN_TRUST_DIRECT_INTRA;
            }

            Status = LsapDomainHasDomainTrust(Flags,
                                              NULL,
                                              DomainSid,
                                              &AcquiredReadLockTrustedDomainList,
                                              &TrustEntry);
            MIDL_user_free(DomainSid);
            DomainSid = NULL;

            if (Status == STATUS_NO_SUCH_DOMAIN) {
                Status = STATUS_SUCCESS;
                continue;
            }

            if ( !NT_SUCCESS(Status) ) {
                break;
            }

            //
            // If the trust is not outbound, don't try to lookup
            //
            ASSERT( NULL != TrustEntry );
            if ( !FLAG_ON( TrustEntry->TrustInfoEx.TrustDirection, TRUST_DIRECTION_OUTBOUND ) ) {

                Status = STATUS_SUCCESS;
                continue;
                
            }
            ASSERT( NULL != TrustEntry->TrustInfoEx.Sid );
            TrustInformation = &TrustEntry->ConstructedTrustInfo;

            //
            // Sid belongs to a Trusted Domain for which there is
            // no Work Item.  Add the Domain to the Referenced Domain List
            // and obtain a Domain Index.
            //

            Status = LsapDbLookupAddListReferencedDomains(
                         ReferencedDomains,
                         TrustInformation,
                         &DomainIndex
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            //
            // Create a new Work Item for this domain.
            //

            Status = LsapDbLookupCreateWorkItem(
                         TrustInformation,
                         DomainIndex,
                         (ULONG) LSAP_DB_LOOKUP_WORK_ITEM_GRANULARITY + (ULONG) 1,
                         &NewWorkItem
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            //
            // Add the Work Item to the List.
            //

            Status = LsapDbAddWorkItemToWorkList( OutputWorkList, NewWorkItem );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            WorkItemToUpdate = NewWorkItem;
        }

        if (!NT_SUCCESS(Status)) {

            break;
        }

        //
        // Add the Sid Index to the Work Item.
        //

        Status = LsapDbLookupAddIndicesToWorkItem(
                     WorkItemToUpdate,
                     (ULONG) 1,
                     &SidIndex
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        //
        // Store the Domain Index in the Translated Names array entry for
        // the Sid.
        //

        OutputWorkList->LookupSidsParams.TranslatedNames->Names[SidIndex].DomainIndex = WorkItemToUpdate->DomainIndex;
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsBuildWorkListError;
    }

    //
    // If the Work List has no Work Items, this means that none of the
    // Sids belong to any of the Trusted Domains.  In this case,
    // we discard the Work List.
    //

    Status = STATUS_NONE_MAPPED;

    if (OutputWorkList->WorkItemCount == 0) {

        goto LookupSidsBuildWorkListError;
    }

    //
    // Compute the Advisory Thread Count for this lookup.
    //

    Status = LsapDbLookupComputeAdvisoryChildThreadCount( OutputWorkList );

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsBuildWorkListError;
    }

    //
    // Insert the Work List at the end of the Work Queue.
    //

    Status = LsapDbLookupInsertWorkList(OutputWorkList);

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsBuildWorkListError;
    }

    //
    // Update the Mapped Counts
    //

    LsapDbUpdateMappedCountsWorkList( OutputWorkList );

    *WorkList = OutputWorkList;

LookupSidsBuildWorkListFinish:

    //
    // If necessary, release the Trusted Domain List Read Lock.
    //

    if (DomainSid) {
        midl_user_free(DomainSid);
    }

    if (AcquiredReadLockTrustedDomainList) {

        LsapDbReleaseLockTrustedDomainList();
        AcquiredReadLockTrustedDomainList = FALSE;
    }

    return(Status);

LookupSidsBuildWorkListError:

    if ( OutputWorkList != NULL ) {

        IgnoreStatus = LsapDbLookupDeleteWorkList( OutputWorkList );
        OutputWorkList = NULL;
    }

    *WorkList = NULL;
    goto LookupSidsBuildWorkListFinish;
}


NTSTATUS
LsapDbLookupXForestSidsBuildWorkList(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList
    )
/*++

Routine Description:
                                               
    This function constructs a Work List for a Lookup SID request that contains
    names that need to be resolved at cross forest domains.  This routine, 
    hence is only called on DC's in the root of forest.
    
    N.B.  The trust information is the name of the target trusted forest,
    not the domain since we don't know the domain at this point.
    
Parameters:
    

    Count - Number of Sids in the Sids array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Sids - Pointer to array of pointers to Sids to be translated.
        Zero or all of the Sids may already have been translated
        elsewhere.  If any of the Sids have been translated, the

        Names parameter will point to a location containing a non-NULL
        array of Name translation structures corresponding to the
        Sids.  If the nth Sid has been translated, the nth name
        translation structure will contain either a non-NULL name
        or a non-negative offset into the Referenced Domain List.  If
        the nth Sid has not yet been translated, the nth name
        translation structure will contain a zero-length name string
        and a negative value for the Referenced Domain List index.

    TrustInformation - Pointer to Trust Information specifying a Domain Sid
        and Name.

    ReferencedDomains - Pointer to a Referenced Domain List structure.
        The structure references an array of zero or more Trust Information
        entries, one per referenced domain.  This array will be appended to
        or reallocated if necessary.

    TranslatedNames - Pointer to structure that optionally references a list
        of name translations for some of the Sids in the Sids array.

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.

    MappedCount - Pointer to location containing the number of Sids
        in the Sids array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Sids.  A Sid is completely unmapped
        if it is unknown and also its Domain Prefix Sid is not recognized.
        This count is updated on exit, the number of completely unmapped
        Sids whose Domain Prefices are identified by this routine being
        subtracted from the input value.

    WorkList - Receives pointer to completed Work List if successfully built.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_NONE_MAPPED - None of the Sids specified belong to any of
            the Trusted Domains.  No Work List has been generated.  Note
            that this is not a fatal error.
--*/


{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus = STATUS_SUCCESS;
    PLSAP_DB_LOOKUP_WORK_LIST OutputWorkList = NULL;
    ULONG SidIndex;
    PSID DomainSid = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM AnchorWorkItem = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM NextWorkItem = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM WorkItemToUpdate = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM NewWorkItem = NULL;
    PLSAPR_TRUST_INFORMATION TrustInformation = NULL;
    LSAPR_TRUST_INFORMATION TrustInfo;
    LONG DomainIndex;
    PSID Sid = NULL;
    UNICODE_STRING XForestName = {0, 0, NULL};

    //
    // Create an empty Work List
    //

    Status = LsapDbLookupCreateWorkList(&OutputWorkList);

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsBuildWorkListError;
    }

    //
    // Initialize the rest of the Work List Header fields.  Some fields
    // were initialized upon creation to fixed values.  The ones set here
    // depend on parameter values passed into this routine.
    //

    OutputWorkList->LookupType = LookupSids;
    OutputWorkList->Count = Count;
    OutputWorkList->LookupLevel = LookupLevel;
    OutputWorkList->ReferencedDomains = ReferencedDomains;
    OutputWorkList->MappedCount = MappedCount;
    OutputWorkList->CompletelyUnmappedCount = CompletelyUnmappedCount;
    OutputWorkList->LookupSidsParams.Sids = Sids;
    OutputWorkList->LookupSidsParams.TranslatedNames = TranslatedNames;

    //
    // Construct the array of Work Items.  Each Work Item will
    // contain all the Sids for a given domain, so we will scan
    // all of the Sids, sorting them into Work Items as we go.
    // For each Sid, follow the steps detailed below.
    //

    for (SidIndex = 0; SidIndex < Count; SidIndex++) {

        ULONG Length;
        ULONG DomainSidBuffer[SECURITY_MAX_SID_SIZE/sizeof( ULONG ) + 1 ];

        //
        // Sid is completely unknown.  Extract its Domain Sid and see if
        // there is already a Work Item for its Domain.
        //

        Sid = Sids[SidIndex];
        
        //
        // Extract the domain portion of the SID and see if it matches
        // one of our cross forest domains.
        //
        
        Length = sizeof(DomainSidBuffer);
        DomainSid = (PSID)DomainSidBuffer;
        if (!GetWindowsAccountDomainSid(Sid, DomainSid, &Length)) {
            continue;
        }
        Status = LsaIForestTrustFindMatch(RoutingMatchDomainSid,
                                          (PVOID)DomainSid,
                                          &XForestName);

        if (!NT_SUCCESS(Status)) {
            //
            // Can't find match? Continue
            //
            Status = STATUS_SUCCESS;
            continue;
        }

        NextWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM) OutputWorkList->AnchorWorkItem->Links.Flink;
        AnchorWorkItem = OutputWorkList->AnchorWorkItem;
        WorkItemToUpdate = NULL;
        NewWorkItem = NULL;

        while (NextWorkItem != AnchorWorkItem) {


            if (RtlEqualDomainName(
                    (PUNICODE_STRING) &NextWorkItem->TrustInformation.Name,
                    (PUNICODE_STRING) &XForestName
                    ))  {

                //
                // A Work Item already exists for the Sid's Trusted Domain.
                // Select that Work Item for update.
                //
                WorkItemToUpdate = NextWorkItem;
                break;
            }

            //
            // Sid's domain not found among existing Work Items.  Skip to
            // next Work Item.
            //

            NextWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM) NextWorkItem->Links.Flink;
        }

        if (WorkItemToUpdate == NULL) {

            //
            // No Work Item exists for the Sid's Domain.  See if the
            // Sid belongs to one of the Trusted Domains.  If not, skip
            // to the next Sid.
            //


           RtlZeroMemory( &TrustInfo, sizeof(TrustInfo) );
           TrustInfo.Name.Length = XForestName.Length;
           TrustInfo.Name.MaximumLength = XForestName.MaximumLength;
           TrustInfo.Name.Buffer = XForestName.Buffer;
           TrustInfo.Sid = NULL;
           TrustInformation = &TrustInfo;
            //
            // Create a new Work Item for this domain.
            //

            Status = LsapDbLookupCreateWorkItem(
                         TrustInformation,
                         LSA_UNKNOWN_INDEX,
                         (ULONG) LSAP_DB_LOOKUP_WORK_ITEM_GRANULARITY + (ULONG) 1,
                         &NewWorkItem
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            //
            // Add the Work Item to the List.
            //

            Status = LsapDbAddWorkItemToWorkList( OutputWorkList, NewWorkItem );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            WorkItemToUpdate = NewWorkItem;

            NewWorkItem->Properties |= LSAP_DB_LOOKUP_WORK_ITEM_XFOREST;
        }

        LsaIFree_LSAPR_UNICODE_STRING_BUFFER( (LSAPR_UNICODE_STRING*)&XForestName);
        XForestName.Buffer = NULL;

        //
        // Add the Sid Index to the Work Item.
        //

        Status = LsapDbLookupAddIndicesToWorkItem(
                     WorkItemToUpdate,
                     (ULONG) 1,
                     &SidIndex
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        //
        // Store the Domain Index in the Translated Names array entry for
        // the Sid.
        //

        OutputWorkList->LookupSidsParams.TranslatedNames->Names[SidIndex].DomainIndex = WorkItemToUpdate->DomainIndex;
    }

    if (XForestName.Buffer) {
        LsaIFree_LSAPR_UNICODE_STRING_BUFFER( (LSAPR_UNICODE_STRING*)&XForestName);
        XForestName.Buffer = NULL;
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsBuildWorkListError;
    }

    //
    // If the Work List has no Work Items, this means that none of the
    // Sids belong to any of the Trusted Domains.  In this case,
    // we discard the Work List.
    //

    Status = STATUS_NONE_MAPPED;

    if (OutputWorkList->WorkItemCount == 0) {

        goto LookupSidsBuildWorkListError;
    }

    //
    // Compute the Advisory Thread Count for this lookup.
    //

    Status = LsapDbLookupComputeAdvisoryChildThreadCount( OutputWorkList );

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsBuildWorkListError;
    }

    //
    // Insert the Work List at the end of the Work Queue.
    //

    Status = LsapDbLookupInsertWorkList(OutputWorkList);

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsBuildWorkListError;
    }

    //
    // Update the Mapped Counts
    //

    LsapDbUpdateMappedCountsWorkList( OutputWorkList );

    *WorkList = OutputWorkList;

LookupSidsBuildWorkListFinish:


    return(Status);

LookupSidsBuildWorkListError:

    if ( OutputWorkList != NULL ) {

        IgnoreStatus = LsapDbLookupDeleteWorkList( OutputWorkList );
        OutputWorkList = NULL;
    }

    *WorkList = NULL;
    goto LookupSidsBuildWorkListFinish;
}


NTSTATUS
LsapDbLookupCreateWorkList(
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList
    )

/*++

Routine Description:

    This function creates a Lookup Operation Work List and
    initializes fixed default fields.

Arguments:

    WorkList - Receives Pointer to an empty Work List structure.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Allocate memory for the Work List header.
    //

    *WorkList = LsapAllocateLsaHeap( sizeof(LSAP_DB_LOOKUP_WORK_LIST) );

    if ( *WorkList == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        //
        // Initialize the fixed fields in the Work List.
        //
        Status = LsapDbLookupInitializeWorkList(*WorkList);
    }


    return(Status);
}


NTSTATUS
LsapDbLookupInsertWorkList(
    IN PLSAP_DB_LOOKUP_WORK_LIST WorkList
    )

/*++

Routine Description:

    This function inserts a Lookup Operation Work List in the Work Queue.

Arguments:

    WorkList - Pointer to a Work List structure describing a Lookup Sids
        or Lookup Names operation.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN AcquiredWorkQueueLock = FALSE;

    //
    // Acquire the Lookup Work Queue Lock.
    //

    Status = LsapDbLookupAcquireWorkQueueLock();

    if (!NT_SUCCESS(Status)) {

        goto LookupInsertWorkListError;
    }

    AcquiredWorkQueueLock = TRUE;

    //
    // Mark the Work List as Active.
    //

    WorkList->State = ActiveWorkList;

    //
    // Link the Work List onto the end of the Work Queue.
    //

    WorkList->WorkLists.Flink =
        (PLIST_ENTRY) LookupWorkQueue.AnchorWorkList;
    WorkList->WorkLists.Blink =
        (PLIST_ENTRY) LookupWorkQueue.AnchorWorkList->WorkLists.Blink;

    WorkList->WorkLists.Flink->Blink = (PLIST_ENTRY) WorkList;
    WorkList->WorkLists.Blink->Flink = (PLIST_ENTRY) WorkList;

    //
    // Update the Currently Assignable Work List and Work Item pointers
    // if there is none.
    //

    if (LookupWorkQueue.CurrentAssignableWorkList == NULL) {

        LookupWorkQueue.CurrentAssignableWorkList = WorkList;
        LookupWorkQueue.CurrentAssignableWorkItem =
            (PLSAP_DB_LOOKUP_WORK_ITEM) WorkList->AnchorWorkItem->Links.Flink;
    }


    //
    // Diagnostic message indicating work list has been inserted
    //

    LsapDiagPrint( DB_LOOKUP_WORK_LIST,
                   ("LSA DB: Inserting WorkList: 0x%lx ( Item Count: %ld)\n", WorkList, WorkList->WorkItemCount) );


LookupInsertWorkListFinish:

    //
    // If necessary, release the Lookup Work Queue Lock.
    //

    if (AcquiredWorkQueueLock) {

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;
    }

    return(Status);

LookupInsertWorkListError:

    goto LookupInsertWorkListFinish;
}


NTSTATUS
LsapDbLookupDeleteWorkList(
    IN PLSAP_DB_LOOKUP_WORK_LIST WorkList
    )

/*++

Routine Description:

    This function Deletes a Lookup Operation Work List from the Work Queue
    and frees the Work List structure.

Arguments:

    WorkList - Pointer to a Work List structure describing a Lookup Sids
        or Lookup Names operation.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_LOOKUP_WORK_ITEM ThisWorkItem = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM NextWorkItem = NULL;
    BOOLEAN AcquiredWorkQueueLock = FALSE;

    //
    // Acquire the Lookup Work Queue Lock.
    //

    Status = LsapDbLookupAcquireWorkQueueLock();

    if (!NT_SUCCESS(Status)) {

        goto LookupDeleteWorkListError;
    }

    AcquiredWorkQueueLock = TRUE;

    //
    // An internal error exists if we are trying to delete an active Work List.
    // Only inactive or completed Work Lists can be removed.
    //

    ASSERT(WorkList->State != ActiveWorkList);

    //
    // If the Work List is on the Work Queue, remove it.
    //

    if ((WorkList->WorkLists.Blink != NULL) &&
        (WorkList->WorkLists.Flink != NULL)) {

        WorkList->WorkLists.Blink->Flink = WorkList->WorkLists.Flink;
        WorkList->WorkLists.Flink->Blink = WorkList->WorkLists.Blink;
    }

    //
    // Release the Lookup Work Queue Lock.
    //

    LsapDbLookupReleaseWorkQueueLock();
    AcquiredWorkQueueLock = FALSE;

    //
    // Free up memory allocated for the Work Items on the List.
    //

    ThisWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM) WorkList->AnchorWorkItem->Links.Blink;

    while (ThisWorkItem != WorkList->AnchorWorkItem) {

        NextWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM) ThisWorkItem->Links.Blink;

        if (ThisWorkItem->Indices != NULL) {

            MIDL_user_free( ThisWorkItem->Indices );
        }

        MIDL_user_free( ThisWorkItem->TrustInformation.Sid );

        MIDL_user_free( ThisWorkItem->TrustInformation.Name.Buffer );

        MIDL_user_free( ThisWorkItem );

        ThisWorkItem = NextWorkItem;
    }

    //
    // Release the handle
    //

    if ( WorkList->LookupCompleteEvent ) {

        NtClose( WorkList->LookupCompleteEvent );
    }

    //
    // Free up memory allocated for the Work List structure itself.
    //

    MIDL_user_free( WorkList );

LookupDeleteWorkListFinish:

    //
    // If necessary, release the Lookup Work Queue Lock.
    //

    if (AcquiredWorkQueueLock) {

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;
    }

    return(Status);

LookupDeleteWorkListError:

    goto LookupDeleteWorkListFinish;
}


VOID
LsapDbUpdateMappedCountsWorkList(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    )

/*++

Routine Decsription:

    This function updates the counts of completely Mapped and completely
    Unmapped Sids or Names in a Work List.  A Sid or Name is completely
    mapped if its Use has been identified, partially mapped if its
    Domain is known but its terminal name of relative id is not yet
    known, completely unmapped if its domain is not yet known.

Arguments:

    WorkList - Pointer to Work List to be updated.

Return Values:

    None.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN AcquiredWorkQueueLock = FALSE;
    ULONG OutputMappedCount = (ULONG) 0;
    ULONG OutputCompletelyUnmappedCount = WorkList->Count;
    ULONG Index;

    //
    // Acquire the Lookup Work Queue Lock.
    //

    Status = LsapDbLookupAcquireWorkQueueLock();

    if (!NT_SUCCESS(Status)) {

        goto UpdateMappedCountsWorkListError;
    }

    AcquiredWorkQueueLock = TRUE;

    if (WorkList->LookupType == LookupSids) {

        for ( Index = (ULONG) 0; Index < WorkList->Count; Index++ ) {

            if (WorkList->LookupSidsParams.TranslatedNames->Names[ Index].Use
                   != SidTypeUnknown) {

                OutputMappedCount++;
                OutputCompletelyUnmappedCount--;

            } else if (WorkList->LookupSidsParams.TranslatedNames->Names[ Index].DomainIndex
                           != LSA_UNKNOWN_INDEX) {

                OutputCompletelyUnmappedCount--;
            }
        }

    } else {

        for ( Index = (ULONG) 0; Index < WorkList->Count; Index++ ) {

            if (WorkList->LookupNamesParams.TranslatedSids->Sids[ Index].Use
                   != SidTypeUnknown) {

                OutputMappedCount++;
                OutputCompletelyUnmappedCount--;

            } else if (WorkList->LookupNamesParams.TranslatedSids->Sids[ Index].DomainIndex
                           != LSA_UNKNOWN_INDEX) {

                OutputCompletelyUnmappedCount--;
            }
        }
    }

    *WorkList->MappedCount = OutputMappedCount;
    *WorkList->CompletelyUnmappedCount = OutputCompletelyUnmappedCount;

UpdateMappedCountsWorkListFinish:

    if (AcquiredWorkQueueLock) {

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;
    }

    return;

UpdateMappedCountsWorkListError:

    goto UpdateMappedCountsWorkListFinish;
}


NTSTATUS
LsapDbLookupSignalCompletionWorkList(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    )

/*++

Routine Description:

    This function signals the completion or termination of work on
    a Work List.

Arguments:

    WorkList - Pointer to a Work List structure describing a Lookup Sids
        or Lookup Names operation.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN AcquiredWorkQueueLock = FALSE;

    //
    // Verify that all work on the Work List is either complete or
    // the Work List has been terminated.
    //

    Status = LsapDbLookupAcquireWorkQueueLock();

    if (!NT_SUCCESS(Status)) {

        goto LookupSignalCompletionWorkListError;
    }

    AcquiredWorkQueueLock = TRUE;

    if (NT_SUCCESS(WorkList->Status)) {

        Status = STATUS_INTERNAL_DB_ERROR;

        if (WorkList->CompletedWorkItemCount != WorkList->WorkItemCount) {

            goto LookupSignalCompletionWorkListError;
        }
    }

    //
    // Signal the event that indicates that a Work List has been processed.
    //

    Status = NtSetEvent( WorkList->LookupCompleteEvent, NULL );


    if (!NT_SUCCESS(Status)) {

        LsapDiagPrint( DB_LOOKUP_WORK_LIST,
                     ("LSA DB: LsapDbLookupSignalCompletion.. NtSetEvent failed 0x%lx\n",Status));
        goto LookupSignalCompletionWorkListError;
    }

LookupSignalCompletionWorkListFinish:


    LsapDiagPrint( DB_LOOKUP_WORK_LIST,
                   ("LSA DB: Lookup completion event signalled. (Status: 0x%lx)\n"
                    "            WorkList: 0x%lx\n", Status, WorkList) );

    //
    // If necessary, release the Lookup Work Queue Lock.
    //

    if (AcquiredWorkQueueLock) {

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;
    }

    return(Status);

LookupSignalCompletionWorkListError:

    goto LookupSignalCompletionWorkListFinish;
}


NTSTATUS
LsapDbLookupAwaitCompletionWorkList(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    )

/*++

Routine Description:

    This function awaits the completion or termination of work on a
    specified Work List.

    NOTE:  This routine expects the specified pointer to a Work List to be
           valid.  A Work List pointer always remains valid until its
           Primary thread detects completion of the Work List via this
           routine and then deletes it via LsapDbLookupDeleteWorkList().
           For this reason, the Lookup Work Queue lock does not have to
           be held while this routine executes.

Arguments:

    WorkList - Pointer to a Work List structure describing a Lookup Sids
        or Lookup Names operation.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_LOOKUP_WORK_LIST_STATE WorkListState;
    BOOLEAN AcquiredWorkQueueLock = FALSE;

    //
    // Loop, waiting for completion events to occur.  When one does,
    // check the status of the specified Work List.
    //

    for (;;) {

        //
        // Check for completed Work List.  Since someone else may be
        // setting the state, we need to read it while holding the lock.
        //

        Status = LsapDbLookupAcquireWorkQueueLock();

        if (!NT_SUCCESS(Status)) {

            break;
        }

        AcquiredWorkQueueLock = TRUE;

        WorkListState = WorkList->State;

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;

        if (WorkListState == CompletedWorkList) {

            break;
        }

        //
        // Wait for Work List completed event to be signalled.
        //

        LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("Lsa Db: Waiting on worklist completion event\n") );
        Status = NtWaitForSingleObject( WorkList->LookupCompleteEvent, TRUE, NULL);
        LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LsapDb: Wait on worklist completion event Done\n        Status: 0x%lx\n", Status) );

        if (!NT_SUCCESS(Status)) {

            break;
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupAwaitCompletionWorkListError;
    }

LookupAwaitCompletionWorkListFinish:

    //
    // If necessary, release the Lookup Work Queue Lock.
    //

    if (AcquiredWorkQueueLock) {

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;
    }

    return(Status);

LookupAwaitCompletionWorkListError:


    LsapDiagPrint( DB_LOOKUP_WORK_LIST,
                   ("Lsa Db: LookupAwaitWorklist error. (Status: 0x%lx)\n", Status) );

    goto LookupAwaitCompletionWorkListFinish;
}


NTSTATUS
LsapDbAddWorkItemToWorkList(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList,
    IN PLSAP_DB_LOOKUP_WORK_ITEM WorkItem
    )

/*++

Routine Decsription:

    This function adds a Work Item to a Work List.  The specified
    Work Item must exist in non-volatile memory (e.g a heap block).

Arguments:

    WorkList - Pointer to a Work List structure describing a Lookup Sids
        or Lookup Names operation.

    WorkItem - Pointer to a Work Item structure describing a list of
        Sids or Names and a domain in which they are to be looked up.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN AcquiredWorkQueueLock = FALSE;

    //
    // Acquire the Lookup Work Queue Lock.
    //

    Status = LsapDbLookupAcquireWorkQueueLock();

    if (!NT_SUCCESS(Status)) {

        goto LookupAddWorkItemToWorkListError;
    }

    AcquiredWorkQueueLock = TRUE;

    //
    // Mark the Work Item as assignable.
    //

    WorkItem->State = AssignableWorkItem;

    //
    // Link the Work Item onto the end of the Work List and increment the
    // Work Item Count.
    //

    WorkItem->Links.Flink = (PLIST_ENTRY) WorkList->AnchorWorkItem;
    WorkItem->Links.Blink = (PLIST_ENTRY) WorkList->AnchorWorkItem->Links.Blink;
    WorkItem->Links.Flink->Blink = (PLIST_ENTRY) WorkItem;
    WorkItem->Links.Blink->Flink = (PLIST_ENTRY) WorkItem;

    WorkList->WorkItemCount++;

LookupAddWorkItemToWorkListFinish:

    //
    // If necessary, release the Lookup Work Queue Lock.
    //

    if (AcquiredWorkQueueLock) {

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;
    }

    return(Status);

LookupAddWorkItemToWorkListError:

    goto LookupAddWorkItemToWorkListFinish;
}


VOID
LsapDbLookupWorkerThreadStart(
    )

/*++

Routine Description:

    This routine initiates a child Worker Thread for a Lookup operation.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // Start the thread's work processing loop, specifying that this
    // thread is a child thread rather than the main thread.
    //

    LsapDbLookupWorkerThread( FALSE );
}


VOID
LsapDbLookupWorkerThread(
    IN BOOLEAN PrimaryThread
    )

/*++

Routine Description:

    This function is executed by each worker thread for a Lookup operation.
    Each worker thread loops, requesting work items from the Lookup
    Work Queue.  Work Items assigned may belong to any current lookup.

Arguments:

    PrimaryThread - TRUE if thread is the main thread of the Lookup
        operation, FALSE if the thread is a child thread created by
        the Lookup operation.  The main thread of the Lookup operation
        also processes work items, but is also responsible for collating
        the results of the Lookup operation.  It is not counted in the
        active thread count and is not returnable to the thread pool.

Return Value:

    None.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_LOOKUP_WORK_LIST WorkList = NULL;
    PLSAP_DB_LOOKUP_WORK_ITEM WorkItem = NULL;
    BOOLEAN AcquiredWorkQueueLock = FALSE;

    //
    // If this thread is a child worker thread, increment count of active
    // child threads.
    //

    if (!PrimaryThread) {

        Status = LsapDbLookupAcquireWorkQueueLock();

        if (!NT_SUCCESS(Status)) {

            goto LookupWorkerThreadError;
        }

        AcquiredWorkQueueLock = TRUE;

        LookupWorkQueue.ActiveChildThreadCount++;

        LsapDbLookupReleaseWorkQueueLock();

        AcquiredWorkQueueLock = FALSE;
    }

    //
    // Loop while there is work to do.
    //

    for (;;) {

        //
        // Obtain work packet
        //

        Status = LsapDbLookupObtainWorkItem(&WorkList, &WorkItem);

        if (NT_SUCCESS(Status)) {

            Status = LsapDbLookupProcessWorkItem(WorkList, WorkItem);

            if (NT_SUCCESS(Status)) {

                continue;
            }

            //
            // An error has occurred.  Stop this lookup.
            //

            Status = LsapDbLookupStopProcessingWorkList(WorkList, Status);

            //
            // NOTE:  Intentionally ignore the status.
            //

            Status = STATUS_SUCCESS;
        }

        //
        // If an error occurred other than there being no more work to do,
        // quit.
        //

        if (Status != STATUS_NO_MORE_ENTRIES) {

            break;
        }

        Status = STATUS_SUCCESS;

        //
        // There is no more work to do.  If this thread is a child worker
        // thread, either return thread to pool and wait for more work, or
        // terminate if enough threads have already been retained.  If this
        // thread is the main thread of a Lookup operation, just return
        // in order to collate results.
        //

        if (!PrimaryThread) {

            Status = LsapDbLookupAcquireWorkQueueLock();

            if (!NT_SUCCESS(Status)) {

                break;
            }

            AcquiredWorkQueueLock = TRUE;

            if (LookupWorkQueue.ActiveChildThreadCount <= LookupWorkQueue.MaximumRetainedChildThreadCount) {

                LsapDbLookupReleaseWorkQueueLock();
                AcquiredWorkQueueLock = FALSE;

                //
                // Wait forever for more work.
                //

                Status = NtWaitForSingleObject( LsapDbLookupStartedEvent, TRUE, NULL);

                if (NT_SUCCESS(Status)) {

                    continue;
                }

                //
                // An error occurred in the wait routine. Exit the thread.
                //

                Status = LsapDbLookupAcquireWorkQueueLock();

                if (!NT_SUCCESS(Status)) {

                    break;
                }

                AcquiredWorkQueueLock = TRUE;
            }

            //
            // We already have enough active threads or an error has occurred.
            // Mark this one inactive and terminate it.
            //

            LookupWorkQueue.ActiveChildThreadCount--;

            LsapDbLookupReleaseWorkQueueLock();
            AcquiredWorkQueueLock = FALSE;

            //
            // Terminate the thread.
            //

            ExitThread((DWORD) Status);
        }

        //
        // We're the Primary Thread of some Lookup operation and there is
        // no more work to do.  Break out so we can return to caller.
        //

        break;
    }

LookupWorkerThreadFinish:

    //
    // If necessary, release the Lookup Work Queue Lock.
    //

    if (AcquiredWorkQueueLock) {

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;
    }

    return;

LookupWorkerThreadError:

    goto LookupWorkerThreadFinish;
}


NTSTATUS
LsapDbLookupObtainWorkItem(
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList,
    OUT PLSAP_DB_LOOKUP_WORK_ITEM *WorkItem
    )

/*++

Routine Description:

    This function is called by a worker thread to obtain a Work Item.  This
    Work Item may belong to any current lookup operation.

Arguments:

    WorkList - Receives a pointer to a Work List structure describing a
        Lookup Sids or Lookup Names operation.

    WorkItem - Receives a pointer to a Work Item structure describing a
        list of Sids or Names and a domain in which they are to be looked up.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_NO_MORE_ENTRIES - No more work items available.
--*/

{
    NTSTATUS Status;
    BOOLEAN AcquiredWorkQueueLock = FALSE;
    *WorkList = NULL;
    *WorkItem = NULL;

    //
    // Acquire the Lookup Work Queue Lock.
    //

    Status = LsapDbLookupAcquireWorkQueueLock();

    if (!NT_SUCCESS(Status)) {

        goto LookupObtainWorkItemError;
    }

    AcquiredWorkQueueLock = TRUE;

    //
    // Return an error if there are no more Work Items.
    //

    Status = STATUS_NO_MORE_ENTRIES;

    if (LookupWorkQueue.CurrentAssignableWorkList == NULL) {

        goto LookupObtainWorkItemError;
    }

    //
    // Verify that the Current Assignable Work List does not have
    // a termination error.  This should never happen, because the
    // pointers should be updated if the Lookup corresponding to the Current
    // Assignable Work List is terminated.
    //

    ASSERT(NT_SUCCESS(LookupWorkQueue.CurrentAssignableWorkList->Status));

    //
    // There are work items available.  Check the next one out.
    //

    ASSERT(LookupWorkQueue.CurrentAssignableWorkItem->State == AssignableWorkItem);
    LookupWorkQueue.CurrentAssignableWorkItem->State = AssignedWorkItem;
    *WorkList = LookupWorkQueue.CurrentAssignableWorkList;
    *WorkItem = LookupWorkQueue.CurrentAssignableWorkItem;

    //
    // Update pointers to next item (if any) in the current Work List
    // where work is being given out.
    //

    Status = LsapDbLookupUpdateAssignableWorkItem(FALSE);

    if (!NT_SUCCESS(Status)) {

        goto LookupObtainWorkItemError;
    }

LookupObtainWorkItemFinish:

    //
    // If we acquired the Lookup Work Queue Lock, release it.
    //

    if (AcquiredWorkQueueLock) {

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;
    }

    return(Status);

LookupObtainWorkItemError:

    goto LookupObtainWorkItemFinish;
}


NTSTATUS
LsapDbLookupProcessWorkItem(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList,
    IN OUT PLSAP_DB_LOOKUP_WORK_ITEM WorkItem
    )

/*++

Routine Description:

    This function processes a Work Item for a Lookup operation.  The Work
    Item specifies a number of Sids or Names to be looked up in a given
    domain.

Arguments:

    WorkList - Pointer to a Work List structure describing a
        Lookup Sids or Lookup Names operation.

    WorkItem - Pointer to a Work Item structure describing a
        list of Sids or Names and a domain in which they are to be looked up.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SecondaryStatus = STATUS_SUCCESS;
    ULONG NextLevelCount;
    ULONG NextLevelMappedCount;
    PLSAP_BINDING_CACHE_ENTRY ControllerPolicyEntry = NULL;
    ULONG NextLevelIndex;
    PLSAPR_REFERENCED_DOMAIN_LIST NextLevelReferencedDomains = NULL;
    PSID *NextLevelSids = NULL;
    PUNICODE_STRING NextLevelNames = NULL;
    PLSAPR_REFERENCED_DOMAIN_LIST OutputReferencedDomains = NULL;
    PLSAPR_TRANSLATED_SID_EX2 NextLevelTranslatedSids = NULL;
    PLSA_TRANSLATED_NAME_EX NextLevelTranslatedNames = NULL;
    ULONG Index;
    LPWSTR ServerPrincipalName = NULL;
    LPWSTR ServerName = NULL;
    PVOID ClientContext = NULL;
    ULONG AuthnLevel = 0;
    NL_OS_VERSION ServerOsVersion;
    LSAP_LOOKUP_LEVEL LookupLevel = WorkList->LookupLevel;
    PUNICODE_STRING TargetDomainName = NULL;
    LSAPR_TRUST_INFORMATION_EX TrustInfoEx;
    BOOLEAN *NextLevelNamesMorphed = NULL;


    TargetDomainName = (PUNICODE_STRING) &WorkItem->TrustInformation.Name;

    RtlZeroMemory(&TrustInfoEx, sizeof(TrustInfoEx));
    TrustInfoEx.FlatName = WorkItem->TrustInformation.Name;
    TrustInfoEx.Sid = WorkItem->TrustInformation.Sid;

    LsapDiagPrint( DB_LOOKUP_WORK_LIST,
           ("LSA DB: Processing work item. (0x%lx, 0x%lx)\n", WorkList, WorkItem));

    ASSERT(  (WorkList->LookupLevel == LsapLookupTDL)
          || (WorkList->LookupLevel == LsapLookupXForestResolve) );


    //
    // Branch according to lookup type.
    //

    NextLevelCount = WorkItem->UsedCount;

    if (WorkList->LookupType == LookupSids) {

        //
        // Allocate an array for the Sids to be looked up at a Domain
        // Controller for the specified Trusted Domain.
        //

        NextLevelSids = MIDL_user_allocate( sizeof(PSID) * NextLevelCount );
        if (NextLevelSids == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto LookupProcessWorkItemError;
        }

        //
        // Copy in the Sids to be looked up from the Work List.  The Work
        // Item contains their indices relative to the Sid array in the
        // Work List.
        //

        for (NextLevelIndex = 0;
             NextLevelIndex < NextLevelCount;
             NextLevelIndex++) {

            Index = WorkItem->Indices[ NextLevelIndex ];
            NextLevelSids[NextLevelIndex] = WorkList->LookupSidsParams.Sids[Index];
        }

        NextLevelMappedCount = (ULONG) 0;

        //
        // Lookup the Sids at the DC.
        //
        Status = LsaDbLookupSidChainRequest(&TrustInfoEx,
                                            NextLevelCount,
                                            NextLevelSids,
                                            (PLSA_REFERENCED_DOMAIN_LIST *) &NextLevelReferencedDomains,
                                            &NextLevelTranslatedNames,
                                            WorkList->LookupLevel,
                                            &NextLevelMappedCount,
                                            NULL
                                            );

        LsapDiagPrint( DB_LOOKUP_WORK_LIST,
                   ("LSA DB: Sid Lookup.\n"
                    "            Item: (0x%lx, 0x%lx)\n"
                    "           Count: 0x%lx\n", WorkList, WorkItem, NextLevelCount));

        //
        // If the callout to LsaLookupSids() was unsuccessful, disregard
        // the error and set the domain name for any Sids having this
        // domain Sid as prefix sid.
        //

        if (!NT_SUCCESS(Status) && Status != STATUS_NONE_MAPPED) {

            SecondaryStatus = Status;
            Status = STATUS_SUCCESS;
            goto LookupProcessWorkItemFinish;
        }

        //
        // The callout to LsaICLookupSids() was successful.  Update the
        // TranslatedNames information in the Work List as appropriate
        // using the TranslatedNames information returned from the callout.
        //

        Status = LsapDbLookupSidsUpdateTranslatedNames(
                     WorkList,
                     WorkItem,
                     NextLevelTranslatedNames,
                     NextLevelReferencedDomains
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupProcessWorkItemError;
        }

    } else if (WorkList->LookupType == LookupNames) {

        //
        // Allocate an array of UNICODE_STRING structures for the
        // names to be looked up at the Domain Controller.
        //

        NextLevelNames = MIDL_user_allocate(sizeof(UNICODE_STRING) * NextLevelCount);
        if (NextLevelNames == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto LookupProcessWorkItemError;
        }


        //
        // Allocate space to remember which names are morphed in place
        // from a UPN to SamAccountName format.
        //
        NextLevelNamesMorphed = MIDL_user_allocate(sizeof(BOOLEAN) * NextLevelCount);
        if (NextLevelNamesMorphed == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto LookupProcessWorkItemError;
        }

        //
        // Copy in the Names to be looked up from the Work List.  The Work
        // Item contains their indices relative to the Names array in the
        // Work List.
        //

        for (NextLevelIndex = 0;
             NextLevelIndex < NextLevelCount;
             NextLevelIndex++) {

            Index = WorkItem->Indices[ NextLevelIndex ];
            NextLevelNames[NextLevelIndex] =
                *((PUNICODE_STRING) &WorkList->LookupNamesParams.Names[Index]);

            if ( (WorkList->LookupLevel == LsapLookupTDL)
             &&  LsapLookupIsUPN(&NextLevelNames[NextLevelIndex])) {

                //
                // We are performing a TDL level lookup.  The server side
                // of the TDL lookup's don't know how to translate UPN's
                // so morph  username@domainname to domainname\username.
                // Remember which names we morph so that we can morph
                // them back.
                // 
                // N.B.  A name would only be here if format of the UPN
                // was username@domainname, where domainname is the name
                // of the trusted domain.
                //
                LsapLookupUPNToSamAccountName(&NextLevelNames[NextLevelIndex]);
                NextLevelNamesMorphed[NextLevelIndex] = TRUE;
            } else {
                NextLevelNamesMorphed[NextLevelIndex] = FALSE;
            }

        }

        NextLevelMappedCount = (ULONG) 0;

        //
        // Lookup the Names at the DC.
        //
        Status = LsapDbLookupNameChainRequest(&TrustInfoEx,
                                              NextLevelCount,
                                              NextLevelNames,
                                              (PLSA_REFERENCED_DOMAIN_LIST *)&NextLevelReferencedDomains,
                                              (PLSA_TRANSLATED_SID_EX2 * )&NextLevelTranslatedSids,
                                              WorkList->LookupLevel,
                                              &NextLevelMappedCount,
                                              NULL
                                              );


        //
        // Upmorph any names
        //
        for (NextLevelIndex = 0; NextLevelIndex < NextLevelCount; NextLevelIndex++) {

            if (NextLevelNamesMorphed[NextLevelIndex]) {

                //
                // Morph name back to original state
                //
                LsapLookupSamAccountNameToUPN(&NextLevelNames[NextLevelIndex]);
            }
        }

        //
        // If the callout to LsaLookupNames() was unsuccessful, disregard
        // the error and set the domain name for any Sids having this
        // domain Sid as prefix sid.
        //

        if (!NT_SUCCESS(Status) && Status != STATUS_NONE_MAPPED) {

            SecondaryStatus = Status;
            Status = STATUS_SUCCESS;
            goto LookupProcessWorkItemError;
        }

        //
        // The callout to LsaICLookupNames() was successful.  Update the
        // TranslatedSids information in the Work List as appropriate
        // using the TranslatedSids information returned from the callout.
        //

        Status = LsapDbLookupNamesUpdateTranslatedSids(
                     WorkList,
                     WorkItem,
                     NextLevelTranslatedSids,
                     NextLevelReferencedDomains
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupProcessWorkItemError;
        }

    } else {

        Status = STATUS_INVALID_PARAMETER;
        goto LookupProcessWorkItemError;
    }

LookupProcessWorkItemFinish:

    //
    // If we are unable to connect to the Trusted Domain via any DC,
    // suppress the error so that the Lookup can continue to try and
    // translate other Sids/Names.
    //

    // But record what the error was in case no sids are translated
    if (!NT_SUCCESS(SecondaryStatus)) {

        NTSTATUS st;

        st = LsapDbLookupAcquireWorkQueueLock();
        ASSERT( NT_SUCCESS( st ) );
        if ( NT_SUCCESS( st ) ) {
            if ( NT_SUCCESS(WorkList->NonFatalStatus)  ) {

                //
                // Treat any error to open the open domain
                // as a trust problem
                //
                WorkList->NonFatalStatus = STATUS_TRUSTED_DOMAIN_FAILURE;
            }
            LsapDbLookupReleaseWorkQueueLock();
        }
    }

    //
    // Change the state of the work item to "Completed"
    //

    WorkItem->State = CompletedWorkItem;


    //
    // Update the Mapped Counts
    //

    LsapDbUpdateMappedCountsWorkList( WorkList );


    //
    // Protect WorkList operations
    //

    Status = LsapDbLookupAcquireWorkQueueLock();
    if (!NT_SUCCESS(Status)) {
        goto LookupProcessWorkItemError;
    }

    //
    // Increment the count of completed Work Items whether or not this
    // one was completed without error.  If the Work List has just been
    // completed, change its state to "CompletedWorkList" and signal
    // the Lookup operation completed event.  Allow re-entry into
    // this section if an error is returned.
    //

    WorkList->CompletedWorkItemCount++;


    LsapDiagPrint( DB_LOOKUP_WORK_LIST,
                   ("LSA DB: Process Work Item Completed.\n"
                    "                       Item: (0x%lx, 0x%lx)\n"
                    "            Completed Count: %ld\n", WorkList, WorkItem, WorkList->CompletedWorkItemCount));

    if (WorkList->State != CompletedWorkList) {

        if (WorkList->CompletedWorkItemCount == WorkList->WorkItemCount) {

            WorkList->State = CompletedWorkList;

            SecondaryStatus = LsapDbLookupSignalCompletionWorkList( WorkList );
        }
    }

    //
    // Done making work list changes
    //

    LsapDbLookupReleaseWorkQueueLock();


    //
    // If necessary, free the array of Sids looked up at the next level.
    //

    if (NextLevelSids != NULL) {

        MIDL_user_free( NextLevelSids );
        NextLevelSids = NULL;
    }

    //
    // If necessary, free the array of Names looked up at the next level.
    //

    if (NextLevelNames != NULL) {
        MIDL_user_free( NextLevelNames );
        NextLevelNames = NULL;
    }

    if (NextLevelReferencedDomains != NULL) {
        MIDL_user_free( NextLevelReferencedDomains );
        NextLevelReferencedDomains = NULL;
    }

    if (NextLevelTranslatedNames != NULL) {
        MIDL_user_free( NextLevelTranslatedNames );
        NextLevelTranslatedNames = NULL;
    }

    if (NextLevelTranslatedSids != NULL) {
        MIDL_user_free( NextLevelTranslatedSids );
        NextLevelTranslatedSids = NULL;
    }

    if (NextLevelNamesMorphed != NULL) {
        MIDL_user_free( NextLevelNamesMorphed );
    }

    return(Status);

LookupProcessWorkItemError:

    goto LookupProcessWorkItemFinish;
}


NTSTATUS
LsapDbLookupSidsUpdateTranslatedNames(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList,
    IN OUT PLSAP_DB_LOOKUP_WORK_ITEM WorkItem,
    IN PLSA_TRANSLATED_NAME_EX TranslatedNames,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains
    )

/*++

Routine Description:

    This function is called during the processing of a Work Item to update
    the output TranslatedNames and ReferencedDomains parameters of a
    Lookup operation's Work List with the results of a callout to
    LsaICLookupNames.  Zero or more Sids may have been translated.  Note
    that, unlike the translation of Names, Sid translation occurs within
    a single Work Item only.

Arguments:

    WorkList - Pointer to a Work List

    WorkItem - Pointer to a Work Item.

    TranslatedNames - Translated Sids information returned from
        LsaICLookupSids().

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index, WorkItemIndex;
    BOOLEAN AcquiredWorkQueueLock = FALSE;
    PLSAPR_TRANSLATED_NAME_EX WorkListTranslatedNames =
        WorkList->LookupSidsParams.TranslatedNames->Names;

    //
    // Acquire the Work Queue Lock.
    //

    Status = LsapDbLookupAcquireWorkQueueLock();

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsUpdateTranslatedNamesError;
    }

    AcquiredWorkQueueLock = TRUE;

    for( WorkItemIndex = 0;
         WorkItemIndex < WorkItem->UsedCount;
         WorkItemIndex++) {

        //
        // If this Sid has been fully translated, copy information to output.
        // Note that the Sid is partially translated during the building
        // phase where its Domain is identified.
        //

        if (TranslatedNames[WorkItemIndex].Use != SidTypeUnknown) {

            ULONG LocalDomainIndex;

            Index = WorkItem->Indices[WorkItemIndex];

            if (TranslatedNames[WorkItemIndex].DomainIndex != LSA_UNKNOWN_INDEX) {
    
                //
                // Make sure this is in the referenced domains list
                //
                Status = LsapDbLookupAddListReferencedDomains(
                             WorkList->ReferencedDomains,
                             &ReferencedDomains->Domains[TranslatedNames[WorkItemIndex].DomainIndex],
                             (PLONG) &LocalDomainIndex
                             );
    
                if (!NT_SUCCESS(Status)) {
    
                    break;
                }
            } else {

                LocalDomainIndex = TranslatedNames[WorkItemIndex].DomainIndex;

            }

            WorkListTranslatedNames[Index].Use
            = TranslatedNames[WorkItemIndex].Use;

            WorkListTranslatedNames[Index].DomainIndex = LocalDomainIndex;

            Status = LsapRpcCopyUnicodeString(
                         NULL,
                         (PUNICODE_STRING) &WorkListTranslatedNames[Index].Name,
                         (PUNICODE_STRING) &TranslatedNames[WorkItemIndex].Name
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupSidsUpdateTranslatedNamesError;
    }

LookupSidsUpdateTranslatedNamesFinish:

    //
    // If necessary, release the Lookup Work Queue Lock.
    //

    if (AcquiredWorkQueueLock) {

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;
    }

    return(Status);

LookupSidsUpdateTranslatedNamesError:

    goto LookupSidsUpdateTranslatedNamesFinish;
}


NTSTATUS
LsapDbLookupNamesUpdateTranslatedSids(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList,
    IN OUT PLSAP_DB_LOOKUP_WORK_ITEM WorkItem,
    IN PLSAPR_TRANSLATED_SID_EX2 TranslatedSids,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains
    )

/*++

Routine Description:

    This function is called during the processing of a Work Item to update
    the output TranslatedSids and ReferencedDomains parameters of a
    Lookup operation's Work List with the results of a callout to
    LsaICLookupNames.  Zero or more Names may have been translated, and
    there is the additional complication of multiple translations of
    Isolated Names as a result of their presence in more than one
    Work Item.  The following rules apply:

    If the Name is a Qualified Name, it only belongs to the specified
    Work Item, so it suffices to check that it has been mapped to a Sid.

    If the Name is an Isolated Name, it belongs to all other Work Items,
    so it may already have been translated during the processing of some
    other Work Item.  If the Name has previously been translated, the prior
    translation stands and the present translation is discarded.  If the
    Name has not previously been translated, the Domain for this Work Item
    is added to the Referenced Domain List and the newly obtained translation
    is stored in the output TranslatedSids array in the Work List.

Arguments:

    WorkList - Pointer to a Work List

    WorkItem - Pointer to a Work Item.  The DomainIndex field will be
        updated if the Domain specified by this Work Item is added to
        the Referenced Domain List by this routine.

    TranslatedSids - Translated Sids information returned from
        LsaICLookupNames().

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG WorkItemIndex;
    ULONG LocalDomainIndex;
    ULONG Index;
    PLSAPR_TRANSLATED_SID_EX2 WorkListTranslatedSids =
        WorkList->LookupNamesParams.TranslatedSids->Sids;
    BOOLEAN AcquiredWorkQueueLock = FALSE;

    //
    // Acquire the Work Queue Lock.
    //

    Status = LsapDbLookupAcquireWorkQueueLock();

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesUpdateTranslatedSidsError;
    }

    AcquiredWorkQueueLock = TRUE;

    for( WorkItemIndex = 0;
         WorkItemIndex < WorkItem->UsedCount;
         WorkItemIndex++) {

        //
        // If this Name has not been translated at all during processing of
        // this Work Item, skip to the next.
        //

        if (LsapDbCompletelyUnmappedSid(&TranslatedSids[WorkItemIndex])) {

            continue;
        }

        //
        // We partially or fully translated the Name during processing of
        // this Work Item.  If this Name has previously been fully translated
        // during the processing of another Work Item, discard the new
        // translation and skip to the next Name.  Note that Qualified
        // Names are always partially translated during the building
        // of the Work List.  Isolated Names are fully translated during
        // the building phase if they are Domain Names.
        //

        Index = WorkItem->Indices[WorkItemIndex];

        if ( WorkListTranslatedSids[ Index ].Use != SidTypeUnknown ) {

            continue;
        }

        //
        // If the SID does not pass the filter test, ignore
        //
        if ( (WorkItem->Properties & LSAP_DB_LOOKUP_WORK_ITEM_XFOREST)
          &&  TranslatedSids[WorkItemIndex].Sid ) {

            NTSTATUS Status2;

            Status2 = LsapSidOnFtInfo((PUNICODE_STRING)&WorkItem->TrustInformation.Name,
                                      TranslatedSids[WorkItemIndex].Sid );
            if (!NT_SUCCESS(Status2)) {

                //
                // This SID did not pass the test
                //
                BOOL fSuccess;
                LPWSTR StringSid = NULL, TargetForest = NULL, AccountName = NULL;

                LsapDiagPrint( DB_LOOKUP_WORK_LIST,
                  ("LsapSidOnFtInfo returned 0x%x\n",Status2));

                //
                // This should be rare -- event log for troubleshooting
                // purposes
                //
                fSuccess = ConvertSidToStringSidW(TranslatedSids[WorkItemIndex].Sid,
                                                  &StringSid);

                TargetForest = LocalAlloc(LMEM_ZEROINIT, WorkItem->TrustInformation.Name.Length + sizeof(WCHAR));
                if (TargetForest) {
                    RtlCopyMemory(TargetForest,
                                  WorkItem->TrustInformation.Name.Buffer,
                                  WorkItem->TrustInformation.Name.Length);

                }

                AccountName = LocalAlloc(LMEM_ZEROINIT, WorkList->LookupNamesParams.Names[Index].Length + sizeof(WCHAR));
                if (AccountName) {
                    RtlCopyMemory(AccountName,
                                  WorkList->LookupNamesParams.Names[Index].Buffer,
                                  WorkList->LookupNamesParams.Names[Index].Length);
                }


                if (   fSuccess 
                    && TargetForest
                    && AccountName) {

                    LsapDbLookupReportEvent3( 1,
                                              EVENTLOG_WARNING_TYPE,
                                              LSAEVENT_LOOKUP_SID_FILTERED,
                                              sizeof( ULONG ),
                                              &Status2,
                                              AccountName,
                                              StringSid,
                                              TargetForest );                
                }


                if (StringSid) {
                    LocalFree(StringSid);
                }
                if (TargetForest) {
                    LocalFree(TargetForest);
                }
                if (AccountName) {
                    LocalFree(AccountName);
                }

                continue;
            }
        }


        //
        // Name has been translated for the first time during the processing
        // of this Work Item.  If this Work Item does not specify a Domain
        // Index, we need to add its Domain to the Referenced Domains List.
        //
        if (TranslatedSids[WorkItemIndex].DomainIndex != LSA_UNKNOWN_INDEX) {

            //
            // Make sure this is in the referenced domains list
            //
            Status = LsapDbLookupAddListReferencedDomains(
                         WorkList->ReferencedDomains,
                         &ReferencedDomains->Domains[TranslatedSids[WorkItemIndex].DomainIndex],
                         (PLONG) &LocalDomainIndex
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }
        } else {
            LocalDomainIndex = TranslatedSids[WorkItemIndex].DomainIndex;
        }

        //
        // Now update the TranslatedSids array in the Work List.

        WorkListTranslatedSids[Index] = TranslatedSids[WorkItemIndex];
        WorkListTranslatedSids[Index].DomainIndex = LocalDomainIndex;

        Status = LsapRpcCopySid(NULL,
                                &WorkListTranslatedSids[Index].Sid,
                                TranslatedSids[WorkItemIndex].Sid);

        if (!NT_SUCCESS(Status)) {
            break;;
        }

    }

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesUpdateTranslatedSidsError;
    }

LookupNamesUpdateTranslatedSidsFinish:

    //
    // If necessary, release the Lookup Work Queue Lock.
    //

    if (AcquiredWorkQueueLock) {

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;
    }

    return(Status);

LookupNamesUpdateTranslatedSidsError:

    goto LookupNamesUpdateTranslatedSidsFinish;
}


NTSTATUS
LsapDbLookupCreateWorkItem(
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN LONG DomainIndex,
    IN ULONG MaximumEntryCount,
    OUT PLSAP_DB_LOOKUP_WORK_ITEM *WorkItem
    )

/*++

Routine Description:

    This function creates a new Work Item for a name Lookup operation.

Arguments:

    TrustInformation - Specifies the Name of the Trusted Domain
        to which the Work Item relates.  The Sid field may be NULL or
        set to the corresponding Sid.  The Trust Information is expected
        to be in heap or global data.

    DomainIndex - Specifies the Domain Index of this domain relative to
        the Referenced Domain List for the Lookup operation specified
        by the Work List.

    MaximumEntryCount - Specifies the maximum number of entries that
        this Work Item will initialiiy be able to contain.

    WorkItem - Receives a pointer to an empty Work Item structure.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_LOOKUP_WORK_ITEM OutputWorkItem = NULL;
    PULONG OutputIndices = NULL;
    ULONG InitialEntryCount;

    //
    // Allocate memory for the Work Item Header.
    //

    Status = STATUS_INSUFFICIENT_RESOURCES;

    OutputWorkItem = MIDL_user_allocate(sizeof(LSAP_DB_LOOKUP_WORK_ITEM));

    if (OutputWorkItem == NULL) {

        goto LookupCreateWorkItemError;
    }

    RtlZeroMemory(
        OutputWorkItem,
        sizeof(LSAP_DB_LOOKUP_WORK_ITEM)
        );

    //
    // Initialize the fixed fields in the Work Item.
    //

    Status = LsapDbLookupInitializeWorkItem(OutputWorkItem);

    if (!NT_SUCCESS(Status)) {

        goto LookupCreateWorkItemError;
    }

    //
    // Initialize other fields from parameters.
    //

    //
    // Copy the trusted domain information into the work item.  The
    // trust information may be NULL if this is the isolated names
    // work item.
    //

    if (TrustInformation != NULL) {

        if ( TrustInformation->Sid ) {

            OutputWorkItem->TrustInformation.Sid =
                MIDL_user_allocate( RtlLengthSid(TrustInformation->Sid) );

            if (OutputWorkItem->TrustInformation.Sid == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto LookupCreateWorkItemError;
            }

            RtlCopyMemory(
                OutputWorkItem->TrustInformation.Sid,
                TrustInformation->Sid,
                RtlLengthSid(TrustInformation->Sid)
                );
        }

        OutputWorkItem->TrustInformation.Name.MaximumLength = TrustInformation->Name.Length + sizeof(WCHAR);
        OutputWorkItem->TrustInformation.Name.Buffer =
            MIDL_user_allocate(TrustInformation->Name.Length + sizeof(WCHAR));

        if (OutputWorkItem->TrustInformation.Name.Buffer == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto LookupCreateWorkItemError;
        }

        RtlCopyUnicodeString(
            (PUNICODE_STRING) &OutputWorkItem->TrustInformation.Name,
            (PUNICODE_STRING) &TrustInformation->Name
            );

    }


    //
    // Create the Indices array in the Work Item.
    //

    InitialEntryCount = (MaximumEntryCount +
                         LSAP_DB_LOOKUP_WORK_ITEM_GRANULARITY) &
                         (~LSAP_DB_LOOKUP_WORK_ITEM_GRANULARITY);

    Status = STATUS_INSUFFICIENT_RESOURCES;

    OutputIndices = MIDL_user_allocate( InitialEntryCount * sizeof(ULONG) );

    if (OutputIndices == NULL) {

        goto LookupCreateWorkItemError;
    }

    Status = STATUS_SUCCESS;

    OutputWorkItem->UsedCount = (ULONG) 0;
    OutputWorkItem->MaximumCount = InitialEntryCount;
    OutputWorkItem->Indices = OutputIndices;
    OutputWorkItem->DomainIndex = DomainIndex;

LookupCreateWorkItemFinish:

    //
    // Return pointer to newly created Work Item or NULL.
    //

    *WorkItem = OutputWorkItem;
    return(Status);

LookupCreateWorkItemError:

    //
    // Free memory allocated for Indices array.
    //

    if (OutputIndices != NULL) {

        MIDL_user_free( OutputIndices );
        OutputIndices = NULL;
    }

    //
    // Free any memory allocated for the Work Item header.
    //

    if (OutputWorkItem != NULL) {
        if (OutputWorkItem->TrustInformation.Sid != NULL) {
            MIDL_user_free( OutputWorkItem->TrustInformation.Sid );
        }

        if (OutputWorkItem->TrustInformation.Name.Buffer != NULL) {
            MIDL_user_free( OutputWorkItem->TrustInformation.Name.Buffer );
        }

        MIDL_user_free(OutputWorkItem);
        OutputWorkItem = NULL;
    }

    goto LookupCreateWorkItemFinish;
}


NTSTATUS
LsapDbLookupAddIndicesToWorkItem(
    IN OUT PLSAP_DB_LOOKUP_WORK_ITEM WorkItem,
    IN ULONG Count,
    IN PULONG Indices
    )

/*++

Routine Description:

    This function adds an array of Sid or Name indices to a Work Item.
    The indices specify Sids or Names within the Sids or Names arrays in
    the WorkList.  If there is sufficient room in the Work Item's
    existing indices array, the indices will be copied to that array.
    Otherwise, a larger array will be allocated and the existing one
    will be freed after copying the existing indices.

    NOTE:  The Work Item must NOT belong to a Work List that is currently
           on the Work Queue.  The Lookup Work Queue Lock will not be
           taken.
Arguments:

    WorkItem - Pointer to a Work Item structure describing a
        list of Sids or Names and a domain in which they are to be looked up.

    Count - Specifies the number of indices to be added.

    Indices - Specifies the array of indices to be added to the WorkItem.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PULONG OutputIndices = NULL;
    ULONG NewMaximumCount;

    //
    // Check room available in the work item.  If there is enough
    // room, just copy the indices in.
    //

    if (WorkItem->MaximumCount - WorkItem->UsedCount >= Count) {

        RtlCopyMemory(
            &WorkItem->Indices[WorkItem->UsedCount],
            Indices,
            Count * sizeof(ULONG)
            );

        WorkItem->UsedCount += Count;
        goto AddIndicesToWorkItemFinish;
    }

    //
    // Allocate array of sufficient size to accommodate the existing
    // and new indices.  Round up number of entries to some granularity
    // to avoid frequent reallocations.
    //

    Status = STATUS_INSUFFICIENT_RESOURCES;

    NewMaximumCount = ((WorkItem->UsedCount + Count) +
                        LSAP_DB_LOOKUP_WORK_ITEM_GRANULARITY) &
                        (~LSAP_DB_LOOKUP_WORK_ITEM_GRANULARITY);

    OutputIndices = MIDL_user_allocate( NewMaximumCount * sizeof(ULONG) );

    if (OutputIndices == NULL) {

        goto AddIndicesToWorkItemError;
    }

    Status = STATUS_SUCCESS;

    //
    // Copy in the existing and new indices.
    //

    RtlCopyMemory(
        OutputIndices,
        WorkItem->Indices,
        WorkItem->UsedCount * sizeof(ULONG)
        );

    RtlCopyMemory(
        &OutputIndices[WorkItem->UsedCount],
        Indices,
        Count * sizeof(ULONG)
        );

    //
    // Free the existing indices.  Set pointer to the updated indices array
    // and update the used and maximum counts.
    //

    MIDL_user_free( WorkItem->Indices );
    WorkItem->Indices = OutputIndices;
    WorkItem->UsedCount += Count;
    WorkItem->MaximumCount = NewMaximumCount;

AddIndicesToWorkItemFinish:

    return(Status);

AddIndicesToWorkItemError:

    //
    // Free any memory allocated for the Output Indices array.
    //

    if (OutputIndices != NULL) {

        MIDL_user_free( OutputIndices );
        OutputIndices = NULL;
    }

    goto AddIndicesToWorkItemFinish;
}


NTSTATUS
LsapDbLookupComputeAdvisoryChildThreadCount(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    )

/*++

Routine Description:

    This function computes the advisory thread count for a Lookup
    operation.  This count is an estimate of the optimal number of
    worker threads (in addition to the main thread) needed to process the
    Work List.

Arguments:

    WorkList - Pointer to a Work List structure describing a
        Lookup Sids or Lookup Names operation.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(WorkList->WorkItemCount != (ULONG) 0);
    WorkList->AdvisoryChildThreadCount = (WorkList->WorkItemCount - (ULONG) 1);

    return(Status);
}


NTSTATUS
LsapDbLookupUpdateAssignableWorkItem(
    IN BOOLEAN MoveToNextWorkList
    )

/*++

Routine Description:

    This function updates the next assignable Work Item pointers.

Arguments:

    MoveToNextWorkList - If TRUE, skip the rest of the current Work List.  If
        FALSE, point at the next item in the current Work List.

Return Value:

    NTSTATUS - Standard Nt Result Code.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_LOOKUP_WORK_ITEM CandAssignableWorkItem = NULL;
    PLSAP_DB_LOOKUP_WORK_LIST CandAssignableWorkList = NULL;
    BOOLEAN AcquiredWorkQueueLock = FALSE;

    //
    // Acquire the LookupWork Queue Lock.
    //

    Status = LsapDbLookupAcquireWorkQueueLock();

    if (!NT_SUCCESS(Status)) {

        goto LookupUpdateAssignableWorkItemError;
    }

    AcquiredWorkQueueLock = TRUE;

    //
    // If there is no Currently Assignable Work List, just exit.
    //

    if (LookupWorkQueue.CurrentAssignableWorkList == NULL) {

        goto LookupUpdateAssignableWorkItemFinish;
    }

    //
    // There is a Currently Assignable Work List.  Unless requested to
    // skip this Work List, examine it.
    //

    if (!MoveToNextWorkList) {

        ASSERT( LookupWorkQueue.CurrentAssignableWorkItem != NULL);

        //
        // Select the next Work Item in the list as candidate for the
        // next Assignable Work Item.  If we have not returned to the First
        // Work Item, selection is complete.
        //

        CandAssignableWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM)
            LookupWorkQueue.CurrentAssignableWorkItem->Links.Flink;

        if (CandAssignableWorkItem !=
                LookupWorkQueue.CurrentAssignableWorkList->AnchorWorkItem) {

            ASSERT( CandAssignableWorkItem->State == AssignableWorkItem);

            LookupWorkQueue.CurrentAssignableWorkItem = CandAssignableWorkItem;
            goto LookupUpdateAssignableWorkItemFinish;
        }
    }

    //
    // There are no more work items in this Work List or we're to skip the
    // rest of it.  See if there is another Work List.
    //

    CandAssignableWorkList = (PLSAP_DB_LOOKUP_WORK_LIST)
        LookupWorkQueue.CurrentAssignableWorkList->WorkLists.Flink;

    if (CandAssignableWorkList != LookupWorkQueue.AnchorWorkList) {

        //
        // There is another Work List.  Select the first Work Item in the
        // list following the anchor.
        //

        CandAssignableWorkItem = (PLSAP_DB_LOOKUP_WORK_ITEM)
            CandAssignableWorkList->AnchorWorkItem->Links.Flink;

        //
        // Verify that the list does not just contain the Anchor Work Item.
        // Work Lists on the Work Queue should never be empty.
        //

        ASSERT (CandAssignableWorkItem != CandAssignableWorkList->AnchorWorkItem);

        LookupWorkQueue.CurrentAssignableWorkList = CandAssignableWorkList;
        LookupWorkQueue.CurrentAssignableWorkItem = CandAssignableWorkItem;
        goto LookupUpdateAssignableWorkItemFinish;
    }

    //
    // All work has been assigned.  Set pointers to NULL.
    //

    LookupWorkQueue.CurrentAssignableWorkList = NULL;
    LookupWorkQueue.CurrentAssignableWorkItem = NULL;

LookupUpdateAssignableWorkItemFinish:

    //
    // If necessary, release the Lookup Work Queue Lock.
    //

    if (AcquiredWorkQueueLock) {

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;
    }

    return(Status);

LookupUpdateAssignableWorkItemError:

    goto LookupUpdateAssignableWorkItemFinish;
}


NTSTATUS
LsapDbLookupStopProcessingWorkList(
    IN PLSAP_DB_LOOKUP_WORK_LIST WorkList,
    IN NTSTATUS TerminationStatus
    )

/*++

Routine Description:

    This function stops further work on a lookup operation at a given
    level and stores an error code.

Arguments:

    WorkList - Pointer to a Work List structure describing a
        Lookup Sids or Lookup Names operation.

    TerminationStatus - Specifies the Nt Result Code to be returned
        by LsarLookupnames or LsarLookupSids.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN AcquiredWorkQueueLock = FALSE;

    //
    // Acquire the LookupWork Queue Lock.
    //

    Status = LsapDbLookupAcquireWorkQueueLock();

    if (!NT_SUCCESS(Status)) {

        goto LookupStopProcessingWorkListError;
    }

    AcquiredWorkQueueLock = TRUE;

    //
    // Store the termination status in the appropriate WorkList.
    //

    WorkList->Status = TerminationStatus;

    //
    // If this WorkList happens to be the one in which Work Items are being
    // given out, we need to prevent any further Work Items from being given
    // out.  Update the next assignable Work Item pointers, specifying that
    // we should skip to the next Work List (if any).
    //

    if (WorkList == LookupWorkQueue.CurrentAssignableWorkList) {

        Status = LsapDbLookupUpdateAssignableWorkItem(TRUE);
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupStopProcessingWorkListError;
    }

LookupStopProcessingWorkListFinish:

    //
    // If necessary, release the Lookup Work Queue Lock.
    //

    if (AcquiredWorkQueueLock) {

        LsapDbLookupReleaseWorkQueueLock();
        AcquiredWorkQueueLock = FALSE;
    }

    return(Status);

LookupStopProcessingWorkListError:

    goto LookupStopProcessingWorkListFinish;
}


NTSTATUS
LsapRtlExtractDomainSid(
    IN PSID Sid,
    OUT PSID *DomainSid
    )

/*++

Routine Description:

   This function extracts a Domain Sid from a Sid.

Arguments:

    Sid - Pointer to Sid whose Domain Prefix Sid is to be extracted.

    DomainSid - Receives pointer to Domain Sid.  This Sid will be
        allocated memory by MIDL_User_allocate() and should be freed
        via MIDL_user_free when no longer required.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    PSID OutputDomainSid;
    ULONG DomainSidLength = RtlLengthSid(Sid) - sizeof(ULONG);



    OutputDomainSid = MIDL_user_allocate( DomainSidLength );
    if (OutputDomainSid == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    RtlCopyMemory( OutputDomainSid, Sid, DomainSidLength);
    (*(RtlSubAuthorityCountSid(OutputDomainSid)))--;

    *DomainSid = OutputDomainSid;

    return(STATUS_SUCCESS);

}


NTSTATUS
LsapDbLookupReadRegistrySettings(
    PVOID Ignored OPTIONAL
    )
/*++

Routine Description:

    This routine is called via LsaIRegisterNotification whenever the LSA's
    registry settings change.

Arguments:

    Ignored -- a callback parameter that is not used.

Return Value:

    STATUS_SUCCCESS;

--*/
{
    DWORD err;
    HKEY hKey;
    DWORD dwType;
    DWORD dwValue;
    DWORD dwValueSize;
   

    err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                        L"SYSTEM\\CurrentControlSet\\Control\\Lsa",
                        0, // reserved
                        KEY_QUERY_VALUE,
                       &hKey );

    if ( ERROR_SUCCESS == err ) {

        dwValueSize = sizeof(dwValue);
        err = RegQueryValueExW( hKey,
                                L"AllowExtendedDownlevelLookup",
                                NULL,  //reserved,
                                &dwType,
                                (PBYTE)&dwValue,
                                &dwValueSize );

        if ( (ERROR_SUCCESS == err)
          && (dwValue != 0)   ) {

            LsapAllowExtendedDownlevelLookup = TRUE;
        } else {
            // Reset the value
            LsapAllowExtendedDownlevelLookup = FALSE;
        }

        dwValueSize = sizeof(dwValue);
        err = RegQueryValueExW( hKey,
                                L"LookupLogLevel",
                                NULL,  //reserved,
                                &dwType,
                                (PBYTE)&dwValue,
                                &dwValueSize );


        if ( ERROR_SUCCESS == err) {
            LsapLookupLogLevel = dwValue;
        } else {
            // default value
            LsapLookupLogLevel = 0;
        }
#if DBG
        if (LsapLookupLogLevel > 0) {
             LsapGlobalFlag |= LSAP_DIAG_DB_LOOKUP_WORK_LIST;
        } else {
            LsapGlobalFlag &= ~LSAP_DIAG_DB_LOOKUP_WORK_LIST;
        }
#endif

        dwValueSize = sizeof(DWORD);
        dwValue = 0;
        err = RegQueryValueExW( hKey,
                                L"LsaLookupReturnSidTypeDeleted",
                                NULL,  //reserved,
                                &dwType,
                                (PBYTE)&dwValue,
                                &dwValueSize );

        if ( (ERROR_SUCCESS == err)
          && (dwType == REG_DWORD)  
          && (dwValue != 0)   ) {
            LsapReturnSidTypeDeleted = TRUE;
        } else {
            LsapReturnSidTypeDeleted = FALSE;
        }

        LsapSidCacheReadParameters(hKey);

        RegCloseKey( hKey );

    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(Ignored);
}


NTSTATUS
LsapDbLookupInitialize(
    )

/*++

Routine Description:

    This function performs initialization of the data structures
    used by Lookup operations.  These structures are as follows:

    LookupWorkQueue - This is a doubly-linked list of Lookup Work Lists.
        There is one Work List for each Lookup operation in progress
        on a DC.  Each Lookup Work List contains a doubly-linked list
        of Lookup Work Items.  Each Lookup Work Item specifies a
        Trusted Domain and array of Sids or Names to be looked up in that
        domain.  Access to this queue is controlled via the Lookup
        Work Queue Lock.

    Trusted Domain List - This is a doubly-linked list which contains
        the Trust Information (i.e. Domain Sid and Domain Name) of
        each Trusted Domain.  The purpose of this list is to enable
        fast identification of Trusted Domain Sids and Names, without
        having recourse to open or enumerate Trusted Domain objects.
        This list is initialized when the system is loaded, and is
        updated directly when a Trusted Domain object is created or
        deleted.

Arguments:

    None

Return Value:

    NTSTATUS - Standard Nt Result Code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = LsapDbLookupInitPolicyCache();
    if (!NT_SUCCESS(Status)) {
        return Status; 
    }

    //
    // Arrange to be notified when the parameter settings change
    //
    LsaIRegisterNotification( LsapDbLookupReadRegistrySettings,
                              0,
                              NOTIFIER_TYPE_NOTIFY_EVENT,
                              NOTIFY_CLASS_REGISTRY_CHANGE,
                              0,
                              0,
                              0 );

    Status = LsapDbLookupReadRegistrySettings(NULL);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }


    //
    // Perform initialization specific to DC's
    //

    if (LsapProductType != NtProductLanManNt) {

        goto LookupInitializeFinish;
    }

    //
    // Create the Lookup Work List initiated event.
    //

    Status = NtCreateEvent(
                 &LsapDbLookupStartedEvent,
                 EVENT_QUERY_STATE | EVENT_MODIFY_STATE | SYNCHRONIZE,
                 NULL,
                 SynchronizationEvent,
                 FALSE
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupInitializeError;
    }

    //
    // Initialize the Lookup Work Queue
    //

    Status = LsapDbLookupInitializeWorkQueue();

    if (!NT_SUCCESS(Status)) {

        goto LookupInitializeError;
    }

LookupInitializeFinish:

    return(Status);

LookupInitializeError:

    goto LookupInitializeFinish;
}


NTSTATUS
LsapDbLookupInitializeWorkQueue(
    )

/*++

Routine Description:

    This function initializes the Lookup Work Queue.  It is only
    called for DC's.

Arguments:

    None

Return Value:

    NTSTATUS - Standard Nt Result Code.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_LOOKUP_WORK_LIST AnchorWorkList = NULL;

    //
    // Initialize the Work Queue Lock.
    //

    Status = SafeInitializeCriticalSection(&LookupWorkQueue.Lock, ( DWORD )LOOKUP_WORK_QUEUE_LOCK_ENUM );

    if (!NT_SUCCESS(Status)) {

        LsapLogError(
            "LsapDbLookupInitialize: RtlInit..CritSec returned 0x%lx\n",
            Status
            );
        return Status;
    }

    //
    // Initialize the Work Queue to comprise the Anchor Work List
    // doubly-linked to itself.
    //

    LookupWorkQueue.AnchorWorkList = &LookupWorkQueue.DummyAnchorWorkList;
    AnchorWorkList = &LookupWorkQueue.DummyAnchorWorkList;

    //
    // Set the currently assignable Work List and Work Item pointers to
    // NULL to indicate that there is no work to to.
    //

    LookupWorkQueue.CurrentAssignableWorkList = NULL;
    LookupWorkQueue.CurrentAssignableWorkItem = NULL;

    //
    // Initialize the Anchor Work List.
    //

    Status = LsapDbLookupInitializeWorkList(AnchorWorkList);

    if (!NT_SUCCESS(Status)) {

        goto LookupInitializeWorkQueueError;
    }

    AnchorWorkList->WorkLists.Flink = (PLIST_ENTRY) AnchorWorkList;
    AnchorWorkList->WorkLists.Blink = (PLIST_ENTRY) AnchorWorkList;

    //
    // Set the thread counts.
    //

    LookupWorkQueue.ActiveChildThreadCount = (ULONG) 0;
    LookupWorkQueue.MaximumChildThreadCount = LSAP_DB_LOOKUP_MAX_THREAD_COUNT;
    LookupWorkQueue.MaximumRetainedChildThreadCount = LSAP_DB_LOOKUP_MAX_RET_THREAD_COUNT;

LookupInitializeWorkQueueFinish:

    return(Status);

LookupInitializeWorkQueueError:

    goto LookupInitializeWorkQueueFinish;
}


NTSTATUS
LsapDbLookupInitializeWorkList(
    OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    )

/*++

Routine Description:

    This function initializes an empty Work List structure.  The Work List
    link fields are not set by this function.

Arguments:

    WorkList - Points to Work List structure to be initialized.

Return Value:

    NTSTATUS - Standard Nt Result Code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_LOOKUP_WORK_ITEM AnchorWorkItem = NULL;

    //
    // Initialize miscellaneous fields in the Work List header.
    //

    WorkList->WorkLists.Flink = NULL;
    WorkList->WorkLists.Blink = NULL;
    WorkList->WorkItemCount = (ULONG) 0;
    WorkList->CompletedWorkItemCount = (ULONG) 0;
    WorkList->State = InactiveWorkList;
    WorkList->Status = STATUS_SUCCESS;
    WorkList->NonFatalStatus = STATUS_SUCCESS;

    //
    // Init the completion event
    //
    Status = NtCreateEvent(
                 &WorkList->LookupCompleteEvent,
                 EVENT_QUERY_STATE | EVENT_MODIFY_STATE | SYNCHRONIZE,
                 NULL,
                 SynchronizationEvent,
                 FALSE
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupInitializeWorkListError;
    }



    //
    // Initialize the Work List's list of Work Items to comprise the
    // Anchor Work Item doubly-linked to itself.
    //

    WorkList->AnchorWorkItem = &WorkList->DummyAnchorWorkItem;
    AnchorWorkItem = WorkList->AnchorWorkItem;
    AnchorWorkItem->Links.Flink = (PLIST_ENTRY) AnchorWorkItem;
    AnchorWorkItem->Links.Blink = (PLIST_ENTRY) AnchorWorkItem;

    //
    // Initialize the Anchor Work Item.
    //

    Status = LsapDbLookupInitializeWorkItem(AnchorWorkItem);

    if (!NT_SUCCESS(Status)) {

        goto LookupInitializeWorkListError;
    }

LookupInitializeWorkListFinish:

    return(Status);

LookupInitializeWorkListError:

    goto LookupInitializeWorkListFinish;
}


NTSTATUS
LsapDbLookupInitializeWorkItem(
    OUT PLSAP_DB_LOOKUP_WORK_ITEM WorkItem
    )

/*++

Routine Description:

    This function initializes an empty Work Item structure.  The Work Item
    link fields are not set by this function.

Arguments:

    WorkItem - Points to Work Item structure to be initialized.

Return Value:

    NTSTATUS - Standard Nt Result Code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    WorkItem->UsedCount = (ULONG) 0;
    WorkItem->MaximumCount = (ULONG) 0;
    WorkItem->State = NonAssignableWorkItem;
    WorkItem->Properties = (ULONG) 0;

    return(Status);
}


NTSTATUS
LsapDbLookupLocalDomains(
    OUT PLSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation,
    OUT PLSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation,
    OUT PLSAPR_TRUST_INFORMATION_EX PrimaryDomainTrustInformation
    )

/*++

Routine Description:

    This function returns Trust Information for the Local Domains.

Arguments:

    BuiltInDomainTrustInformation - Pointer to structure that will
        receive the Name and Sid of the Built-In Domain.  Unlike
        the other two parameters, the Name and Sid buffers for the
        Built-in Domain are NOT freed after use, because they are
        global data constants.

    AccountDomainTrustInformation - Pointer to structure that will
        receive the Name and Sid of the Accounts Domain.  The Name and
        Sid buffers must be freed after use via MIDL_user_free.

    PrimaryDomainTrustInformation - Pointer to structure that will
        receive the Name and Sid of the Accounts Domain.  The Name and
        Sid buffers must be freed after use via MIDL_user_free.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG WellKnownSidIndex;
    PLSAPR_POLICY_ACCOUNT_DOM_INFO PolicyAccountDomainInfo = NULL;
    PLSAPR_POLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfo = NULL;

    RtlZeroMemory( AccountDomainTrustInformation, sizeof( LSAPR_TRUST_INFORMATION_EX ) );
    RtlZeroMemory( PrimaryDomainTrustInformation, sizeof( LSAPR_TRUST_INFORMATION_EX ) );

    //
    // Obtain the Name and Sid of the Built-in Domain
    //

    BuiltInDomainTrustInformation->Sid = LsapBuiltInDomainSid;

    Status = STATUS_INTERNAL_DB_ERROR;

    if (!LsapDbLookupIndexWellKnownSid(
            LsapBuiltInDomainSid,
            (PLSAP_WELL_KNOWN_SID_INDEX) &WellKnownSidIndex
            )) {

        goto LookupLocalDomainsError;
    }

    Status = STATUS_SUCCESS;

    //
    // Obtain the name of the Built In Domain from the table of
    // Well Known Sids.  It suffices to copy the Unicode structures
    // since we do not need a separate copy of the name buffer.
    //

    BuiltInDomainTrustInformation->Name = *((PLSAPR_UNICODE_STRING)
                             LsapDbWellKnownSidName(WellKnownSidIndex));

    //
    // Now obtain the Name and Sid of the Account Domain.
    // The Sid and Name of the Account Domain are both configurable, and
    // we need to obtain them from the Policy Object.  Now obtain the
    // Account Domain Sid and Name by querying the appropriate
    // Policy Information Class.
    //

    Status = LsapDbLookupGetDomainInfo((POLICY_ACCOUNT_DOMAIN_INFO **)&PolicyAccountDomainInfo,
                                       (POLICY_DNS_DOMAIN_INFO **)&PolicyDnsDomainInfo);

    if (!NT_SUCCESS(Status)) {

        goto LookupLocalDomainsError;
    }

    //
    // Set up the Trust Information structure for the Account Domain.
    //

    AccountDomainTrustInformation->Sid = PolicyAccountDomainInfo->DomainSid;

    RtlCopyMemory(
        &AccountDomainTrustInformation->FlatName,
        &PolicyAccountDomainInfo->DomainName,
        sizeof (UNICODE_STRING)
        );


    //
    // If the account domain is the same as the Dns domain info, return the
    // dns domain name as the account domain name
    //
    if ( PolicyDnsDomainInfo->Sid &&
         PolicyAccountDomainInfo->DomainSid &&
         RtlEqualSid( PolicyDnsDomainInfo->Sid,
                      PolicyAccountDomainInfo->DomainSid ) &&
         RtlEqualUnicodeString( ( PUNICODE_STRING )&PolicyDnsDomainInfo->Name,
                                  ( PUNICODE_STRING )&PolicyAccountDomainInfo->DomainName,
                                  TRUE ) ) {

        AccountDomainTrustInformation->DomainName = PolicyDnsDomainInfo->DnsDomainName;

        AccountDomainTrustInformation->DomainNamesDiffer = TRUE;

    } else {

        AccountDomainTrustInformation->DomainName = AccountDomainTrustInformation->FlatName;

    }

    //
    // Now obtain the Name and Sid of the Primary Domain (if any)
    // The Sid and Name of the Primary Domain are both configurable, and
    // we need to obtain them from the Policy Object.  Now obtain the
    // Account Domain Sid and Name by querying the appropriate
    // Policy Information Class.
    //
    if ( NT_SUCCESS( Status ) ) {

        //
        // Set up the Trust Information structure for the Primary Domain.
        //

        PrimaryDomainTrustInformation->Sid = PolicyDnsDomainInfo->Sid;

        RtlCopyMemory( &PrimaryDomainTrustInformation->FlatName,
                       &PolicyDnsDomainInfo->Name,
                       sizeof (UNICODE_STRING) );

        RtlCopyMemory( &PrimaryDomainTrustInformation->DomainName,
                       &PolicyDnsDomainInfo->DnsDomainName,
                       sizeof( UNICODE_STRING ) );

        if ( !RtlEqualUnicodeString( ( PUNICODE_STRING )&PolicyDnsDomainInfo->DnsDomainName,
                                     ( PUNICODE_STRING )&PolicyDnsDomainInfo->Name, TRUE ) ) {

            PrimaryDomainTrustInformation->DomainNamesDiffer = TRUE;
        }
    }

LookupLocalDomainsFinish:

    return(Status);

LookupLocalDomainsError:

    goto LookupLocalDomainsFinish;
}

BOOLEAN
LsapIsBuiltinDomain(
    IN PSID Sid
    )
{
    return RtlEqualSid( Sid, LsapBuiltInDomainSid );
}

BOOLEAN
LsapIsDsDomainByNetbiosName(
    WCHAR *NetbiosName
    )
/*++

Routine Description

    This routine determines if the (domain) netbios name passed in is an
    accounts domain that is reprssented in the DS (ie is at least an nt5 domain).

Parameters:

    NetbiosName -- a valid string

--*/
{
    NTSTATUS NtStatus;
    PDSNAME dsname;
    ULONG   len;

    ASSERT( Sid );

    // Ask the DS if it has heard of this name
    NtStatus = MatchCrossRefByNetbiosName( NetbiosName,
                                           NULL,
                                           &len );
    if ( NT_SUCCESS(NtStatus) ) {
        //
        // The domain was found in the ds
        //
        return TRUE;
    }

    return FALSE;

}


NTSTATUS
LsapGetDomainNameBySid(
    IN  PSID Sid,
    OUT PUNICODE_STRING DomainName
    )
/*++

Routine Description

    Given a sid, this routine will return the netbios name of the domain,
    if the domain is stored in the ds

Parameters:

    Sid -- domain sid
    Domain Name -- domain name allocated from MIDL

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LPWSTR Name = NULL;
    DSNAME dsname = {0};
    ULONG  len = 0;

    ASSERT( Sid );
    ASSERT( DomainName );

    dsname.structLen = DSNameSizeFromLen(0);
    len = min( sizeof( NT4SID ), RtlLengthSid( Sid ) );
    memcpy( &dsname.Sid, Sid, len );
    dsname.SidLen = len;

    NtStatus = FindNetbiosDomainName(
                   &dsname,
                   NULL,
                   &len );

    if ( NT_SUCCESS( NtStatus ) ) {

        Name = MIDL_user_allocate( len );
        if ( !Name ) {

            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        NtStatus = FindNetbiosDomainName(
                       &dsname,
                       Name,
                       &len );

        if ( NT_SUCCESS( NtStatus ) ) {
            RtlInitUnicodeString( DomainName, Name );
        } else {
            MIDL_user_free( Name );
        }
    }

    if ( !NT_SUCCESS( NtStatus ) ) {
        //
        // Something failed?  Assume not a nt5 domain
        //
        NtStatus = STATUS_NO_SUCH_DOMAIN;
    }

Cleanup:

    return NtStatus;

}


NTSTATUS
LsapGetDomainSidByNetbiosName(
    IN LPWSTR NetbiosName,
    OUT PSID *Sid
    )
/*++

Routine Description

    Given a netbios name, this routine will return the sid of the domain, if
    it exists.

Parameters:

    NetbiosName -- the name of the domain
    Sid -- domain sid allocated from MIDL

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DSNAME *dsname = NULL;
    ULONG  len = 0;

    ASSERT( NetbiosName );
    ASSERT( Sid );

    // Init the out param
    *Sid = NULL;

    // Check with the DS
    NtStatus = MatchDomainDnByNetbiosName( NetbiosName,
                                           NULL,
                                          &len );

    if ( NT_SUCCESS( NtStatus ) ) {

        SafeAllocaAllocate( dsname, len );

        if ( dsname == NULL ) {

            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        NtStatus = MatchDomainDnByNetbiosName( NetbiosName,
                                               dsname,
                                              &len );


        if (   NT_SUCCESS( NtStatus )
            && (dsname->SidLen > 0)    ) {

            len = RtlLengthSid( &dsname->Sid );
            *Sid = midl_user_allocate( len );
            if ( !(*Sid) ) {
                SafeAllocaFree( dsname );
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }
            RtlCopySid( len, *Sid, &dsname->Sid );
        }

        SafeAllocaFree( dsname );

    }

    if ( !(*Sid) ) {
        //
        // Something failed?  Assume not a nt5 domain
        //
        NtStatus = STATUS_NO_SUCH_DOMAIN;
    }

Cleanup:

    return NtStatus;

}


NTSTATUS
LsapGetDomainSidByDnsName(
    IN LPWSTR DnsName,
    OUT PSID *Sid
    )
/*++

Routine Description

    Given a dns name, this routine will return the sid of the domain, if
    it exists.

Parameters:

    DnsName -- the name of the domain
    Sid -- domain sid allocated from MIDL

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DSNAME *dsname = NULL;
    ULONG  len = 0;

    ASSERT( DnsName );
    ASSERT( Sid );

    // Init the out param
    *Sid = NULL;

    // Check with the DS
    NtStatus = MatchDomainDnByDnsName( DnsName,
                                       NULL,
                                      &len );

    if ( NT_SUCCESS( NtStatus ) ) {

        SafeAllocaAllocate( dsname, len );

        if ( dsname == NULL ) {

            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        NtStatus = MatchDomainDnByDnsName( DnsName,
                                           dsname,
                                           &len );


        if (   NT_SUCCESS( NtStatus )
            && (dsname->SidLen > 0)    ) {

            len = RtlLengthSid( &dsname->Sid );
            *Sid = midl_user_allocate( len );
            if ( !(*Sid) ) {
                SafeAllocaFree( dsname );
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }
            RtlCopySid( len, *Sid, &dsname->Sid );
        }

        SafeAllocaFree( dsname );

    }

    if ( !(*Sid) ) {
        //
        // Something failed?  Assume not a nt5 domain
        //
        NtStatus = STATUS_NO_SUCH_DOMAIN;
    }

Cleanup:

    return NtStatus;

}

VOID
LsapConvertExTrustToOriginal(
    IN OUT PLSAPR_TRUST_INFORMATION TrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformationEx
    )
{
    RtlZeroMemory( TrustInformation, sizeof(LSAPR_TRUST_INFORMATION) );
    RtlCopyMemory( &TrustInformation->Name, &TrustInformationEx->FlatName, sizeof(UNICODE_STRING) );
    TrustInformation->Sid = TrustInformationEx->Sid;

    return;
}


VOID
LsapConvertTrustToEx(
    IN OUT PLSAPR_TRUST_INFORMATION_EX TrustInformationEx,
    IN PLSAPR_TRUST_INFORMATION TrustInformation
)
{
    RtlZeroMemory( TrustInformationEx, sizeof(LSAPR_TRUST_INFORMATION_EX) );
    RtlCopyMemory( &TrustInformationEx->FlatName, &TrustInformation->Name, sizeof(UNICODE_STRING) );
    TrustInformationEx->Sid = TrustInformation->Sid;
}

NTSTATUS
LsapDbOpenPolicyGc (
    OUT HANDLE *LsaPolicyHandle                        
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD    WinError = ERROR_SUCCESS;
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    DcName;

    ASSERT( LsaPolicyHandle );

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    //
    // Find a GC in our forest
    //
    WinError = DsGetDcName(
                    NULL,  // Local computer
                    NULL,  // Local domain
                    NULL,  // no domain guid
                    NULL,  // site doesn't matter
                    (DS_GC_SERVER_REQUIRED | 
                     DS_RETURN_DNS_NAME | 
                     DS_DIRECTORY_SERVICE_REQUIRED),
                    &DcInfo );

    if ( ERROR_SUCCESS != WinError ) {

        //
        // No GC?
        //
        Status = STATUS_DS_GC_NOT_AVAILABLE;
        goto Finish;
        
    }

    //
    // Open it
    //
    RtlInitUnicodeString( &DcName, DcInfo->DomainControllerName );
    Status = LsaOpenPolicy( &DcName,
                            &ObjectAttributes,
                            POLICY_LOOKUP_NAMES,
                            LsaPolicyHandle );

    if ( !NT_SUCCESS( Status ) ) {

        //
        // A problem binding means that we can't access the GC for what ever
        // reason so return that code
        //
        Status = STATUS_DS_GC_NOT_AVAILABLE;
        goto Finish;
        
    }

Finish:

    if ( DcInfo ) {
        NetApiBufferFree( DcInfo );
    }

    return Status;
}

BOOLEAN
LsapRevisionCanHandleNewErrorCodes (
    IN ULONG Revision
    )
{
    return (Revision != LSA_CLIENT_PRE_NT5);
}

//
// The LSA Lookup Policy Cache
//
//
// During lookup operations the code frequently needs to know the current
// Account and DNS domain policy information.  Since this information is
// largely static, it is suited for caching.
//
// LsapDbPolicyCache contains the cached information.  When the policy changes, 
// a callback function is called (LsapDbLookupDomainCacheNotify) that NULL's
// out this value.  The existing global value is freed in one hour.  The next 
// time LsapDbLookupGetDomainInfo is called, new values are placed in the cache. 
// Note that this scheme does not require any locks.
//

//
// This typedef describes the format of the cache
//
typedef struct _LSAP_DB_DOMAIN_CACHE_TYPE
{
    PPOLICY_ACCOUNT_DOMAIN_INFO Account;
    PPOLICY_DNS_DOMAIN_INFO     Dns;
}LSAP_DB_DOMAIN_CACHE_TYPE, *PLSAP_DB_DOMAIN_CACHE_TYPE;

//
// This is global cache value, gaurded in code by InterlockedExchangePointer
//
PLSAP_DB_DOMAIN_CACHE_TYPE LsapDbPolicyCache = NULL;


NTSTATUS
LsapDbLookupFreeDomainCache(
    PVOID p
    )
/*++

Routine Description:

    This routine frees a cached copy of the LSA Lookup Policy Cache.

Arguments:

    p -- a valid pointer to LSAP_DB_DOMAIN_CACHE_TYPE

Return Values:

    STATUS_SUCCESS

--*/
{
    ASSERT(p);
    if (p) {
        PLSAP_DB_DOMAIN_CACHE_TYPE Cache = (PLSAP_DB_DOMAIN_CACHE_TYPE)p;
        if (Cache->Account) {
            LsaIFree_LSAPR_POLICY_INFORMATION(PolicyAccountDomainInformation,
                                             (PLSAPR_POLICY_INFORMATION) Cache->Account);
        }
        if (Cache->Dns) {
            LsaIFree_LSAPR_POLICY_INFORMATION(PolicyDnsDomainInformation,
                                             (PLSAPR_POLICY_INFORMATION) Cache->Dns);
        }

        LocalFree(p);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
LsapDbLookupBuildDomainCache(
    OUT PLSAP_DB_DOMAIN_CACHE_TYPE *pCache OPTIONAL
    )
/*++

Routine Description:

    This routine queries the LSA to find out the current policy settings 
    (Account and DNS domain) and then places the information in the LSA
    Lookup Policy cache.
    
    Note that the current values are freed after 1 hour.

Arguments:

    pCache -- the value of the new cache created by this routine; caller should
              not free

Return Values:

    STATUS_SUCCESS, or a resource error

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PPOLICY_ACCOUNT_DOMAIN_INFO LocalAccountDomainInfo = NULL;
    PPOLICY_DNS_DOMAIN_INFO LocalDnsDomainInfo = NULL;
    PLSAP_DB_DOMAIN_CACHE_TYPE NewCache = NULL, OldCache = NULL;

    NewCache = LocalAlloc(LMEM_ZEROINIT, sizeof(*NewCache));
    if (NULL == NewCache) {
        return STATUS_NO_MEMORY;
    }

    Status = LsaIQueryInformationPolicyTrusted(PolicyAccountDomainInformation,
                         (PLSAPR_POLICY_INFORMATION *) &LocalAccountDomainInfo);
    if (NT_SUCCESS(Status)) {

        Status = LsaIQueryInformationPolicyTrusted(PolicyDnsDomainInformation,
                             (PLSAPR_POLICY_INFORMATION *) &LocalDnsDomainInfo);
    
    }

    if (NT_SUCCESS(Status)) {

        ASSERT(NULL != LocalAccountDomainInfo);
        ASSERT(NULL != LocalDnsDomainInfo);

        NewCache->Account = LocalAccountDomainInfo;
        LocalAccountDomainInfo = NULL;
        NewCache->Dns = LocalDnsDomainInfo;
        LocalDnsDomainInfo = NULL;

        //
        // Return the new cache to caller
        //
        if (pCache) {
            *pCache = NewCache;
        }

        //
        // Carefully move new cache to global pointer
        //
        OldCache = InterlockedExchangePointer(&LsapDbPolicyCache, NewCache);

        //
        // Don't free the NewCache since it is now in the global space
        //
        NewCache = NULL;

        if (OldCache) {

            LsaIRegisterNotification(LsapDbLookupFreeDomainCache,
                                     OldCache,
                                     NOTIFIER_TYPE_INTERVAL,
                                     0, // no class
                                     NOTIFIER_FLAG_ONE_SHOT,
                                     60 * 60,  // free in one hour
                                     NULL); // no handle
            //
            //  N.B Memory leak of OldCache if failed to register task
            //
        }
    }

    if (LocalAccountDomainInfo) {
        LsaIFree_LSAPR_POLICY_INFORMATION(PolicyAccountDomainInformation,
                                         (PLSAPR_POLICY_INFORMATION) LocalAccountDomainInfo);
    }

    if (LocalDnsDomainInfo) {
        LsaIFree_LSAPR_POLICY_INFORMATION(PolicyDnsDomainInformation,
                                         (PLSAPR_POLICY_INFORMATION) LocalDnsDomainInfo);
    }

    if (NewCache) {
        LocalFree(NewCache);
    }

    return Status;

}

NTSTATUS
LsapDbLookupGetDomainInfo(
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO *AccountDomainInfo OPTIONAL,
    OUT PPOLICY_DNS_DOMAIN_INFO *DnsDomainInfo OPTIONAL
    )
/*++

Routine Description:

    This routine returns to the caller a reference to the global copy
    of the cached Account or DNS domain policy.  Caller must not free.

Arguments:

    p -- a valid pointer to LSAP_DB_DOMAIN_CACHE_TYPE

Return Values:

    STATUS_SUCCESS

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    //
    // Get a copy of the global cache
    //
    PLSAP_DB_DOMAIN_CACHE_TYPE LocalPolicyCache = LsapDbPolicyCache;

    //
    // If the cache is empty, fill it
    //
    if (NULL == LocalPolicyCache) {
        //
        // This will only fail on resource error
        //
        NtStatus = LsapDbLookupBuildDomainCache(&LocalPolicyCache);
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }
    }

    //
    // We must have valid values
    //
    ASSERT(NULL != LocalPolicyCache);
    ASSERT(NULL != LocalPolicyCache->Account);
    ASSERT(NULL != LocalPolicyCache->Dns);

    if (AccountDomainInfo) {
        *AccountDomainInfo = LocalPolicyCache->Account;
    }

    if (DnsDomainInfo) {
        *DnsDomainInfo = LocalPolicyCache->Dns;
    }

    return NtStatus;

}

NTSTATUS
LsapDbLookupDomainCacheNotify(
    PVOID p
    )
/*++

Routine Description:

    This routine is called when a change occurs to the system's policy. This
    routine rebuilds the LSA policy cache.

Arguments:

    p -- ignored.

Return Values:

    STATUS_SUCCESS, or a resource error

--*/
{
    PLSAP_DB_DOMAIN_CACHE_TYPE OldCache;

    //
    // Invalidate the current cache
    //
    OldCache = InterlockedExchangePointer(&LsapDbPolicyCache,
                                           NULL);
    if (OldCache) {

        //
        // Free the memory in an hour
        //
        LsaIRegisterNotification(LsapDbLookupFreeDomainCache,
                                 OldCache,
                                 NOTIFIER_TYPE_INTERVAL,
                                 0, // no class
                                 NOTIFIER_FLAG_ONE_SHOT,
                                 60 * 60,  // free in one hour
                                 NULL); // no handle
    
        //
        //  N.B Memory leak of OldCache if failed to register task
        //
    }
    
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(p);

}

NTSTATUS
LsapDbLookupInitPolicyCache(
    VOID
    )
/*++

Routine Description:

    This routine initializes the LSA Lookup Policy Cache.

Arguments:

    None.

Return Values:

    STATUS_SUCCESS, or a resources error

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE   hEvent = NULL;
    PVOID    fItem = NULL;

    //
    // Create event to be used to notify us of changes to the domain
    // policy
    //
    hEvent = CreateEvent(NULL,  // use default access control
                         FALSE, // reset automatically
                         FALSE, // start off non-signalled
                         NULL );
    if (NULL == hEvent) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set the function to be called on change
    //
    fItem = LsaIRegisterNotification(LsapDbLookupDomainCacheNotify,
                                     NULL,
                                     NOTIFIER_TYPE_HANDLE_WAIT,
                                     0, // no class,
                                     0,
                                     0,
                                     hEvent);
    if (NULL == fItem) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Set the event to be set on change
    //
    Status = LsaRegisterPolicyChangeNotification(PolicyNotifyAccountDomainInformation,
                                                 hEvent);
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaRegisterPolicyChangeNotification(PolicyNotifyDnsDomainInformation,
                                                 hEvent);
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }
    
    Status = LsapDbLookupBuildDomainCache(NULL);
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Success!
    //
    fItem = NULL;
    hEvent = NULL;

Cleanup:

    if (fItem) {
        LsaICancelNotification(fItem);
    }

    if (hEvent) {
        CloseHandle(hEvent);
    }

    return Status;

}

BOOLEAN
LsapDbIsStatusConnectionFailure(
    NTSTATUS st
    )
/*++

Routine Description:

    This routine returns TRUE if the status provided indicates a trust
    or connection error that prevented the lookup from succeeding.                 

Arguments:

    None.

Return Values:

    TRUE, FALSE

--*/
{
    switch (st) {
    case STATUS_TRUSTED_DOMAIN_FAILURE:
    case STATUS_TRUSTED_RELATIONSHIP_FAILURE:
    case STATUS_DS_GC_NOT_AVAILABLE:
        return TRUE;
    }

    return FALSE;

}


NTSTATUS
LsapDbLookupAccessCheck(
    IN LSAPR_HANDLE PolicyHandle
    )
/*++

Routine Description:

    This routine performs an access on PolicyHandle to see if the handle
    has the right to perform a lookup.

Arguments:

    PolicyHanlde -- an RPC context handle

Return Values:

    STATUS_SUCCESS, STATUS_ACCESS_DENIED, other resource errors

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (PolicyHandle) {

        //
        // Acquire the Lsa Database lock.  Verify that the connection handle is
        // valid, is of the expected type and has all of the desired accesses
        // granted.  Reference he handle.
        //
        Status = LsapDbReferenceObject(
                     PolicyHandle,
                     POLICY_LOOKUP_NAMES,
                     PolicyObject,
                     NullObject,
                     LSAP_DB_READ_ONLY_TRANSACTION | LSAP_DB_NO_DS_OP_TRANSACTION
                     );
    
        if (NT_SUCCESS(Status)) {
            //
            // We can dereference the original PolicyHandle and release the lock on
            // the LSA Database; if we need to access the database again, we'll
            // use the trusted Lsa handle and the appropriate API will take
            // the lock as required.
            //
            Status = LsapDbDereferenceObject(
                         &PolicyHandle,
                         PolicyObject,
                         NullObject,
                         LSAP_DB_READ_ONLY_TRANSACTION | LSAP_DB_NO_DS_OP_TRANSACTION,
                         (SECURITY_DB_DELTA_TYPE) 0,
                         Status
                         );
        }

    } else {

        //
        // Only NETLOGON can call without a policy handle
        //
        ULONG RpcErr;
        ULONG AuthnLevel = 0;
        ULONG AuthnSvc = 0;
        
        RpcErr = RpcBindingInqAuthClient(
                    NULL,
                    NULL,               // no privileges
                    NULL,               // no server principal name
                    &AuthnLevel,
                    &AuthnSvc,
                    NULL                // no authorization level
                    );
        //
        // If it as authenticated at level packet integrity or better
        // and is done with the netlogon package, allow it through
        //
        if ((RpcErr == ERROR_SUCCESS) &&
            (AuthnLevel >= RPC_C_AUTHN_LEVEL_PKT_INTEGRITY) &&
            (AuthnSvc == RPC_C_AUTHN_NETLOGON )) {
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_ACCESS_DENIED;
        }
    }

    return Status;

}


NTSTATUS
LsapDbLookupGetServerConnection(
    IN  LSAPR_TRUST_INFORMATION_EX *TrustInfo,
    IN  DWORD             Flags,
    IN  LSAP_LOOKUP_LEVEL LookupLevel,
    OUT LPWSTR        *ServerName,
    OUT NL_OS_VERSION *ServerOsVersion,
    OUT LPWSTR        *ServerPrincipalName,
    OUT PVOID         *ClientContext,
    OUT ULONG         *AuthnLevel,
    OUT LSA_HANDLE    *PolicyHandle,
    OUT PLSAP_BINDING_CACHE_ENTRY * CachedPolicyEntry
    )
/*++

Routine Description:

    This routines returns connection information to a domain controller in the
    domain specified by TrustInfo, if one can be found.
    
    Primarily, this routine uses I_NetLogonGetAuthData to obtain the secure
    channel DC.  If the secure channel DC is NT4 or less, this routine won't
    work, so the code falls back to using the locator (DsGetDcName).
    
    Once a DC is found, if the DC is Whistler and we have a client context,
    then we can exit since that is that is needed by the Whister protocol.
    Otherwise, the call falls back to obtaining an LSA policy handle.
    
    N.B. Which OUT parameters are allocated depends on flags and network
    environment.

Arguments:

    TrustInfo -- contains the destination domain; at least one of DomainName
                 or FlatName must be present; Sid is optional.
    
    Flags --  LSAP_LOOKUP_CONNECTION_GET_HANDLE -- even if the secure channel
                                                   DC is Whistler and a client
                                                   context is available, obtain
                                                   a policy handle.  This is
                                                   need for Whistler beta1
                                                   interop.
             
    LookupLevel -- the kind of chaining being performed
    
    Server -- out, the destination server name, NULL terminated
    
    ServerOsVersion -- out, the OS version
    
    ServerPrincipalName, 
    ClientContext, 
    AuthnLevel     -- out, goo needed for RpcSetAuthInfo
    
    PolicyHandle -- out, a policy to the destination DC.
    
    CachedPolicyEntry -- out, a binding handle cache (only for TDL's)

Return Values:

    STATUS_SUCCESS, or fatal resource or network related error.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LPWSTR  TargetDomain = NULL;
    PUNICODE_STRING  TargetDomainU;
    ULONG   Size;
    ULONG   NlFlags = 0;
    LPWSTR  NetlogonServerName = NULL;

    //
    // Init the out parameters
    //
    *ServerName = NULL;       
    *ServerPrincipalName = NULL;
    *ClientContext = NULL;
    *PolicyHandle = NULL;
    *CachedPolicyEntry = NULL;

    if (TrustInfo->DomainName.Length > 0) {
        TargetDomainU = (PUNICODE_STRING) &TrustInfo->DomainName;
    } else {
        TargetDomainU = (PUNICODE_STRING) &TrustInfo->FlatName;
    }
    ASSERT(TargetDomainU->Length > 0);
    
    //
    // Make the domain name null terminated
    //
    Size = TargetDomainU->Length + sizeof(WCHAR);

    SafeAllocaAllocate( TargetDomain, Size );

    if ( TargetDomain == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(TargetDomain, Size);
    RtlCopyMemory(TargetDomain, TargetDomainU->Buffer, TargetDomainU->Length);

    //
    // Determine the type of secure channel we need
    //
    if (LookupLevel == LsapLookupXForestReferral) {
        NlFlags |= NL_RETURN_CLOSEST_HOP;
    } else {
        NlFlags |= NL_DIRECT_TRUST_REQUIRED;
    }

    //
    // Try to obtain a secure channel
    //
    Status = I_NetLogonGetAuthDataEx(NULL,  // local domain
                                     TargetDomain,
                                     FALSE, // don't reset channel
                                     NlFlags,
                                     &NetlogonServerName,
                                     ServerOsVersion,
                                     ServerPrincipalName,
                                     ClientContext,
                                     AuthnLevel);

    if (NT_SUCCESS(Status)) {
        //
        // Realloc the ServerName
        //
        Size = (wcslen(NetlogonServerName) + 1) * sizeof(WCHAR);
        *ServerName = LocalAlloc(LMEM_ZEROINIT, Size);
        if (NULL == *ServerName) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        wcscpy(*ServerName, NetlogonServerName);
        I_NetLogonFree( NetlogonServerName );
        NetlogonServerName = NULL;

    }

    if (!NT_SUCCESS(Status)) {

        //
        // This is a fatal error for this batch of names
        //
        LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: I_NetLogonGetAuthDataEx to %ws failed (0x%x)\n", TargetDomain, Status));

        LsapDbLookupReportEvent2( 1,
                                  EVENTLOG_WARNING_TYPE,
                                  LSAEVENT_LOOKUP_SC_FAILED,
                                  sizeof( ULONG ),
                                  &Status,
                                  TargetDomain,
                                  TargetDomain );

        goto Cleanup;

    }
    ASSERT(NULL != *ServerName);

    //
    // We have a destination DC
    //
    if ( (*ServerOsVersion < NlWhistler)
      || ((*ServerOsVersion >= NlWhistler) && (*ClientContext == NULL))
      || (Flags & LSAP_LOOKUP_CONNECTION_GET_HANDLE) == LSAP_LOOKUP_CONNECTION_GET_HANDLE  ) {

        //
        // Get a policy handle because either
        //
        // 1. Secure channel DC is not at least Whistler 
        // 2. Secure channel is configured to not use auth blob (no sign or seal)
        // 3. Caller requested a handle (Whistler beta w/o new lookup API's)
        //
        LSAPR_TRUST_INFORMATION TrustInformation;
        UNICODE_STRING DomainControllerName;

        RtlInitUnicodeString(&DomainControllerName, *ServerName);
        //
        // We use the flat name here since part of the validate routine
        // compares the name against the AccountDomainName of the target
        // domain controller.
        //
        RtlZeroMemory(&TrustInformation, sizeof(TrustInformation));
        TrustInformation.Name = TrustInfo->FlatName;

        if (LookupLevel == LsapLookupTDL) {

            //
            // Use the caching scheme; note that this routine will take 
            // ownership of ServerName, ServerPrincipalName, and ClientContext
            // on success (and will hence set them to NULL)
            //
            Status = LsapDbGetCachedHandleTrustedDomain(&TrustInformation,
                                                        POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,
                                                        ServerName,
                                                        ServerPrincipalName,
                                                        ClientContext,
                                                        CachedPolicyEntry);

        } else {

            Status = LsapRtlValidateControllerTrustedDomain( (PLSAPR_UNICODE_STRING)&DomainControllerName,
                                                             &TrustInformation,
                                                             POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,
                                                             *ServerPrincipalName,
                                                             *ClientContext,
                                                             PolicyHandle );
        }

        if (!NT_SUCCESS(Status)) {
    
            //
            // This is a fatal error for this batch of names
            //
            LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: Failed to open a policy handle to %ws (0x%x)\n", *ServerName, Status));
    
            LsapDbLookupReportEvent2( 1,
                                      EVENTLOG_WARNING_TYPE,
                                      LSAEVENT_LOOKUP_SC_HANDLE_FAILED,
                                      sizeof( ULONG ),
                                      &Status,
                                      *ServerName,
                                      *ServerName );
            goto Cleanup;
        }
    }

Cleanup:

    if (!NT_SUCCESS(Status)) {

        if (*PolicyHandle != NULL) {
            LsaClose( *PolicyHandle );
            *PolicyHandle = NULL;
        }
        if (NetlogonServerName != NULL) {
            I_NetLogonFree(NetlogonServerName);
        }
        if (*ServerPrincipalName != NULL) {
            I_NetLogonFree(*ServerPrincipalName);
            *ServerPrincipalName = NULL;
        }
        if (*ClientContext != NULL) {
            I_NetLogonFree(*ClientContext);
            *ClientContext = NULL;
        }
        if (*ServerName) {
            LocalFree(*ServerName);
            *ServerName = NULL;
        }
        if (*CachedPolicyEntry) {
            LsapDereferenceBindingCacheEntry(*CachedPolicyEntry);
            *CachedPolicyEntry = NULL;
        }

    } else {

        //
        // Either a auth info, a policy handle, or a cached policy handle
        // must be returned
        //
        ASSERT( (*PolicyHandle != NULL) 
             || (*ClientContext != NULL)
             || (*CachedPolicyEntry != NULL));

    }

    SafeAllocaFree( TargetDomain );

    return Status;
}

NTSTATUS
LsapDbLookupNameChainRequest(
    IN LSAPR_TRUST_INFORMATION_EX *TrustInfo,
    IN  ULONG Count,
    IN  PUNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID_EX2 *Sids,
    IN  LSAP_LOOKUP_LEVEL LookupLevel,
    OUT PULONG MappedCount,
    OUT PULONG ServerRevision
    )
/*++

Routine Description:

    This routine is the general purpose routine to be used when ever 
    a name request needs to be chained (be resolved off machine). This includes
    
    member -> DC
    DC     -> trusted domain DC
    DC     -> trusted forest DC

Arguments:

    TrustInfo -- contains the destination domain; at least one of DomainName
                 or FlatName must be present; Sid is optional.
    
    Count --  the number of Names to be resovled
    
    Names -- the names to be resolved
    
    ReferencedDomains -- out, the resolved domain referenced
    
    Sids -- out, the resolved SID's
    
    LookupLevel -- the type of chaining requested
    
    MappedCount -- out, the number of Names fully resolved
    
    ServerRevision -- the LSA lookup revision of the target

Return Values:

    STATUS_SUCCESS
    
    STATUS_NONE_MAPPED
    
    STATUS_SOME_NOT_MAPPED
    
    other fatal resource errors
           
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    LPWSTR ServerPrincipalName = NULL;
    LPWSTR ServerName = NULL;
    PVOID ClientContext = NULL;
    ULONG AuthnLevel;
    NL_OS_VERSION ServerOsVersion;
    LSA_HANDLE ControllerPolicyHandle = NULL;
    DWORD ConnectionFlags = 0;
    BOOLEAN fLookupCallFailed = FALSE;
    PUNICODE_STRING DestinationDomain;
    PLSAP_BINDING_CACHE_ENTRY ControllerPolicyEntry = NULL;
    LPWSTR     TargetServerName = NULL;

    if (TrustInfo->DomainName.Length > 0) {
        DestinationDomain = (PUNICODE_STRING)&TrustInfo->DomainName;
    } else {
        DestinationDomain = (PUNICODE_STRING)&TrustInfo->FlatName;
    }
    ASSERT(DestinationDomain->Length > 0);
    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: Chaining a name request to %wZ of type %ws\n", DestinationDomain, LsapDbLookupGetLevel(LookupLevel)) );

    while (TRUE) {

        Status = LsapDbLookupGetServerConnection(TrustInfo,
                                                 ConnectionFlags,
                                                 LookupLevel,
                                                &ServerName,
                                                &ServerOsVersion,
                                                &ServerPrincipalName,
                                                &ClientContext,
                                                &AuthnLevel,
                                                &ControllerPolicyHandle,
                                                &ControllerPolicyEntry);
    
    
        if (!NT_SUCCESS(Status)) {
    
            //
            // This is a fatal error for this batch of names
            //
            LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: Can't get server connection to %wZ (0x%x)\n", DestinationDomain, Status));
    
            goto Cleanup;
    
        }
    
        //
        // We have the secure channel
        //
        if (  (ServerOsVersion >= NlWhistler)
           && (ClientContext != NULL)
           && ((ConnectionFlags & LSAP_LOOKUP_CONNECTION_GET_HANDLE) == 0)) {
    
            //
            // Use new version
            //
    
            Status = LsaICLookupNamesWithCreds(ServerName,
                                             ServerPrincipalName,
                                             AuthnLevel,
                                             RPC_C_AUTHN_NETLOGON,
                                             ClientContext,
                                             RPC_C_AUTHZ_NONE,
                                             Count,
                                             (PUNICODE_STRING)Names,
                                             (PLSA_REFERENCED_DOMAIN_LIST *)ReferencedDomains,
                                             (PLSA_TRANSLATED_SID_EX2 * )Sids,
                                             LookupLevel,
                                             MappedCount);

            if (Status == STATUS_NOT_SUPPORTED) {
                //
                // RPC interface is not known -- retry with handle.  This
                // code can be removed once support for Whistler beta1 is dropped.
                //
                if (ServerName != NULL) {
                    LocalFree(ServerName);
                    ServerName = NULL;
                }
                if (ServerPrincipalName != NULL) {
                    I_NetLogonFree(ServerPrincipalName);
                    ServerPrincipalName = NULL;
                }
                if (ClientContext != NULL) {
                    I_NetLogonFree(ClientContext);
                    ClientContext = NULL;
                }
                ASSERT( NULL == ControllerPolicyHandle);
                ASSERT( NULL == ControllerPolicyEntry);
                ConnectionFlags |= LSAP_LOOKUP_CONNECTION_GET_HANDLE;
                continue;
            }
    
            if (ServerRevision) {
                *ServerRevision = LSA_CLIENT_LATEST;
            }

            TargetServerName = ServerName;
    
            if (!NT_SUCCESS(Status)
             && Status != STATUS_NONE_MAPPED  ) {
    
                //
                // This is a fatal error for this batch of names
                //
                LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsaICLookupNamesWithCreds to %ws failed (0x%x)\n", ServerName, Status));
                fLookupCallFailed = TRUE;
                goto Cleanup;
            }
            LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsaICLookupNamesWithCreds to %ws succeeded\n", ServerName));
    
    
        } else {
    
            LSA_HANDLE TargetHandle;
            ULONG LsaICLookupFlags = 0;

            LsaICLookupFlags = LsapLookupGetChainingFlags(ServerOsVersion);

            if (ControllerPolicyEntry) {
                TargetHandle = ControllerPolicyEntry->PolicyHandle;
                TargetServerName = ControllerPolicyEntry->ServerName;
                ASSERT( NULL == ControllerPolicyHandle);
            } else {
                TargetHandle = ControllerPolicyHandle;
                TargetServerName = ServerName;
            }
            ASSERT(NULL != TargetHandle);
    
            Status = LsaICLookupNames(
                         TargetHandle,
                         0, // no flags necessary
                         Count,
                         (PUNICODE_STRING) Names,
                         (PLSA_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                         (PLSA_TRANSLATED_SID_EX2 *) Sids,
                         LookupLevel,
                         LsaICLookupFlags,
                         MappedCount,
                         ServerRevision
                         );
    
            if (!NT_SUCCESS(Status)
             && Status != STATUS_NONE_MAPPED  ) {
    
                //
                // This is a fatal error for this batch of names
                //
                LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsaICLookupNames to %ws failed (0x%x)\n", TargetServerName, Status));
                fLookupCallFailed = TRUE;
                goto Cleanup;
            }
            LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsaICLookupNames to %ws succeeded\n", TargetServerName));
    
        }

        break;
    }

Cleanup:

    if (fLookupCallFailed) {

        ASSERT(NULL != TargetServerName);

        LsapDbLookupReportEvent2( 1,
                                  EVENTLOG_WARNING_TYPE,
                                  LSAEVENT_LOOKUP_SC_LOOKUP_FAILED,
                                  sizeof( ULONG ),
                                  &Status,
                                  TargetServerName,
                                  TargetServerName );
    }

    if (  !NT_SUCCESS(Status)
      &&  (Status != STATUS_NONE_MAPPED)
      &&  !LsapDbIsStatusConnectionFailure(Status)) {

        //
        // An error occurred not one that our callers will understand.
        // The specific error has already been logged, so return a general one.
        //
        if (LookupLevel == LsapLookupPDC) {
            Status = STATUS_TRUSTED_RELATIONSHIP_FAILURE;
        } else {
            Status = STATUS_TRUSTED_DOMAIN_FAILURE;
        }
    }

    if (ControllerPolicyHandle != NULL) {
        LsaClose( ControllerPolicyHandle );
    }
    if (ServerName != NULL) {
        LocalFree(ServerName);
    }
    if (ServerPrincipalName != NULL) {
        I_NetLogonFree(ServerPrincipalName);
    }
    if (ClientContext != NULL) {
        I_NetLogonFree(ClientContext);
    }
    if (ControllerPolicyEntry) {
        LsapDereferenceBindingCacheEntry( ControllerPolicyEntry );
    }

    return Status;
}

NTSTATUS
LsaDbLookupSidChainRequest(
    IN LSAPR_TRUST_INFORMATION_EX *TrustInfo,
    IN ULONG Count,
    IN PSID *Sids,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_NAME_EX *Names,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    OUT PULONG ServerRevision OPTIONAL
    )

/*++

Routine Description:

    This routine is the general purpose routine to be used when ever 
    a SID request needs to be chained (be resolved off machine). This includes
    
    member -> DC
    DC     -> trusted domain DC
    DC     -> trusted forest DC

Arguments:

    TrustInfo -- contains the destination domain; at least one of DomainName
                 or FlatName must be present; Sid is optional.
    
    Count --  the number of SIDs to be resovled
    
    Sids -- the Sids to be resolved
    
    ReferencedDomains -- out, the resolved domain referenced
    
    Names -- out, the resolved names's
    
    LookupLevel -- the type of chaining requested
    
    MappedCount -- out, the number of Names fully resolved
    
    ServerRevision -- the LSA lookup revision of the target

Return Values:

    STATUS_SUCCESS
    
    STATUS_NONE_MAPPED
    
    STATUS_SOME_NOT_MAPPED
    
    STATUS_TRUSTED_DOMAIN_FAILURE
    
    STATUS_TRUSTED_RELATIONSHIP_FAILURE
    
    other fatal resource errors
           
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LPWSTR ServerName = NULL;
    NL_OS_VERSION ServerOsVersion;
    LPWSTR ServerPrincipalName = NULL;
    PVOID ClientContext = NULL;
    ULONG AuthnLevel;
    LSA_HANDLE ControllerPolicyHandle = NULL;
    DWORD ConnectionFlags = 0;
    BOOLEAN fLookupCallFailed = FALSE;
    PUNICODE_STRING DestinationDomain;
    PLSAP_BINDING_CACHE_ENTRY ControllerPolicyEntry = NULL;
    LPWSTR     TargetServerName = NULL;

    if (TrustInfo->DomainName.Length > 0) {
        DestinationDomain = (PUNICODE_STRING)&TrustInfo->DomainName;
    } else {
        DestinationDomain = (PUNICODE_STRING)&TrustInfo->FlatName;
    }
    ASSERT(DestinationDomain->Length > 0);
    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: Chaining a SID request to %wZ of type %ws\n", DestinationDomain, LsapDbLookupGetLevel(LookupLevel)) );

    while (TRUE) {

        Status = LsapDbLookupGetServerConnection(TrustInfo,
                                                 ConnectionFlags,
                                                 LookupLevel,
                                                &ServerName,
                                                &ServerOsVersion,
                                                &ServerPrincipalName,
                                                &ClientContext,
                                                &AuthnLevel,
                                                &ControllerPolicyHandle,
                                                &ControllerPolicyEntry);
    
        if (!NT_SUCCESS(Status)) {
    
            //
            // This is a fatal error for this batch of names
            //
            LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: Can't get server connection to %wZ  failed (0x%x)\n", DestinationDomain, Status));
    
            goto Cleanup;
    
        }
    
        //
        // We have the secure channel
        //
        if ( (ServerOsVersion >= NlWhistler)
          && (ClientContext != NULL)
          && ((ConnectionFlags & LSAP_LOOKUP_CONNECTION_GET_HANDLE) == 0) ){
    
            //
            // Use new version
            //
    
            Status = LsaICLookupSidsWithCreds(ServerName,
                                            ServerPrincipalName,
                                            AuthnLevel,
                                            RPC_C_AUTHN_NETLOGON,
                                            ClientContext,
                                            RPC_C_AUTHZ_NONE,
                                            Count,
                                            (PSID*)Sids,
                                            (PLSA_REFERENCED_DOMAIN_LIST *)ReferencedDomains,
                                            (PLSA_TRANSLATED_NAME_EX * )Names,
                                            LookupLevel,
                                            MappedCount);
    
    
            if (Status == STATUS_NOT_SUPPORTED) {

                //
                // RPC interface is not known -- retry with handle.  This
                // code can be removed once support for Whistler beta1 is dropped.
                //
                if (ServerName != NULL) {
                    LocalFree(ServerName);
                    ServerName = NULL;
                }
                if (ServerPrincipalName != NULL) {
                    I_NetLogonFree(ServerPrincipalName);
                    ServerPrincipalName = NULL;
                }
                if (ClientContext != NULL) {
                    I_NetLogonFree(ClientContext);
                    ClientContext = NULL;
                }
                ASSERT( NULL == ControllerPolicyHandle);
                ASSERT( NULL == ControllerPolicyEntry);
                ConnectionFlags |= LSAP_LOOKUP_CONNECTION_GET_HANDLE;
                continue;
            }
            if (ServerRevision) {
                *ServerRevision = LSA_CLIENT_LATEST;
            }
            TargetServerName = ServerName;
    
            if (!NT_SUCCESS(Status)
             && Status != STATUS_NONE_MAPPED  ) {
    
                //
                // This is a fatal error for this batch of names
                //
                LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsaICLookupSidsWithCreds to %ws failed 0x%x\n", ServerName, Status));
                fLookupCallFailed = TRUE;
                goto Cleanup;
            } else {
                LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsaICLookupSidsWithCreds to %ws succeeded\n", ServerName));
            }
    
        } else {
    
            //
            // Must use downlevel API
            //
            LSA_HANDLE TargetHandle;
            ULONG LsaICLookupFlags = 0;

            LsaICLookupFlags = LsapLookupGetChainingFlags(ServerOsVersion);

            if (ControllerPolicyEntry) {
                TargetHandle = ControllerPolicyEntry->PolicyHandle;
                TargetServerName = ControllerPolicyEntry->ServerName;
                ASSERT( NULL == ControllerPolicyHandle);
            } else {
                TargetHandle = ControllerPolicyHandle;
                TargetServerName = ServerName;
            }
            ASSERT(NULL != TargetHandle);

            Status = LsaICLookupSids(
                         TargetHandle,
                         Count,
                         (PSID*) Sids,
                         (PLSA_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                         (PLSA_TRANSLATED_NAME_EX *) Names,
                         LookupLevel,
                         LsaICLookupFlags,
                         MappedCount,
                         ServerRevision
                         );
    
            if (!NT_SUCCESS(Status)
             && Status != STATUS_NONE_MAPPED  ) {
    
                //
                // This is a fatal error for this batch of names
                //
    
                LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsaICLookupNames to %ws failed 0x%x\n", TargetServerName, Status));
                fLookupCallFailed = TRUE;
                goto Cleanup;

            } else {
                LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsaICLookupNames to %ws succeeded\n", TargetServerName));
            }
    
        }

        break;

    }

Cleanup:

    if (fLookupCallFailed) {

        ASSERT(NULL != TargetServerName);

        LsapDbLookupReportEvent2( 1,
                                  EVENTLOG_WARNING_TYPE,
                                  LSAEVENT_LOOKUP_SC_LOOKUP_FAILED,
                                  sizeof( ULONG ),
                                  &Status,
                                  TargetServerName,
                                  TargetServerName );
    }

    if (  !NT_SUCCESS(Status)
      &&  (Status != STATUS_NONE_MAPPED)
      &&  !LsapDbIsStatusConnectionFailure(Status)) {

        //
        // An error occurred not one that our callers will understand.
        // The specific error has already been logged, so return a general one.
        //
        if (LookupLevel == LsapLookupPDC) {
            Status = STATUS_TRUSTED_RELATIONSHIP_FAILURE;
        } else {
            Status = STATUS_TRUSTED_DOMAIN_FAILURE;
        }
    }

    if (ServerName != NULL) {
        LocalFree(ServerName);
    }
    if (ServerPrincipalName != NULL) {
        I_NetLogonFree(ServerPrincipalName);
    }
    if (ClientContext != NULL) {
        I_NetLogonFree(ClientContext);
    }
    if (ControllerPolicyHandle != NULL) {
        LsaClose( ControllerPolicyHandle );
    }
    if (ControllerPolicyEntry) {
        LsapDereferenceBindingCacheEntry( ControllerPolicyEntry );
    }

    return Status;
}



NTSTATUS
LsapLookupReallocateTranslations(
    IN OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN     ULONG Count,
    IN OUT PLSA_TRANSLATED_NAME_EX *    Names, OPTIONAL
    IN OUT PLSA_TRANSLATED_SID_EX2 *    Sids OPTIONAL
    )
/*++

Routine Description:

    This routine reallocates ReferencedDomains, Names, and Sids, from
    allocate_all_nodes, to !allocate_all_nodes.  This is so that values
    returned from chaining calls can be returned to the caller.

Arguments:

    ReferencedDomains -- the referenced domains to reallocate, if any
    
    Count -- the number of entries in either Names or Sids
    
    Names -- the names to reallocate, if any
    
    Sids -- the sids to reallocate, if any

Return Values:

    STATUS_SUCCESS, STATUS_NO_MEMORY
    
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSA_REFERENCED_DOMAIN_LIST LocalReferencedDomains = NULL;
    PLSA_TRANSLATED_NAME_EX     LocalNames = NULL;
    PLSA_TRANSLATED_SID_EX2     LocalSids = NULL;

    ULONG Length, i;
    PVOID Src = NULL, Dst = NULL;

    // Only one is allowed
    ASSERT(!((Names && *Names) && (Sids && *Sids)));

    if (*ReferencedDomains) {

        LocalReferencedDomains = midl_user_allocate(sizeof(LSA_REFERENCED_DOMAIN_LIST));
        if (NULL == LocalReferencedDomains) {
            goto MemoryFailure;
        }
        Length = sizeof(LSA_TRUST_INFORMATION) * (*ReferencedDomains)->Entries;
        LocalReferencedDomains->Domains = midl_user_allocate(Length);
        if (NULL == LocalReferencedDomains->Domains) {
            goto MemoryFailure;
        }
        RtlZeroMemory(LocalReferencedDomains->Domains, Length);
        LocalReferencedDomains->Entries = (*ReferencedDomains)->Entries;
        for (i = 0; i < LocalReferencedDomains->Entries; i++) {
            Src= (*ReferencedDomains)->Domains[i].Name.Buffer;
            if (Src) {
                Length = (*ReferencedDomains)->Domains[i].Name.Length;
                Dst = midl_user_allocate(Length);
                if (NULL == Dst) {
                    goto MemoryFailure;
                }
                RtlCopyMemory(Dst, Src, Length);
                LocalReferencedDomains->Domains[i].Name.Length = (USHORT)Length;
                LocalReferencedDomains->Domains[i].Name.MaximumLength = (USHORT)Length;
                LocalReferencedDomains->Domains[i].Name.Buffer = Dst;
                Dst = NULL;
            }
            Src = (*ReferencedDomains)->Domains[i].Sid;
            if (Src) {
                Length = GetLengthSid(Src);
                Dst = midl_user_allocate(Length);
                if (NULL == Dst) {
                    goto MemoryFailure;
                }
                CopySid(Length, Dst, Src);
                LocalReferencedDomains->Domains[i].Sid = Dst;
                Dst = NULL;
            }
        }
    }

    if (Names && *Names) {
        Length = sizeof(LSA_TRANSLATED_NAME_EX) * Count;
        LocalNames = midl_user_allocate(Length);
        if (NULL == LocalNames) {
            goto MemoryFailure;
        }
        RtlZeroMemory(LocalNames, Length);
        for (i = 0; i < Count; i++) {
            LocalNames[i] = (*Names)[i];
            RtlInitUnicodeString(&LocalNames[i].Name, NULL);
            Src = (*Names)[i].Name.Buffer;
            if (Src) {
                Length = (*Names)[i].Name.Length;
                Dst = midl_user_allocate(Length);
                if (NULL == Dst) {
                    goto MemoryFailure;
                }
                RtlCopyMemory(Dst, Src, Length);
                LocalNames[i].Name.Length = (USHORT)Length;
                LocalNames[i].Name.MaximumLength = (USHORT)Length;
                LocalNames[i].Name.Buffer = Dst;
                Dst = NULL;
            }
        }
    }

    if (Sids && *Sids) {
        Length = sizeof(LSA_TRANSLATED_SID_EX2) * Count;
        LocalSids = midl_user_allocate(Length);
        if (NULL == LocalSids) {
            goto MemoryFailure;
        }
        RtlZeroMemory(LocalSids, Length);
        for (i = 0; i < Count; i++) {
            LocalSids[i] = (*Sids)[i];
            LocalSids[i].Sid = NULL;
            Src = (*Sids)[i].Sid;
            if (Src) {
                Length = GetLengthSid(Src);
                Dst = midl_user_allocate(Length);
                if (NULL == Dst) {
                    goto MemoryFailure;
                }
                CopySid(Length, Dst, Src);
                LocalSids[i].Sid = Dst;
                Dst = NULL;
            }
        }
    }

    if (*ReferencedDomains) {
        midl_user_free(*ReferencedDomains);
        *ReferencedDomains = LocalReferencedDomains;
        LocalReferencedDomains = NULL;
    }
    if (Names && *Names) {
        midl_user_free(*Names);
        *Names = LocalNames;
        LocalNames = NULL;
    }
    if (Sids && *Sids) {
        midl_user_free(*Sids);
        *Sids = LocalSids;
        LocalSids = NULL;
    }

Exit:

    if (LocalReferencedDomains) {
        if (LocalReferencedDomains->Domains) {
            for (i = 0; i < LocalReferencedDomains->Entries; i++) {
                if (LocalReferencedDomains->Domains[i].Name.Buffer) {
                    midl_user_free(LocalReferencedDomains->Domains[i].Name.Buffer);
                }
                if (LocalReferencedDomains->Domains[i].Sid) {
                    midl_user_free(LocalReferencedDomains->Domains[i].Sid);
                }
            }
            midl_user_free(LocalReferencedDomains->Domains);
        }
        midl_user_free(LocalReferencedDomains);
    }

    if (LocalNames) {
        for (i = 0; i < Count; i++) {
            if (LocalNames[i].Name.Buffer) {
                midl_user_free(LocalNames[i].Name.Buffer);
            }
        }
        midl_user_free(LocalNames);
    }


    if (LocalSids) {
        for (i = 0; i < Count; i++) {
            if (LocalSids[i].Sid) {
                midl_user_free(LocalSids[i].Sid);
            }
        }
        midl_user_free(LocalSids);
    }

    return Status;

MemoryFailure:

    Status = STATUS_NO_MEMORY;
    goto Exit;

}

#if DBG
LPWSTR
LsapDbLookupGetLevel(
    IN LSAP_LOOKUP_LEVEL LookupLevel
    )
//
// Simple debug helper routine
//
{
    switch (LookupLevel) {
        case LsapLookupWksta:
            return L"LsapLookupWksta";
        case LsapLookupPDC:
            return L"LsapLookupPDC";
        case LsapLookupTDL:
            return L"LsapLookupTDL";
        case LsapLookupGC:
            return L"LsapLookupGC";
        case LsapLookupXForestReferral:
            return L"LsapLookupXForestReferral";
        case LsapLookupXForestResolve:
            return L"LsapLookupXForestResolve";
        default:
            return L"Unknown Lookup Level";
    }
}
#endif


NTSTATUS
LsapDomainHasDomainTrust(
    IN ULONG           Flags,
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    IN OUT  BOOLEAN   *fTDLLock,   OPTIONAL
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustEntryOut OPTIONAL
    )
/*++

Routine Description:

    This routine determines if the DomainName is the name of a domain 
    that the current DC trusts.
    
    If requested, the TrustEntry for the domain will be returned.
    
    Note that the Trusted Domain List lock is required for this. Therefore
    fTDLock is a required parameter when passing in TrustEntryOut.

Arguments:

    Flags -- LSAP_LOOKUP_DOMAIN_TRUST_DIRECT_EXTERNAL
             LSAP_LOOKUP_DOMAIN_TRUST_DIRECT_INTRA   
             LSAP_LOOKUP_DOMAIN_TRUST_FOREST
             
    DomainName -- the name of the target domain
    
    DomainSid -- the sid of the target domain
    
    fTDLLock -- an IN/OUT parameter indicating whether the trusted domain
                lock is held or not.  NULL implies that this routine
                should grab and release the lock

    TrustEntryOut -- out, the TrustEntry of DomainName/DomainSid if found
                     and if trust satisfies above criteria.
                                                         
Return Values:

    STATUS_SUCCESS  -- the domain fits the criteria above
    
    STATUS_NO_SUCH_DOMAIN -- otherwise
           
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN fLock = FALSE;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry = NULL;
    UNICODE_STRING DomainNameFound;
    BOOLEAN fForestTrust = FALSE;
    BOOLEAN fDomainTrust = FALSE;
    BOOLEAN fIntraForestDomainTrust = FALSE;

    //
    // Only and exactly one IN parameter is permitted
    //
    ASSERT( (DomainName != NULL) || (DomainSid != NULL) );
    ASSERT( (DomainName == NULL) || (DomainSid == NULL) );

    //
    // Both or none of the these parameters should be sent in
    //
    ASSERT(  ((fTDLLock == NULL)  && (TrustEntryOut == NULL))
          || ((fTDLLock != NULL)  && (TrustEntryOut != NULL)) );

    //
    // At least one variation must be present currently
    //
    ASSERT( 0 != Flags );

    //
    // Init the out parameter
    //
    if (TrustEntryOut) {
        *TrustEntryOut = NULL;
    }

    RtlInitUnicodeString(&DomainNameFound, NULL);

    //
    // Attempt to find the domain in our trusted domain list
    //
    if ( (fTDLLock && (*fTDLLock == FALSE))
      ||  fTDLLock == NULL ) {

        Status = LsapDbAcquireReadLockTrustedDomainList();
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }
        fLock = TRUE;
    }

    if (DomainName) {

        Status = LsapDbLookupNameTrustedDomainListEx(
                     (PLSAPR_UNICODE_STRING) DomainName,
                     &TrustEntry
                     );
    } else {

        Status = LsapDbLookupSidTrustedDomainListEx(
                     DomainSid,
                     &TrustEntry
                     );

    }

    //
    // Didn't find it?  Bail now
    //
    if (!NT_SUCCESS(Status)) {

        Status = STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    if ( LsapOutboundTrustedForest(TrustEntry) ) {
        fForestTrust = TRUE;
    }

    if ( LsapOutboundTrustedDomain(TrustEntry) ) {
        fDomainTrust = TRUE;
    }
    
    Status = LsapGetDomainNameBySid(TrustEntry->TrustInfoEx.Sid,
                                    &DomainNameFound);
    if (NT_SUCCESS(Status)) {
        fIntraForestDomainTrust = TRUE;
    } else if (Status != STATUS_NO_SUCH_DOMAIN) {
        // Unhandled error
        goto Cleanup;
    }


    //
    // Now for some logic
    //
    if ( 
            //
            // Forest trust
            //
          ( FLAG_ON(Flags, LSAP_LOOKUP_DOMAIN_TRUST_FOREST)
       &&   fForestTrust) 

            //
            // Direct external trust
            //
       || ( FLAG_ON(Flags, LSAP_LOOKUP_DOMAIN_TRUST_DIRECT_EXTERNAL) 
       &&   fDomainTrust 
       &&  !fIntraForestDomainTrust)

            //
            // Direct, internal trust  (intra forest)
            //
       || ( FLAG_ON(Flags, LSAP_LOOKUP_DOMAIN_TRUST_DIRECT_INTRA) 
       &&   fDomainTrust 
       &&   fIntraForestDomainTrust)

        ) {
        //
        // Success!
        //
        Status = STATUS_SUCCESS;
        if (TrustEntryOut) {
            *TrustEntryOut = TrustEntry;
        }

    } else {

        Status = STATUS_NO_SUCH_DOMAIN;
    }

Cleanup:

    if (fLock) {
        if (fTDLLock == NULL) {
            LsapDbReleaseLockTrustedDomainList();
        } else {
            *fTDLLock = TRUE;
        }
    }

    if (DomainNameFound.Buffer) {
        midl_user_free(DomainNameFound.Buffer);
    }

    return Status;
}

NTSTATUS
LsapDomainHasForestTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    IN OUT  BOOLEAN   *fTDLLock,   OPTIONAL
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustEntryOut OPTIONAL
    )
//
// See LsapDomainHasDomainTrust
//
{
    return LsapDomainHasDomainTrust(LSAP_LOOKUP_DOMAIN_TRUST_FOREST,
                                    DomainName,
                                    DomainSid,
                                    fTDLLock,
                                    TrustEntryOut);
}


NTSTATUS
LsapDomainHasDirectTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    IN OUT  BOOLEAN   *fTDLLock,   OPTIONAL
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustEntryOut OPTIONAL
    )
{
    return LsapDomainHasDomainTrust(LSAP_LOOKUP_DOMAIN_TRUST_DIRECT_INTRA|
                                    LSAP_LOOKUP_DOMAIN_TRUST_DIRECT_EXTERNAL,
                                    DomainName,
                                    DomainSid,
                                    fTDLLock,
                                    TrustEntryOut);
}
                                
NTSTATUS
LsapDomainHasDirectExternalTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    IN OUT  BOOLEAN   *fTDLLock,   OPTIONAL
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustEntryOut OPTIONAL
    )
//
// See LsapDomainHasDomainTrust
//
{
    return LsapDomainHasDomainTrust(LSAP_LOOKUP_DOMAIN_TRUST_DIRECT_EXTERNAL,
                                    DomainName,
                                    DomainSid,
                                    fTDLLock,
                                    TrustEntryOut);

}

NTSTATUS
LsapDomainHasTransitiveTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    OUT LSA_TRUST_INFORMATION *TrustInfo OPTIONAL
    )
/*++

Routine Description:

    This routine determines if the domain information (DomainName or
    DomainSid) belongs to a domain in the current forest.

Arguments:

    DomainName -- the name of the target domain
    
    DomainSid -- the sid of the target domain

    TrustInfo -- the domain SID and netbios name of the domain, if found is
                 returned.  The embedded values (the SID and unicode string 
                 must be freed by the caller)    
                                                         
Return Values:

    STATUS_SUCCESS  -- the domain fits the criteria above
    
    STATUS_NO_SUCH_DOMAIN -- otherwise
           
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSID           LocalDomainSid = NULL;
    UNICODE_STRING LocalDomainName;

    // Precisely one is allowed and expected
    ASSERT(!(DomainName && DomainSid));
    ASSERT(!((DomainName == NULL) && (DomainSid == NULL)));

    RtlInitUnicodeString(&LocalDomainName, NULL);
    if (DomainName) {

        //
        // Try to match by name
        //
        LPWSTR   Name;

        //
        // Make a NULL terminated string
        //
        Name = (WCHAR*)midl_user_allocate(DomainName->Length + sizeof(WCHAR));
        if (NULL == Name) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }
        RtlCopyMemory(Name, DomainName->Buffer, DomainName->Length);
        Name[DomainName->Length / sizeof(WCHAR)] = UNICODE_NULL;

        //
        // Try Netbios
        //
        Status =  LsapGetDomainSidByNetbiosName( Name,
                                                 &LocalDomainSid );

        if ( STATUS_NO_SUCH_DOMAIN == Status ) {

            //
            // Try DNS
            //
            Status =  LsapGetDomainSidByDnsName( Name,
                                                &LocalDomainSid );

        }

        //
        // Get the flat name in all cases
        //
        if ( NT_SUCCESS( Status ) ) {

            Status = LsapGetDomainNameBySid( LocalDomainSid,
                                             &LocalDomainName );

        }

        midl_user_free(Name);

    } else {

        //
        // Try to match by SID
        //
        Status = LsapGetDomainNameBySid( DomainSid,
                                         &LocalDomainName );
        if (NT_SUCCESS(Status)) {
            LocalDomainSid = midl_user_allocate(GetLengthSid(DomainSid));
            if (NULL == LocalDomainSid) {
                Status = STATUS_NO_MEMORY;
                goto Exit;
            }
            if (NULL != LocalDomainSid) {
                CopySid(GetLengthSid(DomainSid), LocalDomainSid, DomainSid);
            }
        }

    }

    if (NT_SUCCESS(Status)) {
        ASSERT(NULL != LocalDomainSid);
        ASSERT(NULL != LocalDomainName.Buffer);
        if (TrustInfo) {
            RtlZeroMemory(TrustInfo, sizeof(*TrustInfo));
            TrustInfo->Sid = LocalDomainSid;
            TrustInfo->Name = LocalDomainName;
            LocalDomainSid = NULL;
            RtlInitUnicodeString(&LocalDomainName, NULL);
        }
    }

Exit:

    if (LocalDomainSid) {
        midl_user_free(LocalDomainSid);
    }
    if (LocalDomainName.Buffer) {
        midl_user_free(LocalDomainName.Buffer);

    }

    return Status;
}



//
// The character to search for if the name format is assumed to be
// a UPN
//
#define LSAP_LOOKUP_UPN_DELIMITER           L'@'

//
// The character to search for if the name format is assumed to a
// SamAccountName format name
//
#define LSAP_LOOKUP_SAM_ACCOUNT_DELIMITER   L'\\'

BOOL
LsapLookupNameContainsDelimiter(
    IN PUNICODE_STRING Name,
    IN WCHAR Delimiter,
    OUT ULONG *Position OPTIONAL
    )
/*++

Routine Description:

    This routine finds Delimiter in Name and returns the position of
    the delimiter.  Name must be at least 3 characters long and the delimiter
    cannot be in the first or last position.
    
    N.B. This routines looks for the left-most delimiter
                                   
Arguments:

    Name -- the name to be converted (in place)
    
    Delimiter -- LSAP_LOOKUP_SAM_ACCOUNT_DELIMITER
                 LSAP_LOOKUP_UPN_DELIMITER
    
    Position -- the array index of Delimiter in Name->Buffer                
                
Return Values:

    TRUE if delimiter found; FALSE otherwise
    
--*/
{
    ULONG StringLength = Name->Length / sizeof(WCHAR);
    ULONG DelimiterPosition;
    ULONG i;

    //
    // Find the last Delimiter; return if not found, or in first or last position
    //
    DelimiterPosition = 0;
    for (i = StringLength; i > 0; i--) {
        if (Name->Buffer[i-1] == Delimiter) {
            DelimiterPosition = i-1;
            break;
        }
    }
    if ((DelimiterPosition == 0) || (DelimiterPosition == (StringLength - 1))) {
        return FALSE;
    }
    if (Position) {
        *Position = DelimiterPosition;
    }

    return TRUE;
}    

VOID
LsapLookupConvertNameFormat(
    IN OUT PUNICODE_STRING Name,
    IN WCHAR OldDelimiter,
    IN WCHAR NewDelimiter
    )
/*++

Routine Description:

    This routine takes a Name and converts the name format between
    UPN and SamAccountName style.  For example:
    
    billg@microsoft.com to microsoft.com\billg
    
    and
    
    microsoft.com\billg  to billg@microsoft.com
    
    If the expected delimiter is not found in the name, the string is
    untouched.
                                   
Arguments:

    Name -- the name to be converted (in place)
    
    OldDelimiter -- LSAP_LOOKUP_SAM_ACCOUNT_DELIMITER
                    LSAP_LOOKUP_UPN_DELIMITER
                    
    NewDelimiter -- LSAP_LOOKUP_SAM_ACCOUNT_DELIMITER                    
                    LSAP_LOOKUP_UPN_DELIMITER
                
Return Values:

    None.
    
--*/
{
    ULONG StringLength = Name->Length / sizeof(WCHAR);
    ULONG Delimiter;
    ULONG i;
    ULONG Length1, Length2;
    WCHAR *Buffer = Name->Buffer;
    ULONG RotationFactor;
    ULONG LastStartingPoint, MovedCount, CurrentPosition, NextPosition;
    WCHAR Temp1, Temp2;

    //
    // The function's behavior is not defined in this case.
    //
    ASSERT(OldDelimiter != NewDelimiter);

    //
    // Find the last Delimiter; return if not found, or in first or last position
    //
    if (!LsapLookupNameContainsDelimiter(Name, OldDelimiter, &Delimiter)) {
        return;
    }

    //
    // Make the delimiter part of the first segment
    // Ie.  billg@            microsoft.com
    //      microsoft.com\    billg
    //
    Length1 = Delimiter + 1;
    Length2 = StringLength - Length1;

    //
    // Rotate the string
    //
    RotationFactor = Length2;
    MovedCount = 0;

    CurrentPosition = 0;
    LastStartingPoint = 0;
    Temp1 = Buffer[0];
    while (MovedCount < StringLength) {

        NextPosition = CurrentPosition + RotationFactor;
        NextPosition %= StringLength;

        Temp2 = Buffer[NextPosition];
        Buffer[NextPosition] = Temp1;
        Temp1 = Temp2;
        CurrentPosition = NextPosition;

        if (CurrentPosition == LastStartingPoint) {
            CurrentPosition++;
            LastStartingPoint = CurrentPosition;
            Temp1 = Buffer[CurrentPosition];
        }

        MovedCount++;
    }

    //
    // The string now looks like
    // microsoft.combillg@
    // billgmicrosoft.com\

    //
    // Move down and add new limiter
    //
    Temp1 = Buffer[Length2];
    for (i = Length2+1; i < StringLength; i++) {
        Temp2 = Buffer[i];
        Buffer[i] = Temp1;
        Temp1 = Temp2;
    }
    Buffer[Length2] = NewDelimiter;

    //
    // Final form:
    // microsoft.com\billg
    // billg@microsoft.com
    //

    return;

}

VOID
LsapLookupCrackName(
    IN PUNICODE_STRING Prefix,
    IN PUNICODE_STRING Suffix,
    OUT PUNICODE_STRING SamAccountName,
    OUT PUNICODE_STRING DomainName
    )
/*++

Routine Description:

    This routine takes Prefix and Suffix, which represent a name of the
    form Prefix\Suffix, and determines what the domain and username
    portion are.
    
Arguments:

    Prefix -- the left side of the \ of the originally requested name
    
    Suffix -- the right side of the \ of the originally requested name
    
    SamAccountName -- the sam account name embedded in Prefix\Suffix
    
    DomainName -- the domain name embedded in Prefix\Suffix
                                                         
Return Values:

    None.
    
--*/
{
    ULONG Position;

    if ( (Prefix->Length == 0)
     &&  LsapLookupNameContainsDelimiter(Suffix, 
                                         LSAP_LOOKUP_UPN_DELIMITER,
                                         &Position)) {

        //
        // This is an isolated name (no explicit domain portaion) that contains
        // the UPN delimiter -- crack as UPN.
        //
        ULONG StringLength = Suffix->Length / sizeof(WCHAR);
        
        SamAccountName->Buffer = Suffix->Buffer;
        SamAccountName->Length = (USHORT)Position * sizeof(WCHAR);
        SamAccountName->MaximumLength = SamAccountName->Length;
        
        DomainName->Buffer = Suffix->Buffer + Position + 1;
        DomainName->Length = (USHORT) (StringLength - Position - 1) * sizeof(WCHAR);
        DomainName->MaximumLength = DomainName->Length;

    } else {

        //
        // Simple case, domain is specified as prefix
        //
        *SamAccountName = *Suffix;
        *DomainName = *Prefix;
    }
}

VOID
LsapLookupSamAccountNameToUPN(
    IN OUT PUNICODE_STRING Name
    )
//
// Converts, in place, domainname\username to username@domainname
//
{
    LsapLookupConvertNameFormat(Name, 
                                LSAP_LOOKUP_SAM_ACCOUNT_DELIMITER, 
                                LSAP_LOOKUP_UPN_DELIMITER);
}


VOID
LsapLookupUPNToSamAccountName(
    IN OUT PUNICODE_STRING Name
    )
//
// Converts, in place, username@domainname to domainname\username
//
{
    LsapLookupConvertNameFormat(Name, 
                                LSAP_LOOKUP_UPN_DELIMITER,
                                LSAP_LOOKUP_SAM_ACCOUNT_DELIMITER);
}
                             
BOOL
LsapLookupIsUPN(
    OUT PUNICODE_STRING Name
    )
//
// Returns TRUE if Name is syntactically determined to be a UPN
//
{
    return LsapLookupNameContainsDelimiter(Name, 
                                           LSAP_LOOKUP_UPN_DELIMITER, 
                                           NULL);
}

ULONG
LsapGetDomainLookupScope(
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN ULONG             ClientRevision
    )
/*++

Routine Description:

    This routine returns what scope is appropriate when looking up domain
    names and SID's.
    
Arguments:

    LookupLevel -- the level requested by the caller
    
    fTransitiveTrustSupport -- is the client aware of transitive trust
                               relations.        
                                                         
Return Values:

    A bitmask containing, possibly
    
    LSAP_LOOKUP_TRUSTED_DOMAIN_DIRECT
    LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE
    LSAP_LOOKUP_TRUSTED_FOREST
    LSAP_LOOKUP_TRUSTED_FOREST_ROOT
   
--*/
{
    ULONG Scope = 0;

    if ( 
        //
        // Workstation request
        //
             (LookupLevel == LsapLookupPDC)

        //
        // Local lookup on DC
        //
      ||     ((LookupLevel == LsapLookupWksta)
          && (LsapProductType == NtProductLanManNt))

        ) {

        //
        // Include directly trusted domains
        //
        Scope |= LSAP_LOOKUP_TRUSTED_DOMAIN_DIRECT;

        //
        // Determine if newer features apply
        //
        if ( (ClientRevision > LSA_CLIENT_PRE_NT5)
          || (LsapSamOpened && !SamIMixedDomain( LsapAccountDomainHandle ))
          || LsapAllowExtendedDownlevelLookup  ) {

            //
            // Allow DNS support
            //
            Scope |= LSAP_LOOKUP_DNS_SUPPORT;

            //
            // Include transitivly trusted domains
            //
            Scope |= LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE;

            //
            // Include forest trusts
            //
            Scope |= LSAP_LOOKUP_TRUSTED_FOREST;

            if (LsapDbDcInRootDomain()) {

                //
                // If we are in the root domain, also check for
                // trusts to directly trusted forests for isolated
                // domain names or domain SID's
                //
                Scope |= LSAP_LOOKUP_TRUSTED_FOREST_ROOT;
            }
        }

    } else if ((LookupLevel == LsapLookupXForestResolve)
           ||  (LookupLevel == LsapLookupGC) ) {
        //
        // Only consider transitively trusted domains 
        //
        Scope |= LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE;
    }

    return Scope;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbpob.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbpob.c

Abstract:

    LSA Database Object Manager - Private Routines

    These routines perform low-level functions private to the LSA Database
    Object Manager.

Author:

    Scott Birrell       (ScottBi)       January 8, 1992

Environment:

Revision History:

--*/
#include <lsapch2.h>
#include "dbp.h"


NTSTATUS
LsapDbLogicalToPhysicalSubKey(
    IN LSAPR_HANDLE ObjectHandle,
    OUT PUNICODE_STRING PhysicalSubKeyNameU,
    IN PUNICODE_STRING LogicalSubKeyNameU
    )

/*++

Routine Description:

    This routine converts a Logical Name of a subkey of an open object to
    the corresponding Physical Name.  The Physical Name of a subkey is the
    hierarchic Registry key name relative to the Registry Key corresponding
    to the LSA Database root object.  It is constructed by extracting the
    Physical Name of the object from its handle and appending "\" and the
    given Logical SubKey name.

Arguments:

    ObjectHandle - Handle to open object from an LsapDbOpenObject call.

    PhysicalSubKeyNameU - Pointer to Unicode string that will receive the
        Physical Name of the subkey.

    LogicalSubKeyNameU - Pointer to Unicode string that contains the
        Logical name of the subkey.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INSUFFICIENT_RESOURCES - Not enough system resources to
            allocate intermediate and final string buffers needed.
--*/

{
    NTSTATUS Status;

    LSAP_DB_HANDLE Handle = (LSAP_DB_HANDLE) ObjectHandle;

    Status = LsapDbJoinSubPaths(
                 &Handle->PhysicalNameU,
                 LogicalSubKeyNameU,
                 PhysicalSubKeyNameU
                 );

    return Status;
}


NTSTATUS
LsapDbJoinSubPaths(
    IN PUNICODE_STRING MajorSubPathU,
    IN PUNICODE_STRING MinorSubPathU,
    OUT PUNICODE_STRING JoinedPathU
    )

/*++

Routine Description:

    This function joins together two parts of a Regsitry SubPath, inserting
    a "\" as a separator.  The Minor SubPath must not begin with a "\".
    Either or both sub path components may be NULL.  Except where both
    sub path components are NULL, memory is always allocated for the output
    buffer.  This memory must be freed when no longer required by calling
    RtlFreeUnicodeString() on the output string.

Arguments:

    MajorSubPathU - Pointer to Unicode String containing an absolute or
        relative subpath.

    MinorSubPathU - Pointer to Unicode String containing a relative
        subpath.

    JoinedPathU - Pointer to Unicode String that will receive the joined
        path.  Memory will be allocated for the JoinedPath buffer.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INSUFFICIENT_RESOURCES - Not enough system resources to
            allocate intermediate and final string buffers needed.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT JoinedPathLength;

    //
    // Compute the size needed for the Joined Sub Path string.
    // The Joined Sub Path has the following form:
    //
    // <Major Sub Path> + L"\" + <Minor Sub Path>
    //
    // where the "+" operator denotes concatenation.
    //
    // If both major and minor sub path are null, then result string
    // is empty.
    //
    // If either major or minor sub path is null, then path separator is
    // omitted.
    //

    if (MajorSubPathU == NULL) {

        //
        // If MinorSubPathU is also NULL, just set the output
        // buffer size to 0.
        //

        if (MinorSubPathU == NULL) {

            JoinedPathU->Length = 0;
            JoinedPathU->Buffer = NULL;
            return STATUS_SUCCESS;
        }

        JoinedPathLength = MinorSubPathU->MaximumLength;

    } else if (MinorSubPathU == NULL) {

        JoinedPathLength = MajorSubPathU->MaximumLength;

    } else {

        JoinedPathLength = MajorSubPathU->Length +
                              (USHORT) sizeof( OBJ_NAME_PATH_SEPARATOR ) +
                              MinorSubPathU->Length;

    }

    //
    // Now allocate buffer for the Joined Sub Path string
    //

    JoinedPathU->Length = 0;
    JoinedPathU->MaximumLength = JoinedPathLength;
    JoinedPathU->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, JoinedPathLength );

    if (JoinedPathU->Buffer == NULL) {
        goto JoinSubPathError;
    }

    if (MajorSubPathU != NULL) {

        Status = RtlAppendUnicodeStringToString( JoinedPathU,
                                                 MajorSubPathU
                                               );

        if (!NT_SUCCESS(Status)) {
            goto JoinSubPathError;
        }

    }

    if (MinorSubPathU != NULL) {

        if (MajorSubPathU != NULL) {

            Status = RtlAppendUnicodeToString( JoinedPathU,
                                               L"\\"
                                             );

            if (!NT_SUCCESS(Status)) {
                goto JoinSubPathError;
            }
        }

        Status = RtlAppendUnicodeStringToString( JoinedPathU,
                                                 MinorSubPathU
                                               );
        if (!NT_SUCCESS(Status)) {
            goto JoinSubPathError;
        }

    }

    return Status;

JoinSubPathError:

    //
    // If necessary, free the Joined Sub Path string buffer.
    //

    if (JoinedPathU->Buffer != NULL) {

        RtlFreeHeap( RtlProcessHeap(), 0, JoinedPathU->Buffer );
        JoinedPathU->Buffer = NULL;
    }

    return Status;
}


NTSTATUS
LsapDbCreateSDObject(
    IN LSAPR_HANDLE ContainerHandle,
    IN LSAPR_HANDLE ObjectHandle,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    This function creates the initial Security Descriptor Attribute for an LSA
    Database object.  The DACL in this SD is dependent on the object type.

Arguments:

    ContainerHandle - Handle of the parent object

    ObjectHandle - Handle to open object.

    SecurityDescriptor - Returns a pointer to the security descriptor for the object.
        The Security Descriptor should be freed using
        RtlFreeHeap( RtlProcessHeap(), 0, SecurityDescriptor );

Return Value:

    NTSTATUS - Standard Nt Result Code.

--*/

{
    NTSTATUS Status;
    ULONG DaclLength;
    PACL Dacl = NULL;
    HANDLE LsaProcessHandle = NULL;
    HANDLE LsaProcessTokenHandle = NULL;
    PSECURITY_DESCRIPTOR ContainerDescriptor = NULL;
    ULONG ContainerDescriptorLength;
    OBJECT_ATTRIBUTES LsaProcessObjectAttributes;
    SECURITY_DESCRIPTOR CreatorDescriptor;
    LSAP_DB_HANDLE Handle = (LSAP_DB_HANDLE) ObjectHandle;
    PTEB CurrentTeb;


    //
    // We will be creating a Security Descriptor in Self-Relative format.
    // The information that goes into the SD comes from two sources - the Lsa
    // Process's token and the information we provide, such as DACL.  First,
    // we need to open the Lsa process to access its token.
    //

    *SecurityDescriptor = NULL;

    InitializeObjectAttributes(
        &LsaProcessObjectAttributes,
        NULL,
        0,
        NULL,
        NULL
        );

    CurrentTeb = NtCurrentTeb();

    Status = NtOpenProcess(
                 &LsaProcessHandle,
                 PROCESS_QUERY_INFORMATION,
                 &LsaProcessObjectAttributes,
                 &CurrentTeb->ClientId
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateSDError;
    }

    //
    // Now open the Lsa process's token with appropriate access
    //

    Status = NtOpenProcessToken(
                 LsaProcessHandle,
                 TOKEN_QUERY,
                 &LsaProcessTokenHandle
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateSDError;
    }

    //
    // Next, we want to specify a DACL to define the access for the
    // object whose SD is being created.
    //
    // Give GENERIC_ALL and, if the object is deletable, DELETE access to
    // the group DOMAIN_ALIAS_ADMINS.
    // Give GENERIC_EXECUTE access to WORLD.
    //
    // Note that the group ALIAS_ADMINS does NOT require access.  This access is not
    // required because a logon to a member of DOMAIN_ADMIN results in a token
    // being constructed that has ALIAS_ADMINS added (by an Lsa authentication
    // filter routine).
    //
    // Construct a Security Descriptor that will contain only the DACL
    // we want and all other fields set to NULL.
    //

    Status = RtlCreateSecurityDescriptor(
                 &CreatorDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateSDError;
    }

    //
    // Calculate length of DACL required.  It will hold two Access Allowed
    // ACE's, one for DOMAIN_ALIAS_ADMINS and one for WORLD.  The size of the DACL is
    // the size of the ACL header plus the sizes of the ACE's minus a
    // redundant ULONG built into the header.
    //

    DaclLength = sizeof (ACL) - sizeof (ULONG) +
                      sizeof (ACCESS_ALLOWED_ACE ) +
                      RtlLengthSid( LsapAliasAdminsSid ) +
                      sizeof (ACCESS_ALLOWED_ACE ) +
                      RtlLengthSid( LsapWorldSid ) +
                      (LsapDbState.DbObjectTypes[Handle->ObjectTypeId].AnonymousLogonAccess == 0 ?
                            0 :
                            (sizeof (ACCESS_ALLOWED_ACE ) +
                            RtlLengthSid( LsapAnonymousSid ) ) ) +
                      (LsapDbState.DbObjectTypes[Handle->ObjectTypeId].LocalServiceAccess == 0 ?
                            0 :
                            (sizeof (ACCESS_ALLOWED_ACE ) +
                            RtlLengthSid( LsapLocalServiceSid ) ) ) +
                      (LsapDbState.DbObjectTypes[Handle->ObjectTypeId].NetworkServiceAccess == 0 ?
                            0 :
                            (sizeof (ACCESS_ALLOWED_ACE ) +
                            RtlLengthSid( LsapNetworkServiceSid ) ) );

    Status = STATUS_INSUFFICIENT_RESOURCES;

    Dacl = LsapAllocateLsaHeap(DaclLength);

    if (Dacl == NULL) {

        goto CreateSDError;
    }

    Status = RtlCreateAcl(
                 Dacl,
                 DaclLength,
                 ACL_REVISION
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateSDError;
    }

    //
    // Now add the Access Allowed ACE for the group DOMAIN_ALIAS_ADMINS to the
    // object's DACL.
    //

    Status = RtlAddAccessAllowedAce(
                 Dacl,
                 ACL_REVISION,
                 LsapDbState.DbObjectTypes[Handle->ObjectTypeId].AliasAdminsAccess,
                 LsapAliasAdminsSid
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateSDError;
    }

    //
    // Now add the Access Allowed ACE for the group WORLD to the
    // object's DACL.
    //

    Status = RtlAddAccessAllowedAce(
                 Dacl,
                 ACL_REVISION,
                 LsapDbState.DbObjectTypes[Handle->ObjectTypeId].WorldAccess,
                 LsapWorldSid
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateSDError;
    }

    //
    // Now add the Access Allowed ACE for the group AnoymousLogon to the
    // object's DACL.
    //

    if ( LsapDbState.DbObjectTypes[Handle->ObjectTypeId].AnonymousLogonAccess != 0 ) {
        Status = RtlAddAccessAllowedAce(
                     Dacl,
                     ACL_REVISION,
                     LsapDbState.DbObjectTypes[Handle->ObjectTypeId].AnonymousLogonAccess,
                     LsapAnonymousSid
                     );

        if (!NT_SUCCESS(Status)) {

            goto CreateSDError;
        }
    }

    //
    // Now add the Access Allowed ACE for LocalService to the object's DACL.
    //

    if ( LsapDbState.DbObjectTypes[Handle->ObjectTypeId].LocalServiceAccess != 0 ) {
        Status = RtlAddAccessAllowedAce(
                     Dacl,
                     ACL_REVISION,
                     LsapDbState.DbObjectTypes[Handle->ObjectTypeId].LocalServiceAccess,
                     LsapLocalServiceSid
                     );

        if (!NT_SUCCESS(Status)) {

            goto CreateSDError;
        }
    }

    //
    // Now add the Access Allowed ACE for NetworkService to the object's DACL.
    //

    if ( LsapDbState.DbObjectTypes[Handle->ObjectTypeId].NetworkServiceAccess != 0 ) {
        Status = RtlAddAccessAllowedAce(
                     Dacl,
                     ACL_REVISION,
                     LsapDbState.DbObjectTypes[Handle->ObjectTypeId].NetworkServiceAccess,
                     LsapNetworkServiceSid
                     );

        if (!NT_SUCCESS(Status)) {

            goto CreateSDError;
        }
    }


    //
    // Set the initial owner of the object
    //

    Status = RtlSetOwnerSecurityDescriptor(
                 &CreatorDescriptor,
                 LsapDbState.DbObjectTypes[Handle->ObjectTypeId].InitialOwnerSid,
                 FALSE
                 );

    if (!NT_SUCCESS(Status)) {

         goto CreateSDError;
    }

    //
    // Hook the newly constructed DACL for the LsaDb object into the
    // Modification Descriptor.
    //

    Status = RtlSetDaclSecurityDescriptor(
                 &CreatorDescriptor,
                 TRUE,
                 Dacl,
                 FALSE
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateSDError;
    }

    //
    // If there is a container object, obtain its Security Descriptor so that
    // we can use it as the basis for our new descriptor.  The new
    // descriptor will be equal to the container descriptor with DACL replaced
    // by the Modification Descriptor just constructed.
    //
    // Reading the container SD takes several steps:
    //
    // o Get the length of the Container SD
    // o Allocate a buffer for the SD
    // o Read the SD
    //
    // Obtain the length of the container object's SD by issuing a read for
    // the SecDesc subkey of the container object's Registry key, with a
    // dummy buffer whose size is too small.
    //

    if (ContainerHandle != NULL) {

        //
        // Obtain the length of the container object's SD by issuing a read for
        // the SecDesc subkey of the container object's Registry key, with a
        // dummy buffer whose size is too small.
        //

        ContainerDescriptorLength = 0;

        Status = LsapDbReadAttributeObject(
                     ContainerHandle,
                     &LsapDbNames[SecDesc],
                     NULL,
                     &ContainerDescriptorLength
                     );

        if (!NT_SUCCESS(Status)) {

            goto CreateSDError;
        }

        //
        // Allocate a buffer from the Lsa Heap for the container object's SD.
        //

        Status = STATUS_INSUFFICIENT_RESOURCES;

        ContainerDescriptor = LsapAllocateLsaHeap( ContainerDescriptorLength );

        if (ContainerDescriptor == NULL) {

            goto CreateSDError;
        }

        //
        // Read the container object's SD.  It is the value of the SecDesc
        // subkey.
        //

        Status = LsapDbReadAttributeObject(
                     ContainerHandle,
                     &LsapDbNames[SecDesc],
                     ContainerDescriptor,
                     &ContainerDescriptorLength
                     );

        if (!NT_SUCCESS(Status)) {

            goto CreateSDError;
        }
    }

    //
    // Now we are ready to construct the Self-Relative Security Descriptor.
    // Information in the SD will be based on that in the LSA Process
    // Token, except for the DACL we provide in a Security Descriptor.
    // Note that we pass in the LSA Process Token explicitly because we
    // are not impersonating a client.
    //

    Status = RtlNewSecurityObject(
                 ContainerDescriptor,
                 &CreatorDescriptor,
                 SecurityDescriptor,
                 FALSE,
                 LsaProcessTokenHandle,
                 &(LsapDbState.
                     DbObjectTypes[Handle->ObjectTypeId].GenericMapping)
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateSDError;
    }


CreateSDFinish:

    //
    // If necessary, free the memory allocated for the Container Descriptor
    //

    if (ContainerDescriptor != NULL) {

        LsapFreeLsaHeap( ContainerDescriptor );
        ContainerDescriptor = NULL;
    }

    //
    // If necessary, free the memory allocated for the DACL
    //

    if (Dacl != NULL) {

        LsapFreeLsaHeap(Dacl);
        Dacl = NULL;
    }

    //
    // Close the Handles to our process and token.
    //

    if ( LsaProcessHandle != NULL ) {
        (VOID) NtClose( LsaProcessHandle );
    }

    if ( LsaProcessTokenHandle != NULL ) {
        (VOID) NtClose( LsaProcessTokenHandle );
    }

    return(Status);

CreateSDError:

    //
    // If necessary, free the memory allocated for SecurityDescriptor.
    //

    if (*SecurityDescriptor != NULL) {

        RtlFreeHeap( RtlProcessHeap(), 0, *SecurityDescriptor );
        *SecurityDescriptor = NULL;
    }

    goto CreateSDFinish;
}


NTSTATUS
LsapDbCreateSDAttributeObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN OUT PLSAP_DB_OBJECT_INFORMATION ObjectInformation
    )

/*++

Routine Description:

    This function creates the initial Security Descriptor Attribute for an LSA
    Database object.  The DACL in this SD is dependent on the object type.

Arguments:

    ObjectHandle - Handle to open object.

    ObjectInformation - Pointer to Object Information structure containing
        the object's Sid and type.  A pointer to the created SD is filled in.

Return Value:

    NTSTATUS - Standard Nt Result Code.

--*/

{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG SecurityDescriptorLength;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LSAP_DB_HANDLE Handle = (LSAP_DB_HANDLE) ObjectHandle;


    //
    // If these references a ds object, lease.  We won't set the security on a ds object
    //
    if ( LsapDsIsHandleDsHandle( ObjectHandle ) ) {

        return( STATUS_SUCCESS );
    }

    //
    // Create the Security Descriptor
    //

    Status = LsapDbCreateSDObject(
                    (LSAP_DB_HANDLE) ObjectInformation->ObjectAttributes.RootDirectory,
                    ObjectHandle,
                    &SecurityDescriptor );

    if (!NT_SUCCESS(Status)) {
        goto CreateSDError;
    }

    //
    // Set up the Security Quality Of Service
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Store the Security Descriptor
    //

    ObjectInformation->ObjectAttributes.SecurityDescriptor = SecurityDescriptor;

    //
    // The InitializeObjectAttributes macro stores NULL for the
    // SecurityQualityOfService field, so we must manually copy that
    // structure.
    //

    ObjectInformation->ObjectAttributes.SecurityQualityOfService =
        &SecurityQualityOfService;

    //
    // Obtain the length of the newly created SD.
    //

    SecurityDescriptorLength = RtlLengthSecurityDescriptor(
                                   SecurityDescriptor
                                   );

    //
    // Add a Registry transaction to write the Security Descriptor as the
    // value of the new object's SecDesc subkey.
    //

    Status = LsapDbWriteAttributeObject(
                 Handle,
                 &LsapDbNames[SecDesc],
                 SecurityDescriptor,
                 SecurityDescriptorLength
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateSDError;
    }

CreateSDFinish:

    return(Status);

CreateSDError:

    //
    // If necessary, free the memory allocated for SecurityDescriptor.
    //

    if (SecurityDescriptor != NULL) {

        RtlFreeHeap( RtlProcessHeap(), 0, SecurityDescriptor );
        SecurityDescriptor = NULL;
        ObjectInformation->ObjectAttributes.SecurityDescriptor = NULL;
    }

    goto CreateSDFinish;
}


NTSTATUS
LsapDbCheckCountObject(
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId
    )

/*++

Routine Description:

    This function checks if the number of objects of a given type has
    reached the type-dependent maximum limit (if any).  If the limit
    is reached, a type-dependent error status is returned.  Currently,
    only Secret objects have a limit imposed.

Arguments:

    Handle - Handle to open object.

    ObjectTypeId - Specifies the type of the object.

Return Value:

    NTSTATUS - Standard Nt Result Code.

        STATUS_TOO_MANY_SECRETS - Too many Secrets

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_OBJECT_TYPE ObjectType;

    ObjectType = &(LsapDbState.DbObjectTypes[ObjectTypeId]);

    //
    // If there is an Object Count Limit, check that it has not been
    // reached.
    //

    if ((ObjectType->ObjectCountLimited) &&
        (ObjectType->ObjectCount == ObjectType->MaximumObjectCount)) {

        Status = ObjectType->ObjectCountError;
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbmisc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbmisc.c

Abstract:

    Local Security Authority - Miscellaneous API

    This file contains worker routines for miscellaneous API that are
    not specific to objects of a given type.

Author:

    Scott Birrell       (ScottBi)       January 15, 1992

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"
#include "lsawmi.h"
#include <names.h>
#include <windns.h>
#include <alloca.h>

NTSTATUS
LsarClose(
    IN OUT LSAPR_HANDLE *ObjectHandle
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the LsaClose
    API.

Arguments:

    ObjectHandle - Handle returned from an LsaOpen<object type> or
        LsaCreate<object type> call.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{

    return LsapCloseHandle(
               ObjectHandle,
               STATUS_SUCCESS
               );
}

NTSTATUS
LsapCloseHandle(
    IN OUT LSAPR_HANDLE *ObjectHandle,
    IN NTSTATUS PreliminaryStatus
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the LsaClose
    API.

    The LsaClose API closes a handle to an open object within the database.
    If closing a handle to the Policy object and there are no objects still
    open within the current connection to the LSA, the connection is closed.
    If a handle to an object within the database is closed and the object is
    marked for DELETE access, the object will be deleted when the last handle
    to that object is closed.

Arguments:

    ObjectHandle - Handle returned from an LsaOpen<object type> or
        LsaCreate<object type> call.

    PreliminaryStatus - Status of the operation.  Used to decide whether
        to abort or commit a transaction.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status;
    LSAP_DB_HANDLE InternalHandle = *ObjectHandle;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId;

    LsapDsDebugOut(( DEB_FTRACE, "LsapCloseHandle\n" ));

    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_Close);

    if ( *ObjectHandle == NULL ) {

        Status = STATUS_INVALID_HANDLE;
        goto Cleanup;
    }

    ObjectTypeId = InternalHandle->ObjectTypeId;

    if ( *ObjectHandle == LsapPolicyHandle ) {

#if DBG
        DbgPrint("Closing global policy handle!!!\n");
#endif

        DbgBreakPoint();
        Status = STATUS_INVALID_HANDLE;
        goto Cleanup;
    }

    //
    // Acquire the Lsa Database Lock
    //
    LsapDbAcquireLockEx( ObjectTypeId,
                         LSAP_DB_READ_ONLY_TRANSACTION );

    //
    // Validate and close the object handle, dereference its container (if any).
    //

    Status = LsapDbCloseObject(
                 ObjectHandle,
                 LSAP_DB_VALIDATE_HANDLE |
                     LSAP_DB_DEREFERENCE_CONTR |
                     LSAP_DB_ADMIT_DELETED_OBJECT_HANDLES |
                     LSAP_DB_READ_ONLY_TRANSACTION |
                     LSAP_DB_DS_OP_TRANSACTION,
                 PreliminaryStatus
                 );

    LsapDbReleaseLockEx( ObjectTypeId,
                         LSAP_DB_READ_ONLY_TRANSACTION );

Cleanup:

    *ObjectHandle = NULL;

    LsapDsDebugOut(( DEB_FTRACE, "LsapCloseHandle: 0x%lx\n", Status ));

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_Close);

    return Status;
}


NTSTATUS
LsarDeleteObject(
    IN OUT LSAPR_HANDLE *ObjectHandle
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the LsaDelete
    API.

    The LsaDelete API deletes an object from the LSA Database.  The object must be
    open for DELETE access.

Arguments:

    ObjectHandle - Pointer to Handle from an LsaOpen<object type> or
        LsaCreate<object type> call.  On return, this location will contain
        NULL if the call is successful.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_NOT_FOUND - There is no object in the
            target system's LSA Database having the name and type specified
            by the handle.
--*/

{
    return LsapDeleteObject( ObjectHandle , TRUE );
}



NTSTATUS
LsapDeleteObject(
    IN OUT LSAPR_HANDLE *ObjectHandle,
    IN BOOL LockSce
    )
/*++

Routine Description:

    This is the worker routine for LsarDeleteObject, with an added
    semantics of not locking the SCE policy.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;
    LSAP_DB_HANDLE InternalHandle = *ObjectHandle;
    BOOLEAN ObjectReferenced = FALSE;
    ULONG ReferenceOptions = LSAP_DB_START_TRANSACTION |
                                LSAP_DB_LOCK ;
    ULONG DereferenceOptions = LSAP_DB_FINISH_TRANSACTION |
                                LSAP_DB_LOCK      |
                                LSAP_DB_DEREFERENCE_CONTR;

    PLSAPR_TRUST_INFORMATION TrustInformation = NULL;
    LSAPR_TRUST_INFORMATION OutputTrustInformation;
    BOOLEAN TrustInformationPresent = FALSE;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId;
    PTRUSTED_DOMAIN_INFORMATION_EX CurrentTrustedDomainInfoEx = NULL;
    BOOLEAN ScePolicyLocked = FALSE;
    BOOLEAN NotifySce = FALSE;
    SECURITY_DB_OBJECT_TYPE ObjectType = SecurityDbObjectLsaPolicy;
    PSID ObjectSid = NULL;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarDeleteObject\n" ));

    ObjectTypeId = InternalHandle->ObjectTypeId;

    //
    // The LSA will only call SceNotify if the policy change was made via a handle
    // not marked 'SCE handle'.  This prevents SCE from being notified of its own
    // changes.  This is required to ensure that policy read from the LSA matches
    // that written by a non-SCE application.
    //

    if ( !InternalHandle->SceHandle &&
         !InternalHandle->SceHandleChild ) {

        switch ( ObjectTypeId ) {

        case AccountObject: {

            ULONG SidLength;
            ASSERT( InternalHandle->Sid );

            SidLength = RtlLengthSid( InternalHandle->Sid );
            ObjectSid = ( PSID )LsapAllocateLsaHeap( SidLength );
            if ( ObjectSid ) {

                RtlCopyMemory( ObjectSid, InternalHandle->Sid, SidLength );

            } else {

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto DeleteObjectError;
            }

            ObjectType = SecurityDbObjectLsaAccount;

            // FALLTHRU
        }

        case PolicyObject:

            if ( LockSce ) {

                RtlEnterCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );
                if ( LsapDbState.ScePolicyLock.NumberOfWaitingShared > MAX_SCE_WAITING_SHARED ) {

                    Status = STATUS_TOO_MANY_THREADS;
                }
                RtlLeaveCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );

                if ( !NT_SUCCESS( Status )) {

                    goto DeleteObjectError;
                }

                WaitForSingleObject( LsapDbState.SceSyncEvent, INFINITE );
                RtlAcquireResourceShared( &LsapDbState.ScePolicyLock, TRUE );
                ASSERT( !g_ScePolicyLocked );
                ScePolicyLocked = TRUE;
            }

            NotifySce = TRUE;
            break;

        default:
            break;
        }
    }

    //
    // Verify that the Object handle is valid, is of the expected type and
    // has all of the desired accesses granted.  Reference the handle and
    // open a database transaction.
    //

    Status = LsapDbReferenceObject(
                 *ObjectHandle,
                 DELETE,
                 ObjectTypeId,
                 ObjectTypeId,
                 ReferenceOptions
                 );

    if (!NT_SUCCESS(Status)) {

        goto DeleteObjectError;
    }

    ObjectReferenced = TRUE;

    //
    // Perform object type specific pre-processing.  Note that some
    // pre-processing is also done within LsapDbReferenceObject(), for
    // example, for local secrets.
    //

    switch (ObjectTypeId) {

    case PolicyObject:

            Status = STATUS_INVALID_PARAMETER;
            break;

    case TrustedDomainObject:

        if ( LsapDsWriteDs && InternalHandle->Sid == NULL ) {

            BOOLEAN  TrustedStatus = InternalHandle->Trusted;

            //
            // Toggle trusted bit so that access cks do not prevent following
            // query from succeeding
            //

            InternalHandle->Trusted = TRUE;

            Status = LsarQueryInfoTrustedDomain( *ObjectHandle,
                                                 TrustedDomainInformationEx,
                                                 (PLSAPR_TRUSTED_DOMAIN_INFO *)
                                                                     &CurrentTrustedDomainInfoEx );

            InternalHandle->Trusted = TrustedStatus;

            if ( NT_SUCCESS( Status ) ) {

                InternalHandle->Sid = CurrentTrustedDomainInfoEx->Sid;
                CurrentTrustedDomainInfoEx->Sid = NULL;

            } else {

                LsapDsDebugOut(( DEB_ERROR,
                            "Query for TD Sid failed with 0x%lx\n", Status ));
            }
        }

        if (LsapAdtAuditingPolicyChanges()) {

            //
            // If we're auditing deletions of TrustedDomain objects, we need
            // to retrieve the TrustedDomain name and keep it for later when
            // we generate the audit.
            //

            Status = LsapDbAcquireReadLockTrustedDomainList();

            if (NT_SUCCESS(Status))
            {

                Status = LsapDbLookupSidTrustedDomainList(
                             InternalHandle->Sid,
                             &TrustInformation
                             );

                if (STATUS_NO_SUCH_DOMAIN==Status)
                {
                    //
                    // If we could not find by the SID, then lookup by the logical name
                    // field.
                    //

                    Status = LsapDbLookupNameTrustedDomainList(
                                (PLSAPR_UNICODE_STRING) &InternalHandle->LogicalNameU,
                                &TrustInformation
                                );
                }


                if ( NT_SUCCESS( Status )) {

                    Status = LsapRpcCopyTrustInformation(
                                 NULL,
                                 &OutputTrustInformation,
                                 TrustInformation
                                 );

                    TrustInformationPresent = NT_SUCCESS( Status );
                }

                LsapDbReleaseLockTrustedDomainList();
            }



            //
            // Reset the status to SUCCESS. Failure to get the information for
            // auditing should not be a failure to delete
            //

            Status = STATUS_SUCCESS;
        }



        if ( NT_SUCCESS( Status )) {

            //
            // Notify netlogon.  Potentially ignore any failures
            //
            Status = LsapNotifyNetlogonOfTrustChange( InternalHandle->Sid,
                                                      SecurityDbDelete );
#if DBG
            if ( !NT_SUCCESS( Status ) ) {

                LsapDsDebugOut(( DEB_ERROR,
                             "LsapNotifyNetlogonOfTrustChange failed with an unexpected 0x%lx\n",
                                 Status ));
                ASSERT( NT_SUCCESS(Status) );
            }
#endif
            Status = STATUS_SUCCESS;


        }

        break;

    case AccountObject:

        {
            PLSAPR_PRIVILEGE_SET Privileges;
            LSAPR_HANDLE AccountHandle;
            PLSAPR_SID AccountSid = NULL;
            ULONG AuditEventId;

            AccountHandle = *ObjectHandle;

            AccountSid = LsapDbSidFromHandle( AccountHandle );

            if (LsapAdtAuditingPolicyChanges()) {

                Status = LsarEnumeratePrivilegesAccount(
                             AccountHandle,
                             &Privileges
                             );

                if (!NT_SUCCESS( Status )) {

                    LsapDsDebugOut(( DEB_ERROR,
                                     "LsarEnumeratePrivilegesAccount ret'd %x\n", Status ));
                    break;
                }


                AuditEventId = SE_AUDITID_USER_RIGHT_REMOVED;

                //
                // Audit the privilege set change.  Ignore failures from Auditing.
                //

                IgnoreStatus = LsapAdtGenerateLsaAuditEvent(
                                   AccountHandle,
                                   SE_CATEGID_POLICY_CHANGE,
                                   AuditEventId,
                                   (PPRIVILEGE_SET)Privileges,
                                   1,
                                   (PSID *) &AccountSid,
                                   0,
                                   NULL,
                                   NULL
                                   );

                MIDL_user_free( Privileges );
            }
        }

        break;

    case SecretObject:

        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto DeleteObjectError;
    }

    Status = LsapDbDeleteObject( *ObjectHandle );

    if (!NT_SUCCESS(Status)) {

        goto DeleteObjectError;
    }

    //
    // Decrement the Reference Count so that the object's handle will be
    // freed upon dereference.
    //

    LsapDbDereferenceHandle( *ObjectHandle );

    //
    // Perform object post-processing.  The only post-processing is
    // the auditing of TrustedDomain object deletion.
    //

    if (LsapAdtAuditingPolicyChanges() && TrustInformationPresent) {

        if (ObjectTypeId == TrustedDomainObject) {

            (void)  LsapAdtTrustedDomainRem(
                         EVENTLOG_AUDIT_SUCCESS,
                         (PUNICODE_STRING) &OutputTrustInformation.Name,
                         InternalHandle->Sid,
                         NULL, // UserSid
                         NULL  // UserAuthenticationId
                         );
            
            //
            // Call fgs routine because we want to free the graph of the
            // structure, but not the top level of the structure.
            //

            _fgs__LSAPR_TRUST_INFORMATION ( &OutputTrustInformation );
            TrustInformation = NULL;
        }
    }

    //
    // Delete new object from the in-memory cache (if any)
    //

    if ( ObjectTypeId == AccountObject &&
         LsapDbIsCacheSupported( AccountObject ) &&
         LsapDbIsCacheValid( AccountObject )) {

        IgnoreStatus = LsapDbDeleteAccount( InternalHandle->Sid );
    }

    //
    // Audit the deletion
    //

    IgnoreStatus = NtDeleteObjectAuditAlarm( &LsapState.SubsystemName,
                                             *ObjectHandle,
                                             InternalHandle->GenerateOnClose);

DeleteObjectFinish:

    //
    // If we referenced the object, dereference it, close the database
    // transaction, notify the replicator of the delete, release the LSA
    // Database lock and return.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     ObjectHandle,
                     ObjectTypeId,
                     ObjectTypeId,
                     DereferenceOptions,
                     SecurityDbDelete,
                     Status
                     );

        ObjectReferenced = FALSE;

        if (!NT_SUCCESS(Status)) {

            goto DeleteObjectError;
        }
    }

    if ( CurrentTrustedDomainInfoEx ) {
        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO(
            TrustedDomainInformationEx,
            (PLSAPR_TRUSTED_DOMAIN_INFO) CurrentTrustedDomainInfoEx );
    }

    //
    // Notify SCE of the change.  Only notify for callers
    // that did not open their policy handles with LsaOpenPolicySce.
    //

    if ( NotifySce && NT_SUCCESS( Status )) {

        LsapSceNotify(
            SecurityDbDelete,
            ObjectType,
            ObjectSid
            );
    }

    if ( ScePolicyLocked ) {

        RtlReleaseResource( &LsapDbState.ScePolicyLock );
    }

    if ( ObjectSid ) {

        LsapFreeLsaHeap( ObjectSid );
    }

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarDeleteObject: 0x%lx\n", Status ));

    //
    // Under all circumstances tell RPC we're done with this handle
    //
    *ObjectHandle = NULL;
    return(Status);

DeleteObjectError:

    goto DeleteObjectFinish;
}


NTSTATUS
LsarDelete(
    IN LSAPR_HANDLE ObjectHandle
    )

/*++

Routine Description:

    This function is the former LSA server RPC worker routine for the
    LsaDelete API.  It has been termorarily retained for compatibility
    with pre Beta 2 versions 1.369 and earlier of the system.  It has been
    necessary to replace this routine with a new one, LsarDeleteObject(),
    on the RPC interface.  This is because, like LsarClose(), a pointer to a
    handle is required rather than a handle so that LsarDeleteObject() can
    inform the RPC server calling stub that the handle has been deleted by
    returning NULL.   The client wrapper for LsaDelete() will try to call
    LsarDeleteObject().  If the server code does not contain this interface,
    the client will call LsarDelete().  In this event, the server's
    LSAPR_HANDLE_rundown() routine may attempt to rundown the handle after it
    has been deleted (versions 1.363 - 369 only).

    The LsaDelete API deletes an object from the LSA Database.  The object must be
    open for DELETE access.

Arguments:

    ObjectHandle - Handle from an LsaOpen<object type> or LsaCreate<object type>
    call.

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_NOT_FOUND - There is no object in the
            target system's LSA Database having the name and type specified
            by the handle.
--*/

{
    //
    // Call the replacement routine LsarDeleteObject()
    //

    return( LsarDeleteObject((LSAPR_HANDLE *) &ObjectHandle));
}


NTSTATUS
LsarChangePassword(
    IN PLSAPR_UNICODE_STRING ServerName,
    IN PLSAPR_UNICODE_STRING DomainName,
    IN PLSAPR_UNICODE_STRING AccountName,
    IN PLSAPR_UNICODE_STRING OldPassword,
    IN PLSAPR_UNICODE_STRING NewPassword
    )

/*++

Routine Description:

    The LsaChangePassword API is used to change a user account's password.
    The user must have appropriate access to the user account and must
    know the current password value.


Arguments:

    ServerName - The name of the Domain Controller at which the password
        can be changed.

    DomainName - The name of the domain in which the account exists.

    AccountName - The name of the account whose password is to be changed.

    NewPassword - The new password value.

    OldPassword - The old (current) password value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed, e.g.
            contains characters that can't be entered from the keyboard.

        STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
            from being changed.  This may be for an number of reasons,
            including time restrictions on how often a password may be changed
            or length restrictions on the provided (new) password.

            This error might also be returned if the new password matched
            a password in the recent history log for the account.  Security
            administrators indicate how many of the most recently used
            passwords may not be re-used.

        STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
            current password.

        STATUS_NO_SUCH_USER - The SID provided does not lead to a user
            account.

        STATUS_CANT_UPDATE_MASTER - An attempt to update the master copy
            of the password was unsuccessful.  Please try again later.

--*/

{
    NTSTATUS Status;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarChangePassword\n" ));


    DBG_UNREFERENCED_PARAMETER( ServerName );
    DBG_UNREFERENCED_PARAMETER( DomainName );
    DBG_UNREFERENCED_PARAMETER( AccountName );
    DBG_UNREFERENCED_PARAMETER( OldPassword );
    DBG_UNREFERENCED_PARAMETER( NewPassword );

    Status = STATUS_NOT_IMPLEMENTED;

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarChangePassword: 0x%lx\n", Status ));

    return(Status);
}


NTSTATUS
LsapDbIsImpersonatedClientNetworkClient(
    IN OUT PBOOLEAN IsNetworkClient
    )
/*++

Routine Description:

    This call is used to determine if the currently impersonated user
    is a network client (came in via the network as opposed to locally)
    or not.

Arguments:

    IsNetworkClient - Pointer to a BOOLEAN that gets set to the results
                      of whether this is a network client or not

Return Values:

    STATUS_SUCCESS - Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SID_IDENTIFIER_AUTHORITY UaspNtAuthority = SECURITY_NT_AUTHORITY;
    DWORD BuiltSid[sizeof( SID ) / sizeof( DWORD ) + 2 ];
    PSID NetworkSid = ( PSID )BuiltSid;
    BOOL AccessResults = FALSE;

    *IsNetworkClient = FALSE;

    //
    // Build the network sid
    //
    RtlInitializeSid( NetworkSid, &UaspNtAuthority, 1 );
    *( RtlSubAuthoritySid( NetworkSid, 0 ) ) = SECURITY_NETWORK_RID;

    //
    // Check membership
    //
    if ( CheckTokenMembership( NULL,
                               NetworkSid,
                               &AccessResults ) == FALSE ) {

        Status = STATUS_UNSUCCESSFUL;

    } else {

        *IsNetworkClient = ( BOOLEAN )AccessResults;
    }

    return( Status );
}

NTSTATUS
LsapValidateNetbiosName(
    IN const UNICODE_STRING * Name,
    OUT BOOLEAN * Valid
    )
/*++

Routine Description:

    Validates that a NetBIOS name conforms to certain minimum standards.
    For more details, see the description of NetpIsDomainNameValid.

Arguments:

    Name        name to validate

    Valid       will be set to TRUE if validation checks out, FALSE otherwise

Returns:

    STATUS_SUCCESS

    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    WCHAR * Buffer;
    BOOLEAN BufferAllocated = FALSE;

    ASSERT( Name );
    ASSERT( Valid );
    ASSERT( LsapValidateLsaUnicodeString( Name ));

    //
    // Empty names and names that are too long are not allowed
    //

    if ( Name->Length == 0 ||
         Name->Length > DNLEN * sizeof( WCHAR )) {

        *Valid = FALSE;
        return STATUS_SUCCESS;
    }

    if ( Name->MaximumLength > Name->Length ) {

        Buffer = Name->Buffer;

    } else {

        SafeAllocaAllocate( Buffer, Name->Length + sizeof( WCHAR )); 

        if ( Buffer == NULL ) {

            *Valid = FALSE;
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        BufferAllocated = TRUE;

        RtlCopyMemory( Buffer, Name->Buffer, Name->Length );
    }

    Buffer[Name->Length / sizeof( WCHAR )] = L'\0';

    *Valid = ( TRUE == NetpIsDomainNameValid( Buffer ));

    if ( BufferAllocated ) {

        SafeAllocaFree( Buffer );
    }

    return STATUS_SUCCESS;
}



NTSTATUS
LsapValidateDnsName(
    IN const UNICODE_STRING * Name,
    OUT BOOLEAN * Valid
    )
/*++

Routine Description:

    Validates that a DNS name conforms to certain minimum standards.

Arguments:

    Name        name to validate

    Valid       will be set to TRUE if validation checks out, FALSE otherwise

Returns:

    STATUS_SUCCESS

    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    DNS_STATUS DnsStatus;
    WCHAR * Buffer;
    BOOLEAN BufferAllocated = FALSE;

    ASSERT( Name );
    ASSERT( Valid );
    ASSERT( LsapValidateLsaUnicodeString( Name ));

    //
    // Empty names and names that are too long are not allowed
    //

    if ( Name->Length == 0 ||
         Name->Length > DNS_MAX_NAME_LENGTH * sizeof( WCHAR )) {

        *Valid = FALSE;
        return STATUS_SUCCESS;
    }

    if ( Name->MaximumLength > Name->Length ) {

        Buffer = Name->Buffer;

    } else {

        SafeAllocaAllocate( Buffer, Name->Length + sizeof( WCHAR )); 

        if ( Buffer == NULL ) {

            *Valid = FALSE;
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        BufferAllocated = TRUE;

        RtlCopyMemory( Buffer, Name->Buffer, Name->Length );
    }

    Buffer[Name->Length / sizeof( WCHAR )] = L'\0';

    DnsStatus = DnsValidateName_W( Buffer, DnsNameDomain );

    //
    // Bug 350434: Must allow non-standard characters in DNS names
    //             (which cause DNS_ERROR_NON_RFC_NAME)
    //

    *Valid = ( DnsStatus == ERROR_SUCCESS ||
               DnsStatus == DNS_ERROR_NON_RFC_NAME );

    if ( BufferAllocated ) {

        SafeAllocaFree( Buffer );
    }

    return STATUS_SUCCESS;
}



BOOLEAN
LsapIsRunningOnPersonal(
    VOID
    )

/*++

Routine Description:

    This function checks the system to see if
    we are running on the personal version of
    the operating system.

    The personal version is denoted by the product
    id equal to WINNT, which is really workstation,
    and the product suite containing the personal
    suite string.

Arguments:

    None.

Return Value:

    TRUE if we are running on personal, FALSE otherwise.

--*/

{
    OSVERSIONINFOEXW OsVer = {0};
    ULONGLONG ConditionMask = 0;

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVer.wSuiteMask = VER_SUITE_PERSONAL;
    OsVer.wProductType = VER_NT_WORKSTATION;

    VER_SET_CONDITION( ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL );
    VER_SET_CONDITION( ConditionMask, VER_SUITENAME, VER_AND );

    return RtlVerifyVersionInfo( &OsVer,
                                 VER_PRODUCT_TYPE | VER_SUITENAME,
                                 ConditionMask) == STATUS_SUCCESS;
}

#ifdef XFOREST_CIRCUMVENT

NTSTATUS
LsapDbLookupEnableXForestSwitch(
    OUT BOOLEAN * Result
    )
/*++

Routine Description:

    This routine is called at startup to allow cross-forest logic to
    work on DCs before behavior-version of the forest changes from 0 to 1.

Arguments:

    Result      used to return the value of XForestEnabled switch

Return Value:

    STATUS_SUCCCESS;

--*/
{
    DWORD err;
    HKEY hKey;
    DWORD dwType;
    DWORD dwValue;
    DWORD dwValueSize;
    static BOOLEAN XForestEnabled = 0xFF;

    if ( XForestEnabled != 0xFF ) {

        ASSERT( XForestEnabled == TRUE || XForestEnabled == FALSE );
        *Result = XForestEnabled;
        return STATUS_SUCCESS;
    }

    err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                        L"SYSTEM\\CurrentControlSet\\Control\\Lsa",
                        0,
                        KEY_QUERY_VALUE,
                       &hKey );

    if ( ERROR_SUCCESS == err ) {

        dwValueSize = sizeof(dwValue);
        err = RegQueryValueExW( hKey,
                                L"EnableXForest",
                                NULL,
                                &dwType,
                                (PBYTE)&dwValue,
                                &dwValueSize );

        if ( ERROR_SUCCESS == err ) {

            if ( dwValue != 0 ) {

                XForestEnabled = TRUE;

            } else {

                XForestEnabled = FALSE;
            }
        }

        RegCloseKey( hKey );
    }

    return err;
}

#endif // XFOREST_CIRCUMVENT

NTSTATUS
LsaITestCall(
    IN LSAPR_HANDLE PolicyHandle,
    IN LSAPR_TEST_INTERNAL_ROUTINES Call,
    IN PLSAPR_TEST_INTERNAL_ARG_LIST InputArgs,
    OUT PLSAPR_TEST_INTERNAL_ARG_LIST *OutputArgs
    )
{
    return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbpolex.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbpol2.c

Abstract:

    LSA Database - Policy Object Private API Workers

Author:

    Mac McLain       (MacM)      January 17, 1997

Environment:

Revision History:

--*/
#include <lsapch2.h>
#include <dbp.h>
#include "lsawmi.h"

#ifndef LSAP_DB_POLICY_MAX_BUFFERS
#define LSAP_DB_POLICY_MAX_BUFFERS             ((ULONG) 0x00000005L)
#endif

NTSTATUS
LsapDbVerifyInfoAllQueryPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    OUT PACCESS_MASK RequiredAccess
    )

/*++

Routine Description:

    This function validates a Local Policy Information Class.  If valid, a mask
    of the accesses required to set the Policy Information of the class is
    returned.

Arguments:

    PolicyHandle - Handle from an LsapDbOpenPolicy call.  The handle
        may be trusted.

    InformationClass - Specifies a Policy Information Class.

    RequiredAccess - Points to variable that will receive a mask of the
        accesses required to query the given class of Policy Information.
        If an error is returned, this value is cleared to 0.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The Policy Information Class provided is
            valid and the information provided is consistent with this
            class.

        STATUS_INVALID_PARAMETER - Invalid parameter:

            Information Class is invalid
            Policy  Information not valid for the class

        STATUS_SHARED_POLICY - The policy is replicated from the DCs and cannot be modified
            locally
--*/

{
    //
    // Ensure the info level is valid.
    //

    if ( InformationClass < PolicyDomainEfsInformation ||
         InformationClass > PolicyDomainKerberosTicketInformation ) {
        return STATUS_INVALID_PARAMETER;
    }

    *RequiredAccess = LsapDbRequiredAccessQueryDomainPolicy[InformationClass];

    return STATUS_SUCCESS;

}


NTSTATUS
LsapDbVerifyInfoAllSetPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    IN PVOID PolicyInformation,
    OUT PACCESS_MASK RequiredAccess
    )

/*++

Routine Description:

    This function validates a Policy Information Class.  If valid, a mask
    of the accesses required to set the Policy Information of the class is
    returned.

Arguments:

    PolicyHandle - Handle from an LsapDbOpenPolicy call.  The handle
        may be trusted.

    InformationClass - Specifies a Policy Information Class.

    RequiredAccess - Points to variable that will receive a mask of the
        accesses required to query the given class of Policy Information.
        If an error is returned, this value is cleared to 0.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The Policy Information Class provided is
            valid and the information provided is consistent with this
            class.

        STATUS_INVALID_PARAMETER - Invalid parameter:

            Information Class is invalid
            Policy  Information not valid for the class
--*/

{

    //
    // Ensure the info level is valid.
    //

    if ( InformationClass < PolicyDomainEfsInformation ||
         InformationClass > PolicyDomainKerberosTicketInformation ) {
        return STATUS_INVALID_PARAMETER;

    } else if ( InformationClass == PolicyDomainKerberosTicketInformation &&
                PolicyInformation == NULL ) {

        return STATUS_INVALID_PARAMETER;
    }

    *RequiredAccess = LsapDbRequiredAccessSetDomainPolicy[InformationClass];

    return STATUS_SUCCESS;
}



NTSTATUS
NTAPI
LsarQueryDomainInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_DOMAIN_INFORMATION *PolicyDomainInformation
    )
/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsarQueryDomainInformationPolicy API.

    The LsaQueryDomainInformationPolicy API obtains information from the Local Policy
    object.  The caller must have access appropriate to the information
    being requested (see InformationClass parameter).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                       Required Access Type
        PolicyDomainEfsInformation              POLICY_VIEW_LOCAL_INFORMATION
        PolicyDomainKerberosTicketInformation   POLICY_VIEW_LOCAL_INFORMATION

    PolicyLocalInformation - receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INTERNAL_DB_CORRUPTION - The Policy Database is possibly
            corrupt.  The returned Policy Information is invalid for
            the given class.
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN ObjectReferenced = FALSE;
    ACCESS_MASK DesiredAccess;
    ULONG ReferenceOptions, DereferenceOptions = 0;


    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarQueryDomainInformationPolicy\n" ));
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_QueryDomainInformationPolicy);

    Status = LsapDbVerifyInfoAllQueryPolicy(
                 PolicyHandle,
                 InformationClass,
                 &DesiredAccess
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryInfoDomainPolicyFinish;
    }

    //
    // If querying the Audit Log Full information, we may need to perform a
    // test write to the Audit Log to verify that the Log Full status is
    // up to date.  The Audit Log Queue Lock must always be taken
    // prior to acquiring the LSA Database lock, so take the former lock
    // here in case we need it.
    //

    ReferenceOptions = LSAP_DB_LOCK |
                       LSAP_DB_START_TRANSACTION | LSAP_DB_READ_ONLY_TRANSACTION |
                       LSAP_DB_NO_DS_OP_TRANSACTION;

    DereferenceOptions = LSAP_DB_LOCK |
                         LSAP_DB_FINISH_TRANSACTION | LSAP_DB_READ_ONLY_TRANSACTION |
                         LSAP_DB_NO_DS_OP_TRANSACTION;

    //
    // Acquire the Lsa Database lock.  Verify that the handle is valid, is
    // a handle to the Policy object and has the necessary access granted.
    // Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 DesiredAccess,
                 PolicyObject,
                 PolicyObject,
                 ReferenceOptions
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryInfoDomainPolicyFinish;
    }

    ObjectReferenced = TRUE;

    //
    // If caching is enabled for this Information Class, grab the info from the
    // cache.
    //

    *PolicyDomainInformation = NULL;

    Status = LsapDbQueryInformationPolicyEx(
                 LsapPolicyHandle,
                 InformationClass,
                 PolicyDomainInformation
                 );

QueryInfoDomainPolicyFinish:

    //
    // If necessary, dereference the Policy Object, release the LSA Database lock and
    // return.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     PolicyObject,
                     DereferenceOptions,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    LsapDsDebugOut(( DEB_FTRACE, "LsarQueryDomainInformationPolicy: 0x%lx\n", Status ));
    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_QueryDomainInformationPolicy);
    LsarpReturnPrologue();


    return(Status);
}

NTSTATUS
NTAPI
LsarSetDomainInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_DOMAIN_INFORMATION PolicyDomainInformation
    )
/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsarSetDomainInformationPolicy API.

    The LsarSetDomainInformationPolicy API obtains information from the Domain Policy
    object.  The caller must have access appropriate to the information
    being requested (see InformationClass parameter).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the information to be set.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        PolicyAuditEventsInformation      POLICY_VIEW_AUDIT_INFORMATION
        PolicyAccountDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyPdAccountInformation        POLICY_GET_PRIVATE_INFORMATION
        PolicyLsaServerRoleInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyReplicaSourceInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyDefaultQuotaInformation     POLICY_VIEW_LOCAL_INFORMATION
        PolicyAuditFullQueryInformation   POLICY_VIEW_AUDIT_INFORMATION
        PolicyDnsDomainInformation        POLICY_VIEW_LOCAL_INFORMATION
        PolicyDnsDomainInformationInt     POLICY_VIEW_LOCAL_INFORMATION

    PolicyLocalInformation - receives a pointer to the buffer information to be set

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN ObjectReferenced = FALSE;
    ACCESS_MASK DesiredAccess;
    ULONG ReferenceOptions, DereferenceOptions = 0;

    LsarpReturnCheckSetup();
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_SetDomainInformationPolicy);

    Status = LsapDbVerifyInfoAllSetPolicy(
                 PolicyHandle,
                 InformationClass,
                 PolicyDomainInformation,
                 &DesiredAccess
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryInfoDomainPolicyFinish;
    }

    //
    // If querying the Audit Log Full information, we may need to perform a
    // test write to the Audit Log to verify that the Log Full status is
    // up to date.  The Audit Log Queue Lock must always be taken
    // prior to acquiring the LSA Database lock, so take the former lock
    // here in case we need it.
    //

    ReferenceOptions = LSAP_DB_LOCK | LSAP_DB_NO_DS_OP_TRANSACTION | LSAP_DB_START_TRANSACTION;
    DereferenceOptions = LSAP_DB_LOCK | LSAP_DB_NO_DS_OP_TRANSACTION | LSAP_DB_FINISH_TRANSACTION;


    //
    // Acquire the Lsa Database lock.  Verify that the handle is valid, is
    // a handle to the Policy object and has the necessary access granted.
    // Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 DesiredAccess,
                 PolicyObject,
                 PolicyObject,
                 ReferenceOptions
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryInfoDomainPolicyFinish;
    }

    ObjectReferenced = TRUE;

    Status = LsapDbSetInformationPolicyEx(
                 LsapPolicyHandle,
                 InformationClass,
                 PolicyDomainInformation
                 );

QueryInfoDomainPolicyFinish:

    //
    // If necessary, dereference the Policy Object, release the LSA Database lock and
    // return.
    //

    if (ObjectReferenced) {

        //
        // Don't notify the NT 4 replicator.  NT 4 doesn't understand any of the attributes
        //  changed by this API.
        //
        Status = LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     PolicyObject,
                     DereferenceOptions | LSAP_DB_OMIT_REPLICATOR_NOTIFICATION,
                     SecurityDbChange,
                     Status
                     );
    }

#if DBG
    LsapDsDebugOut(( DEB_POLICY,
                     "LsarSetDomainInformationPolicy for info %lu returned 0x%lx\n",
                     InformationClass,
                     Status ));
#endif

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_SetDomainInformationPolicy);
    LsarpReturnPrologue();

    return(Status);

}




NTSTATUS
LsapDbQueryInformationPolicyEx(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    IN OUT PVOID *Buffer
    )

/*++

Routine Description:

    This function is a thin wrapper around LsapDbSlowQueryInformationPolicyEx

    The LsaQueryInformationPolicy API obtains information from the Policy
    object.  The caller must have access appropriate to the information
    being requested (see InformationClass parameter).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    NOTE:  Currently, this function only allows the
        PolicyDefaultQuotaInformation information class to be read from
        the Policy Cache.  Other information classes can be added
        in the future.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        PolicyAuditEventsInformation      POLICY_VIEW_AUDIT_INFORMATION
        PolicyPrimaryDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyAccountDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyPdAccountInformation        POLICY_GET_PRIVATE_INFORMATION
        PolicyLsaServerRoleInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyReplicaSourceInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyDefaultQuotaInformation     POLICY_VIEW_LOCAL_INFORMATION
        PolicyAuditFullQueryInformation   POLICY_VIEW_AUDIT_INFORMATION

    Buffer - Pointer to location that contains either a pointer to the
        buffer that will be used to return the information.  If NULL
        is contained in this location, a buffer will be allocated via
        MIDL_user_allocate and a pointer to it returned.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INTERNAL_DB_CORRUPTION - The Policy Database is possibly
            corrupt.  The returned Policy Information is invalid for
            the given class.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = LsapDbSlowQueryInformationPolicyEx(
                 LsapPolicyHandle,
                 InformationClass,
                 Buffer
                 );

    return(Status);

}


NTSTATUS
LsapDbSlowQueryInformationPolicyEx(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    IN OUT PVOID *Buffer
    )

/*++

Routine Description:

    This function is the slow LSA server RPC worker routine for the
    LsarQueryInformationPolicy API.  It actually reads the information
    from backing storage.

    The LsaQueryInformationPolicy API obtains information from the Policy
    object.  The caller must have access appropriate to the information
    being requested (see InformationClass parameter).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        PolicyAuditEventsInformation      POLICY_VIEW_AUDIT_INFORMATION
        PolicyPrimaryDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyAccountDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyPdAccountInformation        POLICY_GET_PRIVATE_INFORMATION
        PolicyLsaServerRoleInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyReplicaSourceInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyDefaultQuotaInformation     POLICY_VIEW_LOCAL_INFORMATION
        PolicyAuditFullQueryInformation   POLICY_VIEW_AUDIT_INFORMATION

    Buffer - Pointer to location that contains either a pointer to the
        buffer that will be used to return the information.  If NULL
        is contained in this location, a buffer will be allocated via
        MIDL_user_allocate and a pointer to it returned.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INTERNAL_DB_CORRUPTION - The Policy Database is possibly
            corrupt.  The returned Policy Information is invalid for
            the given class.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PPOLICY_DOMAIN_EFS_INFO PolicyEfsInfo;
    PPOLICY_DOMAIN_KERBEROS_TICKET_INFO PolicyKerbTicketInfo;
    LSAP_DB_ATTRIBUTE Attributes[LSAP_DB_ATTRS_INFO_CLASS_POLICY];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    ULONG AttributeCount = 0;
    ULONG AttributeNumber = 0;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) PolicyHandle;

    PVOID InformationBuffer = NULL;
    BOOLEAN ObjectReferenced = FALSE;
    ULONG EventAuditingOptionsSize, InfoSize;
    BOOLEAN InfoBufferInAttributeArray = TRUE;
    BOOLEAN BufferProvided = FALSE;

    if (*Buffer != NULL) {

        BufferProvided = TRUE;
    }

    //
    // Compile a list of the attributes that hold the Policy Information of
    // the specified class.
    //

    NextAttribute = Attributes;

    switch (InformationClass) {


    case PolicyDomainEfsInformation:

        //
        // Request read of the Efs policy attribute
        //
        LsapDbInitializeAttributeDs( NextAttribute,
                                     PolEfDat,
                                     NULL,
                                     0,
                                     FALSE );

        NextAttribute++;
        AttributeCount++;
        break;

    case PolicyDomainKerberosTicketInformation:

        LsapDbInitializeAttributeDs( NextAttribute,
                                     KerOpts,
                                     NULL,
                                     0,
                                     FALSE );

        NextAttribute++;
        AttributeCount++;

        LsapDbInitializeAttributeDs( NextAttribute,
                                     KerMinT,
                                     NULL,
                                     0,
                                     FALSE );

        NextAttribute++;
        AttributeCount++;

        LsapDbInitializeAttributeDs( NextAttribute,
                                     KerMaxT,
                                     NULL,
                                     0,
                                     FALSE );

        NextAttribute++;
        AttributeCount++;

        LsapDbInitializeAttributeDs( NextAttribute,
                                     KerMaxR,
                                     NULL,
                                     0,
                                     FALSE );

        NextAttribute++;
        AttributeCount++;

        LsapDbInitializeAttributeDs( NextAttribute,
                                     KerProxy,
                                     NULL,
                                     0,
                                     FALSE );

        NextAttribute++;
        AttributeCount++;

        LsapDbInitializeAttributeDs( NextAttribute,
                                     KerLogoff,
                                     NULL,
                                     0,
                                     FALSE );

        NextAttribute++;
        AttributeCount++;

        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto SlowQueryInformationPolicyError;
    }

    //
    //
    // Read the attributes corresponding to the given Policy Information
    // Class.  Memory will be allocated where required for output
    // Attribute Value buffers, via MIDL_user_allocate().
    //

    Status = LsapDbReadAttributesObject( PolicyHandle,
                                         0,
                                         Attributes,
                                         AttributeCount );

    if (!NT_SUCCESS(Status)) {

        //
        // Some attributes may not exist because they were never set
        // or were deleted because they were set to NULL values.
        //
        goto SlowQueryInformationPolicyError;
    }

    //
    // Now copy the information read to the output.  The following flags
    // are used to control freeing of memory buffers:
    //
    // InfoBufferInAttributeArray
    //
    // If set to TRUE (the default), the information to be returned to
    // the caller consists of a single buffer which was read directly
    // from a single attribute of the Policy object and can be returned
    // as is to the caller.  The information buffer being returned is
    // therefore referenced by the single Attribute Information block's
    // AttributeValue field.
    //
    // If set to FALSE, the information to be returned to the caller
    // does not satisfy the above.  The information to be returned is
    // either obtained from a single attribute, but is in a different form
    // from that read from the Database, or it is complex, consisting
    // of information read from multiple attributes, hung off a top-level
    // node.  In these cases, the top level information buffer is not
    // referenced by any member of the Attribute Info Array.
    //
    // Attribute->MemoryAllocated
    //
    // When an attribute is read via LsapDbReadAttributesObject, this
    // field is set to TRUE to indicate that memory was allocated via
    // MIDL_user_allocate() for the AttributeValue.  If this memory
    // buffer is to be returned to the caller (i.e. referenced from
    // the output structure graph returned), it is set to FALSE so that
    // the normal success finish part of this routine will not free it.
    // In this case, the calling server RPC stub will free the memory after
    // marshalling its contents into the return buffer.  If this memory
    // buffer is not to be returned to the calling RPC server stub (because
    // the memory is an intermediate buffer), the field is left set to TRUE
    // so that normal cleanup will free it.
    //

    NextAttribute = Attributes;

    switch (InformationClass) {

    case PolicyDomainEfsInformation:

        //
        // Get the size of the item
        //
        InfoSize = NextAttribute->AttributeValueLength;

        //
        // Allocate memory for output buffer top-level structure.
        //
        InfoBufferInAttributeArray = FALSE;
        PolicyEfsInfo = MIDL_user_allocate( sizeof( POLICY_DOMAIN_EFS_INFO ) );

        if (PolicyEfsInfo == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        PolicyEfsInfo->InfoLength = InfoSize;

        //
        // Next, the blob
        //
        PolicyEfsInfo->EfsBlob = NextAttribute->AttributeValue;
        NextAttribute->MemoryAllocated = FALSE;

        InformationBuffer = PolicyEfsInfo;
        break;

    case PolicyDomainKerberosTicketInformation:
        //
        // Allocate memory for output buffer top-level structure.
        //
        InfoBufferInAttributeArray = FALSE;
        PolicyKerbTicketInfo = MIDL_user_allocate( sizeof( POLICY_DOMAIN_KERBEROS_TICKET_INFO ) );

        if (PolicyKerbTicketInfo == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }


        PolicyKerbTicketInfo->AuthenticationOptions = *(PULONG)NextAttribute->AttributeValue;
        NextAttribute++;


        RtlCopyMemory( &PolicyKerbTicketInfo->MaxServiceTicketAge,
                       NextAttribute->AttributeValue,
                       sizeof( LARGE_INTEGER ) );
        NextAttribute++;

        RtlCopyMemory( &PolicyKerbTicketInfo->MaxTicketAge,
                       NextAttribute->AttributeValue,
                       sizeof( LARGE_INTEGER ) );
        NextAttribute++;

        RtlCopyMemory( &PolicyKerbTicketInfo->MaxRenewAge,
                       NextAttribute->AttributeValue,
                       sizeof( LARGE_INTEGER ) );
        NextAttribute++;

        RtlCopyMemory( &PolicyKerbTicketInfo->MaxClockSkew,
                       NextAttribute->AttributeValue,
                       sizeof( LARGE_INTEGER ) );
        NextAttribute++;

        RtlCopyMemory( &PolicyKerbTicketInfo->Reserved,
                       NextAttribute->AttributeValue,
                       sizeof( LARGE_INTEGER ) );
        NextAttribute++;

        InformationBuffer = PolicyKerbTicketInfo;
        break;


    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto SlowQueryInformationPolicyError;
    }

    //
    // Verify that the returned Policy Information is valid. If not,
    // the Policy Database is corrupt.
    //

//    Status = STATUS_INTERNAL_DB_CORRUPTION;
//
//    if (!LsapDbValidInfoPolicy(InformationClass, InformationBuffer)) {
//
//        goto SlowQueryInformationPolicyError;
//    }

    Status = STATUS_SUCCESS;

    //
    // If the caller provided a buffer, return information there.
    //

    if (BufferProvided) {

        RtlCopyMemory(
            *Buffer,
            InformationBuffer,
            LsapDbPolicy.Info[ InformationClass ].AttributeLength
            );

        MIDL_user_free( InformationBuffer );
        InformationBuffer = NULL;

    } else {

        *Buffer = InformationBuffer;
    }

SlowQueryInformationPolicyFinish:

    //
    // Free any unwanted buffers that were allocated by
    // LsapDbReadAttributesObject() and that are not being returned to the
    // caller server stub.  The server stub will free the buffers that we
    // do return after copying them to the return RPC transmit buffer.
    //

    //$ REVIEW  kumarp 22-March-1999
    //  replace this for loop with LsapDbFreeAttributes
    //
    for (NextAttribute = Attributes, AttributeNumber = 0;
         AttributeNumber < AttributeCount;
         NextAttribute++, AttributeNumber++) {

        //
        // If buffer holding attribute is marked as allocated, it is
        // to be freed here.
        //

        if (NextAttribute->MemoryAllocated) {

            if (NextAttribute->AttributeValue != NULL) {

                MIDL_user_free(NextAttribute->AttributeValue);
            }
        }
    }

    return(Status);

SlowQueryInformationPolicyError:

    //
    // If necessary, free the memory allocated for the output buffer.
    // We only do this free if the buffer is not referenced by the
    // attribute array, since all buffers so referenced will be freed
    // here or in the Finish section.
    //

    if ((InformationBuffer != NULL) && !InfoBufferInAttributeArray) {

        MIDL_user_free(InformationBuffer);
        InformationBuffer = NULL;
    }

    //
    // Free the buffers referenced by the attributes array that will not be
    // freed by the Finish section of this routine.
    //

    //$ REVIEW  kumarp 22-March-1999
    //  replace this for loop with LsapDbFreeAttributes
    //
    for (NextAttribute = Attributes, AttributeNumber = 0;
         AttributeNumber < AttributeCount;
         NextAttribute++, AttributeNumber++) {

        //
        // If buffer holding attribute is marked as normally not to be freed,
        // will not get freed by the Finish section so it must be freed here.
        //

        if (!NextAttribute->MemoryAllocated) {

            if (NextAttribute->AttributeValue != NULL) {

                MIDL_user_free(NextAttribute->AttributeValue);
                NextAttribute->AttributeValue = NULL;
                NextAttribute->MemoryAllocated = FALSE;
            }

            NextAttribute->MemoryAllocated = FALSE;
        }
    }

    goto SlowQueryInformationPolicyFinish;
}



NTSTATUS
LsapDbSetInformationPolicyEx(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    IN PVOID PolicyInformation
    )
/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaSetInformationPolicy API.

    The LsaSetInformationPolicy API modifies information in the Policy Object.
    The caller must have access appropriate to the information to be changed
    in the Policy Object, see the InformationClass parameter.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the type of information being changed.
        The information types and accesses required to change them are as
        follows:

        PolicyDomainEfsInformation               POLICY_TRUST_ADMIN
        PolicyDomainKerberosTicketInformation    POLICY_TRUST_ADMIN

    Buffer - Points to a structure containing the information appropriate
        to the information type specified by the InformationClass parameter.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        Others TBS
--*/
{
    NTSTATUS Status = STATUS_SUCCESS, SavedStatus;
    ACCESS_MASK DesiredAccess;

    PPOLICY_DOMAIN_EFS_INFO PolicyEfsInfo;
    PPOLICY_DOMAIN_KERBEROS_TICKET_INFO PolicyKerbTicketInfo;

    LSAP_DB_ATTRIBUTE Attributes[LSAP_DB_ATTRS_INFO_CLASS_POLICY];
    LSAP_DB_ATTRIBUTE OldAttributes[LSAP_DB_ATTRS_INFO_CLASS_POLICY];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    PLSAP_DB_ATTRIBUTE NextOldAttribute;
    ULONG AttributeCount = 0;
    ULONG OldAttributeCount = 0;
    ULONG AttributeNumber;
    ULONG AccountUlong;
    BOOLEAN RemoveAttributes = FALSE;
    BOOLEAN OldHandleDs;
    BOOLEAN BooleanStatus;
    BOOLEAN PreviousAuditEventsInfoExists;
    BOOLEAN ResetClientSyncData;

    PUNICODE_STRING DomainName = NULL;
    LARGE_INTEGER ModifiedIdAtLastPromotion;
    PUNICODE_STRING ReplicaSource = NULL;
    PUNICODE_STRING AccountName = NULL;
    ULONG SpecialProcessing = 0;

    BOOLEAN Notify = FALSE;
    BOOLEAN AuditingEnabled=FALSE;
    BOOLEAN AuditingSuccessEnabled=FALSE;
    BOOLEAN AuditingFailureEnabled=FALSE;
    USHORT AuditEventType;

    POLICY_NOTIFICATION_INFORMATION_CLASS NotifyClass = 0;

    if ( PolicyInformation == NULL ) {

        RemoveAttributes = TRUE;
    }

    AuditingFailureEnabled =
        LsapAdtIsAuditingEnabledForCategory(AuditCategoryPolicyChange,
                                            EVENTLOG_AUDIT_FAILURE);

    AuditingSuccessEnabled =
        LsapAdtIsAuditingEnabledForCategory(AuditCategoryPolicyChange,
                                            EVENTLOG_AUDIT_SUCCESS);

    AuditingEnabled = AuditingSuccessEnabled || AuditingFailureEnabled;

    //
    // Build the list of attributes
    //
    NextAttribute = Attributes;
    NextOldAttribute = OldAttributes;

    switch (InformationClass) {

    case PolicyDomainEfsInformation:

        PolicyEfsInfo = ( PPOLICY_DOMAIN_EFS_INFO )PolicyInformation;

        //
        // Do the blob attribute
        //
        LsapDbInitializeAttributeDs( NextAttribute,
                                     PolEfDat,
                                     PolicyEfsInfo ? PolicyEfsInfo->EfsBlob : NULL,
                                     PolicyEfsInfo ? PolicyEfsInfo->InfoLength : 0,
                                     FALSE );

        AttributeCount++;
        Notify = TRUE;
        NotifyClass = PolicyNotifyDomainEfsInformation;

        if (AuditingEnabled) {
            LsapDbInitializeAttributeDs( NextOldAttribute,
                                         PolEfDat,
                                         NULL,
                                         0,
                                         FALSE );
            OldAttributeCount++;
        }

        break;

    case PolicyDomainKerberosTicketInformation:

        PolicyKerbTicketInfo = ( PPOLICY_DOMAIN_KERBEROS_TICKET_INFO )PolicyInformation;

        LsapDbInitializeAttributeDs( NextAttribute,
                                     KerOpts,
                                     PolicyKerbTicketInfo ?
                                                &PolicyKerbTicketInfo->AuthenticationOptions : 0,
                                     sizeof( ULONG ),
                                     FALSE );

        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs( NextAttribute,
                                     KerMinT,
                                     PolicyKerbTicketInfo ?
                                                &PolicyKerbTicketInfo->MaxServiceTicketAge: 0,
                                     sizeof( LARGE_INTEGER ),
                                     FALSE );

        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs( NextAttribute,
                                     KerMaxT,
                                     PolicyKerbTicketInfo ?
                                                &PolicyKerbTicketInfo->MaxTicketAge : 0,
                                     sizeof( LARGE_INTEGER ),
                                     FALSE );

        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs( NextAttribute,
                                     KerMaxR,
                                     PolicyKerbTicketInfo ?
                                                &PolicyKerbTicketInfo->MaxRenewAge : 0,
                                     sizeof( LARGE_INTEGER ),
                                     FALSE );

        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs( NextAttribute,
                                     KerProxy,
                                     PolicyKerbTicketInfo ?
                                                &PolicyKerbTicketInfo->MaxClockSkew: 0,
                                     sizeof( LARGE_INTEGER ),
                                     FALSE );

        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs( NextAttribute,
                                     KerLogoff,
                                     PolicyKerbTicketInfo ?
                                                &PolicyKerbTicketInfo->Reserved: 0,
                                     sizeof( LARGE_INTEGER ),
                                     FALSE );

        AttributeCount++;
        NextAttribute++;

        Notify = TRUE;
        NotifyClass = PolicyNotifyDomainKerberosTicketInformation;

        if (AuditingEnabled) {
            LsapDbInitializeAttributeDs( NextOldAttribute,
                                         KerOpts,
                                         0, sizeof( ULONG ), FALSE );

            OldAttributeCount++;
            NextOldAttribute++;

            LsapDbInitializeAttributeDs( NextOldAttribute,
                                         KerMinT,
                                         0, sizeof( LARGE_INTEGER ), FALSE );

            OldAttributeCount++;
            NextOldAttribute++;

            LsapDbInitializeAttributeDs( NextOldAttribute,
                                         KerMaxT,
                                         0, sizeof( LARGE_INTEGER ), FALSE );

            OldAttributeCount++;
            NextOldAttribute++;

            LsapDbInitializeAttributeDs( NextOldAttribute,
                                         KerMaxR,
                                         0, sizeof( LARGE_INTEGER ), FALSE );

            OldAttributeCount++;
            NextOldAttribute++;

            LsapDbInitializeAttributeDs( NextOldAttribute,
                                         KerProxy,
                                         0, sizeof( LARGE_INTEGER ), FALSE );

            OldAttributeCount++;
            NextOldAttribute++;

            LsapDbInitializeAttributeDs( NextOldAttribute,
                                         KerLogoff,
                                         0, sizeof( LARGE_INTEGER ), FALSE );

            OldAttributeCount++;
            NextOldAttribute++;
        }

        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto SetInformationPolicyError;
    }

    //
    // Query the existing values before we modify them
    //
    if (AuditingEnabled) {

        (void) LsapDbReadAttributesObject( PolicyHandle,
                                           0, // no options
                                           OldAttributes,
                                           OldAttributeCount );
    }

    //
    // Update the Policy Object attributes
    //
    if ( RemoveAttributes ) {

        Status = LsapDbDeleteAttributesObject( PolicyHandle,
                                               Attributes,
                                               AttributeCount );

    } else {

        Status = LsapDbWriteAttributesObject( PolicyHandle,
                                              Attributes,
                                              AttributeCount );
    }

    if ( ( AuditingSuccessEnabled &&  NT_SUCCESS(Status) ) ||
         ( AuditingFailureEnabled && !NT_SUCCESS(Status) ) ) {
        
        AuditEventType = NT_SUCCESS(Status) ?
            EVENTLOG_AUDIT_SUCCESS : EVENTLOG_AUDIT_FAILURE;
        (void) LsapAdtGenerateDomainPolicyChangeAuditEvent(
            InformationClass,
            AuditEventType,
            OldAttributes,
            Attributes,
            AttributeCount);
    }

    if (!NT_SUCCESS(Status)) {

        goto SetInformationPolicyError;
    }

    //
    // Finally, call the notification routines.  We don't care about errors coming back
    // from this.
    //
    if ( Notify ) {

        LsaINotifyChangeNotification( NotifyClass );
    }

SetInformationPolicyFinish:

    //
    // Free memory allocated by this routine for attribute buffers.
    // These have MemoryAllocated = TRUE in their attribute information.
    // Leave alone buffers allocated by calling RPC stub.
    //

    (void) LsapDbFreeAttributes(AttributeCount, Attributes);
    (void) LsapDbFreeAttributes(OldAttributeCount, OldAttributes);

    return(Status);

SetInformationPolicyError:

    goto SetInformationPolicyFinish;
}


NTSTATUS
LsaISetServerRoleForNextBoot(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_LSA_SERVER_ROLE ServerRole
    )
/*++

Routine Description:

    This function will set the server role for the machine.  It is intended for
    use by setup only.  The value that is set has no affect on the currently running
    system.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    ServerRole - Server role to set

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        Others TBS
--*/
{
    LsapDsDebugOut(( DEB_ERROR, "LsaISetServerRoleForNextBoot stubbed out\n" ));
    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbobject.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbobject.c

Abstract:

    Local Security Authority - LSA Database Public Object Management Routines

    This module contains the public routines that perform LSA Database object
    manipulation.  These routines are exported to the rest of the
    LSA, function prototypes of these routines will be found in db.h.  These
    exported routines present an implementation-independent hierarchic
    object-based view of the LSA Database and are used exclusively by the
    LSA API.  See the Additional Notes further below for a description of
    the LSA Database model.

    Routines in this module that are private to the object management
    function have function prototypes in dbp.h.

Author:

    Scott Birrell       (ScottBi)       August 26, 1991

Environment:

    User Mode

Revision History:

Notes on the LSA Database Architecture

OBJECT STRUCTURE

    The LSA Database is an hierarchic structure containing "objects" of
    several "types".  Objects have either a "name" or a Sid depending only
    on object type, and may have data stored with them under named
    "attributes".  The database hierarchy contains a single root object
    called the Lsa Database object and having name "Policy".  This object
    represents the entire LSA Database.  Currently, the Lsa Database has a
    simple hierarchy consisting of only two levels.

                           Policy

     Account Objects,  Trusted Domain Objects, Secret Objects

    The Policy object is called a "Container Object" for the other
    object types.  The attributes of the Policy object house information
    that applies generally to the whole database.  The single Policy object
    has name "Policy".

    Account objects represent those user accounts which are treated specially
    on the local system, but not necessarily so on other systems.  Such
    accounts may have additional privileges, or system quotas for example.
    Account objects are referenced by Sid.

    TrustedDomain objects describe domains which the system has a trust
    relationship with.  These objects are referenced by Sid.

    Secret Objects are named entities containing information that is protected
    in some way.  Secret objects are referenced by name.

OBJECT ACCESS AND DATABASE SECURITY

    Each object in the LSA Database is protected by a Security Descriptor which
    contains a Discretionary Access Control List (DACL) defining which groups
    can access the object and in which ways.  Before an object can be
    accessed, it must first be "opened" with the desired accesses requested
    that are needed to perform the desired operations on the object.  Opening
    an object returns a "handle" to the object.  This handle may then be
    specified on Lsa services that access the object.  After use, the handle
    to the object should then be "closed".  Closing the handle renders it
    invalid.

CONCURRENCY OF ACCESS

    More than one handle may be open to an object concurrently, possibly with
    different accesses granted.

PERMANENCY OF OBJECTS

    All LSA Database objects are backed by non-volatile storage media, that is,
    they remain in existence until deleted via the LsaDelete() service.
    The Policy object cannot be deleted and the single object of this type cannot
    be created via the public LSA service interface.

    Objects will not be deleted while there are open handles to them.
    When access to an object is no longer required, the handle should be
    "closed".

DATABASE DESIGN

    The LSA Database is of an hierarchic design permitting future extension.
    Currently the database has the following simple hierarchy:

                       Policy Object  (name = Policy)

       Account Objects    TrustedDomain Objects   Secret Objects

    The single object of type Policy is at the topmost level and serves as
    a parent or "container" object  for objects of the other three types.
    Since named objects of different types may potentially reside in the
    same container object in the future, an object is referenced uniquely
    only if the object name and type together with the identity of its
    container object (currently always the Policy object) are known.
    To implement this kind of reference easily, objects of the same type
    are held within a "classifying directory" which has a name derived
    from the object's type as follows:

    Object Type      Containing Directory Name

    Policy           Not required
    Account          Accounts
    TrustedDomain    Domains
    Secret           Secrets

IMPLEMENTATION NOTES

    The LSA Database is currently implemented as a subtree of the Configuration
    Registry.  This subtree has the following form

       \Policy\Accounts\<account_object_Rid>\<account_object_attribute_name>
              \Domains\<trusted_domain_Rid>\<trus_domain_object_attribute_name>
              \Secrets\<secret_name>\<secret_object_attribute_name>
              \<policy_object_attribute_name>

    where each item between \..\ is the name of a Registry Key and
    "Rid" is a character name made out of the Relative Id (lowest
    subauthority extracted from the object's Sid).  Named object attributes
    can have binary data "values".

--*/
#include <lsapch2.h>
#include "dbp.h"
// #include "adtp.h"
#include <accctrl.h>
#include <sertlp.h>

NTSTATUS
LsapDbOpenObject(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Options,
    OUT PLSAPR_HANDLE ObjectHandle
    )

/*++

Routine Description:

    This function opens an existing object in the LSA Database.  An error
    is returned if the object does not already exist.  The LSA Database must
    be already locked when calling this function and any container handle
    must have been validated as having the necessary access for creation
    of an object of the given type.

Arguments:

    ObjectInformation - Pointer to information describing this object.  The
        following information items must be specified:

        o Object Type Id
        o Object Logical Name (as ObjectAttributes->ObjectName, a pointer to
             a Unicode string)
        o Container object handle (for any object except the root Policy object).
        o Object Sid (if any)

        All other fields in ObjectAttributes portion of ObjectInformation
        such as SecurityDescriptor are ignored.

    DesiredAccess - Specifies the Desired accesses to the Lsa object

    Options - Specifies optional additional actions to be taken:

        LSAP_DB_TRUSTED - A trusted handle is wanted regardless of the trust
            status of any container handle provided in ObjectInformation.

        LSAP_DB_OMIT_REPLICATOR_NOTIFICATION - Omit replicator notification
            on object updates.  This flag will be stored in the handle
            created for the object and retrieved when committing an update
            to the object via LsapDbDereferenceObject().

    ObjectHandle - Receives the handle to the object.

Return Value:

    NTSTATUS - Standard NT status code

        STATUS_INVALID_PARAMETER - One or more parameters invalid.
            - Invalid syntax of parameters, e.g Sid
            - Sid not specified when required for object type
            - Name specified when not allowed.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the request (e.g. memory for reading object's
            Security Descriptor).

        STATUS_OBJECT_NOT_FOUND - Object does not exist.
--*/

{
    NTSTATUS Status;
    ULONG SecurityDescriptorLength;
    LSAP_DB_HANDLE NewObjectHandle = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    OBJECT_ATTRIBUTES OpenKeyObjectAttributes;
    ULONG States = Options & LSAP_DB_STATE_MASK;
    ULONG ResetStates = 0;
    LSAPR_HANDLE OutputHandle = NULL;
    LSAP_DB_HANDLE InternalOutputHandle = NULL;

    PSECURITY_DESCRIPTOR SavedSecurityDescriptor =
        ObjectInformation->ObjectAttributes.SecurityDescriptor;

    //
    // Validate the Object Information parameter.
    //

    Status = LsapDbVerifyInformationObject( ObjectInformation );

    if (!NT_SUCCESS(Status)) {

        goto OpenObjectError;
    }


    //
    // Allocate and initialize a handle for the object.  The object's
    // Registry Key, Logical and Physical Names will be derived from
    // the given ObjectInformation and pointers to them will be stored in
    // the handle.
    //
    Status = LsapDbCreateHandle( ObjectInformation,
                                 Options,
                                 LSAP_DB_CREATE_OPEN_EXISTING,
                                 &OutputHandle );
    InternalOutputHandle = ( LSAP_DB_HANDLE ) OutputHandle;


    if ( !NT_SUCCESS( Status ) ) {

        goto OpenObjectError;
    }

    //
    // Now attempt to open the object's Registry Key.  Store the Registry
    // Key handle in the object's handle.
    //
    // Avoid this if we're using a cached handle and the key is already open.
    //
    if ( InternalOutputHandle->KeyHandle == NULL ) {

        if ( !LsapDsIsHandleDsHandle( InternalOutputHandle ) ) {

            InternalOutputHandle->fWriteDs = FALSE;

            Status = LsapRegOpenObject( InternalOutputHandle,
                                        KEY_READ | KEY_WRITE,
                                        &(InternalOutputHandle->KeyHandle)
                                        );

        } else {

            InternalOutputHandle->fWriteDs = TRUE;

            Status = LsapDsOpenObject( InternalOutputHandle,
                                       KEY_READ | KEY_WRITE,
                                       &(InternalOutputHandle->KeyHandle)
                                       );

            if ( NT_SUCCESS( Status ) && InternalOutputHandle->ObjectTypeId == PolicyObject) {

                Status = LsapRegOpenObject( InternalOutputHandle,
                                            KEY_READ | KEY_WRITE,
                                            &( InternalOutputHandle->KeyHandle ) );

            }

        }

        if (!NT_SUCCESS(Status)) {

            InternalOutputHandle->KeyHandle = NULL; // For cleanup purposes
            goto OpenObjectError;
        }
    }

    //
    // The object exists.  Unless access checking is to be bypassed, we
    // need to access the object's Security Descriptor and perform an
    // access check.  The Security Descriptor is stored as the object's
    // SecDesc attribute, so we need to read this.  First, we must query the
    // size of the Security Descriptor to determine how much memory to
    // allocate for reading it.  The query is done by issuing a read of the
    // object's SecDesc subkey with a NULL output buffer and zero size
    // specified.
    //

    if (!(InternalOutputHandle->Trusted)) {

        if ( LsapDsIsWriteDs( InternalOutputHandle ) ) {

            Status = LsapDsReadObjectSD(
                         OutputHandle,
                         &SecurityDescriptor );

        } else {

            Status = LsapRegReadObjectSD(
                         OutputHandle,
                         &SecurityDescriptor );

        }

        //
        // Request the desired accesses and store them in the object's handle.
        // granted.
        //

        if ( NT_SUCCESS( Status ) ) {

            ObjectInformation->ObjectAttributes.SecurityDescriptor = SecurityDescriptor;

            Status = LsapDbRequestAccessObject(
                         OutputHandle,
                         ObjectInformation,
                         DesiredAccess,
                         Options
                         );
        }

        //
        // If the accesses are granted, the open has completed successfully.
        // Store the container object handle in the object's handle and
        // return the handle to the caller..
        //

        if (!NT_SUCCESS(Status)) {

            goto OpenObjectError;
        }

        //
        // See if there is an existing identical handle in the cache
        //

        if ( !LsapDbFindIdenticalHandleInTable( &OutputHandle ) ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto OpenObjectError;
        }
        InternalOutputHandle = ( LSAP_DB_HANDLE ) OutputHandle;

    }

    *ObjectHandle = OutputHandle;

OpenObjectFinish:

    //
    // Restore the saved Security Descriptor reference in the object
    // information.
    //

    ObjectInformation->ObjectAttributes.SecurityDescriptor =
        SavedSecurityDescriptor;

    //
    // If necessary, free the memory allocated for the Security Descriptor
    //

    if (SecurityDescriptor != NULL) {

        LsapFreeLsaHeap( SecurityDescriptor );
    }

    return(Status);

OpenObjectError:

    //
    // If necessary, free the handle we created.
    //

    if (OutputHandle != NULL) {

        LsapDbDereferenceHandle(OutputHandle);
    }

    goto OpenObjectFinish;
}


NTSTATUS
LsapDbCreateObject(
    IN OUT PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateDisposition,
    IN ULONG Options,
    IN OPTIONAL PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG TypeSpecificAttributeCount,
    OUT PLSAPR_HANDLE ObjectHandle
    )

/*++

Routine Description:

    This function creates an object in the LSA Database, together with
    the set of attributes, such as Security Descriptor that are common
    to all object types.  The object will be left in the open state
    and the caller may use the returned handle to create the type-
    specific attributes.

    NOTE:  For an object creation, it is the responsibility of the calling
    LSA object creation routine to verify that the necessary access to the
    container object is granted.  That access is dependent on the type of
    LSA object being created.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.  No Lsa Database transaction may be pending when
              this function is called.

Arguments:

    ObjectInformation - Pointer to information describing this object.  The
        following information items must be specified:

        o Object Type Id
        o Object Logical Name (as ObjectAttributes->ObjectName, a pointer to
             a Unicode string)
        o Container object handle (for any object except the root Policy object).
        o Object Sid (if any)

        All other fields in ObjectAttributes portion of ObjectInformation
        such as SecurityDescriptor are ignored.

    DesiredAccess - Specifies the Desired accesses to the object.

    CreateDisposition - Specifies the Creation Disposition.  This is the
        action to take depending on whether the object already exists.

        LSA_OBJECT_CREATE - Create the object if it does not exist.  If
            the object already exists, return an error.

        LSA_OBJECT_OPEN_IF - Create the object if it does not exist.  If
            the object already exists, just open it.

    Options - Specifies optional information and actions to be taken

        LSAP_DB_TRUSTED - A Trusted Handle is wanted regardless of the
            Trust status of any container handle provided in
            ObjectInformation.

        LSAP_DB_OMIT_REPLICATOR_NOTIFICATION - Omit notification of the
            object creation to Replicator.

        Note, this routine performs a complete database transaction so
        there is no option to start one.

    Attributes - Optional pointer to an array of attribute
        names and values.  These are specific to the type of object.

    TypeSpecificAttributeCount - Number of elements in the array
        referenced by the Attributes parameter.

    ObjectHandle - Receives the handle to the object.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_PARAMETER - The given Sid is invalid.

        STATUS_OBJECT_NAME_EXISTS - An object having the given Sid
            already exists and has been opened because LSA_OBJECT_OPEN_IF
            disposition has been specified.  This is a warning only.

        STATUS_OBJECT_NAME_COLLISION - An object having the given Sid
            already exists but has not been opened because LSA_OBJECT_CREATE
            disposition has been specified.  This is an error.
--*/

{
    NTSTATUS Status, SecondaryStatus, IgnoreStatus;
    OBJECT_ATTRIBUTES OpenKeyObjectAttributes;
    ULONG CloseOptions, Index, TrustAttribs = 0, TrustType, TransOptions = 0, EndTransOptions = 0;
    BOOLEAN CreatedObject = FALSE;
    BOOLEAN OpenedObject = FALSE;
    BOOLEAN OpenedTransaction = FALSE;
    LSAPR_HANDLE OutputHandle = NULL;
    LSAP_DB_HANDLE InternalOutputHandle = (LSAP_DB_HANDLE) OutputHandle;
    LSAP_DB_HANDLE ContainerHandle = NULL;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId = ObjectInformation->ObjectTypeId;
    PDSNAME ObjectXRef = NULL;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbCreateObject\n" ));

    //
    // Get the container handle
    //

    ContainerHandle = (LSAP_DB_HANDLE) ObjectInformation->ObjectAttributes.RootDirectory;

    //
    // Verify the creation disposition.
    //

    if (((CreateDisposition & ~LSAP_DB_CREATE_VALID_EXTENDED_FLAGS) != LSAP_DB_OBJECT_CREATE) &&
        ((CreateDisposition & ~LSAP_DB_CREATE_VALID_EXTENDED_FLAGS) != LSAP_DB_OBJECT_OPEN_IF)) {

        Status = STATUS_INVALID_PARAMETER;
        goto CreateObjectError;
    }


    //
    // Try to open the object.  It is permissible for the object to
    // exist already if LSA_OBJECT_OPEN_IF disposition was specified.
    //

    if ( FLAG_ON( CreateDisposition, LSAP_DB_CREATE_OBJECT_IN_DS ) ) {

        Options |= LSAP_DB_OBJECT_SCOPE_DS;
    }

    Status = LsapDbOpenObject(
                 ObjectInformation,
                 DesiredAccess,
                 Options,
                 &OutputHandle
                 );

    InternalOutputHandle = (LSAP_DB_HANDLE) OutputHandle;

    if (NT_SUCCESS(Status)) {

        //
        // The object was successfully opened.  If LSA_OBJECT_OPEN_IF
        // disposition was specified, we're done, otherwise, we
        // return a collision error.
        //

        OpenedObject = TRUE;

        if ( (CreateDisposition & ~LSAP_DB_CREATE_VALID_EXTENDED_FLAGS) == LSAP_DB_OBJECT_OPEN_IF) {

            Status = STATUS_OBJECT_NAME_EXISTS;

            goto CreateObjectFinish;
        }

        if ((CreateDisposition & ~LSAP_DB_CREATE_VALID_EXTENDED_FLAGS) == LSAP_DB_OBJECT_CREATE ) {

            Status = STATUS_OBJECT_NAME_COLLISION;

            LsapLogError(
                "LsapDbCreateObject: 0x%lx\n", Status
                );

            goto CreateObjectError;
        }
    }

    //
    // The object was not successfully opened.  If this is for any
    // reason other than that the object was not found, return an error.
    //

    if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

        goto CreateObjectError;
    }

    //
    // If this is a trusted domain object, and the Ds is installed, let's try and open it
    // by Sid as well.  If this succeeds, then we'll consider that the object exists, even
    // if the names don't match..
    //

    if ( LsaDsStateInfo.UseDs && ObjectInformation->ObjectTypeId == TrustedDomainObject &&
         ObjectInformation->Sid != NULL ) {

        Status = LsapDsTrustedDomainSidToLogicalName( ObjectInformation->Sid,
                                                      NULL );

        if (NT_SUCCESS(Status)) {

            //
            // The object was successfully opened.  If LSA_OBJECT_OPEN_IF
            // disposition was specified, we're done, otherwise, we
            // return a collision error.
            //
            if ( (CreateDisposition & ~LSAP_DB_CREATE_VALID_EXTENDED_FLAGS) == LSAP_DB_OBJECT_OPEN_IF) {

                Status = STATUS_OBJECT_NAME_EXISTS;

                goto CreateObjectFinish;
            }

            if ((CreateDisposition & ~LSAP_DB_CREATE_VALID_EXTENDED_FLAGS) == LSAP_DB_OBJECT_CREATE ) {

                Status = STATUS_OBJECT_NAME_COLLISION;

                goto CreateObjectError;
            }

        }

        if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

            goto CreateObjectError;
        }
    }

    //
    // The object was not found.  Prepare to create it.  First, we need to
    // check that any maximum limit on the number of objects of this type
    // imposed will not be exceeded.
    //

    Status = LsapDbCheckCountObject(ObjectTypeId);

    if (!NT_SUCCESS(Status)) {

        goto CreateObjectError;
    }

    //
    // Next we need to create a handle for the new object.
    //
    if ( ObjectInformation->ObjectTypeId == TrustedDomainObject ) {

        ObjectInformation->ObjectTypeId = NewTrustedDomainObject;
    }

    Status = LsapDbCreateHandle( ObjectInformation,
                                 Options,
                                 LSAP_DB_CREATE_HANDLE_MORPH,
                                 &OutputHandle );
    InternalOutputHandle = (LSAP_DB_HANDLE) OutputHandle;
    if ( ObjectInformation->ObjectTypeId == NewTrustedDomainObject ) {

        ObjectInformation->ObjectTypeId = TrustedDomainObject;
    }

    if ( !NT_SUCCESS( Status ) ) {

        goto CreateObjectError;
    }

    //
    // If this is a Ds object, indicate so in the handle, so that in the
    // subsequent call to RequestAccessNewObject, we can properly make the
    // determiniation on whether to abort if this is a backup domain controller
    //
    if ( LsapDsIsHandleDsHandle( InternalOutputHandle ) ) {

        LsapDsSetHandleWriteDs( InternalOutputHandle );
    }


    //
    // Verify that the requested accesses can be given to the handle that
    // has been opened and grant them if so.
    //
    Status = LsapDbRequestAccessNewObject(
                 OutputHandle,
                 ObjectInformation,
                 DesiredAccess,
                 Options
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateObjectError;
    }

    //
    // Open a Registry transaction for creation of the object.
    //
    if ( ObjectTypeId == TrustedDomainObject ) {

        TransOptions |= LSAP_DB_READ_ONLY_TRANSACTION; // Skip the registry transaction
        EndTransOptions |= LSAP_DB_READ_ONLY_TRANSACTION;
    }

    if ( ObjectTypeId == SecretObject && !FLAG_ON( Options, LSAP_DB_OBJECT_SCOPE_DS ) ) {

        TransOptions |= LSAP_DB_NO_DS_OP_TRANSACTION;
        EndTransOptions |= LSAP_DB_NO_DS_OP_TRANSACTION;
    }

    if ( ObjectTypeId == PolicyObject ||
         ObjectTypeId == AccountObject ) {

        TransOptions |= LSAP_DB_NO_DS_OP_TRANSACTION;
        EndTransOptions |= LSAP_DB_NO_DS_OP_TRANSACTION;
    }

    Status = LsapDbOpenTransaction( TransOptions );

    if (!NT_SUCCESS(Status)) {

        goto CreateObjectError;
    }

    OpenedTransaction = TRUE;

    //
    // Add a registry transaction to create the Registry key for the new
    // Database object.
    //

    //
    // If we have a Ds name, do a Ds create
    //
    if ( !LsapDsIsHandleDsHandle( InternalOutputHandle ) ) {

        //
        // Create it in the registry
        //
        InternalOutputHandle->fWriteDs = FALSE;
        Status = LsapRegCreateObject( &InternalOutputHandle->PhysicalNameU,
                                      ObjectTypeId );

    } else {

        //
        // Don't actually attempt to create an account object
        //
        if ( InternalOutputHandle->ObjectTypeId != AccountObject) {

            Status = LsapDsCreateObject(
                        &InternalOutputHandle->PhysicalNameDs,
                        FLAG_ON( ContainerHandle->Options, LSAP_DB_TRUSTED) ?
                                            LSAPDS_CREATE_TRUSTED :
                                            0,
                        ObjectTypeId );

        } else {

            //
            // Since we didn't actually create an object, don't do any notification
            //
            Options |= LSAP_DB_OMIT_REPLICATOR_NOTIFICATION;
            goto CreateObjectReset;
        }
    }


    if (!NT_SUCCESS(Status)) {

        goto CreateObjectError;
    }

    //
    // Create the Security Descriptor for the new object.  This will be
    // stored in Self-Relative form as the value of the SecDesc attribute
    // of the new object.
    //

    Status = LsapDbCreateSDAttributeObject(
                 OutputHandle,
                 ObjectInformation
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateObjectError;
    }

    //
    // The self-relative SD returned is not needed here or by callers of
    // this routine.
    //

    if (ObjectInformation->ObjectAttributes.SecurityDescriptor != NULL) {

        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            ObjectInformation->ObjectAttributes.SecurityDescriptor
            );

        ObjectInformation->ObjectAttributes.SecurityDescriptor = NULL;
    }

    //
    // Write the type-specific attributes (if any) for the object).
    //

    if (TypeSpecificAttributeCount != 0) {

        Status = LsapDbWriteAttributesObject(
                     OutputHandle,
                     Attributes,
                     TypeSpecificAttributeCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto CreateObjectError;
        }
    }



CreateObjectReset:

    //
    // Apply the Registry Transaction to create the object.  Note
    // that we have to create the object before we can open its
    // registry key for placement within the handle.
    //

    Status = LsapDbResetStates(
                 OutputHandle,
                 Options | EndTransOptions | LSAP_DB_FINISH_TRANSACTION,
                 ObjectTypeId,
                 SecurityDbNew,
                 Status
                 );

    OpenedTransaction = FALSE;

    if (!NT_SUCCESS(Status)) {

        goto CreateObjectError;
    }

    //
    // Increment the count of objects created.  It should not have
    // changed since we're still holding the LSA Database lock.
    // NOTE: Count is decremented on error inside LsapDbDeleteObject()
    //

    LsapDbIncrementCountObject(ObjectInformation->ObjectTypeId);

    CreatedObject = TRUE;

    if ( !LsapDsIsWriteDs( OutputHandle ) ) {

        //
        // The object has now been created.  We need to obtain its Registry
        // Key handle so that we can save it in the Object Handle.
        // Setup Object Attributes structure for opening the Registry key of
        // the object.  Specify as path the Physical Name of the object, this
        // being the path of the object's Registry Key relative to the
        // LSA Database root key.
        //

        InitializeObjectAttributes(
            &OpenKeyObjectAttributes,
            &InternalOutputHandle->PhysicalNameU,
            OBJ_CASE_INSENSITIVE,
            LsapDbState.DbRootRegKeyHandle,
            NULL
            );

        //
        // Now attempt to open the object's Registry Key.  Store the Registry
        // Key handle in the object's handle.
        //

        Status = RtlpNtOpenKey(
                     (PHANDLE) &InternalOutputHandle->KeyHandle,
                     KEY_READ | KEY_WRITE,
                     &OpenKeyObjectAttributes,
                     0L
                     );

        if (!NT_SUCCESS(Status)) {

            InternalOutputHandle->KeyHandle = NULL;
            goto CreateObjectError;
        }

    }

    //
    // Add the new object to the in-memory cache (if any).  This is done
    // after all other actions, so that no removal from the cache is required
    // on the error paths.  If the object cannot be added to the cache, the
    // cache routine automatically disables the cache.
    //

    if ( ObjectTypeId == AccountObject &&
         LsapDbIsCacheSupported( AccountObject ) &&
         LsapDbIsCacheValid( AccountObject )) {

        IgnoreStatus = LsapDbCreateAccount(
                           InternalOutputHandle->Sid,
                           NULL
                           );
    }

CreateObjectFinish:

    //
    // Return NULL or a handle to the newly created and opened object.
    //

    *ObjectHandle = OutputHandle;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbCreateObject: 0x%lx\n", Status ));

    return(Status);

CreateObjectError:

    //
    // Cleanup after error.  Various variables are set non-null if
    // there is cleanup work to do.
    //

    //
    // If necessary, abort the Registry Transaction to create the object
    //

    if (OpenedTransaction) {

        SecondaryStatus = LsapDbResetStates(
                            OutputHandle,
                            EndTransOptions | LSAP_DB_FINISH_TRANSACTION,
                            ObjectTypeId,
                            (SECURITY_DB_DELTA_TYPE) 0,
                            Status
                            );
        LsapDbSetStatusFromSecondary( Status, SecondaryStatus );
    }

    //
    // If we opened the object, close it.
    //

    if (OpenedObject) {

        CloseOptions = 0;
        SecondaryStatus = LsapDbCloseObject( &OutputHandle, CloseOptions, Status );

        if ( Status != SecondaryStatus && !NT_SUCCESS(SecondaryStatus)) {

            LsapLogError(
                "LsapDbCreateObject: LsapDbCloseObject failed 0x%lx\n",
                SecondaryStatus
                );
        }

        OutputHandle = NULL;
        InternalOutputHandle = (LSAP_DB_HANDLE) OutputHandle;

    } else if (CreatedObject) {

        //
        // If we created the object, convert its handle into a trusted
        // handle and delete it.
        //

        InternalOutputHandle->Trusted = TRUE;

        SecondaryStatus = LsarDelete( OutputHandle );

        if (!NT_SUCCESS(SecondaryStatus)) {

            LsapLogError(
                "LsapDbCreateObject: LsarDeleteObject failed 0x%lx\n",
                SecondaryStatus
                );
        }

    } else if (OutputHandle != NULL) {

        //
        // If we just created the handle, free it.
        //

        LsapDbDereferenceHandle( OutputHandle );

        OutputHandle = NULL;
        InternalOutputHandle = (LSAP_DB_HANDLE) OutputHandle;
    }

    goto CreateObjectFinish;

    DBG_UNREFERENCED_PARAMETER( CloseOptions );
}

GUID LsapDsTrustedDomainNamePropSet =  {0x4886566c,0xaf31,0x11d2,0xb7,0xdf,0x00,0x80,0x5f,0x48,0xca,0xeb};
GUID LsapDsTrustedDomainAuthPropSet =  {0x736e4812,0xaf31,0x11d2,0xb7,0xdf,0x00,0x80,0x5f,0x48,0xca,0xeb};
GUID LsapDsTrustedDomainPosixPropSet = {0x9567ca92,0xaf31,0x11d2,0xb7,0xdf,0x00,0x80,0x5f,0x48,0xca,0xeb};

static LSAP_DS_OBJECT_ACCESS_MAP TrustedDomainAccessMap[] = {

        { TRUSTED_QUERY_DOMAIN_NAME, ACTRL_DS_READ_PROP,  ACCESS_PROPERTY_SET_GUID, &LsapDsTrustedDomainNamePropSet },
        { TRUSTED_SET_AUTH,          ACTRL_DS_WRITE_PROP, ACCESS_PROPERTY_SET_GUID, &LsapDsTrustedDomainAuthPropSet },
        { TRUSTED_QUERY_AUTH,        ACTRL_DS_READ_PROP,  ACCESS_PROPERTY_SET_GUID, &LsapDsTrustedDomainAuthPropSet },
        { TRUSTED_QUERY_POSIX,       ACTRL_DS_READ_PROP,  ACCESS_PROPERTY_SET_GUID, &LsapDsTrustedDomainPosixPropSet },
        { TRUSTED_SET_POSIX,         ACTRL_DS_WRITE_PROP, ACCESS_PROPERTY_SET_GUID, &LsapDsTrustedDomainPosixPropSet }
    };

#define TrustedDomainAccessMapSize ((sizeof(TrustedDomainAccessMap))/(sizeof(TrustedDomainAccessMap[0])))

static LSAP_DS_OBJECT_ACCESS_MAP TrustedDomainAsSecretAccessMap[] = {
    { SECRET_QUERY_VALUE,  ACTRL_DS_READ_PROP, ACCESS_PROPERTY_SET_GUID, &LsapDsTrustedDomainAuthPropSet },
    { SECRET_SET_VALUE,    ACTRL_DS_READ_PROP, ACCESS_PROPERTY_SET_GUID, &LsapDsTrustedDomainAuthPropSet }
};

#define TrustedDomainAsSecretAccessMapSize ((sizeof(TrustedDomainAsSecretAccessMap))/(sizeof(TrustedDomainAsSecretAccessMap[0])))

OBJECT_TYPE_LIST TrustedDomainTypeList[] = {
        { ACCESS_OBJECT_GUID, 0, &LsapDsGuidList[ LsapDsGuidTrust ] },

            { ACCESS_PROPERTY_SET_GUID,0,&LsapDsTrustedDomainNamePropSet},
                { ACCESS_PROPERTY_GUID, 0,&LsapDsGuidList[ LsapDsGuidFlatName ] },
                { ACCESS_PROPERTY_GUID, 0,&LsapDsGuidList[ LsapDsGuidSid ] },
                { ACCESS_PROPERTY_GUID, 0,&LsapDsGuidList[ LsapDsGuidAttributes ] },
                { ACCESS_PROPERTY_GUID, 0,&LsapDsGuidList[ LsapDsGuidDirection ] },
                { ACCESS_PROPERTY_GUID, 0,&LsapDsGuidList[ LsapDsGuidPartner] },
                { ACCESS_PROPERTY_GUID, 0,&LsapDsGuidList[ LsapDsGuidType ] },

            { ACCESS_PROPERTY_SET_GUID, 0, &LsapDsTrustedDomainAuthPropSet},
                { ACCESS_PROPERTY_GUID, 0,&LsapDsGuidList[ LsapDsGuidInitialIncoming ] },
                { ACCESS_PROPERTY_GUID, 0,&LsapDsGuidList[ LsapDsGuidInitialOutgoing ] },
                { ACCESS_PROPERTY_GUID, 0,&LsapDsGuidList[ LsapDsGuidIncoming ] },
                { ACCESS_PROPERTY_GUID, 0,&LsapDsGuidList[ LsapDsGuidOutgoing ] },

            { ACCESS_PROPERTY_SET_GUID, 0,&LsapDsTrustedDomainPosixPropSet},
                { ACCESS_PROPERTY_GUID, 0,&LsapDsGuidList[ LsapDsGuidPosix ] },

        };

#define TDTYPE_LIST_SIZE ((sizeof( TrustedDomainTypeList ))/(sizeof( OBJECT_TYPE_LIST )))

GUID LsapDsSecretPropSet    = {0x9fa81d6c,0xaf69,0x11d2,0xb7,0xdf,0x00,0x80,0x5f,0x48,0xca,0xeb};

static LSAP_DS_OBJECT_ACCESS_MAP GlobalSecretAccessMap[] = {
            { SECRET_QUERY_VALUE, ACTRL_DS_READ_PROP, ACCESS_PROPERTY_SET_GUID, &LsapDsSecretPropSet },
            { SECRET_SET_VALUE,   ACTRL_DS_WRITE_PROP, ACCESS_PROPERTY_SET_GUID, &LsapDsSecretPropSet }
        };

#define  GlobalSecretAccessMapSize ( (sizeof(GlobalSecretAccessMap))/(sizeof(GlobalSecretAccessMap[0])))


OBJECT_TYPE_LIST GlobalSecretTypeList[] = {

        { ACCESS_OBJECT_GUID, 0, &LsapDsGuidList[ LsapDsGuidSecret ] },
        { ACCESS_PROPERTY_SET_GUID, 0, &LsapDsSecretPropSet },
        { ACCESS_PROPERTY_SET_GUID, 0, &LsapDsGuidList[LsapDsGuidCurrent] },
        { ACCESS_PROPERTY_SET_GUID, 0, &LsapDsGuidList[LsapDsGuidCurrentTime] },
        { ACCESS_PROPERTY_SET_GUID, 0, &LsapDsGuidList[LsapDsGuidPrevious] },
        { ACCESS_PROPERTY_SET_GUID, 0, &LsapDsGuidList[LsapDsguidPreviousTime] }
        };

#define SECRETTYPE_LIST_SIZE ( sizeof( GlobalSecretTypeList ) / sizeof( OBJECT_TYPE_LIST ) )

// generic read
#define LSAP_DS_GENERIC_READ_MAPPING     ((STANDARD_RIGHTS_READ)     | \
                                          (ACTRL_DS_LIST)   | \
                                          (ACTRL_DS_READ_PROP)   | \
                                          (ACTRL_DS_LIST_OBJECT))

// generic execute
#define LSAP_DS_GENERIC_EXECUTE_MAPPING  ((STANDARD_RIGHTS_EXECUTE)  | \
                                  (ACTRL_DS_LIST_OBJECT))
// generic right
#define LSAP_DS_GENERIC_WRITE_MAPPING    ((STANDARD_RIGHTS_WRITE)    | \
                                  (ACTRL_DS_SELF)  | \
                                  (ACTRL_DS_WRITE_PROP))
// generic all

#define LSAP_DS_GENERIC_ALL_MAPPING      ((STANDARD_RIGHTS_REQUIRED) | \
                                  (ACTRL_DS_CREATE_CHILD)    | \
                                  (ACTRL_DS_DELETE_CHILD)    | \
                                  (ACTRL_DS_DELETE_TREE)     | \
                                  (ACTRL_DS_READ_PROP)       | \
                                  (ACTRL_DS_WRITE_PROP)      | \
                                  (ACTRL_DS_LIST)            | \
                                  (ACTRL_DS_LIST_OBJECT)     | \
                                  (ACTRL_DS_CONTROL_ACCESS)  | \
                                  (ACTRL_DS_SELF))

//
// Standard DS generic access rights mapping
//

#define LSAP_DS_GENERIC_MAPPING { \
                LSAP_DS_GENERIC_READ_MAPPING,    \
                LSAP_DS_GENERIC_WRITE_MAPPING,   \
                LSAP_DS_GENERIC_EXECUTE_MAPPING, \
                LSAP_DS_GENERIC_ALL_MAPPING}


NTSTATUS
LsapDbRequestAccessObject(
    IN OUT LSAPR_HANDLE ObjectHandle,
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Options
    )

/*++

Routine Description:

    This function performs an access check for an LSA Database object.  While
    impersonating an RPC client, the specified Desired Accesses are reconciled
    with the Discretionary Access Control List (DACL) in the object's
    Security Descriptor.  Note that the object's Security Descriptor is
    passed explicitly so that this routine can be called for new objects
    for which a SD has been constructed but not yet written to the
    Registry.

Arguments:

    ObjectHandle - Handle to object.  The handle will receive the
        granted accesses if the call is successful.

    ObjectInformation - Pointer to object's information.  As a minimum, the
        object's Security Descriptor must be set up.

    DesiredAccess - Specifies a mask of the access types desired to the
        object.

    Options - Specifies optional actions to be taken


Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Not all of the Desired Accessed can be
            granted to the caller.

        STATUS_BACKUP_CONTROLLER - A create, update or delete operation
            is not allowed for a non-trusted client for this object on a BDC,
            because the object is global to all DC's for a domain and is replicated.

        Errors from RPC client impersonation
--*/

{
    NTSTATUS Status = STATUS_SUCCESS, RevertStatus = STATUS_SUCCESS, AccessStatus = STATUS_SUCCESS;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) ObjectHandle;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId = InternalHandle->ObjectTypeId;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeIdForGenericMapping;
    ULONG EffectiveOptions = Options | InternalHandle->Options;
    GENERIC_MAPPING LsapDsGenericMap = LSAP_DS_GENERIC_MAPPING;

#ifdef LSAP_TRACK_HANDLE
    HANDLE ClientToken = NULL;
#endif

    ULONG i;

    ULONG TrustedDomainTypeCount = 0;

    ULONG GlobalSecretTypeCount = sizeof( GlobalSecretTypeList ) / sizeof( OBJECT_TYPE_LIST );
    ULONG GrantedAccess = 0;
    POBJECT_TYPE_LIST TypeListToCheck = NULL;
    LSAP_DS_OBJECT_ACCESS_MAP * MappingTableToUse = NULL;
    ULONG TypeListToCheckCount = 0;
    ULONG MappingTableSize=0;
    ULONG AccessStatusArray[ TDTYPE_LIST_SIZE ];
    ULONG GrantedAccessArray[ TDTYPE_LIST_SIZE ];
    BOOLEAN fAtLeastOneAccessGranted = FALSE;
    BOOLEAN fNoAccessRequested = FALSE;

    //
    // AccessStatusArray and GrantedAccessArray are set to the larger of the
    // two counts: TDTYPE_LIST_SIZE and SECRETTYPE_LIST_SIZE
    //

    ASSERT( TDTYPE_LIST_SIZE > SECRETTYPE_LIST_SIZE );

    // This routine should not be called on trusted clients
    ASSERT( !InternalHandle->Trusted );


    //
    // Get the correct object type id for generic mapping
    //

    if ( FLAG_ON( InternalHandle->Options, LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET ) )
    {
        ObjectTypeIdForGenericMapping = SecretObject;
    }
    else
    {
        ObjectTypeIdForGenericMapping = ObjectTypeId;
    }

    //
    // Map any Generic Access Types to Specific Access Types
    //

    RtlMapGenericMask(
        &DesiredAccess,
        &(LsapDbState.DbObjectTypes[ObjectTypeIdForGenericMapping].GenericMapping)
        );


    //
    // Common path for Object Open and Creation.  We need to reconcile
    // the desired accesses to the object with the Discretionary Access
    // Control List contained in the Security Descriptor.  Note that this
    // needs to be done even for newly created objects, since they are
    // being opened as well as created.

    //
    // Impersonate the client thread prior to doing an access check.
    //

    if ( Options & LSAP_DB_USE_LPC_IMPERSONATE ) {
        Status = LsapImpersonateClient( );
    } else {
        Status = I_RpcMapWin32Status(RpcImpersonateClient(0));
    }

    if (!NT_SUCCESS(Status)) {
        return Status;
    }



    //
    // Reconcile the desired access with the discretionary ACL
    // of the Resultant Descriptor.  Note that this operation is performed
    // even if we are just creating the object since the object is to
    // be opened.


    switch ( InternalHandle->ObjectTypeId ) {
    case TrustedDomainObject:


        if ( !LsaDsStateInfo.UseDs ) {

            break;
        }

        if ( FLAG_ON( InternalHandle->Options, LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET ) )
        {
             MappingTableToUse = TrustedDomainAsSecretAccessMap;
             MappingTableSize = TrustedDomainAsSecretAccessMapSize;
        }
        else
        {
             MappingTableToUse = TrustedDomainAccessMap;
             MappingTableSize = TrustedDomainAccessMapSize;
        }



        TypeListToCheck = TrustedDomainTypeList;
        TypeListToCheckCount = TDTYPE_LIST_SIZE ;

        break;



    case SecretObject:

        //
        // If we are running on a client, don't specify a property list, or it'll fail
        //

        if ( !LsaDsStateInfo.UseDs ) {

            break;
        }

        if ( FLAG_ON( InternalHandle->Options, LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET ) ) {

            TypeListToCheck = TrustedDomainTypeList;
            TypeListToCheckCount = TDTYPE_LIST_SIZE;
            MappingTableToUse = TrustedDomainAsSecretAccessMap;
            MappingTableSize = TrustedDomainAsSecretAccessMapSize;

        } else if ( FLAG_ON( InternalHandle->Options, LSAP_DB_OBJECT_SCOPE_DS ) ) {

            TypeListToCheck = GlobalSecretTypeList;
            TypeListToCheckCount = SECRETTYPE_LIST_SIZE;
            MappingTableToUse = GlobalSecretAccessMap;
            MappingTableSize = GlobalSecretAccessMapSize;
        }

        break;

    default:
        break;
    }


    if (NULL!=MappingTableToUse)
    {
        Status = NtAccessCheckByTypeResultListAndAuditAlarm(
                        &LsapState.SubsystemName,
                        ObjectHandle,
                        &LsapDbObjectTypeNames[ObjectTypeId],
                        ( PUNICODE_STRING )ObjectInformation->ObjectAttributes.ObjectName,
                        ObjectInformation->ObjectAttributes.SecurityDescriptor,
                        NULL,  // Principal Self sid
                        MAXIMUM_ALLOWED |
                           ((DesiredAccess & ACCESS_SYSTEM_SECURITY )?
                            ACCESS_SYSTEM_SECURITY:0),
                        AuditEventObjectAccess,
                        0, // FLAGS
                        TypeListToCheck,
                        TypeListToCheckCount,
                        &LsapDsGenericMap,
                        FALSE,
                        GrantedAccessArray,
                        AccessStatusArray,
                        ( PBOOLEAN )&( InternalHandle->GenerateOnClose ) );
    }
    else
    {

        //
        // Because of bug 411289, the NtAccessCheck* API's don't return
        // ACCESS_DENIED when presented with 0 access.  Because clients
        // may already expect this behavoir, only return ACCESS_DENIED
        // when the client really doesn't have any access. We want to
        // return ACCESS_DENIED to prevent anonymous clients from acquiring
        // handles.
        //
        if ( DesiredAccess == 0 ) {
            fNoAccessRequested = TRUE;
            DesiredAccess = MAXIMUM_ALLOWED;
        }

        Status = NtAccessCheckByTypeAndAuditAlarm(
                        &LsapState.SubsystemName,
                        ObjectHandle,
                        &LsapDbObjectTypeNames[ObjectTypeId],
                        ( PUNICODE_STRING )ObjectInformation->ObjectAttributes.ObjectName,
                        ObjectInformation->ObjectAttributes.SecurityDescriptor,
                        NULL,  // Principal Self sid
                        DesiredAccess,
                        AuditEventObjectAccess,
                        0, // FLAGS
                        TypeListToCheck,
                        TypeListToCheckCount,
                        &( LsapDbState.DbObjectTypes[ ObjectTypeId ].GenericMapping ),
                        FALSE,
                        ( PACCESS_MASK )&GrantedAccess ,
                        ( PNTSTATUS )&AccessStatus,
                        ( PBOOLEAN )&( InternalHandle->GenerateOnClose ) );


        if ( fNoAccessRequested ) {

            DesiredAccess = 0;

            if ( NT_SUCCESS( Status )
             &&  NT_SUCCESS( AccessStatus ) ) {
                GrantedAccess = 0;
            }
        }

        //
        // If this is a failed LsaOpenPolicy,
        //  try some hacks to get the call to succeed.
        //

        if ( NT_SUCCESS( Status) &&
             AccessStatus == STATUS_ACCESS_DENIED &&
             InternalHandle->ObjectTypeId == PolicyObject ) {

            //
            // Don't fail the LsaOpenPolicy just because POLICY_TRUST_ADMIN access is requested
            //
            // NT 4.0 and older required that the caller ask for POLICY_TRUST_ADMIN to manipulate TDOs.
            // That's no longer required, but some applications still ask for it. So, don't fail
            // the LsaOpenPolicy if the access isn't granted.  Rather, let the individual call fail
            // when it checks to see if the access was granted on the handle.
            //
            // TDOs access is now controlled by the security descriptor on the TDO.  That allows
            // delegation of TDO manipulation.
            //
            if ( (DesiredAccess & POLICY_TRUST_ADMIN) != 0 ) {

                //
                // Do the access check again not asking for POLICY_TRUST_ADMIN this time.
                //

                DesiredAccess &= ~((ULONG) POLICY_TRUST_ADMIN);

                Status = NtAccessCheckByTypeAndAuditAlarm(
                                &LsapState.SubsystemName,
                                ObjectHandle,
                                &LsapDbObjectTypeNames[ObjectTypeId],
                                ( PUNICODE_STRING )ObjectInformation->ObjectAttributes.ObjectName,
                                ObjectInformation->ObjectAttributes.SecurityDescriptor,
                                NULL,  // Principal Self sid
                                DesiredAccess,
                                AuditEventObjectAccess,
                                0, // FLAGS
                                TypeListToCheck,
                                TypeListToCheckCount,
                                &( LsapDbState.DbObjectTypes[ ObjectTypeId ].GenericMapping ),
                                FALSE,
                                ( PACCESS_MASK )&GrantedAccess ,
                                ( PNTSTATUS )&AccessStatus,
                                ( PBOOLEAN )&( InternalHandle->GenerateOnClose ) );

            }

            //
            // Don't fail the LsaOpenPolicy just because the anonymous user asked for
            //  READ_CONTROL.  Some apps ask for GENERIC_EXECUTE which contains READ_CONTROL
            //  even though the app really doesn't need it.
            //

            if ( NT_SUCCESS( Status) &&
                 AccessStatus == STATUS_ACCESS_DENIED &&
                 (DesiredAccess & READ_CONTROL) != 0 ) {

                NTSTATUS Status2 ;
                HANDLE ClientToken;
                BOOL IsAnonymous = FALSE;

                //
                // Determine if the caller is the anonymous user
                //


                Status2 = NtOpenThreadToken( NtCurrentThread(),
                                            TOKEN_QUERY,
                                            FALSE,
                                            &ClientToken );

                if ( NT_SUCCESS( Status2 ) ) {
                    UCHAR Buffer[ 128 ];
                    PTOKEN_USER User ;
                    ULONG Size ;

                    User = (PTOKEN_USER) Buffer ;

                    Status2 = NtQueryInformationToken(
                                    ClientToken,
                                    TokenUser,
                                    User,
                                    sizeof( Buffer ),
                                    &Size );

                    if ( NT_SUCCESS( Status2 ) ) {
                        if ( RtlEqualSid( User->User.Sid, LsapAnonymousSid ) ) {
                            IsAnonymous = TRUE;
                        }
                    }

                    NtClose( ClientToken );
                }

                //
                // Do the access check again not asking for READ_CONTROL this time.
                //

                if ( IsAnonymous ) {
                    DesiredAccess &= ~((ULONG) READ_CONTROL );

                    Status = NtAccessCheckByTypeAndAuditAlarm(
                                    &LsapState.SubsystemName,
                                    ObjectHandle,
                                    &LsapDbObjectTypeNames[ObjectTypeId],
                                    ( PUNICODE_STRING )ObjectInformation->ObjectAttributes.ObjectName,
                                    ObjectInformation->ObjectAttributes.SecurityDescriptor,
                                    NULL,  // Principal Self sid
                                    DesiredAccess,
                                    AuditEventObjectAccess,
                                    0, // FLAGS
                                    TypeListToCheck,
                                    TypeListToCheckCount,
                                    &( LsapDbState.DbObjectTypes[ ObjectTypeId ].GenericMapping ),
                                    FALSE,
                                    ( PACCESS_MASK )&GrantedAccess ,
                                    ( PNTSTATUS )&AccessStatus,
                                    ( PBOOLEAN )&( InternalHandle->GenerateOnClose ) );
                }

            }
        }

    }


    if ( NT_SUCCESS( Status ) ){
        ULONG i,j;


        switch ( InternalHandle->ObjectTypeId ) {
        case SecretObject:
        case TrustedDomainObject:

            //
            // If we are running on a client, or local secret No need to do any mapping
            //

            if (NULL==MappingTableToUse) {

                break;
            }

            //
            // Take standard rights from the object guid level in the type list
            //

            GrantedAccess = 0;
            if (NT_SUCCESS(AccessStatusArray[0]))
            {
                GrantedAccess |= (GrantedAccessArray[0]) & ((STANDARD_RIGHTS_ALL)|ACCESS_SYSTEM_SECURITY);
            }

            for (i=0;i<TypeListToCheckCount;i++)
            {
                if (NT_SUCCESS(AccessStatusArray[i]))
                {
                    fAtLeastOneAccessGranted = TRUE;

                    for (j=0;j<MappingTableSize;j++)
                    {
                        if ((0==memcmp(MappingTableToUse[j].ObjectGuid,TypeListToCheck[i].ObjectType,sizeof(GUID)))
                             && (GrantedAccessArray[i] & MappingTableToUse[j].DsAccessRequired))
                        {
                            //
                            // Or in the downlevel right granted by virtue of the granted DS right
                            // on the particular prop set guid
                            //

                            GrantedAccess |= MappingTableToUse[j].DesiredAccess;
                        }
                    }
                }
            }

            //
            // Grant in the unused trusted domain access bits
            //

            if (TrustedDomainObject == InternalHandle->ObjectTypeId)
            {
                GrantedAccess |=TRUSTED_QUERY_CONTROLLERS|TRUSTED_SET_CONTROLLERS;
            }

            if ( !fAtLeastOneAccessGranted )
            {
                // No access' granted
                GrantedAccess = 0;
                AccessStatus = STATUS_ACCESS_DENIED;
            }
            else if (DesiredAccess & MAXIMUM_ALLOWED)
            {
                //
                // Granted access already contains the maximum allowed access in lsa terms as
                // computed above
                //

                AccessStatus = STATUS_SUCCESS;

            }
            else if (RtlAreAllAccessesGranted(GrantedAccess,DesiredAccess))
            {
                GrantedAccess = DesiredAccess;
                AccessStatus = STATUS_SUCCESS;
            }
            else
            {
                //
                // One or more accesses that were requested was not granted
                //

                GrantedAccess = 0;
                AccessStatus = STATUS_ACCESS_DENIED;
            }

            break;


        default:

            break;
        }

         if (NT_SUCCESS(AccessStatus))
         {
             InternalHandle->GrantedAccess = GrantedAccess;
         }

    }


    //
    // Check to see whether this is a network request that is coming in or
    // not
    //
    if ( NT_SUCCESS( Status ) && NT_SUCCESS( AccessStatus ) &&
         InternalHandle->ObjectTypeId == SecretObject ) {

         Status = LsapDbIsImpersonatedClientNetworkClient( &InternalHandle->NetworkClient );
    }

#ifdef LSAP_TRACK_HANDLE
    //
    // If we haven't already done so, open the client token so we can copy it off below
    //
    if ( !InternalHandle->ClientToken ) {

        Status = NtOpenThreadToken( NtCurrentThread(),
                                    TOKEN_QUERY | TOKEN_DUPLICATE,
                                    TRUE,
                                    &ClientToken );
    }
#endif


    //
    // Before checking the Status, stop impersonating the client and become
    // our former self.
    //

    if ( Options & LSAP_DB_USE_LPC_IMPERSONATE ) {
        RevertToSelf();
        RevertStatus = STATUS_SUCCESS;
    } else {
        RevertStatus = I_RpcMapWin32Status(RpcRevertToSelf());

        if (!NT_SUCCESS(RevertStatus)) {

            LsapLogError(
                "LsapDbRequestAccessObject: RpcRevertToSelf failed 0x%lx\n",
                RevertStatus
                );
        }
    }

#ifdef LSAP_TRACK_HANDLE

    //
    // Copy off the client token
    //
    if ( ClientToken ) {

        OBJECT_ATTRIBUTES ObjAttrs;
        SECURITY_QUALITY_OF_SERVICE SecurityQofS;

        //
        // Duplicate the token
        //
        InitializeObjectAttributes( &ObjAttrs, NULL, 0L, NULL, NULL );
        SecurityQofS.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );
        SecurityQofS.ImpersonationLevel = SecurityImpersonation;
        SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
        SecurityQofS.EffectiveOnly = FALSE;
        ObjAttrs.SecurityQualityOfService = &SecurityQofS;

        Status = NtDuplicateToken( ClientToken,
                                   TOKEN_READ | TOKEN_WRITE | TOKEN_EXECUTE,
                                   &ObjAttrs,
                                   FALSE,
                                   TokenImpersonation,
                                   &InternalHandle->ClientToken );


        NtClose( ClientToken );
    }
#endif

    //
    // If the primary status code is a success status code, return the
    // secondary status code.  If this is alsoa success code, return the
    // revert to self status.
    //

    if (NT_SUCCESS(Status)) {

        Status = AccessStatus;

        if (NT_SUCCESS(Status)) {

            Status = RevertStatus;
        }
    }

    return Status;
}

NTSTATUS
LsapDbRequestAccessNewObject(
    IN OUT LSAPR_HANDLE ObjectHandle,
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Options
    )

/*++

Routine Description:

    This function verifies that a desired set of accesses can be granted
    to the handle that is opened when a new object is created.

    It is important to note that the rules for granting accesses to the
    handle that is open upon object creation are different from the rules
    for granting accesses upon the opening of an existing object.  For a new
    object, the associated handle will be granted any subset of GENERIC_ALL
    access desired and, if the creator has SE_SECURITY_PRIVILEGE, the handle
    will be granted ACCESS_SYSTEM_SECURITY access if requested.  If the
    creator requests MAXIMUM_ALLOWED, the handle will be granted GENERIC_ALL.

Arguments:

    ObjectHandle - Handle to object.  The handle will receive the
        granted accesses if the call is successful.

    ObjectInformation - Pointer to object's information.  As a minimum, the
        object's Security Descriptor must be set up.

    DesiredAccess - Specifies a mask of the access types desired to the
        object.

    Options - Specifies optional actions to be taken

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Not all of the Desired Accessed can be
            granted to the caller.

        STATUS_BACKUP_CONTROLLER - A create, update or delete operation
            is not allowed for a non-trusted client for this object on a BDC,
            because the object is global to all DC's for a domain and is replicated.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ACCESS_MASK EffectiveDesiredAccess = DesiredAccess;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) ObjectHandle;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId = InternalHandle->ObjectTypeId;
    ULONG EffectiveOptions = Options | InternalHandle->Options;

#ifndef LSADS_MAP_SD
    if ( LsapDsIsWriteDs( ObjectHandle ) ) {

        LsapDsDebugOut(( DEB_TRACE, "Shortcurcuit Ds access check\n" ));
        InternalHandle->GrantedAccess = 0xFFFFFFFF;
        return( STATUS_SUCCESS );
    }
#endif




    //
    // If MAXIMUM_ALLOWED is requested, add GENERIC_ALL
    //

    if (EffectiveDesiredAccess & MAXIMUM_ALLOWED) {

        EffectiveDesiredAccess |= GENERIC_ALL;
    }

    //
    // If ACCESS_SYSTEM_SECURITY is requested and we are a non-trusted
    // client, check that we have SE_SECURITY_PRIVILEGE.
    //

    if ((EffectiveDesiredAccess & ACCESS_SYSTEM_SECURITY) &&
        (!InternalHandle->Trusted)) {

        Status = LsapRtlWellKnownPrivilegeCheck(
                     (PVOID)ObjectHandle,
                     TRUE,
                     SE_SECURITY_PRIVILEGE,
                     NULL
                     );

        if (!NT_SUCCESS(Status)) {

            goto RequestAccessNewObjectError;
        }
    }

    //
    // Make sure the caller can be given the requested access
    // to the new object
    //

    InternalHandle->GrantedAccess = EffectiveDesiredAccess;

    RtlMapGenericMask(
        &InternalHandle->GrantedAccess,
        &LsapDbState.DbObjectTypes[ObjectTypeId].GenericMapping
        );

    if ((LsapDbState.DbObjectTypes[ObjectTypeId].InvalidMappedAccess
        &InternalHandle->GrantedAccess) != 0) {

        Status = STATUS_ACCESS_DENIED;
        goto RequestAccessNewObjectError;
    }

RequestAccessNewObjectFinish:

    return(Status);

RequestAccessNewObjectError:

    goto RequestAccessNewObjectFinish;
}


NTSTATUS
LsapDbCloseObject   (
    IN PLSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN NTSTATUS PreliminaryStatus
    )

/*++

Routine Description:

    This function closes (dereferences) a handle to an Lsa Database object.
    If the reference count of the handle reduces to 0, the handle is freed.

Arguments:

    ObjectHandle - Pointer to handle to object from LsapDbOpenObject or
        LsapDbCreateObject.

    Options - Optional actions to be performed

        LSAP_DB_VALIDATE_HANDLE - Verify that the handle is valid.

        LSAP_DB_DEREFERENCE_CONTR - Dereference the Container Handle.  Note
            that the Container Handle was referenced when the subordinate
            handle was created.

        LSAP_DB_ADMIT_DELETED_OBJECT_HANDLES - Permit the handle provided
            to be for a deleted object.

    PreliminaryStatus - Used to decide whether to abort or commit the transaction

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status;

    //
    // Dereference the object handle and free the handle if the reference count
    // reaches zero.  Optionally, the handle will be verified and/or freed
    // and the container object handle dereferenced.
    //

    Status = LsapDbDereferenceObject(
                 ObjectHandle,
                 NullObject,
                 NullObject,
                 Options,
                 (SECURITY_DB_DELTA_TYPE) 0,
                 PreliminaryStatus
                 );

    *ObjectHandle = NULL;

    return(Status);
}


NTSTATUS
LsapDbDeleteObject(
    IN LSAPR_HANDLE ObjectHandle
    )

/*++

Routine Description:

    This function deletes an object from the Lsa Database.

Arguments:

    ObjectHandle - Handle to open object to be deleted.

Return Value:

    NTSTATUS - Standard NT Result Code.

        STATUS_INVALID_HANDLE - Handle is not a valid handle to an open
            object.

        STATUS_ACCESS_DENIED - Handle does not specify DELETE access.
--*/

{
    NTSTATUS Status;
    LSAP_DB_HANDLE Handle = (LSAP_DB_HANDLE) ObjectHandle;
    PUNICODE_STRING AttributeNames[LSAP_DB_MAX_ATTRIBUTES];
    BOOLEAN DeleteSecurely[LSAP_DB_MAX_ATTRIBUTES] = {0};
    PUNICODE_STRING *NextAttributeName;
    LSAP_DB_ATTRIBUTE Attributes[ 2 ];
    ULONG AttributeCount;
    ULONG AttributeNumber;
    LSAPR_TRUST_INFORMATION TrustInformation;


    //
    // All object types have a Security Descriptor stored as the SecDesc
    // attribute.
    //

    NextAttributeName = AttributeNames;
    AttributeCount = 0;
    *NextAttributeName = &LsapDbNames[SecDesc];

    NextAttributeName++;
    AttributeCount++;

    Status = STATUS_SUCCESS;

    //
    // Check the other references to the object and mark all other handles
    // invalid.
    //

    Status = LsapDbMarkDeletedObjectHandles( ObjectHandle, FALSE );

    if (!NT_SUCCESS(Status)) {

        goto DeleteObjectError;
    }

    //
    // Switch on object type
    //

    switch (Handle->ObjectTypeId) {

        case PolicyObject:

            Status = STATUS_INVALID_PARAMETER;
            break;

        case TrustedDomainObject:

            //
            // Deal with the TrustedDomainAsSecret problem
            if (FLAG_ON( Handle->Options, LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET ) ) {

                LsapDbInitializeAttributeDs( &Attributes[ 0 ],
                                             TrDmSAI,
                                             NULL,
                                             0,
                                             FALSE );

                LsapDbInitializeAttributeDs( &Attributes[ 1 ],
                                             TrDmSAO,
                                             NULL,
                                             0,
                                             FALSE );

            } else {

                *NextAttributeName = &LsapDbNames[TrDmName];
                NextAttributeName++;
                AttributeCount++;

                *NextAttributeName = &LsapDbNames[Sid];
                NextAttributeName++;
                AttributeCount++;

                *NextAttributeName = &LsapDbNames[TrDmAcN];
                NextAttributeName++;
                AttributeCount++;

                *NextAttributeName = &LsapDbNames[TrDmCtN];
                NextAttributeName++;
                AttributeCount++;

                *NextAttributeName = &LsapDbNames[TrDmPxOf];
                NextAttributeName++;
                AttributeCount++;

                *NextAttributeName = &LsapDbNames[TrDmCtEn];
                NextAttributeName++;
                AttributeCount++;

                //
                // Delete the object from the list of Trusted Domains
                //

                TrustInformation.Sid = Handle->Sid;
                TrustInformation.Name = *((PLSAPR_UNICODE_STRING) &Handle->LogicalNameU);

                Status = LsapDbAcquireWriteLockTrustedDomainList();

                if ( NT_SUCCESS( Status )) {

                    Status = LsapDbDeleteTrustedDomainList( &TrustInformation );

                    LsapDbReleaseLockTrustedDomainList();
                }

                //
                // Then, delete the sam account corresponding to this trust, if it existed
                //
                Status = LsapDsDeleteInterdomainTrustAccount( ObjectHandle );


            }

            break;

        case AccountObject:

            *NextAttributeName = &LsapDbNames[Sid];
            NextAttributeName++;
            AttributeCount++;

            *NextAttributeName = &LsapDbNames[ActSysAc];
            NextAttributeName++;
            AttributeCount++;

            *NextAttributeName = &LsapDbNames[Privilgs];
            NextAttributeName++;
            AttributeCount++;

            *NextAttributeName = &LsapDbNames[QuotaLim];
            NextAttributeName++;
            AttributeCount++;

            break;

        case SecretObject:

            DeleteSecurely[AttributeCount] = TRUE;
            *NextAttributeName = &LsapDbNames[CurrVal];
            NextAttributeName++;
            AttributeCount++;

            DeleteSecurely[AttributeCount] = TRUE;
            *NextAttributeName = &LsapDbNames[OldVal];
            NextAttributeName++;
            AttributeCount++;

            *NextAttributeName = &LsapDbNames[CupdTime];
            NextAttributeName++;
            AttributeCount++;

            *NextAttributeName = &LsapDbNames[OupdTime];
            NextAttributeName++;
            AttributeCount++;
            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
            break;
    }


    if (!NT_SUCCESS(Status)) {

        goto DeleteObjectError;
    }

    //
    // Add Registry Transactions to delete each of the object's attributes.
    //
    for(AttributeNumber = 0;
        AttributeNumber < AttributeCount && !LsapDsIsHandleDsHandle( ObjectHandle);
        AttributeNumber++) {

        Status = LsapDbDeleteAttributeObject(
                     ObjectHandle,
                     AttributeNames[AttributeNumber],
                     DeleteSecurely[AttributeNumber]
                     );

        //
        // Ignore "attribute not found" errors.  The object need not
        // have all attributes set, or may be only partially created.
        //

        if (!NT_SUCCESS(Status)) {

            if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

                break;
            }

            Status = STATUS_SUCCESS;
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto DeleteObjectError;
    }

    //
    // Close the handle to the Registry Key representing the object.
    // The Registry transaction package will open another handle with
    // DELETE access to perform the deletion.
    //
    if ( !LsapDsIsHandleDsHandle( ObjectHandle) &&
         Handle->KeyHandle != NULL ) {

        Status = NtClose(Handle->KeyHandle);

        Handle->KeyHandle = NULL;

        if (!NT_SUCCESS(Status)) {

            goto DeleteObjectError;
        }
    }

    //
    // Add a Registry Transaction to delete the object's Registry Key.
    //

    if ( !LsapDsIsHandleDsHandle( ObjectHandle) ) {

        Status = LsapRegDeleteObject( &Handle->PhysicalNameU );

    } else {

        //
        // Deal with the special case of TrustedDomainObject as Secret
        //
        if ( FLAG_ON( Handle->Options, LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET ) &&
             Handle->ObjectTypeId == TrustedDomainObject) {

            Status = LsapDsDeleteAttributes( &Handle->PhysicalNameDs,
                                             Attributes,
                                             2 );
        } else {

            Status = LsapDsDeleteObject( &Handle->PhysicalNameDs );
        }

    }

    if (!NT_SUCCESS(Status)) {

        goto DeleteObjectError;
    }

    //
    // If the machine account is being deleted, make sure to do notification on it
    //
    if ( Handle->ObjectTypeId == SecretObject && LsapDbSecretIsMachineAcc( Handle ) ) {

        LsaINotifyChangeNotification( PolicyNotifyMachineAccountPasswordInformation );
    }

DeleteObjectFinish:

    //
    // Decrement the count of objects of the given type.
    //

    LsapDbDecrementCountObject(
        ((LSAP_DB_HANDLE) ObjectHandle)->ObjectTypeId
        );

    return (Status);

DeleteObjectError:

    goto DeleteObjectFinish;
}


NTSTATUS
LsapDbReferenceObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN ACCESS_MASK DesiredAccess,
    IN LSAP_DB_OBJECT_TYPE_ID HandleTypeId,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN ULONG Options
    )

/*++

Routine Description:

    This function verifies that a passed handle is valid, is for an
    object of the specified type and has the specified accesses granted.
    The handle's reference count is then incremented.  If Lsa Database
    locking is not requested, the Lsa Database must aready be locked.
    If Lsa Database locking is requested, the Lsa Database must NOT be
    locked.

Arguments:

    ObjectHandle - Pointer to handle to be validated and referenced.

    DesiredAccess - Specifies the accesses that are desired.  The function
        returns an error if any of the specified accesses have not been
        granted.

    HandleTypeId - Specifies the expected object type to which the handle
        relates.  An error is returned if this type does not match the
        type contained in the handle.

    ObjectTypeId - Specifies the expected object type to which the object that is to
        be operated upon relates

    Options - Specifies optional additional actions including database state
        changes to be made, or actions not to be performed.

        LSAP_DB_LOCK - Acquire the Lsa database lock.  If this
            flag is specified, the Lsa Database must NOT already be locked.
            If this flag is not specified, the Lsa Database must already
            be locked.

        LSAP_DB_LOG_QUEUE_LOCK - Acquire the Lsa Audit Log Queue
            Lock.

        LSAP_DB_START_TRANSACTION - Start an Lsa database transaction.

        NOTE: There may be some Options (not database states) provided in the
              ObjectHandle.  These options augment those provided.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - The handle could not be found.

        STATUS_ACCESS_DENIED - Not all of the accesses specified have
            been granted.

        STATUS_OBJECT_TYPE_MISMATCH - The specified object type id does not
            match the object type id contained in the handle.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources to
            complete the command.  An example is too many references to
            the handle causing the count to overflow.

        STATUS_BACKUP_CONTROLLER - A request to open a transaction has been
            made by a non-trusted caller and the system is a Backup Domain
            Controller.  The LSA Database of a Backup Domain Controller
            can only be updated by a trusted client, such as a replicator.

        Result Codes from database transaction package.
--*/

{
    NTSTATUS Status;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) ObjectHandle;
    BOOLEAN GlobalSecret = FALSE;
    ULONG States, EffectiveOptions;
    ULONG ResetStates = 0;
    BOOLEAN HandleReferenced = FALSE;
    BOOLEAN StatesSet = FALSE;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbReferenceObject\n" ));

    //
    // Search the list of handles for the given handle, validate the
    // handle and verify that is for an object of the expected type.
    // Augment the options passed in with those contained in the handle.
    //
    // Reference the handle.
    //

    Status =  LsapDbVerifyHandle( ObjectHandle, 0, HandleTypeId, TRUE );

    if (!NT_SUCCESS(Status)) {
        ObjectHandle = NULL;
        goto ReferenceError;
    }

    HandleReferenced = TRUE;


    States = Options & LSAP_DB_STATE_MASK;

    //
    // Set the requested states before doing anything else.  This ensures
    // that the validity checks performed by this function are performed
    // while the Lsa database is locked.
    //
    ResetStates |= ( States & ( LSAP_DB_READ_ONLY_TRANSACTION |
                                LSAP_DB_DS_OP_TRANSACTION ) );

    if (States != 0) {

        Status = LsapDbSetStates( States,
                                  ObjectHandle,
                                  ObjectTypeId );

        if (!NT_SUCCESS(Status)) {


            goto ReferenceError;
        }

        StatesSet = TRUE;

        if (States & LSAP_DB_START_TRANSACTION) {

            ResetStates |= LSAP_DB_FINISH_TRANSACTION;
        }

        if (States & LSAP_DB_LOCK) {

            ResetStates |= LSAP_DB_LOCK;
        }

        if (States & LSAP_DB_LOG_QUEUE_LOCK) {

            ResetStates |= LSAP_DB_LOG_QUEUE_LOCK;
        }

    }

    //
    // There may also be options set in the handle.  Take these into
    // account as well.
    //

    EffectiveOptions = Options | InternalHandle->Options;




    //
    // If the handle is not Trusted, verify that the desired accesses have been granted
    //

    if (!(InternalHandle->Trusted)) {

        if (!RtlAreAllAccessesGranted( InternalHandle->GrantedAccess, DesiredAccess )) {

            //
            // Check to see if the caller is using authenticated RPC & they
            // are failing because of POLICY_LOOKUP_NAME access
            //
            Status = STATUS_ACCESS_DENIED;

            if ((InternalHandle->ObjectTypeId == PolicyObject) &&
                RtlAreAllAccessesGranted(POLICY_LOOKUP_NAMES,DesiredAccess) &&
                !RtlAreAllAccessesGranted(InternalHandle->GrantedAccess, POLICY_LOOKUP_NAMES) ) {

                ULONG RpcErr;
                ULONG AuthnLevel = 0;
                ULONG AuthnSvc = 0;

                RpcErr = RpcBindingInqAuthClient(
                            NULL,
                            NULL,               // no privileges
                            NULL,               // no server principal name
                            &AuthnLevel,
                            &AuthnSvc,
                            NULL                // no authorization level
                            );
                //
                // If it as authenticated at level packet integrity or better
                // and is done with the netlogon package, allow it through
                //

                if ((RpcErr == ERROR_SUCCESS) &&
                    (AuthnLevel >= RPC_C_AUTHN_LEVEL_PKT_INTEGRITY) &&
                    (AuthnSvc == RPC_C_AUTHN_NETLOGON )) {
                    Status = STATUS_SUCCESS;
                }

            }
            if (!NT_SUCCESS(Status)) {
                goto ReferenceError;
            }
        }
    }

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbReferenceObject: 0x%lx\n", Status ));

    return (Status);

ReferenceError:

    //
    // Unset the states in the correct order.  If a database transaction
    // was started by this routine, it will be aborted.  Ignore the status
    // No registry transaction can be active here
    //
    if (( ObjectHandle != NULL ) && (StatesSet)) {
        LsapDbResetStates( ObjectHandle,
                           ResetStates,
                           ObjectTypeId,
                           ( SECURITY_DB_DELTA_TYPE )0,
                           Status );
    }

    //
    // Dereference the handle if we referenced it.
    //

    if ( HandleReferenced ) {
        LsapDbDereferenceHandle( ObjectHandle );
    }

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbReferenceObject: 0x%lx\n", Status ));

    return Status;
}


NTSTATUS
LsapDbDereferenceObject(
    IN OUT PLSAPR_HANDLE ObjectHandle,
    IN LSAP_DB_OBJECT_TYPE_ID HandleTypeId,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN ULONG Options,
    IN SECURITY_DB_DELTA_TYPE SecurityDbDeltaType,
    IN NTSTATUS PreliminaryStatus
    )

/*++

Routine Description:

    This function dereferences a handle, optionally validating it first.
    If the Reference Count in the handle goes to 0, the handle is freed.
    The Lsa Database may optionally be unlocked by this function.  It
    must be locked before calling this function.

Arguments:

    ObjectHandle - Pointer to handle to be dereferenced.  If the reference
        count reaches 0, NULL is returned in this location.

    HandleTypeId - Specifies the expected object type to which the handle
        relates.  An error is returned if this type does not match the
        type contained in the handle.

    ObjectTypeId - Specifies the expected object type to which the object that is to
        be operated upon relates

    Options - Specifies optional additional actions to be performed including
        Lsa Database states to be cleared.

        LSAP_DB_VALIDATE_HANDLE - Validate the handle.

        LSAP_DEREFERENCE_CONTR - Dereference the container object

        LSAP_DB_FINISH_TRANSACTION - A database transaction was started
            and must be concluded.  Conclude the current Lsa Database
            transaction by applying or aborting it depending on the
            final Status.

        LSAP_DB_LOCK - The Lsa database lock was acquired and
            should be released.

        LSAP_DB_LOG_QUEUE_LOCK - The Lsa Audit Log Queue Lock
            was acquired and should be released.

        LSAP_DB_OMIT_REPLICATOR_NOTIFICATION - Omit notification to
            Replicator of the change.

        LSAP_DB_ADMIT_DELETED_OBJECT_HANDLES - Permit the handle provided
            to be for a deleted object.

        NOTE: There may be some Options (not database states) provided in the
              ObjectHandle.  These options augment those provided.

    PreliminaryStatus = Current Result Code.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - The handle could not be found.

        STATUS_OBJECT_TYPE_MISMATCH - The specified object type id does not
            match the object type id contained in the handle.
--*/

{
    NTSTATUS Status, SecondaryStatus, TmpStatus;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) *ObjectHandle;
    BOOLEAN DecrementCount = TRUE;
    ULONG EffectiveOptions;
    ULONG ReferenceCount = 0;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbDereferenceObject\n" ));

    Status = PreliminaryStatus;
    SecondaryStatus = STATUS_SUCCESS;


    //
    // There may also be options set in the handle.  Take these into
    // account as well.
    //

    EffectiveOptions = Options | InternalHandle->Options;

    //
    // If validating, lookup the handle and match the type.
    //

    if (EffectiveOptions & LSAP_DB_VALIDATE_HANDLE) {

        SecondaryStatus = LsapDbVerifyHandle(
                              *ObjectHandle,
                              EffectiveOptions,
                              HandleTypeId,
                              FALSE );

        if (!NT_SUCCESS(SecondaryStatus)) {

            DecrementCount = FALSE;
            goto DereferenceObjectError;
        }

    }

    //
    // Dereference the container handle if so requested
    //

    if (EffectiveOptions & LSAP_DB_DEREFERENCE_CONTR) {

        if (InternalHandle->ContainerHandle != NULL) {
            //
            // Dereference the container object.
            //

            SecondaryStatus = LsapDbDereferenceObject(
                                  (PLSAPR_HANDLE) &InternalHandle->ContainerHandle,
                                  NullObject,
                                  NullObject,
                                  LSAP_DB_READ_ONLY_TRANSACTION |
                                     LSAP_DB_DS_OP_TRANSACTION |
                                     LSAP_DB_STANDALONE_REFERENCE,
                                  (SECURITY_DB_DELTA_TYPE) 0,
                                  STATUS_SUCCESS
                                  );
        }
    }


DereferenceObjectFinish:

    //
    // Unlock the database.
    //

    if (NT_SUCCESS(SecondaryStatus))
    {
        SecondaryStatus = LsapDbResetStates(
                    *ObjectHandle,
                    EffectiveOptions,
                    ObjectTypeId,
                    SecurityDbDeltaType,
                    Status
                    );

    }

    //
    // Dereference the object handle
    //

    if ( DecrementCount ) {

        //
        // If the reference count reached zero,
        //  ditch to callers pointer to the handle.
        //
        if ( LsapDbDereferenceHandle( *ObjectHandle ) ) {
            *ObjectHandle = NULL;
        }

    }


    if ( NT_SUCCESS( Status ) ) {

        Status = SecondaryStatus;
    }

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbDereferenceObject: 0x%lx\n", Status ));

    return( Status );

DereferenceObjectError:

    if (NT_SUCCESS(Status) && !NT_SUCCESS(SecondaryStatus)) {

        Status = SecondaryStatus;
    }

    goto DereferenceObjectFinish;
}


NTSTATUS
LsapDbReadAttributeObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PUNICODE_STRING AttributeNameU,
    IN OPTIONAL PVOID AttributeValue,
    IN OUT PULONG AttributeValueLength
    )

/*++

Routine Description:

    This routine reads the value of an attribute of an open LSA Database object.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called and the supplied ObjectHandle must be valid.

Arguments:

    ObjectHandle - LSA Handle to object.  This must be valid.

    AttributeNameU - Pointer to Unicode name of attribute

    AttributeValue - Pointer to buffer to receive attribute's value.  This
        parameter may be NULL if the input AttributeValueLength is zero.

    AttributeValueLength - Pointer to variable containing on input the size of
        attribute value buffer and on output the size of the attributes's
        value.  A value of zero may be specified to indicate that the size of
        the attribute's value is unknown.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_BUFFER_OVERFLOW - This warning is returned if the specified
            attribute value length is non-zero and too small for the
            attribute's value.
--*/

{
    //
    // The LSA Database is implemented as a subtree of the Configuration
    // Registry.  In this implementation, Lsa Database objects correspond
    // to Registry keys and "attributes" and their "values" correspond to
    // Registry "subkeys" and "values" of the Registry key representing the
    // object.
    //

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Verify that the LSA Database is locked
    //  (The lock for the specified object type must be locked.)
    //

    // ASSERT (LsapDbIsLocked());


    Status = LsapRegReadAttribute( ObjectHandle,
                                   AttributeNameU,
                                   AttributeValue,
                                   AttributeValueLength );
    return(Status);
}



NTSTATUS
LsapDbReadAttributeObjectEx(
    IN LSAPR_HANDLE ObjectHandle,
    IN LSAP_DB_NAMES AttributeIndex,
    IN OPTIONAL PVOID AttributeValue,
    IN OUT PULONG AttributeValueLength,
    IN BOOLEAN CanDefaultToZero
    )

/*++

Routine Description:

    This routine reads the value of an attribute of an open LSA Database object.

    NOTE: This function obsolesces LsapDbReadAttributeObject

    WARNING:  The Lsa Database must be in the locked state when this function
              is called and the supplied ObjectHandle must be valid.

Arguments:

    ObjectHandle - LSA Handle to object.  This must be valid.

    AttributeIndex - Index into attribute list of attribute to be read

    AttributeType - Type of the attribute

    AttributeValue - Pointer to buffer to receive attribute's value.  This
        parameter may be NULL if the input AttributeValueLength is zero.

    AttributeValueLength - Pointer to variable containing on input the size of
        attribute value buffer and on output the size of the attributes's
        value.  A value of zero may be specified to indicate that the size of
        the attribute's value is unknown.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_BUFFER_OVERFLOW - This warning is returned if the specified
            attribute value length is non-zero and too small for the
            attribute's value.
--*/

{
    //
    // The LSA Database is implemented as a subtree of the Configuration
    // Registry.  In this implementation, Lsa Database objects correspond
    // to Registry keys and "attributes" and their "values" correspond to
    // Registry "subkeys" and "values" of the Registry key representing the
    // object.
    //

    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_ATTRIBUTE Attribute;

    if ( !ARGUMENT_PRESENT( AttributeValueLength ) ) {

        return( STATUS_INVALID_PARAMETER );
    }

    LsapDbInitializeAttributeDs(
        &Attribute,
        AttributeIndex,
        AttributeValue,
        AttributeValueLength ? *AttributeValueLength : 0,
        FALSE
        );

    LsapDbAttributeCanNotExist( &Attribute );


    //
    // Verify that the LSA Database is locked
    //  (The lock for the specific object type must be locked.)
    //
    // ASSERT (LsapDbIsLocked());

    Status = LsapDbReadAttributesObject( ObjectHandle,
                                         0,
                                         &Attribute,
                                         1 );

    if ( Status == STATUS_SUCCESS ) {

        if ( ARGUMENT_PRESENT( AttributeValue ) ) {

            if ( *AttributeValueLength >= Attribute.AttributeValueLength ) {

                RtlCopyMemory( AttributeValue,
                               Attribute.AttributeValue,
                               Attribute.AttributeValueLength );

            } else {

                Status = STATUS_BUFFER_OVERFLOW;

            }
        }

        *AttributeValueLength = Attribute.AttributeValueLength;

        if ( Attribute.MemoryAllocated ) {

            MIDL_user_free( Attribute.AttributeValue );
        }
    }

    return(Status);
}


NTSTATUS
LsapDbWriteAttributeObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PUNICODE_STRING AttributeNameU,
    IN PVOID AttributeValue,
    IN ULONG AttributeValueLength
    )

/*++

Routine Description:

    This routine writes the value of an attribute of an open LSA Database
    object.  A Database transaction must already be open: the write is
    appended to the transaction log.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

Arguments:

    ObjectHandle - Lsa Handle of open object.

    AttributeNameU - Pointer to Unicode string containing the name of the
       attribute whose value is to be written.

    AttributeValue - Pointer to buffer containing attribute's value.  If NULL
        is specified for this parameter, AttributeValueLength must be 0.

    AttributeValueLength - Contains the size of attribute value buffer to be
        written.  0 may be specified, indicating that the attribute is to be
        deleted.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The attribute was successfully added to the
            transaction log.

        STATUS_INVALID_PARAMETER - AttributeValue is NULL but the
            AttributeValueLength value is not 0.

        Errors from the Registry Transaction Package.
--*/

{
    //
    // The LSA Database is implemented as a subtree of the Configuration
    // Registry.  In this implementation, Lsa Database objects correspond
    // to Registry keys and "attributes" and their "values" correspond to
    // Registry "subkeys" and "values" of the Registry key representing the
    // object.
    //

    NTSTATUS Status;
    UNICODE_STRING PhysicalSubKeyNameU;


    PhysicalSubKeyNameU.Buffer = NULL;

    //
    // Verify that the LSA Database is locked
    //  (The lock for the specified object type must be locked.)
    //

    // ASSERT (LsapDbIsLocked());

    //
    // If the attribute value is null, verify that the AttributeValueLength
    // field is 0.
    //

    if (!ARGUMENT_PRESENT(AttributeValue)) {

        if (AttributeValueLength != 0) {

            Status = STATUS_INVALID_PARAMETER;
            goto WriteAttributeObjectError;
        }
    }

    //
    // Writing an object attribute's value is more complex than reading
    // one because the Registry Transaction package is called instead of
    // calling the Registry API directly.  Since the transaction package
    // expects to perform its own open of the target subkey representing
    // the attribute (when a transaction commit is finally done) using a
    // name relative to the LSA Database Registry Transaction Key (which
    // we call the Physical Name within the LSA Database code).  The
    // Registry Key handle contained in the object handle is therefore
    // not used by the present routine.  Instead, we need to construct the
    // Physical Name the sub key and pass it together with the LSA Database
    // Registry transaction key handle on the Registry transaction API
    // call.  The Physical Name of the subkey is constructed by
    // concatenating the Physical Object Name stored in the object handle
    // with a "\" and the given sub key name.
    //

    Status = LsapDbLogicalToPhysicalSubKey(
                 ObjectHandle,
                 &PhysicalSubKeyNameU,
                 AttributeNameU
                 );

    if (!NT_SUCCESS(Status)) {

        goto WriteAttributeObjectError;
    }

    //
    // Now log the sub key write as a Registry Transaction
    //

    Status = LsapRegWriteAttribute(
                 &PhysicalSubKeyNameU,
                 AttributeValue,
                 AttributeValueLength
                 );

    if (!NT_SUCCESS(Status)) {

        goto WriteAttributeObjectError;
    }

WriteAttributeObjectFinish:

    //
    // If necessary, free the Unicode String buffer allocated by
    // LsapDbLogicalToPhysicalSubKey;
    //

    if (PhysicalSubKeyNameU.Buffer != NULL) {

        RtlFreeUnicodeString(&PhysicalSubKeyNameU);
    }

    return(Status);

WriteAttributeObjectError:

    goto WriteAttributeObjectFinish;
}


NTSTATUS
LsapDbWriteAttributeObjectEx(
    IN LSAPR_HANDLE ObjectHandle,
    IN LSAP_DB_NAMES AttributeIndex,
    IN PVOID AttributeValue,
    IN ULONG AttributeValueLength
    )

/*++

Routine Description:

    This routine writes the value of an attribute of an open LSA Database
    object.  A Database transaction must already be open: the write is
    appended to the transaction log.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

Arguments:

    ObjectHandle - Lsa Handle of open object.

    AttributeNameU - Pointer to Unicode string containing the name of the
       attribute whose value is to be written.

    AttributeValue - Pointer to buffer containing attribute's value.  If NULL
        is specified for this parameter, AttributeValueLength must be 0.

    AttributeValueLength - Contains the size of attribute value buffer to be
        written.  0 may be specified, indicating that the attribute is to be
        deleted.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The attribute was successfully added to the
            transaction log.

        STATUS_INVALID_PARAMETER - AttributeValue is NULL but the
            AttributeValueLength value is not 0.

        Errors from the Registry Transaction Package.
--*/

{
    //
    // The LSA Database is implemented as a subtree of the Configuration
    // Registry.  In this implementation, Lsa Database objects correspond
    // to Registry keys and "attributes" and their "values" correspond to
    // Registry "subkeys" and "values" of the Registry key representing the
    // object.
    //

    NTSTATUS Status;
    UNICODE_STRING PhysicalSubKeyNameU;
    LSAP_DB_ATTRIBUTE Attribute;

    LsapDbInitializeAttributeDs(
        &Attribute,
        AttributeIndex,
        AttributeValue,
        AttributeValueLength,
        FALSE
        );

    Status = LsapDbWriteAttributesObject( ObjectHandle,
                                          &Attribute,
                                          1 );


    return(Status);

}


NTSTATUS
LsapDbWriteAttributesObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    )

/*++

Routine Description:

    This routine writes the values of one or more attributes of an open LSA
    Database object.  A Database transaction must already be open: the write
    is appended to the transaction log.  The attribute names specified are
    assumed to be consistent with the object type and the values supplied
    are assumed to be valid.

    WARNINGS:  The Lsa Database must be in the locked state when this function
               is called.

Arguments:

    ObjectHandle - Lsa Handle of open object.

    Attributes - Pointer to an array of Attribute Information blocks each
        containing pointers to the attribute's Unicode Name, the value
        to be stored, and the length of the value in bytes.

    AttributeCount - Count of the attributes to be written, equivalently,
        this is the number of elements of the array pointed to by Attributes.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index, Options = 0;
    LSAP_DB_HANDLE InternalHandle;

    if ( !LsapDsIsWriteDs( ObjectHandle ) ) {

        for(Index = 0; Index < AttributeCount; Index++) {

            Status = LsapDbWriteAttributeObject(
                         ObjectHandle,
                         Attributes[Index].AttributeName,
                         Attributes[Index].AttributeValue,
                         Attributes[Index].AttributeValueLength
                         );


            if (!NT_SUCCESS(Status)) {

                break;
            }
        }

    } else {

        InternalHandle = ( LSAP_DB_HANDLE )ObjectHandle;

        if ( InternalHandle->ObjectTypeId == SecretObject &&
             FLAG_ON( InternalHandle->Options, LSAP_DB_HANDLE_CREATED_SECRET ) ) {

            Options |= LSAPDS_REPL_CHANGE_URGENTLY;
        }

        Status = LsapDsWriteAttributes( &((LSAP_DB_HANDLE)ObjectHandle)->PhysicalNameDs,
                                        Attributes,
                                        AttributeCount,
                                        Options);

        if ( NT_SUCCESS( Status ) && FLAG_ON( Options, LSAPDS_REPL_CHANGE_URGENTLY ) ) {

            InternalHandle->Options &= ~LSAP_DB_HANDLE_CREATED_SECRET;

        }

    }

    return(Status);
}


NTSTATUS
LsapDbReadAttributesObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN OUT PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    )

/*++

Routine Description:

    This routine reads the values of one or more attributes of an open LSA
    Database object.  A Database transaction must already be open: the write
    is appended to the transaction log.  The attribute names specified are
    assumed to be consistent with the object type and the values supplied
    are assumed to be valid.  This routine will allocate memory via
    MIDL_user_allocate for buffers which will receive attribute values if
    requested.  This memory must be freed after use by calling MIDL_User_free
    after use.

    WARNINGS:  The Lsa Database must be in the locked state when this function
               is called.

Arguments:

    ObjectHandle - Lsa Handle of open object.

    Attributes - Pointer to an array of Attribute Information blocks each
        containing pointers to the attribute's Unicode Name, an optional
        pointer to a buffer that will receive the value and an optional
        length of the value expected in bytes.

        If the AttributeValue field in this structure is specified as non-NULL,
        the attribute's data will be returned in the specified buffer.  In
        this case, the AttributeValueLength field must specify a sufficiently
        large buffer size in bytes.  If the specified size is too small,
        a warning is returned and the buffer size required is returned in
        AttributeValueLength.

        If the AttributeValue field in this structure is NULL, the routine
        will allocate memory for the attribute value's buffer, via MIDL_user_allocate().  If
        the AttributeValueLength field is non-zero, the number of bytes specified
        will be allocated.  If the size of buffer allocated is too small to
        hold the attribute's value, a warning is returned.  If the
        AttributeValuelength field is 0, the routine will first query the size
        of buffer required and then allocate its memory.

        In all success cases and buffer overflow cases, the
        AttributeValueLength is set upon exit to the size of data required.

    AttributeCount - Count of the attributes to be read, equivalently,
        this is the number of elements of the array pointed to by Attributes.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_OBJECT_NAME_NOT_FOUND - One or more of the specified
            attributes do not exist.  In this case, the attribute information
            AttributeValue, AttributeValueLength fields are zeroised.  Note
            that an attempt will be made to read all of the supplied
            attributes, even if one of them is not found.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_ATTRIBUTE NextAttribute = NULL;
    BOOLEAN MemoryToFree = FALSE;
    ULONG MemoryToFreeCount = 0;

    if ( !LsapDsIsWriteDs(ObjectHandle) ) {

        for (NextAttribute = Attributes;
             NextAttribute < &Attributes[AttributeCount];
             NextAttribute++) {

            NextAttribute->MemoryAllocated = FALSE;

            // If an explicit buffer pointer is given, verify that the length
            // specified is non-zero and attempt to use that buffer.
            //

            if (NextAttribute->AttributeValue != NULL) {

                if (NextAttribute->AttributeValueLength == 0) {


                    return(STATUS_INVALID_PARAMETER);
                }

                Status = LsapDbReadAttributeObject(
                             ObjectHandle,
                             NextAttribute->AttributeName,
                             (PVOID) NextAttribute->AttributeValue,
                             (PULONG) &NextAttribute->AttributeValueLength
                             );

                if (!NT_SUCCESS(Status)) {

                    //
                    // If the attribute was not found, set the AttributeValue
                    // and AttributeValueLength fields to NULL and continue.
                    //

                    if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

                        break;
                    }

                    NextAttribute->AttributeValue = NULL;
                    NextAttribute->AttributeValueLength = 0;
                }

                continue;
            }

            //
            // No output buffer pointer has been given.  If a zero buffer
            // size is given, query size of memory required.  Since the
            // buffer length is 0, STATUS_SUCCESS should be returned rather
            // than STATUS_BUFFER_OVERFLOW.
            //

            if (NextAttribute->AttributeValueLength == 0) {

                Status = LsapDbReadAttributeObject(
                             ObjectHandle,
                             NextAttribute->AttributeName,
                             NULL,
                             (PULONG) &NextAttribute->AttributeValueLength
                             );

                if (!NT_SUCCESS(Status)) {

                    //
                    // If the attribute was not found, set the AttributeValue
                    // and AttributeValueLength fields to NULL and continue.
                    //

                    if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

                        break;
                    }

                    NextAttribute->AttributeValue = NULL;
                    NextAttribute->AttributeValueLength = 0;
                    continue;
                }

                Status = STATUS_SUCCESS;
            }

            //
            // If the attribute value size needed is 0, return NULL pointer
            //

            if (NextAttribute->AttributeValueLength == 0) {

                NextAttribute->AttributeValue = NULL;
                continue;
            }

            //
            // Allocate memory for the buffer.
            //

            NextAttribute->AttributeValue =
                MIDL_user_allocate(NextAttribute->AttributeValueLength);

            if (NextAttribute->AttributeValue == NULL) {

                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            NextAttribute->MemoryAllocated = TRUE;
            MemoryToFree = TRUE;
            MemoryToFreeCount++;

            //
            // Now read the attribute into the buffer.
            //

            Status = LsapDbReadAttributeObject(
                         ObjectHandle,
                         NextAttribute->AttributeName,
                         (PVOID) NextAttribute->AttributeValue,
                         (PULONG) &NextAttribute->AttributeValueLength
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }
        }

        if (!NT_SUCCESS(Status)) {

            goto ReadAttributesError;
        }

    } else {

        //
        // Use the DS method to read them all at once
        //

        Status = LsapDsReadAttributes( &((LSAP_DB_HANDLE)ObjectHandle)->PhysicalNameDs,
                                       LSAPDS_OP_NO_LOCK,
                                       Attributes,
                                       AttributeCount );

    }


ReadAttributesFinish:

    return(Status);

ReadAttributesError:

    //
    // If memory was allocated for any values read, it must be freed.
    //

    if (MemoryToFree) {

        for (NextAttribute = &Attributes[0];
             (MemoryToFreeCount > 0) &&
                 (NextAttribute < &Attributes[AttributeCount]);
             NextAttribute++) {

            if (NextAttribute->MemoryAllocated) {

                 MIDL_user_free( NextAttribute->AttributeValue );
                 NextAttribute->AttributeValue = NULL;
                 MemoryToFreeCount--;
            }
        }
    }

    goto ReadAttributesFinish;
}


NTSTATUS
LsapDbDeleteAttributeObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PUNICODE_STRING AttributeNameU,
    IN BOOLEAN DeleteSecurely
    )

/*++

Routine Description:

    This routine deletes an attribute of an open LSA Database object.
    A Database transaction must already be open: the delete actions are
    appended to the transaction log.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

    The LSA Database is implemented as a subtree of the Configuration
    Registry.  In this implementation, Lsa Database objects correspond
    to Registry keys and "attributes" and their "values" correspond to
    Registry "subkeys" and "values" of the Registry key representing the
    object.

Arguments:

    ObjectHandle - Lsa Handle of open object.

    AttributeNameU - Pointer to Unicode string containing the name of the
       attribute whose value is to be written.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status;
    UNICODE_STRING PhysicalSubKeyNameU;
    ULONG AttributeLength = 0;

    //
    // Verify that the LSA Database is locked
    //  (The lock for the specified object type must be locked.)
    //

    // ASSERT (LsapDbIsLocked());

    //
    // The Registry code will actually create a key if one does not exist, so
    // probe for the existence of the key first.
    //

    Status = LsapDbReadAttributeObject(
                 ObjectHandle,
                 AttributeNameU,
                 NULL,
                 &AttributeLength
                 );

    if (!NT_SUCCESS(Status)) {

        goto DeleteAttributeObjectError;
    }

    //
    // We need to construct the Physical Name the sub key relative
    // to the LSA Database root node in the Registry.  This is done by
    // concatenating the Physical Object Name stored in the object handle with
    // a "\" and the given sub key name.
    //

    Status = LsapDbLogicalToPhysicalSubKey(
                 ObjectHandle,
                 &PhysicalSubKeyNameU,
                 AttributeNameU
                 );

    if (!NT_SUCCESS(Status)) {

        goto DeleteAttributeObjectError;
    }

    //
    // Now log the sub key write as a Registry Transaction
    //

    Status = LsapRegDeleteAttribute(
                 &PhysicalSubKeyNameU,
                 DeleteSecurely,
                 AttributeLength
                 );

    RtlFreeUnicodeString(&PhysicalSubKeyNameU);

    if (!NT_SUCCESS(Status)) {

        goto DeleteAttributeObjectError;
    }

DeleteAttributeObjectFinish:

    return(Status);

DeleteAttributeObjectError:

    //
    // Add any cleanup required on error paths only here.
    //

    goto DeleteAttributeObjectFinish;
}


NTSTATUS
LsapDbDeleteAttributesObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    )
/*++

Routine Description:

    This routine deletes the values of one or more attributes of an open LSA
    Database object.  A Database transaction must already be open: the write
    is appended to the transaction log.  The attribute names specified are
    assumed to be consistent with the object type and the values supplied
    are assumed to be valid.

    WARNINGS:  The Lsa Database must be in the locked state when this function
               is called.

Arguments:

    ObjectHandle - Lsa Handle of open object.

    Attributes - Pointer to an array of Attribute Information blocks each
        containing pointers to the attribute's Unicode Name, the value
        to be stored, and the length of the value in bytes.

    AttributeCount - Count of the attributes to be written, equivalently,
        this is the number of elements of the array pointed to by Attributes.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index;

    if ( !LsapDsIsWriteDs( ObjectHandle ) ) {

        for(Index = 0; Index < AttributeCount; Index++) {

            Status = LsapDbDeleteAttributeObject(
                         ObjectHandle,
                         Attributes[Index].AttributeName,
                         FALSE
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }
        }

    } else {

        Status = LsapDsDeleteAttributes( &((LSAP_DB_HANDLE)ObjectHandle)->PhysicalNameDs,
                                         Attributes,
                                         AttributeCount);

    }

    return(Status);
}

typedef NTSTATUS ( *LsapDsPolicyNotify )(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid
    );

NTSTATUS
LsapSceNotify(
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid OPTIONAL
    )
{
    NTSTATUS Status;
    NTSTATUS SavedStatus = STATUS_SUCCESS;
    static LsapDsPolicyNotify SceNotify = NULL;
    static HANDLE DllHandle = NULL;
    static LARGE_INTEGER liZero = {0};

    ASSERT( !g_ScePolicyLocked );

    if ( !LsapDbState.ReplicatorNotificationEnabled ) {

        return STATUS_SUCCESS;
    }

    if ( SceNotify == NULL ) {

        if ( DllHandle != NULL ) {

            FreeLibrary( DllHandle );
            DllHandle = NULL;
        }

        DllHandle = LoadLibraryA( "scecli" );

        if ( DllHandle == NULL ) {

            LsapDsDebugOut(( DEB_ERROR, "Failed to load SCECLI.DLL\n" ));
            if ( NT_SUCCESS(SavedStatus)) {
                SavedStatus = STATUS_DLL_NOT_FOUND;
            }
        } else {
            SceNotify = ( LsapDsPolicyNotify )GetProcAddress( DllHandle,
                                                              "SceNotifyPolicyDelta" );

            if ( SceNotify == NULL ) {

                LsapDsDebugOut(( DEB_ERROR,
                                 "Failed to find SceNotifyPolicyDelta in SCECLI.DLL\n" ));
                if ( NT_SUCCESS(SavedStatus)) {
                    SavedStatus = STATUS_ENTRYPOINT_NOT_FOUND;
                }
            }
        }

    }

    //
    // The only two types of objects SCE cares about are Policy and Account objects
    //

    switch ( ObjectType ) {

    case SecurityDbObjectLsaPolicy:
    case SecurityDbObjectLsaAccount:
        break;

    default:

        //
        // Shouldn't call this routine with other object types
        //

        ASSERT( FALSE );
        return STATUS_SUCCESS;
    }

    if ( SceNotify != NULL ) {

        Status = ( *SceNotify )(
                     SecurityDbLsa,
                     DeltaType,
                     ObjectType,
                     ObjectSid );

        if ( !NT_SUCCESS( Status ) ) {
            if ( NT_SUCCESS(SavedStatus)) {
                SavedStatus = Status;
            }
        }
    }

    return SavedStatus;
}

NTSTATUS
LsapNetNotifyDelta (
    IN SECURITY_DB_TYPE DbType,
    IN LARGE_INTEGER SerialNumber,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PSID ObjectSid,
    IN PUNICODE_STRING ObjectName,
    IN DWORD ReplicateImmediately,
    IN PSAM_DELTA_DATA MemberId
    )
/*++

Routine Description:

    This is a wrapper function for Netlogon's I_NetNotifyDelta

Arguments:

    Same as I_NetNotifyDelta

Return Value:

    Same as I_NetNotifyDelta

--*/
{
    //
    // Notify the LSA Database Replicator of the change.
    //

    return ( I_NetNotifyDelta(
                 DbType,
                 SerialNumber,
                 DeltaType,
                 ObjectType,
                 ObjectRid,
                 ObjectSid,
                 ObjectName,
                 ReplicateImmediately,
                 MemberId ));
}

NTSTATUS
LsapDbNotifyChangeObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN SECURITY_DB_DELTA_TYPE SecurityDbDeltaType
    )

/*++

Routine Description:

    This function notifies the LSA Database Replicator (if any) of a
    change to an object.  Change notifications for Secret objects specify
    that replication of the change should occur immediately.

    WARNING! All parameters passed to this routine are assumed valid.
    No checking will be done.

    Must be entered with the RegistryLock locked.

Arguments:

    ObjectHandle - Handle to an LSA object.  This is expected to have
        already been validated.

    SecurityDbDeltaType - Specifies the type of change being made.  The
        following values only are relevant:

        SecurityDbNew - Indicates that a new object has been created.
        SecurityDbDelete - Indicates that an object is being deleted.
        SecurityDbChange - Indicates that the attributes of an object
            are being changed, including creation or deletion of
            attributes.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INVALID_HANDLE - The specified handle is invalid.  This
            error is only returned if the Object Type Id in the handle
            is invalid.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    SECURITY_DB_OBJECT_TYPE ObjectType = SecurityDbObjectLsaTDomain;
    UNICODE_STRING ObjectName;
    PSID ObjectSid = NULL;
    ULONG ObjectRid = 0;
    UCHAR SubAuthorityCount;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) ObjectHandle;
    BOOLEAN ReplicateImmediately = FALSE;

    ASSERT( LsapDbIsLocked( &LsapDbState.RegistryLock ));

    ObjectName.Buffer = NULL;
    ObjectName.Length = ObjectName.MaximumLength = 0;

    ASSERT(LsapDbState.ReplicatorNotificationEnabled);

    //
    // The problem is that many code paths in the lsa pass a 0 for SecurityDbDeltaType.
    // without specifying omit replicator notification. This is incorrect and causes
    // a notification with a 0 specified for the delta type. This is causes a full
    // sync of all NT4 BDC's. To safegaurd against this case

    ASSERT(SecurityDbDeltaType!=0);
    if (0==SecurityDbDeltaType)
    {
        SecurityDbDeltaType = SecurityDbChange;
    }

    //
    // Convert the Lsa Database Object Type to a Database Delta Type.
    //

    switch (InternalHandle->ObjectTypeId) {

    case PolicyObject:

        ObjectType = SecurityDbObjectLsaPolicy;
        break;

    case AccountObject:

        ObjectType = SecurityDbObjectLsaAccount;
        break;

    case TrustedDomainObject:

        ObjectType = SecurityDbObjectLsaTDomain;
        break;

    case SecretObject:

        ObjectType = SecurityDbObjectLsaSecret;
        ReplicateImmediately = TRUE;
        break;

    default:

        Status = STATUS_INVALID_HANDLE;
        goto Cleanup;
    }


    //
    // Get the Name or Sid of the object from its handle.  If the object
    // is of a type such as SecretObject that is accessed by Name, then
    // the object's externally known name is equal to its internal
    // Logical Name contained in the handle.
    //

    if ( LsapDbAccessedBySidObject( InternalHandle->ObjectTypeId )) {

        ObjectSid = InternalHandle->Sid;

        if ( InternalHandle->ObjectTypeId != TrustedDomainObject ) {

            ASSERT( ObjectSid );

            if ( ObjectSid == NULL ) {

                Status = STATUS_INVALID_SID;
                goto Cleanup;

            }

            SubAuthorityCount = *RtlSubAuthorityCountSid( ObjectSid );
            ObjectRid = *RtlSubAuthoritySid( ObjectSid, SubAuthorityCount -1 );

        }

    } else if (LsapDsIsWriteDs( InternalHandle) ||
               LsapDbAccessedByNameObject( InternalHandle->ObjectTypeId )) {

        Status = LsapRpcCopyUnicodeString(
                     NULL,
                     &ObjectName,
                     &InternalHandle->LogicalNameU
                     );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

    } else {

        //
        // Currently, an object is either accessed by Sid or by Name, so
        // something is wrong if both of the above chacks have failed.
        //

        Status = STATUS_INVALID_HANDLE;
        goto Cleanup;
    }

    //
    // Notify the LSA Database Replicator of the change.
    //

    Status = LsapNetNotifyDelta (
                 SecurityDbLsa,
                 LsapDbState.PolicyModificationInfo.ModifiedId,
                 SecurityDbDeltaType,
                 ObjectType,
                 ObjectRid,
                 ObjectSid,
                 &ObjectName,
                 ReplicateImmediately,
                 NULL
                 );


Cleanup:

    //
    // If we allocated memory for the Object Name Unicode buffer, free it.
    //

    if (ObjectName.Buffer != NULL) {

        MIDL_user_free( ObjectName.Buffer );
    }

    //
    // Suppress any error and return STATUS_SUCCESS.  Currently, there is
    // no meaningful action an LSA client of this routine can take.
    //

    return STATUS_SUCCESS;
}


NTSTATUS
LsapDbVerifyInformationObject(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation
    )

/*++

Routine Description:

    This function verifies that the information specified in passed
    ObjectInformation is syntactically valid.

Arguments:

    ObjectInformation - Pointer to information describing this object.  The
        following information items must be specified:

        o Object Type Id
        o Object Logical Name (as ObjectAttributes->ObjectName, a pointer to
             a Unicode string)
        o Container object handle (for any object except the root Policy object).

        All other fields in ObjectAttributes portion of ObjectInformation
        such as SecurityDescriptor are ignored.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_PARAMETER - Invalid object information given
            - ObjectInformation is NULL
            - Object Type Id is out of range
            - No Logical Name pointer given
            - Logical Name not a pointer to a Unicode String (TBS)
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId = ObjectInformation->ObjectTypeId;

    //
    // Verify that ObjectInformation is given
    //

    if (!ARGUMENT_PRESENT(ObjectInformation)) {

         return(STATUS_INVALID_PARAMETER);
    }

    //
    // Validate the Object Type Id.  It must be in range.
    //

    if (!LsapDbIsValidTypeObject(ObjectTypeId)) {

        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Verify that a Logical Name is given.  A pointer to a Unicode string
    // is expected.
    //

    if (!ARGUMENT_PRESENT(ObjectInformation->ObjectAttributes.ObjectName)) {

        Status = STATUS_INVALID_PARAMETER;
    }

    return(Status);
}


NTSTATUS
LsapDbSidToLogicalNameObject(
    IN PSID Sid,
    OUT PUNICODE_STRING LogicalNameU
    )

/*++

Routine Description:

    This function generates the Logical Name (Internal LSA Database Name)
    of an object from its Sid.  Currently, only the Relative Id (lowest
    sub-authority) is used due to Registry and hence Lsa Database limits
    on name components to 8 characters.  The Rid is extracted and converted
    to an 8-digit Unicode Integer.

Arguments:

    Sid - Pointer to the Sid to be looked up.  It is the caller's
        responsibility to ensure that the Sid has valid syntax.

    LogicalNameU -  Pointer to a Unicode String structure that will receive
        the Logical Name.  Note that memory for the string buffer in this
        Unicode String will be allocated by this routine if successful.  The
        caller must free this memory after use by calling RtlFreeUnicodeString.

Return Value:

    NTSTATUS - Standard Nt Status code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to allocate buffer for Unicode String name.
--*/

{
    NTSTATUS Status;

    //
    // First, verify that the given Sid is valid
    //

    if (!RtlValidSid( Sid )) {

        return STATUS_INVALID_PARAMETER;
    }


    Status = RtlConvertSidToUnicodeString( LogicalNameU, Sid, TRUE);

    return Status;
}


NTSTATUS
LsapDbGetNamesObject(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ULONG CreateHandleOptions,
    OUT OPTIONAL PUNICODE_STRING LogicalNameU,
    OUT OPTIONAL PUNICODE_STRING PhysicalNameU,
    OUT OPTIONAL PUNICODE_STRING PhysicalNameDs
    )

/*++

Routine Description:

    This function returns the Logical and/or Physical Names of an object
    given an object information buffer.  Memory will be allocated for
    the Unicode String Buffers that will receive the name(s).

    The Logical Name of an object is the path of the object within the
    LSA Database relative to its Classifying Directory.  The Logical Name
    of an object is implemntation-dependent and on current implementations
    is equal to one of the following depending on object type:

    o The External Name of the object (if any)
    o The Relative Id (lowest sub-authority) in the object's Sid (if any)
      converted to an 8-digit integer, including leading 0's added as
      padding.

    The Physical Name of an object is the full path of the object relative
    to the root ot the Database.  It is computed by concatenating the Physical
    Name of the Container Object (if any), the Classifying Directory
    corresponding to the object type id, and the Logical Name of the
    object.

    <Physical Name of Object> =
        [<Physical Name of Container Object> "\"]
        [<Classifying Directory> "\"] <Logical Name of Object>

    If there is no Container Object (as in the case of the Policy object)
    the <Physical Name of Container Object> and following \ are omitted.
    If there is no Classifying Directory (as in the case of the Policy object)
    the <Classifying Directory> and following \ are omitted.  If neither
    Container Object not Classifying Directory exist, the Logical and Physical
    names coincide.

    Note that memory is allocated by this routine for the output
    Unicode string buffer(s).  When the output Unicode String(s) are no
    longer needed, the memory must be freed by call(s) to
    RtlFreeUnicodeString().

    Example of Physical Name computation:

    Consider the user or group account object ScottBi

    Container Object Logical Name:     Policy
    Container Object Physical Name:    Policy  (no Classifying Directory or
                                               Container Object exists)
    Classifying Directory for ScottBi: Accounts
    Logical Name of Object:            ScottBi
    Physical Name of Object            Policy\Accounts\ScottBi

    Note that the Physical Name is exactly the Registry path relative to
    the Security directory.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

Arguments:

    ObjectInformation - Pointer to object information containing as a minimum
        the object's Logical Name, Container Object's handle and object type
        id.

    LogicalNameU - Optional pointer to Unicode String structure which will
        receive the Logical Name of the object.  A buffer will be allocated
        by this routine for the name text.  This memory must be freed when no
        longer needed by calling RtlFreeUnicodeString() wiht a pointer such
        as LogicalNameU to the Unicode String structure.

    PhysicalNameU - Optional pointer to Unicode String structure which will
       receive the Physical Name of the object.  A buffer will be allocated by
       this routine for the name text.  This memory must be freed when no
       longer needed by calling RtlFreeUnicodeString() with a pointer such as
       PhysicalNameU to the Unicode String structure.  This is only initialized
       the object can reside in the registry

    PhysicalNameDs - Optional pointer to Unicode String structure which will
       receive the Physical Name of the object if it resides in the DS.  Same
       caveats apply.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources to
            allocate the name string buffer for the Physical Name or
            Logical Name.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PUNICODE_STRING ContainerPhysicalNameU = NULL;
    PUNICODE_STRING ClassifyingDirU = NULL;
    UNICODE_STRING IntermediatePath1U;
    PUNICODE_STRING JoinedPath1U = &IntermediatePath1U;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId = ObjectInformation->ObjectTypeId;
    POBJECT_ATTRIBUTES ObjectAttributes = &ObjectInformation->ObjectAttributes;
    UNICODE_STRING TempLogicalNameU, TempDomainLogicalName;
    UUID Uuid;
    PWSTR GuidString;
    RPC_STATUS RpcStatus;
    ULONG GuidLength, BufferLength, SkipLength;
    PBYTE ScratchBuffer = NULL, CopyStart;
    BOOLEAN ObjectShouldExist = TRUE;

    //
    // Initialize
    //
    RtlInitUnicodeString( &IntermediatePath1U, NULL );
    RtlInitUnicodeString( &TempLogicalNameU, NULL );
    RtlInitUnicodeString( &TempDomainLogicalName, NULL );

    //
    // Verify that the LSA Database is locked
    //  (The lock for the specified object type must be locked.)
    //
    // ASSERT (LsapDbIsLocked());

    //
    // Capture the Logical Name of the object into permanent memory.
    //
    LSAPDS_ALLOC_AND_COPY_UNICODE_STRING_ON_SUCCESS( Status,
                                                     &TempLogicalNameU,
                                                     ObjectInformation->ObjectAttributes.ObjectName );
    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    //
    // If the Logical Name of the object is requested, return this.
    //

    if (ARGUMENT_PRESENT(LogicalNameU)) {

        *LogicalNameU = TempLogicalNameU;
    }

    //
    // If the Physical Name of the object is not required, just return.
    //

    if (ARGUMENT_PRESENT(PhysicalNameU)) {

        PhysicalNameU->Buffer = NULL;
        Status = LsapRegGetPhysicalObjectName(
                    ObjectInformation,
                    &TempLogicalNameU,
                    PhysicalNameU );
    }

    if ( NT_SUCCESS( Status ) && ARGUMENT_PRESENT( PhysicalNameDs) ) {

        PhysicalNameDs->Buffer = NULL;

        //
        // Copy the logical name, in case we have to return the current copy...
        //
        LSAPDS_ALLOC_AND_COPY_UNICODE_STRING_ON_SUCCESS( Status,
                                                         &TempDomainLogicalName,
                                                         &TempLogicalNameU );

        if ( !NT_SUCCESS( Status ) ) {

            goto Cleanup;
        }

        if ( FLAG_ON( CreateHandleOptions, LSAP_DB_CREATE_HANDLE_MORPH ) ) {

            ObjectShouldExist = FALSE;
        }

        //
        // If the name is too long, truncate it...
        //
        if ( FLAG_ON( CreateHandleOptions, LSAP_DB_CREATE_HANDLE_MORPH ) ) {

            LsapTruncateUnicodeString( &TempDomainLogicalName, MAX_RDN_KEY_SIZE );
        }

        Status = LsapDsGetPhysicalObjectName( ObjectInformation,
                                              ObjectShouldExist,
                                              &TempDomainLogicalName,
                                              PhysicalNameDs );

        if ( (Status == STATUS_OBJECT_NAME_COLLISION) &&
             (ObjectInformation->ObjectTypeId == NewTrustedDomainObject) &&
              FLAG_ON( CreateHandleOptions, LSAP_DB_CREATE_HANDLE_MORPH ) ) {

            //
            // Got a name collion.  Morph the name by replacing the last digits with a GUID
            //
            RpcStatus = UuidCreate ( &Uuid );

            if ( RpcStatus == RPC_S_OK || RpcStatus == RPC_S_UUID_LOCAL_ONLY ) {

                Status = STATUS_SUCCESS;

                RpcStatus = UuidToStringW( &Uuid, &GuidString );

                if ( RpcStatus == RPC_S_OK ) {

                    GuidLength = wcslen( GuidString );

                    //
                    // Now, we have to handle the cases of the various string lengths...
                    //
                    BufferLength = 0;
                    if ( ( TempDomainLogicalName.Length / sizeof( WCHAR ) ) + GuidLength >=
                                                                                MAX_RDN_KEY_SIZE ) {

                        LsapTruncateUnicodeString( &TempDomainLogicalName, MAX_RDN_KEY_SIZE );
                        BufferLength = MAX_RDN_KEY_SIZE;
                        SkipLength = MAX_RDN_KEY_SIZE - GuidLength;

                    } else {

                        BufferLength = ( TempDomainLogicalName.Length / sizeof( WCHAR ) ) + GuidLength;
                        SkipLength =  TempDomainLogicalName.Length / sizeof( WCHAR );

                    }

                    if ( BufferLength >
                                   ( TempDomainLogicalName.MaximumLength  / sizeof( WCHAR ) ) ) {

                        //
                        // Have to allocate a new buffer
                        //
                        ScratchBuffer =
                                    LsapAllocateLsaHeap( ( BufferLength + 1 ) * sizeof( WCHAR ) );

                        if ( ScratchBuffer == NULL ) {

                            Status = STATUS_INSUFFICIENT_RESOURCES;

                        } else {

                            RtlCopyMemory( ScratchBuffer,
                                           TempDomainLogicalName.Buffer,
                                           TempDomainLogicalName.Length );

                            LsapFreeLsaHeap( TempDomainLogicalName.Buffer );
                            TempDomainLogicalName.Length = ( USHORT )BufferLength * sizeof( WCHAR );
                            TempDomainLogicalName.MaximumLength = TempDomainLogicalName.Length + sizeof( WCHAR );
                            TempDomainLogicalName.Buffer = ( PWSTR )ScratchBuffer;
                        }
                    }

                    //
                    // Now, build the new string
                    //
                    if ( NT_SUCCESS( Status ) ) {

                        RtlCopyMemory( ( ( PWSTR )TempDomainLogicalName.Buffer + SkipLength ),
                                       GuidString,
                                       GuidLength );
                    }

                    RpcStringFreeW( &GuidString );

                }

                if ( NT_SUCCESS( Status ) && RpcStatus != RPC_S_OK ) {

                    Status = STATUS_OBJECT_NAME_INVALID;
                }

            }

            //
            // Try to build the name again.  If this fails, such is life...
            //
            if ( NT_SUCCESS( Status ) ) {

                Status = LsapDsGetPhysicalObjectName( ObjectInformation,
                                                      ObjectShouldExist,
                                                      &TempDomainLogicalName,
                                                      PhysicalNameDs );

            }
        }
    }

Cleanup:

    // Do cleanup that does not depend on success or failure of this function
    //
    LsapFreeLsaHeap( TempDomainLogicalName.Buffer );


    // Do cleanup required on failure of this function
    //
    if ( !NT_SUCCESS( Status ) ) {

        LsapFreeLsaHeap( TempLogicalNameU.Buffer );

        if ( ARGUMENT_PRESENT(LogicalNameU) ) {
            // we dont need to free this since this simply points to TempLogicalNameU
            // which is already freed.
            LogicalNameU->Buffer = NULL;
        }

        if ( ARGUMENT_PRESENT(PhysicalNameU) ) {

            LsapFreeLsaHeap( PhysicalNameU->Buffer );
            PhysicalNameU->Buffer = NULL;
        }

        if ( ARGUMENT_PRESENT(PhysicalNameDs) ) {

            LsapFreeLsaHeap( PhysicalNameDs->Buffer );
            PhysicalNameDs->Buffer = NULL;
        }
    }

    return Status;
}


BOOLEAN
LsapDbIsLocked(
    IN PSAFE_CRITICAL_SECTION CritSect
    )

/*++

Routine Description:

    Check if LSA Database is locked.

Arguments:

    CritSect to check.

Return Value:

    BOOLEAN - TRUE if LSA database is locked, else false.

--*/

{
    return (BOOLEAN)( SafeCritsecLockCount( CritSect ) != -1L);
}

BOOLEAN
LsapDbResourceIsLocked(
    IN PSAFE_RESOURCE Resource
    )

/*++

Routine Description:

    Check if LSA Database is locked.

Arguments:

    CritSect to check.

Return Value:

    BOOLEAN - TRUE if LSA database is locked, else false.

--*/

{
    BOOLEAN IsLocked;

    SafeEnterResourceCritsec( Resource );
    IsLocked = ( SafeNumberOfActive( Resource ) != 0);
    SafeLeaveResourceCritsec( Resource );

    return IsLocked;
}


NTSTATUS
LsarQuerySecurityObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PLSAPR_SR_SECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    The LsaQuerySecurityObject API returns security information assigned
    to an LSA Database object.

    Based on the caller's access rights and privileges, this procedure will
    return a security descriptor containing any or all of the object's owner
    ID, group ID, discretionary ACL or system ACL.  To read the owner ID,
    group ID, or the discretionary ACL, the caller must be granted
    READ_CONTROL access to the object.  To read the system ACL, the caller must
    have SeSecurityPrivilege privilege.

    This API is modelled after the NtQuerySecurityObject() system service.

Arguments:

    ObjectHandle - A handle to an existing object in the LSA Database.

    SecurityInformation - Supplies a value describing which pieces of
        security information are being queried.  The values that may be
        specified are the same as those defined in the NtSetSecurityObject()
        API section.

    SecurityDescriptor - Receives a pointer to a buffer containing the
        requested security information.  This information is returned in
        the form of a Self-Relative Security Descriptor.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_PARAMETER - An invalid parameter has been specified.
--*/

{
    NTSTATUS
        Status,
        IgnoreStatus;

    LSAP_DB_HANDLE
        InternalHandle = (LSAP_DB_HANDLE) ObjectHandle;

    ACCESS_MASK
        RequiredAccess = 0;

    BOOLEAN
        Present,
        IgnoreBoolean;

    LSAP_DB_ATTRIBUTE
        Attribute;

    PLSAPR_SR_SECURITY_DESCRIPTOR
        RpcSD = NULL;

    SECURITY_DESCRIPTOR_RELATIVE
        *SD = NULL;

    SECURITY_DESCRIPTOR
        *ReturnSD = NULL;

    ULONG
        ReturnSDLength;
    BOOLEAN ObjectReferenced = FALSE;

    LsarpReturnCheckSetup();


    if (!ARGUMENT_PRESENT( SecurityDescriptor )) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // If this is a non-Trusted client, determine the required accesses
    // for querying the object's Security Descriptor.  These accesses
    // depend on the information being queried.
    //

    LsapRtlQuerySecurityAccessMask( SecurityInformation, &RequiredAccess );


    //
    // Acquire the Lsa Database lock.  Verify that the object handle
    // is a valid handle (of any type) and is trusted or has
    // all of the required accesses granted.  Reference the container
    // object handle.
    //

    Status = LsapDbReferenceObject(
                 ObjectHandle,
                 RequiredAccess,
                 InternalHandle->ObjectTypeId,
                 InternalHandle->ObjectTypeId,
                 LSAP_DB_LOCK
                 );

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    ObjectReferenced = TRUE;

    //
    // Handle objects in the DS
    //

    if ( LsapDsIsHandleDsHandle( InternalHandle )) {

        //
        // A trusted client needs an SD to replicate to NT 4 BDCs.
        //  Give it the default SD for the object.
        //

        if ( InternalHandle->Trusted ) {

            Status = LsapDbCreateSDObject(
                            InternalHandle->ContainerHandle,
                            ObjectHandle,
                            (PSECURITY_DESCRIPTOR*) &SD );

            if ( !NT_SUCCESS( Status ) ) {
                goto Cleanup;
            }

        //
        // Don't support this API for objects in the DS
        //  (Otherwise, we'd have to translate the SD to DS format.)
        //
        } else {
            Status = STATUS_NOT_SUPPORTED;
            goto Cleanup;
        }

    //
    // For objects in the registry,
    //  read the security descriptor from the registry.
    //

    } else {

        //
        // Read the existing Security Descriptor for the object.  This always
        // exists as the value of the SecDesc attribute of the object.
        //

        LsapDbInitializeAttributeDs(
            &Attribute,
            SecDesc,
            NULL,
            0,
            FALSE
            );

        Status = LsapDbReadAttribute( ObjectHandle, &Attribute );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        SD = Attribute.AttributeValue;
    }


    //
    // ASSERT: SD is the complete security descriptor of the object.
    //
    // Elimate components that weren't requested.
    //
    ASSERT( SD != NULL );

    if ( !(SecurityInformation & OWNER_SECURITY_INFORMATION)) {
        SD->Owner = 0;
    }

    if ( !(SecurityInformation & GROUP_SECURITY_INFORMATION)) {
        SD->Group = 0;
    }

    if ( !(SecurityInformation & DACL_SECURITY_INFORMATION)) {
        SD->Control &= (~SE_DACL_PRESENT);
    }

    if ( !(SecurityInformation & SACL_SECURITY_INFORMATION)) {
        SD->Control &= (~SE_SACL_PRESENT);
    }


    //
    // Now copy the parts of the security descriptor that we are going to return.
    //

    ReturnSDLength = 0;
    ReturnSD = NULL;
    Status = RtlMakeSelfRelativeSD( (PSECURITY_DESCRIPTOR) SD,
                                    ReturnSD,
                                    &ReturnSDLength );

    if (Status == STATUS_BUFFER_TOO_SMALL) {    // This is the expected case

        ReturnSD = MIDL_user_allocate( ReturnSDLength );

        if (ReturnSD == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Status = RtlMakeSelfRelativeSD( (PSECURITY_DESCRIPTOR) SD,
                                         (PSECURITY_DESCRIPTOR) ReturnSD,
                                         &ReturnSDLength );

        if ( !NT_SUCCESS(Status)) {
            ASSERT( NT_SUCCESS(Status) );
            goto Cleanup;
        }
    } else {
        if ( NT_SUCCESS(Status) ) {
            Status = STATUS_INTERNAL_ERROR;
        }
        goto Cleanup;
    }


    //
    // Allocate the first block of returned memory.
    //

    RpcSD = MIDL_user_allocate( sizeof(LSAPR_SR_SECURITY_DESCRIPTOR) );

    if (RpcSD == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RpcSD->Length = ReturnSDLength;
    RpcSD->SecurityDescriptor = (PUCHAR)( (PVOID)ReturnSD );
    ReturnSD = NULL;

Cleanup:


    //
    // free the attribute read from disk
    //
    if ( SD != NULL ) {
        MIDL_user_free( SD );
    }

    if ( ReturnSD != NULL ) {
        MIDL_user_free( ReturnSD );
    }

    if ( ObjectReferenced ) {

        IgnoreStatus = LsapDbDereferenceObject(
                           &ObjectHandle,
                           InternalHandle->ObjectTypeId,
                           InternalHandle->ObjectTypeId,
                           LSAP_DB_LOCK,
                           (SECURITY_DB_DELTA_TYPE) 0,
                           Status
                           );

    }

    *SecurityDescriptor = RpcSD;

    LsarpReturnPrologue();

    return(Status);
}



NTSTATUS
LsarSetSecurityObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PLSAPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    The LsaSetSecurityObject API takes a well formaed Security Descriptor
    and assigns specified portions of it to an object.  Based on the flags set
    in the SecurityInformation parameter and the caller's access rights, this
    procedure will replace any or alll of the security information associated
    with the object.

    The caller must have WRITE_OWNER access to the object to change the
    owner or Primary group of the object.  The caller must have WRITE_DAC
    access to the object to change the Discretionary ACL.  The caller must
    have SeSecurityPrivilege to assign a system ACL to an object.

    This API is modelled after the NtSetSecurityObject() system service.

Arguments:

    ObjectHandle - A handle to an existing object in the LSA Database.

    SecurityInformation - Indicates which security information is to be
        applied to the object.  The values that may be specified are the
        same as those defined in the NtSetSecurityObject() API section.
        The value(s) to be assigned are passed in the SecurityDescriptor
        parameter.

    SecurityDescriptor - A pointer to a well formed Self-Relative
        Security Descriptor.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_PARAMETER - An invalid parameter has been specified.

        STATUS_INVALID_SECURITY_DESCR - A bad security descriptor was given

--*/

{
    NTSTATUS Status;
    NTSTATUS SecondaryStatus = STATUS_SUCCESS;
    ACCESS_MASK RequiredAccess = 0;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) ObjectHandle;
    LSAP_DB_ATTRIBUTE Attribute;
    PSECURITY_DESCRIPTOR SetSD = NULL;
    PSECURITY_DESCRIPTOR RetrieveSD = NULL;
    PSECURITY_DESCRIPTOR ModificationSD = NULL;
    ULONG RetrieveSDLength;
    ULONG SetSDLength;
    BOOLEAN ObjectReferenced = FALSE;
    HANDLE ClientToken = NULL;

    LsarpReturnCheckSetup();

    //
    // Verify that a Security Descriptor has been passed.
    //

    if (!ARGUMENT_PRESENT( SecurityDescriptor )) {
        Status = STATUS_INVALID_PARAMETER;
        goto SetSecurityObjectError;
    }

    if (!ARGUMENT_PRESENT( SecurityDescriptor->SecurityDescriptor )) {
        Status = STATUS_INVALID_PARAMETER;
        goto SetSecurityObjectError;
    }

    //
    // Verify its a valid security descriptor
    //

    if ( !RtlValidRelativeSecurityDescriptor(
              (PSECURITY_DESCRIPTOR)SecurityDescriptor->SecurityDescriptor,
              SecurityDescriptor->Length,
              SecurityInformation )) {

        Status = STATUS_INVALID_SECURITY_DESCR;
        goto SetSecurityObjectError;
    }

    ModificationSD = (PSECURITY_DESCRIPTOR)(SecurityDescriptor->SecurityDescriptor);

    //
    // If the caller is non-trusted, figure the accesses required
    // to update the object's Security Descriptor based on the
    // information being changed.
    //

    if (!InternalHandle->Trusted) {

        LsapRtlSetSecurityAccessMask( SecurityInformation, &RequiredAccess);
    }

    //
    // Acquire the Lsa Database lock.  Verify that the object handle
    // is a valid handle (of any type), and is trusted or has
    // all of the desired accesses granted.  Reference the container
    // object handle.
    //

    Status = LsapDbReferenceObject(
                 ObjectHandle,
                 RequiredAccess,
                 InternalHandle->ObjectTypeId,
                 InternalHandle->ObjectTypeId,
                 LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetSecurityObjectError;
    }

    ObjectReferenced = TRUE;

    //
    // Don't support this API for objects in the DS
    //  (Otherwise, we'd have to translate the SD to DS format.)
    //

    if ( LsapDsIsHandleDsHandle( InternalHandle )) {
        Status = STATUS_NOT_SUPPORTED;
        goto SetSecurityObjectError;
    }

    //
    // Read the existing Security Descriptor for the object.  This always
    // exists as the value of the SecDesc attribute of the object.
    //

    LsapDbInitializeAttributeDs(
        &Attribute,
        SecDesc,
        NULL,
        0,
        FALSE
        );

    Status = LsapDbReadAttribute( ObjectHandle, &Attribute );

    if (!NT_SUCCESS(Status)) {

        goto SetSecurityObjectError;
    }

    //
    // Copy the retrieved descriptor into process heap so we can use
    // RTL routines.
    //

    RetrieveSD = Attribute.AttributeValue;
    RetrieveSDLength = Attribute.AttributeValueLength;


    if (RetrieveSD == NULL) {
        Status = STATUS_INTERNAL_DB_CORRUPTION;
        goto SetSecurityObjectError;
    }

    if (RetrieveSDLength == 0) {
        Status = STATUS_INTERNAL_DB_CORRUPTION;
        goto SetSecurityObjectError;
    }

    SetSD = RtlAllocateHeap( RtlProcessHeap(), 0, RetrieveSDLength );

    if (SetSD == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SetSecurityObjectError;
    }

    RtlCopyMemory( SetSD, RetrieveSD, RetrieveSDLength );

    //
    // If the caller is replacing the owner, then a handle to the impersonation
    // token is necessary.
    //

    ClientToken = 0;

    if (SecurityInformation & OWNER_SECURITY_INFORMATION) {

        if (!InternalHandle->Trusted) {

            //
            // Client is non-trusted.  Impersonate the client and
            // obtain a handle to the impersonation token.
            //

            Status = I_RpcMapWin32Status(RpcImpersonateClient( NULL ));

            if (!NT_SUCCESS(Status)) {

                goto SetSecurityObjectError;
            }

            Status = NtOpenThreadToken(
                         NtCurrentThread(),
                         TOKEN_QUERY,
                         TRUE,            //OpenAsSelf
                         &ClientToken
                         );

            if (!NT_SUCCESS(Status)) {

                if (Status != STATUS_NO_TOKEN) {

                    goto SetSecurityObjectError;
                }
            }

            //
            // Stop impersonating the client
            //

            SecondaryStatus = I_RpcMapWin32Status(RpcRevertToSelf());

            if (!NT_SUCCESS(SecondaryStatus)) {

                goto SetSecurityObjectError;
            }

        } else {

            //
            // Client is trusted and so is the LSA Process itself.  Open the
            // process token
            //

            Status = NtOpenProcessToken(
                         NtCurrentProcess(),
                         TOKEN_QUERY,
                         &ClientToken
                         );

            if (!NT_SUCCESS(Status)) {

                goto SetSecurityObjectError;
            }
        }
    }

    //
    // Build the replacement security descriptor.  This must be done in
    // process heap to satisfy the needs of the RTL routine.
    //

    Status = RtlSetSecurityObject(
                 SecurityInformation,
                 ModificationSD,
                 &SetSD,
                 &(LsapDbState.
                     DbObjectTypes[InternalHandle->ObjectTypeId].GenericMapping),
                 ClientToken
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetSecurityObjectError;
    }

    SetSDLength = RtlLengthSecurityDescriptor( SetSD );

    //
    // Now replace the existing SD with the updated one.
    //

    Status = LsapDbWriteAttributeObject(
                 ObjectHandle,
                 &LsapDbNames[SecDesc],
                 SetSD,
                 SetSDLength
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetSecurityObjectError;
    }

SetSecurityObjectFinish:

    //
    // If necessary, close the Client Token.
    //

    if (ClientToken != 0) {

        SecondaryStatus = NtClose( ClientToken );

        ClientToken = NULL;

        if (!NT_SUCCESS( Status )) {

            goto SetSecurityObjectError;
        }
    }

    //
    // If necessary, free the buffer containing the retrieved SD.
    //

    if (RetrieveSD != NULL) {

        MIDL_user_free( RetrieveSD );
        RetrieveSD = NULL;
    }

    //
    // If necessary, dereference the object, finish the database
    // transaction, notify the LSA Database Replicator of the change,
    // release the LSA Database lock and return.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     &ObjectHandle,
                     InternalHandle->ObjectTypeId,
                     InternalHandle->ObjectTypeId,
                     LSAP_DB_LOCK | LSAP_DB_FINISH_TRANSACTION,
                     SecurityDbChange,
                     Status
                     );

        ObjectReferenced = FALSE;
    }

    //
    // Free the Security descriptor that we set
    //
    if ( SetSD ) {

        RtlFreeHeap( RtlProcessHeap(), 0, SetSD );
    }

    LsarpReturnPrologue();

    return(Status);

SetSecurityObjectError:

    if (NT_SUCCESS(Status)) {

        Status = SecondaryStatus;
    }

    goto SetSecurityObjectFinish;
}


NTSTATUS
LsapDbRebuildCache(
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId
    )

/*++

Routine Description:

    This function rebuilds cached information for a given LSA object type.

Arguments:

    ObjectTypeId - Specifies the Object Type for which the cached information
        is to be rebuilt.

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // If caching is not supporte, just return.
    //

    if (!LsapDbIsCacheSupported( ObjectTypeId )) {

        goto RebuildCacheFinish;
    }

    //
    // Call the build routine for the specified LSA object Type
    //

    switch (ObjectTypeId) {

    case PolicyObject:

        SafeAcquireResourceExclusive( &LsapDbState.PolicyCacheLock, TRUE );
        LsapDbMakeCacheInvalid( PolicyObject );
        Status = LsapDbBuildPolicyCache();
        LsapDbMakeCacheValid( PolicyObject );
        SafeReleaseResource( &LsapDbState.PolicyCacheLock );
        break;

    case AccountObject:

        LsapDbMakeCacheInvalid( AccountObject );
        Status = LsapDbBuildAccountCache();
        LsapDbMakeCacheValid( AccountObject );
        break;

    case TrustedDomainObject:

        LsapDbAcquireWriteLockTrustedDomainList();
        LsapDbMakeCacheInvalid( TrustedDomainObject );
        LsapDbPurgeTrustedDomainCache();
        Status = LsapDbBuildTrustedDomainCache();
        LsapDbMakeCacheValid( TrustedDomainObject );
        LsapDbReleaseLockTrustedDomainList();
        break;

    case SecretObject:

        LsapDbMakeCacheInvalid( SecretObject );
        Status = LsapDbBuildSecretCache();
        LsapDbMakeCacheValid( SecretObject );
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto RebuildCacheError;
    }

RebuildCacheFinish:

    return(Status);

RebuildCacheError:

    LsapDbMakeCacheInvalid( ObjectTypeId );

    goto RebuildCacheFinish;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbpolicy.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbpolicy.c

Abstract:

    LSA Database - Policy Object Private API Workers

Author:

    Scott Birrell       (ScottBi)      January 10, 1992

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"
#include "lsawmi.h"

#define LSAP_DB_POLICY_MAX_BUFFERS             ((ULONG) 0x00000005L)

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Function prototypes private to this module                              //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#define LsapDbIsCacheValidPolicyInfoClass( InformationClass )              \
    (LsapDbPolicy.Info[ InformationClass ].AttributeLength > 0)

NTSTATUS
LsapDbUpdateInformationPolicy(
    IN POLICY_INFORMATION_CLASS InformationClass
    );


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Code                                                                    //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

NTSTATUS
LsarOpenPolicy(
    IN OPTIONAL PLSAPR_SERVER_NAME SystemName,
    IN PLSAPR_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE PolicyHandle
    )

/*++

Routine Description:

    This function is the LSA server worker dispatch routine for the
    LsaOpenPolicy API.

    To administer the Local Security Policy of a local or remote system,
    this API must be called to establish a session with that system's
    Local Security Authority (LSA) subsystem.  This API connects to
    the LSA of the target system and opens the Policy object
    of the target system's Local Security Policy database.  A handle to
    the Policy object is returned.  This handle must be used
    on all subsequent API calls to administer the Local Security Policy
    information for the target system.

Arguments:

    SystemName - Name of the system to be administered.  This RPC call
        only passes in a single character for system name, so it is not
        passed along to the internal routine.

    ObjectAttributes - Pointer to the set of attributes to use for this
        connection.  The security Quality Of Service information is used and
        normally should provide Security Identification Class of
        impersonation.  Some operations, however, require Security
        Impersonation Class of impersonation.

    DesiredAccess - This is an access mask indicating accesses being
        requested for the LSA Subsystem's LSA Database.  These access types
        are reconciled with the Discretionary Access Control List of the
        target Policy object to determine whether the accesses will be granted or denied.

    PolicyHandle - Receives a handle to be used in future requests.


Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have access to the target
        system's LSA Database, or does not have other desired accesses.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LsarpReturnCheckSetup();

    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_OpenPolicy);

    Status = LsapDbOpenPolicy( NULL,
                               ObjectAttributes,
                               DesiredAccess,
                               0,   // No special options
                               PolicyHandle,
                               FALSE );

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_OpenPolicy);
    LsarpReturnPrologue();

    UNREFERENCED_PARAMETER( SystemName );

    return( Status );
}

NTSTATUS
LsarOpenPolicy2(
    IN OPTIONAL PLSAPR_SERVER_NAME SystemName,
    IN PLSAPR_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE PolicyHandle
    )

/*++

Routine Description:

    This function is the LSA server worker dispatch routine for the
    LsaOpenPolicy API.

    To administer the Local Security Policy of a local or remote system,
    this API must be called to establish a session with that system's
    Local Security Authority (LSA) subsystem.  This API connects to
    the LSA of the target system and opens the Policy object
    of the target system's Local Security Policy database.  A handle to
    the Policy object is returned.  This handle must be used
    on all subsequent API calls to administer the Local Security Policy
    information for the target system.

    The difference between this call and LsaOpenPolicy is that the entire
    system name is passed in instead of the first character.

Arguments:

    SystemName - Name of the system to be administered.  Administration of
        the local system is assumed if NULL is specified.

    ObjectAttributes - Pointer to the set of attributes to use for this
        connection.  The security Quality Of Service information is used and
        normally should provide Security Identification Class of
        impersonation.  Some operations, however, require Security
        Impersonation Class of impersonation.

    DesiredAccess - This is an access mask indicating accesses being
        requested for the LSA Subsystem's LSA Database.  These access types
        are reconciled with the Discretionary Access Control List of the
        target Policy object to determine whether the accesses will be granted or denied.

    PolicyHandle - Receives a handle to be used in future requests.


Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have access to the target
        system's LSA Database, or does not have other desired accesses.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    LsarpReturnCheckSetup();

    Status = LsapDbOpenPolicy( SystemName,
                               ObjectAttributes,
                               DesiredAccess,
                               0,   // No special options
                               PolicyHandle,
                               FALSE );

    LsarpReturnPrologue();

    return( Status );
}


NTSTATUS
LsarOpenPolicySce(
    IN OPTIONAL PLSAPR_SERVER_NAME SystemName,
    IN PLSAPR_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE PolicyHandle
    )

/*++

Routine Description:

    Same as LsarOpenPolicy2, except it provides an additional parameter
    to LsapDbOpenPolicy to obtain a special handle synchronized for SCE.

    The caller must have TCB privilege in order to successfully perform this call.
    Finally, this routine will call SceOpenPolicy() to give SCE the chance to
    send all pending policy changes to the SCE.

Arguments:

    See LsarOpenPolicy2

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have access to the target
        system's LSA Database, or does not have other desired accesses.

        STATUS_PRIVILEGE_NOT_HELD - Caller must come in with TCB privilege.

--*/

{
    NTSTATUS Status;
    HANDLE ClientToken = NULL;
    typedef NTSTATUS ( *PfnSceOpenPolicy )();
    static PfnSceOpenPolicy SceOpenPolicy = NULL;
    static HANDLE DllHandle = NULL;

    LsarpReturnCheckSetup();

    //
    // TCB privilege must be held by the client in order to
    // make this call.  Verify that before doing anything else
    //

    Status = I_RpcMapWin32Status( RpcImpersonateClient( 0 ));

    if ( NT_SUCCESS( Status )) {

        Status = NtOpenThreadToken(
                     NtCurrentThread(),
                     TOKEN_QUERY,
                     TRUE,
                     &ClientToken
                     );

        if ( NT_SUCCESS( Status )) {

            BOOLEAN Result = FALSE;
            PRIVILEGE_SET RequiredPrivileges;
            LUID_AND_ATTRIBUTES PrivilegeArray[1];

            RequiredPrivileges.PrivilegeCount = 1;
            RequiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
            RequiredPrivileges.Privilege[0].Luid = RtlConvertLongToLuid( SE_TCB_PRIVILEGE );
            RequiredPrivileges.Privilege[0].Attributes = 0;

            Status = NtPrivilegeCheck(
                         ClientToken,
                         &RequiredPrivileges,
                         &Result
                         );

            if ( NT_SUCCESS( Status ) &&
                 Result == FALSE ) {

                Status = STATUS_PRIVILEGE_NOT_HELD;
            }

            NtClose( ClientToken );
            ClientToken = NULL;
        }

        RpcRevertToSelf();
    }

    if ( NT_SUCCESS( Status ) && SceOpenPolicy == NULL ) {

        if ( DllHandle != NULL ) {

            FreeLibrary( DllHandle );
            DllHandle = NULL;
        }

        DllHandle = LoadLibraryW( L"SCECLI" );

        if ( DllHandle == NULL ) {

            LsapDsDebugOut(( DEB_ERROR, "Failed to load SCECLI.DLL\n" ));
            Status = STATUS_DLL_NOT_FOUND;

        } else {

            SceOpenPolicy = ( PfnSceOpenPolicy )GetProcAddress( DllHandle, "SceOpenPolicy" );

            if ( SceOpenPolicy == NULL ) {

                LsapDsDebugOut(( DEB_ERROR, "Failed to find SceNotifyPolicyDelta in SCECLI.DLL\n" ));
                Status = STATUS_ENTRYPOINT_NOT_FOUND;
            }
        }
    }

    //
    // Wait for SCECLI.DLL to send all pending policy changes to the SCE.
    // Upon success, the routine below returns STATUS_SUCCESS.  If the queue
    // of pending changes cannot be emptied within 1 second, the routine
    // returns STATUS_TIMEOUT.
    //

    if ( NT_SUCCESS( Status )) {

        //
        // Grab the SCE policy lock here to give SCE the chance to send pending changes
        //

        ResetEvent( LsapDbState.SceSyncEvent );

        RtlAcquireResourceExclusive( &LsapDbState.ScePolicyLock, TRUE );

        Status = ( *SceOpenPolicy )();

        if ( !NT_SUCCESS( Status )) {

            RtlReleaseResource( &LsapDbState.ScePolicyLock );

#ifdef DBG
        } else {

            ASSERT( !g_ScePolicyLocked );
            g_ScePolicyLocked = TRUE;
#endif
        }
    }

    if ( NT_SUCCESS( Status )) {

        Status = LsapDbOpenPolicy(
                     SystemName,
                     ObjectAttributes,
                     DesiredAccess,
                     LSAP_DB_SCE_POLICY_HANDLE,
                     PolicyHandle,
                     FALSE
                     );

        if ( !NT_SUCCESS( Status )) {

#ifdef DBG
            g_ScePolicyLocked = FALSE;
#endif

            RtlReleaseResource( &LsapDbState.ScePolicyLock );
        }
    }

    if ( ClientToken ) {

        NtClose( ClientToken );
    }

    LsarpReturnPrologue();

    return( Status );
}


NTSTATUS
LsaIOpenPolicyTrusted(
    OUT PLSAPR_HANDLE PolicyHandle
    )

/*++

Routine Description:

    This function opens a handle to the Policy Object and identifies the
    caller as a trusted client.  Any handles to LSA objects opened via
    this handle will also be trusted.  This function is specifically
    only for use by clients that form part of the Security Process.

Arguments:

    PolicyHandle - Receives a handle to the Policy Object.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

        STATUS_INTERNAL_DB_CORRUPTION - The LSA Policy Database contains
            an internal inconsistency or invalid value.
--*/

{
    return(LsapDbOpenPolicy(
               NULL,
               NULL,
               0,
               0,   // No special options
               PolicyHandle,
               TRUE
               ));
}


NTSTATUS
LsarSetPolicyReplicationHandle(
    IN OUT PLSAPR_HANDLE PolicyHandle
    )

/*++

Routine Description:

    This function sets the given handle to be the policy replication handle.

Arguments:

    PolicyHandle - Handle to be modified

Return Values:

    NTSTATUS - Standard Nt Result Code.

--*/

{

    //
    // This routine is never used and was never properly implemented
    //

    return STATUS_NOT_IMPLEMENTED;
    UNREFERENCED_PARAMETER( PolicyHandle );
}


NTSTATUS
LsapDbOpenPolicy(
    IN OPTIONAL PLSAPR_SERVER_NAME SystemName,
    IN OPTIONAL PLSAPR_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Options,
    OUT PLSAPR_HANDLE PolicyHandle,
    IN BOOLEAN TrustedClient
    )

/*++

Routine Description:

    This function is the LSA server worker routine for the LsaOpenPolicy
    API and the LsaIOpenPolicy private API for trusted clients.

    To administer the Local Security Policy of a local or remote system,
    this API must be called to establish a session with that system's
    Local Security Authority (LSA) subsystem.  This API connects to
    the LSA of the target system and opens the Policy object
    of the target system's Local Security Policy database.  A handle to
    the Policy object is returned.  This handle must be used
    on all subsequent API calls to administer the Local Security Policy
    information for the target system.

Arguments:

    SystemName - Name of the system to be administered.  Administration of
        the local system is assumed if NULL is specified.

    ObjectAttributes - Pointer to the set of attributes to use for this
        connection.  The security Quality Of Service information is used and
        normally should provide Security Identification Class of
        impersonation.  Some operations, however, require Security
        Impersonation Class of impersonation.  This parameter MUST
        be specified for non-Trusted clients (TrustedClient = FALSE)
        and must not be specified for Trusted Clients.

    DesiredAccess - This is an access mask indicating accesses being
        requested for the LSA Subsystem's LSA Database.  These access types
        are reconciled with the Discretionary Access Control List of the
        target Policy object to determine whether the accesses will be granted or denied.

    Options - Specifies optional additional actions to be taken.

    PolicyHandle - Receives a handle to be used in future requests.

    TrustedClient - Indicates whether the client is known to be part of
        the trusted computer base (TCB).  If so (TRUE), no access validation
        is performed and all requested accesses are granted.  If not
        (FALSE), then the client is impersonated and access validation
        performed against the SecurityDescriptor on the SERVER object.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

        STATUS_INTERNAL_DB_CORRUPTION - The LSA Policy Database contains
            an internal inconsistency or invalid value.

        STATUS_ACCESS_DENIED - Caller does not have access to the target
            system's LSA Database, or does not have other desired accesses.

        STATUS_INVALID_PARAMETER - Invalid parameter or combination
            of parameters,

        STATUS_BACKUP_CONTROLLER - An update access has been requested
            that is not allowed on Backup Domain Controllers for non-
            trusted clients.
--*/

{
    NTSTATUS Status;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    BOOLEAN AcquiredLock = FALSE;

    LsapEnterFunc( "LsapDbOpenPolicy" );

    //
    // Verify Object Attributes accoring to client trust status.
    //

    if (!TrustedClient) {

        Status = STATUS_INVALID_PARAMETER;

        //
        // Client is not trusted.  Object Attributes must be specified
        // and the RootDirectory field must be NULL.
        //

        if (!ARGUMENT_PRESENT(ObjectAttributes)) {

            goto OpenPolicyError;
        }


        //
        // Verify that NULL has been specified for the RootDirectory
        // of ObjectAttributes.
        //

        if (ObjectAttributes->RootDirectory != NULL) {

            goto OpenPolicyError;
        }

        //
        // Copy the supplied ObjectAttributes to the ObjectInformation and
        // augment them with the name of the Policy Object.
        //

        ObjectInformation.ObjectAttributes = *((POBJECT_ATTRIBUTES) ObjectAttributes);

    } else {

        //
        // Trusted Client.
        //

        Options |= LSAP_DB_TRUSTED;

        InitializeObjectAttributes(
            &(ObjectInformation.ObjectAttributes),
            NULL,
            0L,
            NULL,
            NULL
            );
    }

    //
    // Set the Object Type and Logical Name in the ObjectInformation structure.
    //

    ObjectInformation.ObjectTypeId = PolicyObject;
    ObjectInformation.ObjectAttributes.ObjectName = &LsapDbNames[Policy];
    ObjectInformation.ContainerTypeId = 0;
    ObjectInformation.Sid = NULL;
    ObjectInformation.ObjectAttributeNameOnly = FALSE;
    ObjectInformation.DesiredObjectAccess = DesiredAccess;

    //
    // Acquire the Lsa Database lock
    //
    LsapDbAcquireLockEx( PolicyObject,
                         LSAP_DB_READ_ONLY_TRANSACTION );

    AcquiredLock = TRUE;

    //
    // Open the Policy Object.  Return the Handle obtained as the
    // RPC Context Handle.
    //

    Status = LsapDbOpenObject(
                 &ObjectInformation,
                 DesiredAccess,
                 Options,
                 PolicyHandle
                 );

    if (!NT_SUCCESS(Status)) {

        goto OpenPolicyError;
    }

    //
    // Release the LSA Database lock and return.
    //

OpenPolicyFinish:

    //
    // If necessary, release the LSA Database lock.
    //

    if (AcquiredLock) {

        LsapDbReleaseLockEx( PolicyObject,
                             LSAP_DB_READ_ONLY_TRANSACTION );
    }

    LsapExitFunc( "LsapDbOpenPolicy", Status );

    return( Status );

OpenPolicyError:

    *PolicyHandle = NULL;
    goto OpenPolicyFinish;

    //
    // Usage of the SystemName parameter is hidden within the RPC stub
    // code, so this parameter will be permanently unreferenced.
    //

    UNREFERENCED_PARAMETER(SystemName);

}


NTSTATUS
LsaIQueryInformationPolicyTrusted(
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    )

/*++

Routine Description:

    This function is a trusted version of LsarQueryInformationPolicy.
    Unlike the standard version, no handle is required to the Policy object
    because an internal handle is used.  This routine is available only
    in the context of the Lsa Process.

Arguments:

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        PolicyAuditLogInformation         POLICY_VIEW_AUDIT_INFORMATION
        PolicyAuditEventsInformation      POLICY_VIEW_AUDIT_INFORMATION
        PolicyPrimaryDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyAccountDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyPdAccountInformation        POLICY_GET_PRIVATE_INFORMATION
        PolicyLsaServerRoleInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyReplicaSourceInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyDefaultQuotaInformation     POLICY_VIEW_LOCAL_INFORMATION
        PolicyAuditFullQueryInformation   POLICY_VIEW_AUDIT_INFORMATION
        PolicyDnsDomainInformation        POLICY_VIEW_LOCAL_INFORMATION
        PolicyDnsDomainInformationInt     POLICY_VIEW_LOCAL_INFORMATION

    Buffer - receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to the appropriate LsaIFreeLSAPR_POLICY... routine.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        Result codes returned from LsarQueryInformationPolicy()
--*/

{
    if ( InformationClass == PolicyDnsDomainInformation ) {

        //
        // Make sure NT4 emulation does not interfere with our processing here
        //
        InformationClass = PolicyDnsDomainInformationInt;
    }

    return(LsarQueryInformationPolicy(
               LsapPolicyHandle,
               InformationClass,
               Buffer
               ));
}


NTSTATUS
LsarQueryInformationPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsarQueryInformationPolicy API.

    The LsaQueryInformationPolicy API obtains information from the Policy
    object.  The caller must have access appropriate to the information
    being requested (see InformationClass parameter).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        PolicyAuditLogInformation         POLICY_VIEW_AUDIT_INFORMATION
        PolicyAuditEventsInformation      POLICY_VIEW_AUDIT_INFORMATION
        PolicyPrimaryDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyAccountDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyPdAccountInformation        POLICY_GET_PRIVATE_INFORMATION
        PolicyLsaServerRoleInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyReplicaSourceInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyDefaultQuotaInformation     POLICY_VIEW_LOCAL_INFORMATION
        PolicyAuditFullQueryInformation   POLICY_VIEW_AUDIT_INFORMATION
        PolicyDnsDomainInformation        POLICY_VIEW_LOCAL_INFORMATION
        PolicyDnsDomainInformationInt     POLICY_VIEW_LOCAL_INFORMATION

    Buffer - receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INTERNAL_DB_CORRUPTION - The Policy Database is possibly
            corrupt.  The returned Policy Information is invalid for
            the given class.
--*/

{
    NTSTATUS Status;
    ACCESS_MASK DesiredAccess;
    ULONG ReferenceOptions;
    ULONG DereferenceOptions = 0;
    BOOLEAN ObjectReferenced = FALSE;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) PolicyHandle;

    LsarpReturnCheckSetup();

    LsapEnterFunc( "LsarQueryInformationPolicy" );

    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_QueryInformationPolicy);

    //
    // If NT4 emulation is enabled, fail requests for PolicyDnsDomainInformation
    // as if they weren't implemented
    //

    if ( LsapDbState.EmulateNT4 &&
         InformationClass == PolicyDnsDomainInformation &&
         !InternalHandle->Trusted ) {

         RaiseException( RPC_NT_PROCNUM_OUT_OF_RANGE, 0, 0, NULL );

    } else if ( InformationClass == PolicyDnsDomainInformationInt ) {

        //
        // PolicyDnsDomainInformationInt is a request to override
        // NT4 emulation
        //

        InformationClass = PolicyDnsDomainInformation;
    }

    //
    // Validate the Information Class and determine the access required to
    // query this Policy Information Class.
    //

    Status = LsapDbVerifyInfoQueryPolicy(
                 PolicyHandle,
                 InformationClass,
                 &DesiredAccess
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryInfoPolicyError;
    }

    //
    // If querying the Audit Log Full information, we may need to perform a
    // test write to the Audit Log to verify that the Log Full status is
    // up to date.  The Audit Log Queue Lock must always be taken
    // prior to acquiring the LSA Database lock, so take the former lock
    // here in case we need it.
    //

    ReferenceOptions =  LSAP_DB_NO_DS_OP_TRANSACTION |
                            LSAP_DB_READ_ONLY_TRANSACTION;

    DereferenceOptions = LSAP_DB_NO_DS_OP_TRANSACTION |
                            LSAP_DB_READ_ONLY_TRANSACTION;

    //
    // If we're gettings the server role, don't hold a lock
    //
    if ( InformationClass != PolicyLsaServerRoleInformation ) {

        ReferenceOptions |= LSAP_DB_LOCK;
        DereferenceOptions |= LSAP_DB_LOCK;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the handle is valid, is
    // a handle to the Policy object and has the necessary access granted.
    // Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 DesiredAccess,
                 PolicyObject,
                 PolicyObject,
                 ReferenceOptions
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryInfoPolicyError;
    }

    ObjectReferenced = TRUE;

    //
    // If caching is enabled for this Information Class, grab the info from the
    // cache.
    //

    *Buffer = NULL;

    Status = LsapDbQueryInformationPolicy(
                 LsapPolicyHandle,
                 InformationClass,
                 Buffer
                 );

QueryInfoPolicyFinish:

    //
    // If necessary, dereference the Policy Object, release the LSA Database lock and
    // return.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     PolicyObject,
                     DereferenceOptions,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

#if DBG
    LsapDsDebugOut(( DEB_POLICY,
                     "LsarQueryInformationPolicy for info %lu returned 0x%lx\n",
                     InformationClass,
                     Status ));
#endif
    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_QueryInformationPolicy);
    LsapExitFunc( "LsarQueryInformationPolicy", Status );
    LsarpReturnPrologue();

    return(Status);

QueryInfoPolicyError:

    goto QueryInfoPolicyFinish;
}


NTSTATUS
LsarQueryInformationPolicy2(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsarQueryInformationPolicy API.

    The LsaQueryInformationPolicy API obtains information from the Policy
    object.  The caller must have access appropriate to the information
    being requested (see InformationClass parameter).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        PolicyAuditLogInformation         POLICY_VIEW_AUDIT_INFORMATION
        PolicyAuditEventsInformation      POLICY_VIEW_AUDIT_INFORMATION
        PolicyPrimaryDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyAccountDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyPdAccountInformation        POLICY_GET_PRIVATE_INFORMATION
        PolicyLsaServerRoleInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyReplicaSourceInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyDefaultQuotaInformation     POLICY_VIEW_LOCAL_INFORMATION
        PolicyAuditFullQueryInformation   POLICY_VIEW_AUDIT_INFORMATION
        PolicyDnsDomainInformation        POLICY_VIEW_LOCAL_INFORMATION
        PolicyDnsDomainInformationInt     POLICY_VIEW_LOCAL_INFORMATION

    Buffer - receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        Result codes returned from LsarQueryInformationPolicy()
--*/

{
    return(LsarQueryInformationPolicy(
               PolicyHandle,
               InformationClass,
               Buffer
               ));

}


NTSTATUS
LsapDbQueryInformationPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN OUT PLSAPR_POLICY_INFORMATION *Buffer
    )

/*++

Routine Description:

    This function is the fast LSA server RPC worker routine for the
    LsarQueryInformationPolicy API.  It reads the information
    from the Policy object cache.

    The LsaQueryInformationPolicy API obtains information from the Policy
    object.  The caller must have access appropriate to the information
    being requested (see InformationClass parameter).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    NOTE:  Currently, this function only allows the
        PolicyDefaultQuotaInformation information class to be read from
        the Policy Cache.  Other information classes can be added
        in the future.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        PolicyAuditLogInformation         POLICY_VIEW_AUDIT_INFORMATION
        PolicyAuditEventsInformation      POLICY_VIEW_AUDIT_INFORMATION
        PolicyPrimaryDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyAccountDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyPdAccountInformation        POLICY_GET_PRIVATE_INFORMATION
        PolicyLsaServerRoleInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyReplicaSourceInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyDefaultQuotaInformation     POLICY_VIEW_LOCAL_INFORMATION
        PolicyAuditFullQueryInformation   POLICY_VIEW_AUDIT_INFORMATION

    Buffer - Pointer to location that contains either a pointer to the
        buffer that will be used to return the information.  If NULL
        is contained in this location, a buffer will be allocated via
        MIDL_user_allocate and a pointer to it returned.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INTERNAL_DB_CORRUPTION - The Policy Database is possibly
            corrupt.  The returned Policy Information is invalid for
            the given class.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_POLICY_INFORMATION OutputBuffer = NULL;
    PLSAPR_POLICY_INFORMATION TempBuffer = NULL;
    ULONG OutputBufferLength;
    BOOLEAN BufferAllocated = FALSE;
    PLSAPR_POLICY_AUDIT_EVENTS_INFO   PolicyAuditEventsInfo;
    PLSAPR_POLICY_PRIMARY_DOM_INFO    PolicyPrimaryDomainInfo;
    PLSAPR_POLICY_ACCOUNT_DOM_INFO    PolicyAccountDomainInfo;
    PLSAPR_POLICY_PD_ACCOUNT_INFO     PolicyPdAccountInfo;
    PLSAPR_POLICY_REPLICA_SRCE_INFO   PolicyReplicaSourceInfo;
    PLSAPR_POLICY_DNS_DOMAIN_INFO     PolicyDnsDomainInfo;
    PPOLICY_LSA_SERVER_ROLE PolicyServerRole;
    PVOID SourceBuffers[LSAP_DB_POLICY_MAX_BUFFERS];
    PVOID DestBuffers[LSAP_DB_POLICY_MAX_BUFFERS];
    ULONG CopyLength[LSAP_DB_POLICY_MAX_BUFFERS];
    ULONG NextBufferIndex = 0;
    ULONG BufferCount = 0;
    BOOLEAN BufferProvided = FALSE;
    DOMAIN_SERVER_ROLE SamServerRole;
    BOOLEAN PolicyCacheLocked = FALSE;

    LsapEnterFunc( "LsapDbQueryInformationPolicy" );

    if (*Buffer != NULL) {

        OutputBuffer = *Buffer;
        BufferProvided = TRUE;
    }

    //
    // Special case the ServerRole information.  This information is not stored exclusively in
    // SAM, so we need to read it directly from there
    //
    if ( InformationClass == PolicyLsaServerRoleInformation ) {

        Status = LsapOpenSam();
        if ( !NT_SUCCESS( Status )  ) {

            LsapDsDebugOut(( DEB_ERROR,
                             "LsapDbQueryInformationPolicy: Sam not opened (Error 0x%x)\n", Status ));

        } else {

            Status = SamIQueryServerRole( LsapAccountDomainHandle, &SamServerRole );

            if ( !NT_SUCCESS( Status ) ) {

                LsapDsDebugOut(( DEB_ERROR,
                                 "SamIQueryServerRole failed with %lu\n", Status ));
            } else {

                //
                // Have to return the information...
                //
                if ( !BufferProvided ) {

                    OutputBuffer = MIDL_user_allocate( sizeof( POLICY_LSA_SERVER_ROLE ) );

                    if ( OutputBuffer == NULL ) {

                        Status = STATUS_INSUFFICIENT_RESOURCES;

                    } else {

                        *Buffer = OutputBuffer;
                    }


                }

                if ( NT_SUCCESS( Status ) ) {

                    PolicyServerRole = ( PPOLICY_LSA_SERVER_ROLE )OutputBuffer;

                    *PolicyServerRole =  ( POLICY_LSA_SERVER_ROLE )SamServerRole;

                }
            }
        }

        goto QueryInformationPolicyFinish;
    }

    //
    // If caching of the Policy Object is not supported, or has been disabled
    // until the next system reload, call slow query routine to read the
    // information from backing storage.
    //

    if (!LsapDbIsCacheSupported(PolicyObject)) {

        Status = LsapDbSlowQueryInformationPolicy(
                     LsapPolicyHandle,
                     InformationClass,
                     Buffer
                     );

        if (!NT_SUCCESS(Status)) {

            goto QueryInformationPolicyError;
        }

        return(Status);
    }

    //
    // Caching of the Policy Object is supported, but it may not be
    // valid.  If not valid for any information classes, rebuild the cache.
    //

    SafeAcquireResourceShared( &LsapDbState.PolicyCacheLock, TRUE );

    PolicyCacheLocked = TRUE;

    if (!LsapDbIsCacheValid(PolicyObject)) {

        SafeConvertSharedToExclusive( &LsapDbState.PolicyCacheLock );

        if ( !LsapDbIsCacheValid( PolicyObject )) {

            Status = LsapDbBuildPolicyCache();

            if (!NT_SUCCESS(Status)) {

                goto QueryInformationPolicyError;
            }

            LsapDbMakeCacheValid(PolicyObject);
        }

        SafeConvertExclusiveToShared( &LsapDbState.PolicyCacheLock );
    }

    //
    // The cache is now valid but may contain out of date information for
    // the sepcific Information Class requested.  Check for this and rebuild
    // if necessary.
    //

    if (!LsapDbIsCacheValidPolicyInfoClass(InformationClass)) {

        SafeConvertSharedToExclusive( &LsapDbState.PolicyCacheLock );

        Status = LsapDbUpdateInformationPolicy( InformationClass );

        SafeConvertExclusiveToShared( &LsapDbState.PolicyCacheLock );

        if (!NT_SUCCESS(Status)) {

            goto QueryInformationPolicyError;
        }
    }

    //
    // The cache has valid information for this Information Class.  Now read
    // the information desired from the cache.  This information consists
    // of a hierarchic structure with a single root node and zero or more
    // subnodes.  First, read the root node from the cache.  We cache its
    // length too.  We need to allocate a buffer if one was not provided.
    //

    OutputBufferLength = LsapDbPolicy.Info[ InformationClass].AttributeLength;

    if (OutputBuffer == NULL) {

        if (OutputBufferLength > 0) {

            OutputBuffer = MIDL_user_allocate( OutputBufferLength );

            if (OutputBuffer == NULL) {

                Status = STATUS_NO_MEMORY;
                goto QueryInformationPolicyError;
            }
        }

        BufferAllocated = TRUE;
    }

    //
    // Copy data for the root node from the cache
    //

    RtlCopyMemory(
        OutputBuffer,
        LsapDbPolicy.Info[InformationClass].Attribute,
        OutputBufferLength
        );

    //
    // Allocate and copy graph of output (if any)
    //

    NextBufferIndex = 0;

    switch (InformationClass) {

        case PolicyAuditLogInformation:

            break;

        case PolicyAuditEventsInformation:

            PolicyAuditEventsInfo = (PLSAPR_POLICY_AUDIT_EVENTS_INFO) OutputBuffer;

            //
            // Setup to copy the Event Auditing Options
            //

            CopyLength[ NextBufferIndex ] =
                    (PolicyAuditEventsInfo->MaximumAuditEventCount * sizeof(ULONG));

            if (CopyLength[ NextBufferIndex ] > 0) {

                DestBuffers[NextBufferIndex] = MIDL_user_allocate( CopyLength[ NextBufferIndex ] );

                if (DestBuffers[NextBufferIndex] == NULL) {

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                PolicyAuditEventsInfo->EventAuditingOptions =
                    (PPOLICY_AUDIT_EVENT_OPTIONS) DestBuffers[NextBufferIndex];

                SourceBuffers[NextBufferIndex] =
                    ((PLSAPR_POLICY_AUDIT_EVENTS_INFO)
                    LsapDbPolicy.Info[ InformationClass].Attribute)->EventAuditingOptions;

                NextBufferIndex++;
            }

            break;

        case PolicyPrimaryDomainInformation:

            PolicyPrimaryDomainInfo = (PLSAPR_POLICY_PRIMARY_DOM_INFO) OutputBuffer;

            //
            // Setup to copy the Unicode Name Buffer
            //

            CopyLength[ NextBufferIndex ] = (ULONG) PolicyPrimaryDomainInfo->Name.MaximumLength;

            if (CopyLength[ NextBufferIndex ] > 0) {

                DestBuffers[NextBufferIndex] = MIDL_user_allocate( CopyLength[ NextBufferIndex ] );

                if (DestBuffers[NextBufferIndex] == NULL) {

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                PolicyPrimaryDomainInfo->Name.Buffer =
                    (PWSTR) DestBuffers[NextBufferIndex];

                SourceBuffers[NextBufferIndex] =
                    ((PLSAPR_POLICY_PRIMARY_DOM_INFO) LsapDbPolicy.Info[ InformationClass].Attribute)->Name.Buffer;


                NextBufferIndex++;
            }

            //
            // Setup to copy the Sid (if any).  Note that the Primary Domain Sid may
            // be set to NULL so signify that we have no Primary Domain.  This
            // situation occurs during installation before a Primary Domain
            // has been specified, or if we're a member of a WorkGroup instead
            // of a Domain.
            //

            if (  PolicyPrimaryDomainInfo->Sid != NULL ) {

                CopyLength[ NextBufferIndex ] = RtlLengthSid(PolicyPrimaryDomainInfo->Sid);
                DestBuffers[NextBufferIndex] = MIDL_user_allocate( CopyLength[ NextBufferIndex ] );

                if (DestBuffers[NextBufferIndex] == NULL) {

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                PolicyPrimaryDomainInfo->Sid =
                    (PLSAPR_SID) DestBuffers[NextBufferIndex];

                SourceBuffers[NextBufferIndex] =
                    ((PLSAPR_POLICY_PRIMARY_DOM_INFO) LsapDbPolicy.Info[ InformationClass].Attribute)->Sid;

                NextBufferIndex++;
            }

            break;

        case PolicyDnsDomainInformation:

            PolicyDnsDomainInfo = (PLSAPR_POLICY_DNS_DOMAIN_INFO) OutputBuffer;

            //
            // Setup to copy the Unicode Name Buffer.  We get this from the Primary Domain info
            //

            CopyLength[ NextBufferIndex ] = (ULONG) PolicyDnsDomainInfo->Name.MaximumLength;

            if (CopyLength[ NextBufferIndex ] > 0) {

                DestBuffers[NextBufferIndex] = MIDL_user_allocate( CopyLength[ NextBufferIndex ] );

                if (DestBuffers[NextBufferIndex] == NULL) {

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                PolicyDnsDomainInfo->Name.Buffer =
                    (PWSTR) DestBuffers[NextBufferIndex];

                SourceBuffers[NextBufferIndex] =
                    ((PLSAPR_POLICY_DNS_DOMAIN_INFO) LsapDbPolicy.Info[
                                        InformationClass ].Attribute)->Name.Buffer;


                NextBufferIndex++;
            }

            //
            // Setup to copy the Unicode DNS Domain Name Buffer
            //

            CopyLength[ NextBufferIndex ] = (ULONG) PolicyDnsDomainInfo->DnsDomainName.MaximumLength;

            if (CopyLength[ NextBufferIndex ] > 0) {

                DestBuffers[NextBufferIndex] = MIDL_user_allocate( CopyLength[ NextBufferIndex ] );

                if (DestBuffers[NextBufferIndex] == NULL) {

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                PolicyDnsDomainInfo->DnsDomainName.Buffer =
                    (PWSTR) DestBuffers[NextBufferIndex];

                SourceBuffers[NextBufferIndex] =
                    ((PLSAPR_POLICY_DNS_DOMAIN_INFO) LsapDbPolicy.Info[ InformationClass].Attribute)->DnsDomainName.Buffer;


                NextBufferIndex++;
            }


            //
            // Setup to copy the Unicode DNS Tree Name Buffer
            //

            CopyLength[ NextBufferIndex ] = (ULONG) PolicyDnsDomainInfo->DnsForestName.MaximumLength;

            if (CopyLength[ NextBufferIndex ] > 0) {

                DestBuffers[NextBufferIndex] = MIDL_user_allocate( CopyLength[ NextBufferIndex ] );

                if (DestBuffers[NextBufferIndex] == NULL) {

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                PolicyDnsDomainInfo->DnsForestName.Buffer =
                    (PWSTR) DestBuffers[NextBufferIndex];

                SourceBuffers[NextBufferIndex] =
                    ((PLSAPR_POLICY_DNS_DOMAIN_INFO) LsapDbPolicy.Info[ InformationClass].Attribute)->DnsForestName.Buffer;


                NextBufferIndex++;
            }

            //
            // Setup to copy the Domain GUID.  Note that no allocation will occur here
            // (since the guid exists in the information class itself), so we'll have to
            // do the copy directly
            //
            RtlCopyMemory(
                &(PolicyDnsDomainInfo->DomainGuid),
                &(((PLSAPR_POLICY_DNS_DOMAIN_INFO) LsapDbPolicy.Info[ InformationClass].Attribute)->DomainGuid),
                sizeof(GUID)
                );


            //
            // Setup to copy the Sid from the Primary Domain info (if any).
            // Note that the Primary Domain Sid may be set to NULL to signify
            // signify that we have no Primary Domain.  This situation occurs
            // during installation before a Primary Domain has been specified,
            // or if we're a member of a WorkGroup instead of a Domain.
            //

            if ( PolicyDnsDomainInfo->Sid != NULL ) {

                CopyLength[ NextBufferIndex ] = RtlLengthSid(PolicyDnsDomainInfo->Sid);
                DestBuffers[NextBufferIndex] = MIDL_user_allocate( CopyLength[ NextBufferIndex ] );

                if (DestBuffers[NextBufferIndex] == NULL) {

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                PolicyDnsDomainInfo->Sid =
                    (PLSAPR_SID) DestBuffers[NextBufferIndex];

                SourceBuffers[NextBufferIndex] =
                    ((PLSAPR_POLICY_DNS_DOMAIN_INFO) LsapDbPolicy.Info[
                                                 InformationClass].Attribute)->Sid;

                NextBufferIndex++;
            }

            //
            // if there is a '.' at the end of DnsDomainName or DnsForestName,
            // remove it
            //
            LsapRemoveTrailingDot(
                (PUNICODE_STRING) &PolicyDnsDomainInfo->DnsDomainName, FALSE);
            LsapRemoveTrailingDot(
                (PUNICODE_STRING) &PolicyDnsDomainInfo->DnsForestName, FALSE);

            break;

        case PolicyAccountDomainInformation:

            PolicyAccountDomainInfo = (PLSAPR_POLICY_ACCOUNT_DOM_INFO) OutputBuffer;

            //
            // Setup to copy the Unicode Name Buffer
            //

            CopyLength[ NextBufferIndex ] = (ULONG) PolicyAccountDomainInfo->DomainName.MaximumLength;

            if (CopyLength[ NextBufferIndex ] > 0) {

                DestBuffers[NextBufferIndex] = MIDL_user_allocate( CopyLength[ NextBufferIndex ] );

                if (DestBuffers[NextBufferIndex] == NULL) {

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                PolicyAccountDomainInfo->DomainName.Buffer =
                    (PWSTR) DestBuffers[NextBufferIndex];

                SourceBuffers[NextBufferIndex] =
                    ((PLSAPR_POLICY_ACCOUNT_DOM_INFO) LsapDbPolicy.Info[ InformationClass].Attribute)->DomainName.Buffer;

                NextBufferIndex++;
            }

            //
            // Setup to copy the Sid (if any)
            //

            if (PolicyAccountDomainInfo->DomainSid != NULL) {

                CopyLength[ NextBufferIndex ] = RtlLengthSid(PolicyAccountDomainInfo->DomainSid);
                DestBuffers[NextBufferIndex] = MIDL_user_allocate( CopyLength[ NextBufferIndex ] );

                if (DestBuffers[NextBufferIndex] == NULL) {

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                PolicyAccountDomainInfo->DomainSid =
                    (PLSAPR_SID) DestBuffers[NextBufferIndex];

                SourceBuffers[NextBufferIndex] =
                    ((PLSAPR_POLICY_ACCOUNT_DOM_INFO) LsapDbPolicy.Info[ InformationClass].Attribute)->DomainSid;

                NextBufferIndex++;
            }

            break;

        case PolicyPdAccountInformation:

            PolicyPdAccountInfo = (PLSAPR_POLICY_PD_ACCOUNT_INFO) OutputBuffer;

            //
            // Setup to copy the Unicode Name Buffer
            //

            CopyLength[ NextBufferIndex ] = (ULONG) PolicyPdAccountInfo->Name.MaximumLength;

            if (CopyLength[ NextBufferIndex ] > 0) {

                DestBuffers[NextBufferIndex] = MIDL_user_allocate( CopyLength[ NextBufferIndex ] );

                if (DestBuffers[NextBufferIndex] == NULL) {

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                PolicyPdAccountInfo->Name.Buffer =
                    (PWSTR) DestBuffers[NextBufferIndex];

                SourceBuffers[NextBufferIndex] =
                    ((PLSAPR_POLICY_PD_ACCOUNT_INFO) LsapDbPolicy.Info[ InformationClass].Attribute)->Name.Buffer;

                NextBufferIndex++;
            }

            break;

        case PolicyLsaServerRoleInformation:

            break;

        case PolicyReplicaSourceInformation:

            PolicyReplicaSourceInfo = (PLSAPR_POLICY_REPLICA_SRCE_INFO) OutputBuffer;

            //
            // Setup to copy the Unicode Name Buffer
            //

            CopyLength[ NextBufferIndex ] =
                                    (ULONG) PolicyReplicaSourceInfo->ReplicaSource.MaximumLength;

            if (CopyLength[ NextBufferIndex ] > 0) {

                DestBuffers[NextBufferIndex] = MIDL_user_allocate( CopyLength[ NextBufferIndex ] );

                if (DestBuffers[NextBufferIndex] == NULL) {

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                PolicyReplicaSourceInfo->ReplicaSource.Buffer =
                    (PWSTR) DestBuffers[NextBufferIndex];

                SourceBuffers[NextBufferIndex] =
                    ((PLSAPR_POLICY_REPLICA_SRCE_INFO) LsapDbPolicy.Info[ InformationClass].
                                                               Attribute)->ReplicaSource.Buffer;

                NextBufferIndex++;
            }

            CopyLength[ NextBufferIndex ] = (ULONG) PolicyReplicaSourceInfo->ReplicaAccountName.MaximumLength;

            if (CopyLength[ NextBufferIndex ] > 0) {

                DestBuffers[NextBufferIndex] = MIDL_user_allocate( CopyLength[ NextBufferIndex ] );

                if (DestBuffers[NextBufferIndex] == NULL) {

                    Status = STATUS_NO_MEMORY;
                    break;
                }

                PolicyReplicaSourceInfo->ReplicaAccountName.Buffer =
                    (PWSTR) DestBuffers[NextBufferIndex];

                SourceBuffers[NextBufferIndex] =
                    ((PLSAPR_POLICY_REPLICA_SRCE_INFO) LsapDbPolicy.Info[ InformationClass].Attribute)->ReplicaAccountName.Buffer;

                NextBufferIndex++;
            }

            break;

        case PolicyDefaultQuotaInformation:

            break;

        case PolicyModificationInformation:

            break;

        case PolicyAuditFullQueryInformation:
            Status = STATUS_NOT_SUPPORTED;
            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
            break;
    }

    if (!NT_SUCCESS(Status)) {

        goto QueryInformationPolicyError;
    }

    BufferCount = NextBufferIndex;

    //
    // Now copy the graph of the output (if any) to the pre-allocated buffers.
    //

    if (BufferCount > 0) {

        for (NextBufferIndex = 0; NextBufferIndex < BufferCount; NextBufferIndex++) {

            RtlCopyMemory(
                DestBuffers[NextBufferIndex],
                SourceBuffers[NextBufferIndex],
                CopyLength[NextBufferIndex]
                );
        }
    }

    if (!BufferProvided) {

        *Buffer = OutputBuffer;
    }

QueryInformationPolicyFinish:

    if ( PolicyCacheLocked ) {

        SafeReleaseResource( &LsapDbState.PolicyCacheLock );
    }

    LsapExitFunc( "LsapDbQueryInformationPolicy", Status );

    return(Status);

QueryInformationPolicyError:

    if (BufferAllocated) {

        MIDL_user_free(OutputBuffer);
        OutputBuffer = *Buffer = NULL;
        BufferAllocated = FALSE;
    }

    BufferCount = NextBufferIndex;

    if (BufferCount > 0) {

        for ( NextBufferIndex = 0; NextBufferIndex < BufferCount; NextBufferIndex++ ) {

            MIDL_user_free( DestBuffers[ NextBufferIndex ] );
            DestBuffers[ NextBufferIndex] = NULL;
        }
    }

    goto QueryInformationPolicyFinish;
}


NTSTATUS
LsapDbSlowQueryInformationPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN OUT PLSAPR_POLICY_INFORMATION *Buffer
    )

/*++

Routine Description:

    This function is the slow LSA server RPC worker routine for the
    LsarQueryInformationPolicy API.  It actually reads the information
    from backing storage.

    The LsaQueryInformationPolicy API obtains information from the Policy
    object.  The caller must have access appropriate to the information
    being requested (see InformationClass parameter).

    N.B.  During Ds Repair mode (ie LsaISafeMode() returning TRUE), this
    routines returns the Primary and Dns information as if we are part
    of a workgroup called WORKGROUP. This is because in this diagnostic mode
    we are using the local account database of SAM and do not have a valid
    machine account for a domain.  Also the account domain name is the name
    of the computer.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        PolicyAuditLogInformation         POLICY_VIEW_AUDIT_INFORMATION
        PolicyAuditEventsInformation      POLICY_VIEW_AUDIT_INFORMATION
        PolicyPrimaryDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyAccountDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyPdAccountInformation        POLICY_GET_PRIVATE_INFORMATION
        PolicyLsaServerRoleInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyReplicaSourceInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyDefaultQuotaInformation     POLICY_VIEW_LOCAL_INFORMATION
        PolicyAuditFullQueryInformation   POLICY_VIEW_AUDIT_INFORMATION

    Buffer - Pointer to location that contains either a pointer to the
        buffer that will be used to return the information.  If NULL
        is contained in this location, a buffer will be allocated via
        MIDL_user_allocate and a pointer to it returned.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INTERNAL_DB_CORRUPTION - The Policy Database is possibly
            corrupt.  The returned Policy Information is invalid for
            the given class.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PPOLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;
    PPOLICY_PRIMARY_DOMAIN_INFO PolicyPrimaryDomainInfo;
    PPOLICY_DNS_DOMAIN_INFO     PolicyDnsDomainInfo;
    PPOLICY_PD_ACCOUNT_INFO PolicyPdAccountInfo;
    PPOLICY_REPLICA_SOURCE_INFO PolicyReplicaSourceInfo;
    PPOLICY_AUDIT_FULL_QUERY_INFO PolicyAuditFullQueryInfo;
    PLSARM_POLICY_AUDIT_EVENTS_INFO DbPolicyAuditEventsInfo = NULL;
    ULONG PolicyAuditEventsInfoLength = sizeof (LSARM_POLICY_AUDIT_EVENTS_INFO);
    ULONG AttributeCount = 0;
    ULONG AttributeNumber = 0;
    ULONG AuditListCopySize;
    PVOID InformationBuffer = NULL;
    LSAP_DB_ATTRIBUTE Attributes[LSAP_DB_ATTRS_INFO_CLASS_POLICY];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    BOOLEAN ObjectReferenced = FALSE;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) PolicyHandle;
    BOOLEAN InfoBufferInAttributeArray = TRUE;
    BOOLEAN BufferProvided = FALSE;
    PVOID FreeList[ 4 ];
    ULONG FreeCount = 0;

    LsapEnterFunc( "LsapDbSlowQueryInformationPolicy" );

    if (*Buffer != NULL) {

        BufferProvided = TRUE;
    }

    //
    // Compile a list of the attributes that hold the Policy Information of
    // the specified class.
    //

    NextAttribute = Attributes;

    switch (InformationClass) {

    case PolicyAuditLogInformation:

        //
        // Request read of the Audit Log Information.
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolAdtLg,
            NULL,
            sizeof(POLICY_AUDIT_LOG_INFO),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;
        break;

    case PolicyAuditEventsInformation:

        //
        // Request read of the Audit Events Information.
        // intermediate buffer.
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolAdtEv,
            NULL,
            sizeof(LSARM_POLICY_AUDIT_EVENTS_INFO),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;
        break;

    case PolicyDnsDomainInformation:

        //
        // Request read of the Dns Domain Name attribute
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolDnDDN,
            NULL,
            0,
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Request read of the Dns Tree Name attribute
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolDnTrN,
            NULL,
            0,
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Request read of the Dns Domain Guid attribute
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolDnDmG,
            NULL,
            0,
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // FALL THROUGH to PolicyPrimaryDomainInformation
        //

    case PolicyPrimaryDomainInformation:

        //
        // Request read of the DomainName attribute
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolPrDmN,
            NULL,
            0,
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Request read of the Sid attribute
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolPrDmS,
            NULL,
            0,
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        break;

    case PolicyAccountDomainInformation:

        //
        // Request read of the DomainName attribute
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolAcDmN,
            NULL,
            0,
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Request read of the Sid attribute
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolAcDmS,
            NULL,
            0,
            FALSE
            );

        NextAttribute++;
        AttributeCount++;
        break;

    case PolicyPdAccountInformation:

        //
        // Request read of the DomainName attribute
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolPdAcN,
            NULL,
            0,
            FALSE
            );

        NextAttribute++;
        AttributeCount++;
        break;

    case PolicyReplicaSourceInformation:

        //
        // Request read of the Replica Source attribute
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolRepSc,
            NULL,
            0,
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Request read of the Replica Account Name attribute
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolRepAc,
            NULL,
            0,
            FALSE
            );

        NextAttribute++;
        AttributeCount++;
        break;

    case PolicyDefaultQuotaInformation:

        //
        // Request read of the Default Quota attribute.
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            DefQuota,
            NULL,
            sizeof (POLICY_DEFAULT_QUOTA_INFO),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;
        break;

    case PolicyModificationInformation:

        //
        // Request read of the Policy Modification Information
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolMod,
            NULL,
            sizeof (POLICY_MODIFICATION_INFO),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;
        break;

    case PolicyAuditFullQueryInformation:

        Status = STATUS_NOT_SUPPORTED;
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto SlowQueryInformationPolicyError;
    }

    //
    //
    // Read the attributes corresponding to the given Policy Information
    // Class.  Memory will be allocated where required for output
    // Attribute Value buffers, via MIDL_user_allocate().
    //

    Status = LsapDbReadAttributesObject( PolicyHandle,
                                         0,
                                         Attributes,
                                         AttributeCount );

    if (!NT_SUCCESS(Status)) {

        //
        // Some attributes may not exist because they were never set
        // or were deleted because they were set to NULL values.
        //

        if (Status != STATUS_OBJECT_NAME_NOT_FOUND ) {

             goto SlowQueryInformationPolicyError;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // Now copy the information read to the output.  The following flags
    // are used to control freeing of memory buffers:
    //
    // InfoBufferInAttributeArray
    //
    // If set to TRUE (the default), the information to be returned to
    // the caller consists of a single buffer which was read directly
    // from a single attribute of the Policy object and can be returned
    // as is to the caller.  The information buffer being returned is
    // therefore referenced by the single Attribute Information block's
    // AttributeValue field.
    //
    // If set to FALSE, the information to be returned to the caller
    // does not satisfy the above.  The information to be returned is
    // either obtained from a single attribute, but is in a different form
    // from that read from the Database, or it is complex, consisting
    // of information read from multiple attributes, hung off a top-level
    // node.  In these cases, the top level information buffer is not
    // referenced by any member of the Attribute Info Array.
    //
    // Attribute->MemoryAllocated
    //
    // When an attribute is read via LsapDbReadAttributesObject, this
    // field is set to TRUE to indicate that memory was allocated via
    // MIDL_user_allocate() for the AttributeValue.  If this memory
    // buffer is to be returned to the caller (i.e. referenced from
    // the output structure graph returned), it is set to FALSE so that
    // the normal success finish part of this routine will not free it.
    // In this case, the calling server RPC stub will free the memory after
    // marshalling its contents into the return buffer.  If this memory
    // buffer is not to be returned to the calling RPC server stub (because
    // the memory is an intermediate buffer), the field is left set to TRUE
    // so that normal cleanup will free it.
    //

    NextAttribute = Attributes;

    switch (InformationClass) {

    case PolicyAuditLogInformation:

        InformationBuffer = NextAttribute->AttributeValue;

        //
        // We can use this buffer as is, so we don't want to free it here.
        //

        NextAttribute->MemoryAllocated = FALSE;
        break;

    case PolicyAuditEventsInformation:

        //
        // An intermediate buffer is required, because the Audit Events
        // read from the database are in a different form from those
        // returned.
        //

        DbPolicyAuditEventsInfo = NextAttribute->AttributeValue;
        InfoBufferInAttributeArray = FALSE;

        //
        // Allocate Buffer for output in final format.  This differs
        // slightly from the self-relative format in which this
        // Information Class is stored.
        //

        PolicyAuditEventsInfo = MIDL_user_allocate(sizeof (POLICY_AUDIT_EVENTS_INFO));


        if (PolicyAuditEventsInfo == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        FreeList[ FreeCount++ ] = PolicyAuditEventsInfo;

        //
        // Need to allocate memory via MIDL_user_allocate for the
        // EventAuditingOptions pointer since we are not using
        // the midl allocate_all_nodes feature for the LSAPR_POLICY_INFORMATION
        // structure graph on this server side.
        //
        PolicyAuditEventsInfo->EventAuditingOptions =
                                        MIDL_user_allocate( LSARM_AUDIT_EVENT_OPTIONS_SIZE );


        if (PolicyAuditEventsInfo->EventAuditingOptions == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        FreeList[ FreeCount++ ] = PolicyAuditEventsInfo->EventAuditingOptions;

        RtlZeroMemory( PolicyAuditEventsInfo->EventAuditingOptions,
                        LSARM_AUDIT_EVENT_OPTIONS_SIZE );

        //
        // If Policy Audit Event Info was read from the LSA Database, copy
        // its fields to output, otherwise return values with Auditing
        // Disabled and no Auditing set foro any Event Types.
        //

        if (DbPolicyAuditEventsInfo != NULL) {

            PolicyAuditEventsInfo->AuditingMode = DbPolicyAuditEventsInfo->AuditingMode;
            PolicyAuditEventsInfo->MaximumAuditEventCount =
                                        DbPolicyAuditEventsInfo->MaximumAuditEventCount;

            //
            // We need to be careful here.  NT4 stored registry information as:
            // AuditMode - List of Audit Event Entries - Audit Entries Count.
            // Since NT5 added additional audit events, we need to handle that case here...
            //
            AuditListCopySize = POLICY_AUDIT_EVENT_TYPE_COUNT;
            if ( NextAttribute->AttributeValueLength / sizeof( POLICY_AUDIT_EVENT_OPTIONS ) !=
                                                            POLICY_AUDIT_EVENT_TYPE_COUNT + 2 ) {

                ASSERT( NextAttribute->AttributeValueLength / sizeof( POLICY_AUDIT_EVENT_OPTIONS ) ==
                                                            POLICY_AUDIT_EVENT_TYPE_COUNT );

                AuditListCopySize -= 2;

            }

            //
            // Copy over the Event Auditing Options
            //
            RtlCopyMemory(
                PolicyAuditEventsInfo->EventAuditingOptions,
                DbPolicyAuditEventsInfo->EventAuditingOptions,
                AuditListCopySize  * sizeof( POLICY_AUDIT_EVENT_OPTIONS ) );

            PolicyAuditEventsInfo->MaximumAuditEventCount = AuditListCopySize;

        } else {

            PolicyAuditEventsInfo->AuditingMode = FALSE;
            PolicyAuditEventsInfo->MaximumAuditEventCount = POLICY_AUDIT_EVENT_TYPE_COUNT;

        }

        InformationBuffer = PolicyAuditEventsInfo;
        break;

    case PolicyDnsDomainInformation:

        //
        // Allocate memory for output buffer top-level structure.
        //
        InfoBufferInAttributeArray = FALSE;
        PolicyDnsDomainInfo = MIDL_user_allocate(sizeof(POLICY_DNS_DOMAIN_INFO));

        if (PolicyDnsDomainInfo == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        FreeList[ FreeCount++ ] = PolicyDnsDomainInfo;

        //
        // Copy the DnsDomain Name field to the output. Original buffer will
        // be freed in Finish section.
        //
        if ( LsaISafeMode() ) {

            RtlInitUnicodeString( &PolicyDnsDomainInfo->DnsDomainName, NULL );

        } else {

            Status = LsapDbCopyUnicodeAttribute(
                         &PolicyDnsDomainInfo->DnsDomainName,
                         NextAttribute,
                         TRUE
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

        }

        FreeList[ FreeCount++ ] = PolicyDnsDomainInfo->DnsDomainName.Buffer;

        NextAttribute++;

        //
        // Next, the Dns tree name
        if ( LsaISafeMode() ) {

            RtlInitUnicodeString( &PolicyDnsDomainInfo->DnsForestName, NULL );

        } else {

            Status = LsapDbCopyUnicodeAttribute(
                         &PolicyDnsDomainInfo->DnsForestName,
                         NextAttribute,
                         TRUE
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }
        }

        FreeList[ FreeCount++ ] = PolicyDnsDomainInfo->DnsForestName.Buffer;

        NextAttribute++;

        //
        // Next, the Domain Guid
        //
        if ( LsaISafeMode() ) {

            RtlZeroMemory(&PolicyDnsDomainInfo->DomainGuid, sizeof(GUID));

        } else {

            if(NextAttribute->AttributeValue != NULL) {

                RtlCopyMemory(&PolicyDnsDomainInfo->DomainGuid,
                              NextAttribute->AttributeValue,
                              sizeof(GUID));
            } else {

                RtlZeroMemory(&PolicyDnsDomainInfo->DomainGuid, sizeof(GUID));
            }
        }

        NextAttribute++;

        //
        // Copy the primary domain name field from the Primary Domain information buffer
        //

        if ( LsaISafeMode() ) {

            WCHAR Workgroup[] =  L"WORKGROUP";
            LPWSTR Buffer = midl_user_allocate( sizeof(Workgroup) );
            if ( !Buffer ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            wcscpy( Buffer, Workgroup );
            RtlInitUnicodeString( &PolicyDnsDomainInfo->Name, Buffer );

        } else {

            Status = LsapDbCopyUnicodeAttribute(
                        &PolicyDnsDomainInfo->Name,
                        NextAttribute,
                        TRUE
                        );

            if (!NT_SUCCESS(Status)) {

                break;
            }

        }

        FreeList[ FreeCount++ ] = PolicyDnsDomainInfo->Name.Buffer;

        NextAttribute++;

        //
        // Finally, the domain SID
        //
        if ( LsaISafeMode() ) {

            PolicyDnsDomainInfo->Sid = NULL;

        } else {

            PolicyDnsDomainInfo->Sid = (PSID) NextAttribute->AttributeValue;
            NextAttribute->MemoryAllocated = FALSE;
        }


        InformationBuffer = PolicyDnsDomainInfo;
        break;

    case PolicyPrimaryDomainInformation:

        //
        // Allocate memory for output buffer top-level structure.
        //

        InfoBufferInAttributeArray = FALSE;
        PolicyPrimaryDomainInfo =
            MIDL_user_allocate(sizeof (POLICY_PRIMARY_DOMAIN_INFO));

        if (PolicyPrimaryDomainInfo == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        FreeList[ FreeCount++ ] = PolicyPrimaryDomainInfo;

        //
        // Copy the Unicode Name field to the output. Original buffer will
        // be freed in Finish section.
        //

        if ( LsaISafeMode() ) {

            WCHAR Workgroup[] =  L"WORKGROUP";
            LPWSTR Buffer = midl_user_allocate( sizeof(Workgroup) );
            if ( !Buffer ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            wcscpy( Buffer, Workgroup );
            RtlInitUnicodeString( &PolicyPrimaryDomainInfo->Name, Buffer );

        } else {

            Status = LsapDbCopyUnicodeAttribute(
                        &PolicyPrimaryDomainInfo->Name,
                        NextAttribute,
                        TRUE
                        );

            if (!NT_SUCCESS(Status)) {

                break;
            }

        }

        FreeList[ FreeCount++ ] = PolicyPrimaryDomainInfo->Name.Buffer;
        NextAttribute++;

        //
        // Copy the Sid to the output.  We can use this buffer as is
        // since it was allocated via MIDL_user_allocate, so just copy the
        // buffer pointer and clear the MemoryAllocated flag in the
        // attribute information so we don't free it in the Finish section.
        //
        if ( LsaISafeMode() ) {

            PolicyPrimaryDomainInfo->Sid = NULL;

        } else {

            PolicyPrimaryDomainInfo->Sid = (PSID) NextAttribute->AttributeValue;
            NextAttribute->MemoryAllocated = FALSE;

        }


        InformationBuffer = PolicyPrimaryDomainInfo;
        break;

    case PolicyAccountDomainInformation:

        //
        // Allocate memory for output buffer top-level structure.
        //

        InfoBufferInAttributeArray = FALSE;
        PolicyAccountDomainInfo =
            MIDL_user_allocate(sizeof(POLICY_ACCOUNT_DOMAIN_INFO));


        if (PolicyAccountDomainInfo == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        FreeList[ FreeCount++ ] = PolicyAccountDomainInfo;

        //
        // Copy the Unicode DomainName field to the output. Original buffer will
        // be freed in Finish section.
        //
        if ( LsaISafeMode() ) {

            WCHAR Buffer[MAX_COMPUTERNAME_LENGTH+1];
            ULONG Size = sizeof(Buffer)/sizeof(Buffer[0]);

            Status = STATUS_INSUFFICIENT_RESOURCES;
            if ( GetComputerName( Buffer, &Size) ) {
                LPWSTR String = MIDL_user_allocate( (Size+1)*sizeof(Buffer[0]) );
                if ( String ) {
                    wcscpy( String, Buffer );
                    RtlInitUnicodeString( &PolicyAccountDomainInfo->DomainName,
                                          String );
                    Status = STATUS_SUCCESS;
                }
            }

        } else {

            Status = LsapDbCopyUnicodeAttribute(
                         &PolicyAccountDomainInfo->DomainName,
                         NextAttribute,
                         TRUE
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

        }

        FreeList[ FreeCount++ ] = PolicyAccountDomainInfo->DomainName.Buffer;
        NextAttribute++;

        //
        // Copy the Sid to the output.  We can use this buffer as is
        // since it was allocated via MIDL_user_allocate, so just copy the
        // buffer pointer and clear the MemoryAllocated flag in the
        // attribute information so we don't free it in the Finish section.
        //

        PolicyAccountDomainInfo->DomainSid = (PSID) NextAttribute->AttributeValue;

        InformationBuffer = PolicyAccountDomainInfo;
        NextAttribute->MemoryAllocated = FALSE;
        break;

    case PolicyPdAccountInformation:

        //
        // Allocate memory for output buffer top-level structure.
        //

        InfoBufferInAttributeArray = FALSE;
        PolicyPdAccountInfo = MIDL_user_allocate(sizeof(POLICY_PD_ACCOUNT_INFO));


        if (PolicyPdAccountInfo == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        FreeList[ FreeCount++ ] = PolicyPdAccountInfo;

        //
        // Copy the Unicode Name field to the output. Original buffer will
        // be freed in Finish section.
        //

        Status = LsapDbCopyUnicodeAttribute(
                     &PolicyPdAccountInfo->Name,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        FreeList[ FreeCount++ ] = PolicyPdAccountInfo->Name.Buffer;

        InformationBuffer = PolicyPdAccountInfo;
        break;

    case PolicyLsaServerRoleInformation:

        //
        // We can use this buffer as is, so we don't want to free it here.
        //

        InformationBuffer = NextAttribute->AttributeValue;
        NextAttribute->MemoryAllocated = FALSE;
        break;

    case PolicyReplicaSourceInformation:

        //
        // Allocate memory for output buffer top-level structure.
        //

        InfoBufferInAttributeArray = FALSE;
        PolicyReplicaSourceInfo =
            MIDL_user_allocate(sizeof(POLICY_REPLICA_SOURCE_INFO));


        if (PolicyReplicaSourceInfo == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        FreeList[ FreeCount++ ] = PolicyReplicaSourceInfo;
        //
        // Copy the Unicode ReplicaSource field to the output. Original buffer will
        // be freed in Finish section.
        //

        Status = LsapDbCopyUnicodeAttribute(
                     &PolicyReplicaSourceInfo->ReplicaSource,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        FreeList[ FreeCount++ ] = PolicyReplicaSourceInfo->ReplicaSource.Buffer;
        NextAttribute++;

        //
        // Copy the Unicode ReplicaAccountName field to the output. Original buffer will
        // be freed in Finish section.
        //

        Status = LsapDbCopyUnicodeAttribute(
                     &PolicyReplicaSourceInfo->ReplicaAccountName,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        FreeList[ FreeCount++ ] = PolicyReplicaSourceInfo->ReplicaAccountName.Buffer;

        InformationBuffer = PolicyReplicaSourceInfo;
        break;

    case PolicyDefaultQuotaInformation:

        //
        // We can use this buffer as is, so we don't want to free it here.
        //

        InformationBuffer = NextAttribute->AttributeValue;
        NextAttribute->MemoryAllocated = FALSE;
        break;

    case PolicyModificationInformation:

        //
        // We can use this buffer as is, so we don't want to free it here.
        //

        InformationBuffer = NextAttribute->AttributeValue;
        NextAttribute->MemoryAllocated = FALSE;
        break;

    case PolicyAuditFullSetInformation:

        Status = STATUS_NOT_SUPPORTED;
        break;

    case PolicyAuditFullQueryInformation:

        Status = STATUS_NOT_SUPPORTED;
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto SlowQueryInformationPolicyError;
    }

    //
    // Verify that the returned Policy Information is valid. If not,
    // the Policy Database is corrupt.
    //

    if (!LsapDbValidInfoPolicy(InformationClass, InformationBuffer)) {

        ASSERT( FALSE );
        Status = STATUS_INTERNAL_DB_CORRUPTION;
        PolicyAccountDomainInfo = InformationBuffer;
        goto SlowQueryInformationPolicyError;
    }

    //
    // If the caller provided a buffer, return information there.
    //

    if (BufferProvided && InformationBuffer) {

        RtlCopyMemory(
            *Buffer,
            InformationBuffer,
            LsapDbPolicy.Info[ InformationClass ].AttributeLength
            );

        MIDL_user_free( InformationBuffer );
        InformationBuffer = NULL;

    } else {

        *Buffer = InformationBuffer;
    }

SlowQueryInformationPolicyFinish:

    //
    // Free any unwanted buffers that were allocated by
    // LsapDbReadAttributesObject() and that are not being returned to the
    // caller server stub.  The server stub will free the buffers that we
    // do return after copying them to the return RPC transmit buffer.
    //

    for (NextAttribute = Attributes, AttributeNumber = 0;
         AttributeNumber < AttributeCount;
         NextAttribute++, AttributeNumber++) {

        //
        // If buffer holding attribute is marked as allocated, it is
        // to be freed here.
        //

        if (NextAttribute->MemoryAllocated) {

           if (NextAttribute->AttributeValue != NULL) {

                MIDL_user_free(NextAttribute->AttributeValue);
                NextAttribute->AttributeValue = NULL;
                NextAttribute->MemoryAllocated = FALSE;
            }
        }
    }

    LsapExitFunc( "LsapDbSlowQueryInformationPolicy", Status );

    return(Status);

SlowQueryInformationPolicyError:

    //
    // If necessary, free the memory allocated for the output buffer.
    // We only do this free if the buffer is not referenced by the
    // attribute array, since all buffers so referenced will be freed
    // here or in the Finish section.
    //

    if ((InformationBuffer != NULL) && !InfoBufferInAttributeArray) {

        MIDL_user_free(InformationBuffer);
        InformationBuffer = NULL;
    }

    //
    // Free the buffers referenced by the attributes array that will not be
    // freed by the Finish section of this routine.
    //

    for (NextAttribute = Attributes, AttributeNumber = 0;
         AttributeNumber < AttributeCount;
         NextAttribute++, AttributeNumber++) {

        //
        // If buffer holding attribute is marked as normally not to be freed,
        // will not get freed by the Finish section so it must be freed here.
        //

        if (!NextAttribute->MemoryAllocated) {

            if (NextAttribute->AttributeValue != NULL) {

                MIDL_user_free(NextAttribute->AttributeValue);
                NextAttribute->AttributeValue = NULL;
                NextAttribute->MemoryAllocated = FALSE;
            }

            NextAttribute->MemoryAllocated = FALSE;
        }
    }

    //
    // Free the free list, if it exists.  Always delete the list backwards - the opposite order
    // of allocation
    //

    ASSERT( FreeCount < sizeof( FreeList ) / sizeof( PVOID ) );
    while( FreeCount != 0 ) {

        MIDL_user_free( FreeList[ FreeCount - 1 ]);
        FreeCount--;
    }

    goto SlowQueryInformationPolicyFinish;
}


NTSTATUS
LsarSetInformationPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaSetInformationPolicy API.

    The LsaSetInformationPolicy API modifies information in the Policy Object.
    The caller must have access appropriate to the information to be changed
    in the Policy Object, see the InformationClass parameter.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the type of information being changed.
        The information types and accesses required to change them are as
        follows:

        PolicyAuditLogInformation         POLICY_AUDIT_LOG_ADMIN
        PolicyAuditEventsInformation      POLICY_SET_AUDIT_REQUIREMENTS
        PolicyPrimaryDomainInformation    POLICY_TRUST_ADMIN
        PolicyAccountDomainInformation    POLICY_TRUST_ADMIN
        PolicyPdAccountInformation        Not settable by this API
        PolicyLsaServerRoleInformation    POLICY_SERVER_ADMIN
        PolicyReplicaSourceInformation    POLICY_SERVER_ADMIN
        PolicyDefaultQuotaInformation     POLICY_SET_DEFAULT_QUOTA_LIMITS
        PolicyAuditFullSetInformation     POLICY_AUDIT_LOG_ADMIN
        PolicyDnsDomainInformation        POLICY_TRUST_ADMIN
        PolicyDnsDomainInformationInt     POLICY_TRUST_ADMIN

    Buffer - Points to a structure containing the information appropriate
        to the information type specified by the InformationClass parameter.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        Others TBS
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ACCESS_MASK DesiredAccess;
    ULONG ReferenceOptions, DereferenceOptions;
    BOOLEAN ScePolicyLocked = FALSE;
    BOOLEAN NotifySce = FALSE;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) PolicyHandle;

    LsarpReturnCheckSetup();

    LsapEnterFunc( "LsarSetInformationPolicy" );

    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_SetInformationPolicy);

    //
    // If NT4 emulation is enabled, fail requests for PolicyDnsDomainInformation
    // as if they weren't implemented
    //

    if ( LsapDbState.EmulateNT4 &&
         InformationClass == PolicyDnsDomainInformation &&
         !InternalHandle->Trusted ) {

         RaiseException( RPC_NT_PROCNUM_OUT_OF_RANGE, 0, 0, NULL );

    } else if ( InformationClass == PolicyDnsDomainInformationInt ) {

        //
        // PolicyDnsDomainInformationInt is a request to override
        // NT4 emulation
        //

        InformationClass = PolicyDnsDomainInformation;
    }

    //
    // Grab the SCE policy lock for information classes for which SCE
    // notifications are expected.
    //

    if ( InformationClass == PolicyAuditEventsInformation ) {

        LSAP_DB_HANDLE InternalHandle = ( LSAP_DB_HANDLE )PolicyHandle;

        //
        // Do not grab the SCE policy lock for handles opened as SCE policy handles
        //

        if ( !InternalHandle->SceHandle ) {

            RtlEnterCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );
            if ( LsapDbState.ScePolicyLock.NumberOfWaitingShared > MAX_SCE_WAITING_SHARED ) {

                Status = STATUS_TOO_MANY_THREADS;
            }
            RtlLeaveCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );

            if ( !NT_SUCCESS( Status )) {

                goto Cleanup;
            }

            WaitForSingleObject( LsapDbState.SceSyncEvent, INFINITE );
            RtlAcquireResourceShared( &LsapDbState.ScePolicyLock, TRUE );
            ASSERT( !g_ScePolicyLocked );
            ScePolicyLocked = TRUE;
            NotifySce = TRUE;
        }
    }

    Status = LsapDbVerifyInfoSetPolicy(
                 PolicyHandle,
                 InformationClass,
                 PolicyInformation,
                 &DesiredAccess
                 );

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    //
    // Set the options for referencing the Policy Object.  We need to
    // acquire the LSA Database Lock and start a transaction.  Normally,
    // the object reference routine will disallow updates to a Backup
    // Domain Controller from non-trusted clients, but a non-trusted
    // client is allowed to revert the server role to Primary Controller.
    // A special flag is used to allow this operation to go through.
    //

    ReferenceOptions = LSAP_DB_START_TRANSACTION |
                          LSAP_DB_NO_DS_OP_TRANSACTION;

    DereferenceOptions = LSAP_DB_FINISH_TRANSACTION |
                            LSAP_DB_NO_DS_OP_TRANSACTION;


    //
    // If we are setting the Policy Audit Log Information, we may need
    // the Audit Log Queue Lock.
    //

    if (InformationClass == PolicyAuditLogInformation) {

        ReferenceOptions |= (LSAP_DB_LOG_QUEUE_LOCK | LSAP_DB_OMIT_REPLICATOR_NOTIFICATION);
        DereferenceOptions |= LSAP_DB_LOG_QUEUE_LOCK;
    }

    //
    // If we're setting the server role, don't hold a lock
    //
    if ( InformationClass != PolicyLsaServerRoleInformation ) {

        ReferenceOptions |= LSAP_DB_LOCK;
        DereferenceOptions |= LSAP_DB_LOCK;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the handle is
    // valid, is a handle to the Policy Object and has the necessary accesses
    // granted.  Reference the handle and start an Lsa Database transaction.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 DesiredAccess,
                 PolicyObject,
                 PolicyObject,
                 ReferenceOptions
                 );

    if (NT_SUCCESS(Status)) {

        //
        // Special case the ServerRole information.  This information is not stored exclusively in
        // SAM, so we need to read it directly from there
        //

        if ( InformationClass == PolicyLsaServerRoleInformation ) {

            DOMAIN_SERVER_ROLE SamServerRole;

            //
            // SamIDoFSMORoleChange goes off machine to do its work so do this outside
            // of an LSA policy lock
            //

            Status = LsapDbDereferenceObject(
                         &PolicyHandle,
                         PolicyObject,
                         PolicyObject,
                         DereferenceOptions,
                         SecurityDbChange,
                         Status
                         );

            if ( !NT_SUCCESS( Status )) {

                goto Cleanup;
            }

            Status = LsapOpenSam();
            if ( !NT_SUCCESS( Status )  ) {

                LsapDsDebugOut(( DEB_ERROR,
                                 "LsarSetInformationPolicy: Sam not opened\n"));
                goto Cleanup;

            }

            SamServerRole = ( DOMAIN_SERVER_ROLE )(((PPOLICY_LSA_SERVER_ROLE_INFO)PolicyInformation)->LsaServerRole);

            if ( SamServerRole == DomainServerRolePrimary ) {

                Status = SamIDoFSMORoleChange( LsapAccountDomainHandle );

                if ( !NT_SUCCESS( Status ) ) {

                    LsapDsDebugOut(( DEB_ERROR,
                                     "SamIDoFSMORoleChange failed with %lu\n", Status ));
                }

            } else if ( SamServerRole == DomainServerRoleBackup ) {

                //
                // Do nothing: you do not give up the FSMO, someone grabs it
                //

            } else {

                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

        } else {

            Status = LsapDbSetInformationPolicy( PolicyHandle,
                                                 InformationClass,
                                                 PolicyInformation );

            Status = LsapDbDereferenceObject(
                         &PolicyHandle,
                         PolicyObject,
                         PolicyObject,
                         DereferenceOptions,
                         SecurityDbChange,
                         Status
                         );
        }
    }

Cleanup:

    //
    // Notify SCE of the change.  Only notify for callers
    // that did not open their policy handles with LsaOpenPolicySce.
    //

    if ( NotifySce && NT_SUCCESS( Status )) {

        LsapSceNotify(
            SecurityDbChange,
            SecurityDbObjectLsaPolicy,
            NULL
            );
    }

    if ( ScePolicyLocked ) {

        RtlReleaseResource( &LsapDbState.ScePolicyLock );
    }

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_SetInformationPolicy);
    LsapExitFunc( "LsarSetInformationPolicy", Status );
    LsarpReturnPrologue();

    return(Status);
}


NTSTATUS
LsapDbSetInformationPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation
    )
/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaSetInformationPolicy API.

    The LsaSetInformationPolicy API modifies information in the Policy Object.
    The caller must have access appropriate to the information to be changed
    in the Policy Object, see the InformationClass parameter.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the type of information being changed.
        The information types and accesses required to change them are as
        follows:

        PolicyAuditLogInformation         POLICY_AUDIT_LOG_ADMIN
        PolicyAuditEventsInformation      POLICY_SET_AUDIT_REQUIREMENTS
        PolicyPrimaryDomainInformation    POLICY_TRUST_ADMIN
        PolicyAccountDomainInformation    POLICY_TRUST_ADMIN
        PolicyPdAccountInformation        Not settable by this API
        PolicyLsaServerRoleInformation    POLICY_SERVER_ADMIN
        PolicyReplicaSourceInformation    POLICY_SERVER_ADMIN
        PolicyDefaultQuotaInformation     POLICY_SET_DEFAULT_QUOTA_LIMITS
        PolicyAuditFullSetInformation     POLICY_AUDIT_LOG_ADMIN
        PolicyDnsDomainInformation        POLICY_TRUST_ADMIN

    Buffer - Points to a structure containing the information appropriate
        to the information type specified by the InformationClass parameter.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        Others TBS
--*/
{
    NTSTATUS Status, SavedStatus;
    ACCESS_MASK DesiredAccess;

    PPOLICY_AUDIT_EVENTS_INFO ModifyPolicyAuditEventsInfo;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;
    PPOLICY_PRIMARY_DOMAIN_INFO PolicyPrimaryDomainInfo;
    PPOLICY_REPLICA_SOURCE_INFO PolicyReplicaSourceInfo;
    PPOLICY_DEFAULT_QUOTA_INFO PolicyDefaultQuotaInfo;
    PPOLICY_MODIFICATION_INFO PolicyModificationInfo;
    PPOLICY_AUDIT_FULL_SET_INFO PolicyAuditFullSetInfo;
    PPOLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfo, CurrentDnsDomainInfo = NULL;

    POLICY_DNS_DOMAIN_INFO  DnsDomainInfo;


    LSAP_DB_ATTRIBUTE Attributes[LSAP_DB_ATTRS_INFO_CLASS_POLICY];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    ULONG AttributeCount = 0;
    ULONG AttributeNumber;
    POLICY_AUDIT_EVENT_TYPE AuditEventType;
    PLSARM_POLICY_AUDIT_EVENTS_INFO PreviousPolicyAuditEventsInfo = NULL;
    PLSARM_POLICY_AUDIT_EVENTS_INFO UpdatedPolicyAuditEventsInfo = NULL;
    ULONG UpdatedPolicyAuditEventsInfoLength;
    ULONG UpdatedMaximumAuditEventCount;
    ULONG ModifyMaximumAuditEventCount;
    PPOLICY_AUDIT_EVENT_OPTIONS UpdatedEventAuditingOptions;
    PPOLICY_AUDIT_EVENT_OPTIONS ModifyEventAuditingOptions;
    PPOLICY_AUDIT_EVENT_OPTIONS PreviousEventAuditingOptions;
    ULONG PolicyAuditEventsInfoLength = sizeof (LSARM_POLICY_AUDIT_EVENTS_INFO);
    ULONG PreviousPolicyAuditEventsInfoLength = sizeof (LSARM_POLICY_AUDIT_EVENTS_INFO);
    BOOLEAN NeedToFreeUpdatedPolicyAuditEventsInfo = FALSE;
    PUNICODE_STRING DomainName = NULL;
    PUNICODE_STRING AccountName = NULL;
    PUNICODE_STRING ReplicaSource = NULL;
    BOOLEAN ObjectReferenced = FALSE;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) PolicyHandle;
    ULONG NewMaximumAuditEventCount = 0;
    BOOLEAN PreviousAuditEventsInfoExists;
    POLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo;

    PLSAPR_TRUST_INFORMATION TrustInformation = NULL;
    BOOLEAN WerePolicyChangesAuditedBefore = FALSE;
    POLICY_NOTIFICATION_INFORMATION_CLASS NotifyClass = 0;
    BOOLEAN NotifyPolicyChange = FALSE;
    BOOLEAN DnsDomainNameTruncated;
    BOOLEAN DnsForestNameTruncated;

    LsapEnterFunc( "LsapDbSetInformationPolicy" );

    //
    // Validate the Information Class and Policy Information provided and
    // if valid, return the mask of accesses required to update this
    // class of policy information.
    //

    Status = LsapDbVerifyInfoSetPolicy(
                 PolicyHandle,
                 InformationClass,
                 PolicyInformation,
                 &DesiredAccess
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetInformationPolicyError;
    }

    //
    // Update the specified information in the Policy Object.
    //

    NextAttribute = Attributes;

    switch (InformationClass) {

    case PolicyLsaServerRoleInformation:

        Status = STATUS_NOT_IMPLEMENTED;
        break;

    case PolicyAuditLogInformation:

        {
            //
            // This operation is no longer supported.  Return an
            // error to anyone who tries except trusted clients who
            // are just blindly replcate the entire database.
            //

            LSAP_DB_HANDLE InternalHandle = PolicyHandle;

            if (!InternalHandle->Trusted) {

                Status = STATUS_NOT_IMPLEMENTED;
            }
        }

        break;

    case PolicyAuditEventsInformation:

        //
        // NOTE: If turning Auditing back on and the LogIsFull state is set,
        // it is automatically cleared.  When the Audit Log becomes full and
        // the system is shutdown, auditing is automatically disabled upon
        // reboot.  The user is forced to log on as Administrator to clear
        // the log, or modify its size/retention.  When Auditing is turned
        // back on, the LogIsFull state is automatically cleared.
        //
        // IMPORTANT:  To allow new Audit Event Types to be added to the
        // system in successive versions, this code caters for the
        // following situations:
        //
        // (1)  The LSA Database is older than the present system and
        //      contains information for fewer Audit Event Types than
        //      currently supported.
        //
        // (2)  The client code is older than the present system and
        //      specifies fewer Audit Event Types than currently supported.
        //      In this case, the newer options will be left unchanged.
        //
        // In all cases, the updated information written to the LSA Database
        // and transmitted to the Reference Monitor within the Nt Executive
        // contains Event Auditing Options for every Audit Event Type
        // currently supported.
        //
        // Additionally, this code caters for old LSA Databases that have
        // no default Audit Event Information.  This is a very temporary
        // situation, since installation now initializes this information.
        //
        // If no information has been provided or there is more information
        // than the current Audit Event Info structure holds, return an error.
        // Note that the caller is allowed to specify infomration for
        // the firt n Audit Events, where n is less than the current
        // number the system supports.  This allows new events to be
        // added without the need to change calling code.
        //

        WerePolicyChangesAuditedBefore = (BOOLEAN) LsapAdtAuditingPolicyChanges();

        ModifyPolicyAuditEventsInfo = (PPOLICY_AUDIT_EVENTS_INFO) PolicyInformation;

        Status = STATUS_INVALID_PARAMETER;

        if (ModifyPolicyAuditEventsInfo == NULL) {

             break;
        }

        UpdatedMaximumAuditEventCount = POLICY_AUDIT_EVENT_TYPE_COUNT;

        //
        //
        // The following check is disabled so that replication will work when
        // reading from a PDC with pre-Build 354 Auditing Event Information
        // in which there were 12 categories.
        //
        //
        // if (ModifyPolicyAuditEventsInfo->MaximumAuditEventCount >
        //     UpdatedMaximumAuditEventCount) {
        //
        //     break;
        // }
        //

        if (ModifyPolicyAuditEventsInfo->MaximumAuditEventCount == 0) {

            break;
        }

        //
        // Read Existing Audit Events.  Specify NULL for the buffer pointer
        // so that the read routine will allocate the buffer for us.
        // Specify 0 for the length, because we don't know what it is.
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolAdtEv,
            NULL,
            0,
            FALSE
            );


        Status = LsapDbReadAttribute( PolicyHandle, NextAttribute );


        if (NT_SUCCESS(Status)) {

            PreviousPolicyAuditEventsInfo = NextAttribute->AttributeValue;

            if (PreviousPolicyAuditEventsInfo == NULL) {

                Status = STATUS_INTERNAL_DB_CORRUPTION;
                break;
            }

            PreviousPolicyAuditEventsInfoLength = NextAttribute->AttributeValueLength;
            PreviousAuditEventsInfoExists = TRUE;

        } else {

            //
            // Unable to read existing Audit Event Options.  If this is
            // because there is no Audit Event Information in an old
            // Database, then, temorarily, we will proceed as if Auditing
            // and all Options were disabled.  NOTE: This situation will NOT
            // occur in the finished product.
            //

            if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

                break;
            }

            PreviousAuditEventsInfoExists = FALSE;
        }

        //
        // Setup a buffer to hold the updated Audit Event Information.
        // We try to use the existing buffer if possible.
        //

        if (PreviousAuditEventsInfoExists &&
            PreviousPolicyAuditEventsInfoLength == sizeof( LSARM_POLICY_AUDIT_EVENTS_INFO ) &&
            ( PreviousPolicyAuditEventsInfo->MaximumAuditEventCount ==
                                                    POLICY_AUDIT_EVENT_TYPE_COUNT &&
              ModifyPolicyAuditEventsInfo->MaximumAuditEventCount <=
                                PreviousPolicyAuditEventsInfo->MaximumAuditEventCount ) ) {

            //
            // There is an existing Audit Event Info buffer and it is
            // large enough so update it in situ.
            //

            UpdatedPolicyAuditEventsInfo = PreviousPolicyAuditEventsInfo;
            UpdatedPolicyAuditEventsInfoLength = PreviousPolicyAuditEventsInfoLength;
            UpdatedEventAuditingOptions = PreviousPolicyAuditEventsInfo->EventAuditingOptions;

        } else {

            //
            // There is either no existing buffer or it is not large
            // enough.   We need to allocate a new one for the updated
            // information.  This will store the number of Audit Event
            // Types that the system currently supports.
            //

            UpdatedPolicyAuditEventsInfoLength = sizeof (LSARM_POLICY_AUDIT_EVENTS_INFO);
            UpdatedPolicyAuditEventsInfo = MIDL_user_allocate( UpdatedPolicyAuditEventsInfoLength );

            if (UpdatedPolicyAuditEventsInfo == 0) {

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto SetInformationPolicyError;
            }

            NeedToFreeUpdatedPolicyAuditEventsInfo = TRUE;

            UpdatedPolicyAuditEventsInfo->AuditingMode = FALSE;
            UpdatedEventAuditingOptions =
            UpdatedPolicyAuditEventsInfo->EventAuditingOptions;

            for ( AuditEventType=0 ;
                  AuditEventType < (POLICY_AUDIT_EVENT_TYPE) UpdatedMaximumAuditEventCount ;
                  AuditEventType++ ) {

                UpdatedEventAuditingOptions[ AuditEventType ] = 0;
            }

            if (!PreviousAuditEventsInfoExists) {

                PreviousPolicyAuditEventsInfo = UpdatedPolicyAuditEventsInfo;
            }
        }

        //
        // Construct the updated Audit Event Info, applying the Modification
        // information provided.  Note that for an old database we may be
        // writing more info back than we read.
        //

        PreviousEventAuditingOptions = PreviousPolicyAuditEventsInfo->EventAuditingOptions;
        ModifyMaximumAuditEventCount = ModifyPolicyAuditEventsInfo->MaximumAuditEventCount;
        ModifyEventAuditingOptions = ModifyPolicyAuditEventsInfo->EventAuditingOptions;

        for ( AuditEventType = 0;
              AuditEventType < (POLICY_AUDIT_EVENT_TYPE) ModifyMaximumAuditEventCount;
              AuditEventType++ ) {

            if ( ModifyEventAuditingOptions[ AuditEventType ] & POLICY_AUDIT_EVENT_NONE ) {

                //
                // Clear all existing flags for this Audit Event Type.
                //

                UpdatedEventAuditingOptions[ AuditEventType ] = 0;

            }

            //
            // Apply new flags.
            //

            UpdatedEventAuditingOptions[ AuditEventType ] |=
                (ModifyEventAuditingOptions[ AuditEventType ] &
                        ( POLICY_AUDIT_EVENT_MASK & ~POLICY_AUDIT_EVENT_NONE));
        }

        //
        // Update the Auditing Mode as specified.  Set the Maximum Audit Event
        // Count.
        //

        UpdatedPolicyAuditEventsInfo->AuditingMode = ModifyPolicyAuditEventsInfo->AuditingMode;
        UpdatedPolicyAuditEventsInfo->MaximumAuditEventCount = UpdatedMaximumAuditEventCount;

        //
        // Update global variables that keep track of whether or not we
        // are auditing logon events
        //

        LsapAdtAuditingLogon( UpdatedPolicyAuditEventsInfo );

        //
        // Ship the new Auditing Options to the Kernel.
        //


        Status = LsapCallRm(
                     RmAuditSetCommand,
                     (PVOID) UpdatedPolicyAuditEventsInfo,
                     sizeof(LSARM_POLICY_AUDIT_EVENTS_INFO),
                     NULL,
                     0
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        RtlCopyMemory(
            &LsapAdtEventsInformation,
            UpdatedPolicyAuditEventsInfo,
            sizeof(LSARM_POLICY_AUDIT_EVENTS_INFO)
            );

        //
        // Update Audit Event Category Info held by SAM
        //

        PolicyAuditEventsInfo.AuditingMode = UpdatedPolicyAuditEventsInfo->AuditingMode;
        PolicyAuditEventsInfo.MaximumAuditEventCount = POLICY_AUDIT_EVENT_TYPE_COUNT;
            PolicyAuditEventsInfo.EventAuditingOptions =
                UpdatedPolicyAuditEventsInfo->EventAuditingOptions;

        Status = SamISetAuditingInformation(&PolicyAuditEventsInfo);

        if (!NT_SUCCESS(Status)) {

            break;
        }

        //
        // Setup attribute info for writing the updated Audit Event Info
        // to the LSA Database (PolAdtEv attribute of the Policy Object).
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolAdtEv,
            UpdatedPolicyAuditEventsInfo,
            UpdatedPolicyAuditEventsInfoLength,
            FALSE
            );

        AttributeCount++;

        NotifyClass = PolicyNotifyAuditEventsInformation;
        NotifyPolicyChange = TRUE;
        break;

    case PolicyPrimaryDomainInformation:


        //
        // Get the current DnsDomainInformation to see if we're changing
        //  anything.
        //
        //  Use the trusted policy handle
        //

        Status = LsapDbQueryInformationPolicy(
                     LsapPolicyHandle,
                     PolicyDnsDomainInformation,
                     (PLSAPR_POLICY_INFORMATION *) &CurrentDnsDomainInfo );

        if ( !NT_SUCCESS(Status) ) {
            goto SetInformationPolicyError;
        }

        //
        // If the new policy is the same as the old policy,
        //  avoid clearing the NT 5 specific information
        //

        PolicyPrimaryDomainInfo = (PPOLICY_PRIMARY_DOMAIN_INFO) PolicyInformation;

        if ( RtlEqualDomainName( &PolicyPrimaryDomainInfo->Name,
                                 &CurrentDnsDomainInfo->Name ) &&

              (( PolicyPrimaryDomainInfo->Sid == NULL &&
                 CurrentDnsDomainInfo->Sid == NULL) ||
               ( PolicyPrimaryDomainInfo->Sid != NULL &&
                 CurrentDnsDomainInfo->Sid != NULL &&
                 RtlEqualSid( PolicyPrimaryDomainInfo->Sid,
                              CurrentDnsDomainInfo->Sid ) ) ) ) {

            //
            // Be sure to invalidate PrimaryDomainInformation since that info
            //  level contains this one.
            //

            // LsapDbMakeInvalidInformationPolicy( PolicyDnsDomainInformation );

            Status = STATUS_SUCCESS;
            break;

        }

        //
        // Join domain must fail on personal SKU
        //

        if ( LsapIsRunningOnPersonal()) {

            ASSERT( CurrentDnsDomainInfo->Sid == NULL );

            if ( PolicyPrimaryDomainInfo->Sid != NULL ) {

                Status = STATUS_NOT_SUPPORTED;
                break;
            }
        }

        //
        // Since the PrimaryDomainInformation structure is a subset of the DnsDomainInformation,
        // we'll build the latter, and set that.
        //
        // Clear the NT 5 specific information.
        //

        RtlZeroMemory( &DnsDomainInfo, sizeof(POLICY_DNS_DOMAIN_INFO) );

        DnsDomainInfo.Name = PolicyPrimaryDomainInfo->Name;
        DnsDomainInfo.Sid = PolicyPrimaryDomainInfo->Sid;

        //
        // Ok, set our policy information to be the DnsDomainInfo we just initialized
        //
        PolicyInformation = (PLSAPR_POLICY_INFORMATION)&DnsDomainInfo;
        LsapDbMakeInvalidInformationPolicy( PolicyDnsDomainInformation );


        //
        // FALL THROUGH to PolicyDnsDomainInformation
        //

    case PolicyDnsDomainInformation:

        PolicyDnsDomainInfo = (PPOLICY_DNS_DOMAIN_INFO) PolicyInformation;

        //
        // Join domain must fail on personal SKU
        //

        if ( CurrentDnsDomainInfo == NULL &&
             LsapIsRunningOnPersonal()) {

            //
            // Get the current DnsDomainInformation to see if we're changing
            //  anything.
            //
            //  Use the trusted policy handle
            //

            Status = LsapDbQueryInformationPolicy(
                         LsapPolicyHandle,
                         PolicyDnsDomainInformation,
                         (PLSAPR_POLICY_INFORMATION *) &CurrentDnsDomainInfo );

            if ( !NT_SUCCESS(Status) ) {
                goto SetInformationPolicyError;
            }

            ASSERT( CurrentDnsDomainInfo->Sid == NULL );

            if ( PolicyDnsDomainInfo->Sid != NULL ) {

                Status = STATUS_NOT_SUPPORTED;
                break;
            }
        }
        
        //
        // if there is a '.' at the end of DnsDomainName or DnsForestName,
        // remove it
        //
        DnsDomainNameTruncated =
            LsapRemoveTrailingDot(&PolicyDnsDomainInfo->DnsDomainName, TRUE);
        DnsForestNameTruncated =
            LsapRemoveTrailingDot(&PolicyDnsDomainInfo->DnsForestName, TRUE);

        //
        // Make sure we invalidate the PrimaryDomainInformation
        //  since the info level is a subset of this one.
        //

        LsapDbMakeInvalidInformationPolicy( PolicyPrimaryDomainInformation );


        //
        // Construct the Domain name attribute info
        //

        Status = LsapDbMakeUnicodeAttributeDs(
                     &PolicyDnsDomainInfo->Name,
                     PolPrDmN,
                     NextAttribute
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        DomainName = NextAttribute->AttributeName;
        NextAttribute++;
        AttributeCount++;

        //
        // Construct the DNS Domain name attribute info
        //

        Status = LsapDbMakeUnicodeAttributeDs(
                    &PolicyDnsDomainInfo->DnsDomainName,
                    PolDnDDN,
                    NextAttribute
                    );

        NextAttribute++;
        AttributeCount++;

        //
        // Construct the DNS Tree name attribute info
        //

        Status = LsapDbMakeUnicodeAttributeDs(
                    &PolicyDnsDomainInfo->DnsForestName,
                    PolDnTrN,
                    NextAttribute
                    );

        NextAttribute++;
        AttributeCount++;

        //
        // Construct the Domain GUID attribute info
        //

        Status = LsapDbMakeGuidAttributeDs(
                    &PolicyDnsDomainInfo->DomainGuid,
                    PolDnDmG,
                    NextAttribute
                    );

        NextAttribute++;
        AttributeCount++;


        //
        // Construct the Sid attribute info
        //

        Status = LsapDbMakeSidAttributeDs(
                     PolicyDnsDomainInfo->Sid,
                     PolPrDmS,
                     NextAttribute
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        AttributeCount++;

        NotifyClass = PolicyNotifyDnsDomainInformation;
        NotifyPolicyChange = TRUE;

        if (DnsDomainNameTruncated) {

            PolicyDnsDomainInfo->DnsDomainName.Length += sizeof(WCHAR);
        }

        if (DnsForestNameTruncated) {

            PolicyDnsDomainInfo->DnsForestName.Length += sizeof(WCHAR);
        }
        break;

    case PolicyAccountDomainInformation:

        PolicyAccountDomainInfo = (PPOLICY_ACCOUNT_DOMAIN_INFO) PolicyInformation;

        //
        // 368441: NULL account domain SID will cause the machine to
        //         fail to boot, even into safe mode
        //

        if ( PolicyAccountDomainInfo->DomainSid == NULL ) {

            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Construct the Domain name attribute info
        //

        Status = LsapDbMakeUnicodeAttributeDs(
                     &PolicyAccountDomainInfo->DomainName,
                     PolAcDmN,
                     NextAttribute
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        DomainName = NextAttribute->AttributeName;
        AttributeCount++;
        NextAttribute++;

        //
        // Construct the Sid attribute info
        //

        Status = LsapDbMakeSidAttributeDs(
                     PolicyAccountDomainInfo->DomainSid,
                     PolAcDmS,
                     NextAttribute
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        AttributeCount++;
        NotifyClass = PolicyNotifyAccountDomainInformation;
        NotifyPolicyChange = TRUE;
        break;

    case PolicyPdAccountInformation:

        Status = STATUS_INVALID_PARAMETER;
        break;

    case PolicyReplicaSourceInformation:

        PolicyReplicaSourceInfo = (PPOLICY_REPLICA_SOURCE_INFO) PolicyInformation;

        //
        // Construct the Replica Source Name attribute info
        //

        Status = LsapDbMakeUnicodeAttributeDs(
                     &PolicyReplicaSourceInfo->ReplicaSource,
                     PolRepSc,
                     NextAttribute
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        ReplicaSource = NextAttribute->AttributeName;
        AttributeCount++;
        NextAttribute++;

        //
        // Construct the Replica Account Name attribute info
        //

        Status = LsapDbMakeUnicodeAttributeDs(
                     &PolicyReplicaSourceInfo->ReplicaAccountName,
                     PolRepAc,
                     NextAttribute
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        AccountName = NextAttribute->AttributeName;
        AttributeCount++;
        break;

    case PolicyDefaultQuotaInformation:

        PolicyDefaultQuotaInfo = (PPOLICY_DEFAULT_QUOTA_INFO) PolicyInformation;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            DefQuota,
            &PolicyDefaultQuotaInfo->QuotaLimits,
            sizeof (POLICY_DEFAULT_QUOTA_INFO),
            FALSE
            );

        AttributeCount++;
        break;

    case PolicyModificationInformation:

        PolicyModificationInfo = (PPOLICY_MODIFICATION_INFO) PolicyInformation;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            PolMod,
            PolicyModificationInfo,
            sizeof (POLICY_MODIFICATION_INFO),
            FALSE
            );

        AttributeCount++;
        break;

    case PolicyAuditFullSetInformation:

        Status = STATUS_NOT_SUPPORTED;
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto SetInformationPolicyError;
    }

    //
    // Update the Policy Object attributes
    //
    Status = LsapDbWriteAttributesObject( PolicyHandle,
                                          Attributes,
                                          AttributeCount );


    if (!NT_SUCCESS(Status)) {

        goto SetInformationPolicyError;
    }

    //
    // Generate an audit if necessary.
    //

    if (LsapAdtAuditingPolicyChanges() || WerePolicyChangesAuditedBefore) {

        SavedStatus = Status;

        Status = LsapAdtGenerateLsaAuditEvent(
                     PolicyHandle,
                     SE_CATEGID_POLICY_CHANGE,
                     SE_AUDITID_POLICY_CHANGE,
                     NULL,
                     0,
                     NULL,
                     0,
                     NULL,
                     &LsapAdtEventsInformation
                     );

        //
        // Ignore failure status from auditing.
        //

        Status = SavedStatus;

        //
        // Free the memory containing the TrustInformation.
        //

        LsaIFree_LSAPR_TRUST_INFORMATION ( TrustInformation );
        TrustInformation = NULL;
    }


    if ( NT_SUCCESS( Status ) ) {

        //
        // Invalidate the information in the Policy Cache for this information
        // class
        //
        LsapDbMakeInvalidInformationPolicy( InformationClass );

    }

    //
    // Finally, call the notification routines.  We don't care about errors coming back
    // from this.
    //
    if ( NT_SUCCESS( Status ) && NotifyPolicyChange ) {

        LsaINotifyChangeNotification( NotifyClass );
    }


SetInformationPolicyFinish:

    //
    // If necessary, finish any Lsa Database transaction, notify the
    // LSA Database Replicator of the change, dereference the Policy Object,
    // release the LSA Database lock and return.
    //

    //
    // Free memory allocated by this routine for attribute buffers.
    // These have MemoryAllocated = TRUE in their attribute information.
    // Leave alone buffers allocated by calling RPC stub.
    //

    for( NextAttribute = Attributes, AttributeNumber = 0;
         AttributeNumber < AttributeCount;
         NextAttribute++, AttributeNumber++) {

        if (NextAttribute->MemoryAllocated) {

            if (NextAttribute->AttributeValue != NULL) {

                MIDL_user_free(NextAttribute->AttributeValue);
                NextAttribute->MemoryAllocated = FALSE;
                NextAttribute->AttributeValue = NULL;
            }
        }
    }

    //
    // If necessary, free memory allocated for the Previous Audit Event
    // Information.  Only do this if it is not the same as the
    // Updated Audit Event Information pointer.
    //

    if (PreviousPolicyAuditEventsInfo != NULL) {

        if (PreviousPolicyAuditEventsInfo != UpdatedPolicyAuditEventsInfo) {

            MIDL_user_free( PreviousPolicyAuditEventsInfo );
            PreviousPolicyAuditEventsInfo = NULL;
        }
    }

    if (NeedToFreeUpdatedPolicyAuditEventsInfo) {

        MIDL_user_free( UpdatedPolicyAuditEventsInfo );
    }

    LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                       (PLSAPR_POLICY_INFORMATION)CurrentDnsDomainInfo );

    LsapExitFunc( "LsapDbSetInformationPolicy", Status );

    return(Status);

SetInformationPolicyError:

    goto SetInformationPolicyFinish;
}



NTSTATUS
LsarSetInformationPolicy2(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaSetInformationPolicy API.

    The LsaSetInformationPolicy API modifies information in the Policy Object.
    The caller must have access appropriate to the information to be changed
    in the Policy Object, see the InformationClass parameter.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the type of information being changed.
        The information types and accesses required to change them are as
        follows:

        PolicyAuditLogInformation         POLICY_AUDIT_LOG_ADMIN
        PolicyAuditEventsInformation      POLICY_SET_AUDIT_REQUIREMENTS
        PolicyPrimaryDomainInformation    POLICY_TRUST_ADMIN
        PolicyAccountDomainInformation    POLICY_TRUST_ADMIN
        PolicyPdAccountInformation        Not settable by this API
        PolicyLsaServerRoleInformation    POLICY_SERVER_ADMIN
        PolicyReplicaSourceInformation    POLICY_SERVER_ADMIN
        PolicyDefaultQuotaInformation     POLICY_SET_DEFAULT_QUOTA_LIMITS
        PolicyAuditFullSetInformation     POLICY_AUDIT_LOG_ADMIN
        PolicyDnsDomainInformation        POLICY_TRUST_ADMIN
        PolicyDnsDomainInformationInt     POLICY_TRUST_ADMIN

    Buffer - Points to a structure containing the information appropriate
        to the information type specified by the InformationClass parameter.

Return Value:

    NTSTATUS - Standard Nt Result Code

        Result codes returned from LsarSetInformationPolicy()
--*/

{
    return(LsarSetInformationPolicy(
                PolicyHandle,
                InformationClass,
                PolicyInformation
                ));
}


VOID
LsapDbMakeInvalidInformationPolicy(
    IN ULONG InformationClass
    )

/*++

Routine Description:

    This function frees and invalidates the information held for a specific
    Information Class in the Policy Object cache.  The general cache state
    remains unchanged.

Arguments:

    InformationClass - Specifies the Information Class whose information is to be
        discarded.

Return Values:

--*/

{
    SafeAcquireResourceExclusive( &LsapDbState.PolicyCacheLock, TRUE );

    //
    // If the Policy Cache is invalid, just return.
    //

    if (!LsapDbIsCacheValid(PolicyObject)) {

        goto Cleanup;
    }

    //
    //
    // If PolicyAuditFullSetInformation is specified, free
    // PolicyAuditFullQueryInformation
    //

    if (InformationClass == PolicyAuditFullSetInformation) {

        InformationClass = PolicyAuditFullQueryInformation;
    }

    //
    // If the information in the cache for this Information Class is invalid,
    // just return
    //

    if (!LsapDbIsCacheValidPolicyInfoClass( InformationClass )) {

        goto Cleanup;
    }

    if (LsapDbPolicy.Info[InformationClass].AttributeLength != 0) {

        LsaIFree_LSAPR_POLICY_INFORMATION (
            InformationClass,
            (PLSAPR_POLICY_INFORMATION) LsapDbPolicy.Info[ InformationClass ].Attribute
            );

        LsapDbPolicy.Info[InformationClass].Attribute = NULL;
        LsapDbPolicy.Info[InformationClass].AttributeLength = 0;
    }

Cleanup:

    SafeReleaseResource( &LsapDbState.PolicyCacheLock );

    return;
}


NTSTATUS
LsapDbVerifyInfoQueryPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PACCESS_MASK RequiredAccess
    )

/*++

Routine Description:

    This function validates a Policy Information Class.  If valid, a mask
    of the accesses required to set the Policy Information of the class is
    returned.

Arguments:

    PolicyHandle - Handle from an LsapDbOpenPolicy call.  The handle
        may be trusted.

    InformationClass - Specifies a Policy Information Class.

    RequiredAccess - Points to variable that will receive a mask of the
        accesses required to query the given class of Policy Information.
        If an error is returned, this value is cleared to 0.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The Policy Information Class provided is
            valid and the information provided is consistent with this
            class.

        STATUS_INVALID_PARAMETER - Invalid parameter:

            Information Class is invalid
            Policy  Information not valid for the class
--*/

{
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) PolicyHandle;

    if (LsapDbValidInfoPolicy( InformationClass, NULL)) {

        //
        // Non-trusted callers are not allowed to query the
        // PolicyModificationInformation information class.
        //

        if (!InternalHandle->Trusted) {

            if (InformationClass == PolicyModificationInformation) {

                return(STATUS_INVALID_PARAMETER);
            }
        }

        *RequiredAccess = LsapDbRequiredAccessQueryPolicy[InformationClass];
        return(STATUS_SUCCESS);
    }

    return(STATUS_INVALID_PARAMETER);
}


NTSTATUS
LsapDbVerifyInfoSetPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation,
    OUT PACCESS_MASK RequiredAccess
    )

/*++

Routine Description:

    This function validates a Policy Information Class and verifies
    that the provided Policy Information is valid for the class.
    If valid, a mask of the accesses required to set the Policy
    Information of the class is returned.

Arguments:

    PolicyHandle - Handle from an LsapDbOpenPolicy call.  The handle
        may be trusted.

    InformationClass - Specifies a Policy Information Class.

    PolicyInformation - Points to Policy Information to be set.

    RequiredAccess - Points to variable that will receive a mask of the
        accesses required to set the given class of Policy Information.
        If an error is returned, this value is cleared to 0.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The Policy Information Class provided is
            valid and the information provided is consistent with this
            class.

        STATUS_INVALID_PARAMETER - Invalid parameter:

            Information Class is invalid
            Information Class is invalid for non-trusted clients
            Policy Information not valid for the class

        STATUS_SHARED_POLICY - The policy is replicated from the DCs and cannot be modified
            locally
--*/

{
    NTSTATUS Status;

    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) PolicyHandle;

    //
    // Verify that the information class is valid and that the Policy
    // Information provided is valid for the class.
    //

    if (LsapDbValidInfoPolicy( InformationClass, PolicyInformation)) {

        //
        // Non-trusted callers are not allowed to set information for
        // the following classes.
        //
        // PolicyPdAccountInformation
        // PolicyModificationInformation
        //

        if (!InternalHandle->Trusted) {

            if ((InformationClass == PolicyPdAccountInformation) ||
                (InformationClass == PolicyModificationInformation)) {

#ifdef LSA_SAM_ACCOUNTS_DOMAIN_TEST

            if (InformationClass == PolicyPdAccountInformation) {

                Status = LsapDbTestLoadSamAccountsDomain(
                             (PUNICODE_STRING) PolicyInformation
                             );
            }

#endif // LSA_SAM_ACCOUNTS_DOMAIN_TEST
                return(STATUS_INVALID_PARAMETER);
            }
        }

        *RequiredAccess = LsapDbRequiredAccessSetPolicy[InformationClass];
        return(STATUS_SUCCESS);
    }

    Status = STATUS_INVALID_PARAMETER;
    return(Status);
}


BOOLEAN
LsapDbValidInfoPolicy(
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN OPTIONAL PLSAPR_POLICY_INFORMATION PolicyInformation
    )

/*++

Routine Description:

    This function validates a Policy Information Class and optionally verifies
    that provided Policy Information is valid for the class.

Arguments:

    InformationClass - Specifies a Policy Information Class.

    PolicyInformation - Optionally points to Policy Information.  If
        NULL is specified, no Policy Information checking takes place.

Return Values:

    BOOLEAN - TRUE if the Policy information class provided is
        valid, else FALSE.
--*/

{
    BOOLEAN BooleanStatus = TRUE;
    PPOLICY_AUDIT_LOG_INFO PolicyAuditLogInfo;
    PPOLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;
    PPOLICY_PRIMARY_DOMAIN_INFO PolicyPrimaryDomainInfo;
    PPOLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfo;
    PPOLICY_PD_ACCOUNT_INFO PolicyPdAccountInfo;
    PPOLICY_LSA_SERVER_ROLE_INFO PolicyLsaServerRoleInfo;
    PPOLICY_REPLICA_SOURCE_INFO PolicyReplicaSourceInfo;
    PPOLICY_DEFAULT_QUOTA_INFO PolicyDefaultQuotaInfo;
    PPOLICY_MODIFICATION_INFO PolicyModificationInfo;
    POLICY_AUDIT_EVENT_TYPE AuditEventType;
    ULONG MaximumAuditEventCount;
    PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;

    //
    // Validate the Information Class
    //

    if ((InformationClass >= PolicyAuditLogInformation) &&
        (InformationClass <= PolicyDnsDomainInformation)) {

        if ((InformationClass == PolicyAuditFullSetInformation) ||
            (InformationClass == PolicyAuditFullQueryInformation)) {

            return FALSE;
        }
        
        if (PolicyInformation == NULL) {

            return(TRUE);
        }

        switch (InformationClass) {

        case PolicyAuditLogInformation:

            PolicyAuditLogInfo = (PPOLICY_AUDIT_LOG_INFO) PolicyInformation;

            //
            // PPOLICY_AUDIT_LOG_INFO is a pointer-free struct;
            // nothing to verify
            //

            break;

        case PolicyAuditEventsInformation:

            PolicyAuditEventsInfo = (PPOLICY_AUDIT_EVENTS_INFO) PolicyInformation;

            MaximumAuditEventCount = PolicyAuditEventsInfo->MaximumAuditEventCount;

            if (MaximumAuditEventCount == 0) {

                BooleanStatus = FALSE;
                break;
            }

            EventAuditingOptions = PolicyAuditEventsInfo->EventAuditingOptions;

            try {

                //
                // Verify that the Event Auditing Options are meaningful.
                //

                for (AuditEventType = 0;
                     AuditEventType < (POLICY_AUDIT_EVENT_TYPE) MaximumAuditEventCount;
                     AuditEventType++) {

                     if (EventAuditingOptions[ AuditEventType ] !=

                         (EventAuditingOptions[ AuditEventType ] & POLICY_AUDIT_EVENT_MASK )) {

                         BooleanStatus = FALSE;
                         break;
                     }
                }

            } except (EXCEPTION_EXECUTE_HANDLER) {

                BooleanStatus = FALSE;
            }

            break;

        case PolicyPrimaryDomainInformation:

            PolicyPrimaryDomainInfo = (PPOLICY_PRIMARY_DOMAIN_INFO) PolicyInformation;

            if ( !LsapValidateLsaUnicodeString( &PolicyPrimaryDomainInfo->Name )) {

                BooleanStatus = FALSE;
                break;
            }

            break;

        case PolicyDnsDomainInformation:

            PolicyDnsDomainInfo = (PPOLICY_DNS_DOMAIN_INFO) PolicyInformation;

            if ( !LsapValidateLsaUnicodeString( &PolicyDnsDomainInfo->Name ) ||
                 !LsapValidateLsaUnicodeString( &PolicyDnsDomainInfo->DnsDomainName ) ||
                 !LsapValidateLsaUnicodeString( &PolicyDnsDomainInfo->DnsForestName )) {

                BooleanStatus = FALSE;
                break;
            }

            break;

        case PolicyAccountDomainInformation:

            PolicyAccountDomainInfo = (PPOLICY_ACCOUNT_DOMAIN_INFO) PolicyInformation;

            if ( !LsapValidateLsaUnicodeString( &PolicyAccountDomainInfo->DomainName )) {

                BooleanStatus = FALSE;
                break;
            }

            break;

        case PolicyPdAccountInformation:

            PolicyPdAccountInfo = (PPOLICY_PD_ACCOUNT_INFO) PolicyInformation;

            if ( !LsapValidateLsaUnicodeString( &PolicyPdAccountInfo->Name )) {

                BooleanStatus = FALSE;
                break;
            }

            break;

        case PolicyLsaServerRoleInformation:

            PolicyLsaServerRoleInfo = (PPOLICY_LSA_SERVER_ROLE_INFO) PolicyInformation;

            break;

        case PolicyReplicaSourceInformation:

            PolicyReplicaSourceInfo = (PPOLICY_REPLICA_SOURCE_INFO) PolicyInformation;

            if ( !LsapValidateLsaUnicodeString( &PolicyReplicaSourceInfo->ReplicaSource ) ||
                 !LsapValidateLsaUnicodeString( &PolicyReplicaSourceInfo->ReplicaAccountName )) {

                BooleanStatus = FALSE;
                break;
            }

            break;

        case PolicyDefaultQuotaInformation:

            PolicyDefaultQuotaInfo = (PPOLICY_DEFAULT_QUOTA_INFO) PolicyInformation;
            break;

        case PolicyModificationInformation:

            PolicyModificationInfo = (PPOLICY_MODIFICATION_INFO) PolicyInformation;
            break;

        default:

            BooleanStatus = FALSE;
            break;
        }
    } else {
        BooleanStatus = FALSE;
    }

    return(BooleanStatus);
}


NTSTATUS
LsaIGetSerialNumberPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    OUT PLARGE_INTEGER ModifiedCount,
    OUT PLARGE_INTEGER CreationTime
    )

/*++

Routine Description:

    Thin wrapper to LsaIGetSerialNumberPolicy2().
    See that function for descriptions.


--*/

{
    LARGE_INTEGER
        Ignore1;

    return( LsaIGetSerialNumberPolicy2( PolicyHandle,
                                        ModifiedCount,
                                        &Ignore1,
                                        CreationTime
                                        ) );

}


NTSTATUS
LsaIGetSerialNumberPolicy2(
    IN LSAPR_HANDLE PolicyHandle,
    OUT PLARGE_INTEGER ModifiedCount,
    OUT PLARGE_INTEGER ModifiedCountAtLastPromotion,
    OUT PLARGE_INTEGER CreationTime
    )

/*++

Routine Description:

    This service retrieves the creation time and the current count of
    modifications to the LSA Database.  This information is used as
    a serial number for the LSA Database.

Arguments:

    PolicyHandle - Trusted handle to Policy object obtained from
        LsaIOpenPolicyTrusted().

    ModifiedCount - Receives the current count of modifications to the
        LSA's database.

    ModifiedCountAtLastPromotion - Receives the modified count the last
        time this machine was promoted to primary domain controller.

    CreationTime - Receives the date/time at which the LSA database
        was created.

Return Value:

    NTSTATUS - Standard Nt Result Code.

        Same as LsarQueryInformationPolicy.
--*/

{
    NTSTATUS Status;
    PPOLICY_MODIFICATION_INFO PolicyModificationInfo = NULL;


    //
    // Query the Policy Modification and internal Information.
    // Note that only a handle marked as Trusted will be accepted.
    //

    Status = LsarQueryInformationPolicy(
                 PolicyHandle,
                 PolicyModificationInformation,
                 (PLSAPR_POLICY_INFORMATION *) &PolicyModificationInfo
                 );

    if (!NT_SUCCESS(Status)) {
        goto GetSerialNumberPolicyError;
    }


GetSerialNumberPolicyFinish:


    if (PolicyModificationInfo != NULL) {

        *ModifiedCount = PolicyModificationInfo->ModifiedId;
        *CreationTime = PolicyModificationInfo->DatabaseCreationTime;
        MIDL_user_free( PolicyModificationInfo );
    }

    ModifiedCountAtLastPromotion->QuadPart = 0;

    return (Status);

GetSerialNumberPolicyError:

    goto GetSerialNumberPolicyFinish;
}


NTSTATUS
LsaISetSerialNumberPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLARGE_INTEGER ModifiedCount,
    IN PLARGE_INTEGER CreationTime,
    IN BOOLEAN StartOfFullSync
    )

/*++

Routine Description:

    Thin wrapper around LsaISetSerialNumberPolicy2().
    See that function for descriptions.

--*/

{

    return( LsaISetSerialNumberPolicy2( PolicyHandle,
                                        ModifiedCount,
                                        NULL,
                                        CreationTime,
                                        StartOfFullSync
                                        ) );
}


NTSTATUS
LsaISetSerialNumberPolicy2(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLARGE_INTEGER ModifiedCount,
    IN OPTIONAL PLARGE_INTEGER ModifiedCountAtLastPromotion,
    IN PLARGE_INTEGER CreationTime,
    IN BOOLEAN StartOfFullSync
    )

/*++

Routine Description:


Arguments:

    PolicyHandle - Trusted handle to Policy object obtained from
        LsaIOpenPolicyTrusted().

    ModifiedCount - Provides the current count of modifications to the
        LSA's database.

    ModifiedCountAtLastPromotion - If present, provides a new
        ModifiedIdAtLastPromotion value for the LSA database.

    CreationTime - Provides the date/time at which the LSA database
        was created.

    StartOfFullSync - This boolean indicates whether a full sync is
        being initiated.  If TRUE is specified, then a full sync is to
        follow and all existing LSA database information will be discarded.
        If FALSE is specified, then only specific LSA Database information
        is to follow and all changes must comply with standard LSA
        operation behavior.

        NOTE:  This parameter is not currently used.  It is designed
               in for possible future use.

Return Value:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status;
    LARGE_INTEGER AdjustedModifiedId;
    LARGE_INTEGER One = {1,0};
    BOOLEAN ObjectReferenced = FALSE;
    POLICY_MODIFICATION_INFO OriginalPolicyModificationInfo = {0, 0};

    LsapEnterFunc( "LsaISetSerialNumberPolicy2" );


    //
    // Acquire the Lsa Database lock.  Verify that the handle is
    // a valid trusted handle to the Policy Object.
    // Reference the handle and start an Lsa Database transaction.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 (ACCESS_MASK) 0,
                 PolicyObject,
                 PolicyObject,
                 LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION | LSAP_DB_TRUSTED | LSAP_DB_NO_DS_OP_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetSerialNumberPolicyError;
    }

    ObjectReferenced = TRUE;

    // Since the policy object is in the registry, it grabbed the registry lock too.
    // (The registry lock protects LsapDbState.PolicyModificationInfo)
    ASSERT( LsapDbIsLocked( &LsapDbState.RegistryLock ));
    OriginalPolicyModificationInfo = LsapDbState.PolicyModificationInfo;

    {
        //
        // Set the in-memory copy of the Modified Id to the desired value
        // minus one.  The transaction log is empty at this point, but the
        // routine LsapDbApplyTransaction() automatically increments
        // the in-memory Modified Id and then adds an entry to the transaction
        // log to write the Modified Id to the database.  The net effect is
        // therefore to set the Modified Id to the value specified.
        //

        AdjustedModifiedId.QuadPart = ModifiedCount->QuadPart - One.QuadPart;

        //
        //
        // Set the Policy Modification Information local copy.  When we
        // commit the transaction, the database copy will be updated.
        //

        LsapDbState.PolicyModificationInfo.ModifiedId = AdjustedModifiedId;
        LsapDbState.PolicyModificationInfo.DatabaseCreationTime = *CreationTime;
        LsapDbState.RegistryModificationCount++;
    }

    //
    // Invalidate the cache for the Policy Modification Information
    //

    LsapDbMakeInvalidInformationPolicy( PolicyModificationInformation );

SetSerialNumberPolicyFinish:

    //
    // If necessary, finish any Lsa Database transaction, notify the
    // LSA Database Replicator of the change, dereference the Policy Object,
    // release the LSA Database lock and return.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     PolicyObject,
                     LSAP_DB_LOCK | LSAP_DB_FINISH_TRANSACTION | LSAP_DB_NO_DS_OP_TRANSACTION,
                     SecurityDbChange,
                     Status
                     );

        ObjectReferenced = FALSE;

    }

    LsapExitFunc( "LsaISetSerialNumberPolicy2", Status );

    return (Status);

SetSerialNumberPolicyError:

    //
    // Attempt to restore the Serial Number to its original value.
    // We need only reset the in-memory copy.
    //

    if ( ObjectReferenced ) {
        LsapDbState.PolicyModificationInfo = OriginalPolicyModificationInfo;
    }

    goto SetSerialNumberPolicyFinish;

    //
    // Although the StartOfFullSync parameter is included in the specification
    // of this API, it has currently been designed out.  The original
    // intent was to disable non-Trusted access to the Policy Database
    // while a full sync was taking place, but such a sync is currently
    // a non-atomic operation.
    //

    UNREFERENCED_PARAMETER( StartOfFullSync );
    UNREFERENCED_PARAMETER( ModifiedCountAtLastPromotion );
}



NTSTATUS
LsapDbBuildPolicyCache(
    )

/*++

Routine Description:

    This function constructs a cache for the Policy object.  The cache
    consists of a single structure containing fixed length attributes
    of the Policy object directly, and pointers or Top level structures
    for (variable length attributes.

    NOTE:  Currently, only the PolicyDefaultQuotaInformation information
    class has information in the Policy object Cache.

Arguments:

    None

Return Values:

    None

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    POLICY_INFORMATION_CLASS InformationClass;

    //
    // Do a slow query of each attribute in turn.
    //

    for ( InformationClass = PolicyAuditLogInformation;
          InformationClass <= PolicyDnsDomainInformation;
          InformationClass++ ) {

        if ((InformationClass == PolicyAuditFullSetInformation) ||
            (InformationClass == PolicyAuditFullQueryInformation) ||
            (InformationClass == PolicyLsaServerRoleInformation) ) {

            continue;
        }

        //
        // Throw away current informaiton
        //

        LsaIFree_LSAPR_POLICY_INFORMATION(
            InformationClass,
            ( PLSAPR_POLICY_INFORMATION )LsapDbPolicy.Info[InformationClass].Attribute );

        LsapDbPolicy.Info[InformationClass].Attribute = NULL;

        //
        // ... and obtain new one
        //

        Status = LsapDbSlowQueryInformationPolicy(
                     LsapPolicyHandle,
                     InformationClass,
                     &LsapDbPolicy.Info[InformationClass].Attribute
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        LsapDbPolicy.Info[InformationClass].AttributeLength = 0;
    }

    if (!NT_SUCCESS(Status)) {

        goto BuildPolicyCacheError;
    }

    //
    // Store buffer lengths top level nodes of returned information.
    //

    LsapDbPolicy.Info[PolicyAuditLogInformation].AttributeLength
        = sizeof(POLICY_AUDIT_LOG_INFO);
    LsapDbPolicy.Info[PolicyAuditEventsInformation].AttributeLength
        = sizeof(LSAPR_POLICY_AUDIT_EVENTS_INFO);
    LsapDbPolicy.Info[PolicyPrimaryDomainInformation].AttributeLength
        = sizeof(LSAPR_POLICY_PRIMARY_DOM_INFO);
    LsapDbPolicy.Info[PolicyAccountDomainInformation].AttributeLength
        = sizeof(LSAPR_POLICY_ACCOUNT_DOM_INFO);
    LsapDbPolicy.Info[PolicyPdAccountInformation].AttributeLength
        = sizeof(LSAPR_POLICY_PD_ACCOUNT_INFO);
    LsapDbPolicy.Info[PolicyLsaServerRoleInformation].AttributeLength
        = sizeof(POLICY_LSA_SERVER_ROLE_INFO);
    LsapDbPolicy.Info[PolicyReplicaSourceInformation].AttributeLength
        = sizeof(LSAPR_POLICY_REPLICA_SRCE_INFO);
    LsapDbPolicy.Info[PolicyDefaultQuotaInformation].AttributeLength
        = sizeof(POLICY_DEFAULT_QUOTA_INFO);
    LsapDbPolicy.Info[PolicyModificationInformation].AttributeLength
        = sizeof(POLICY_MODIFICATION_INFO);
    LsapDbPolicy.Info[PolicyAuditFullSetInformation].AttributeLength
        = sizeof(POLICY_AUDIT_FULL_SET_INFO);
    LsapDbPolicy.Info[PolicyAuditFullQueryInformation].AttributeLength
        = sizeof(POLICY_AUDIT_FULL_QUERY_INFO);
    LsapDbPolicy.Info[PolicyDnsDomainInformation].AttributeLength
        = sizeof(LSAPR_POLICY_DNS_DOMAIN_INFO);
    LsapDbPolicy.Info[PolicyDnsDomainInformationInt].AttributeLength
        = 0; // dummy value for a dummy information class

BuildPolicyCacheFinish:

    return(Status);

BuildPolicyCacheError:

    goto BuildPolicyCacheFinish;
}


NTSTATUS
LsapDbUpdateInformationPolicy(
    IN POLICY_INFORMATION_CLASS InformationClass
    )

/*++

Routine Description:

    This function updates the Policy Object Cache for a particular information
    class.  When a set of the information for a given class occurs, the
    old information stored in the Policy Object Cache for that class is marked
    invalid and freed.  Next time a query is done for that class, this
    routine is called to restore the information from backing storage.

Arguments:

    InformationClass - Specifies the type of information being changed.
        See LsapDbQueryInformationPolicy for details.

    Buffer - Points to a structure containing the new information.
        If NULL is specified, the information will be updated from backing
        storage.  NOTE: Currently, only NULL may be specified.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        Others TBS
--*/

{
    NTSTATUS Status;
    ULONG TopNodeLength = 0;

    //
    // Just query the information back from disk to the cache.
    //

    Status = LsapDbSlowQueryInformationPolicy(
                 LsapPolicyHandle,
                 InformationClass,
                 &LsapDbPolicy.Info[InformationClass].Attribute
                 );

    if (!NT_SUCCESS(Status)) {

        goto UpdateInformationPolicyError;
    }

    //
    // Now compute and store the length of the top node.
    //

    switch (InformationClass) {

    case PolicyAuditLogInformation :

        TopNodeLength = sizeof(POLICY_AUDIT_LOG_INFO);
        break;

    case PolicyAuditEventsInformation :

        TopNodeLength = sizeof(LSAPR_POLICY_AUDIT_EVENTS_INFO);
        break;

    case PolicyPrimaryDomainInformation :

        TopNodeLength = sizeof(LSAPR_POLICY_PRIMARY_DOM_INFO);
        break;

    case PolicyDnsDomainInformation :

        TopNodeLength = sizeof(LSAPR_POLICY_DNS_DOMAIN_INFO);
        break;

    case PolicyAccountDomainInformation :

        TopNodeLength = sizeof(LSAPR_POLICY_ACCOUNT_DOM_INFO);
        break;

    case PolicyPdAccountInformation :

        TopNodeLength = sizeof(LSAPR_POLICY_PD_ACCOUNT_INFO);
        break;

    case PolicyLsaServerRoleInformation :

        TopNodeLength = sizeof(POLICY_LSA_SERVER_ROLE_INFO);
        break;

    case PolicyReplicaSourceInformation :

        TopNodeLength = sizeof(LSAPR_POLICY_REPLICA_SRCE_INFO);
        break;

    case PolicyDefaultQuotaInformation :

        TopNodeLength = sizeof(POLICY_DEFAULT_QUOTA_INFO);
        break;

    case PolicyModificationInformation :

        TopNodeLength = sizeof(POLICY_MODIFICATION_INFO);
        break;

    case PolicyAuditFullSetInformation :

        TopNodeLength = 0;
        break;

    case PolicyAuditFullQueryInformation :

        TopNodeLength = sizeof(POLICY_AUDIT_FULL_QUERY_INFO);
        break;

    }

    LsapDbPolicy.Info[ InformationClass].AttributeLength = TopNodeLength;

UpdateInformationPolicyFinish:

    return(Status);

UpdateInformationPolicyError:

    goto UpdateInformationPolicyFinish;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbsamtst.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbsamtst.c

Abstract:

    LSA Database - SAM Database load testing code

    When enabled, this code provides a mechanism for stress loading of the
    SAM database with a large number of accounts.  The load executes in the
    context of lsass.exe, similar to how it does in replication.

Author:

    Scott Birrell       (ScottBi)      January 10, 1992

Environment:

Revision History:

--*/
#include <lsapch2.h>
#include "dbp.h"


//
// Uncomment the define LSA_SAM_ACCOUNTS_DOMAIN_TEST to enable the
// code needed for the ctsamdb test program.  Recompile dbsamtst.c,
// dbpolicy.c.  rebuild lsasrv.dll and nmake UMTYPE=console UMTEST=ctsamdb.
//

#ifdef LSA_SAM_ACCOUNTS_DOMAIN_TEST

//
// Global data needed by test
//

//
// Random Unicode text Buffer (gets updated pseudo-randomly during run)
//

#define LSAP_DB_TEST_TEXT_BUFF_CHAR_LENGTH     ((ULONG) 1024)

#define LSAP_DB_TEST_TEXT_BUFF_BYTE_LENGTH      \
    (LSAP_DB_TEST_TEXT_BUFF_CHAR_LENGTH * sizeof (WCHAR))

static PWSTR TextBuffer = L"ABCDEFGHIJKLMNOPQRSTUVWXYZAABBCC"
                          L"DDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSS"
                          L"TTUUVVWWXXYYZZZYXWVUTSRQPONMLKJI"
                          L"HGFEDCBAMEJHCKZXHDKCXJHCKXSKLCJJ"
                          L"QKXJHDHNSLCJIFUENSGXCJCVKLSJKSHD"
                          L"QXKXJHDGHASOESDGPMSDVJKSDNJCKACJ"
                          L"AOJSDVJKJASDHABJKACSBNVAJKAJSKDV"
                          L"AJLSBSDJBVAJKLQWDQBVAKLJSCVAKLDD"
                          L"OJWQEFBNQGOTQJWDBVBJOQWDBXQPJJPB"
                          L"QWERTYUIOPASDFGHJKLZXCVBNMQUFIEJ"
                          L"ARWFUITYBNOMVJGBLJHKGJKGKGTJHKHS"
                          L"AOPDEBLFPYVQRUCVKJGRKSDBKGKWPOID"
                          L"MBCZLADJGFDOYEJHLSDYQWHLSOQLFHBF"
                          L"MCNXBZLGHKFDKDHSAQTWYEUTODMKCVJW"
                          L"QOPKIJUNYBTYVTCRCXEXECDWZQGGICRT"
                          L"ZWRFXCERYHVFYJNGHJNMBGTYVFJNMJJK";

//
// Random Unicode text Buffer backup (used for reset)
//

static PWSTR TextBuffBak = L"ABCDEFGHIJKLMNOPQRSTUVWXYZAABBCC"
                           L"DDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSS"
                           L"TTUUVVWWXXYYZZZYXWVUTSRQPONMLKJI"
                           L"HGFEDCBAMEJHCKZXHDKCXJHCKXSKLCJJ"
                           L"QKXJHDHNSLCJIFUENSGXCJCVKLSJKSHD"
                           L"QXKXJHDGHASOESDGPMSDVJKSDNJCKACJ"
                           L"AOJSDVJKJASDHABJKACSBNVAJKAJSKDV"
                           L"AJLSBSDJBVAJKLQWDQBVAKLJSCVAKLDD"
                           L"OJWQEFBNQGOTQJWDBVBJOQWDBXQPJJPB"
                           L"QWERTYUIOPASDFGHJKLZXCVBNMQUFIEJ"
                           L"ARWFUITYBNOMVJGBLJHKGJKGKGTJHKHS"
                           L"AOPDEBLFPYVQRUCVKJGRKSDBKGKWPOID"
                           L"MBCZLADJGFDOYEJHLSDYQWHLSOQLFHBF"
                           L"MCNXBZLGHKFDKDHSAQTWYEUTODMKCVJW"
                           L"QOPKIJUNYBTYVTCRCXEXECDWZQGGICRT"
                           L"ZWRFXCERYHVFYJNGHJNMBGTYVFJNMJJK";

static ULONG Array0Index = 0,
             Array1Index = 0,
             Array2Index = 0,
             Array3Index = 0,
             Array4Index = 0,
             Array5Index = 0;


static ULONG Array0[] = { 0, 44, 88 };
static ULONG Array1[] = { 87,2,45,48,68};
static ULONG Array2[] = { 23,1,43,37,4,16,8 };
static ULONG Array3[] = { 64,5,17,29,18,17,22,56,19,20,6 };
static ULONG Array4[] = { 7,11,97,88,8,5,24,0,99,51,33,20,80 };
static ULONG Array5[] = { 53,56,3,27,29,98,35,47,53,92,89,4,66,34,1,99,3 };


NTSTATUS
LsapDbTestLoadSamAccountsDomain(
    IN PUNICODE_STRING NumberOfAccounts
    );

NTSTATUS
LsapDbTestLoadSamAccountsDomainInitialize(
    IN OUT PUSER_ALL_INFORMATION UserInformation
    );

NTSTATUS
LsapDbTestCreateNextAccountInfo(
    IN OUT PUSER_ALL_INFORMATION UserInformation
    );

NTSTATUS
LsapDbTestGenUnicodeString(
    OUT PUNICODE_STRING OutputString,
    IN ULONG MinimumLength,
    IN ULONG MaximumLength
    );

PWSTR
LsapDbTestGenRandomStringPointer(
    IN ULONG MinLengthToLeaveAtEnd
    );

ULONG
LsapDbTestGenRandomNumber(
    IN ULONG MinimumValue,
    IN ULONG MaximumValue
    );

NTSTATUS
LsapDbTestLoadSamAccountsDomain(
    IN PUNICODE_STRING NumberOfAccounts
    )

/*++

Routine Description:

    This function creates a number of users in the local SAM Accounts Domain,
    or deletes previously created users in the domain.

Arguments:

    AccountCount - Specifies the number of accounts to be created.  If a negative
        number is specified, the accounts are deleted.

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status, EnumerateStatus;
    LONG AccountNumber = 0;
    LONG AccountCount = 0;
    LONG CollisionCount = 0;
    LONG ExistingAccountCount = 0;
    LONG DeletedUserCount = 0;
    ANSI_STRING NumberOfAccountsAnsi;
    PLSAPR_POLICY_ACCOUNT_DOM_INFO PolicyAccountDomainInfo = NULL;
    LSA_TRUST_INFORMATION TrustInformation;
    SAMPR_HANDLE LocalSamServerHandle = NULL;
    USER_ALL_INFORMATION UserInformation;
    SAMPR_HANDLE UserHandle = NULL;
    SAMPR_HANDLE LocalSamDomainHandle = NULL;
    ULONG InitialRelativeId, RelativeId;
    ULONG CountReturned;
    SAM_ENUMERATE_HANDLE EnumerationContext = 0;
    PSAMPR_ENUMERATION_BUFFER RidEnumerationBuffer = NULL;
    ULONG NextAccount;
    ULONG ConflictingAccountRid;
    LARGE_INTEGER StartTime, TimeAfterThis100Users, TimeAfterPrevious100Users;
    LARGE_INTEGER TimeForThis100Users, TimeForThis100UsersInMs, TotalTime, TenThousand;


    //
    // Open the local SAM Accounts Domain
    //
    // The Sid and Name of the Account Domain are both configurable, and
    // we need to obtain them from the Policy Object.  Now obtain the
    // Account Domain Sid and Name by querying the appropriate
    // Policy Information Class.
    //

    Status = LsarQueryInformationPolicy(
                 LsapPolicyHandle,
                 PolicyAccountDomainInformation,
                 (PLSAPR_POLICY_INFORMATION *) &PolicyAccountDomainInfo
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("LsarQueryInformationPolicy failed 0x%lx\n", Status));
        goto TestLoadSamAccountsDomainError;
    }

    //
    // Set up the Trust Information structure for the Account Domain.
    //

    TrustInformation.Sid = PolicyAccountDomainInfo->DomainSid;

    RtlCopyMemory(
        &TrustInformation.Name,
        &PolicyAccountDomainInfo->DomainName,
        sizeof (UNICODE_STRING)
        );

    //
    // Connect to the Local Sam.  The LSA server is a trusted client, so we
    // call the internal version of the SamConnect routine.
    //

    Status = SamIConnect( NULL, &LocalSamServerHandle, 0, TRUE );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("SamIConnect failed 0x%lx\n", Status));
        goto TestLoadSamAccountsDomainError;
    }

    //
    // Open the Account Domain.
    //

    Status = SamrOpenDomain(
                 LocalSamServerHandle,
                 DOMAIN_LOOKUP,
                 TrustInformation.Sid,
                 &LocalSamDomainHandle
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("SamrOpenDomain failed 0x%lx\n", Status));
        goto TestLoadSamAccountsDomainError;
    }

    //
    // Now convert the count of accounts from unicode.
    //

    Status = RtlUnicodeStringToAnsiString(
                 &NumberOfAccountsAnsi,
                 NumberOfAccounts,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("RtlUnicodeStringToAnsiString failed 0x%lx\n", Status));
        goto TestLoadSamAccountsDomainError;
    }

    AccountCount = (LONG) atoi(NumberOfAccountsAnsi.Buffer);

    //
    // Tke initial relative id is used by both the create and delete
    // account branches so initialize it here.
    //

    InitialRelativeId = (ULONG) 0x00001000L;

    //
    // If the number of accounts is > 0, add the specified number of
    // accounts to the SAM account domain.  If the number of accounts is
    // < 0, delete all accounts from the SAM account s domain.
    //

    if (AccountCount > 0) {

        //
        // Initialize the constant fields in the UserInformation structure
        //

        Status = LsapDbTestLoadSamAccountsDomainInitialize(&UserInformation);

        if (!NT_SUCCESS(Status)) {

            goto TestLoadSamAccountsDomainError;
        }

        KdPrint(("Sam Account Database Load Begins\n"));

        Status = NtQuerySystemTime( &StartTime );

        if (!NT_SUCCESS(Status)) {

            return(Status);
        }

        TimeAfterPrevious100Users = StartTime;

        //
        // Conversion factor for converting 100ns ticks to milliseconds
        //

        TenThousand = RtlConvertUlongToLargeInteger((ULONG) 10000);

        for( AccountNumber = 0; AccountNumber < AccountCount; AccountNumber++) {

            //
            // Generate Information for this Account
            //

            Status = LsapDbTestCreateNextAccountInfo(&UserInformation);

            if (!NT_SUCCESS(Status)) {

                break;
            }

            RelativeId = InitialRelativeId + (ULONG) AccountNumber;

            //
            // Create the account
            //

            ConflictingAccountRid = (ULONG) 0;

            Status = SamICreateAccountByRid(
                         LocalSamDomainHandle,
                         SamObjectUser,
                         RelativeId,
                         (PRPC_UNICODE_STRING) &UserInformation.UserName,
                         USER_ALL_ACCESS,
                         &UserHandle,
                         &ConflictingAccountRid
                         );

            if (!NT_SUCCESS(Status)) {

                if ((Status == STATUS_USER_EXISTS) || (Status == STATUS_OBJECT_TYPE_MISMATCH)) {

                    CollisionCount++;
                    AccountNumber--;
                    if ((CollisionCount%100)==0) {
                        KdPrint(("."));
                    }
                    continue;
                }

                KdPrint(("SamrCreateAccountByRid failed 0x%lx\n", Status));
                break;
            }

            //
            // If an account already existed with the given Rid and had
            // the same account type  and name, it will have been opened.
            // Record the number of occurrences of this.
            //

            if (ConflictingAccountRid == RelativeId) {

                ExistingAccountCount++;
            }

            //
            // Set the information for the account
            //

            UserInformation.UserId = RelativeId;

            Status = SamrSetInformationUser(
                         UserHandle,
                         UserAllInformation,
                         (PSAMPR_USER_INFO_BUFFER) &UserInformation
                         );

            if (!NT_SUCCESS(Status)) {

                KdPrint(("SamrSetInformationUser failed 0x%lx\n", Status));
                break;
            }

            Status = SamrCloseHandle( &UserHandle );

            if ((AccountNumber > 0) && ((AccountNumber % 100) == 0)) {

                Status = NtQuerySystemTime( &TimeAfterThis100Users );

                if (!NT_SUCCESS(Status)) {

                    break;
                }

                TimeForThis100Users.QuadPart = TimeAfterThis100Users.QuadPart -
                                               TimeAfterPrevious100Users.QuadPart;

                TimeForThis100UsersInMs = TimeForThis100Users.QuadPart /
                                          TenThousand.QuadPart;

                TotalTime = TimeAfterThis100Users.QuadPart -
                            StartTime.QuadPart;

                KdPrint(("%d Accounts Created\n", AccountNumber));
                KdPrint(("Last 100 users took %d millisecs to create\n", TimeForThis100UsersInMs.LowPart));

                if (ExistingAccountCount > 0) {

                    KdPrint(("%d Attempts to create non-conflicting existing users\n\n", ExistingAccountCount));
                }

                if (CollisionCount > 0) {

                    KdPrint(("%d Creation conflicts with existing users\n", CollisionCount));
                }

                TimeAfterPrevious100Users = TimeAfterThis100Users;
            }
        }

        KdPrint(("%d Accounts Created\n", AccountNumber));
        KdPrint(("%d existing accounts opened\n", ExistingAccountCount));
        KdPrint(("%d Rid/Name/Type conflicts with existing accounts\n", CollisionCount));
        KdPrint(("\nSam Account Database Load Ends\n"));

    } else if (AccountCount < 0) {

        //
        // Delete the accounts
        //

        KdPrint(("Deleting user accounts with Rid >= 4096 in the local SAM Accounts Domain\n"));

        EnumerateStatus = STATUS_MORE_ENTRIES;

        while(EnumerateStatus == STATUS_MORE_ENTRIES) {

            RidEnumerationBuffer = NULL;

            Status = SamrEnumerateUsersInDomain(
                         LocalSamDomainHandle,
                         &EnumerationContext,
                         USER_NORMAL_ACCOUNT,
                         (PSAMPR_ENUMERATION_BUFFER *) &RidEnumerationBuffer,
                         4096,
                         &CountReturned
                         );

            EnumerateStatus = Status;

            if (!NT_SUCCESS(Status)) {

                KdPrint(("SamrEnumerateUsersInDomain failed 0x%lx\n", Status));
                break;
            }

            if (CountReturned == 0) {

                break;
            }

            for (NextAccount = 0; NextAccount < CountReturned; NextAccount++) {

                RelativeId = RidEnumerationBuffer->Buffer[ NextAccount ].RelativeId;

                //
                // Skip this account if it's not one of ours.  This is not
                // a rigorous check, but works.
                //

                if (RelativeId < InitialRelativeId) {

                    continue;
                }

                Status = SamrOpenUser(
                             LocalSamDomainHandle,
                             DELETE,
                             RelativeId,
                             &UserHandle
                             );

                if (!NT_SUCCESS(Status)) {

                    KdPrint(("SamrOpenUser failed 0x%lx\n", Status));
                    break;
                }

                Status = SamrDeleteUser( &UserHandle );

                if (!NT_SUCCESS(Status)) {

                    if (Status != STATUS_SPECIAL_ACCOUNT) {

                        KdPrint(("SamrDeleteUser failed 0x%lx\n", Status));
                        break;
                    }

                    Status = SamrCloseHandle(&UserHandle);

                    if (!NT_SUCCESS(Status)) {

                        KdPrint(("SamrCloseHandle failed 0x%lx\n", Status));
                        break;
                    }
                }

                DeletedUserCount++;
            }

            if (!NT_SUCCESS(Status)) {

                break;
            }
        }

        if (NT_SUCCESS(Status)) {

            KdPrint(("%d user accounts deleted\n", DeletedUserCount));
            KdPrint(("Deletion of user accounts ends\n"));
        }
    }

TestLoadSamAccountsDomainFinish:

    return(Status);

TestLoadSamAccountsDomainError:

    goto TestLoadSamAccountsDomainFinish;
}


NTSTATUS
LsapDbTestLoadSamAccountsDomainInitialize(
    IN OUT PUSER_ALL_INFORMATION UserInformation
    )

/*++

Routine Description:

    This function initializes the constant values required by the
    SAM Accounts Domain load/update tests.  These values include
    static global data and fixed values within a USER_ALL_INFORMATION
    structure used for creating/updating accounts.

Arguments:

    UserInformation - Points to USER_ALL_INFORMATION structure.

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index;

    static UCHAR LogonHours[SAM_HOURS_PER_WEEK / 8];

    //
    // Restore the Unicode Text Buffer used for generating random
    // Unicode Strings to its original contents.
    //

    RtlCopyMemory( TextBuffer, TextBuffBak, LSAP_DB_TEST_TEXT_BUFF_CHAR_LENGTH );

    //
    // Reset the random number generator indices
    //

    Array0Index = 0;
    Array1Index = 0;
    Array2Index = 0;
    Array3Index = 0;
    Array4Index = 0;
    Array5Index = 0;

    //
    // Initialize Logon Hours data
    //

    for( Index = 0; Index < (SAM_HOURS_PER_WEEK / 8); Index++) {

        LogonHours[Index] = (UCHAR) 0xff;
    }

    //
    // Initialize constaint values in User Information structure
    //

    UserInformation->LogonCount = 0;
    UserInformation->LogonHours.UnitsPerWeek = SAM_HOURS_PER_WEEK;
    UserInformation->LogonHours.LogonHours = LogonHours;
    UserInformation->BadPasswordCount = 1;
    UserInformation->LogonCount = 1;
    UserInformation->UserAccountControl = USER_NORMAL_ACCOUNT;
    UserInformation->CountryCode = 1;
    UserInformation->CodePage = 850;
    UserInformation->NtPasswordPresent = FALSE;
    UserInformation->LmPasswordPresent = FALSE;
    UserInformation->PasswordExpired = FALSE;
    UserInformation->SecurityDescriptor.SecurityDescriptor = NULL;
    UserInformation->SecurityDescriptor.Length = 0;
    UserInformation->WhichFields =
        (
         USER_ALL_USERNAME |
         USER_ALL_FULLNAME |
         USER_ALL_ADMINCOMMENT |
         USER_ALL_USERCOMMENT |
         USER_ALL_HOMEDIRECTORY |
         USER_ALL_HOMEDIRECTORYDRIVE |
         USER_ALL_SCRIPTPATH |
         USER_ALL_PROFILEPATH |
         USER_ALL_LOGONHOURS |
         USER_ALL_USERACCOUNTCONTROL
        );
    return(Status);
}


NTSTATUS
LsapDbTestCreateNextAccountInfo(
    IN OUT PUSER_ALL_INFORMATION UserInformation
    )

/*++

Routine Description:

    This function generates the user information for the next user.

Arguments:

    UserInformation - Pointer to User Information structure

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{

#define LSAP_TEST_MIN_USERNAME_LENGTH ((ULONG)  0x00000005L)
#define LSAP_TEST_MAX_USERNAME_LENGTH ((ULONG)  0x0000000cL)

#define LSAP_TEST_MIN_FULLNAME_LENGTH ((ULONG)  0x00000003L)
#define LSAP_TEST_MAX_FULLNAME_LENGTH ((ULONG)  0x00000030L)

#define LSAP_TEST_MIN_HOMEDIR_LENGTH ((ULONG)   0x00000003L)
#define LSAP_TEST_MAX_HOMEDIR_LENGTH ((ULONG)   0x00000030L)

#define LSAP_TEST_MIN_SCRIPTPATH_LENGTH ((ULONG)  0x00000003L)
#define LSAP_TEST_MAX_SCRIPTPATH_LENGTH ((ULONG)  0x00000100L)

#define LSAP_TEST_MIN_PROFPATH_LENGTH ((ULONG)  0x00000003L)
#define LSAP_TEST_MAX_PROFPATH_LENGTH ((ULONG)  0x00000100L)

#define LSAP_TEST_MIN_DRIVE_LENGTH ((ULONG)     0x00000001L)
#define LSAP_TEST_MAX_DRIVE_LENGTH ((ULONG)     0x00000001L)

#define LSAP_TEST_MIN_ADMCMT_LENGTH ((ULONG)     0x00000003L)
#define LSAP_TEST_MAX_ADMCMT_LENGTH ((ULONG)     0x00000100L)

#define LSAP_TEST_MIN_WKSTA_LENGTH ((ULONG)     0x00000003L)
#define LSAP_TEST_MAX_WKSTA_LENGTH ((ULONG)     0x00000040L)

#define LSAP_TEST_MIN_USER_COMMENT_LENGTH ((ULONG)     0x00000003L)
#define LSAP_TEST_MAX_USER_COMMENT_LENGTH ((ULONG)     0x00000040L)

#define LSAP_TEST_MIN_PARAMS_LENGTH ((ULONG)     0x00000003L)
#define LSAP_TEST_MAX_PARAMS_LENGTH ((ULONG)     0x00000040L)

#define LSAP_TEST_MIN_PRIVDATA_LENGTH ((ULONG)     0x00000003L)
#define LSAP_TEST_MAX_PRIVDATA_LENGTH ((ULONG)     0x00000040L)

    NTSTATUS Status;

    Status = LsapDbTestGenUnicodeString(
                 &UserInformation->UserName,
                 LSAP_TEST_MIN_USERNAME_LENGTH,
                 LSAP_TEST_MAX_USERNAME_LENGTH
                 );

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    Status = LsapDbTestGenUnicodeString(
                 &UserInformation->FullName,
                 LSAP_TEST_MIN_FULLNAME_LENGTH,
                 LSAP_TEST_MAX_FULLNAME_LENGTH
                 );

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    Status = LsapDbTestGenUnicodeString(
                 &UserInformation->HomeDirectoryDrive,
                 LSAP_TEST_MIN_DRIVE_LENGTH,
                 LSAP_TEST_MAX_DRIVE_LENGTH
                 );

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    Status = LsapDbTestGenUnicodeString(
                 &UserInformation->HomeDirectory,
                 LSAP_TEST_MIN_HOMEDIR_LENGTH,
                 LSAP_TEST_MAX_HOMEDIR_LENGTH
                 );

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    Status = LsapDbTestGenUnicodeString(
                 &UserInformation->ScriptPath,
                 LSAP_TEST_MIN_SCRIPTPATH_LENGTH,
                 LSAP_TEST_MAX_SCRIPTPATH_LENGTH
                 );

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    Status = LsapDbTestGenUnicodeString(
                 &UserInformation->ProfilePath,
                 LSAP_TEST_MIN_PROFPATH_LENGTH,
                 LSAP_TEST_MAX_PROFPATH_LENGTH
                 );

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    Status = LsapDbTestGenUnicodeString(
                 &UserInformation->AdminComment,
                 LSAP_TEST_MIN_ADMCMT_LENGTH,
                 LSAP_TEST_MAX_ADMCMT_LENGTH
                 );

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    Status = LsapDbTestGenUnicodeString(
                 &UserInformation->WorkStations,
                 LSAP_TEST_MIN_WKSTA_LENGTH,
                 LSAP_TEST_MAX_WKSTA_LENGTH
                 );

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    Status = LsapDbTestGenUnicodeString(
                 &UserInformation->UserComment,
                 LSAP_TEST_MIN_USER_COMMENT_LENGTH,
                 LSAP_TEST_MAX_USER_COMMENT_LENGTH
                 );

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    Status = LsapDbTestGenUnicodeString(
                 &UserInformation->Parameters,
                 LSAP_TEST_MIN_PARAMS_LENGTH,
                 LSAP_TEST_MAX_PARAMS_LENGTH
                 );

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    Status = LsapDbTestGenUnicodeString(
                 (PUNICODE_STRING) &UserInformation->PrivateData,
                 LSAP_TEST_MIN_PRIVDATA_LENGTH,
                 LSAP_TEST_MAX_PRIVDATA_LENGTH
                 );

    return(Status);
}

NTSTATUS
LsapDbTestGenUnicodeString(
    OUT PUNICODE_STRING OutputString,
    IN ULONG MinimumLength,
    IN ULONG MaximumLength
    )

/*++

Routine Description:

    This function generates a pseudo-random Unicode String whose length
    lies within the indicated bounds.

Arguments:

    OutputString - Points to output UNICODE_STRING structure to be
        initialized.

    MinimumLength - Minimum length required in wide characters.

    MaximumLength - Maximum length required in wide characters.

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    OutputString->Length = (USHORT) (sizeof(WCHAR) * LsapDbTestGenRandomNumber(
                                                        MinimumLength,
                                                        MaximumLength
                                                        ));

    OutputString->Buffer = LsapDbTestGenRandomStringPointer(
                               (OutputString->Length / 2)
                               );

    OutputString->MaximumLength = OutputString->Length;

    return(Status);
}

PWSTR
LsapDbTestGenRandomStringPointer(
    IN ULONG MinLengthToLeaveAtEnd
    )

/*++

Routine Description:

    This function returns a random pointer to a location within a global
    block of text.

Arguments:

    MinLengthToLeaveAtEnd - Specifies the minimum length of the string
        in Wide Chars from the returned pointer to the end of the global buffer.

Return Values:

    PUCHAR - Receives a pointer referencing a character within the block
        of text.

--*/

{
    WCHAR Temp;

    ULONG Offset = LsapDbTestGenRandomNumber(
                       0,
                       (ULONG) 512 - MinLengthToLeaveAtEnd
                       );

    ULONG Offset1 = LsapDbTestGenRandomNumber(
                       0,
                       (ULONG) 512 - 1
                       );

    ULONG Offset2 = LsapDbTestGenRandomNumber(
                       0,
                       (ULONG) 512 - 1
                       );

    ULONG Offset3 = LsapDbTestGenRandomNumber(
                       0,
                       (ULONG) 512 - 1
                       );

    ULONG Offset4 = LsapDbTestGenRandomNumber(
                       0,
                       (ULONG) 512 - 1
                       );

    //
    // Randomly alter the 2nd to 6th characters of the selected string.
    //

    Temp = TextBuffer[Offset + 1];
    TextBuffer[Offset + 1] = TextBuffer[Offset1];
    TextBuffer[Offset1] = Temp;

    if ((Offset > 0) && (Offset < (ULONG) (512 - 2))) {

        Temp = TextBuffer[Offset + 2];
        TextBuffer[Offset + 2] = TextBuffer[Offset2];
        TextBuffer[Offset2] = Temp;
    }

    if ((Offset > 0) && (Offset < (ULONG) (512 - 3))) {

        Temp = TextBuffer[Offset + 3];
        TextBuffer[Offset + 3] = TextBuffer[Offset3];
        TextBuffer[Offset3] = Temp;
    }

    if ((Offset > 0) && (Offset < (ULONG) (512 - 4))) {

        Temp = TextBuffer[Offset + 4];
        TextBuffer[Offset + 4] = TextBuffer[Offset4];
        TextBuffer[Offset4] = Temp;
    }

    return(&TextBuffer[Offset]);
}


ULONG
LsapDbTestGenRandomNumber(
    IN ULONG MinimumValue,
    IN ULONG MaximumValue
    )

/*++

Routine Description:

    This function generates a pseudo-random unsigned integer lying between
    two values.

Arguments:

    MinimumValue - The minimum value of the random number

    MaximumValue - The maximum value of the random number

--*/

{
    ULONG NextValue, NextValue1, NextValue2;
    ULONG MaxPossValue = 88 + 87 + 43 + 64 + 99 + 99;

    Array0Index++;
    if (Array0Index == sizeof(Array0) / sizeof(ULONG)) {

        Array0Index = 0;
    }

    Array1Index++;
    if (Array1Index == sizeof(Array1) / sizeof(ULONG)) {

        Array1Index = 0;
    }

    Array2Index++;
    if (Array2Index == sizeof(Array2) / sizeof(ULONG)) {

        Array2Index = 0;
    }

    Array3Index++;
    if (Array3Index == sizeof(Array3) / sizeof(ULONG)) {

        Array3Index = 0;
    }

    Array4Index++;
    if (Array4Index == sizeof(Array4) / sizeof(ULONG)) {

        Array4Index = 0;
    }

    Array5Index++;
    if (Array5Index == sizeof(Array5) / sizeof(ULONG)) {

        Array5Index = 0;
    }

    NextValue1 = Array0[Array0Index] +
                 Array1[Array1Index] +
                 Array2[Array2Index] +
                 Array3[Array3Index] +
                 Array4[Array4Index] +
                 Array5[Array5Index];

    Array0Index++;
    if (Array0Index == sizeof(Array0) / sizeof(ULONG)) {

        Array0Index = 0;
    }

    Array1Index++;
    if (Array1Index == sizeof(Array1) / sizeof(ULONG)) {

        Array1Index = 0;
    }

    Array2Index++;
    if (Array2Index == sizeof(Array2) / sizeof(ULONG)) {

        Array2Index = 0;
    }

    Array3Index++;
    if (Array3Index == sizeof(Array3) / sizeof(ULONG)) {

        Array3Index = 0;
    }

    Array4Index++;
    if (Array4Index == sizeof(Array4) / sizeof(ULONG)) {

        Array4Index = 0;
    }

    Array5Index++;
    if (Array5Index == sizeof(Array5) / sizeof(ULONG)) {

        Array5Index = 0;
    }

    NextValue2 = Array0[Array0Index] +
                 Array1[Array1Index] +
                 Array2[Array2Index] +
                 Array3[Array3Index] +
                 Array4[Array4Index] +
                 Array5[Array5Index];

    if (NextValue2 > NextValue1) {

        NextValue = NextValue2 - NextValue1;

    } else {

        NextValue = NextValue1 - NextValue2;
    }

    NextValue = MinimumValue +
                    (MaximumValue - MinimumValue) * NextValue / MaxPossValue;

    return(NextValue);
}

#endif // LSA_SAM_ACCOUNTS_DOMAIN_TEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbsecret.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbsecret.c

Abstract:

    LSA - Database - Secret Object Private API Workers

    NOTE:  This module should remain as portable code that is independent
           of the implementation of the LSA Database.  As such, it is
           permitted to use only the exported LSA Database interfaces
           contained in db.h and NOT the private implementation
           dependent functions in dbp.h.

Author:

    Scott Birrell       (ScottBi)      December 12, 1991

Environment:

Revision History:

--*/
#include <lsapch2.h>
#include "dbp.h"
#include <lmcons.h>     // CRYPT_TXT_LEN
#include <crypt.h>      // required for logonmsv.h
#include <logonmsv.h>   // SSI_SECRET_NAME
#include <kerberos.h>   // KERB_CHANGE_MACH_PWD_REQUEST
#include <ntddnfs.h>    // DD_NFS_DEVICE_NAME_U
#include <remboot.h>    // LMMR_RI_XXX
#include <lsawmi.h>


#if defined(REMOTE_BOOT)
//
// This BOOLEAN tracks whether we have received the first LsarQuerySecret()
// call for the the machine account secret. On the first call, we check
// with the remote boot code to see if the password has changed while
// the machine was off.
//

static BOOLEAN FirstMachineAccountQueryDone = FALSE;
#endif // defined(REMOTE_BOOT)

//
// The name of the machine account password secret.
//

static UNICODE_STRING LsapMachineSecret = { sizeof(SSI_SECRET_NAME)-sizeof(WCHAR), sizeof(SSI_SECRET_NAME), SSI_SECRET_NAME};

VOID
LsaIFree_LSAI_SECRET_ENUM_BUFFER (
    IN PVOID Buffer,
    IN ULONG Count
    );

//
// The real function that LsarSetSecret() calls.
//

NTSTATUS
LsapDbSetSecret(
    IN LSAPR_HANDLE SecretHandle,
    IN OPTIONAL PLSAPR_CR_CIPHER_VALUE CipherCurrentValue,
    IN OPTIONAL PLARGE_INTEGER CurrentTime,
    IN OPTIONAL PLSAPR_CR_CIPHER_VALUE CipherOldValue,
    IN OPTIONAL PLARGE_INTEGER OldTime
#if defined(REMOTE_BOOT)
    ,
    IN BOOLEAN RemoteBootMachinePasswordChange
#endif // defined(REMOTE_BOOT)
    );

BOOLEAN
LsapDbSecretIsMachineAcc(
    IN LSAPR_HANDLE SecretHandle
    )
/*++

Routine Description:

    This function determines if the given handle refers to the local machine account

Arguments:

    SecretHandle -  Handle from an LsaOpenSecret call.

Return Values:

    TRUE -- The handle refers to the machine account

    FALSE -- It doesn't

--*/
{
    BOOLEAN IsMachAcc = FALSE;
    UNICODE_STRING CheckSecret;
    LSAP_DB_HANDLE Handle = ( LSAP_DB_HANDLE )SecretHandle;

    RtlInitUnicodeString( &CheckSecret, L"$MACHINE.ACC" );

    if ( RtlEqualUnicodeString( &CheckSecret, &Handle->LogicalNameU, TRUE ) ) {

        IsMachAcc = TRUE;
    }

    return( IsMachAcc );
}



NTSTATUS
LsarCreateSecret(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE SecretHandle
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaCreateSecret API.

    The LsaCreateSecret API creates a named Secret object in the
    Lsa Database.  Each Secret Object can have two values assigned,
    called the Current Value and the Old Value.  The meaning of these
    values is known to the Secret object creator.  The caller must have
    LSA_CREATE_SECRET access to the LsaDatabase object.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    SecretName - Pointer to Unicode String specifying the name of the
        secret.

    DesiredAccess - Specifies the accesses to be granted to the newly
        created and opened secret.

    SecretHandle - Receives a handle to the newly created and opened
        Secret object.  This handle is used on subsequent accesses to
        the object until closed.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_COLLISION - A Secret object having the given name
            already exists.

        STATUS_TOO_MANY_SECRETS - The maximum number of Secret objects in the
            system has been reached.

        STATUS_NAME_TOO_LONG - The name of the secret is too long to be stored
            in the LSA database.
--*/

{
    NTSTATUS Status, SecondaryStatus;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    BOOLEAN ContainerReferenced = FALSE;
    ULONG CriticalValue = 0;
    LSAP_DB_ATTRIBUTE Attributes[3];
    ULONG TypeSpecificAttributeCount;
    LARGE_INTEGER CreationTime;
    ULONG Index;
    ULONG CreateOptions = 0;
    ULONG CreateDisp = 0;
    ULONG ReferenceOptions = LSAP_DB_LOCK |
                                 LSAP_DB_DS_OP_TRANSACTION |
                                 LSAP_DB_READ_ONLY_TRANSACTION;
    ULONG DereferenceOptions = LSAP_DB_LOCK |
                                  LSAP_DB_DS_OP_TRANSACTION |
                                  LSAP_DB_READ_ONLY_TRANSACTION;
    BOOLEAN GlobalSecret = FALSE;
    BOOLEAN DsTrustedDomainSecret = FALSE;
    ULONG SecretType;
    LSAP_DB_HANDLE InternalHandle;

    LsarpReturnCheckSetup();
    LsapEnterFunc( "LsarCreateSecret" );


    //
    // Check to see if the lenght of the name is within the limits of the
    // LSA database.
    //

    if ( SecretName->Length > LSAP_DB_LOGICAL_NAME_MAX_LENGTH ) {

        LsapExitFunc( "LsarCreateSecret", STATUS_NAME_TOO_LONG );
        return(STATUS_NAME_TOO_LONG);
    }

    //
    // Validate the input buffer
    //
    if ( !LsapValidateLsaUnicodeString( SecretName ) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto CreateSecretError;
    }


    //
    // Check for Local Secret creation request.  If the Secret name does
    // not begin with the Global Secret Prefix, the Secret is local.  In
    // this case, creation of the secret is allowed on BDC's as well as
    // PDC's and Workstations.  Creation of Global Secrets is not
    // allowed on BDC's except for trusted callers such as a Replicator.
    //
    SecretType = LsapDbGetSecretType( SecretName );

    if ( FLAG_ON( SecretType, LSAP_DB_SECRET_GLOBAL ) ) {

        GlobalSecret = TRUE;
    }

    if (!GlobalSecret) {

        CreateOptions |= LSAP_DB_OMIT_REPLICATOR_NOTIFICATION;
        ReferenceOptions |= LSAP_DB_OMIT_REPLICATOR_NOTIFICATION;

    } else {

        CreateOptions |= LSAP_DB_OBJECT_SCOPE_DS;
    }

    //
    // It isn't legal to create a TrustedDomain secret of the form G$$<DomainName>.
    //
    // There is a race condition between creating such secrets and converting the
    // TDO between inbound and outbound.  It is pragmatic to simply not allow
    // creation of G$$ secrets and then not worry about morphing such objects into TDOs.
    //

    if ( FLAG_ON( SecretType, LSAP_DB_SECRET_TRUSTED_DOMAIN ) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto CreateSecretError;
    }


    //
    // Acquire the Lsa Database lock.  Verify that the connection handle
    // (container object handle) is valid, is of the expected type and has
    // all of the desired accesses granted.  Reference the container
    // object handle.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_CREATE_SECRET,
                 PolicyObject,
                 SecretObject,
                 ReferenceOptions
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateSecretError;
    }

    ContainerReferenced = TRUE;

    //
    // Fill in the ObjectInformation structure.  Initialize the
    // embedded Object Attributes with the PolicyHandle as the
    // Root Directory (Container Object) handle and the Logical Name
    // of the account. Store the types of the object and its container.
    //

    InitializeObjectAttributes(
        &ObjectInformation.ObjectAttributes,
        (PUNICODE_STRING)SecretName,
        OBJ_CASE_INSENSITIVE,
        PolicyHandle,
        NULL
        );

    ObjectInformation.ObjectTypeId = SecretObject;
    ObjectInformation.ContainerTypeId = PolicyObject;
    ObjectInformation.Sid = NULL;
    ObjectInformation.ObjectAttributeNameOnly = FALSE;
    ObjectInformation.DesiredObjectAccess = DesiredAccess;

    //
    // Set up the Creation Time as a Type Specific Attribute.
    //

    GetSystemTimeAsFileTime( (LPFILETIME) &CreationTime );

    Index = 0;

    LsapDbInitializeAttributeDs( &Attributes[Index],
                                 CupdTime,
                                 &CreationTime,
                                 sizeof( LARGE_INTEGER ),
                                 FALSE );
    Index++;
    LsapDbInitializeAttributeDs( &Attributes[Index],
                                 OupdTime,
                                 &CreationTime,
                                 sizeof( LARGE_INTEGER ),
                                 FALSE );
    Index++;


    TypeSpecificAttributeCount = Index;

    //
    // We'll have to see whether we have a global secret for a trusted domain in the
    // DS or just a global secret.  If it's the first case, we'll need to locate the
    // TrustedDomain object and then we'll set the attributes on that.
    //
    if ( GlobalSecret ) {

        Status = LsapDsIsSecretDsTrustedDomain( (PUNICODE_STRING)SecretName,
                                                &ObjectInformation,
                                                CreateOptions,
                                                DesiredAccess,
                                                SecretHandle,
                                                &DsTrustedDomainSecret );

        //
        // If it's a Ds trusted domain, we don't do anything with it.  If it's a global secret,
        // then we'll go ahead and do our normal proceesing
        //
        if ( NT_SUCCESS( Status ) ) {

            if ( DsTrustedDomainSecret ) {

                goto CreateSecretFinish;

            }
        }


        if ( LsaDsStateInfo.UseDs ) {

            CreateDisp = LSAP_DB_CREATE_OBJECT_IN_DS;

            //
            // We are doing secret creation.  This means that this an object that we'll need to
            // mark for initial system replication when setting up a new replica
            //
            CriticalValue = 1;
            LsapDbInitializeAttributeDs( &Attributes[Index],
                                         PseudoSystemCritical,
                                         &CriticalValue,
                                         sizeof( ULONG ),
                                         FALSE );
            Index++;
            TypeSpecificAttributeCount++;

        }
    }

    ASSERT( sizeof( Attributes ) / sizeof( LSAP_DB_ATTRIBUTE ) >= TypeSpecificAttributeCount );

    if ( NT_SUCCESS( Status ) ) {

        //
        // Create the Secret Object.  We fail if the object already exists.
        // Note that the object create routine performs a Database transaction.
        //

        Status = LsapDbCreateObject(
                     &ObjectInformation,
                     DesiredAccess,
                     LSAP_DB_OBJECT_CREATE | CreateDisp,
                     CreateOptions,
                     Attributes,
                     TypeSpecificAttributeCount,
                     SecretHandle
                     );

        //
        // If we are creating a secret in the ds, set the flag in the handle to know that
        // we just created the secret.  We'll use this later on to urgently replicate the change
        //
        if ( NT_SUCCESS( Status ) && GlobalSecret ) {

            ((LSAP_DB_HANDLE)( *SecretHandle ) )->Options |= LSAP_DB_HANDLE_CREATED_SECRET;
        }

        //
        // Set the internal secret flag if necessary
        //
        if ( NT_SUCCESS( Status ) ) {

            InternalHandle = ( LSAP_DB_HANDLE )( *SecretHandle );

            if ( FLAG_ON( SecretType, LSAP_DB_SECRET_LOCAL ) ) {

                InternalHandle->ObjectOptions |= LSAP_DB_OBJECT_SECRET_LOCAL;

            }

            if ( FLAG_ON( SecretType, LSAP_DB_SECRET_SYSTEM ) ) {

                InternalHandle->ObjectOptions |= LSAP_DB_OBJECT_SECRET_INTERNAL;

            }
        }

    }

    if (!NT_SUCCESS(Status)) {

        goto CreateSecretError;
    }

CreateSecretFinish:

    //
    // If necessary, release the LSA Database lock.
    //

    if (ContainerReferenced) {

        LsapDbApplyTransaction( PolicyHandle,
                                LSAP_DB_DS_OP_TRANSACTION |
                                    LSAP_DB_READ_ONLY_TRANSACTION,
                                (SECURITY_DB_DELTA_TYPE) 0 );

        LsapDbReleaseLockEx( SecretObject,
                             LSAP_DB_READ_ONLY_TRANSACTION);
    }

#ifdef TRACK_HANDLE_CLOSE
    if (*SecretHandle == LsapDbHandle)
    {
        DbgPrint("Closing global policy handle!!!\n");
        DbgBreakPoint();
    }
#endif
    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarCreateSecret: 0x%lx\n", Status ));

    return( Status );

CreateSecretError:

    //
    // If necessary, dereference the Container Object.
    //

    if (ContainerReferenced) {

        SecondaryStatus = LsapDbDereferenceObject(
                              &PolicyHandle,
                              PolicyObject,
                              SecretObject,
                              DereferenceOptions,
                              (SECURITY_DB_DELTA_TYPE) 0,
                              Status
                              );
        LsapDbSetStatusFromSecondary( Status, SecondaryStatus );

        ContainerReferenced = FALSE;
    }

    goto CreateSecretFinish;

}


NTSTATUS
LsarOpenSecret(
    IN LSAPR_HANDLE ConnectHandle,
    IN PLSAPR_UNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE SecretHandle
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the LsaOpenSecret
    API.

    The LsaOpenSecret API opens a Secret Object within the LSA Database.
    A handle is returned which must be used to perform operations on the
    secret object.

Arguments:

    ConnectHandle - Handle from an LsaOpenLsa call.

    DesiredAccess - This is an access mask indicating accesses being
        requested for the secret object being opened.  These access types
        are reconciled with the Discretionary Access Control List of the
        target secret object to determine whether the accesses will be
        granted or denied.

    SecretName - Pointer to a Unicode String structure that references the
        name of the Secret object to be opened.

    SecretHandle - Pointer to location that will receive a handle to the
        newly opened Secret object.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_NOT_FOUND - There is no Secret object in the
            target system's LSA Database having the specified SecretName.

--*/

{
    NTSTATUS Status, SecondaryStatus;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    BOOLEAN ContainerReferenced = FALSE;
    BOOLEAN AcquiredLock = FALSE;
    BOOLEAN GlobalSecret = FALSE;
    ULONG OpenOptions = 0;
    ULONG ReferenceOptions = LSAP_DB_LOCK |
                                 LSAP_DB_DS_OP_TRANSACTION |
                                 LSAP_DB_READ_ONLY_TRANSACTION;
    BOOLEAN DsTrustedDomainSecret = FALSE;
    ULONG SecretType;
    LSAP_DB_HANDLE InternalHandle;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarOpenSecret\n" ));


    //
    // Validate the input buffer
    //
    if ( !LsapValidateLsaUnicodeString( SecretName ) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto OpenSecretError;
    }

    //
    // Check for Local Secret open request.  If the Secret name does
    // not begin with the Global Secret Prefix, the Secret is local.  In
    // this case, update/deletion of the secret is allowed on BDC's as well as
    // PDC's and Workstations.  Update/deletion of Global Secrets is not
    // allowed on BDC's except for trusted callers such as a Replicator.
    // To facilitate validation of the open request on BDC's we record
    // that the BDC check should be omitted on the container reference, and
    // that the replicator notification should be omitted on a commit.
    //

    SecretType = LsapDbGetSecretType( SecretName );

    if ( FLAG_ON( SecretType, LSAP_DB_SECRET_GLOBAL ) ) {

        GlobalSecret = TRUE;
    }

    if (!GlobalSecret) {

        OpenOptions |= LSAP_DB_OMIT_REPLICATOR_NOTIFICATION;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the connection handle
    // (container object handle) is valid, and is of the expected type.
    // Reference the container object handle.  This reference remains in
    // effect until the child object handle is closed.
    //

    Status = LsapDbReferenceObject(
                 ConnectHandle,
                 0,
                 PolicyObject,
                 SecretObject,
                 ReferenceOptions
                 );

    if (!NT_SUCCESS(Status)) {

        goto OpenSecretError;
    }

    AcquiredLock = TRUE;
    ContainerReferenced =TRUE;

    //
    // Setup Object Information prior to calling the LSA Database Object
    // Open routine.  The Object Type, Container Object Type and
    // Logical Name (derived from the Sid) need to be filled in.
    //

    ObjectInformation.ObjectTypeId = SecretObject;
    ObjectInformation.ContainerTypeId = PolicyObject;
    ObjectInformation.Sid = NULL;
    ObjectInformation.ObjectAttributeNameOnly = FALSE;
    ObjectInformation.DesiredObjectAccess = DesiredAccess;

    //
    // Initialize the Object Attributes.  The Container Object Handle and
    // Logical Name (Internal Name) of the object must be set up.
    //

    InitializeObjectAttributes(
        &ObjectInformation.ObjectAttributes,
        (PUNICODE_STRING)SecretName,
        0,
        ConnectHandle,
        NULL
        );

    //
    // Open the specific Secret object.  Note that the account object
    // handle returned is an RPC Context Handle.
    //

    if ( GlobalSecret ) {

        Status = LsapDsIsSecretDsTrustedDomain( (PUNICODE_STRING)SecretName,
                                                &ObjectInformation,
                                                ((LSAP_DB_HANDLE)ConnectHandle)->Options,
                                                DesiredAccess,
                                                SecretHandle,
                                                &DsTrustedDomainSecret );
        //
        // If it's a Ds trusted domain, we don't do anything with it.  If it's a global secret,
        // then we'll go ahead and do our normal proceesing
        //
        if ( NT_SUCCESS( Status ) ) {

            if( DsTrustedDomainSecret ) {

                InternalHandle = ( LSAP_DB_HANDLE )( *SecretHandle );
                InternalHandle->ObjectOptions |= LSAP_DB_OBJECT_SECRET_INTERNAL;
                goto OpenSecretFinish;

            } else {

                OpenOptions |= LSAP_DB_OBJECT_SCOPE_DS;

            }

        }

    }

    if ( NT_SUCCESS( Status ) ) {

        Status = LsapDbOpenObject( &ObjectInformation,
                                   DesiredAccess,
                                   OpenOptions,
                                   SecretHandle );

        if ( Status == STATUS_OBJECT_NAME_NOT_FOUND && GlobalSecret ) {

            //
            // It's possible that we have a manually created global secret... This
            // would not have the SECRET postfix on the name...
            //
            ObjectInformation.ObjectAttributeNameOnly = TRUE;
            Status = LsapDbOpenObject( &ObjectInformation,
                                       DesiredAccess,
                                       OpenOptions,
                                       SecretHandle );
        }

        //
        // Set the internal secret flag if necessary
        //
        if ( NT_SUCCESS( Status ) ) {

            InternalHandle = ( LSAP_DB_HANDLE )( *SecretHandle );

            if ( FLAG_ON( SecretType, LSAP_DB_SECRET_LOCAL ) ) {

                InternalHandle->ObjectOptions |= LSAP_DB_OBJECT_SECRET_LOCAL;

            }

            if ( FLAG_ON( SecretType, LSAP_DB_SECRET_SYSTEM ) ) {

                InternalHandle->ObjectOptions |= LSAP_DB_OBJECT_SECRET_INTERNAL;

            }
        }
    }

    //
    // If the open failed, dereference the container object.
    //

    if (!NT_SUCCESS(Status)) {

        goto OpenSecretError;
    }

OpenSecretFinish:

    //
    // If necessary, release the LSA Database lock.
    //

    if (AcquiredLock) {

        LsapDbApplyTransaction( ConnectHandle,
                                LSAP_DB_DS_OP_TRANSACTION |
                                    LSAP_DB_READ_ONLY_TRANSACTION,
                                (SECURITY_DB_DELTA_TYPE) 0 );

        LsapDbReleaseLockEx( SecretObject,
                             LSAP_DB_READ_ONLY_TRANSACTION );
    }

#ifdef TRACK_HANDLE_CLOSE
    if (*SecretHandle == LsapDbHandle)
    {
        DbgPrint("Closing global policy handle!!!\n");
        DbgBreakPoint();
    }
#endif

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarOpenSecret:0x%lx\n", Status ));

    return(Status);

OpenSecretError:

    //
    // If necessary, dereference the Container Object handle.  Note that
    // this is only done in the error case.  In the non-error case, the
    // Container handle stays referenced until the Account object is
    // closed.
    //

    if (ContainerReferenced) {

        *SecretHandle = NULL;

        SecondaryStatus = LsapDbDereferenceObject(
                              &ConnectHandle,
                              PolicyObject,
                              SecretObject,
                              LSAP_DB_DS_OP_TRANSACTION |
                                 LSAP_DB_READ_ONLY_TRANSACTION,
                              (SECURITY_DB_DELTA_TYPE) 0,
                              Status
                              );
        LsapDbSetStatusFromSecondary( Status, SecondaryStatus );
    }

    goto OpenSecretFinish;
}


NTSTATUS
LsapNotifySecurityPackagesOfPasswordChange(
    IN PLSAP_CR_CLEAR_VALUE CurrentValue,
    IN OPTIONAL PLSAP_CR_CLEAR_VALUE OldValue
    )
/*++

Routine Description:

    Call the Kerberos package to let it know that the machine's
    password has changed. This should only be called after it has
    been updated successfully on the server.

Arguments:

    NewPassword - The new NT OWF for the machine.

Return Value:

    none

--*/
{

    SECPKG_PRIMARY_CRED     PrimaryCred;
    ULONG_PTR               OldPackage;
    PLSAP_SECURITY_PACKAGE  pAuxPackage;
    NTSTATUS                scRet = STATUS_SUCCESS;


    //
    // If we are being called during initialization
    // then return success.
    //

    if (!LsapDbState.DbServerInitialized)
    {
        return( STATUS_SUCCESS);
    }

    if ( CurrentValue == NULL ) {

        return( STATUS_SUCCESS );
    }


    DebugLog((DEB_TRACE, "Updating machine credentials.\n"));



    RtlZeroMemory(
        &PrimaryCred,
        sizeof(PrimaryCred)
        );


    PrimaryCred.Password.Buffer = (LPWSTR) CurrentValue->Buffer;
    PrimaryCred.Password.Length = (USHORT) CurrentValue->Length;
    PrimaryCred.Password.MaximumLength = (USHORT) CurrentValue->MaximumLength;
    PrimaryCred.Flags = PRIMARY_CRED_CLEAR_PASSWORD | PRIMARY_CRED_UPDATE;

    if (OldValue != NULL)
    {
        PrimaryCred.OldPassword.Buffer = (LPWSTR) OldValue->Buffer;
        PrimaryCred.OldPassword.Length = (USHORT) OldValue->Length;
        PrimaryCred.OldPassword.MaximumLength = (USHORT) OldValue->MaximumLength;
    }


    OldPackage = GetCurrentPackageId();


    pAuxPackage = SpmpIteratePackagesByRequest( NULL, SP_ORDINAL_ACCEPTCREDS );

    while (pAuxPackage)
    {
        ULONG_PTR iPackage;
        LUID NetworkServiceLogonId = NETWORKSERVICE_LUID;

        iPackage = pAuxPackage->dwPackageID;

        DebugLog((DEB_TRACE_INIT, "Updating package %ws with %x:%xn",
            pAuxPackage->Name.Buffer,
            SystemLogonId.HighPart, SystemLogonId.LowPart
            ));

        SetCurrentPackageId(iPackage);

        //
        // call each package twice:
        // once for the SYSTEM_LUID
        // once for the NETWORKSERVICE_LUID
        //
        // Note:  if an exception occurs, we don't fail the logon, we just
        // do the magic on the package that blew.  If the package blows,
        // the other packages may succeed, and so the user may not be able
        // to use that provider.

        PrimaryCred.LogonId = SystemLogonId;

        __try
        {

            scRet = pAuxPackage->FunctionTable.AcceptCredentials(
                        Interactive,
                        NULL,
                        &PrimaryCred,
                        NULL            // no supplemental credentials
                        );
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            scRet = (NTSTATUS) GetExceptionCode();
            scRet = SPException(scRet, iPackage);
        }

        PrimaryCred.LogonId = NetworkServiceLogonId;

        __try
        {

            scRet = pAuxPackage->FunctionTable.AcceptCredentials(
                        Interactive,
                        NULL,
                        &PrimaryCred,
                        NULL            // no supplemental credentials
                        );
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            scRet = (NTSTATUS) GetExceptionCode();
            scRet = SPException(scRet, iPackage);
        }


        pAuxPackage = SpmpIteratePackagesByRequest( pAuxPackage,
                                                    SP_ORDINAL_ACCEPTCREDS );

    }


    //
    // Finally, set this thread back.
    //

    SetCurrentPackageId( OldPackage );


    return scRet;

}

#if defined(REMOTE_BOOT)
NTSTATUS
LsapNotifyRemoteBootOfPasswordChange(
    IN PLSAP_CR_CLEAR_VALUE CurrentValue,
    IN OPTIONAL PLSAP_CR_CLEAR_VALUE OldValue
    )
/*++

Routine Description:

    Call the remote boot package to let it know that the machine's
    password has changed.

Arguments:

    CurrentValue - The cleartext new password.

    OldValue - The cleartext old password.

Return Value:

    Result of the operation.

--*/
{
    NTSTATUS Status ;
    HANDLE RdrDevice ;
    UNICODE_STRING String ;
    OBJECT_ATTRIBUTES ObjA ;
    ULONG SetPasswordLength ;
    PLMMR_RI_SET_NEW_PASSWORD SetPassword ;
    IO_STATUS_BLOCK IoStatus ;

    //
    // Open the redirector device.
    //

    RtlInitUnicodeString( &String, DD_NFS_DEVICE_NAME_U );

    InitializeObjectAttributes( &ObjA,
                                &String,
                                0,
                                0,
                                0);

    Status = NtOpenFile( &RdrDevice,
                         GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                         &ObjA,
                         &IoStatus,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         0 );

    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_ERROR, "FAILED to open %ws, status %x\n",
                        String.Buffer, Status ));
        return Status;
    }

    //
    // Construct the buffer that has the passwords in it.
    //

    SetPasswordLength = FIELD_OFFSET(LMMR_RI_SET_NEW_PASSWORD, Data[0]) +
                        CurrentValue->Length;
    if (ARGUMENT_PRESENT(OldValue)) {
        SetPasswordLength += OldValue->Length;
    }

    SetPassword = (PLMMR_RI_SET_NEW_PASSWORD) LsapAllocateLsaHeap( SetPasswordLength );
    if (SetPassword == NULL) {
        NtClose(RdrDevice);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SetPassword->Length1 = CurrentValue->Length;
    if (ARGUMENT_PRESENT(OldValue)) {
        SetPassword->Length2 = OldValue->Length;
    } else {
        SetPassword->Length2 = 0;
    }

    RtlCopyMemory(
        SetPassword->Data,
        CurrentValue->Buffer,
        CurrentValue->Length);

    if (ARGUMENT_PRESENT(OldValue)) {
        RtlCopyMemory(
            SetPassword->Data + CurrentValue->Length,
            OldValue->Buffer,
            OldValue->Length);
    }

    Status = NtFsControlFile(
                    RdrDevice,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    FSCTL_LMMR_RI_SET_NEW_PASSWORD,
                    SetPassword,
                    SetPasswordLength,
                    NULL,
                    0 );

    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_ERROR, "FAILED to FSCTL_LMMR_RI_SET_NEW_PASSWORD %ws, status %x\n",
                        String.Buffer, Status ));
    }

    LsapFreeLsaHeap(SetPassword);
    NtClose(RdrDevice);

    return Status;

}

NTSTATUS
LsapCheckRemoteBootForPasswordChange(
    IN LSAP_DB_HANDLE InternalHandle
    )
/*++

Routine Description:

    Check with the remote boot package to see if the machine account
    secret has changed, and if so, set the new value.
    NOTE: This routine is called with the database lock held.

Arguments:

    InternalHandle - A handle to the machine account secret.

Return Value:

    Result of the operation.

--*/
{
    NTSTATUS Status;

    UNICODE_STRING DeviceName;

    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE RedirHandle = NULL;

    UCHAR PacketBuffer[sizeof(ULONG)+64];
    PLMMR_RI_CHECK_FOR_NEW_PASSWORD RequestPacket = (PLMMR_RI_CHECK_FOR_NEW_PASSWORD)PacketBuffer;

    LSAPR_HANDLE SecretHandle = NULL;
    PLSAP_CR_CIPHER_VALUE CurrentValue = NULL;
    LSAP_CR_CLEAR_VALUE NewValue;

    //
    // First see if the redirector has a new password to tell us. This
    // will fail unless the password has changed while the machine is
    // off.
    //

    RtlInitUnicodeString(&DeviceName, DD_NFS_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                   &RedirHandle,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   0,
                   0
                   );

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;
    }

    if (!NT_SUCCESS(Status)) {
        DebugLog(( DEB_ERROR, "FAILED to open %ws, status %x\n",
                        DeviceName.Buffer, Status ));
        Status = STATUS_SUCCESS;
        goto CheckRemoteBootFinish;
    }

    //
    // Send the request to the redir.
    //

    Status = NtFsControlFile(
                    RedirHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    FSCTL_LMMR_RI_CHECK_FOR_NEW_PASSWORD,
                    NULL,  // no input buffer
                    0,
                    PacketBuffer,
                    sizeof(PacketBuffer));

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;
    }

    if ( !NT_SUCCESS( Status ) )
    {
        Status = STATUS_SUCCESS;
        goto CheckRemoteBootFinish;
    }

    //
    // The redir thinks there is a new password, so query the current
    // one, and set the new one as the current one and the current
    // one as the old one.
    //

    Status = LsarOpenSecret( LsapPolicyHandle,
                             (PLSAPR_UNICODE_STRING)&LsapMachineSecret,
                             MAXIMUM_ALLOWED,
                             &SecretHandle );

    if (!NT_SUCCESS(Status)) {

        DebugLog(( DEB_ERROR, "FAILED to LsarOpenSecret for remote boot, status %x\n",
                        Status ));
        goto CheckRemoteBootError;
    }

    //
    // Query the Current Value attribute of the Secret Object.
    //

    Status = LsapDbQueryValueSecret(
                 SecretHandle,
                 CurrVal,
                 NULL,
                 &CurrentValue
                 );

    if (!NT_SUCCESS(Status)) {

        DebugLog(( DEB_ERROR, "FAILED to LsarDbQueryValueSecret for remote boot, status %x\n",
                        Status ));
        goto CheckRemoteBootError;
    }

    //
    // Set the new value if it is different from the current one.
    //

    NewValue.Length = RequestPacket->Length;
    NewValue.MaximumLength = RequestPacket->Length;
    NewValue.Buffer = RequestPacket->Data;

    if ((CurrentValue->Length != NewValue.Length) ||
        !RtlEqualMemory(CurrentValue->Buffer, NewValue.Buffer, CurrentValue->Length)) {

        Status = LsapDbSetSecret( SecretHandle,
                                  ( PLSAPR_CR_CIPHER_VALUE )&NewValue,
                                  NULL,
                                  ( PLSAPR_CR_CIPHER_VALUE )CurrentValue,
                                  NULL
#if defined(REMOTE_BOOT)
                                  ,
                                  TRUE
#endif // defined(REMOTE_BOOT)
                                  );    // this is a remote boot machine password change

        if (!NT_SUCCESS(Status)) {

            DebugLog(( DEB_ERROR, "FAILED to LsapDbSetSecret for remote boot, status %x\n",
                            Status ));
            goto CheckRemoteBootError;
        }

    }

CheckRemoteBootFinish:

    if (RedirHandle != NULL) {
        NtClose(RedirHandle);
    }

    if (SecretHandle != NULL) {
        LsapCloseHandle(&SecretHandle, Status);
    }

    if (CurrentValue != NULL) {
        MIDL_user_free(CurrentValue);
    }

    return(Status);

CheckRemoteBootError:

    goto CheckRemoteBootFinish;

}
#endif // defined(REMOTE_BOOT)

NTSTATUS
LsarSetSecret(
    IN LSAPR_HANDLE SecretHandle,
    IN OPTIONAL PLSAPR_CR_CIPHER_VALUE CipherCurrentValue,
    IN OPTIONAL PLSAPR_CR_CIPHER_VALUE CipherOldValue
    )
{
    return LsapDbSetSecret( SecretHandle,
                            CipherCurrentValue,
                            NULL,
                            CipherOldValue,
                            NULL
#if defined(REMOTE_BOOT)
                            ,
                            FALSE
#endif // defined(REMOTE_BOOT)
                             );   // not a remote boot machine password change
}

NTSTATUS
LsapDbSetSecret(
    IN LSAPR_HANDLE SecretHandle,
    IN OPTIONAL PLSAPR_CR_CIPHER_VALUE CipherCurrentValue,
    IN OPTIONAL PLARGE_INTEGER CurrentTime,
    IN OPTIONAL PLSAPR_CR_CIPHER_VALUE CipherOldValue,
    IN OPTIONAL PLARGE_INTEGER OldTime
#if defined(REMOTE_BOOT)
    ,
    IN BOOLEAN RemoteBootMachinePasswordChange
#endif // defined(REMOTE_BOOT)
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the LsaSetSecret
    API.

    The LsaSetSecret API optionally sets one or both values associated with
    a Secret object.  These values are known as the Current Value and
    Old Value of the Secret object and these values have a meaning known to
    the creator of the object.

    This worker routine receives the Secret values in encrypted form from
    the client.  A two-way encryption algorithm using the Session Key will
    havge been applied.  The values received will first be decrypted using
    this same key and then two-way encrypted using the LSA Database Private
    Encryption Key.  The resulting re-encrypted values will then be stored
    as attributes of the Secret object.

Arguments:

    SecretHandle - Handle from an LsaOpenSecret or LsaCreateSecret call.

    CipherCurrentValue - Optional pointer to an encrypted value structure
        containing the Current Value (if any) to be set for the Secret
        Object (if any).  This value is two-way encrypted with the Session
        Key.  If NULL is specified, the existing Current Value will be left
        assigned to the object will be left unchanged.

    CipherOldValue - Optional pointer to an encrypted value structure
        containing the "old value" (if any) to be set for the Secret
        Object (if any).  If NULL is specified, the existing Old Value will be
        assigned to the object will be left unchanged.

#if defined(REMOTE_BOOT)
    RemoteBootMachinePasswordChange - Indicates that a write lock is already
        held, that it is OK to let this proceed even if the remote boot state
        is CANT_NOTIFY, and that we don't need to notify Kerberos about
        the change (because it hasn't initialized yet).
#endif // defined(REMOTE_BOOT)

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - Handle is invalid.
--*/

{
    NTSTATUS Status;
    LSAP_DB_HANDLE Handle = (LSAP_DB_HANDLE) SecretHandle;

    PLSAP_CR_CLEAR_VALUE ClearCurrentValue = NULL;
    PLSAP_CR_CLEAR_VALUE ClearOldValue = NULL;
    PLSAP_CR_CIPHER_VALUE DbCipherCurrentValue = NULL;
    ULONG DbCipherCurrentValueLength;
    PLSAP_CR_CIPHER_VALUE DbCipherOldValue = NULL;
    ULONG DbCipherOldValueLength;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;
    LARGE_INTEGER UpdatedTime;
    LARGE_INTEGER CurrentSecretTime;
    BOOLEAN ObjectReferenced = FALSE, FreeOldCipher = FALSE, FreeCurrentCipher = FALSE;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) SecretHandle;
    ULONG ReferenceOptions = LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION;
    ULONG DereferenceOptions = LSAP_DB_LOCK | LSAP_DB_FINISH_TRANSACTION;
    BOOLEAN GlobalSecret= FALSE, DsTrustedDomainSecret = FALSE;
    LSAP_DB_ATTRIBUTE Attributes[LSAP_DB_ATTRS_SECRET];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    ULONG AttributeCount = 0;
    BOOLEAN NotifyMachineChange = FALSE;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarSetSecret\n" ));


#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot machine and this request is to set the
    // machine account password, check if we can do it right now. The
    // exception is if the remote boot code is notifying LSA of a changed
    // password, then allow this call through, since it isn't necessary
    // to notify remote boot if it is the source of the change.
    //

    if ((LsapDbState.RemoteBootState == LSAP_DB_REMOTE_BOOT_CANT_NOTIFY) &&
        (RtlEqualUnicodeString(
             &LsapMachineSecret,
             &InternalHandle->LogicalNameU,
             TRUE)) &&        // case insensitive
         !RemoteBootMachinePasswordChange) {

         DebugLog(( DEB_ERROR, "FAILED LsarSetSecret for machine secret, remote boot can't be notified on this boot.\n" ));
         Status = STATUS_ACCESS_DENIED;
         goto SetSecretError;
    }
#endif // defined(REMOTE_BOOT)

    //
    // Check for Local Secret set request.  If the Secret name does
    // not begin with the Global Secret Prefix, the Secret is local.  In
    // this case, update of the secret is allowed on BDC's as well as
    // PDC's and Workstations.  Creation of Global Secrets is not
    // allowed on BDC's except for trusted callers such as a Replicator.
    //

    if ( FLAG_ON( InternalHandle->Options, LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET ) ) {
        GlobalSecret = TRUE;
    } else {
        ULONG SecretType;

        SecretType = LsapDbGetSecretType( ( PLSAPR_UNICODE_STRING )&InternalHandle->LogicalNameU );

        if ( FLAG_ON( SecretType, LSAP_DB_SECRET_GLOBAL ) ) {
            GlobalSecret = TRUE;
        }
    }


    if (GlobalSecret) {
        ReferenceOptions |= LSAP_DB_DS_OP_TRANSACTION;
        DereferenceOptions |= LSAP_DB_DS_OP_TRANSACTION;
    } else {
        ReferenceOptions |= LSAP_DB_NO_DS_OP_TRANSACTION;
        DereferenceOptions |= LSAP_DB_OMIT_REPLICATOR_NOTIFICATION | LSAP_DB_NO_DS_OP_TRANSACTION;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the Secret Object handle is
    // valid, is of the expected type and has all of the desired accesses
    // granted.  Reference the handle and open a database transaction.
    //
#if defined(REMOTE_BOOT)
    // If this is a remote boot machine password change, the lock is
    // already acquired.
    //

    if (!RemoteBootMachinePasswordChange)
#endif // defined(REMOTE_BOOT)
    {

        Status = LsapDbReferenceObject(
                     SecretHandle,
                     SECRET_SET_VALUE,
                     SecretObject,
                     SecretObject,
                     ReferenceOptions
                     );

        if (!NT_SUCCESS(Status)) {

            goto SetSecretError;
        }

        ObjectReferenced = TRUE;

    }

    if( GlobalSecret ) {

        Status = LsapDsIsHandleDsObjectTypeHandle( SecretHandle,
                                                   TrustedDomainObject,
                                                   &DsTrustedDomainSecret );
    }

    //
    // If the client is non-trusted, obtain the Session Key used by the
    // client to two-way encrypt the Current Value and/or Old Values.
    //

    if (!InternalHandle->Trusted) {

        Status = LsapCrServerGetSessionKey( SecretHandle, &SessionKey);

        if (!NT_SUCCESS(Status)) {

            goto SetSecretError;
        }
    }

    //
    // If a Current Value is specified for the Secret Object, and the
    // client is non-trusted, decrypt the value using the Session Key and
    // encrypt it using the LSA Database System Key.  Then (for all
    // clients) encrypt the resulting value with the internal LSA Database
    // encryption key and write resulting Value structure (header followed by
    // buffer to the Policy Database as the Current Value attribute of the
    // Secret object.  If no Current Value is specified, or a NULL
    // string is specified, the existing Current Value will be deleted.
    //

    if (ARGUMENT_PRESENT(CipherCurrentValue)) {

        if (!InternalHandle->Trusted) {

            Status = LsapCrDecryptValue(
                         (PLSAP_CR_CIPHER_VALUE) CipherCurrentValue,
                         SessionKey,
                         &ClearCurrentValue
                         );

            if (!NT_SUCCESS(Status)) {

                goto SetSecretError;
            }

        } else {

            ClearCurrentValue = (PLSAP_CR_CLEAR_VALUE) CipherCurrentValue;
        }

    }

    //
    // If an Old Value is specified for the Secret Object, and the
    // client is non-trusted, decrypt the value using the Session Key and
    // encrypt it using the LSA Database System Key.  Then (for all
    // clients) encrypt the resulting value with the internal LSA Database
    // encryption key and write resulting Value structure (header followed by
    // buffer to the Policy Database as the Old Value attribute of the
    // Secret object.  If no Old Value is specified, or a NULL
    // string is specified, the existing Old Value will be deleted.
    //

    if (ARGUMENT_PRESENT(CipherOldValue)) {

        if (!InternalHandle->Trusted) {

            Status = LsapCrDecryptValue(
                         (PLSAP_CR_CIPHER_VALUE) CipherOldValue,
                         SessionKey,
                         &ClearOldValue
                         );

            if (!NT_SUCCESS(Status)) {

                goto SetSecretError;
            }

        } else {

            ClearOldValue = (PLSAP_CR_CLEAR_VALUE) CipherOldValue;
        }

    }

    //
    // Get the time at which the Current Secret value was last updated.
    //

    GetSystemTimeAsFileTime( (LPFILETIME) &UpdatedTime );

    //
    // If it's a trusted domain secret, write it out now...
    //
    if ( DsTrustedDomainSecret ) {

        Status = LsapDsSetSecretOnTrustedDomainObject( SecretHandle,
                                                       TRUST_AUTH_TYPE_CLEAR,
                                                       ClearCurrentValue,
                                                       ClearOldValue,
                                                       &UpdatedTime );
        if (!NT_SUCCESS(Status)) {

            goto SetSecretError;

        } else {

            goto SetSecretFinish;

        }

    }

    //
    // If the caller didn't specify an old value,
    //  get the current value off the object and use that.
    //

    if ( ClearOldValue == NULL ) {
        BOOLEAN SavedTrusted;

        //
        // Grab the current value of the secret.
        //
        // We may not have access, so go as trusted.
        // Password comes back in the clear.
        //

        SavedTrusted = Handle->Trusted;
        Handle->Trusted = TRUE;

        Status = LsarQuerySecret( SecretHandle,
                                  &(PLSAPR_CR_CIPHER_VALUE)ClearOldValue,
                                  &CurrentSecretTime,
                                  NULL,
                                  NULL );

        Handle->Trusted = SavedTrusted;

        if ( !NT_SUCCESS(Status)) {
            goto SetSecretError;
        }

        OldTime = &CurrentSecretTime;
    }

    //
    // Now, encrypt them both, if we are not writing to a DS secret
    //
    if ( ClearCurrentValue != NULL ) {

        if ( !LsapDsIsWriteDs( SecretHandle ) ) {

            Status = LsapCrEncryptValue( ClearCurrentValue,
                                         LsapDbSecretCipherKeyWrite,
                                         &DbCipherCurrentValue );


            if (!NT_SUCCESS(Status)) {

                goto SetSecretError;
            }

            FreeCurrentCipher = TRUE;

            DbCipherCurrentValueLength = DbCipherCurrentValue->Length
                                                            + sizeof( LSAP_CR_CIPHER_VALUE );

            DbCipherCurrentValue->MaximumLength |= LSAP_DB_SECRET_WIN2K_SYSKEY_ENCRYPTED;

        } else {

            DbCipherCurrentValue = ( PLSAP_CR_CIPHER_VALUE )ClearCurrentValue->Buffer;
            DbCipherCurrentValueLength = ClearCurrentValue->Length;
        }


    } else {

        DbCipherCurrentValue = NULL;
        DbCipherCurrentValueLength = 0;

    }

    if ( ClearOldValue != NULL ) {

        if ( !LsapDsIsWriteDs( SecretHandle ) ) {

            Status = LsapCrEncryptValue( ClearOldValue,
                                         LsapDbSecretCipherKeyWrite,
                                         &DbCipherOldValue );

            if (!NT_SUCCESS(Status)) {

                goto SetSecretError;
            }

            FreeOldCipher = TRUE;

            DbCipherOldValueLength = DbCipherOldValue->Length + sizeof( LSAP_CR_CIPHER_VALUE );
            DbCipherOldValue->MaximumLength |= LSAP_DB_SECRET_WIN2K_SYSKEY_ENCRYPTED;

        } else {

            DbCipherOldValue = ( PLSAP_CR_CIPHER_VALUE )ClearOldValue->Buffer;
            DbCipherOldValueLength = ClearOldValue->Length;
        }



    } else {

        DbCipherOldValue = NULL;
        DbCipherOldValueLength = 0;
    }

    //
    // Build the list of attributes
    //
    NextAttribute = Attributes;

    //
    // Current value
    //
    LsapDbInitializeAttributeDs( NextAttribute,
                                 CurrVal,
                                 DbCipherCurrentValue,
                                 DbCipherCurrentValueLength,
                                 FALSE );

    NextAttribute++;
    AttributeCount++;

    //
    // Current time
    //
    LsapDbInitializeAttributeDs( NextAttribute,
                                 CupdTime,
                                 CurrentTime ? CurrentTime : &UpdatedTime,
                                 sizeof( LARGE_INTEGER ),
                                 FALSE );
    NextAttribute++;
    AttributeCount++;

    if ( !( LsapDsIsWriteDs( SecretHandle ) && ClearOldValue == NULL ) ) {

        //
        // Previous value
        //
        LsapDbInitializeAttributeDs( NextAttribute,
                                     OldVal,
                                     DbCipherOldValue,
                                     DbCipherOldValueLength,
                                     FALSE );

        LsapDbAttributeCanNotExist(NextAttribute);

        NextAttribute++;
        AttributeCount++;


        //
        // Previous time
        //
        LsapDbInitializeAttributeDs( NextAttribute,
                                     OupdTime,
                                     OldTime ? OldTime : &UpdatedTime,
                                     sizeof( LARGE_INTEGER ),
                                     FALSE );

        LsapDbAttributeCanNotExist(NextAttribute);

        NextAttribute++;
        AttributeCount++;

    }


    Status = LsapDbWriteAttributesObject( SecretHandle,
                                          Attributes,
                                          AttributeCount );



    if (!NT_SUCCESS(Status)) {

        goto SetSecretError;
    }

    //
    // If this is the machine account, do notification
    //

    if( LsapDbSecretIsMachineAcc( Handle ) ) {

        LsaINotifyChangeNotification( PolicyNotifyMachineAccountPasswordInformation );
    }

    NotifyMachineChange = TRUE;

SetSecretFinish:


    //
    // If necessary, dereference the Secret object, close the database
    // transaction, notify the LSA Database Replicator of the change,
    // release the LSA Database lock and return. If this is a
    // RemoteBootMachinePasswordChange, ObjectReferenced will be FALSE.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     &SecretHandle,
                     SecretObject,
                     SecretObject,
                     DereferenceOptions,
                     SecurityDbChange,
                     Status
                     );
    }

    //
    // If we are changing our machine account password, notify
    // security packages and the remote boot code.
    //

    if (NotifyMachineChange && RtlEqualUnicodeString(
            &LsapMachineSecret,
            &InternalHandle->LogicalNameU,
            TRUE)) {            // case insensitive

#if defined(REMOTE_BOOT)
            //
            // If this is being called due to a remote boot machine password
            // change, we don't need to notify Kerberos, because this will
            // be inside the initial LsarQuerySecret() call that LSA makes,
            // and it notifies Kerberos after that call returns.
            //

            if (!RemoteBootMachinePasswordChange)
#endif // defined(REMOTE_BOOT)
            {
                (VOID) LsapNotifySecurityPackagesOfPasswordChange(
                    ClearCurrentValue,
                    ClearOldValue
                    );
            }

#if defined(REMOTE_BOOT)
            //
            // Notify remote boot if it wants to be notified.
            //

            if (LsapDbState.RemoteBootState == LSAP_DB_REMOTE_BOOT_NOTIFY) {
                (VOID) LsapNotifyRemoteBootOfPasswordChange(
                    ClearCurrentValue,
                    ClearOldValue
                    );
            }
#endif // defined(REMOTE_BOOT)

    }

    //
    // If necessary, free memory allocated for the Session Key.
    //

    if (SessionKey != NULL) {

        MIDL_user_free(SessionKey);
        SessionKey = NULL;
    }

    //
    // If necessary, free memory allocated for the Current Value
    // encrypted for storage in the LSA Database.
    //

    if ( FreeCurrentCipher ) {

        LsapCrFreeMemoryValue( DbCipherCurrentValue );
        DbCipherCurrentValue = NULL;
    }

    //
    // If necessary, free memory allocated for the Old Value
    // encrypted for storage in the LSA Database.
    //

    if ( FreeOldCipher ) {

        LsapCrFreeMemoryValue( DbCipherOldValue );
        DbCipherOldValue = NULL;
    }

    //
    // If necessary, free memory allocated for Decrypted Current Value.
    // Note that for trusted clients, the decryption is the identity
    // mapping, so do not do the free in this case.
    //

    if ((ClearCurrentValue != NULL) && !InternalHandle->Trusted) {

        LsapCrFreeMemoryValue( ClearCurrentValue );
        ClearCurrentValue = NULL;
    }

    //
    // If necessary, free memory allocated for Decrypted Old Value.
    // Note that for trusted clients, the decryption is the identity
    // mapping, so do not do the free in this case.
    //

    if ((ClearOldValue != NULL) && !InternalHandle->Trusted) {

        LsapCrFreeMemoryValue( ClearOldValue );
        ClearOldValue = NULL;
    }


    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarSetSecret: 0x%lx\n", Status ));

    return(Status);

SetSecretError:

    goto SetSecretFinish;
}


NTSTATUS
LsarQuerySecret(
    IN LSAPR_HANDLE SecretHandle,
    IN OUT OPTIONAL PLSAPR_CR_CIPHER_VALUE *CipherCurrentValue,
    OUT OPTIONAL PLARGE_INTEGER CurrentValueSetTime,
    IN OUT OPTIONAL PLSAPR_CR_CIPHER_VALUE *CipherOldValue,
    OUT OPTIONAL PLARGE_INTEGER OldValueSetTime
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the LsaQuerySecret
    API.

    The LsaQuerySecret API optionally returns one or both of the values
    assigned to a Secret object.  These values are known as the "current value"
    and the "old value", and they have a meaning known to the creator of the
    Secret object.  The values are returned in their encrypted form.
    The caller must have LSA_QUERY_SECRET access to the Secret object.

Arguments:

    SecretHandle - Handle from an LsaOpenSecret or LsaCreateSecret call.

    CipherCurrentValue - Optional pointer to location which will receive a
        pointer to an encrypted Unicode String structure containing the
        "current value" of the Secret Object (if any) in encrypted form.
        If no "current value" is assigned to the Secret object, a NULL pointer
        is returned.

    CurrentValueSetTime - The date/time at which the current secret value
        was established.

    CipherOldValue - Optional pointer to location which will receive a
        pointer to an encrypted Unicode String structure containing the
        "old value" of the Secret Object (if any) in encrypted form.
        If no "old value" is assigned to the Secret object, a NULL pointer
        is returned.

    OldValueSetTime - The date/time at which the old secret value
        was established.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

--*/

{
    NTSTATUS Status;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) SecretHandle;
    PLSAP_CR_CIPHER_VALUE OutputCipherCurrentValue = NULL;
    PLSAP_CR_CIPHER_VALUE OutputCipherOldValue = NULL;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;
    BOOLEAN ObjectReferenced = FALSE, DsTrustedDomainSecret = FALSE;
    ULONG ValueSetTimeLength;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarQuerySecret\n" ));

    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_QuerySecret);

    //
    // If the caller is from a network call and we are opening a local/system secret,
    // return an error
    //
    if ( InternalHandle->NetworkClient &&  (!InternalHandle->Trusted) &&
         FLAG_ON( InternalHandle->ObjectOptions, LSAP_DB_OBJECT_SECRET_LOCAL ) ) {

        Status = STATUS_ACCESS_DENIED;
        goto QuerySecretReturn;
    }

    //
    // If the caller is not trusted and they are trying to read an internal secret, return
    // an error
    //
    if ( !InternalHandle->Trusted &&
         FLAG_ON( InternalHandle->ObjectOptions, LSAP_DB_OBJECT_SECRET_INTERNAL ) ) {
        Status = STATUS_ACCESS_DENIED;
        goto QuerySecretReturn;
    }

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot machine that might notify us of
    // password changes that happened while the machine is off, and
    // this seems to be the first time this routine has been called,
    // then take a write lock in case we need to write the secret
    // (after we take the lock we check to make sure this really is
    // the first time through).
    //
    // It is OK to do the initial check of FirstMachineAccountQueryDone
    // without the lock because it starts as FALSE and changes to TRUE
    // exactly once.
    //

    if ((LsapDbState.RemoteBootState != LSAP_DB_REMOTE_BOOT_NO_NOTIFICATION) &&
         !FirstMachineAccountQueryDone &&
         RtlEqualUnicodeString(
             &LsapMachineSecret,
             &InternalHandle->LogicalNameU,
             TRUE)) {            // case insensitive

        NTSTATUS CheckStatus = STATUS_SUCCESS;
        HANDLE TempHandle = SecretHandle;

        //
        // Take the lock with the options that LsarSetSecret will choose
        // to write the machine account secret.
        //

        Status = LsapDbReferenceObject(
                     TempHandle,
                     SECRET_SET_VALUE,
                     SecretObject,
                     SecretObject,
                     LSAP_DB_LOCK |
                        LSAP_DB_START_TRANSACTION |
                        LSAP_DB_NO_DS_OP_TRANSACTION
                     );

        if (!NT_SUCCESS(Status)) {

            goto QuerySecretError;
        }

        //
        // Now that we have acquired the lock, check again to see if we
        // need to check for a remote boot secret. If FirstMachineAccountQueryDone
        // is now also TRUE, it means another thread did the query at the same
        // time, and since we now have the lock, that thread has finished the
        // query and any resulting updating.
        //

        if (!FirstMachineAccountQueryDone) {

            CheckStatus = LsapCheckRemoteBootForPasswordChange(TempHandle);
            FirstMachineAccountQueryDone = TRUE;
        }

        //
        // We verify CheckStatus after we have dereferenced, so that we
        // always do the dereference.
        //

        Status = LsapDbDereferenceObject(
                     &TempHandle,
                     SecretObject,
                     SecretObject,
                     LSAP_DB_LOCK |
                        LSAP_DB_FINISH_TRANSACTION |
                        LSAP_DB_OMIT_REPLICATOR_NOTIFICATION |
                        LSAP_DB_NO_DS_OP_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );

        if (!NT_SUCCESS(CheckStatus)) {

            Status = CheckStatus;
            goto QuerySecretError;
        }

        if (!NT_SUCCESS(Status)) {

            goto QuerySecretError;
        }

    }
#endif // defined(REMOTE_BOOT)

    //
    // If the caller is non-trusted, obtain the Session Key used by the
    // client to two-way encrypt the Current Value and/or Old Values.
    // Trusted Clients do not use encryption since they are calling
    // this server service directly and not via RPC.
    //

    if (!InternalHandle->Trusted) {

        Status = LsapCrServerGetSessionKey( SecretHandle, &SessionKey );

        if (!NT_SUCCESS(Status)) {

            goto QuerySecretError;
        }
    }

    //
    // Acquire the Lsa Database lock.  Verify that the Secret Object handle is
    // valid, is of the expected type and has all of the desired accesses
    // granted.  Reference the handle and open a database transaction.
    //

    Status = LsapDbReferenceObject(
                 SecretHandle,
                 SECRET_QUERY_VALUE,
                 SecretObject,
                 SecretObject,
                 LSAP_DB_LOCK |
                    LSAP_DB_READ_ONLY_TRANSACTION |
                    LSAP_DB_DS_OP_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto QuerySecretError;
    }

    ObjectReferenced = TRUE;

    //
    // See if its a trusted domain secret
    //
    Status = LsapDsIsHandleDsObjectTypeHandle( SecretHandle,
                                               TrustedDomainObject,
                                               &DsTrustedDomainSecret );

    if ( !NT_SUCCESS( Status ) ) {

        goto QuerySecretError;
    }

    //
    // If it's a Ds trusted domain, go ahead and read the data.  Otherwise, pass it along
    //
    if ( DsTrustedDomainSecret ) {

        Status = LsapDsGetSecretOnTrustedDomainObject( SecretHandle,
                                                       SessionKey,
                                                       ARGUMENT_PRESENT(CipherCurrentValue) ?
                                                            &OutputCipherCurrentValue : NULL,
                                                       ARGUMENT_PRESENT(CipherOldValue) ?
                                                            &OutputCipherOldValue : NULL,
                                                       CurrentValueSetTime,
                                                       OldValueSetTime );

        if ( NT_SUCCESS( Status ) ) {

            goto QuerySecretFinish;

        } else {

            goto QuerySecretError;
        }
    }

    //
    // If requested, query the Current Value attribute of the Secret Object.
    // For non-trusted callers, the Current value will be returned in
    // encrypted form embedded within a structure.
    //

    if (ARGUMENT_PRESENT(CipherCurrentValue)) {

        Status = LsapDbQueryValueSecret(
                     SecretHandle,
                     CurrVal,
                     SessionKey,
                     &OutputCipherCurrentValue
                     );

        if (!NT_SUCCESS(Status)) {

            goto QuerySecretError;
        }
    }

    //
    // If requested, query the Old Value attribute of the Secret Object.
    // For non-trusted callers, the Old Value will be returned in
    // encrypted form embedded within a structure.
    //

    if (ARGUMENT_PRESENT(CipherOldValue)) {

        Status = LsapDbQueryValueSecret(
                     SecretHandle,
                     OldVal,
                     SessionKey,
                     &OutputCipherOldValue
                     );

        if (!NT_SUCCESS(Status)) {

            goto QuerySecretError;
        }
    }

    ValueSetTimeLength = sizeof (LARGE_INTEGER);

    //
    // If requested, Query the time at which the Current Value of the Secret
    // was last established.  If the Current Value has never been set, return
    // the time at which the Secret was created.
    //

    if (ARGUMENT_PRESENT(CurrentValueSetTime)) {

        Status = LsapDbReadAttributeObjectEx(
                     SecretHandle,
                     CupdTime,
                     CurrentValueSetTime,
                     &ValueSetTimeLength,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            goto QuerySecretError;
        }
    }

    //
    // If requested, Query the time at which the Old Value of the Secret
    // was last established.  If the Old Value has never been set, return
    // the time at which the Secret was created.
    //

    if (ARGUMENT_PRESENT(OldValueSetTime)) {

        Status = LsapDbReadAttributeObjectEx(
                     SecretHandle,
                     OupdTime,
                     OldValueSetTime,
                     &ValueSetTimeLength,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            goto QuerySecretError;
        }

    }

QuerySecretFinish:

    //
    // If necessary, free memory allocated for the Session Key.
    //

    if (SessionKey != NULL) {

        MIDL_user_free(SessionKey);
    }

    //
    // Return Current and/or Old Values of Secret Object, or NULL to
    // caller.  In error cases, NULL will be returned.
    //

    if (ARGUMENT_PRESENT(CipherCurrentValue)) {

         (PLSAP_CR_CIPHER_VALUE) *CipherCurrentValue = OutputCipherCurrentValue;
    }

    if (ARGUMENT_PRESENT(CipherOldValue)) {

         (PLSAP_CR_CIPHER_VALUE) *CipherOldValue = OutputCipherOldValue;
    }

    //
    // If necessary, dereference the Secret object, close the database
    // transaction, release the LSA Database lock and return.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     &SecretHandle,
                     SecretObject,
                     SecretObject,
                     LSAP_DB_LOCK |
                        LSAP_DB_READ_ONLY_TRANSACTION |
                        LSAP_DB_DS_OP_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }


QuerySecretReturn:
    
    (void) LsapAdtGenerateObjectOperationAuditEvent(
               SecretHandle,
               NT_SUCCESS(Status) ?
                  EVENTLOG_AUDIT_SUCCESS : EVENTLOG_AUDIT_FAILURE,
               ObjectOperationQuery
               );

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_QuerySecret);
    LsapDsDebugOut(( DEB_FTRACE, "LsarQuerySecret: 0x%lx\n", Status ));
    LsarpReturnPrologue();

    return(Status);

QuerySecretError:

    //
    // Deallocate any allocated memory
    //
    if ( OutputCipherCurrentValue ) {

        MIDL_user_free( OutputCipherCurrentValue );
        OutputCipherCurrentValue = NULL;
    }

    if ( OutputCipherOldValue ) {

        MIDL_user_free( OutputCipherOldValue );
        OutputCipherOldValue = NULL;
    }

    goto QuerySecretFinish;
}


NTSTATUS
LsapDbQueryValueSecret(
    IN LSAPR_HANDLE SecretHandle,
    IN LSAP_DB_NAMES ValueIndex,
    IN OPTIONAL PLSAP_CR_CIPHER_KEY SessionKey,
    OUT PLSAP_CR_CIPHER_VALUE *CipherValue
    )

/*++

Routine Description:

    This function queries the specified value of a Secret Object.  If
    the caller is non-trusted, the value returned will have been two-way
    encrypted with the Session Key.  If the caller is trusted, no
    encryption is done since the caller is calling us directly.

Arguments:

    SecretHandle - Handle to Secret Object.

    ValueName - Unicode name of the Secret Value to be queried.  This
        name is either "Currval" (for the Current Value) or "OldVal"
        (for the Old Value.

    SessionKey - Pointer to Session Key to be used for two-way encryption
        of the value to be returned.  This pointer must be non-NULL
        except for Trusted Clients, where it must be NULL.

    CipherValue - Receives 32-bit counted string pointer to Secret Value
        queried.  For non-trusted clients, the value will be encrypted.

            WARNING - Note that CipherValue is defined to RPC as
            "allocate(all_nodes)".  This means that it is returned
            in one contiguous block of memory rather than two, as
            it would appear by the structure definition.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status;
    ULONG DbCipherValueLength;
    PLSAP_CR_CLEAR_VALUE ClearValue = NULL;
    PLSAP_CR_CIPHER_VALUE DbCipherValue = NULL;
    PLSAP_CR_CIPHER_VALUE OutputCipherValue = NULL;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) SecretHandle;

    //
    // Get length of the specified Value attribute of the Secret object.
    //

    DbCipherValueLength = 0;

    Status = LsapDbReadAttributeObjectEx(
                 SecretHandle,
                 ValueIndex,
                 NULL,
                 &DbCipherValueLength,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {

        if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

            goto QueryValueSecretError;
        }

        Status = STATUS_SUCCESS;
        *CipherValue = NULL;
        return(Status);
    }

    //
    // We successfully read the length of the stored Secret Object value
    // plus header from the Policy Database.  Verify that the Secret
    // Object value is either at least as long as a Cipher Value
    // structure header, or is of length 0.
    //

    if ( !LsapDsIsWriteDs( SecretHandle ) &&
         DbCipherValueLength < sizeof (LSAP_CR_CIPHER_VALUE ) ) {

        if (DbCipherValueLength == 0) {

            goto QueryValueSecretFinish;
        }

        Status = STATUS_INTERNAL_DB_ERROR;
        goto QueryValueSecretError;
    }

    //
    // Allocate memory for reading the specified Value of the Secret object.
    // This value is stored in the Policy Database in the form of a
    // Self-Relative Value structure.  The Value Buffer part is encrypted.
    //


    DbCipherValue = MIDL_user_allocate(DbCipherValueLength);

    if (DbCipherValue == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto QueryValueSecretError;
    }

    //
    // Read the specified Policy-database-encrypted Value attribute.
    //

    Status = LsapDbReadAttributeObjectEx(
                 SecretHandle,
                 ValueIndex,
                 DbCipherValue,
                 &DbCipherValueLength,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryValueSecretError;
    }

    //
    // If we are not reading from the DS, the data is encrypted
    //
    if ( !LsapDsIsWriteDs( SecretHandle ) ) {

        PLSAP_CR_CIPHER_KEY KeyToUse = LsapDbCipherKey;
        BOOLEAN             SP4Encrypted = FALSE;

        //
        // Verify that Lengths in returned header are consistent
        // and also match returned data length - header size.
        //

        if (DbCipherValue->Length > DbCipherValue->MaximumLength) {

            Status = STATUS_INTERNAL_DB_ERROR;
            goto QueryValueSecretError;
        }

        if ((DbCipherValue->Length + (ULONG) sizeof(LSAP_CR_CIPHER_VALUE)) !=
               DbCipherValueLength) {

            Status = STATUS_INTERNAL_DB_ERROR;
            goto QueryValueSecretError;
        }

        //
        // If the string length is 0, something is wrong.
        //

        if (DbCipherValue->Length == 0) {

            goto QueryValueSecretError;
        }

        //
        // Store pointer to Value buffer in the Value structure.  This pointer
        // points just after the header.  Then decrypt the  Value using the
        // LSA Database Cipher Key and encrypt the result using the Session Key.
        //

        DbCipherValue->Buffer = (PUCHAR)(DbCipherValue + 1);



        if ( FLAG_ON( DbCipherValue->MaximumLength, LSAP_DB_SECRET_SP4_SYSKEY_ENCRYPTED) ) {

            DbCipherValue->MaximumLength &= ~LSAP_DB_SECRET_SP4_SYSKEY_ENCRYPTED;

            if ( LsapDbSP4SecretCipherKey ) {

                KeyToUse = LsapDbSP4SecretCipherKey;
                SP4Encrypted = TRUE;

            } else {

                //
                // This was encrypted using SP4 syskey, but now we don't have it... We're in trouble
                //

                Status = STATUS_INTERNAL_ERROR;
                goto QueryValueSecretError;

            }
        }

        if ( FLAG_ON( DbCipherValue->MaximumLength, LSAP_DB_SECRET_WIN2K_SYSKEY_ENCRYPTED) ) {

            DbCipherValue->MaximumLength &= ~LSAP_DB_SECRET_WIN2K_SYSKEY_ENCRYPTED;

            if ( LsapDbSecretCipherKeyRead ) {

                KeyToUse = LsapDbSecretCipherKeyRead;

                ASSERT(!SP4Encrypted);

            } else {

                //
                // This was encrypted using  syskey, but now we don't have it... We're in trouble
                //

                Status = STATUS_INTERNAL_ERROR;
                goto QueryValueSecretError;
            }
        }

        Status = LsapCrDecryptValue(
                     DbCipherValue,
                     KeyToUse,
                     &ClearValue
                     );

        if (!NT_SUCCESS(Status)) {

            goto QueryValueSecretError;
        }

    } else {

        ClearValue = MIDL_user_allocate( sizeof( LSAP_CR_CLEAR_VALUE ) + DbCipherValueLength );

        if ( ClearValue == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto QueryValueSecretError;

        } else {

            ClearValue->Length = DbCipherValueLength;
            ClearValue->MaximumLength = DbCipherValueLength;
            ClearValue->Buffer =  ( PUCHAR )(ClearValue+1);

            RtlCopyMemory( ClearValue->Buffer,
                           DbCipherValue,
                           DbCipherValueLength );
        }

    }


    //
    // If the client is non-Trusted, encrypt the value with the Session
    // Key, otherwise, leave it unchanged.
    //

    if (!InternalHandle->Trusted) {

        Status = LsapCrEncryptValue(
                     ClearValue,
                     SessionKey,
                     &OutputCipherValue
                     );

        if (!NT_SUCCESS(Status)) {

            goto QueryValueSecretError;
        }

    } else {

        //
        // Trusted clients get a clear-text block back.
        // The block contains both the header and the text.
        //

        OutputCipherValue = (PLSAP_CR_CIPHER_VALUE)(ClearValue);
    }

QueryValueSecretFinish:

    //
    // If necessary, free memory allocated for the Db-encrypted Secret
    // object Value read from the Policy Database.
    //

    if (DbCipherValue != NULL) {

        LsapCrFreeMemoryValue( DbCipherValue );
    }

    //
    // If necessary, free memory allocated for the Decrypted Value.
    // Trusted client's get a pointer to ClearValue back, so don't
    // free it in this case.
    //

    if ( !InternalHandle->Trusted && ClearValue != NULL ) {

        LsapCrFreeMemoryValue( ClearValue );
    }

    //
    // Return pointer to Cipher Value (Clear Value for trusted clients) or
    // NULL.
    //

    *CipherValue = OutputCipherValue;
    return(Status);

QueryValueSecretError:

    //
    // If necessary, free memory allocated for the Secret object value
    // after re-encryption for return to the Client.
    //

    if (OutputCipherValue != NULL) {

        LsapCrFreeMemoryValue( OutputCipherValue );
    }

    goto QueryValueSecretFinish;
}


NTSTATUS
LsaIEnumerateSecrets(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    This service returns information about Secret objects.  Since there
    may be more information than can be returned in a single call of the
    routine, multiple calls can be made to get all of the information.
    To support this feature, the caller is provided with a handle that
    can be used across calls to the API.  On the initial call,
    EnumerationContext should point to a variable that has been
    initialized to 0.

Arguments:

    PolicyHandle - Trusted handle to an open Policy Object.

    EnumerationContext - Zero-based index at which to start the enumeration.

    Buffer - Receives a pointer to a buffer containing information for
        one or more Secret objects.  This information is an array of
        structures of type UNICODE_STRING, with each entry providing the
        name of a single Secret object.  When this information is no
        longer needed, it must be released using MIDL_user_free.

    PreferedMaximumLength - Prefered maximum length of the returned
        data (in 8-bit bytes).  This is not a hard upper limit but
        serves as a guide.  Due to data conversion between systems
        with different natural data sizes, the actual amount of data
        returned may be greater than this value.

    CountReturned - Numer of entries returned.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_NO_MORE_ENTRIES - No entries have been returned because
            there are no more.
--*/

{
    NTSTATUS Status;
    LSAP_DB_NAME_ENUMERATION_BUFFER RegEnumerationBuffer, DsEnumerationBuffer;
    LSAP_DB_NAME_ENUMERATION_BUFFER DomainEnumerationBuffer, *CurrentEnumerationBuffer = NULL;
    PUNICODE_STRING SecretNames = NULL;
    BOOLEAN Locked = FALSE;
    ULONG MaxLength, Entries, Context, Relative = 0;
    LSA_ENUMERATION_HANDLE LocalEnumerationContext;


    //
    // If no Enumeration Structure is provided, return an error.
    //


    if ( !ARGUMENT_PRESENT(Buffer) ||
         !ARGUMENT_PRESENT(EnumerationContext) ) {
        return(STATUS_INVALID_PARAMETER);
    }

    LsapDsDebugOut(( DEB_FTRACE, "LsaIEnumerateSecrets\n" ));


    //
    // Initialize the internal Lsa Database Enumeration Buffers, and
    // the provided Enumeration Buffer to NULL.
    //
    RegEnumerationBuffer.EntriesRead = 0;
    RegEnumerationBuffer.Names = NULL;
    DsEnumerationBuffer.EntriesRead = 0;
    DsEnumerationBuffer.Names = NULL;
    DomainEnumerationBuffer.EntriesRead = 0;
    DomainEnumerationBuffer.Names = NULL;
    *Buffer = NULL;

    Context = *((PULONG)EnumerationContext);
    //
    // Acquire the Lsa Database lock.  Verify that the connection handle is
    // valid, is of the expected type and has all of the desired accesses
    // granted.  Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_VIEW_LOCAL_INFORMATION,
                 PolicyObject,
                 SecretObject,
                 LSAP_DB_LOCK |
                    LSAP_DB_READ_ONLY_TRANSACTION |
                    LSAP_DB_DS_OP_TRANSACTION
                 );

    if (NT_SUCCESS(Status)) {

        Locked = TRUE;

       //
       // Limit the enumeration length except for trusted callers
       //

       if ( !((LSAP_DB_HANDLE) PolicyHandle)->Trusted &&
            (PreferedMaximumLength > LSA_MAXIMUM_ENUMERATION_LENGTH)
            ) {
            MaxLength = LSA_MAXIMUM_ENUMERATION_LENGTH;
        } else {
            MaxLength = PreferedMaximumLength;
        }

        //
        // Call general enumeration routine.  This will return an array
        // of names of secrets.
        //

        //
        // Start with the Ds
        //
        Status = LsapDsEnumerateSecrets( &DsEnumerationBuffer );

        if ( !NT_SUCCESS( Status ) ) {

            goto EnumSecretCleanup;
        }

        if ( Context < DsEnumerationBuffer.EntriesRead ) {

            CurrentEnumerationBuffer = &DsEnumerationBuffer;

        } else {

            Relative = DsEnumerationBuffer.EntriesRead;

            //
            // Try the trusted domain ones
            //
            Status = LsapDsEnumerateTrustedDomainsAsSecrets( &DomainEnumerationBuffer );

            if ( !NT_SUCCESS( Status ) ) {

                goto EnumSecretCleanup;
            }

            if ( Context < Relative + DomainEnumerationBuffer.EntriesRead) {

                CurrentEnumerationBuffer = &DomainEnumerationBuffer;

            } else {

                if ( !LsaDsStateInfo.UseDs ) {

                    Relative += DomainEnumerationBuffer.EntriesRead;

                    LocalEnumerationContext = Context - Relative;

                    Status = LsapDbEnumerateNames(
                                 PolicyHandle,
                                 SecretObject,
                                 &LocalEnumerationContext,
                                 &RegEnumerationBuffer,
                                 MaxLength
                                 );

                    if ( !NT_SUCCESS( Status ) ) {

                        goto EnumSecretCleanup;
                    }

                    CurrentEnumerationBuffer = &RegEnumerationBuffer;

                } else {

                    *CountReturned = 0;
                    Status = STATUS_NO_MORE_ENTRIES;

                    goto EnumSecretCleanup;


                }
            }
        }


        //
        // At this point:
        //
        //     SUCCESS -> Some names are being returned (may or
        //         may not be additional names to be retrieved
        //         in future calls).
        //
        //     NO_MORE_ENTRIES -> There are NO names to return
        //         for this or any future call.
        //

        if (NT_SUCCESS(Status)) {

            //
            // Return the number of entries read.  Note that the Enumeration Buffer
            // returned from LsapDbEnumerateNames is expected to be non-null
            // in all non-error cases.
            //

            ASSERT(CurrentEnumerationBuffer->EntriesRead != 0);


            //
            // Now copy the output array of Unicode Strings for the caller.
            // Memory for the array and the Unicode Buffers is allocated via
            // MIDL_user_allocate.
            //

            Status = LsapRpcCopyUnicodeStrings(
                         NULL,
                         CurrentEnumerationBuffer->EntriesRead,
                         &SecretNames,
                         CurrentEnumerationBuffer->Names
                         );
        }

        if ( NT_SUCCESS( Status ) ) {

            *(PULONG)EnumerationContext += CurrentEnumerationBuffer->EntriesRead;
        }
    }

    //
    // Fill in returned Enumeration Structure, returning 0 or NULL for
    // fields in the error case.
    //

    *Buffer = SecretNames;
    if (NULL!=CurrentEnumerationBuffer)
    {
        *CountReturned = CurrentEnumerationBuffer->EntriesRead;
    }
    else
    {
        *CountReturned = 0;
    }


EnumSecretCleanup:


   //
   // Dereference retains current status value unless
   // error occurs.
   //

   if ( Locked ) {

       LsapDbDereferenceObject(
           &PolicyHandle,
           PolicyObject,
           SecretObject,
           LSAP_DB_LOCK |
               LSAP_DB_READ_ONLY_TRANSACTION |
               LSAP_DB_DS_OP_TRANSACTION,
           (SECURITY_DB_DELTA_TYPE) 0,
           Status
           );

   }

    //
    // Free the allocated memory
    //

    LsapDbFreeEnumerationBuffer( &DomainEnumerationBuffer );
    LsapDbFreeEnumerationBuffer( &DsEnumerationBuffer );
    LsapDbFreeEnumerationBuffer( &RegEnumerationBuffer );


    LsapDsDebugOut(( DEB_FTRACE, "LsaIEnumerateSecrets: 0x%lx\n", Status ));

    return(Status);

}


NTSTATUS
LsaISetTimesSecret(
    IN LSAPR_HANDLE SecretHandle,
    IN PLARGE_INTEGER CurrentValueSetTime,
    IN PLARGE_INTEGER OldValueSetTime
    )

/*++

Routine Description:

    This service is used to set the times associated with a Secret object.
    This allows the times of secrets to be set to what they are on the
    Primary Domain Controller (PDC) involved in an LSA Database replication
    rather than being set to the time at which the Secret object is
    created on a Backup Domain Controller (BDC) being replicated to.

Arguments:

    SecretHandle - Trusted Handle to an open secret object.  This will
        have been obtained via a call to LsaCreateSecret() or LsaOpenSecret()
        on which a Trusted Policy Handle was specified.

    CurrentValueSetTime - The date and time to set for the date and time
        at which the Current Value of the Secret object was set.

    OldValueSetTime - The date and time to set for the date and time
        at which the Old Value of the Secret object was set.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_ACCESS_DENIED - The supplied SecretHandle is not Trusted.

        STATUS_INVALID_HANDLE - The supplied SecretHandle is not
            a valid habdle to a Secret Object.

--*/

{
    NTSTATUS Status;
    LSAP_DB_HANDLE Handle = (LSAP_DB_HANDLE) SecretHandle;
    BOOLEAN ObjectReferenced = FALSE;

    //
    // Verify that both Times are specified.
    //

    Status = STATUS_INVALID_PARAMETER;

    if (!ARGUMENT_PRESENT( CurrentValueSetTime )) {

        goto SetTimesSecretError;
    }

    if (!ARGUMENT_PRESENT( CurrentValueSetTime )) {

        goto SetTimesSecretError;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the Secret Object handle is
    // valid, is of the expected type and has all of the desired accesses
    // granted.  Reference the handle and open a database transaction.
    //

    Status = LsapDbReferenceObject(
                 SecretHandle,
                 SECRET_SET_VALUE,
                 SecretObject,
                 SecretObject,
                 LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION | LSAP_DB_TRUSTED |
                    LSAP_DB_DS_OP_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetTimesSecretError;
    }

    ObjectReferenced = TRUE;

    //
    // See if it's a secret in the Ds, since Ds replication will do the right thing
    // with the time stamps
    //
    if ( LsapDsIsWriteDs( SecretHandle ) ) {

        goto SetTimesSecretFinish;
    }


    //
    // Set the time at which the Current Secret value was last updated
    // to the specified value.
    //

    Status = LsapDbWriteAttributeObject(
                 SecretHandle,
                 &LsapDbNames[CupdTime],
                 CurrentValueSetTime,
                 sizeof (LARGE_INTEGER)
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetTimesSecretError;
    }

    //
    // Set the time at which the Old Secret value was last updated
    // to the specified value.
    //
    Status = LsapDbWriteAttributeObject(
                 SecretHandle,
                 &LsapDbNames[OupdTime],
                 OldValueSetTime,
                 sizeof (LARGE_INTEGER)
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetTimesSecretError;
    }

SetTimesSecretFinish:

    //
    // If necessary, dereference the Secret object, close the database
    // transaction, notify the LSA Database Replicator of the change and
    // release the LSA Database lock and return.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     &SecretHandle,
                     SecretObject,
                     SecretObject,
                     LSAP_DB_LOCK | LSAP_DB_FINISH_TRANSACTION |
                         LSAP_DB_DS_OP_TRANSACTION,
                     SecurityDbChange,
                     Status
                     );
    }

    return(Status);

SetTimesSecretError:

    goto SetTimesSecretFinish;
}


NTSTATUS
LsapDbGetScopeSecret(
    IN PLSAPR_UNICODE_STRING SecretName,
    OUT PBOOLEAN GlobalSecret
    )

/*++

Routine Description:

    This function checks the scope of a Secret name.  Secrets have either
    Global or Local Scope.

    Global Secrets are Secrets that are normally present on all DC's for a
    Domain.  They are replicated from PDC's to BDC's.  On BDC's, only a
    Trusted Client such as a replicator can create, update or delete Global
    Secrets.  Global Secrets are identified as Secrets whose name begins
    with a designated prefix.

    Local Secrets are Secrets that are private to a specific machine.  They
    are not replicated.  Normal non-trusted clients may create, update or
    delete Local Secrets.  Local Secrets are idientified as Secrets whose
    name does not begin with a designated prefix.

Arguments:

    SecretName - Pointer to Unicode String containing the name of the
        Secret to be checked.

    GlobalSecret - Receives a Boolean indicating

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The Secret name is valid

        STATUS_INVALID_PARAMETER - The Secret Name is invalid in such a
            way as to prevent scope determination.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING GlobalPrefix;
    BOOLEAN OutputGlobalSecret = FALSE;

    //
    // Initialize a Unicode String with the Global Secret name Prefix.
    //

    RtlInitUnicodeString( &GlobalPrefix, LSA_GLOBAL_SECRET_PREFIX );

    //
    // Now check if the given Name has the Global Prefix.
    //

    if (RtlPrefixUnicodeString( &GlobalPrefix, (PUNICODE_STRING) SecretName, TRUE)) {

        OutputGlobalSecret = TRUE;
    }

    *GlobalSecret = OutputGlobalSecret;

    return(Status);
}


NTSTATUS
LsapDbBuildSecretCache(
    )

/*++

Routine Description:

    This function builds a cache of Secret Objects.  Currently, it is not
    implemented

Arguments:

    None

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    return(Status);
}




NTSTATUS
LsapDsEnumerateSecrets(
    IN OUT PLSAP_DB_NAME_ENUMERATION_BUFFER EnumerationBuffer
    )
/*++

Routine Description:

    This function enumerates all of the secret objects in the Ds

Arguments:

    EnumerationBuffer - Enumeration buffer to fill

Return Value:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PDSNAME *DsNames = NULL;
    ULONG Items, i, Len;
    PBYTE Buffer;
    PUNICODE_STRING Names = NULL;
    WCHAR RdnStart[ MAX_RDN_SIZE + 1 ];
    ATTRTYP AttrType;

    //
    // Just return if the Ds isn't running
    //
    if (!LsapDsWriteDs ) {

        RtlZeroMemory( EnumerationBuffer, sizeof( LSAP_DB_NAME_ENUMERATION_BUFFER ) );
        return( Status );
    }

    //
    // First, enumerate all of the secrets
    //
    Status = LsapDsGetListOfSystemContainerItems( CLASS_SECRET,
                                                  &Items,
                                                  &DsNames );

    if ( NT_SUCCESS( Status ) ) {

        Names = MIDL_user_allocate( Items * sizeof( UNICODE_STRING ) );

        if( Names == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

        Items = 0;
        Status = STATUS_SUCCESS;
    }

    //
    // Now, we'll start building the appropriate names for each object
    //
    if ( NT_SUCCESS( Status ) ) {

        for ( i = 0; i < Items; i++ ) {

            Status = LsapDsMapDsReturnToStatus(  GetRDNInfoExternal(
                                                             DsNames[ i ],
                                                             RdnStart,
                                                             &Len,
                                                             &AttrType ) );

            if ( NT_SUCCESS( Status ) ) {

                PBYTE Buffer;

                //
                // Allocate a buffer to hold the name
                //

                Buffer = MIDL_user_allocate( Len * sizeof( WCHAR ) +
                                             sizeof( LSA_GLOBAL_SECRET_PREFIX ) );

                if ( Buffer == NULL ) {

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    break;

                } else {

                    //
                    // If the LSA created the global secret, we appended a postfix... Remove
                    // that here.
                    //
                    RdnStart[ Len ] = UNICODE_NULL;
                    if ( Len > LSAP_DS_SECRET_POSTFIX_LEN &&
                         _wcsicmp( &RdnStart[Len-LSAP_DS_SECRET_POSTFIX_LEN],
                                   LSAP_DS_SECRET_POSTFIX ) == 0 ) {

                        Len -= LSAP_DS_SECRET_POSTFIX_LEN;
                        RdnStart[ Len ] = UNICODE_NULL;
                                                                                    UNICODE_NULL;
                    }


                    RtlCopyMemory( Buffer,
                                   LSA_GLOBAL_SECRET_PREFIX,
                                   sizeof( LSA_GLOBAL_SECRET_PREFIX ) );
                    RtlCopyMemory( Buffer + sizeof( LSA_GLOBAL_SECRET_PREFIX ) - sizeof(WCHAR),
                                   RdnStart,
                                   ( Len + 1 ) * sizeof( WCHAR ) );

                    RtlInitUnicodeString( &Names[ i ], (PWSTR)Buffer );

                }
            }
        }
    }

    //
    // Free any allocated memory we no longer need
    //
    if ( DsNames != NULL ) {

        LsapFreeLsaHeap( DsNames );

    }

    if ( !NT_SUCCESS( Status ) ) {

        for ( i = 0 ;  i < Items ; i++ ) {

            MIDL_user_free( Names[i].Buffer );
        }

        MIDL_user_free( Names );

    } else {

        EnumerationBuffer->Names = Names;
        EnumerationBuffer->EntriesRead = Items;
    }



    return( Status );
}

NTSTATUS
LsapDsIsSecretDsTrustedDomainForUpgrade(
    IN PUNICODE_STRING SecretName,
    OUT PLSAPR_HANDLE TDObjHandle,
    OUT BOOLEAN *IsTrustedDomainSecret
    )
/*++

Routine Description:

    This function will determine if the indicated secret is the global secret for a trust object.

Arguments:

    SecretName - Name of secret to check

    ObjectInformation - LsaDb information on the object

    Options - Options to use for the access

    DesiredAccess - Access to open the object with

    TDObjHandle - Where the object handle is returned

    IsTrustedDomainSecret - A TRUE is returned here if this secret is indeed a trusted domain
                            secret.

Return Value:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PWSTR   pwszSecretName;
    ATTR    SearchAttr[2];
    ATTRVAL AttrVal[2];
    ULONG   ObjId = CLASS_TRUSTED_DOMAIN;
    PDSNAME FoundName = NULL;
    UNICODE_STRING HandleName;
    LSAP_DB_HANDLE  TDHandle;
    LSAP_DB_OBJECT_INFORMATION NewObjInfo;
    ULONG   TDONameLength = 0;

    LsapEnterFunc( "LsapDsIsSecretDsTrustedDomain" );

    *IsTrustedDomainSecret = FALSE;
    *TDObjHandle = NULL;

    LsapDsReturnSuccessIfNoDs

    if ( LsaDsStateInfo.DsInitializedAndRunning == FALSE ) {

        LsapDsDebugOut((DEB_ERROR,
                        "LsapDsIsSecretDsTrustedDomain: Object %wZ, Ds is not started\n ",
                        SecretName ));

        return( Status );
    }


    //
    // Convert the secret name to a TDO name.
    //
    if ( SecretName->Length <= (LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_LENGTH * sizeof(WCHAR)) ) {
        return Status;
    }

    pwszSecretName = SecretName->Buffer + LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_LENGTH;

    LsapDsDebugOut((DEB_TRACE, "Matching secret %ws to trusted domain\n ", pwszSecretName ));


    AttrVal[0].valLen = sizeof( ULONG );
    AttrVal[0].pVal   = (PVOID)&ObjId;

    AttrVal[1].valLen = TDONameLength = wcslen(pwszSecretName) * sizeof(WCHAR );
    AttrVal[1].pVal   = (PVOID)pwszSecretName;

    SearchAttr[ 0 ].attrTyp = LsapDbDsAttInfo[TrDmName].AttributeId;
    SearchAttr[ 0 ].AttrVal.valCount = 1;
    SearchAttr[ 0 ].AttrVal.pAVal = &AttrVal[1];
    SearchAttr[ 1 ].attrTyp = ATT_OBJECT_CLASS;
    SearchAttr[ 1 ].AttrVal.valCount = 1;
    SearchAttr[ 1 ].AttrVal.pAVal = &AttrVal[0];

    Status = LsapDsSearchUnique( LSAPDS_OP_NO_TRANS,
                                 LsaDsStateInfo.DsSystemContainer,
                                 SearchAttr,
                                 sizeof(SearchAttr) / sizeof(ATTR),
                                 &FoundName );



    if ( Status == STATUS_SUCCESS ) {

        UNICODE_STRING TDOName;

        //
        // This is a trusted domain, try opening the trusted domain
        //

        TDOName.Buffer = pwszSecretName;
        TDOName.Length = TDOName.MaximumLength = (USHORT) TDONameLength;


        Status = LsapDbOpenTrustedDomainByName(
                         NULL, // use global policy handle
                         &TDOName,
                         TDObjHandle,
                         MAXIMUM_ALLOWED,
                         LSAP_DB_START_TRANSACTION,
                         TRUE );    // Trusted


        *IsTrustedDomainSecret = TRUE;
        LsapFreeLsaHeap( FoundName );

    }
    else if (STATUS_OBJECT_NAME_NOT_FOUND==Status)
    {
        //
        // O.K to not find the object. That means the secret does not
        // correspond to a TDO.
        //

        Status = STATUS_SUCCESS;
    }

    return( Status );
 }


NTSTATUS
LsapDsSecretUpgradeRegistryToDs(
    IN BOOLEAN DeleteOnly
    )
/*++

Routine Description:

    This routine will move the remaining registry based secrets into the Ds

    NOTE: It is assumed that the database is locked before calling this routine

Arguments:

    DeleteOnly -- If TRUE, the registry values are deleted following the upgade.

Return Values:

    STATUS_SUCCESS   -- Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSA_ENUMERATION_HANDLE EnumContext = 0;
    PBYTE EnumBuffer;
    ULONG Items, i;
    BOOLEAN GlobalSecret;
    LSAPR_HANDLE Secret = NULL , DsSecret;
    PLSAPR_CR_CIPHER_VALUE Current = NULL, Old = NULL ;
    PLSAPR_UNICODE_STRING SecretName;
    BOOLEAN DbLocked = FALSE;
    LSAP_DB_NAME_ENUMERATION_BUFFER NameEnum;
    BOOLEAN     IsTrustedDomainSecret  = FALSE;
    LSAPR_HANDLE TDObjHandle = NULL;

    if (  !LsapDsWriteDs
       && !DeleteOnly ) {

        return( STATUS_SUCCESS );
    }

    ( ( LSAP_DB_HANDLE )LsapPolicyHandle )->Options |= LSAP_DB_HANDLE_UPGRADE;

    //
    // First, enumerate all of the registry based trusted domains
    //
    while ( NT_SUCCESS( Status ) ) {

        LsaDsStateInfo.UseDs = FALSE;

        Status = LsaIEnumerateSecrets( LsapPolicyHandle,
                                       &EnumContext,
                                       &EnumBuffer,
                                       TENMEG,
                                       &Items );

        LsaDsStateInfo.UseDs = TRUE;

        if ( Status == STATUS_SUCCESS || Status == STATUS_MORE_ENTRIES ) {

            for ( i = 0; i < Items; i++ ) {

                Secret = NULL;
                SecretName = &( ( PLSAPR_UNICODE_STRING )EnumBuffer )[ i ];
                Status = LsapDbGetScopeSecret( SecretName,
                                               &GlobalSecret );

                if ( !NT_SUCCESS( Status ) || !GlobalSecret ) {

                    continue;
                }

                //
                // Get the information from the registry for this secret...
                //
                LsaDsStateInfo.UseDs = FALSE;

                Status = LsarOpenSecret( LsapPolicyHandle,
                                         SecretName,
                                         MAXIMUM_ALLOWED,
                                         &Secret );

                if ( DeleteOnly ) {

                    if ( NT_SUCCESS( Status ) ) {

                        Status = LsarDeleteObject( &Secret );

                        if ( !NT_SUCCESS( Status ) ) {

                            LsapDsDebugOut(( DEB_UPGRADE,
                                             "Failed to delete secret (0x%x)\n",
                                             Status ));

                            Status = STATUS_SUCCESS;
                        }

                    } else {

                        LsapDsDebugOut(( DEB_UPGRADE,
                                         "Failed to open secret to delete it (0x%x)\n",
                                         Status ));

                        Status = STATUS_SUCCESS;
                    }


                } else {

                    if ( NT_SUCCESS( Status ) ) {

                        Status = LsarQuerySecret( Secret,
                                                  &Current,
                                                  NULL,
                                                  &Old,
                                                  NULL );
                    }


                    LsaDsStateInfo.UseDs = TRUE;

                    //
                    // Check if the secret is a global secret corresponding
                    // to a trusted domain. Note at this point, due to the
                    // sequence of the upgrade, we have trusted domain objects
                    // in the DS, corresponding to the outbound trusts only
                    //



                    Status = LsapDsIsSecretDsTrustedDomainForUpgrade(
                                (PUNICODE_STRING)SecretName,
                                &TDObjHandle,
                                &IsTrustedDomainSecret
                                );

                    //
                    // Now, if that worked, write it out to the Ds
                    //
                    if ( NT_SUCCESS( Status ) ) {

                        if ( IsTrustedDomainSecret) {

                            TRUSTED_DOMAIN_AUTH_INFORMATION AuthInfo;
                            LSA_AUTH_INFORMATION CurAuth,OldAuth;

                            //
                            // Build the auth information to be written out
                            //

                            ASSERT(NULL!=Current);
                            NtQuerySystemTime(&CurAuth.LastUpdateTime);
                            CurAuth.AuthType = TRUST_AUTH_TYPE_CLEAR;
                            CurAuth.AuthInfoLength = Current->Length;
                            CurAuth.AuthInfo = Current->Buffer;



                            AuthInfo.IncomingAuthInfos = 0;
                            AuthInfo.IncomingAuthenticationInformation = NULL;
                            AuthInfo.IncomingPreviousAuthenticationInformation = NULL;
                            AuthInfo.OutgoingAuthInfos = 1;
                            AuthInfo.OutgoingAuthenticationInformation = &CurAuth;

                            if (NULL!=Old) {

                                NtQuerySystemTime(&OldAuth.LastUpdateTime);
                                OldAuth.AuthType = TRUST_AUTH_TYPE_CLEAR;
                                OldAuth.AuthInfoLength = Old->Length;
                                OldAuth.AuthInfo = Old->Buffer;
                                AuthInfo.OutgoingPreviousAuthenticationInformation = &OldAuth;

                            } else {

                                AuthInfo.OutgoingPreviousAuthenticationInformation =NULL;
                            }

                            Status = LsarSetInformationTrustedDomain(
                                         TDObjHandle,
                                         TrustedDomainAuthInformation,
                                         ( PLSAPR_TRUSTED_DOMAIN_INFO ) &AuthInfo );

                            LsapCloseHandle(&TDObjHandle, Status);

                        } else {

                            //
                            // Case of a normal secret
                            //

                            Status = LsarCreateSecret(
                                        LsapPolicyHandle,
                                        SecretName,
                                        MAXIMUM_ALLOWED,
                                        &DsSecret );

                            if ( NT_SUCCESS( Status ) ) {

                                Status = LsarSetSecret( DsSecret,
                                                        Current,
                                                        Old );

                                LsapCloseHandle( &DsSecret, Status );

        #if DBG
                                if ( NT_SUCCESS( Status ) ) {

                                    LsapDsDebugOut(( DEB_UPGRADE,
                                                     "Moved Secret %wZ to Ds\n",
                                                     SecretName ));
                                }
        #endif
                            }

                            if ( Status == STATUS_OBJECT_NAME_COLLISION ) {

                                Status = STATUS_SUCCESS;
                            }
                        }
                    }

                    if (!NT_SUCCESS(Status)) {

                        if (!LsapDsIsNtStatusResourceError(Status)) {

                            //
                            // Log an event log message indicating the failure
                            //

                            SpmpReportEventU(
                                EVENTLOG_ERROR_TYPE,
                                LSA_SECRET_UPGRADE_ERROR,
                                0,
                                sizeof( ULONG ),
                                &Status,
                                1,
                                SecretName
                                );

                            //
                            // Continue on all errors excepting resource errors
                            //

                            Status = STATUS_SUCCESS;
                        }
                        else
                        {
                            //
                            // Break out of the loop and terminate the upgrade
                            //

                            if ( Secret ) {

                                LsapCloseHandle( &Secret, Status );
                            }

                            break;
                        }
                    }

                    if ( Secret ) {

                        LsapCloseHandle( &Secret, Status );
                    }
                }
            }

            LsaIFree_LSAI_SECRET_ENUM_BUFFER ( EnumBuffer, Items );
        }
    }

    if ( Status == STATUS_NO_MORE_ENTRIES ) {

        Status = STATUS_SUCCESS;
    }

    ( ( LSAP_DB_HANDLE )LsapPolicyHandle )->Options &= ~LSAP_DB_HANDLE_UPGRADE;

    return( Status );
}


ULONG
LsapDbGetSecretType(
    IN PLSAPR_UNICODE_STRING SecretName
    )
/*++

Routine Description:

    This function checks the type (scope) of a Secret name.  Secrets have
    Global, Local, System, or Client Scope.

    Global Secrets are Secrets that are normally present on all DC's for a
    Domain.  They are replicated from PDC's to BDC's.  On BDC's, only a
    Trusted Client such as a replicator can create, update or delete Global
    Secrets.  Global Secrets are identified as Secrets whose name begins
    with a designated prefix.

    Local Secrets are Secrets that cannot be opened/read/set by anyone
    attempting the operation from across the network.

    System Secrets are thos Secrets that never leave the LSA process.
    Examples are netlogon secrets and service controller secrets

    Client Secrets are Secrets that are private to a specific machine.  They
    are not replicated.  Normal non-trusted clients may create, update or
    delete Local Secrets.  Client Secrets are idientified as Secrets whose
    name does not begin with a designated prefix.  These were referred to as
    Local Secrets in the NT3.x-4.x timeframe.

Arguments:

    SecretName - Pointer to Unicode String containing the name of the
        Secret to be checked.

Return Values:

    SecretType - Mask of flags describing the type of secret

--*/

{
    UNICODE_STRING Prefix;
    ULONG i, SecretType = 0;
    LSAP_DB_SECRET_TYPE_LOOKUP SecretTypePrefixLookupTable[ ] = {
        { LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX, LSAP_DB_SECRET_GLOBAL|LSAP_DB_SECRET_TRUSTED_DOMAIN },
        { LSA_GLOBAL_SECRET_PREFIX, LSAP_DB_SECRET_GLOBAL },
        { LSA_LOCAL_SECRET_PREFIX, LSAP_DB_SECRET_LOCAL },
        { LSA_MACHINE_SECRET_PREFIX, LSAP_DB_SECRET_SYSTEM },
        { L"_sc_", LSAP_DB_SECRET_SYSTEM },    // Service Controller passwords
        { L"NL$", LSAP_DB_SECRET_SYSTEM },  // Netlogon secrets
        { L"RasDialParams", LSAP_DB_SECRET_LOCAL },
        { L"RasCredentials", LSAP_DB_SECRET_LOCAL }
    };

    LSAP_DB_SECRET_TYPE_LOOKUP SecretTypeNameLookupTable[ ] = {
        { L"$MACHINE.ACC", LSAP_DB_SECRET_LOCAL },
        { L"SAC", LSAP_DB_SECRET_LOCAL },
        { L"SAI", LSAP_DB_SECRET_LOCAL },
        { L"SANSC", LSAP_DB_SECRET_LOCAL }
        };

    //
    // Until we know better, assume a normal secret
    //
    SecretType = LSAP_DB_SECRET_CLIENT;

    for ( i = 0;
          i < sizeof( SecretTypePrefixLookupTable ) / sizeof( LSAP_DB_SECRET_TYPE_LOOKUP );
          i++ ) {

        //
        // Initialize a Unicode String with the Global Secret name Prefix.
        //
        RtlInitUnicodeString( &Prefix, SecretTypePrefixLookupTable[ i ].SecretPrefix );

        //
        // Now check if the given Name has the Global Prefix.
        //

        if ( RtlPrefixUnicodeString( &Prefix, (PUNICODE_STRING)SecretName, TRUE ) ) {

            SecretType |= SecretTypePrefixLookupTable[ i ].SecretType;
            break;
        }
    }


    //
    // If it's not known yet, see if it is one of the full named secrets we know about...
    //
    if ( SecretType == LSAP_DB_SECRET_CLIENT ) {

        for ( i = 0;
              i < sizeof( SecretTypeNameLookupTable ) / sizeof( LSAP_DB_SECRET_TYPE_LOOKUP );
              i++ ) {

            //
            // Initialize a Unicode String with the Global Secret name Prefix.
            //
            RtlInitUnicodeString( &Prefix, SecretTypeNameLookupTable[ i ].SecretPrefix );

            //
            // Now check if the given Name matches our known secret name
            //

            if ( RtlEqualUnicodeString( &Prefix, ( PUNICODE_STRING )SecretName, TRUE ) ) {

                SecretType |= SecretTypeNameLookupTable[ i ].SecretType;
                break;
            }
        }
    }

    return( SecretType );
}


NTSTATUS
LsapDbUpgradeSecretForKeyChange(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAPR_HANDLE SecretHandle;
    PLSAPR_CR_CIPHER_VALUE Current, Old;
    LARGE_INTEGER CurrentTime, OldTime;
    LSA_ENUMERATION_HANDLE EnumContext = 0;
    ULONG EnumCount, i;
    PUNICODE_STRING SecretList;
    BOOLEAN LockHeld = FALSE;

    Status = LsapDbReferenceObject( LsapDbHandle,
                                    0,
                                    PolicyObject,
                                    SecretObject,
                                    LSAP_DB_LOCK );

    if ( NT_SUCCESS( Status ) ) {

        LockHeld = TRUE;
    }

    while ( Status == STATUS_SUCCESS ) {

        SecretList = NULL;
        Status = LsaIEnumerateSecrets( LsapDbHandle,
                                       &EnumContext,
                                       ( PVOID * )&SecretList,
                                       2048,
                                       &EnumCount );

        for ( i = 0; NT_SUCCESS( Status ) && i < EnumCount; i++ ) {

            Status = LsarOpenSecret( LsapDbHandle,
                                     ( PLSAPR_UNICODE_STRING )&SecretList[ i ],
                                     SECRET_SET_VALUE | SECRET_QUERY_VALUE,
                                     &SecretHandle );

            if ( NT_SUCCESS( Status ) ) {

                Status = LsarQuerySecret( SecretHandle,
                                          &Current,
                                          &CurrentTime,
                                          &Old,
                                          &OldTime );

                if ( NT_SUCCESS( Status ) ) {

                    Status = LsapDbSetSecret( SecretHandle,
                                              Current,
                                              &CurrentTime,
                                              Old,
                                              &OldTime
#if defined(REMOTE_BOOT)
                                              ,
                                              FALSE
#endif // defined(REMOTE_BOOT)
                                               );

                    LsaIFree_LSAPR_CR_CIPHER_VALUE( Current );
                    LsaIFree_LSAPR_CR_CIPHER_VALUE( Old );

                }

                LsapCloseHandle( &SecretHandle, Status );
            }

            //
            // If there was a problem with the secret, press on:
            // we want to convert as many of them as possible.
            // ISSUE-02/05/2001: log the name of the secret with this problem
            //

            Status = STATUS_SUCCESS;
        }

        MIDL_user_free( SecretList );


    }

    if ( Status == STATUS_NO_MORE_ENTRIES ) {

        Status = STATUS_SUCCESS;
    }

    if ( LockHeld ) {

        Status = LsapDbDereferenceObject( &LsapDbHandle,
                                          PolicyObject,
                                          SecretObject,
                                          LSAP_DB_LOCK,
                                          ( SECURITY_DB_DELTA_TYPE )0,
                                          Status );

    }

    return( Status );
}

NTSTATUS
NTAPI
LsaIChangeSecretCipherKey(
    IN PVOID NewSysKey
    )
/*++

Routine Description:

    Given a new syskey, creates a new password encryption key and
    re-encrypts all the secrets with it

Arguments:

    NewSysKey  - new syskey

Return Values:

    NTSTATUS error code

--*/
{
    NTSTATUS Status;
    LSAP_DB_ENCRYPTION_KEY NewEncryptionKey;
    LSAP_DB_ATTRIBUTE Attributes[1];
    PLSAP_DB_ATTRIBUTE NextAttribute = &Attributes[0];
    ULONG AttributeCount = 0;
    BOOLEAN SecretsLocked = FALSE;

    LsapDbAcquireLockEx( SecretObject, 0 );
    SecretsLocked = TRUE;

    //
    // Create a new key for secret encryption
    //

    Status = LsapDbGenerateNewKey( &NewEncryptionKey );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // Setup the secret cipher key.  This key will be used for writing
    // secrets back to the database.  The key used for reading will not
    // be changed until all secrets are re-encrypted.
    //

    LsapDbInitializeSecretCipherKeyWrite( &NewEncryptionKey );

    //
    // Now iterate over all secrets on the machine, re-encrypting them
    //

    Status = LsapDbUpgradeSecretForKeyChange();

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    //
    // Now substitute the key used for reading secrets, as they are all
    // encrypted using the new key
    //

    LsapDbInitializeSecretCipherKeyRead( &NewEncryptionKey );

    LsapDbReleaseLockEx( SecretObject, 0 );
    SecretsLocked = FALSE;

    //
    // Encrypt the key with syskey
    //

    LsapDbEncryptKeyWithSyskey(
        &NewEncryptionKey,
        NewSysKey,
        LSAP_SYSKEY_SIZE
        );

    //
    // Now write out the new password encryption key
    //

    LsapDbInitializeAttribute(
        NextAttribute,
        &LsapDbNames[PolSecretEncryptionKey],
        &NewEncryptionKey,
        sizeof( NewEncryptionKey ),
        FALSE
        );

    NextAttribute++;
    AttributeCount++;

    Status = LsapDbReferenceObject(
                 LsapDbHandle,
                 0,
                 PolicyObject,
                 PolicyObject,
                 LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION
                 );

    if (NT_SUCCESS(Status)) {

        ASSERT( AttributeCount <= ( sizeof( Attributes ) / sizeof( LSAP_DB_ATTRIBUTE ) ) );

        Status = LsapDbWriteAttributesObject(
                     LsapDbHandle,
                     Attributes,
                     AttributeCount
                     );

        //
        // No attributes are replicatable.
        //

        Status = LsapDbDereferenceObject(
                     &LsapDbHandle,
                     PolicyObject,
                     PolicyObject,
                     (LSAP_DB_LOCK |
                        LSAP_DB_FINISH_TRANSACTION |
                        LSAP_DB_OMIT_REPLICATOR_NOTIFICATION ),
                     SecurityDbChange,
                     Status
                     );
    }

    //
    // ISSUE-markpu-2001/06/27
    // If something went wrong and we could not write the password encryption key
    // out, Should we attempt to revert all secrets back to their original state?
    //

Cleanup:

    if ( SecretsLocked ) {

        LsapDbReleaseLockEx( SecretObject, 0 );
    }

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dsdata.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dsdata.c

Abstract:

    Implemntation of LSA/Ds Initialization routines

Author:

    Mac McLain          (MacM)       Jan 17, 1997

Environment:

    User Mode

Revision History:

--*/

#include <lsapch2.h>
#include <dsp.h>

//
// Info how the LSA uses the DS
//
LSADS_DS_STATE_INFO LsaDsStateInfo = {
    NULL,  // DsRoot
    NULL,  // DsPartitionsContainer
    NULL,  // DsSystemContainer
    NULL,  // DsConfigurationContainer
    0L,    // DsDomainHandle
           // DsFuncTable
    { LsapDsOpenTransactionDummy,
      LsapDsApplyTransactionDummy,
      LsapDsAbortTransactionDummy },
           // SystemContainerItems
    { FALSE, 
      NULL,
      NULL },
    NULL,  // SavedThreadState
    FALSE, // DsTransactionSave
    FALSE, // DsTHStateSave
    FALSE, // DsOperationSave
    FALSE, // WriteLocal
    FALSE, // UseDs
    FALSE, // FunctionTableInitialized
    FALSE, // DsInitializedAndRunning
    FALSE  // Nt4UpgradeInProcess
    };

//
// Domain relative paths of the configuration containers for some object types
//
PWSTR   LsapDsDomainRelativeContainers[] = {

        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    };

USHORT   LsapDsDomainRelativeContainersLen[
                   sizeof(LsapDsDomainRelativeContainers) / sizeof(PWSTR)] = {
    (sizeof(LsapDsDomainRelativeContainers[0]) - 1) / sizeof(WCHAR),
    (sizeof(LsapDsDomainRelativeContainers[1]) - 1) / sizeof(WCHAR),
    (sizeof(LsapDsDomainRelativeContainers[2]) - 1) / sizeof(WCHAR),
    (sizeof(LsapDsDomainRelativeContainers[3]) - 1) / sizeof(WCHAR),
    (sizeof(LsapDsDomainRelativeContainers[4]) - 1) / sizeof(WCHAR),
    (sizeof(LsapDsDomainRelativeContainers[5]) - 1) / sizeof(WCHAR)
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dsattrs.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dsattrs.c

Abstract:

    Static list of attribute blocks commonly searched for

Author:

    Mac McLain          (MacM)       Jan 17, 1997

Environment:

    User Mode

Revision History:

--*/
#include <lsapch2.h>
#include <dbp.h>

ATTR LsapDsAttrs[LsapDsAttrLast];

ULONG LsapDsPlug;

//
// DS Guids
//
GUID LsapDsGuidList[ ] = {
    { 0xbf967ab8, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2 }, // TRUSTED_DOMAIN object
    { 0xb7b13117, 0xb82e, 0x11d0, 0xaf, 0xee, 0x00, 0x00, 0xf8, 0x03, 0x67, 0xc1 }, // Flat name
    { 0x52458023, 0xca6a, 0x11d0, 0xaf, 0xff, 0x00, 0x00, 0xf8, 0x03, 0x67, 0xc1 }, // Initial auth incoming
    { 0x52458024, 0xca6a, 0x11d0, 0xaf, 0xff, 0x00, 0x00, 0xf8, 0x03, 0x67, 0xc1 }, // Intinal auth outgoing
    { 0xbf967a2f, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2 }, // SID
    { 0x80a67e5a, 0x9f22, 0x11d0, 0xaf, 0xdd, 0x00, 0xc0, 0x4f, 0xd9, 0x30, 0xc9 }, // Trust attributes
    { 0xbf967a59, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2 }, // Auth incoming
    { 0xbf967a5f, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2 }, // Auth outgoing
    { 0xbf967a5c, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2 }, // Trust direction
    { 0xbf967a5d, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2 }, // Trust partner
    { 0xbf967a5e, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2 }, // Posix offset
    { 0xbf967a60, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2 }, // Trust type
    { 0xbf967aae, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2 }, // SECRET object
    { 0xbf967947, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2 }, // Current
    { 0xbf967998, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2 }, // Current time
    { 0xbf967a02, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2 }, // Previous
    { 0x244b296e, 0x5abd, 0x11d0, 0xaf, 0xd2, 0x00, 0xc0, 0x4f, 0xd9, 0x30, 0xc9 }  // Previous time
};

//
// Class IDs
//
ULONG LsapDsClassIds[LsapDsClassLast] = {
    CLASS_CROSS_REF,
    CLASS_TRUSTED_DOMAIN,
    CLASS_SECRET
    };

//
// Attribute IDs
//
ULONG LsapDsAttributeIds[LsapDsAttrLast] = {
    ATT_SAM_ACCOUNT_NAME,
    ATT_OBJECT_SID,
    ATT_NT_SECURITY_DESCRIPTOR,
    ATT_NC_NAME,
    ATT_MACHINE_ROLE,
    ATT_DNS_HOST_NAME,
    ATT_INITIAL_AUTH_INCOMING,
    ATT_INITIAL_AUTH_OUTGOING,
    ATT_DNS_ROOT,
    ATT_USER_ACCOUNT_CONTROL,
    ATT_TRUST_PARTNER,
    ATT_FLAT_NAME,
    ATT_DEFAULT_SECURITY_DESCRIPTOR,
    ATT_SERVICE_PRINCIPAL_NAME
    };

//
// ATTRVAL lists
//
ATTRVAL LsapDsClassesVals[LsapDsClassLast] = {
    { sizeof( ULONG ), (PUCHAR)&LsapDsClassIds[LsapDsClassXRef] },
    { sizeof( ULONG ), (PUCHAR)&LsapDsClassIds[LsapDsClassTrustedDomain] },
    { sizeof( ULONG ), (PUCHAR)&LsapDsClassIds[LsapDsClassSecret] }
    };


ATTRVAL LsapDsAttrVals[LsapDsAttrLast] = {
    { 0, (PUCHAR)&LsapDsPlug },
    { sizeof( ULONG ), (PUCHAR)&LsapDsAttributeIds[LsapDsAttrSecDesc] },
    { 0, NULL },
    { 0, NULL },
    { 0, NULL },
    { 0, NULL },
    { 0, NULL },
    { sizeof( ULONG ), (PUCHAR)&LsapDsAttributeIds[LsapDsAttrDnsRoot] },
    { sizeof( 0 ), NULL },
    { sizeof( 0 ), NULL },
    { sizeof( 0 ), NULL }
    };


//
// Attribute lists
//
ATTR LsapDsClasses[LsapDsClassLast] = {
    { ATT_OBJECT_CLASS, { 1, &LsapDsAttrVals[LsapDsClassXRef] } },
    { ATT_OBJECT_CLASS, { 1, &LsapDsAttrVals[LsapDsClassTrustedDomain] } },
    { ATT_OBJECT_CLASS, { 1, &LsapDsAttrVals[LsapDsClassSecret] } }

    };

ATTR LsapDsAttrs[LsapDsAttrLast] = {

    { ATT_SAM_ACCOUNT_NAME, {1, &LsapDsAttrVals[LsapDsAttrSamAccountName] } },
    { ATT_OBJECT_SID, { 1, &LsapDsAttrVals[ LsapDsAttrSid ] } },
    { ATT_NT_SECURITY_DESCRIPTOR, { 1, &LsapDsAttrVals[ LsapDsAttrSecDesc ] } },
    { ATT_NC_NAME, { 0, NULL } },
    { ATT_MACHINE_ROLE, { 0, 0 } },
    { ATT_DNS_HOST_NAME, { 0, 0 } },
    { ATT_DEFAULT_SECURITY_DESCRIPTOR, { 0, 0 } }
    };

ATTR LsapDsMachineDnsHost[ 1 ] = {
    { ATT_DNS_HOST_NAME, { 0, NULL } }
    };

ATTR LsapDsMachineSpn[ 1 ] = {
    { ATT_SERVICE_PRINCIPAL_NAME, { 0, NULL } }
    };

ATTR LsapDsMachineClientSetAttrs[ LsapDsMachineClientSetAttrsCount ] = {
    { ATT_DNS_HOST_NAME, {0, NULL } },
    { ATT_OPERATING_SYSTEM, {0, NULL } },
    { ATT_OPERATING_SYSTEM_VERSION, {0, NULL } },
    { ATT_OPERATING_SYSTEM_SERVICE_PACK, {0, NULL } },
    { ATT_SERVICE_PRINCIPAL_NAME, {0, NULL } }
    };

ATTR LsapDsServerReferenceBl[ 1 ] = {
    { ATT_SERVER_REFERENCE_BL, {0, NULL } }
    };

ATTR LsapDsTrustedDomainFixupAttributes[ LsapDsTrustedDomainFixupAttributeCount ] = {
    { ATT_TRUST_PARTNER, {0, NULL } },
    { ATT_FLAT_NAME, {0, NULL } },
    { ATT_DOMAIN_CROSS_REF, {0, NULL } },
    { ATT_TRUST_ATTRIBUTES, {0, NULL } },
    { ATT_TRUST_DIRECTION, {0, NULL } },
    { ATT_TRUST_TYPE, {0, NULL } },
    { ATT_TRUST_POSIX_OFFSET, {0, NULL } },
    { ATT_INITIAL_AUTH_INCOMING, {0, NULL } },
    { ATT_SECURITY_IDENTIFIER, {0,NULL}},
    { ATT_INITIAL_AUTH_OUTGOING, {0, NULL } },
    { ATT_MS_DS_TRUST_FOREST_TRUST_INFO, {0, NULL } },
    };

ATTR LsapDsTrustedDomainFixupXRefAttributes[ LsapDsTrustedDomainFixupXRefCount ] = {
    { ATT_DNS_ROOT, { 0, NULL } },
    { ATT_NC_NAME,  { 0, NULL } },
    { ATT_NETBIOS_NAME, {0, NULL}}
    };

ATTR LsapDsDomainNameSearch [ LsapDsDomainNameSearchCount ] = {
    { ATT_TRUST_PARTNER, { 1, &LsapDsAttrVals[ LsapDsAttrTrustPartner ] } },
    { ATT_FLAT_NAME, { 1, &LsapDsAttrVals[ LsapDsAttrTrustPartnerFlat ] } }
    };


ATTR LsapDsForestInfoSearchAttributes[ LsapDsForestInfoSearchAttributeCount ] = {
    { ATT_DNS_ROOT, { 0, NULL } },
    { ATT_NETBIOS_NAME, { 0, NULL } },
    { ATT_ROOT_TRUST, { 0, NULL } },
    { ATT_TRUST_PARENT, { 0, NULL } },
    { ATT_OBJECT_GUID, { 0, NULL } },
    { ATT_NC_NAME, { 0, NULL } }
    };

ATTR LsapDsDnsRootWellKnownObject[ LsapDsDnsRootWellKnownObjectCount ] = {
    { ATT_WELL_KNOWN_OBJECTS, { 0, NULL } }
    };

ATTR LsapDsITAFixupAttributes[ LsapDsITAFixupAttributeCount ] = {
    { ATT_SAM_ACCOUNT_NAME, { 0, NULL } },
    { ATT_USER_ACCOUNT_CONTROL, { 0, NULL } }
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dsattrs.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dsp.h

Abstract:

    Private macros/definitions/prototypes for implementing a portion of the LSA store
    in the DS

Author:

    Mac McLain          (MacM)       Jan 17, 1997

Environment:

    User Mode

Revision History:

--*/

#ifndef __DSATTRS_H__
#define __DSATTRS_H__


typedef enum _LSAPDS_DS_CLASSES {

    LsapDsClassXRef = 0,
    LsapDsClassTrustedDomain,
    LsapDsClassSecret,
    LsapDsClassLast

} LSAPDS_DS_CLASSES, *PLSAPDS_DS_CLASSES;

typedef enum _LSAPDS_DS_ATTRS {

    LsapDsAttrSamAccountName,               // Machines sam account name
    LsapDsAttrSid,                          // Sid attribute
    LsapDsAttrSecDesc,
    LsapDsAttrNamingContext,                // Naming context
    LsapDsAttrMachineRole,                  // Machine role
    LsapDsAttrMachineDns,                   // Dns name on the machine object
    LsapDsAttrInitialIncomingAuth,
    LsapDsAttrInitialOutgoingAuth,
    LsapDsAttrDnsRoot,                      // Domain Dns root
    LsapDsAttrSamAccountControl,            // SAM user account control fields
    LsapDsAttrTrustPartner,                 // Trust partner for trusted domain objects
    LsapDsAttrTrustPartnerFlat,             // Flat name of partner for trusted domain objects
    LsapDsAttrDefaultSecDesc,               // Default object security descriptor
    LsapDsAttrSpn,                          // Client SPN
    LsapDsAttrLast

} LSAPDS_SRCH_ATTRS;

typedef enum _LSAPDS_DS_GUIDS {

    LsapDsGuidTrust,
    LsapDsGuidFlatName,
    LsapDsGuidInitialIncoming,
    LsapDsGuidInitialOutgoing,
    LsapDsGuidSid,
    LsapDsGuidAttributes,
    LsapDsGuidIncoming,
    LsapDsGuidOutgoing,
    LsapDsGuidDirection,
    LsapDsGuidPartner,
    LsapDsGuidPosix,
    LsapDsGuidType,
    LsapDsGuidSecret,
    LsapDsGuidCurrent,
    LsapDsGuidCurrentTime,
    LsapDsGuidPrevious,
    LsapDsguidPreviousTime

} LSAPDS_DS_GUIDS, *PLSAPDS_DS_GUIDS;

extern GUID LsapDsGuidList[ ];

extern ULONG LsapDsAttributeIds[LsapDsAttrLast];
extern ULONG LsapDsClassIds[LsapDsClassLast];

extern ATTR LsapDsClasses[LsapDsClassLast];
extern ATTR LsapDsAttrs[LsapDsAttrLast];

//
// Specially constructed multiple attributes that
//
extern ATTR LsapDsMachineDnsHost[ 1 ];
#define LsapDsMachineDnsHostCount ( sizeof( LsapDsMachineDnsHost ) / sizeof( ATTR ) )

#define LsapDsMachineClientSetAttrsCount 5
extern ATTR LsapDsMachineClientSetAttrs[ LsapDsMachineClientSetAttrsCount ];

extern ATTR LsapDsMachineSpn[ 1 ];
#define LsapDsMachineSpnCount ( sizeof( LsapDsMachineSpn ) / sizeof( ATTR ) )

extern ATTR LsapDsServerReferenceBl[ 1 ];
#define LsapDsServerReferenceCountBl ( sizeof( LsapDsServerReferenceBl ) / sizeof( ATTR ) )

#define LsapDsDomainNameSearchCount 2
extern ATTR LsapDsDomainNameSearch [ LsapDsDomainNameSearchCount ];

#define LsapDsDnsRootWellKnownObjectCount 1
extern ATTR LsapDsDnsRootWellKnownObject[ LsapDsDnsRootWellKnownObjectCount ];

//
// Used for the trusted domain object fixup on reboot
//
#define LsapDsTrustedDomainFixupAttributeCount 11
extern ATTR LsapDsTrustedDomainFixupAttributes[ LsapDsTrustedDomainFixupAttributeCount ];

#define LsapDsTrustedDomainFixupXRefCount 3
extern ATTR LsapDsTrustedDomainFixupXRefAttributes[ LsapDsTrustedDomainFixupXRefCount ];

#define LsapDsForestInfoSearchAttributeCount 6
extern ATTR LsapDsForestInfoSearchAttributes[ LsapDsForestInfoSearchAttributeCount ];

#define LsapDsITAFixupAttributeCount 2
extern ATTR LsapDsITAFixupAttributes[ LsapDsITAFixupAttributeCount ];

//
// Macros to help with the manipulation of attributes
//
#define LSAP_DS_SET_DS_ATTRIBUTE_STRING( pattr, string )                        \
(pattr)->AttrVal.pAVal->valLen = wcslen( string ) * sizeof( WCHAR );            \
(pattr)->AttrVal.pAVal->pVal = (PUCHAR)string;                                  \

#define LSAP_DS_SET_DS_ATTRIBUTE_UNICODE( pattr, string )                       \
(pattr)->AttrVal.pAVal->valLen = (string)->Length;                              \
(pattr)->AttrVal.pAVal->pVal = (PUCHAR)(string)->Buffer;                        \

#define LSAP_DS_SET_DS_ATTRIBUTE_ULONG( pattr, ulongval )                       \
(pattr)->AttrVal.pAVal->valLen = sizeof( ULONG );                               \
(pattr)->AttrVal.pAVal->pVal = (PUCHAR)&ulongval;                               \

#define LSAP_DS_SET_DS_ATTRIBUTE_SID( pattr, sid )                              \
(pattr)->AttrVal.pAVal->valLen = RtlLengthSid( sid );                           \
(pattr)->AttrVal.pAVal->pVal = (PUCHAR)sid;                                     \

#define LSAP_DS_SET_DS_ATTRIBUTE_DSNAME( pattr, dsname )                        \
(pattr)->AttrVal.pAVal->valLen = dsname->structLen;                             \
(pattr)->AttrVal.pAVal->pVal = (PUCHAR)dsname;                                  \


#define LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( pattr )                            \
(pattr)->AttrVal.pAVal->valLen

#define LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( pattr )                          \
(*(PULONG)((pattr)->AttrVal.pAVal->pVal) )

#define LSAP_DS_GET_DS_ATTRIBUTE_AS_DSNAME( pattr )                         \
((PDSNAME)((pattr)->AttrVal.pAVal->pVal ))

#define LSAP_DS_GET_DS_ATTRIBUTE_AS_PWSTR( pattr )                          \
((PWSTR)((pattr)->AttrVal.pAVal->pVal ))

#define LSAP_DS_GET_DS_ATTRIBUTE_AS_USN( pattr )                            \
((PUSN)((pattr)->AttrVal.pAVal->pVal ))

#define LSAP_DS_GET_DS_ATTRIBUTE_AS_PBYTE( pattr )                          \
((PBYTE)((pattr)->AttrVal.pAVal->pVal ))

#endif // __DSATTRS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbpriv.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbpriv.c

Abstract:

    LSA - Database - Privilege Object Private API Workers

    NOTE:  This module should remain as portable code that is independent
           of the implementation of the LSA Database.  As such, it is
           permitted to use only the exported LSA Database interfaces
           contained in db.h and NOT the private implementation
           dependent functions in dbp.h.

Author:

    Jim Kelly       (JimK)      March 24, 1992

Environment:

Revision History:
    06-April-1999 kumarp
        Since NT5 does not support extensible privilege dlls, code that
        supports this has been removed. This code is available in
        dbpriv.c@v10. The code should be re-added to this file post NT5.
    
--*/

#include <lsapch2.h>
#include "dbp.h"
#include "adtp.h"



///////////////////////////////////////////////////////////////////////////
//                                                                       //
//                                                                       //
//       Module-wide data types                                          //
//                                                                       //
//                                                                       //
///////////////////////////////////////////////////////////////////////////


typedef struct _LSAP_DLL_DESCRIPTOR {
    WORD Count;
    WORD Language;
    PVOID DllHandle;
} LSAP_DLL_DESCRIPTOR, *PLSAP_DLL_DESCRIPTOR;



///////////////////////////////////////////////////////////////////////////
//                                                                       //
//                                                                       //
//       Module-wide variables                                           //
//                                                                       //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

#define MAX_PRIVILEGE_DISPLAY_NAME_CHARS 256

//
// Neutral English language value
//

WORD LsapNeutralEnglish;

//
// Until we actually have a privilege object, keep well known privilege
// information as global data.  The information for each privilege is
// kept in a an array POLICY_PRIVILEGE_DEFINITION structures.
//

ULONG  LsapWellKnownPrivilegeCount;
USHORT LsapWellKnownPrivilegeMaxLen;
POLICY_PRIVILEGE_DEFINITION LsapKnownPrivilege[SE_MAX_WELL_KNOWN_PRIVILEGE];

//
// we store the known privilege names in this array so that we do not have to
// load them from msprivs.dll every time. this will change when we
// support vendor supplied priv. dlls.
//
static LPCWSTR LsapKnownPrivilageNames[] =
{
    SE_CREATE_TOKEN_NAME,
    SE_ASSIGNPRIMARYTOKEN_NAME,
    SE_LOCK_MEMORY_NAME,
    SE_INCREASE_QUOTA_NAME,
    SE_MACHINE_ACCOUNT_NAME,
    SE_TCB_NAME,
    SE_SECURITY_NAME,
    SE_TAKE_OWNERSHIP_NAME,
    SE_LOAD_DRIVER_NAME,
    SE_SYSTEM_PROFILE_NAME,
    SE_SYSTEMTIME_NAME,
    SE_PROF_SINGLE_PROCESS_NAME,
    SE_INC_BASE_PRIORITY_NAME,
    SE_CREATE_PAGEFILE_NAME,
    SE_CREATE_PERMANENT_NAME,
    SE_BACKUP_NAME,
    SE_RESTORE_NAME,
    SE_SHUTDOWN_NAME,
    SE_DEBUG_NAME,
    SE_AUDIT_NAME,
    SE_SYSTEM_ENVIRONMENT_NAME,
    SE_CHANGE_NOTIFY_NAME,
    SE_REMOTE_SHUTDOWN_NAME,
    SE_UNDOCK_NAME,
    SE_SYNC_AGENT_NAME,
    SE_ENABLE_DELEGATION_NAME,
    SE_MANAGE_VOLUME_NAME
};

static UINT LsapNumKnownPrivileges = sizeof(LsapKnownPrivilageNames) /
        sizeof(LsapKnownPrivilageNames[0]);


//
// Array of handles to DLLs containing privilege definitions
//

ULONG LsapPrivilegeDllCount;
PLSAP_DLL_DESCRIPTOR LsapPrivilegeDlls;  //Array



//
// TEMPORARY: Name of Microsoft's standard privilege names DLL
//

WCHAR MsDllNameString[] = L"msprivs";
UNICODE_STRING MsDllName;




///////////////////////////////////////////////////////////////////////////
//                                                                       //
//                                                                       //
//       Module Wide Macros                                              //
//                                                                       //
//                                                                       //
///////////////////////////////////////////////////////////////////////////


#define LsapFreePrivilegeDllNames( D ) (STATUS_SUCCESS)



///////////////////////////////////////////////////////////////////////////
//                                                                       //
//                                                                       //
//       Internal routine templates                                      //
//                                                                       //
//                                                                       //
///////////////////////////////////////////////////////////////////////////


NTSTATUS
LsapLookupKnownPrivilegeName(
    PLUID Value,
    PUNICODE_STRING *Name
    );

NTSTATUS
LsapLookupKnownPrivilegeValue(
    PUNICODE_STRING Name,
    PLUID Value
    );

NTSTATUS
LsapLookupPrivilegeDisplayName(
    IN PUNICODE_STRING ProgrammaticName,
    IN WORD ClientLanguage,
    IN WORD ClientSystemDefaultLanguage,
    OUT PUNICODE_STRING *DisplayName,
    OUT PWORD LanguageReturned
    );


NTSTATUS
LsapGetPrivilegeDisplayName(
    IN ULONG DllIndex,
    IN ULONG PrivilegeIndex,
    IN WORD ClientLanguage,
    IN WORD ClientSystemDefaultLanguage,
    OUT PUNICODE_STRING *DisplayName,
    OUT PWORD LanguageReturned
    );


NTSTATUS
LsapGetPrivilegeDisplayNameResourceId(
    IN PUNICODE_STRING Name,
    IN ULONG DllIndex,
    OUT PULONG PrivilegeIndex
    );


NTSTATUS
LsapOpenPrivilegeDlls( VOID );


NTSTATUS
LsapGetPrivilegeDllNames(
    OUT PUNICODE_STRING *DllNames,
    OUT PULONG DllCount
    );


NTSTATUS
LsapValidatePrivilegeDlls( VOID );


NTSTATUS
LsapValidateProgrammaticNames(
    ULONG DllIndex
    );

NTSTATUS
LsapDbInitWellKnownPrivilegeName(
    IN ULONG            Index,
    IN PUNICODE_STRING  Name
    );


///////////////////////////////////////////////////////////////////////////
//                                                                       //
//                                                                       //
//       RPC stub-called routines                                        //
//                                                                       //
//                                                                       //
///////////////////////////////////////////////////////////////////////////


NTSTATUS
LsarEnumeratePrivileges(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAPR_PRIVILEGE_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength
    )

/*++

Routine Description:

    This function returnes information about privileges known on this
    system.  This call requires POLICY_VIEW_LOCAL_INFORMATION access
    to the Policy Object.  Since there may be more information than
    can be returned in a single call of the routine, multiple calls
    can be made to get all of the information.  To support this feature,
    the caller is provided with a handle that can be used across calls to
    the API.  On the initial call, EnumerationContext should point to a
    variable that has been initialized to 0.

    WARNING!  CURRENTLY, THIS FUNCTION ONLY RETURNS INFORMATION ABOUT
              WELL-KNOWN PRIVILEGES.  LATER, IT WILL RETURN INFORMATION
              ABOUT LOADED PRIVILEGES.

Arguments:

    PolicyHandle - Handle from an LsarOpenPolicy() call.

    EnumerationContext - API specific handle to allow multiple calls
        (see Routine Description).

    EnumerationBuffer - Pointer to structure that will be initialized to
        contain a count of the privileges returned and a pointer to an
        array of structures of type LSAPR_POLICY_PRIVILEGE_DEF describing
        the privileges.

    PreferedMaximumLength - Prefered maximim length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves as
        a guide.  Due to data conversion between systems with different
        natural data sizes, the actual amount of data returned may be
        greater than this value.

    CountReturned - Number of entries returned.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

        STATUS_INVALID_HANDLE - PolicyHandle is not a valid handle to
            a Policy object.

        STATUS_ACCESS_DENIED - The caller does not have the necessary
            access to perform the operation.

        STATUS_MORE_ENTRIES - There are more entries, so call again.  This
            is an informational status only.

        STATUS_NO_MORE_ENTRIES - No entries were returned because there
            are no more.
--*/

{
    NTSTATUS Status, PreliminaryStatus;
    BOOLEAN ObjectReferenced = FALSE;

    LsarpReturnCheckSetup();

    //
    // Acquire the Lsa Database lock.  Verify that PolicyHandle is a valid
    // hadnle to a Policy Object and is trusted or has the necessary accesses.
    // Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_VIEW_LOCAL_INFORMATION,
                 PolicyObject,
                 NullObject,
                 LSAP_DB_READ_ONLY_TRANSACTION | LSAP_DB_NO_DS_OP_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto EnumeratePrivilegesError;
    }

    ObjectReferenced = TRUE;

    //
    // Call Privilege Enumeration Routine.
    //

    Status = LsapDbEnumeratePrivileges(
                 EnumerationContext,
                 EnumerationBuffer,
                 PreferedMaximumLength
                 );

    if (!NT_SUCCESS(Status)) {

        goto EnumeratePrivilegesError;
    }

EnumeratePrivilegesFinish:

    //
    // If necessary, dereference the Policy Object, release the LSA Database
    // lock and return.  Preserve current Status where appropriate.
    //

    if (ObjectReferenced) {

        PreliminaryStatus = Status;

        Status = LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     NullObject,
                     LSAP_DB_READ_ONLY_TRANSACTION | LSAP_DB_NO_DS_OP_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     PreliminaryStatus
                     );

        ObjectReferenced = FALSE;

        if ((!NT_SUCCESS(Status)) && NT_SUCCESS(PreliminaryStatus)) {

            goto EnumeratePrivilegesError;
        }
    }

    LsarpReturnPrologue();

    return(Status);

EnumeratePrivilegesError:

    goto EnumeratePrivilegesFinish;
}


NTSTATUS
LsapDbEnumeratePrivileges(
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAPR_PRIVILEGE_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength
    )

/*++

Routine Description:

    This function returnes information about the Privileges that exist
    in the system.access to the Policy Object.  Since there
    may be more information than can be returned in a single call of the
    routine, multiple calls can be made to get all of the information.
    To support this feature, the caller is provided with a handle that can
    be used across calls to the API.  On the initial call, EnumerationContext
    should point to a variable that has been initialized to 0.

    WARNING!  CURRENTLY, THIS FUNCTION ONLY RETURNS INFORMATION ABOUT
              WELL-KNOWN PRIVILEGES.  LATER, IT WILL RETURN INFORMATION
              ABOUT LOADED PRIVILEGES.

Arguments:

    EnumerationContext - API specific handle to allow multiple calls
        (see Routine Description).

    EnumerationBuffer - Pointer to structure that will be initialized to
        contain a count of the privileges returned and a pointer to an
        array of structures of type LSAPR_POLICY_PRIVILEGE_DEF describing
        the privileges.

    PreferedMaximumLength - Prefered maximim length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves as
        a guide.  Due to data conversion between systems with different
        natural data sizes, the actual amount of data returned may be
        greater than this value.

    CountReturned - Number of entries returned.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

        STATUS_INVALID_HANDLE - PolicyHandle is not a valid handle to
            a Policy object.

        STATUS_ACCESS_DENIED - The caller does not have the necessary
            access to perform the operation.

        STATUS_MORE_ENTRIES - There are more entries, so call again.  This
            is an informational status only.

        STATUS_NO_MORE_ENTRIES - No entries were returned because there
            are no more.
--*/

{
    NTSTATUS Status;
    ULONG WellKnownPrivilegeCount = (SE_MAX_WELL_KNOWN_PRIVILEGE - SE_MIN_WELL_KNOWN_PRIVILEGE + 1);
    ULONG Index;

    Status = STATUS_INVALID_PARAMETER;

    //
    // If the Enumeration Context Value given exceeds the total count of
    // Privileges, return an error.
    //

    Status = STATUS_NO_MORE_ENTRIES;

    if (*EnumerationContext >= WellKnownPrivilegeCount) {

        goto EnumeratePrivilegesError;
    }

    //
    // Since there are only a small number of privileges, we will
    // return all of the information in one go, so allocate memory
    // for output array of Privilege Definition structures.
    //

    EnumerationBuffer->Entries = WellKnownPrivilegeCount;
    EnumerationBuffer->Privileges =
        MIDL_user_allocate(
            WellKnownPrivilegeCount * sizeof (POLICY_PRIVILEGE_DEFINITION)
            );

    Status = STATUS_INSUFFICIENT_RESOURCES;

    if (EnumerationBuffer->Privileges == NULL) {

        goto EnumeratePrivilegesError;
    }

    RtlZeroMemory(
        EnumerationBuffer->Privileges,
        WellKnownPrivilegeCount * sizeof (POLICY_PRIVILEGE_DEFINITION)
        );

    //
    // Now lookup each of the Well Known Privileges.
    //

    for( Index = *EnumerationContext;
        Index < (SE_MAX_WELL_KNOWN_PRIVILEGE - SE_MIN_WELL_KNOWN_PRIVILEGE + 1);
        Index++) {

        EnumerationBuffer->Privileges[ Index ].LocalValue
        = LsapKnownPrivilege[ Index ].LocalValue;

        Status = LsapRpcCopyUnicodeString(
                     NULL,
                     (PUNICODE_STRING) &EnumerationBuffer->Privileges[ Index].Name,
                     &LsapKnownPrivilege[ Index ].Name
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto EnumeratePrivilegesError;
    }

    *EnumerationContext = Index;

EnumeratePrivilegesFinish:

    return(Status);

EnumeratePrivilegesError:

    //
    // If necessary, free any memory buffers allocated for Well Known Privilege
    // Programmatic Names.
    //

    if (EnumerationBuffer->Privileges != NULL) {

        for( Index = 0;
            Index < SE_MAX_WELL_KNOWN_PRIVILEGE - SE_MIN_WELL_KNOWN_PRIVILEGE;
            Index++) {

           if ( EnumerationBuffer->Privileges[ Index].Name.Buffer != NULL) {

               MIDL_user_free( EnumerationBuffer->Privileges[ Index ].Name.Buffer );
           }
        }

        MIDL_user_free( EnumerationBuffer->Privileges );
        EnumerationBuffer->Privileges = NULL;
    }

    EnumerationBuffer->Entries = 0;
    *EnumerationContext = 0;
    goto EnumeratePrivilegesFinish;

    UNREFERENCED_PARAMETER( PreferedMaximumLength );
}


NTSTATUS
LsarLookupPrivilegeValue(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING Name,
    OUT PLUID Value
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaLookupPrivilegeValue() API.


Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy() call.  This handle
        must be open for POLICY_LOOKUP_NAMES access.

    Name - Is the privilege's programmatic name.

    Value - Receives the locally unique ID the privilege is known by on the
        target machine.

Return Value:

    NTSTATUS - The privilege was found and returned.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_NO_SUCH_PRIVILEGE -  The specified privilege could not be
        found.

--*/

{
    NTSTATUS Status;
    LSAP_DB_HANDLE Handle = (LSAP_DB_HANDLE) PolicyHandle;

    LsarpReturnCheckSetup();

    //
    // Validate the input buffer
    //
    if ( !LsapValidateLsaUnicodeString( Name ) ) {

        return( STATUS_INVALID_PARAMETER );
    }


    //
    // Make sure we know what RPC is doing to/for us
    //

    ASSERT( Name != NULL );

    //
    // make sure the caller has the appropriate access
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_LOOKUP_NAMES,
                 PolicyObject,
                 NullObject,
                 LSAP_DB_READ_ONLY_TRANSACTION | LSAP_DB_NO_DS_OP_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    //
    // No need to hold onto the Policy object after this..
    // We just needed it for access validation purposes.
    //


    Status = LsapDbDereferenceObject(
                 &PolicyHandle,
                 PolicyObject,
                 NullObject,
                 LSAP_DB_READ_ONLY_TRANSACTION | LSAP_DB_NO_DS_OP_TRANSACTION,
                 (SECURITY_DB_DELTA_TYPE) 0,
                 Status
                 );


    if (NT_SUCCESS(Status)) {

        if (Name->Buffer == 0 || Name->Length == 0) {
            return(STATUS_NO_SUCH_PRIVILEGE);
        }

        Status = LsapLookupKnownPrivilegeValue( (PUNICODE_STRING) Name, Value );
    }

    LsarpReturnPrologue();


    return(Status);
}



NTSTATUS
LsarLookupPrivilegeName(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLUID Value,
    OUT PLSAPR_UNICODE_STRING *Name
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaLookupPrivilegeName() API.


Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy() call.  This handle
        must be open for POLICY_LOOKUP_NAMES access.

    Value - is the locally unique ID the privilege is known by on the
        target machine.

    Name - Receives the privilege's programmatic name.

Return Value:

    NTSTATUS - Standard Nt Result Code

    STATUS_SUCCESS - The privilege was found and returned.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_NO_SUCH_PRIVILEGE -  The specified privilege could not be
        found.

--*/

{
    NTSTATUS Status;
    LSAP_DB_HANDLE Handle = (LSAP_DB_HANDLE) PolicyHandle;

    LsarpReturnCheckSetup();

    //
    // make sure we know what RPC is doing to/for us
    //

    ASSERT( Name != NULL );
    ASSERT( (*Name) == NULL );


    //
    // make sure the caller has the appropriate access
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_LOOKUP_NAMES,
                 PolicyObject,
                 NullObject,
                 LSAP_DB_READ_ONLY_TRANSACTION | LSAP_DB_NO_DS_OP_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    //
    // No need to hold onto the Policy object after this..
    // We just needed it for access validation purposes.
    //


    Status = LsapDbDereferenceObject(
                 &PolicyHandle,
                 PolicyObject,
                 NullObject,
                 LSAP_DB_READ_ONLY_TRANSACTION | LSAP_DB_NO_DS_OP_TRANSACTION,
                 (SECURITY_DB_DELTA_TYPE) 0,
                 Status
                 );

    if (NT_SUCCESS(Status)) {

        Status = LsapLookupKnownPrivilegeName( Value,(PUNICODE_STRING *) Name );
    }

    LsarpReturnPrologue();

    return(Status);
}



NTSTATUS
LsarLookupPrivilegeDisplayName(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING Name,
    IN SHORT ClientLanguage,
    IN SHORT ClientSystemDefaultLanguage,
    OUT PLSAPR_UNICODE_STRING *DisplayName,
    OUT PWORD LanguageReturned
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaLookupPrivilegeDisplayName() API.


Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy() call.  This handle
        must be open for POLICY_LOOKUP_NAMES access.

    Name - The programmatic privilege name to look up.

    ClientLanguage - The prefered language to be returned.

    ClientSystemDefaultLanguage - The alternate prefered language
        to be returned.

    DisplayName - Receives the privilege's displayable name.

    LanguageReturned - The language actually returned.


Return Value:

    NTSTATUS - The privilege text was found and returned.


    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.


    STATUS_NO_SUCH_PRIVILEGE -  The specified privilege could not be
        found.

--*/

{
    NTSTATUS Status;
    LSAP_DB_HANDLE Handle = (LSAP_DB_HANDLE) PolicyHandle;
    LsarpReturnCheckSetup();

    //
    // make sure we know what RPC is doing to/for us
    //

    ASSERT( DisplayName != NULL );
    ASSERT( (*DisplayName) == NULL );
    ASSERT( LanguageReturned != NULL );

    //
    // Validate the input buffer
    //
    if ( !LsapValidateLsaUnicodeString( Name ) ) {

        return( STATUS_INVALID_PARAMETER );
    }


    //
    // make sure the caller has the appropriate access
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_LOOKUP_NAMES,
                 PolicyObject,
                 NullObject,
                 LSAP_DB_READ_ONLY_TRANSACTION | LSAP_DB_NO_DS_OP_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    //
    // No need to hold onto the Policy object after this..
    // We just needed it for access validation purposes.
    //

    Status = LsapDbDereferenceObject(
                 &PolicyHandle,
                 PolicyObject,
                 NullObject,
                 LSAP_DB_READ_ONLY_TRANSACTION | LSAP_DB_NO_DS_OP_TRANSACTION,
                 (SECURITY_DB_DELTA_TYPE) 0,
                 Status
                 );

    if (NT_SUCCESS(Status)) {

        if (Name->Buffer == 0 || Name->Length == 0) {
            return(STATUS_NO_SUCH_PRIVILEGE);
        }
        Status = LsapLookupPrivilegeDisplayName(
                    (PUNICODE_STRING)Name,
                    (WORD)ClientLanguage,
                    (WORD)ClientSystemDefaultLanguage,
                    (PUNICODE_STRING *)DisplayName,
                    LanguageReturned
                    );
    }

    LsarpReturnPrologue();

    return(Status);
}



///////////////////////////////////////////////////////////////////////////
//                                                                       //
//                                                                       //
//       Internal Routines                                               //
//                                                                       //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

NTSTATUS
LsapLookupKnownPrivilegeNameQuickly(
    IN  PLUID Value,
    OUT UNICODE_STRING *Name
    )
/*++

Routine Description:
    Lookup a privilege luid to find the corresponding privilege name.

Arguments:

    Value - LUID to lookup

    Name  - pointer to privilege name

Return Value:

    NTSTATUS - Standard Nt Result Code

    The name returned must NOT be freed or modified by the caller.

Notes:
    The 'Quickly' in the name refers to an index based lookup.
    This is highly dependent on the privilege values (ntseapi.h)
    being consecutive integers. If there is a hole introduced in the
    well known privilege values, then this function will need to be fixed.
    

--*/
{
    ULONG LowPart = Value->LowPart;
    NTSTATUS Status = STATUS_SUCCESS;
    
    if ((Value->HighPart == 0) &&
        (LowPart >= SE_MIN_WELL_KNOWN_PRIVILEGE) &&
        (LowPart <= SE_MAX_WELL_KNOWN_PRIVILEGE))
    {
        *Name = LsapKnownPrivilege[LowPart-SE_MIN_WELL_KNOWN_PRIVILEGE].Name;
    }
    else
    {
        Status = STATUS_NO_SUCH_PRIVILEGE;
    }

    return Status;
}


NTSTATUS
LsapLookupKnownPrivilegeName(
    IN PLUID Value,
    OUT PUNICODE_STRING *Name
    )

/*++

Routine Description:

    Look up the specified LUID and return the corresponding
    privilege's programmatic name (if found).

    FOR NOW, WE ONLY SUPPORT WELL-KNOWN MICROSOFT PRIVILEGES.
    THESE ARE HARD-CODED HERE.  IN THE FUTURE, WE MUST ALSO
    SEARCH A LIST OF LOADED PRIVILEGES.

Arguments:

    Value - Value to look up.

    Name - Receives the corresponding name - allocated with
        MIDL_user_allocate() and ready to return via an RPC stub.

Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_NO_MEMORY - Indicates there was not enough heap memory available
        to produce the final TokenInformation structure.

    STATUS_NO_SUCH_PRIVILEGE -  The specified privilege could not be
        found.

--*/

{
    ULONG i;
    UNICODE_STRING PrivName;
    PUNICODE_STRING ReturnName;
    NTSTATUS Status=STATUS_SUCCESS;


    Status = LsapLookupKnownPrivilegeNameQuickly( Value, &PrivName );

    if (Status == STATUS_SUCCESS) {
        
        ReturnName = MIDL_user_allocate( sizeof(UNICODE_STRING) );
        if (ReturnName == NULL) {
            return(STATUS_NO_MEMORY);
        }

        *ReturnName = PrivName;

        ReturnName->Buffer = MIDL_user_allocate( ReturnName->MaximumLength );

        if (ReturnName->Buffer == NULL) {
            MIDL_user_free( ReturnName );
            return(STATUS_NO_MEMORY);
        }

        RtlCopyUnicodeString( ReturnName, &PrivName );

        (*Name) = ReturnName;

    }

    return Status;
}



NTSTATUS
LsapLookupKnownPrivilegeValue(
    PUNICODE_STRING Name,
    PLUID Value
    )

/*++

Routine Description:

    Look up the specified name and return the corresponding
    privilege's locally assigned value (if found).


    FOR NOW, WE ONLY SUPPORT WELL-KNOWN MICROSOFT PRIVILEGES.
    THESE ARE HARD-CODED HERE.  IN THE FUTURE, WE MUST ALSO
    SEARCH A LIST OF LOADED PRIVILEGES.



Arguments:



    Name - The name to look up.

    Value - Receives the corresponding locally assigned value.


Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_NO_SUCH_PRIVILEGE -  The specified privilege could not be
        found.

--*/

{
    ULONG i;
    BOOLEAN Found;

    for ( i=0; i<LsapWellKnownPrivilegeCount; i++) {

        Found = RtlEqualUnicodeString( Name, &LsapKnownPrivilege[i].Name, TRUE );

        if (Found) {

            (*Value) = LsapKnownPrivilege[i].LocalValue;
            return(STATUS_SUCCESS);
        }
    }

    return(STATUS_NO_SUCH_PRIVILEGE);
}


NTSTATUS
LsapGetPrivilegeDisplayNameResourceId(
    IN PUNICODE_STRING Name,
    IN ULONG DllIndex,
    OUT PULONG ResourceId
    )

/*++

Routine Description:

    This routine maps a privilege programmatic name in a dll to
    its display name resource id in the same dll.
    Currently since we support only one dll, it simply ignores
    DllIndex and uses the internal table to speed up things.


Arguments:

    Name - The programmatic name of the privilege to look up.
        E.g., "SeTakeOwnershipPrivilege".

    DllIndex - The index of the privilege DLL to look in.

    PrivilegeIndex - Receives the index of the privilege entry in this
        resource file.


Return Value:

    STATUS_SUCCESS - The pivilege has been successfully located.

    STATUS_NO_SUCH_PRIVILEGE - The privilege could not be located.

--*/



{
    UINT i;
    
    for (i=0; i<LsapNumKnownPrivileges; i++)
    {
        if (CSTR_EQUAL ==
            CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),  
                                   SORT_DEFAULT),
                          NORM_IGNORECASE | SORT_STRINGSORT,
                          Name->Buffer, Name->Length / sizeof(WCHAR),
                          LsapKnownPrivilageNames[i], -1))
        {
            *ResourceId = i;
            
            return STATUS_SUCCESS;
        }
    }

    return STATUS_NO_SUCH_PRIVILEGE;
}



NTSTATUS
LsapLookupPrivilegeDisplayName(
    IN PUNICODE_STRING ProgrammaticName,
    IN WORD ClientLanguage,
    IN WORD ClientSystemDefaultLanguage,
    OUT PUNICODE_STRING *DisplayName,
    OUT PWORD LanguageReturned
    )

/*++

Routine Description:

    This routine looks through each of the privilege DLLs for the
    specified privilege.  If found, its displayable name is returned.


Arguments:

    ProgrammaticName - The programmatic name of the privilege to look up.
        E.g., "SeTakeOwnershipPrivilege".

    ClientLanguage - The prefered language to be returned.

    ClientSystemDefaultLanguage - The alternate prefered language
        to be returned.

    DisplayName - receives a pointer to a buffer containing the displayable
        name associated with the privilege.
        E.g., "Take ownership of files or other objects".

        The UNICODE_STRING and the buffer pointed to by that structure
        are individually allocated using MIDL_user_allocate() and must
        be freed using MIDL_user_free().

    LanguageReturned - The language actually returned.


Return Value:

    STATUS_SUCCESS - The name have been successfully retrieved.

    STATUS_NO_MEMORY - Not enough heap was available to return the
        information.

    STATUS_NO_SUCH_PRIVILEGE - The privilege could not be located
        in any of the privilege DLLs.

--*/

{

    NTSTATUS    Status = STATUS_NO_SUCH_PRIVILEGE;
    ULONG       DllIndex, PrivilegeIndex;


    for ( DllIndex=0; DllIndex<LsapPrivilegeDllCount; DllIndex++) {

        Status = LsapGetPrivilegeDisplayNameResourceId(
            (PUNICODE_STRING)ProgrammaticName,
            DllIndex,
            &PrivilegeIndex
            );

        if (NT_SUCCESS(Status)) {

            Status = LsapGetPrivilegeDisplayName( DllIndex,
                                                  PrivilegeIndex,
                                                  ClientLanguage,
                                                  ClientSystemDefaultLanguage,
                                                  DisplayName,
                                                  LanguageReturned
                                                  );
            return(Status);
        }
    }

    return(Status);

}



NTSTATUS
LsapGetPrivilegeDisplayName(
    IN ULONG DllIndex,
    IN ULONG PrivilegeIndex,
    IN WORD ClientLanguage,
    IN WORD ClientSystemDefaultLanguage,
    OUT PUNICODE_STRING *DisplayName,
    OUT PWORD LanguageReturned
    )

/*++

Routine Description:

    This routine returns a copy of the specified privilege's display name.

    The copy of the name is returned in two buffers allocated using
    MIDL_user_allocate().  This allows the information to be returned
    via an RPC service so that RPC generated stubs will correctly free
    the buffers.

    Every attempt is made to retrieve a language that the client prefers
    (first the client, then the client's system).  Failing this, this
    routine may return another language (such as the server's default
    language).


Arguments:

    DllIndex - The index of the privilege DLL to use.

    PrivilegeIndex - The index of the privilege entry in the DLL whose
        display name is to be returned.

    ClientLanguage - The language to return if possible.

    ClientSystemDefaultLanguage - If ClientLanguage couldn't be found, then
        return this language if possible.

    DisplayName - receives a pointer to a buffer containing the displayable
        name associated with the privilege.

        The UNICODE_STRING and the buffer pointed to by that structure
        are individually allocated using MIDL_user_allocate() and must
        be freed using MIDL_user_free().

    LanguageReturned - Receives the language actually retrieved.
        If neither ClientLanguage nor ClientSystemDefaultLanguage could be
        found, then this value may contain yet another value.


Return Value:

    STATUS_SUCCESS - The display name has been successfully returned.

    STATUS_NO_MEMORY - Not enough heap was available to return the
        information.

--*/

{
    NTSTATUS Status=STATUS_NO_SUCH_PRIVILEGE;
    LCID SavedLocale, Locale;
    WCHAR String[MAX_PRIVILEGE_DISPLAY_NAME_CHARS+1];
    USHORT NumChars=0;
    WORD Languages[] =
    {
        ClientLanguage,
        MAKELANGID( PRIMARYLANGID(ClientLanguage), SUBLANG_NEUTRAL),
        ClientSystemDefaultLanguage,
        MAKELANGID( PRIMARYLANGID(ClientSystemDefaultLanguage), SUBLANG_NEUTRAL),
        LsapNeutralEnglish
    };
    UINT NumLanguages = sizeof(Languages) / sizeof(Languages[0]);
    UINT i;
    PUNICODE_STRING ReturnedName;
    
    SavedLocale = GetThreadLocale();

    __try
    {
        for (i = 0; i < NumLanguages; i++)
        {
            Locale = MAKELCID(Languages[i], SORT_DEFAULT);

            if (SetThreadLocale(Locale))
            {
                NumChars =
                (USHORT) LoadString(LsapPrivilegeDlls[ DllIndex ].DllHandle,
                                    PrivilegeIndex, // same as its resource ID
                                    String,
                                    MAX_PRIVILEGE_DISPLAY_NAME_CHARS);
                if (NumChars)
                {
                    if (ReturnedName = MIDL_user_allocate(sizeof(UNICODE_STRING)))
                    {
                        ReturnedName->MaximumLength =
                        ReturnedName->Length = NumChars * sizeof(WCHAR);
                        if (ReturnedName->Buffer =
                            MIDL_user_allocate((NumChars+1)*sizeof(WCHAR)))
                        {
                            RtlCopyMemory(ReturnedName->Buffer, String,
                                          (NumChars+1)*sizeof(WCHAR));
                            *LanguageReturned = Languages[i];
                            *DisplayName = ReturnedName;
                            Status = STATUS_SUCCESS;
                            break;
                        }
                        else
                        {
                            Status = STATUS_NO_MEMORY;
                            break;
                        }
                    }
                    else
                    {
                        Status = STATUS_NO_MEMORY;
                        break;
                    }
                }
            }
        }
    }

    __finally
    {
        SetThreadLocale(SavedLocale);
    }

    return(Status);
}




NTSTATUS
LsapDbInitializePrivilegeObject( VOID )

/*++

Routine Description:

    This function performs initialization functions related to
    the LSA privilege object.

    This includes:

            Initializing some variables.

            Loading DLLs containing displayable privilege names.



Arguments:

    None.

Return Value:

    STATUS_SUCCESS - The names have been successfully retrieved.

    STATUS_NO_MEMORY - Not enough memory was available to initialize.

--*/

{
    NTSTATUS
        Status,
        NtStatus;

    ULONG
        i;

    UNICODE_STRING Temp ;

    LsapNeutralEnglish = MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL);


    Status = LsapOpenPrivilegeDlls( );

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("\n");
        DbgPrint(" LSASS:  Failed loading privilege display name DLLs.\n");
        DbgPrint("         This is not fatal, but may cause some peculiarities\n");
        DbgPrint("         in User Interfaces that display privileges.\n\n");
#endif //DBG
        return(Status);
    }

    LsapWellKnownPrivilegeMaxLen = 0;
    
    //
    // Now set up our internal well-known privilege LUID to programmatic name
    // mapping.
    //
    
    for (i=0; i<LsapNumKnownPrivileges; i++)
    {
        LsapKnownPrivilege[i].LocalValue =
            RtlConvertLongToLuid(i + SE_MIN_WELL_KNOWN_PRIVILEGE);
        RtlInitUnicodeString(&LsapKnownPrivilege[i].Name,
                             LsapKnownPrivilageNames[i]);
        //
        // find the length of the longest well known privilege
        //
        if (LsapWellKnownPrivilegeMaxLen < LsapKnownPrivilege[i].Name.Length)
        {
            LsapWellKnownPrivilegeMaxLen = LsapKnownPrivilege[i].Name.Length;
        }
    }

    LsapWellKnownPrivilegeCount = i;
    ASSERT( i == (SE_MAX_WELL_KNOWN_PRIVILEGE - SE_MIN_WELL_KNOWN_PRIVILEGE +1));

    return(Status);
}


NTSTATUS
LsapOpenPrivilegeDlls( )

/*++

Routine Description:

    This function opens all the privilege DLLs that it can.


Arguments:

    None.

Return Value:

    STATUS_SUCCESS - The names have been successfully retrieved.

    STATUS_NO_MEMORY - Not enough heap was available to return the
        information.

--*/

{

    NTSTATUS Status;
    ULONG PotentialDlls, FoundDlls, i;
    PUNICODE_STRING DllNames;

    //
    // Get the names of the DLLs out of the registry
    //

    Status = LsapGetPrivilegeDllNames( &DllNames, &PotentialDlls );

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Allocate enough memory to hold handles to all potential DLLs.
    //


    LsapPrivilegeDlls = RtlAllocateHeap(
                            RtlProcessHeap(), 0,
                            PotentialDlls*sizeof(LSAP_DLL_DESCRIPTOR)
                            );
    if (LsapPrivilegeDlls == NULL) {
        return(STATUS_NO_MEMORY);
    }

    FoundDlls = 0;
    for ( i=0; i<PotentialDlls; i++) {
        Status = LdrLoadDll(
                     NULL,
                     NULL,
                     &DllNames[i],
                     &LsapPrivilegeDlls[FoundDlls].DllHandle
                     );

        if (NT_SUCCESS(Status)) {
            FoundDlls++;
        }
    }


    LsapPrivilegeDllCount = FoundDlls;

#if DBG
    if (FoundDlls == 0) {
        DbgPrint("\n");
        DbgPrint("LSASS:    Zero privilege DLLs loaded.  We expected at\n");
        DbgPrint("          least msprivs.dll to be loaded.  Privilege\n");
        DbgPrint("          names will not be displayed at UI properly.\n\n");

    }
#endif //DBG


    //
    //
    // !!!!!!!!!!!!!!!!!!!!!!    NOTE     !!!!!!!!!!!!!!!!!!!!!!!!
    //
    // Before supporting user loadable privilege DLLs, we must add
    // code here to validate the structure of the loaded DLL.  This
    // is necessary to prevent an invalid privilege DLL structure
    // from causing us to crash.
    //
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //

    //
    // This routine validates the structure of each loaded DLL.
    // Any found to be invalid will be logged and discarded.
    //

    //Status = LsapValidatePrivilegeDlls();


    return(Status);
}


NTSTATUS
LsapGetPrivilegeDllNames(
    OUT PUNICODE_STRING *DllNames,
    OUT PULONG DllCount
    )

/*++

Routine Description:

    This function obtains the names of DLLs containing privilege
    definitions from the registry.


Arguments:

    DllNames - Receives a pointer to an array of UNICODE_STRINGs
        This buffer must be freed using LsapFreePrivilegeDllNames.

    DllCount - Receives the number of DLL names returned.

Return Value:

    STATUS_SUCCESS - The names have been successfully retrieved.

    STATUS_NO_MEMORY - Not enough heap was available to return the
        information.

--*/

{
    //
    // For the time being, just hard-code our one, known privilege DLL
    // name as a return value.

    (*DllCount) = 1;

    MsDllName.Length = 14;
    MsDllName.MaximumLength = 14;
    MsDllName.Buffer = &MsDllNameString[0];

    (*DllNames) = &MsDllName;

    return(STATUS_SUCCESS);

}


NTSTATUS
LsapBuildPrivilegeAuditString(
    IN PPRIVILEGE_SET PrivilegeSet,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:


    This function builds a unicode string representing the specified
    privileges.  The privilege strings returned are program names.
    These are not as human-friendly as the display names, but I don't
    think we stand a chance of actually showing several display names
    in an audit viewer.

    if no privileges are present in the privilege set, then a string
    containing a dash is returned.


Arguments:

    PrivilegeSet - points to the privilege set to be converted to string
        format.

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of ResultantString
        must be freed to process heap when no longer needed.



Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status;

    USHORT   LengthNeeded;
    ULONG    j;
    ULONG    i;

    PLUID Privilege;

    UNICODE_STRING LineFormatting;
    UNICODE_STRING QuestionMark;

    UNICODE_STRING PrivName;

    PWSTR NextName;

    //
    // make sure that the max length has been calculated
    // (SE_INC_BASE_PRIORITY_NAME currently has the longest name
    //  therefore make sure that the length is at least that much)
    //
    DsysAssert(LsapWellKnownPrivilegeMaxLen >=
               (sizeof(SE_INC_BASE_PRIORITY_NAME) - sizeof(WCHAR)));

    if (PrivilegeSet->PrivilegeCount == 0) {

        //
        // No privileges.  Return a dash
        //
        Status = LsapAdtBuildDashString( ResultantString, FreeWhenDone );
        return(Status);

    }

    RtlInitUnicodeString( &LineFormatting, L"\r\n\t\t\t");
    RtlInitUnicodeString( &QuestionMark, L"?");

    //
    // for better performance, we calculate the total length required
    // to store privilege names based on the longest privilege,
    // instead of going over the privilege-set twice (once to calcualte
    // length and one more time to actually build the string)
    //
    LengthNeeded = (USHORT) (PrivilegeSet->PrivilegeCount *
        ( LsapWellKnownPrivilegeMaxLen + LineFormatting.Length ));

    //
    // Subtract off the length of the last line-formatting.
    // It isn't needed for the last line.
    // BUT! Add in enough for a null termination.
    //
    LengthNeeded = LengthNeeded - LineFormatting.Length + sizeof( WCHAR );


    //
    // We now have the length we need.
    // Allocate the buffer and go through the list copying names.
    //
    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, (ULONG)LengthNeeded);
    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }

    //ResultantString->Length = LengthNeeded - (USHORT)sizeof(UNICODE_NULL);
    ResultantString->MaximumLength = LengthNeeded;


    NextName = ResultantString->Buffer;

    for (j=0; j<PrivilegeSet->PrivilegeCount; j++) {

        Privilege = &(PrivilegeSet->Privilege[j].Luid);

        Status = LsapLookupKnownPrivilegeNameQuickly( Privilege, &PrivName );

        if (Status == STATUS_SUCCESS) {
            
            //
            // Copy the privilege name if lookup succedded
            //
            RtlCopyMemory( NextName, PrivName.Buffer, PrivName.Length );
            NextName = (PWSTR)((PCHAR)NextName + PrivName.Length);
            
        } else {

            //
            // else copy a '?'
            //
            RtlCopyMemory( NextName, QuestionMark.Buffer, QuestionMark.Length );
            NextName = (PWSTR)((PCHAR)NextName + QuestionMark.Length);
        }
        
        //
        // Copy the line formatting string, unless this is the last priv.
        //
        if (j<PrivilegeSet->PrivilegeCount-1) {
            RtlCopyMemory( NextName,
                           LineFormatting.Buffer,
                           LineFormatting.Length
                           );
            NextName = (PWSTR)((PCHAR)NextName + LineFormatting.Length);
        }
    }

    //
    // Add a null to the end
    //

    (*NextName) = (UNICODE_NULL);
    ResultantString->Length = (USHORT) (((PBYTE) NextName) - ((PBYTE) ResultantString->Buffer));

    DsysAssertMsg( ResultantString->Length <= ResultantString->MaximumLength,
                   "LsapBuildPrivilegeAuditString" );
     

    (*FreeWhenDone) = TRUE;
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dslayer.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dslayer.c

Abstract:

    Implemntation of  LSA/Ds interface and support routines

Author:

    Mac McLain          (MacM)       Jan 17, 1997

Environment:

    User Mode

Revision History:

--*/

#include <lsapch2.h>
#include <dbp.h>
#include <md5.h>

NTSTATUS
LsapDsInitAllocAsNeededEx(
    IN ULONG Options,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    OUT PBOOLEAN Reset
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    LsapEnterFunc( "LsapDsInitAllocAsNeededEx" );

    *Reset = FALSE;

    //
    // Grab the lock
    //
    if ( !FLAG_ON( Options, LSAP_DB_NO_LOCK ) ) {

        LsapDbAcquireLockEx( ObjectTypeId,
                             Options );
    }

    //
    // If the LSA has no thread state yet, OR
    //  We aren't using Sam's transaction and
    //  the LSA hasn't yet opened one,
    // do so now.
    //

    Status = ( *LsaDsStateInfo.DsFuncTable.pOpenTransaction ) ( Options );

    if ( NT_SUCCESS( Status ) ) {

        *Reset = TRUE;

    } else {

        if ( !FLAG_ON( Options, LSAP_DB_NO_LOCK ) ) {

            LsapDbReleaseLockEx( ObjectTypeId,
                                 Options );
        }
    }

    LsapDsDebugOut(( DEB_FTRACE, "Leaving LsapDsInitAllocAsNeededEx ( %lu ): 0x%lx\n",
                     *Reset, Status ));

    return( Status );
}


VOID
LsapDsDeleteAllocAsNeededEx(
    IN ULONG Options,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN BOOLEAN Reset
    )
{
   LsapDsDeleteAllocAsNeededEx2(
             Options,
             ObjectTypeId,
             Reset,
             FALSE // Rollback Transaction
             );
}

VOID
LsapDsDeleteAllocAsNeededEx2(
    IN ULONG Options,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN BOOLEAN Reset,
    IN BOOLEAN RollbackTransaction
    )
{
    LsapDsDebugOut(( DEB_FTRACE, "Entering LsapDsDeleteAllocAsNeededEx ( %lu )\n", Reset ));

    if ( Reset ) {

        if (RollbackTransaction)
        {
          ( *LsaDsStateInfo.DsFuncTable.pAbortTransaction )( Options );
        }
        else
        {

          ( *LsaDsStateInfo.DsFuncTable.pApplyTransaction )( Options );
        }
    }

    //
    // Release the lock if we had opened one
    //
    if ( !FLAG_ON( Options, LSAP_DB_NO_LOCK ) ) {

        LsapDbReleaseLockEx( ObjectTypeId,
                             Options );
    }

    LsapDsDebugOut(( DEB_FTRACE, "LsapDsDeleteAllocAsNeededEx: 0\n" ));
}


NTSTATUS
LsapDsReadObjectSD(
    IN  LSAPR_HANDLE            ObjectHandle,
    OUT PSECURITY_DESCRIPTOR   *ppSD
    )
/*++

Routine Description:

    This function will ready the security descriptor from the specified object

Arguments:

    ObjectHandle - Object to read the SD from
    ppSD -- Where the allocated security descriptor is returned.  Allocated via
            LsapAllocateLsaHeap.

Return Value:

    Pointer to allocated memory on success or NULL on failure

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_ATTRIBUTE Attribute;
    BOOLEAN ReleaseState;
    LSAP_DB_HANDLE InternalHandle = ( LSAP_DB_HANDLE )ObjectHandle;

    LsapEnterFunc( "LsapDsReadObjectSD" );

    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                            LSAP_DB_DS_OP_TRANSACTION,
                                        InternalHandle->ObjectTypeId,
                                        &ReleaseState );

    if ( !NT_SUCCESS( Status ) ) {

        LsapExitFunc( "LsapDsReadObjectSD", Status );
        return( Status );
    }

    //
    // Make sure we're coming in as DSA, so the access check that the DS does won't fail
    //
    LsapDsSetDsaFlags( TRUE );


    LsapDbInitializeAttributeDs( &Attribute,
                                 SecDesc,
                                 NULL,
                                 0,
                                 FALSE );

    Status = LsapDsReadAttributes(
                 (PUNICODE_STRING)&((LSAP_DB_HANDLE ) ObjectHandle)->PhysicalNameDs,
                 LSAPDS_OP_NO_LOCK,
                 &Attribute,
                 1 );

    if ( Status == STATUS_SUCCESS ) {

        *ppSD = LsapAllocateLsaHeap( Attribute.AttributeValueLength );

        if ( *ppSD == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            RtlCopyMemory( *ppSD, Attribute.AttributeValue, Attribute.AttributeValueLength );
        }


        MIDL_user_free( Attribute.AttributeValue );

    } else {

        *ppSD = NULL;

    }

    LsapDsDeleteAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                     LSAP_DB_DS_OP_TRANSACTION,
                                 InternalHandle->ObjectTypeId,
                                 ReleaseState );

    LsapExitFunc( "LsapDsReadObjectSD", Status );
    return( Status );
}


NTSTATUS
LsapDsTruncateNameToFitCN(
    IN PUNICODE_STRING OriginalName,
    OUT PUNICODE_STRING TruncatedName
    )
/*++

    Routine Description

     This routine truncates the name to fix the 64 Char CN limit. The truncation
     algorithm uses an MD5 Hash to compute the last 16 chars, the first 47
     chars are left as they are. The 48'th char is a -. If the name is smaller
     than the same limit the original name is returned as is copied into a
     new buffer.

    Parameters

     OriginalName -- The original Name
     TruncatedName -- The name truncated if required

    Return Values

      STATUS_SUCCESS
      Other error codes that return a resource failure
--*/
{
    MD5_CTX            Md5Context;
    ULONG              i;
    #define            MAX_CN_SIZE 64
    #define TO_HEX(x)  (((x)<0xA)?(L'0'+(x)):(L'A'+(x)-0xA))

    //
    // Allocate memory to hold the new name
    //

    TruncatedName->Buffer = LsapAllocateLsaHeap(OriginalName->Length);
    if (NULL==TruncatedName->Buffer)
    {
         return(STATUS_INSUFFICIENT_RESOURCES);
    }

    if (OriginalName->Length<=MAX_CN_SIZE*sizeof(WCHAR))
    {
         //
         // Original Name fits in CN, just copy and return it
         //

         RtlCopyMemory(
             TruncatedName->Buffer,
             OriginalName->Buffer,
             OriginalName->Length
             );

         TruncatedName->Length = TruncatedName->MaximumLength = OriginalName->Length;

         return (STATUS_SUCCESS);
    }

    //
    // Name does not fit in, invent a unique suffix. This is done by
    // computing a MD5 checksum of the original name and
    // replacing the last 16 chars by hexprinted version of the lower
    // nibbles of the hash
    //

    MD5Init(&Md5Context);

    MD5Update(
         &Md5Context,
         (PUCHAR) OriginalName->Buffer,
         OriginalName->Length
         );

    MD5Final(&Md5Context);

    //
    // The new name is the first 46 chars of the original name followed
    // by a - and the checksum hex printed out behind. Only the low nibble
    // of each byte is used so that only 16 chars of space is taken up
    //

    RtlCopyMemory(
         TruncatedName->Buffer,
         OriginalName->Buffer,
         OriginalName->Length
         );

    TruncatedName->Buffer[MAX_CN_SIZE-MD5DIGESTLEN-2] = L'-';

    for (i=0;i<MD5DIGESTLEN;i++)
    {

        TruncatedName->Buffer[MAX_CN_SIZE-MD5DIGESTLEN+i-1] = TO_HEX((0xf & Md5Context.digest[i]));
    }

    TruncatedName->Length = TruncatedName->MaximumLength = MAX_CN_SIZE * sizeof(WCHAR);


    return STATUS_SUCCESS;
}



NTSTATUS
LsapDsGetPhysicalObjectName(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN BOOLEAN ObjectShouldExist,
    IN PUNICODE_STRING  LogicalNameU,
    OUT OPTIONAL PUNICODE_STRING PhysicalNameU
    )

/*++

Routine Description:

    This function returns the Physical Name of an object
    given an object information buffer.  Memory will be allocated for
    the Unicode String Buffers that will receive the name(s).


    The Physical Name of an object is the full path of the object relative
    to the root ot the Database.  It is computed by concatenating the Physical
    Name of the Container Object (if any), the Classifying Directory
    corresponding to the object type id, and the Logical Name of the
    object.

    <Physical Name of Object> =
        [<Physical Name of Container Object> "\"]
        [<Classifying Directory> "\"] <Logical Name of Object>

    If there is no Container Object (as in the case of the Policy object)
    the <Physical Name of Container Object> and following \ are omitted.
    If there is no Classifying Directory (as in the case of the Policy object)
    the <Classifying Directory> and following \ are omitted.  If neither
    Container Object not Classifying Directory exist, the Logical and Physical
    names coincide.

    Note that memory is allocated by this routine for the output
    Unicode string buffer(s).  When the output Unicode String(s) are no
    longer needed, the memory must be freed by call(s) to
    RtlFreeUnicodeString().


Arguments:

    ObjectInformation - Pointer to object information containing as a minimum
        the object's Logical Name, Container Object's handle and object type
        id.

    DefaultName - If TRUE, use the default name for the object

    LogicalNameU - Optional pointer to Unicode String structure which will
        receive the Logical Name of the object.  A buffer will be allocated
        by this routine for the name text.  This memory must be freed when no
        longer needed by calling RtlFreeUnicodeString() wiht a pointer such
        as LogicalNameU to the Unicode String structure.

    PhysicalNameU - Optional pointer to Unicode String structure which will
       receive the Physical Name of the object.  A buffer will be allocated by
       this routine for the name text.  This memory must be freed when no
       longer needed by calling RtlFreeUnicodeString() with a pointer such as
       PhysicalNameU to the Unicode String structure.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources to
            allocate the name string buffer for the Physical Name or
            Logical Name.

        STATUS_OBJECT_NAME_INVALID - Failed to produce the proper name
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId = ObjectInformation->ObjectTypeId;
    POBJECT_ATTRIBUTES ObjectAttributes = &ObjectInformation->ObjectAttributes;
    PDSNAME Root = NULL, NewDsName = NULL;
    PWSTR Name, LogicalName;
    PBYTE Buffer = NULL;
    UNICODE_STRING ObjectName, *Object=NULL;
    ULONG Length = 0, InitialLength;
    USHORT Len = 0, NameLen;
    BOOLEAN NameSet = FALSE;
    UNICODE_STRING TruncatedName;

    LsapEnterFunc( "LsapDsGetPhysicalObjectName" );

    RtlZeroMemory( &ObjectName, sizeof( UNICODE_STRING ) );
    RtlZeroMemory( &TruncatedName, sizeof( UNICODE_STRING ) );

    //
    // The stages go as follows:
    // Root DS domain path, obtained from LsaDsStateInfo
    // Any container path specific to the object type for trusted domain/secret objects
    //     - or -
    // the domain policy path or local policy path if it's a local or domain policy object
    //

    switch ( ObjectTypeId ) {

    case TrustedDomainObject:

        Root = LsaDsStateInfo.DsSystemContainer;
        Object = LogicalNameU;

        if ( ObjectShouldExist ) {

            //
            // Get the name of the object by searching for it
            //
            Status = LsapDsTrustedDomainObjectNameForDomain( Object,
                                                             FALSE,
                                                             &NewDsName );

            if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

                Status = LsapDsTrustedDomainObjectNameForDomain( Object,
                                                                 TRUE,
                                                                 &NewDsName );

            }

            if ( NT_SUCCESS( Status ) ) {

                NameSet = TRUE;
            }
        }
        break;

    case NewTrustedDomainObject:
        Root = LsaDsStateInfo.DsSystemContainer;
        Object = LogicalNameU;
        break;

    case SecretObject:
        Root = LsaDsStateInfo.DsSystemContainer;

        Buffer = LsapAllocateLsaHeap( LogicalNameU->Length + sizeof( LSAP_DS_SECRET_POSTFIX ) -
                                      sizeof(LSA_GLOBAL_SECRET_PREFIX) + sizeof( WCHAR ) );
        if ( Buffer == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            Name = (PWSTR)LogicalNameU->Buffer + LSA_GLOBAL_SECRET_PREFIX_LENGTH;
            NameLen = LogicalNameU->Length - (LSA_GLOBAL_SECRET_PREFIX_LENGTH * sizeof(WCHAR));

            RtlCopyMemory( Buffer,
                           Name,
                           NameLen );

            if ( !ObjectInformation->ObjectAttributeNameOnly ) {

                RtlCopyMemory( Buffer + NameLen,
                               LSAP_DS_SECRET_POSTFIX,
                               sizeof( LSAP_DS_SECRET_POSTFIX ) );
            }

            RtlInitUnicodeString( &ObjectName, (PWSTR)Buffer );
            Object = &ObjectName;

        }
        break;


    default:
        Status = STATUS_INVALID_PARAMETER;
        break;

    }

    //
    // Build the physical name
    //
    if ( NT_SUCCESS ( Status ) ) {

        if ( !NameSet ) {


            //
            // Truncate the name if necessary to fit the common name
            // attribute in the schema
            //

            Status = LsapDsTruncateNameToFitCN(
                         Object,
                         &TruncatedName
                         );

            if (!NT_SUCCESS(Status))
            {
                goto Error;
            }

            //
            // Allocate a default buffer to use...
            //
            InitialLength = LsapDsLengthAppendRdnLength( Root,
                                                         Object->Length + 4 * sizeof( WCHAR ) );
            NewDsName = LsapAllocateLsaHeap( InitialLength );

            if ( NewDsName == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                Length = AppendRDN( Root,
                                    NewDsName,
                                    InitialLength,
                                    TruncatedName.Buffer,
                                    LsapDsGetUnicodeStringLenNoNull( &TruncatedName ) / sizeof( WCHAR ),
                                    ATT_COMMON_NAME );

                if ( Length > InitialLength ) {

                    LsapFreeLsaHeap( NewDsName );
                    NewDsName = LsapAllocateLsaHeap( Length );

                    if ( NewDsName == NULL ) {

                        Status = STATUS_INSUFFICIENT_RESOURCES;

                    } else {

#if DBG
                        InitialLength = Length;
#endif
                        Length = AppendRDN( Root,
                                            NewDsName,
                                            InitialLength,
                                            TruncatedName.Buffer,
                                            LsapDsGetUnicodeStringLenNoNull( &TruncatedName ) /
                                                                                  sizeof( WCHAR ),
                                            ATT_COMMON_NAME );

                        if ( Length != 0 ) {

                            Status = STATUS_OBJECT_NAME_INVALID;

#if DBG
                            LsapDsDebugOut(( DEB_ERROR,
                                             "Failed to build physical name for %wZ.  We "
                                             "allocated %lu but needed %lu\n",
                                             Object,
                                             InitialLength,
                                             Length ));
#endif

                        }
                    }
                }
            }

            //
            // If we are creating a trusted domain name, make sure that the name isn't alread
            // in use
            //
            if ( NT_SUCCESS( Status ) && ( ObjectTypeId == NewTrustedDomainObject ||
                     ( ObjectTypeId == TrustedDomainObject && ObjectShouldExist == FALSE ) ) ) {


                Status = LsapDsVerifyObjectExistenceByDsName( NewDsName );

                if ( Status == STATUS_SUCCESS ) {

                    Status = STATUS_OBJECT_NAME_COLLISION;

                } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

                    Status = STATUS_SUCCESS;
                }
            }

        }

        //
        // Now, we copy off the newly allocated dsname string, and return that
        //
        if ( NT_SUCCESS( Status ) ) {

            Length = ( LsapDsNameLenFromDsName( NewDsName ) *
                                                sizeof( WCHAR ) ) + sizeof( WCHAR );

            PhysicalNameU->Buffer = LsapAllocateLsaHeap( Length  );

            if ( PhysicalNameU->Buffer == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                RtlCopyMemory( PhysicalNameU->Buffer,
                               LsapDsNameFromDsName( NewDsName ),
                               Length );

                RtlInitUnicodeString( PhysicalNameU,
                                      PhysicalNameU->Buffer );

            }
        }
    }

Error:

    if ( ObjectTypeId == SecretObject ) {

        LsapFreeLsaHeap( Buffer );
    }

    if ( NewDsName != NULL ) {

        LsapFreeLsaHeap( NewDsName );
    }

    if ( TruncatedName.Buffer != NULL ) {

        LsapFreeLsaHeap( TruncatedName.Buffer );
    }

    LsapExitFunc( "LsapDsGetPhysicalObjectName", Status );

    return Status;
}


NTSTATUS
LsapDsOpenObject(
    IN LSAP_DB_HANDLE  ObjectHandle,
    IN ULONG  OpenMode,
    OUT PVOID  *pvKey
    )
/*++

Routine Description:

    Opens the object in the DS

Arguments:

    ObjectHandle - Internal LSA object handle

    OpenMode - How to open the object

    pvKey - Where the key is returned

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTR     NameAttr;
    ATTRVAL  NameVal;
    ATTRBLOCK   NameBlock, ReturnBlock;
    PDSNAME  SearchName = NULL;
    BOOLEAN  ReleaseState = FALSE;
    LSAP_DB_HANDLE InternalHandle = ( LSAP_DB_HANDLE )ObjectHandle;
    BOOLEAN  InitAllocSucceded = FALSE;
    ULONG ObjClass;

    LsapEnterFunc( "LsapDsOpenObject" );

    //
    // Ensure the handle is for one of the objects supported in the DS.
    //

    switch ( InternalHandle->ObjectTypeId ) {
    case TrustedDomainObject:

        ObjClass = CLASS_TRUSTED_DOMAIN;
        break;

    case SecretObject:

        ObjClass = CLASS_SECRET;
        break;

    default:

        ASSERT( FALSE );
        return STATUS_INVALID_PARAMETER;
    }


    //
    // Start a transaction.
    //
    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                            LSAP_DB_DS_OP_TRANSACTION,
                                        InternalHandle->ObjectTypeId,
                                        &ReleaseState );

    if ( NT_SUCCESS( Status ) ) {

        InitAllocSucceded = TRUE;

        Status = LsapAllocAndInitializeDsNameFromUnicode(
                     LsapDsObjUnknown,
                     (PLSA_UNICODE_STRING)&ObjectHandle->PhysicalNameDs,
                     &SearchName );

    }

    if ( NT_SUCCESS( Status ) ) {

        //
        // Check for the existence of the object
        //
        NameAttr.attrTyp          = ATT_OBJECT_CLASS;
        NameAttr.AttrVal.valCount = 1;
        NameAttr.AttrVal.pAVal    = &NameVal;


        NameVal.valLen = SearchName->structLen;
        NameVal.pVal   = (PBYTE)SearchName;

        NameBlock.attrCount = 1;
        NameBlock.pAttr = &NameAttr;

        Status = LsapDsRead( &ObjectHandle->PhysicalNameDs,
                             LSAPDS_READ_NO_LOCK,
                             &NameBlock,
                             &ReturnBlock);

        if ( NT_SUCCESS( Status ) ) {
            ULONG ReadVal;

            ReadVal = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( ReturnBlock.pAttr );

            if ( ReadVal != ObjClass ) {
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
            }
        }


    }

    if (InitAllocSucceded)
    {
        LsapDsDeleteAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                         LSAP_DB_DS_OP_TRANSACTION,
                                     InternalHandle->ObjectTypeId,
                                     ReleaseState );
    }

    LsapExitFunc( "LsapDsOpenObject", Status );
    return( Status );
}



NTSTATUS
LsapDsVerifyObjectExistenceByDsName(
    IN PDSNAME DsName
    )
/*++

Routine Description:

    Verifies if an object exists in the DS by opening it

Arguments:

    DsName - pointer to an object's DS name

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTR     NameAttr;
    ATTRVAL  NameVal;
    ATTRBLOCK   NameBlock, ReturnBlock;
    BOOLEAN  ReleaseState = FALSE;

    LsapEnterFunc( "LsapDsOpenObjectByDsName" );

    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                        NullObject,
                                        &ReleaseState );

    if ( NT_SUCCESS( Status ) ) {

        //
        // Check for the existence of the object
        //
        NameAttr.attrTyp          = ATT_OBJECT_CLASS;
        NameAttr.AttrVal.valCount = 1;
        NameAttr.AttrVal.pAVal    = &NameVal;

        NameVal.valLen = 0;
        NameVal.pVal   = NULL;

        NameBlock.attrCount = 1;
        NameBlock.pAttr = &NameAttr;

        Status = LsapDsReadByDsName( DsName,
                                     LSAPDS_READ_NO_LOCK,
                                     &NameBlock,
                                     &ReturnBlock);

    }

    LsapDsDeleteAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                 NullObject,
                                 ReleaseState );

    LsapExitFunc( "LsapDsOpenObjectByDsName", Status );
    return( Status );
}


NTSTATUS
LsapDsOpenTransaction(
    IN ULONG Options
    )
/*++

Routine Description:

    This function starts a transaction within the Ds.

Arguments:

    Options - Options to use when opening the transaction.  Valid values are:


Return Value:

    NTSTATUS - Standard Nt Result Code

        Result codes are those returned from the Registry Transaction
        Package.
--*/

{
    NTSTATUS Status;
    PLSADS_PER_THREAD_INFO CurrentThreadInfo;

    LsapEnterFunc( "LsapDsOpenTransaction" );

    //
    // If this operation doesn't do a DS transaction,
    //  we're done.
    //

    if ( Options & LSAP_DB_NO_DS_OP_TRANSACTION ) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }



    //
    // Get an LSA thread state.
    //
    CurrentThreadInfo = LsapCreateThreadInfo();

    if ( CurrentThreadInfo == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    //
    // If we don't already have a valid thread state, create one
    //
    if ( CurrentThreadInfo->DsThreadStateUseCount == 0 ) {

        CurrentThreadInfo->InitialThreadState = THSave();
        Status = LsapDsMapDsReturnToStatus( THCreate( CALLERTYPE_LSA ) );

        if ( !NT_SUCCESS( Status ) ) {
            THRestore( CurrentThreadInfo->InitialThreadState );
            CurrentThreadInfo->InitialThreadState = NULL;

            LsapClearThreadInfo();
            goto Cleanup;
        }
    }
    CurrentThreadInfo->DsThreadStateUseCount ++;


    //
    // If we ever want to not really start a transaction here,
    //  we have to ensure the same flag is passed to apply/abort and look
    //  at the flag there.
    // if ( !FLAG_ON( Options, LSAP_DB_DS_OP_TRANSACTION ) ) {

        if ( CurrentThreadInfo->DsTransUseCount == 0 ) {

            if ( SampExistsDsTransaction() ) {

                ASSERT( !SampExistsDsTransaction() );
                DirTransactControl( TRANSACT_DONT_BEGIN_DONT_END );
                CurrentThreadInfo->DsOperationCount++;

            } else {

                DirTransactControl( TRANSACT_BEGIN_DONT_END );
            }

            LsapDsDebugOut(( DEB_TRACE,
                            "DirTransactControl( TRANSACT_BEGIN_DONT_END ) in "
                            "LsapDsOpenTransaction\n" ));
        }
        CurrentThreadInfo->DsTransUseCount++;
    // }

    LsapDsSetDsaFlags( TRUE );

    Status = STATUS_SUCCESS;

Cleanup:
    LsapExitFunc( "LsapDsOpenTransaction", Status );

    return( Status );
}


NTSTATUS
LsapDsOpenTransactionDummy(
    IN ULONG Options
    )
{
    return( STATUS_SUCCESS );
}

NTSTATUS
LsapDsApplyTransaction(
    IN ULONG Options
    )

/*++

Routine Description:

    This function applies a transaction within the LSA Database.

Arguments:

    Options - Specifies optional actions to be taken.  The following
        options are recognized, other options relevant to calling routines
        are ignored.

        LSAP_DB_NO_DS_OP_TRANSACTION - Nothing to do, get out

Return Value:

    NTSTATUS - Standard Nt Result Code

        Result codes are those returned from the Registry Transaction
        Package.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS, Status2;
    PLSADS_PER_THREAD_INFO CurrentThreadInfo;

    LsapEnterFunc( "LsapDsApplyTransaction" );

    //
    // If this operation doesn't do a DS transaction,
    //  we're done.
    //

    if ( Options & LSAP_DB_NO_DS_OP_TRANSACTION ) {
        LsapExitFunc( "LsapDsApplyTransaction", 0 );
        return( STATUS_SUCCESS );
    }

    CurrentThreadInfo = LsapQueryThreadInfo();

    //
    // No thread info, no transaction
    //
    if ( CurrentThreadInfo == NULL ) {

        LsapExitFunc( "LsapDsApplyTransaction", 0 );
        return( STATUS_SUCCESS );
    }




    //
    // If we're doing a transaction,
    //  decrement our count of embedded transactions.
    //
    if ( CurrentThreadInfo->DsTransUseCount > 0 ) {
        CurrentThreadInfo->DsTransUseCount--;


        //
        // If this is our last transaction,
        //  commit it.
        //

        if ( CurrentThreadInfo->DsTransUseCount == 0 ) {

            if ( CurrentThreadInfo->DsOperationCount == 0 ) {

                //
                // The only way we should get here is if we inadvertently marked a current
                // "transaction" as active when it has never been used.  As such, we can
                // simply reset the flag.
                //
                if ( !SampExistsDsTransaction() ) {

                    DirTransactControl( TRANSACT_BEGIN_END );

                } else {

                    ASSERT( SampExistsDsTransaction() );
                    CurrentThreadInfo->DsOperationCount = 1;
                }

            }

            //
            // If operations have been made to the DS,
            //  commit them now.
            //
            if ( CurrentThreadInfo->DsOperationCount > 0 ) {

                Status = LsapDsCauseTransactionToCommitOrAbort( TRUE );
                CurrentThreadInfo->DsOperationCount = 0;

            }

        }
    }

    //
    // If we have a DS thread state,
    //  decrement our count of uses of that thread state.
    //

    if ( CurrentThreadInfo->DsThreadStateUseCount > 0 ) {
        CurrentThreadInfo->DsThreadStateUseCount --;

        //
        // If we're now done with our DS thread state,
        //  destroy it.
        //
        if ( CurrentThreadInfo->DsThreadStateUseCount == 0 ) {

            Status2 = LsapDsMapDsReturnToStatus( THDestroy( ) );

            THRestore( CurrentThreadInfo->InitialThreadState );
            CurrentThreadInfo->InitialThreadState = NULL;

            ASSERT( NT_SUCCESS( Status2 ) );

            if ( NT_SUCCESS( Status ) ) {
                Status = Status2;
            }

        }
    }

    LsapClearThreadInfo();


    LsapExitFunc( "LsapDsApplyTransaction", Status );

    return( Status );
}

NTSTATUS
LsapDsApplyTransactionDummy(
    IN ULONG Options
    )
{

    return( STATUS_SUCCESS );
}

NTSTATUS
LsapDsAbortTransaction(
    IN ULONG Options
    )
/*++

Routine Description:

    This function aborts a transaction within the LSA Database.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

Arguments:

    Options - Options to use for aborting the transaction

Return Value:

    NTSTATUS - Standard Nt Result Code

        Result codes are those returned from the Registry Transaction
        Package.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS, Status2;
    PLSADS_PER_THREAD_INFO CurrentThreadInfo;

    LsapEnterFunc( "LsapDsAbortTransaction" );

    //
    // If this operation doesn't do a DS transaction,
    //  we're done.
    //

    if ( Options & LSAP_DB_NO_DS_OP_TRANSACTION ) {
        LsapExitFunc( "LsapDsAbortTransaction", 0 );
        return( STATUS_SUCCESS );
    }

    //
    // No thread info, no transaction
    //
    CurrentThreadInfo = LsapQueryThreadInfo();

    if ( CurrentThreadInfo == NULL ) {

        LsapExitFunc( "LsapDsAbortTransaction", 0 );
        return( STATUS_SUCCESS );
    }


    //
    // If we're doing a transaction,
    //  decrement our count of embedded transactions.
    //

    if ( CurrentThreadInfo->DsTransUseCount > 0 ) {
        CurrentThreadInfo->DsTransUseCount--;

        //
        // If this is our last transaction,
        //  abort it.
        //
        if ( CurrentThreadInfo->DsTransUseCount == 0 ) {

            if ( CurrentThreadInfo->DsOperationCount > 0 ) {

                //
                // Since LsapDsCauseTransactionToCommitOrAbort will return an error
                // if it successfully aborts a transaction, we throw the error code away
               // We don't need to do anything with the transactions other than to ensure that
               // they fail.  We'll ensure this by issuing a bad dir call.
                //
                LsapDsCauseTransactionToCommitOrAbort( FALSE );


            } else {

                //
                // We opened the transaction, but we never used it... Make sure to indicate
                // that we don't have one
                //
                ASSERT(!SampExistsDsTransaction());
                DirTransactControl( TRANSACT_BEGIN_END );
            }

            CurrentThreadInfo->DsOperationCount = 0;

        }
    }

    //
    // If we have a DS thread state,
    //  decrement our count of uses of that thread state.
    //

    if ( CurrentThreadInfo->DsThreadStateUseCount > 0 ) {
        CurrentThreadInfo->DsThreadStateUseCount --;

        //
        // If we're now done with our DS thread state,
        //  destroy it.
        //
        if ( CurrentThreadInfo->DsThreadStateUseCount == 0 ) {

            Status2 = LsapDsMapDsReturnToStatus( THDestroy( ) );

            THRestore( CurrentThreadInfo->InitialThreadState );
            CurrentThreadInfo->InitialThreadState = NULL;

            ASSERT( NT_SUCCESS( Status2 ) );

            if ( NT_SUCCESS( Status ) ) {
                Status = Status2;
            }

        }
    }

    LsapClearThreadInfo();



    LsapExitFunc( "LsapDsAbortTransaction", Status );
    return( Status );
}


NTSTATUS
LsapDsAbortTransactionDummy(
    IN ULONG Options
    )
{

    return( STATUS_SUCCESS );
}



NTSTATUS
LsapDsCreateObject(
    IN PUNICODE_STRING  ObjectPath,
    IN ULONG Flags,
    IN LSAP_DB_OBJECT_TYPE_ID   ObjectType
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       Value = 0;
    ULONG       Items = 1;
    PBYTE       NulLVal = NULL;

    ATTRTYP     AttrType[LSADSP_MAX_ATTRS_ON_CREATE] = {

        ATT_OBJECT_CLASS,
        0,
        0

    };

    ULONG ObjClass;

    ATTRVAL     Values[LSADSP_MAX_ATTRS_ON_CREATE] = {
            {sizeof(ULONG),     (PUCHAR)&ObjClass},
            {sizeof(ULONG),     (PUCHAR)&Value},
            {sizeof(ULONG),     (PUCHAR)&Value}
    };

    switch ( ObjectType ) {
    case TrustedDomainObject:

        ObjClass = CLASS_TRUSTED_DOMAIN;
        break;

    case SecretObject:

        ObjClass = CLASS_SECRET;
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if ( !NT_SUCCESS( Status ) ) {

        LsapExitFunc( "LsapDsCreateObject", Status );
        return( Status );
    }


    if ( NT_SUCCESS( Status ) ) {

        Status = LsapDsCreateAndSetObject( LsapDsObjTrustedDomain,
                                           ObjectPath,
                                           Flags,
                                           Items,
                                           AttrType,
                                           Values );
    }


    LsapExitFunc( "LsapDsCreateObject", Status );
    return( Status );
}



NTSTATUS
LsapDsDeleteObject(
    IN PUNICODE_STRING  ObjectPath
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDSNAME  DsName;
    BOOLEAN ReleaseState;

    LsapEnterFunc( "LsapDsDeleteObject" );


    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                        NullObject,
                                        &ReleaseState );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsapAllocAndInitializeDsNameFromUnicode(
                     LsapDsObjUnknown,
                     ObjectPath,
                     &DsName
                     );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsapDsRemove( DsName );

            THFree( DsName );
        }

        LsapDsDeleteAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                     NullObject,
                                     ReleaseState );
    }

    LsapExitFunc( "LsapDsDeleteObject", Status );
    return( Status );
}



NTSTATUS
LsapDsWriteAttributesByDsName(
    IN PDSNAME  ObjectPath,
    IN PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount,
    IN ULONG Options
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRBLOCK   AttrBlock;
    PATTR       Attrs;
    ULONG       i, AttrBlockIndex = 0;

    LsapEnterFunc( "LsapDsWriteAttributesByDsName" );

    LsapDsSetDsaFlags( TRUE );

    //
    // Ok, first, build the list of Ds attributes
    //
    Attrs = LsapDsAlloc( sizeof( ATTR ) * AttributeCount );

    if ( Attrs == NULL ) {

        Status = STATUS_NO_MEMORY;

    } else {

        for ( i = 0 ; i < AttributeCount && NT_SUCCESS( Status ); i++ ) {

            if ( !Attributes[ i ].PseudoAttribute ) {

                Status = LsapDsLsaAttributeToDsAttribute( &Attributes[ i ],
                                                          &Attrs[ AttrBlockIndex++ ] );
            }
        }

        if ( NT_SUCCESS( Status ) ) {

            AttrBlock.attrCount = AttrBlockIndex;
            AttrBlock.pAttr = Attrs;

            //
            // Now, simply write it out
            //
            Status = LsapDsWriteByDsName( ObjectPath,
                                          LSAPDS_REPLACE_ATTRIBUTE | Options,
                                          &AttrBlock );

        }
    }



    LsapExitFunc( "LsapDsWriteAttributesByDsName", Status );
    return( Status );
}


NTSTATUS
LsapDsWriteAttributes(
    IN PUNICODE_STRING  ObjectPath,
    IN PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount,
    IN ULONG Options
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDSNAME     DsName = NULL;
    BOOLEAN     ReleaseState;

    LsapEnterFunc( "LsapDsWriteAttributes" );

    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                        NullObject,
                                        &ReleaseState );

    if ( !NT_SUCCESS( Status ) ) {

        LsapExitFunc( "LsapDsWriteAttributes", Status );
        return( Status );
    }

    //
    // Build the DSName
    //
    Status = LsapAllocAndInitializeDsNameFromUnicode( LsapDsObjUnknown,
                                                      ObjectPath,
                                                      &DsName );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsapDsWriteAttributesByDsName( DsName,
                                                Attributes,
                                                AttributeCount,
                                                Options );
        LsapDsFree( DsName );
    }

    LsapDsDeleteAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                 NullObject,
                                 ReleaseState );

    LsapExitFunc( "LsapDsWriteAttributes", Status );
    return( Status );
}



NTSTATUS
LsapDsReadAttributesByDsName(
    IN PDSNAME  ObjectPath,
    IN ULONG Options,
    IN OUT PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    ATTRBLOCK   AttrBlock;
    ATTRBLOCK   ReadAttr;
    PATTR       Attrs;
    ULONG       i, j;
    BOOLEAN     ReleaseState;

    LsapEnterFunc( "LsapDsReadAttributesByDsName" );

    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                        NullObject,
                                        &ReleaseState );

    if ( !NT_SUCCESS( Status ) ) {

        LsapExitFunc( "LsapDsReadAttributesByDsName", Status );
        return( Status );
    }

    LsapDsSetDsaFlags( TRUE );

    //
    // Ok, first, build the list of Ds attributes
    //
    Attrs = LsapDsAlloc( sizeof( ATTR ) * AttributeCount );

    if ( Attrs == NULL ) {

        Status = STATUS_NO_MEMORY;

    } else {

        for ( i = 0 ; i < AttributeCount; i++ ) {

            Attrs[i].attrTyp = Attributes[i].DsAttId;
            Attrs[i].AttrVal.valCount = 0;
            Attrs[i].AttrVal.pAVal = NULL;

        }

        AttrBlock.attrCount = AttributeCount;
        AttrBlock.pAttr = Attrs;

        //
        // Now, simply write it out
        //
        Status = LsapDsReadByDsName( ObjectPath, Options, &AttrBlock, &ReadAttr );

        //
        // If that worked, fill in the rest of our attributes
        //
        if ( NT_SUCCESS( Status ) ) {

#if DBG
            if ( AttributeCount != ReadAttr.attrCount ) {

                LsapDsDebugOut(( DEB_WARN,
                                 "LsapDsReadAttributes: Expected %lu attributes, got %lu\n",
                                 AttributeCount, ReadAttr.attrCount ));

            }
#endif
            for ( j = 0; j < AttributeCount; j++ ) {

                for ( i = 0 ; i < ReadAttr.attrCount && NT_SUCCESS( Status ); i++ ) {

                    if ( Attributes[ j ].DsAttId == ReadAttr.pAttr[ i ].attrTyp ) {

                        Status = LsapDsDsAttributeToLsaAttribute( ReadAttr.pAttr[i].AttrVal.pAVal,
                                                                  &Attributes[j] );
                        break;

                    }
                }

                //
                // If we got throught the loop and the value wasn't found, see if our attribute
                // can default to zero.  If not, it's an error
                //
                if ( i >= ReadAttr.attrCount ) {

                    if ( Attributes[ j ].CanDefaultToZero == TRUE ) {

                        Attributes[ j ].AttributeValue = NULL;
                        Attributes[ j ].AttributeValueLength = 0;

                    } else {

                        Status = STATUS_NOT_FOUND;
                        LsapDsDebugOut(( DEB_ERROR,
                                         "Attribute %wZ not found on object %wZ\n",
                                         &Attributes[ j ].AttributeName,
                                         ObjectPath ));
                    }
                }
            }

        } else if ( AttributeCount == 1 && Status == STATUS_NOT_FOUND ) {

            //
            // If we were only looking for one attribute, it's possible that its ok for that
            // attribute to be null.
            //
            if ( Attributes[ 0 ].CanDefaultToZero ) {

                Status = STATUS_SUCCESS;
                Attributes[ 0 ].AttributeValue = NULL;
                Attributes[ 0 ].AttributeValueLength = 0;
            }

        }

    }

    LsapDsDeleteAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                 NullObject,
                                 ReleaseState );

    LsapExitFunc( "LsapDsReadAttributesByDsName", Status );
    return( Status );

}


NTSTATUS
LsapDsReadAttributes(
    IN PUNICODE_STRING  ObjectPath,
    IN ULONG Options,
    IN OUT PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDSNAME     DsName = NULL;
    BOOLEAN     ReleaseState;

    LsapEnterFunc( "LsapDsReadAttributes" );

    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                        NullObject,
                                        &ReleaseState );

    if ( !NT_SUCCESS( Status ) ) {

        LsapExitFunc( "LsapDsReadAttributes", Status );
        return( Status );
    }


    //
    // Build the DSName
    //
    Status = LsapAllocAndInitializeDsNameFromUnicode( LsapDsObjUnknown,
                                                      ObjectPath,
                                                      &DsName );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsapDsReadAttributesByDsName( DsName,
                                               Options,
                                               Attributes,
                                               AttributeCount );
        LsapDsFree( DsName );
    }

    LsapDsDeleteAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                 NullObject,
                                 ReleaseState );

    LsapExitFunc( "LsapDsReadAttributes", Status );
    return( Status );
}



NTSTATUS
LsapDsDeleteAttributes(
    IN PUNICODE_STRING  ObjectPath,
    IN OUT PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRBLOCK   AttrBlock;
    PATTR       Attrs;
    ULONG       i;

    LsapEnterFunc( "LsapDsDeleteAttributes" );

    LsapDsSetDsaFlags( TRUE );

    //
    // Ok, first, build the list of Ds attributes
    //
    Attrs = LsapDsAlloc( sizeof( ATTR ) * AttributeCount );

    if ( Attrs == NULL ) {

        Status = STATUS_NO_MEMORY;

    } else {

        for ( i = 0 ; i < AttributeCount && NT_SUCCESS( Status ); i++ ) {

            Attributes[i].AttributeValueLength = 0;
            Attributes[i].AttributeValue = NULL;
            Status = LsapDsLsaAttributeToDsAttribute( &Attributes[i], &Attrs[i] );
        }

        if ( NT_SUCCESS( Status ) ) {

            AttrBlock.attrCount = AttributeCount;
            AttrBlock.pAttr = Attrs;

            //
            // Now, simply write it out
            //
            Status = LsapDsWrite( ObjectPath, AT_CHOICE_REMOVE_ATT, &AttrBlock );

        }
    }


    LsapExitFunc( "LsapDsDeleteAttributes", Status );
    return( Status );
}


NTSTATUS
LsapDsTrustedDomainSidToLogicalName(
    IN PSID Sid,
    OUT PUNICODE_STRING LogicalNameU
    )
/*++

Routine Description:

    This function generates the Logical Name (Internal LSA Database Name)
    of a trusted domain object from its Sid.  Currently, only the Relative

Arguments:

    Sid - Pointer to the Sid to be looked up.  It

    LogicalNameU -  Pointer to a Unicode String structure that will receive
        the Logical Name.  Note that memory for the string buffer in this
        Unicode String will be allocated by this routine if successful.  The
        caller must free this memory after use by calling RtlFreeUnicodeString.

Return Value:

    NTSTATUS - Standard Nt Status code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to allocate buffer for Unicode String name.
--*/

{
    NTSTATUS Status;
    ATTR     SidAttr;
    ATTRVAL  SidVal;
    ATTRBLOCK   SidBlock;
    PDSNAME  FoundName = NULL;
    BOOLEAN ReleaseState;
    WCHAR   RdnBuffer[MAX_RDN_SIZE + 1];
    ULONG   RdnLen;
    ATTRBLOCK   ReadBlock, ReturnedBlock;
    ATTRTYP RdnType;
    ATTR ReadAttr[] = {
        {LsapDsAttributeIds[ LsapDsAttrTrustPartner ], {0, NULL} }
        };

    LsapEnterFunc( "LsapDsTrustedDomainSidToLogicalName" );


    //
    // First, verify that the given Sid is valid
    //
    if (!RtlValidSid( Sid )) {

        LsapExitFunc( "LsapDsTrustedDomainSidToLogicalName", STATUS_INVALID_PARAMETER );
        return( STATUS_INVALID_PARAMETER );
    }

    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_DS_OP_TRANSACTION |
                                            LSAP_DB_READ_ONLY_TRANSACTION,
                                        TrustedDomainObject,
                                        &ReleaseState );

    if ( NT_SUCCESS( Status ) ) {

        //
        // Check for the existence of the object
        //
        SidAttr.attrTyp          = ATT_SECURITY_IDENTIFIER;
        SidAttr.AttrVal.valCount = 1;
        SidAttr.AttrVal.pAVal    = &SidVal;


        SidVal.valLen = RtlLengthSid( Sid );
        SidVal.pVal   = (PBYTE)Sid;

        SidBlock.attrCount = 1;
        SidBlock.pAttr = &SidAttr;

        Status = LsapDsSearchUnique( LSAPDS_SEARCH_LEVEL | LSAPDS_OP_NO_TRANS,
                                     LsaDsStateInfo.DsSystemContainer,
                                     &SidAttr,
                                     1,
                                     &FoundName );

        if ( NT_SUCCESS( Status ) ) {

            ReadBlock.attrCount = sizeof( ReadAttr ) / sizeof( ATTR );
            ReadBlock.pAttr = ReadAttr;
            Status = LsapDsReadByDsName( FoundName,
                                         LSAPDS_READ_NO_LOCK,
                                         &ReadBlock,
                                         &ReturnedBlock );

            if ( NT_SUCCESS( Status ) && LogicalNameU ) {

                LSAPDS_ALLOC_AND_COPY_STRING_TO_UNICODE_ON_SUCCESS(
                        Status,
                        LogicalNameU,
                        ReturnedBlock.pAttr[0].AttrVal.pAVal[ 0 ].pVal,
                        ReturnedBlock.pAttr[0].AttrVal.pAVal[ 0 ].valLen );

            }

            LsapFreeLsaHeap( FoundName );

        }


        LsapDsDeleteAllocAsNeededEx( LSAP_DB_DS_OP_TRANSACTION |
                                     LSAP_DB_READ_ONLY_TRANSACTION,
                                     TrustedDomainObject,
                                     ReleaseState );

    }


    LsapExitFunc( "LsapDsTrustedDomainSidToLogicalName", Status );
    return( Status );
}


VOID
LsapDsContinueTransaction(
    VOID
    )
/*++

Routine Description:

    Call this function when we've just done a Dir* call and want to continue
    the transaction.

Arguments:

    None.

Return Value:

    None.
--*/
{
    PLSADS_PER_THREAD_INFO CurrentThreadInfo;

    LsapEnterFunc( "LsapDsContinueTransaction" );

    CurrentThreadInfo = LsapQueryThreadInfo();

    ASSERT( CurrentThreadInfo != NULL && CurrentThreadInfo->DsThreadStateUseCount > 0 );
    if ( CurrentThreadInfo != NULL ) {

        //
        //  Tell the DS that there's more to come.
        //

        if ( CurrentThreadInfo->DsTransUseCount ) {

            DirTransactControl( TRANSACT_DONT_BEGIN_DONT_END );
            CurrentThreadInfo->DsOperationCount++;
        }
    }

    LsapExitFunc( "LsapDsContinueTransaction", 0 );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dsfixup.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dsfixup.c

Abstract:

    Implementation of a variety of fixup routines for the Lsa/Ds interaction.

Author:

    Mac McLain          (MacM)       Jan 17, 1997

Environment:

    User Mode

Revision History:

--*/
#include <lsapch2.h>
#include <dbp.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <alloca.h>

//
// List entry that maintains information on notifications
//
typedef struct _LSAP_DSFU_NOTIFICATION_NODE {

    LIST_ENTRY List ;
    LUID AuthenticationId;
    PSID UserSid;
    PDSNAME ObjectPath;
    ULONG Class;
    SECURITY_DB_DELTA_TYPE DeltaType;
    ULONG OldTrustDirection;
    ULONG OldTrustType;
    BOOLEAN ReplicatedInChange;
    BOOLEAN ChangeOriginatedInLSA;

} LSAP_DSFU_NOTIFICATION_NODE, *PLSAP_DSFU_NOTIFICATION_NODE;

LIST_ENTRY LsapFixupList ;
SAFE_CRITICAL_SECTION LsapFixupLock ;
BOOLEAN LsapFixupThreadActive ;

//
// Packages that need to be called when trust changes.  Right now, it's only Kerberos.  If
// that changes, this will have to be changed into a list and processed.
//
pfLsaTrustChangeNotificationCallback LsapKerberosTrustNotificationFunction = NULL;



//
// Local prototypes
//
#define LSAP_DS_FULL_FIXUP      TRUE
#define LSAP_DS_NOTIFY_FIXUP    FALSE
NTSTATUS
LsapDsFixupTrustedDomainObject(
    IN PDSNAME TrustObject,
    IN BOOLEAN Startup,
    IN ULONG SamCount,
    IN PSAMPR_RID_ENUMERATION SamAccountList
    );

NTSTATUS
LsapDsTrustRenameObject(
    IN PDSNAME TrustObject,
    IN PUNICODE_STRING NewDns,
    OUT PDSNAME *NewObjectName
    );

DWORD
WINAPI LsapDsFixupCallback(
    LPVOID ParameterBlock
    );

VOID
LsapFreeNotificationNode(
    IN PLSAP_DSFU_NOTIFICATION_NODE NotificationNode
    );

NTSTATUS
LsapDsFixupTrustByInfo(
    IN PDSNAME ObjectPath,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 TrustInfo2,
    IN ULONG PosixOffset,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN PSID UserSid,
    IN LUID AuthenticationId,
    IN BOOLEAN ReplicatedInChange,
    IN BOOLEAN ChangeOriginatedInLSA
    );




NTSTATUS
LsapDsTrustFixInterdomainTrustAccount(
    IN PDSNAME ObjectPath,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN ULONG Options,
    IN PSID UserSid,
    IN LUID AuthenticationId
    );


BOOL
LsapDsQueueFixupRequest(
    PLSAP_DSFU_NOTIFICATION_NODE Node
    );

NTSTATUS
LsapDsFixupTrustForXrefChange(
   IN PDSNAME ObjectPath,
   IN BOOLEAN TransactionActive
   );

NTSTATUS
LsapDsFixupTrustedDomainOnRestartCallback(IN PVOID Parameter)
{


    return(LsapDsFixupTrustedDomainObjectOnRestart());
}

NTSTATUS
LsapDsFixupTrustedDomainObjectOnRestart(
    VOID
    )
/*++

Routine Description:

    This routine will go through and ensure that all of the trusted domain objects
    are up to date.  This includes:
        Ensuring that the parent x-ref pointer is set
        There is not new authentication information on the object
        That the domain name has not changed
        That a domain x-ref object doesn't exist for a downlevel domain.
            If one does, the domain will be updated to an uplevel domain.

Arguments:

    VOID

Return Values:

    STATUS_SUCCESS   -- Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDSNAME *DsNames = NULL;
    ULONG Items=0, i;
    BOOLEAN CloseTransaction = FALSE;
    SAM_ENUMERATE_HANDLE  SamEnum = 0;
    PSAMPR_ENUMERATION_BUFFER RidEnum = NULL;
    ULONG SamCount = 0;
    DOMAIN_SERVER_ROLE ServerRole = DomainServerRolePrimary;
    BOOLEAN            RollbackTransaction = FALSE;
    BOOLEAN            FixupFailed = FALSE;



    //
    // Begin a DS transaction.
    //

    Status = LsapDsInitAllocAsNeededEx( 0,
                                        TrustedDomainObject,
                                        &CloseTransaction );

    if ( !NT_SUCCESS( Status ) ) {
        return( Status );
    }

    Status = LsapDsGetListOfSystemContainerItems( CLASS_TRUSTED_DOMAIN,
                                                  &Items,
                                                  &DsNames );

    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

        Items = 0;
        Status = STATUS_SUCCESS;
    }


    ASSERT(SampExistsDsTransaction());
    ASSERT(THVerifyCount(1));

    if ( NT_SUCCESS( Status ) ) {

        LsapSaveDsThreadState();

        Status = LsapOpenSam();

        if ( !NT_SUCCESS( Status )  ) {

                LsapDsDebugOut(( DEB_ERROR,
                                 "LsapDsFixupTrustedDomainObjectOnRestart: Sam not opened\n"));

        } else {


            //
            // Query the server role, PDC/BDC
            //

            Status = SamIQueryServerRole(
                        LsapAccountDomainHandle,
                        &ServerRole
                        );

            if ((NT_SUCCESS(Status)) && (DomainServerRolePrimary==ServerRole))
            {

                //
                // Enumerate all of the SAM Interdomain trust accounts
                //

                Status = SamrEnumerateUsersInDomain( LsapAccountDomainHandle,
                                                 &SamEnum,
                                                 USER_INTERDOMAIN_TRUST_ACCOUNT,
                                                 &RidEnum,
                                                 0xFFFFFFFF,
                                                 &SamCount );

                if ( !NT_SUCCESS( Status ) ) {

                    LsapDsDebugOut(( DEB_FIXUP,
                                 "SamEnumerateUsersInDomain failed with 0x%lx\n",
                                 Status ));
                } else {

                    LsapDsDebugOut(( DEB_FIXUP,
                                 "SamEnumerateUsersInDomain returned %lu accounts\n",
                                 SamCount ));

                }
            }

        }

        LsapRestoreDsThreadState();
    }

    ASSERT(SampExistsDsTransaction());
    ASSERT(THVerifyCount(1));

    //
    // Perform fixup only on PDC
    //

    if (( NT_SUCCESS( Status ) ) && (DomainServerRolePrimary==ServerRole)) {

        for ( i = 0; i < Items; i++ ) {

            ASSERT(SampExistsDsTransaction());
            ASSERT(THVerifyCount(1));

            Status = LsapDsFixupTrustedDomainObject( DsNames[ i ], LSAP_DS_FULL_FIXUP,
                SamCount, (NULL!=RidEnum)?RidEnum->Buffer:NULL );

            if (!NT_SUCCESS(Status))
            {
                FixupFailed = TRUE;
            }


        }



    } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

        Status = STATUS_SUCCESS;
    }

    if ( RidEnum ) {

        SamFreeMemory( RidEnum );
    }

    ASSERT(SampExistsDsTransaction());
    ASSERT(THVerifyCount(1));

    if (!NT_SUCCESS(Status))
    {
        RollbackTransaction = TRUE;
    }

    //
    // Close the transacation
    //

    LsapDsDeleteAllocAsNeededEx2( 0,
                                 TrustedDomainObject,
                                 CloseTransaction,
                                 RollbackTransaction
                                 );

    ASSERT(!SampExistsDsTransaction());
    ASSERT(THVerifyCount(0));

    //
    // If failed then queue for a second try
    //

    if ((!NT_SUCCESS(Status)) || (FixupFailed))
    {
        LsaIRegisterNotification(
                LsapDsFixupTrustedDomainOnRestartCallback,
                NULL,
                NOTIFIER_TYPE_INTERVAL,
                0,            // no class
                NOTIFIER_FLAG_ONE_SHOT,
                600,          // wait for another 10 mins
                NULL          // no handle
                ); 
    }

    return( STATUS_SUCCESS );
}



NTSTATUS
LsapDsFixupTrustForXrefChange(
   IN PDSNAME ObjectPath,
   IN BOOLEAN TransactionActive
   )
/*++

    This routine does the appropriate changes to the TDO to make it uplevel, when the
    cross ref replicates in

    Parameters

    ObjectPath -- The path to the Xref ( ie the DSNAME of the Xref )
    TransactionActive -- Indicates that a transaction is active and the trusted domain lock
                         is held. Therefore these 2 operations need not be done
    Return Values

        STATUS_SUCCESS
        Other Error codes

--*/
{
    ATTRBLOCK Read, Results;
    PDSNAME   NcName = NULL;
    PSID      TrustedDomainSid=NULL;
    UNICODE_STRING DnsName;
    UNICODE_STRING FlatName;
    UNICODE_STRING TruncatedName;
    BOOLEAN   NcNameFound = FALSE;
    BOOLEAN   DnsNameFound = FALSE;
    BOOLEAN   FlatNameFound = FALSE;
    LSAPR_HANDLE TrustedDomain=0;
    NTSTATUS   Status = STATUS_SUCCESS;
    DSNAME     *TrustedDomainDsName = NULL;
    DSNAME     *NewObjectName = NULL;
    ULONG       j;
    ULONG       TrustType=0,TrustDirection=0,TrustAttributes=0;
    ULONG       ForestTrustLength = 0;
    PBYTE       ForestTrustInfo = NULL;
    BOOLEAN     CloseTransaction=FALSE;
    BOOLEAN     ActiveThreadState = FALSE;
    BOOLEAN     TrustChanged = FALSE;
    BOOLEAN     FoundCorrespondingTDO = FALSE;



    RtlZeroMemory(&DnsName, sizeof(UNICODE_STRING));
    RtlZeroMemory(&FlatName, sizeof(UNICODE_STRING));
    RtlZeroMemory(&TruncatedName, sizeof(UNICODE_STRING));


    if (!TransactionActive)
    {

        //
        // Begin a Transaction
        //

        Status = LsapDsInitAllocAsNeededEx(
                        0,
                        TrustedDomainObject,
                        &CloseTransaction
                        );

        if (!NT_SUCCESS(Status))
            goto Error;

        ActiveThreadState = TRUE;
    }



    //
    // Read the fixup information we need.  This includes:
    //   Attributes
    //   Trust partner
    //   Crossref info
    //   Type
    //   Initial incoming auth info
    //   Initial outgoing auth info
    //

    Read.attrCount = LsapDsTrustedDomainFixupXRefCount;
    Read.pAttr = LsapDsTrustedDomainFixupXRefAttributes;
    Status = LsapDsReadByDsName( ObjectPath,
                                 0,
                                 &Read,
                                 &Results );

   if (!NT_SUCCESS(Status))
   {
       goto Error;
   }


    ASSERT(SampExistsDsTransaction());
    ASSERT(THVerifyCount(1));

    for ( j = 0; j < Results.attrCount; j++ ) {

        switch ( Results.pAttr[ j ].attrTyp ) {

        case ATT_NC_NAME:
            NcName = (DSNAME *) LSAP_DS_GET_DS_ATTRIBUTE_AS_DSNAME(&Results.pAttr[ j ] );
            if (NcName->SidLen>0)
            {
                TrustedDomainSid = LsapAllocateLsaHeap(NcName->SidLen);
                if ( NULL==TrustedDomainSid)
                {
                    Status = STATUS_NO_MEMORY;
                    goto Error;
                }

                RtlCopyMemory(TrustedDomainSid,&NcName->Sid,NcName->SidLen) ;
            }
            NcNameFound = TRUE;
            break;

        case ATT_DNS_ROOT:
            DnsName.Length = ( USHORT) LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( &Results.pAttr[ j ] );
            DnsName.MaximumLength =  DnsName.Length;
            //
            // Allocate the buffer off of the process heap, so that we can use it even after the thread state
            // has been killed.
            //
            DnsName.Buffer = LsapAllocateLsaHeap(DnsName.MaximumLength);
            if (NULL==DnsName.Buffer)
            {
                Status = STATUS_NO_MEMORY;
                goto Error;
            }
            RtlCopyMemory(
                DnsName.Buffer,
                LSAP_DS_GET_DS_ATTRIBUTE_AS_PWSTR( &Results.pAttr[ j ] ),
                DnsName.Length
                );
            DnsNameFound = TRUE;
            break;

        case ATT_NETBIOS_NAME:
            FlatName.Length = ( USHORT) LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( &Results.pAttr[ j ] );
            FlatName.MaximumLength =  FlatName.Length;
            //
            // Allocate the buffer off of the process heap, so that we can use it even after the thread state
            // has been killed.
            //
            FlatName.Buffer = LsapAllocateLsaHeap(FlatName.MaximumLength);
            if (NULL==FlatName.Buffer)
            {
                Status = STATUS_NO_MEMORY;
                goto Error;
            }
            RtlCopyMemory(
                FlatName.Buffer,
                LSAP_DS_GET_DS_ATTRIBUTE_AS_PWSTR( &Results.pAttr[ j ] ),
                FlatName.Length
                );
            FlatNameFound = TRUE;
            break;

        }
    }


    //
    // Patch up the TDO ( if required ) after finding it by the corresponding SID
    //

    if ((NcNameFound) && (NcName->SidLen>0))
    {

        //
        // Case of an instantiated NC
        //


        ULONG ClassId = CLASS_TRUSTED_DOMAIN;

        ATTRVAL TDOAttVals[] = {
                                    { sizeof(ULONG), (PUCHAR)&ClassId},
                                    { RtlLengthSid(TrustedDomainSid), (PUCHAR)TrustedDomainSid}
                               };

        ATTR TDOAttrs[] = {
            { ATT_OBJECT_CLASS, {1, &TDOAttVals[0] } },
            { ATT_SECURITY_IDENTIFIER, {1, &TDOAttVals[1] } }
            };




        ASSERT(NULL!=TrustedDomainSid);



        Status = LsapDsSearchUnique(
                     0,
                     LsaDsStateInfo.DsSystemContainer,
                     TDOAttrs,
                     sizeof( TDOAttrs ) / sizeof( ATTR ),
                     &TrustedDomainDsName
                     );


        if ((STATUS_OBJECT_NAME_NOT_FOUND==Status)
             && (FlatNameFound))
        {


            ATTRVAL TDOFlatNameAttVals[] = {
                                        { sizeof(ULONG), (PUCHAR)&ClassId},
                                        { FlatName.Length, (PUCHAR)FlatName.Buffer}
                                   };

            ATTR TDOFlatNameAttrs[] = {
                { ATT_OBJECT_CLASS, {1, &TDOFlatNameAttVals[0] } },
                { ATT_TRUST_PARTNER, {1, &TDOFlatNameAttVals[1] } }
                };

            //
            // We could not find the TDO by SID. Maybe this is a case of an inbount only
            // trust . Try to find by the flat name
            //


            Status = LsapDsSearchUnique(
                        0,
                        LsaDsStateInfo.DsSystemContainer,
                        TDOFlatNameAttrs,
                        sizeof( TDOFlatNameAttrs ) / sizeof( ATTR ),
                        &TrustedDomainDsName
                        );

        }



        //
        // Bail if we could not find the corresponding TDO
        //

        if (!NT_SUCCESS(Status))
        {

            //
            // Failure to find the TDO is not an error. It just means that
            // a direct trust to that domain does not exist. Therefore
            // reset the error code before bailing
            //

            if (STATUS_OBJECT_NAME_NOT_FOUND==Status)
            {
                Status = STATUS_SUCCESS;
            }

            goto Error;
        }

        FoundCorrespondingTDO = TRUE;

        //
        // Read and Modify the trust type attribue
        //

        //
        //   Read the fixup information we need.  This includes:
        //   Attributes
        //   Trust partner
        //   Crossref info
        //   Type
        //   Initial incoming auth info
        //   Initial outgoing auth info
        //
        Read.attrCount = LsapDsTrustedDomainFixupAttributeCount;
        Read.pAttr = LsapDsTrustedDomainFixupAttributes;
        Status = LsapDsReadByDsName( TrustedDomainDsName,
                                 0,
                                 &Read,
                                 &Results );

        if (!NT_SUCCESS(Status))
        {
            //
            // Failure to find a matching TDO is not an error. It simply means that we
            // do not have a direct trust to the domain described by the cross ref. Reset
            // error codes to success and bail
            //

            if (STATUS_OBJECT_NAME_NOT_FOUND == Status)
            {
                Status = STATUS_SUCCESS;
            }

            goto Error;
        }


        for ( j = 0; j < Results.attrCount; j++ ) {

            switch ( Results.pAttr[ j ].attrTyp ) {

                case ATT_TRUST_TYPE:

                        TrustType = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &Results.pAttr[ j ] );
                        break;

                case ATT_TRUST_DIRECTION:
                        TrustDirection = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &Results.pAttr[ j ] );
                        break;

                case ATT_TRUST_ATTRIBUTES:
                        TrustAttributes = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &Results.pAttr[ j ] );
                        break;

                case ATT_MS_DS_TRUST_FOREST_TRUST_INFO:
                        ForestTrustLength = ( ULONG )LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( &Results.pAttr[ j ] );
                        ForestTrustInfo = LSAP_DS_GET_DS_ATTRIBUTE_AS_PBYTE( &Results.pAttr[ j ] );
                        break;

            }
        }


        if ((TrustType & TRUST_TYPE_DOWNLEVEL ) && (DnsNameFound))
        {
            //
            // If the trust type is marked as downlevel, we need to change this to an uplevel trust
            //

            //
            // Setup the Attrblock structure for the DS
            //

            ATTRVAL TDOWriteAttVals[] = {
                                            { sizeof(ULONG), (PUCHAR)&TrustType},
                                            { ObjectPath->structLen, (PUCHAR)ObjectPath},
                                            { DnsName.Length, (PUCHAR)DnsName.Buffer}
                                         };

            ATTR TDOWriteAttrs[] = {
                                    { ATT_TRUST_TYPE, {1, &TDOWriteAttVals[0] } },
                                    { ATT_DOMAIN_CROSS_REF, {1, &TDOWriteAttVals[1] } },
                                    { ATT_TRUST_PARTNER, {1, &TDOWriteAttVals[2] } }
                                   };

            ATTRBLOCK TDOWriteAttrBlock = {sizeof(TDOWriteAttrs)/sizeof(TDOWriteAttrs[0]),TDOWriteAttrs};

            //
            // Change trust type to uplevel
            //

            TrustType &= ~((ULONG) TRUST_TYPE_DOWNLEVEL);
            TrustType |=TRUST_TYPE_UPLEVEL;


            //
            // Set the attributes on the TDO
            //


            Status = LsapDsWriteByDsName(
                        TrustedDomainDsName,
                        LSAPDS_REPLACE_ATTRIBUTE,
                        &TDOWriteAttrBlock
                        );

            if (!NT_SUCCESS(Status))
                goto Error;



            //
            // O.K now rename the object ( sets the DNS domain name )
            //

            Status = LsapDsTruncateNameToFitCN(
                        &DnsName,
                        &TruncatedName
                        );

            if (!NT_SUCCESS(Status))
                goto Error;

            Status = LsapDsTrustRenameObject(
                        TrustedDomainDsName,
                        &TruncatedName,
                        &NewObjectName
                        );

            if (!NT_SUCCESS(Status))
                goto Error;

            TrustChanged = TRUE;

        }
    }


Error:

    //
    // Update the LSA in memory list regarding the Trust change
    // Note this update is done after the commit, except in the case
    // where the caller has the transaction open which occurs during an
    // upgrade from NT4 where notifications to the in memory trust list
    // are not processed anyway.
    //

    if ((NT_SUCCESS(Status)) && (TrustChanged))
    {
        LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 NewTrustInfo;

        RtlZeroMemory(&NewTrustInfo, sizeof(NewTrustInfo));

        ASSERT(DnsNameFound);

        if (DnsNameFound)
        {
            RtlCopyMemory(&NewTrustInfo.Name,&DnsName, sizeof(UNICODE_STRING));
        }

        if (FlatNameFound)
        {
            RtlCopyMemory(&NewTrustInfo.FlatName,&FlatName,sizeof(UNICODE_STRING));
        }

        ASSERT(NcName->SidLen >0);

        NewTrustInfo.Sid = TrustedDomainSid;
        NewTrustInfo.TrustType = TrustType;
        NewTrustInfo.TrustDirection = TrustDirection;
        NewTrustInfo.TrustAttributes = TrustAttributes;
        NewTrustInfo.ForestTrustLength = ForestTrustLength;
        NewTrustInfo.ForestTrustInfo = ForestTrustInfo;

        LsapDbFixupTrustedDomainListEntry(
            NewTrustInfo.Sid,
            &NewTrustInfo.Name,
            &NewTrustInfo.FlatName,
            &NewTrustInfo,
            NULL
            );
    }

    //
    // Commit / Rollback the transaction if necessary
    //

    if (ActiveThreadState)
    {
        BOOLEAN RollbackTransaction = (NT_SUCCESS(Status))?FALSE:TRUE;
        LsapDsDeleteAllocAsNeededEx2(
            0,
            TrustedDomainObject,
            CloseTransaction,
            RollbackTransaction // rollback transaction
            );

        ASSERT(!SampExistsDsTransaction());
        ASSERT(THVerifyCount(0));

    }

    if ((!NT_SUCCESS(Status)) && FoundCorrespondingTDO)
    {
        //
        // If we could not update the Corresponding CrossRef then event log
        //

        //
        // Event log the error
        //

        if (DnsNameFound)
        {
            SpmpReportEventU(
                EVENTLOG_ERROR_TYPE,
                LSA_TRUST_UPGRADE_ERROR,
                0,
                sizeof( ULONG ),
                &Status,
                1,
                &DnsName
                );
        }
        else if (FlatNameFound)
        {
            SpmpReportEventU(
                EVENTLOG_ERROR_TYPE,
                LSA_TRUST_UPGRADE_ERROR,
                0,
                sizeof( ULONG ),
                &Status,
                1,
                &FlatName
                );
        }

        //
        // We do not event log the failure if no name is found, but then
        // it is an extremely wierd case indeed.
        //

    }

    if (TrustedDomainDsName)
        LsapFreeLsaHeap(TrustedDomainDsName);


    if (NewObjectName)
        LsapFreeLsaHeap(NewObjectName);

    if (DnsName.Buffer)
        LsapFreeLsaHeap(DnsName.Buffer);

    if (FlatName.Buffer)
        LsapFreeLsaHeap(FlatName.Buffer);

    if (TrustedDomainSid)
        LsapFreeLsaHeap(TrustedDomainSid);

    if (TruncatedName.Buffer)
        LsapFreeLsaHeap(TruncatedName.Buffer);

    return(Status);

}




NTSTATUS
LsapDsFixupTrustedDomainObject(
    IN PDSNAME TrustObject,
    IN BOOLEAN Startup,
    IN ULONG SamCount,
    IN PSAMPR_RID_ENUMERATION SamAccountList

    )
/*++

Routine Description:

    This routine will fixup an individual trusted domain object

Arguments:

    TrustObject -- Trusted domain object to fix up

    Startup -- If TRUE, this is startup fixup, so do the full set.  Otherwise, it's notification
               fixup, so a limited set is done.

Return Values:

    STATUS_SUCCESS   -- Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDSNAME NewTrust = NULL;
    ULONG Items, i, j;
    ATTRBLOCK Read, Results, XRefResults, Write;
    ATTR WriteAttrs[ 4 ];
    ATTRVAL WriteAttrVal[ sizeof( WriteAttrs ) / sizeof( ATTR ) ];
    ULONG Attributes, Type, XRefAttr, Direction = 0;
    PUNICODE_STRING InitialIncoming = NULL, InitialOutgoing = NULL, Partner = NULL, Flat = NULL;
    UNICODE_STRING Initial, UnicodePartner, UnicodeIncoming, UnicodeOutgoing, XRefDns, FlatName = { 0 };
    BOOLEAN CloseTransaction, WriteXRef, WritePartner, WriteAttribute, WriteType;
    BOOLEAN RenameRequired = FALSE, RemoveIncoming = FALSE, RemoveOutgoing = FALSE;
    BOOLEAN RemoveObject = FALSE;
    PSAMPR_RID_ENUMERATION CurrentAccount = NULL;
    TRUSTED_DOMAIN_INFORMATION_EX UpdateInfoEx;
    ULONG Size = 0;

    //
    // A DS transaction should already exist at this point.
    //

    ASSERT(SampExistsDsTransaction());
    ASSERT(THVerifyCount(1));

    RtlZeroMemory( &Write, sizeof( ATTRBLOCK ) );

    WriteXRef = FALSE;
    WritePartner = FALSE;
    WriteAttribute = FALSE;
    WriteType = FALSE;

    LsapDsDebugOut(( DEB_FIXUP,
                     "Processing %ws\n",
                     LsapDsNameFromDsName( TrustObject ) ));

    //
    // Read the fixup information we need.  This includes:
    //   Attributes
    //   Trust partner
    //   Crossref info
    //   Type
    //   Initial incoming auth info
    //   Initial outgoing auth info
    //
    Read.attrCount = LsapDsTrustedDomainFixupAttributeCount;
    Read.pAttr = LsapDsTrustedDomainFixupAttributes;
    Status = LsapDsReadByDsName( TrustObject,
                                 0,
                                 &Read,
                                 &Results );

    if ( NT_SUCCESS( Status ) ) {

        for ( j = 0; j < Results.attrCount; j++ ) {

            switch ( Results.pAttr[ j ].attrTyp ) {

            case ATT_TRUST_PARTNER:
                UnicodePartner.Length = ( USHORT) LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( &Results.pAttr[ j ] );
                UnicodePartner.MaximumLength = UnicodePartner.Length;
                UnicodePartner.Buffer = LSAP_DS_GET_DS_ATTRIBUTE_AS_PWSTR( &Results.pAttr[ j ] );
                Partner = &UnicodePartner;
                break;

            case ATT_FLAT_NAME:
                FlatName.Length = ( USHORT) LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( &Results.pAttr[ j ] );
                FlatName.MaximumLength = FlatName.Length;
                FlatName.Buffer = LSAP_DS_GET_DS_ATTRIBUTE_AS_PWSTR( &Results.pAttr[ j ] );
                Flat = &FlatName;
                break;

            case ATT_TRUST_ATTRIBUTES:
                Attributes = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &Results.pAttr[ j ] );
                break;

            case ATT_TRUST_DIRECTION:
                Direction = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &Results.pAttr[ j ] );
                break;

            case ATT_TRUST_TYPE:
                Type = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &Results.pAttr[ j ] );
                break;

            case ATT_INITIAL_AUTH_INCOMING:
                UnicodeIncoming.Length = ( USHORT) LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( &Results.pAttr[ j ] );
                UnicodeIncoming.MaximumLength = UnicodeIncoming.Length;
                UnicodeIncoming.Buffer = LSAP_DS_GET_DS_ATTRIBUTE_AS_PWSTR( &Results.pAttr[ j ] );
                InitialIncoming = &UnicodeIncoming;
                break;

            case ATT_INITIAL_AUTH_OUTGOING:
                UnicodeOutgoing.Length = ( USHORT) LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( &Results.pAttr[ j ] );
                UnicodeOutgoing.MaximumLength = UnicodeOutgoing.Length;
                UnicodeOutgoing.Buffer = LSAP_DS_GET_DS_ATTRIBUTE_AS_PWSTR( &Results.pAttr[ j ] );
                InitialOutgoing = &UnicodeOutgoing;
                break;

            default:

                //
                // If other attributes that we do not necessarily want came back, then do nothing.
                //
                break;
            }

        }

    }

    //
    // See if we have the proper interdomain trust account set
    //

    if ( NT_SUCCESS( Status ) && Startup && FLAG_ON( Direction, TRUST_DIRECTION_INBOUND ) ) {

        //
        // Find the interdomain trust account that matches
        //
        for ( Items = 0; Items < SamCount; Items++ ) {

            if ( FlatName.Length + sizeof( WCHAR ) == SamAccountList[ Items ].Name.Length &&
                 RtlPrefixUnicodeString( &FlatName,
                                         ( PUNICODE_STRING )&SamAccountList[ Items ].Name,
                                         TRUE ) ) {

                 CurrentAccount = &SamAccountList[ Items ];
                 break;
            }
        }

        //
        // We have no account, so we had better create one
        //
        if ( CurrentAccount == NULL ) {

            Status = LsapDsCreateInterdomainTrustAccountByDsName( TrustObject,
                                                                  &FlatName );

            if ( !NT_SUCCESS( Status ) ) {

                SpmpReportEventU(
                     EVENTLOG_WARNING_TYPE,
                     LSAEVENT_ITA_FOR_TRUST_NOT_CREATED,
                     0,
                     sizeof( ULONG ),
                     &Status,
                     1,
                     Partner ? Partner : &FlatName
                     );            
            }

        } else {

            if ( RemoveObject ) {

                LsapDsDebugOut(( DEB_FIXUP,
                                 "InterdomainTrustAccount %wZ being removed\n",
                                 &CurrentAccount->Name ));
            }
        }
    }


#if DBG
    if ( !NT_SUCCESS( Status ) ) {

        LsapDsDebugOut(( DEB_FIXUP, "Fixup of %ws failed with 0x%lx\n",
                         LsapDsNameFromDsName( TrustObject ), Status ));

    }
#endif


    //
    // The DS transaction should remain open at this point.
    //

    ASSERT(SampExistsDsTransaction());
    ASSERT(THVerifyCount(1));



    return( Status );
}


NTSTATUS
LsapDsTrustRenameObject(
    IN PDSNAME TrustObject,
    IN PUNICODE_STRING NewDns,
    OUT PDSNAME *NewObjectName
    )
/*++

Routine Description:

    This routine will rename an existing trusted domain object

Arguments:

Return Values:

    STATUS_SUCCESS   -- Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDSNAME NewObject = NULL;
    ULONG Len = 0;


    //
    // Build a new object name
    //
    if ( NewObjectName != NULL ) {

        Len = LsapDsLengthAppendRdnLength( LsaDsStateInfo.DsSystemContainer,
                                           NewDns->Length + sizeof( WCHAR ) );
        *NewObjectName = LsapAllocateLsaHeap( Len );

        if ( *NewObjectName == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            Status = LsapDsMapDsReturnToStatus( AppendRDN( LsaDsStateInfo.DsSystemContainer,
                                                           *NewObjectName,
                                                           Len,
                                                           NewDns->Buffer,
                                                           NewDns->Length / sizeof( WCHAR ),
                                                           ATT_COMMON_NAME ) );
        }
    }


    if ( NT_SUCCESS( Status ) ) {

        //
        // Do the rename
        //
        Status = LsapDsRenameObject( TrustObject,
                                     NULL,
                                     ATT_COMMON_NAME,
                                     NewDns );

        if ( !NT_SUCCESS( Status ) ) {

            LsapDsDebugOut(( DEB_FIXUP,
                             "Rename of %ws to %wZ failed with 0x%lx\n",
                             LsapDsNameFromDsName( TrustObject ),
                             NewDns,
                             Status ));

            if ( NewObjectName != NULL ) {

                LsapFreeLsaHeap( *NewObjectName );
                *NewObjectName = NULL;

            }
        }

    }



    return( Status );
}




NTSTATUS
LsaIDsNotifiedObjectChange(
    IN ULONG Class,
    IN PVOID ObjectPath,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN PSID UserSid,
    IN LUID AuthenticationId,
    IN BOOLEAN ReplicatedInChange,
    IN BOOLEAN ChangeOriginatedInLSA
    )
/*++

Routine Description:

    This routine is called by the Ds when an object that the Lsa cares about is modified.
    This call is made synchronously to the Ds commit thread, and so must spend as little
    time doing stuff as possible.  Used only as a dispatch mechanism.

Arguments:

    Class -- Class Id of the object being modified

    ObjectPath -- Full Ds path to the object that has been modified

    DeltaType -- Type of the modification

    UserSid -- The SID of the user who made this change, if known

    AuthenticationId --  ?? authentication ID of the user who made this change

    ReplicatedInChange --    TRUE if this is a replicated-in change

    ChangeOriginatedInLSA -- TRUE if the change originated in LSA

Return Values:

    STATUS_SUCCESS   -- Success

    STATUS_INSUFFICIENT_RESOURCES -- A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DSFU_NOTIFICATION_NODE NotificationNode;
    PDSNAME Object = ( PDSNAME )ObjectPath;


    //
    // Queue the item to be processed
    //
    LsapDsDebugOut(( DEB_DSNOTIFY,
                     "LsaIDsNotifiedObjectChange called for 0x%lx / %lu / %ws\n",
                      Class,
                      DeltaType,
                      LsapDsNameFromDsName( Object ) ));

    //
    // If this is notification of the NTDS-DSA object, the only action we care about
    // is a rename.  All others we eat.  This notification actually gets passed on to
    // Netlogon, and that's all it cares about
    //
    if ( Class == CLASS_NTDS_DSA && DeltaType != SecurityDbRename ) {

        LsapDsDebugOut(( DEB_DSNOTIFY,
                         "Notification for class NTDS_DSA ( %ws )was not a rename.  Eating change\n",
                          LsapDsNameFromDsName( Object ) ));
        return( STATUS_SUCCESS );
    }


    NotificationNode = LsapAllocateLsaHeap( sizeof( LSAP_DSFU_NOTIFICATION_NODE ) );

    if ( NotificationNode == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        RtlZeroMemory( NotificationNode, sizeof( LSAP_DSFU_NOTIFICATION_NODE ) );

        if ( RtlValidSid( UserSid ) ) {

            LSAPDS_ALLOC_AND_COPY_SID_ON_SUCCESS( Status, NotificationNode->UserSid, UserSid );
        }

        if ( NT_SUCCESS( Status ) ) {

            Status = LsapDsCopyDsNameLsa( &NotificationNode->ObjectPath,
                                          Object );

            if (NT_SUCCESS(Status))
            {

                NotificationNode->Class = Class;
                NotificationNode->DeltaType = DeltaType;
                NotificationNode->AuthenticationId = AuthenticationId;
                NotificationNode->ReplicatedInChange = ReplicatedInChange;
                NotificationNode->ChangeOriginatedInLSA = ChangeOriginatedInLSA;

                //
                // If this is an originating change,
                //  get the TrustDirection that existed before the change.
                //

                if ( !ReplicatedInChange ) {
                    PLSADS_PER_THREAD_INFO CurrentThreadInfo;

                    CurrentThreadInfo = TlsGetValue( LsapDsThreadState );

                    // ASSERT( CurrentThreadInfo != NULL )

                    if ( CurrentThreadInfo != NULL ) {
                        NotificationNode->OldTrustDirection = CurrentThreadInfo->OldTrustDirection;
                        NotificationNode->OldTrustType = CurrentThreadInfo->OldTrustType;
                    }

                }


                //
                // Queue the request to another thread
                //

                if ((NT_SUCCESS(Status)) && ( !LsapDsQueueFixupRequest( NotificationNode ) ))
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES ;
                }
            }

        }

        if ( !NT_SUCCESS( Status ) ) {

            LsapFreeNotificationNode( NotificationNode );
        }

    }

    return( Status );
}




NTSTATUS
LsaIKerberosRegisterTrustNotification(
    IN pfLsaTrustChangeNotificationCallback Callback,
    IN LSAP_REGISTER Register
    )
/*++

Routine Description:

    This routine is provided so that in process logon packages, such as Kerberos, can
    get notification of trust changes.  Currently, only one such package is supported.

Arguments:

    Callback -- Address of callback function to make

    Register -- Whether to register or unregister the notification


Return Values:

    STATUS_SUCCESS   -- Success

    STATUS_INVALID_PARAMETER -- A request was made to register a NULL callback

    STATUS_UNCSUCCESSFUL -- The operation couldn't be compeleted.  Either a callback is
            already registered or no call back is registered.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    switch ( Register ) {
    case LsaRegister:

        if ( LsapKerberosTrustNotificationFunction == NULL ) {

            if ( Callback == NULL ) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                LsapKerberosTrustNotificationFunction = Callback;

            }

        } else {

            Status = STATUS_UNSUCCESSFUL;
        }

        break;

    case LsaUnregister:

        if ( LsapKerberosTrustNotificationFunction == NULL ) {

            Status = STATUS_UNSUCCESSFUL;

        } else {

            LsapKerberosTrustNotificationFunction = NULL;
        }
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;

    }

    return( Status );
}



VOID
LsapFreeNotificationNode(
    IN PLSAP_DSFU_NOTIFICATION_NODE NotificationNode
    )
/*++

Routine Description:

    This routine frees a notification node

Arguments:

    NotificationNode -- Node to be freed


Return Values:

    VOID

--*/
{
    if ( NotificationNode ) {

        LsapFreeLsaHeap( NotificationNode->UserSid );
        LsapFreeLsaHeap( NotificationNode->ObjectPath );
        LsapFreeLsaHeap( NotificationNode );
    }
}



NTSTATUS
LsapDsFixupChangeNotificationForReplicator(
        LSAP_DB_OBJECT_TYPE_ID ObjectType,
        PSID    Sid,
        PUNICODE_STRING FlatName,
        PDSNAME ObjectPath,
        SECURITY_DB_DELTA_TYPE DeltaType,
        BOOLEAN     ReplicatedInChange
        )
/*++

  Routine Description:

    This routine provides change notifications to netlogon on trust/global secret changes. This handles replicated in changes in a multimaster system and also
secret object changes  ( needed for NT4 ) when outbound trust changes.

    Parameters:



        Sid   -- The SID of the trusted domain object

        FlatName -- The flat name/netbios name of the domain

        ObjectPath -- The DSNAME of the object. identifies the object in the DS

        DeltaType -- Type of change, add/modify/delete


    Return Values

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER One = {1,0};
    PBYTE Buffer;
    UNICODE_STRING SecretName;

    BOOLEAN SerialNumberChanged = FALSE;


    //
    // Lock the LSA database.
    //
    // We need at least the following locks:
    //  PolicyLock: protect policy cache
    //  RegistryLock: protects LsapDbState.PolicyModificationInfo (and registry transaction)
    //  Registry lock is acquired later, if we decide that the modification info
    //  is going to change
    //

    LsapDbAcquireLockEx( PolicyObject, LSAP_DB_READ_ONLY_TRANSACTION );

    //
    // Handle TDO notification.
    //

    if (TrustedDomainObject==ObjectType) {

        //
        // Give one notification for the trusted domain object
        //

        LsapDbLockAcquire( &LsapDbState.RegistryLock );
        LsapDbState.PolicyModificationInfo.ModifiedId.QuadPart+=One.QuadPart;
        SerialNumberChanged = TRUE;

        LsapNetNotifyDelta(
            SecurityDbLsa,
            LsapDbState.PolicyModificationInfo.ModifiedId,
            DeltaType,
            SecurityDbObjectLsaTDomain,
            0,
            Sid,
            NULL,
            TRUE, // Replicate immediately
            NULL
            );

        //
        // Give  a second notification for the secret object, corresponding to the trusted
        // domain object. NT4 stores the auth info in a global secret, while NT5 stored it
        // in the TDO itself. The TDO is exposed as global secret also for NT4.
        //

        SafeAllocaAllocate( Buffer, FlatName->Length + sizeof( LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX ));

        if ( Buffer == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlZeroMemory(Buffer, FlatName->Length +
                                sizeof( LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX ) );

        RtlCopyMemory( Buffer, LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX,
                       sizeof( LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX ) );
        RtlCopyMemory( Buffer +
                            sizeof( LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX ) -
                                                                sizeof(WCHAR),
                       FlatName->Buffer,
                       FlatName->Length);


        RtlInitUnicodeString( &SecretName, (PWSTR)Buffer );


        LsapDbState.PolicyModificationInfo.ModifiedId.QuadPart+=One.QuadPart;
        SerialNumberChanged = TRUE;

        LsapNetNotifyDelta(
            SecurityDbLsa,
            LsapDbState.PolicyModificationInfo.ModifiedId,
            DeltaType,
            SecurityDbObjectLsaSecret,
            0,
            NULL,
            &SecretName,
            TRUE, // Replicate immediately
            NULL
            );

        SafeAllocaFree( Buffer );
        Buffer = NULL;

    }
    else if ((SecretObject==ObjectType) )
    {
        WCHAR RdnStart[ MAX_RDN_SIZE + 1 ];
        ULONG Len;
        ATTRTYP AttrType;
        BOOLEAN SkipNotification = FALSE;

        Status = LsapDsMapDsReturnToStatus(  GetRDNInfoExternal(
                                                             ObjectPath,
                                                             RdnStart,
                                                             &Len,
                                                             &AttrType ) );

        if ( NT_SUCCESS( Status ) ) {

            ULONG UnmangledLen;


            //
            // The RDN is mangled on a delete, however the first 75 chars
            // of the RDN is prserved ( and we use upto 64 Chars ) so we
            // are O.K wrt to character loss ( fortunately ).
            // So  just adjust the size accordingly. 
            //

            if ((SecurityDbDelete==DeltaType) &&
               (IsMangledRDNExternal(RdnStart,Len,&UnmangledLen)))
            {
                Len = UnmangledLen;
            }


            //
            // Allocate a buffer to hold the name
            //

            SafeAllocaAllocate( Buffer, Len * sizeof( WCHAR ) + sizeof( LSA_GLOBAL_SECRET_PREFIX ));

            if ( Buffer == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            //
            // If the LSA created the global secret, we appended a postfix... Remove
            // that here.
            //
            RdnStart[ Len ] = UNICODE_NULL;
            if ( Len > LSAP_DS_SECRET_POSTFIX_LEN &&
                 _wcsicmp( &RdnStart[Len-LSAP_DS_SECRET_POSTFIX_LEN],
                           LSAP_DS_SECRET_POSTFIX ) == 0 ) {

                Len -= LSAP_DS_SECRET_POSTFIX_LEN;
                RdnStart[ Len ] = UNICODE_NULL;

            }


            RtlCopyMemory( Buffer,
                           LSA_GLOBAL_SECRET_PREFIX,
                           sizeof( LSA_GLOBAL_SECRET_PREFIX ) );
            RtlCopyMemory( Buffer + sizeof( LSA_GLOBAL_SECRET_PREFIX ) - sizeof(WCHAR),
                           RdnStart,
                           ( Len + 1 ) * sizeof( WCHAR ) );

            RtlInitUnicodeString( &SecretName, (PWSTR)Buffer );

            //
            // If this is a secret object deletion,
            //  Skip the notification if the secret was simply morphed into a TDO.
            //

            if ( DeltaType == SecurityDbDelete ) {
                BOOLEAN DsTrustedDomainSecret;

                (VOID) LsapDsIsSecretDsTrustedDomain(
                            &SecretName,
                            NULL,   // No object info since not openning handle
                            0,      // No options since not openning handle
                            0,      // No access since not openning handle
                            NULL,   // Don't return a handle to the object
                            &DsTrustedDomainSecret );

                if ( DsTrustedDomainSecret ) {
                    SkipNotification = TRUE;
                }
            }


            //
            // Do the actual notification.
            //
            if ( !SkipNotification ) {

                LsapDbLockAcquire( &LsapDbState.RegistryLock );
                LsapDbState.PolicyModificationInfo.ModifiedId.QuadPart+=One.QuadPart;
                SerialNumberChanged = TRUE;

                LsapNetNotifyDelta(
                    SecurityDbLsa,
                    LsapDbState.PolicyModificationInfo.ModifiedId,
                    DeltaType,
                    SecurityDbObjectLsaSecret,
                    0,
                    NULL,
                    &SecretName,
                    TRUE, // Replicate immediately
                    NULL
                    );
            }

            SafeAllocaFree( Buffer );
            Buffer = NULL;
        }
    }


    //
    // If the serial number changed,
    //  write it to the registry.
    //
    // Don't do this by going through the policy object since we want to
    //  avoid any side effects when writing this non-replicated attribute.
    //

    if ( SerialNumberChanged ) {
        //
        // Invalidate the cache for the Policy Modification Information
        //
        LsapDbMakeInvalidInformationPolicy( PolicyModificationInformation );

        //
        // Open the transaction
        //

        Status = LsapRegOpenTransaction();

        if ( NT_SUCCESS(Status) ) {

            //
            // Write the attribute
            Status = LsapDbWriteAttributeObject(
                         LsapDbHandle,
                         &LsapDbNames[ PolMod ],
                         (PVOID) &LsapDbState.PolicyModificationInfo,
                         (ULONG) sizeof (POLICY_MODIFICATION_INFO)
                         );

            if ( NT_SUCCESS(Status) ) {
                Status = LsapRegApplyTransaction();
            } else {
                Status = LsapRegAbortTransaction();
            }
        }

    }

Cleanup:

    LsapDbReleaseLockEx( PolicyObject, LSAP_DB_READ_ONLY_TRANSACTION );

    if ( SerialNumberChanged ) {

        LsapDbLockRelease( &LsapDbState.RegistryLock );
    }

    return (Status);
}



DWORD
WINAPI LsapDsFixupCallback(
    LPVOID ParameterBlock
    )
/*++

Routine Description:

    This is the worker thread for the fixup code.  Whenever notification of an object change
    comes from the Ds, it ends up routing through here, which will dispatch it as appropriate.

Arguments:

    ParameterBlock -- NotificationNode of information sufficient to determine what
                      operation should be taken


Return Values:

    ERROR_SUCCESS   -- Success

    ERROR_NOT_ENOUGH_MEMORY -- A memory allocation failed

    ERROR_INVALID_PARAMETER -- An unexpected parameter was encountered

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DSFU_NOTIFICATION_NODE NotificationNode = ( PLSAP_DSFU_NOTIFICATION_NODE )ParameterBlock;
    LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 TrustInfo2;
    BOOLEAN CloseTransaction = FALSE, RollbackTransaction = FALSE, ActiveThreadState = FALSE;
    LSAP_DB_OBJECT_TYPE_ID ObjType = NullObject;

    LsapDsDebugOut(( DEB_DSNOTIFY | DEB_FTRACE,
                     "LsapDsFixupCallback called for 0x%lx / %lu / %ws\n",
                      NotificationNode->Class,
                      NotificationNode->DeltaType,
                      LsapDsNameFromDsName( NotificationNode->ObjectPath ) ));

    switch ( NotificationNode->Class ) {
    case CLASS_TRUSTED_DOMAIN:
        ObjType = TrustedDomainObject;
        break;

    case CLASS_SECRET:
        ObjType = SecretObject;
        break;
    }

    RtlZeroMemory(&TrustInfo2, sizeof(TrustInfo2));


    //
    // Initialize the DS allocator and create a DS thread state at this point.
    //


    if ( ObjType != NullObject ) {

        Status = LsapDsInitAllocAsNeededEx( 0,
                                            ObjType,
                                            &CloseTransaction );

        if ( !NT_SUCCESS( Status ) ) {

            goto FixupCallbackCleanup;
        }

        ActiveThreadState = TRUE;
    }



    //
    // Handle a TDO changing.
    //
    if ( NotificationNode->Class ==  LsapDsClassIds[ LsapDsClassTrustedDomain ] ) {

        //
        // Get a description of the TDO as it appears in the DS.
        //

        Status = LsapDsGetTrustedDomainInfoEx( NotificationNode->ObjectPath,
                                               NotificationNode->DeltaType == SecurityDbDelete ?
                                                            LSAPDS_READ_DELETED : 0,
                                               TrustedDomainFullInformation2Internal,
                                               (PLSAPR_TRUSTED_DOMAIN_INFO)&TrustInfo2,
                                               NULL );

        if ( !NT_SUCCESS(Status) ) {
            goto FixupCallbackCleanup;
        }

        //
        // Our DS Transaction State should not be altered by LsapDsGetTrustedDomainInfoEx
        //


        ASSERT(SampExistsDsTransaction());
        ASSERT(THVerifyCount(1));

        //
        // If this is a replicated in change,
        //  get the previous trust direction from the cache entry on this machine.
        //

        if ( NotificationNode->ReplicatedInChange ) {

            //
            // Default the old direction to the new direction.
            //

            NotificationNode->OldTrustDirection = TrustInfo2.Information.TrustDirection;
            NotificationNode->OldTrustType = TrustInfo2.Information.TrustType;

            //
            // Grab the GUID of the real TDO for this named trust.
            //

            Status = LsapDbAcquireReadLockTrustedDomainList();

            if ( NT_SUCCESS(Status)) {
                PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;

                //
                // Lookup the information in the trusted domain list
                //

                Status = LsapDbLookupNameTrustedDomainListEx(
                                &TrustInfo2.Information.Name,
                                &TrustEntry );

                if ( NT_SUCCESS(Status)) {
                    ASSERT(NULL!=TrustEntry);

                    NotificationNode->OldTrustDirection = TrustEntry->TrustInfoEx.TrustDirection;
                    NotificationNode->OldTrustType = TrustEntry->TrustInfoEx.TrustType;
                }


                LsapDbReleaseLockTrustedDomainList();
            }
        }


        //
        // Fix the TDL to match the actual object.
        //

        Status = LsapDsFixupTrustByInfo( NotificationNode->ObjectPath,
                                         &TrustInfo2.Information,
                                         TrustInfo2.PosixOffset.Offset,
                                         NotificationNode->DeltaType,
                                         NotificationNode->UserSid,
                                         NotificationNode->AuthenticationId,
                                         NotificationNode->ReplicatedInChange,
                                         NotificationNode->ChangeOriginatedInLSA
                                         );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsapNotifyNetlogonOfTrustChange(
                        TrustInfo2.Information.Sid,
                        NotificationNode->DeltaType
                        );

            if ( !NT_SUCCESS( Status ) ) {

                LsapDsDebugOut(( DEB_DSNOTIFY,
                                 "LsapNotifyNetlogonOfTrustChange failed with 0x%lx\n",
                                 Status ));
            }

        }

    } else if ( NotificationNode->Class ==  LsapDsClassIds[ LsapDsClassSecret ] ) {

        //
        // Currently, there is nothing to do...
        //

    } else if ( NotificationNode->Class ==  LsapDsClassIds[ LsapDsClassXRef ] ){


        //
        // New Cross ref has replicated in, look at corresponding TDO and see if it needs
        // to be renamed
        //



        Status = LsapDsFixupTrustForXrefChange(
                        NotificationNode->ObjectPath,
                        FALSE // will begin and end its own transaction
                        );

        //
        // Since a cross-ref has changed, repopulate the cross-forest trust cache
        // with local forest trust information (only do it on the root domain DCs)
        //

        if ( LsapDbDcInRootDomain()) {

            Status = LsapDbAcquireWriteLockTrustedDomainList();

            if ( NT_SUCCESS( Status )) {

                Status = LsapForestTrustInsertLocalInfo();

                if ( !NT_SUCCESS( Status )) {

                    //
                    // Had trouble inserting forest trust info into the cache!!!
                    // Mark the trusted domain list as invalid so it can get rebuilt.
                    //

                    LsapDbPurgeTrustedDomainCache();
                }

                LsapDbReleaseLockTrustedDomainList();
            }
        }

        //
        // Notify netlogon and kerberos of the possibility of the trust tree having changed
        //
        if ( LsapKerberosTrustNotificationFunction ) {

            LsaIRegisterNotification( ( SEC_THREAD_START )LsapKerberosTrustNotificationFunction,
                                      ( PVOID ) NotificationNode->DeltaType,
                                      NOTIFIER_TYPE_IMMEDIATE,
                                      0,
                                      NOTIFIER_FLAG_ONE_SHOT,
                                      0,
                                      0 );
        }

        Status = I_NetNotifyDsChange(  NlOrgChanged );

        if ( !NT_SUCCESS( Status ) ) {

            LsapDsDebugOut(( DEB_ERROR,
                             "I_NetNotifyDsChange( NlOrgChange ) failed with 0x%lx\n" ));
        }

    } else if ( NotificationNode->Class == CLASS_USER ) {

      //
      // Nothing really to do out here. We do not take any change notifications to user
      // objects.
      //

    } else {

        Status = STATUS_INVALID_PARAMETER;
    }

FixupCallbackCleanup:




    RollbackTransaction = (NT_SUCCESS(Status))?FALSE:TRUE;

    //
    // Destruction of the thread state will delete the memory alloced by the SearchNonUnique call
    //

    if (ActiveThreadState)
    {
        LsapDsDeleteAllocAsNeededEx2( 0,
                                 ObjType,
                                 CloseTransaction,
                                 RollbackTransaction
                                 );
    }

    //
    // Assert that we have cleaned up the DS properly
    //

    ASSERT(!SampExistsDsTransaction());
    ASSERT(THVerifyCount(0));


    if (NT_SUCCESS(Status))
    {
        //
        // We need to provide netlogon notifications on trust/secret changes
        // for replication to NT4
        //

        if  ((TrustedDomainObject==ObjType) &&
            (NULL!=TrustInfo2.Information.Sid) &&
            (TrustInfo2.Information.FlatName.Length>0))
        {
            BOOLEAN NotifyNetlogon = TRUE;
            SECURITY_DB_DELTA_TYPE DeltaTypeToUse = NotificationNode->DeltaType;

            //
            // If this object need not be replicated to NT 4,
            //  be careful about giving spurious notifications.
            //

            if ( !LsapReplicateTdoNt4( TrustInfo2.Information.TrustDirection,
                                       TrustInfo2.Information.TrustType ) ) {

                //
                // If the object is just being created or deleted,
                //  then NT 4 isn't interested in this trust.
                //

                if ( DeltaTypeToUse == SecurityDbNew ||
                     DeltaTypeToUse == SecurityDbDelete ) {

                    NotifyNetlogon = FALSE;

                //
                // If the object didn't used to be replicated to NT 4,
                //  then this change simply isn't interesting to NT 4 replication.
                //

                } else if ( !LsapReplicateTdoNt4( NotificationNode->OldTrustDirection,
                                                  NotificationNode->OldTrustType ) ) {

                    NotifyNetlogon = FALSE;

                //
                // If this object used to replicated to NT 4,
                //  then this is really an object deletion as far as NT 4 replication
                //  is concerned.
                //

                } else {

                    DeltaTypeToUse = SecurityDbDelete;

                }

            }

            //
            // Now notify netlogon
            //

            if ( NotifyNetlogon ) {
                //
                //  If we knew that the Outbound password property has been changed,
                //  then and only then should we notify netlogon that the underlying global
                //  secret has changed.
                //  However, the change is probably not worth making, because the cost
                //  of not making it is a few extra bytes on the wire.
                //

                LsapDsFixupChangeNotificationForReplicator(
                    TrustedDomainObject,
                    TrustInfo2.Information.Sid,
                    (PUNICODE_STRING) &TrustInfo2.Information.FlatName,
                    NotificationNode->ObjectPath,
                    DeltaTypeToUse,
                    NotificationNode->ReplicatedInChange
                    );

            }
        }
        else if (SecretObject == ObjType)
        {
            LsapDsFixupChangeNotificationForReplicator(
                SecretObject,
                NULL,
                NULL,
                NotificationNode->ObjectPath,
                NotificationNode->DeltaType,
                NotificationNode->ReplicatedInChange
                );
        }
    }

    //
    // Free the allocations...
    //

    _fgu__LSAPR_TRUSTED_DOMAIN_INFO( (PLSAPR_TRUSTED_DOMAIN_INFO)&TrustInfo2,
                                     TrustedDomainFullInformation2Internal );

    LsapFreeNotificationNode( NotificationNode );

    return( RtlNtStatusToDosError( Status ) );
}



NTSTATUS
LsapDsFixupTrustByInfo(
    IN PDSNAME ObjectPath,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 TrustInfo2,
    IN ULONG PosixOffset,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN PSID UserSid,
    IN LUID AuthenticationId,
    IN BOOLEAN ReplicatedInChange,
    IN BOOLEAN ChangeOriginatedInLSA
    )
/*++

Routine Description:

    This function does the fixup of trusted domain objects following notification from the
    Ds.  For created and deleted objects, it involves updating the trust list and notifying
    netlogon and kerberos of changes.  For modifications, verification of correctness is done.
    Upon an object creaton the corresponding SAM account is created. Upon an object deletion
    the corresponding SAM account is delted.

Arguments:

    ObjectPath -- The Ds name of the object that changed

    TrustInfo2 -- The information that is currently available about the trust

    PosixOffset -- Posix offset of the domain.

    DeltaType -- Type of change that happened

    UserSid -- The user that was responsible for making this change

    AuthenticationId -- AuthenticationId of the user making the change

    ReplicatedInChange --  Indicates that the change replicated in instead of being an originating
                           change

    ChangeOriginatedInLSA -- Indicates that the change has originated in LSA as opposed to DS/LDAP

Return Values:

    ERROR_SUCCESS   -- Success

    ERROR_NOT_ENOUGH_MEMORY -- A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAPR_TRUST_INFORMATION TrustInformation;
    BOOLEAN AcquiredListWriteLock = FALSE;
    BOOLEAN TrustLockAcquired = FALSE;

    LsapDsDebugOut(( DEB_FTRACE,
                     "LsapDsFixupTrustByInfo( %ws, %x, %x, ...)\n",
                     ObjectPath ? LsapDsNameFromDsName( ObjectPath ) : L"<null>",
                     TrustInfo2,
                     DeltaType ));

    //
    // If this is a replicated in change,
    //  make sure the TDO has a valid Posix Offset in it.
    //

    if ( ReplicatedInChange &&
         (DeltaType == SecurityDbNew || DeltaType == SecurityDbChange ) ) {

        DOMAIN_SERVER_ROLE ServerRole;

        //
        // Only change the Posix Offset on the PDC.
        //

        Status = SamIQueryServerRole(
                    LsapAccountDomainHandle,
                    &ServerRole
                    );

        if ( NT_SUCCESS(Status) && ServerRole == DomainServerRolePrimary ) {
            BOOLEAN PosixOffsetChanged = FALSE;

            if ( LsapDbDcInRootDomain()) {

                //
                // On a root domain PDC, acquire the trust lock before
                // the rest to ensure no deadlocks if forest trust data
                // needs to be written back to the DS
                //

                LsapDbAcquireLockEx( TrustedDomainObject, LSAP_DB_LOCK );
                TrustLockAcquired = TRUE;
            }

            //
            // If we should have a Posix Offset,
            //  ensure we have one.
            //

            if ( LsapNeedPosixOffset( TrustInfo2->TrustDirection,
                                      TrustInfo2->TrustType ) ) {


                if ( PosixOffset == 0 ) {

                    //
                    // Need to grab the TDL write lock while allocating a Posix Offset
                    //

                    Status = LsapDbAcquireWriteLockTrustedDomainList();

                    if ( NT_SUCCESS(Status)) {
                        AcquiredListWriteLock = TRUE;


                        //
                        // Allocate the next available Posix Offset.
                        //

                        Status = LsapDbAllocatePosixOffsetTrustedDomainList(
                                    &PosixOffset );

                        if ( NT_SUCCESS(Status)) {
                            PosixOffsetChanged = TRUE;
                        }
                    }
                }

            //
            // If we shouldn't have a Posix Offset,
            //  ensure we don't have one.
            //

            } else {
                if ( PosixOffset != 0 ) {
                    PosixOffset = 0;
                    PosixOffsetChanged = TRUE;
                }
            }

            //
            // If we're forcing the Posix Offset to change,
            //  do it now.
            //

            if ( PosixOffsetChanged ) {
                ATTRVAL TDOWriteAttVals[] = {
                    { sizeof(ULONG), (PUCHAR)&PosixOffset},
                };

                ATTR TDOWriteAttrs[] = {
                    { ATT_TRUST_POSIX_OFFSET, {1, &TDOWriteAttVals[0] } },
                };

                ATTRBLOCK TDOWriteAttrBlock = {sizeof(TDOWriteAttrs)/sizeof(TDOWriteAttrs[0]),TDOWriteAttrs};


                //
                // Set the Posix Offset on the TDO
                //

                Status = LsapDsWriteByDsName(
                            ObjectPath,
                            LSAPDS_REPLACE_ATTRIBUTE,
                            &TDOWriteAttrBlock
                            );

                if (!NT_SUCCESS(Status)) {
                    Status = STATUS_SUCCESS;    // This isn't fatal
                }
            }
        }
    }



    switch ( DeltaType ) {
    case SecurityDbNew:

        if (ReplicatedInChange)
        {
            //
            // On a replicated in change notification, insert the trusted domain
            // object into the trusted domain list. This need not be done for the
            // case of an originating change as this is done within the LSA call to
            // create the trusted domain object.
            //

            if ( NT_SUCCESS( LsapDbAcquireWriteLockTrustedDomainList())) {

                Status = LsapDbInsertTrustedDomainList(
                             TrustInfo2,
                             PosixOffset
                             );

                if ( !NT_SUCCESS( Status ) ) {

                    LsapDsDebugOut(( DEB_ERROR,
                                     "LsapDbInsertTrustedDomainList for %wZ failed with 0x%lx\n",
                                     &TrustInfo2->FlatName,
                                     Status ));
                }

                LsapDbReleaseLockTrustedDomainList();
            }
        }
        break;

    case SecurityDbChange:

        //
        // On a replicated in change update the trusted domain List
        //

        if (ReplicatedInChange)
        {
            Status = LsapDbFixupTrustedDomainListEntry(
                            TrustInfo2->Sid,
                            &TrustInfo2->Name,
                            &TrustInfo2->FlatName,
                            TrustInfo2,
                            &PosixOffset );

            if ( !NT_SUCCESS( Status ) ) {


                LsapDsDebugOut(( DEB_ERROR,
                                 "LsapDbFixupTrustedDomainList for %wZ failed with 0x%lx\n",
                                 &TrustInfo2->FlatName,
                                 Status ));
            }
        }
        break;

    case SecurityDbDelete:

        if ( ReplicatedInChange || !ChangeOriginatedInLSA) {

            PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;
            GUID RealTdoGuid;

            //
            // Check to see that the object path is not a mangled name.
            // If it is drop the notification on the floor.
            //
            // If a set of duplicate trusts exist,
            //      we must delete only the good one from the cache
            //

            //
            // Grab the GUID of the real TDO for this named trust.
            //

            Status = LsapDbAcquireReadLockTrustedDomainList();

            if (!NT_SUCCESS(Status)) {
                 break;
            }

            //
            // Lookup the information in the trusted domain list
            //

            Status = LsapDbLookupNameTrustedDomainListEx(
                            &TrustInfo2->Name,
                            &TrustEntry
                            );

            if (!NT_SUCCESS(Status)) {
                LsapDbReleaseLockTrustedDomainList();
                break;
            }

            ASSERT(NULL!=TrustEntry);

            RealTdoGuid = TrustEntry->ObjectGuidInDs;
            LsapDbReleaseLockTrustedDomainList();


            //
            // If this TDO isn't the TDO that we've selected to represent this trust,
            //  then it is the mangled TDO.
            //
            // Totally ignore changes to this mangled TDO.
            //

            if ((!LsapNullUuid(&RealTdoGuid))
                 && (0!=memcmp(&RealTdoGuid, &ObjectPath->Guid, sizeof(GUID))))
            {
              //
              // Error  out. This will cause us to not update the trusted domain list and not
              // provide netlogon notifications
              //

              Status = STATUS_OBJECT_NAME_COLLISION;
              break;
            }

            TrustInformation.Sid = TrustInfo2->Sid;
            RtlCopyMemory( &TrustInformation.Name, &TrustInfo2->FlatName, sizeof( UNICODE_STRING ) );

            if ( NT_SUCCESS( LsapDbAcquireWriteLockTrustedDomainList())) {

                Status = LsapDbDeleteTrustedDomainList( &TrustInformation );

                if ( !NT_SUCCESS( Status ) ) {

                    LsapDsDebugOut(( DEB_ERROR,
                                     "LsapDbDeleteTrustedDomainList for %wZ failed with 0x%lx\n",
                                     &TrustInfo2->FlatName,
                                     Status ));
                }

                LsapDbReleaseLockTrustedDomainList();
            }
        }

        //
        // if a TDO is deleted by LSA, the audit will be generated in
        // the main thread (LsarDeleteObject). However, if a TDO
        // is deleted by LDAP, DS does not call LsarDeleteObject
        // to effect the change in LSA, it simply deletes object
        // and sends a notification. We generate the audit here
        // if the change did not originate in LSA (indicated by
        // the value of ChangeOriginatedInLSA).
        //
        if (( UserSid && LsapAdtAuditingPolicyChanges() ) &&
            (!ReplicatedInChange) &&
            (!ChangeOriginatedInLSA)) {

            Status = LsapAdtTrustedDomainRem(
                         EVENTLOG_AUDIT_SUCCESS,
                         (PUNICODE_STRING) &TrustInfo2->Name,
                         (PSID) TrustInfo2->Sid,
                         UserSid,
                         &AuthenticationId
                         );
        }
        break;

    default:

        //
        // Unsupported delta type
        //

        LsapDsDebugOut(( DEB_ERROR,
                         "LsapDsFixupTrustByInfo received an unsupported delta type of %lu\n",
                         DeltaType ));

    }

    //
    // If necessary, release the Trusted Domain List Write Lock.
    //

    if (AcquiredListWriteLock) {

        LsapDbReleaseLockTrustedDomainList();
        AcquiredListWriteLock = FALSE;
    }

    if ( TrustLockAcquired ) {

        LsapDbReleaseLockEx( TrustedDomainObject, LSAP_DB_LOCK );
    }
    
    return( Status );
}

NTSTATUS
LsapDsInitFixupQueue(
    VOID
    )
{
    InitializeListHead( &LsapFixupList );
    return SafeInitializeCriticalSection( &LsapFixupLock, ( DWORD )LSAP_FIXUP_LOCK_ENUM );
}

DWORD
LsapDsFixupQueueWorker(
    PVOID Ignored
    )
{
    PLSAP_DSFU_NOTIFICATION_NODE Node ;
    PLIST_ENTRY List ;

    SafeEnterCriticalSection( &LsapFixupLock );

    if ( LsapFixupThreadActive )
    {
        SafeLeaveCriticalSection( &LsapFixupLock );

        return 0 ;
    }

    LsapFixupThreadActive = TRUE ;

    while ( !IsListEmpty( &LsapFixupList ) )
    {
        List = RemoveHeadList( &LsapFixupList );

        SafeLeaveCriticalSection( &LsapFixupLock );

        Node = CONTAINING_RECORD( List, LSAP_DSFU_NOTIFICATION_NODE, List );

        LsapDsFixupCallback( Node );

        SafeEnterCriticalSection( &LsapFixupLock );

    }

    LsapFixupThreadActive = FALSE ;

    SafeLeaveCriticalSection( &LsapFixupLock );

    return 0 ;

}

BOOL
LsapDsQueueFixupRequest(
    PLSAP_DSFU_NOTIFICATION_NODE Node
    )
{
    BOOL Ret = TRUE ;

    SafeEnterCriticalSection( &LsapFixupLock );


    if ( LsapFixupThreadActive == FALSE )
    {
        Ret = QueueUserWorkItem( LsapDsFixupQueueWorker, NULL, 0 );
    }

    if ( Ret )
    {
        InsertTailList( &LsapFixupList, &Node->List );
    }

    SafeLeaveCriticalSection( &LsapFixupLock );

    return Ret ;
}


NTSTATUS
LsapNotifyNetlogonOfTrustWithParent(
    VOID
    )
/*++

Routine Description:

    Notifies Netlogon of trust relationship with the parent domain.
    

Arguments:

    None

Returns:

    STATUS_SUCCESS if happy
    STATUS_ error code otherwise

--*/
{
    NTSTATUS Status;
    PLSAPR_FOREST_TRUST_INFO ForestTrustInfo = NULL;

    ASSERT( SamIIsRebootAfterPromotion());

    //
    // Locate the trust link to the parent
    //

    Status = LsaIQueryForestTrustInfo(
                 LsapPolicyHandle,
                 &ForestTrustInfo
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_ERROR,
                         "LsapNotifyNetlogonOfTrustWithParent got error 0x%lx back from LsaIQueryForestTrustInfo\n",
                         Status ));

        goto Cleanup;
    }

    ASSERT( ForestTrustInfo );

    if ( ForestTrustInfo->ParentDomainReference == NULL ) {

        //
        // We're the root domain of the forest.  Nothing to do.
        //

        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Notify netlogon of the trust relationship changing.
    // Nothing changed, but this will force the necessary replication.
    //

    Status = LsapDsFixupChangeNotificationForReplicator(
                 TrustedDomainObject,
                 ForestTrustInfo->ParentDomainReference->DomainSid,
                 &ForestTrustInfo->ParentDomainReference->FlatName,
                 NULL,
                 SecurityDbChange,
                 FALSE
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_ERROR,
                         "LsapNotifyNetlogonOfTrustWithParent got error 0x%lx back from LsapDsFixupChangeNotificationForReplicator\n",
                         Status ));

        goto Cleanup;
    }

Cleanup:

    LsaIFreeForestTrustInfo( ForestTrustInfo );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\netlogon.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    netlogon.c

Abstract:

    Netlogon routines to access the DS.

    Rightfully these routines belong in netlogon.  However, the current
    interface to the DS is complex enough that the support routines
    are substantial.  Those routines are already duplicated in SAM and LSA.
    Rather than introduce a new set, this module exports exactly what is
    needed by Netlogon.

Author:

    Cliff Van Dyke   (CliffV)       May 7, 1997

Environment:

    User Mode

Revision History:

--*/

#include <lsapch2.h>
#include <dbp.h>
// #include <ntdsa.h>

BOOLEAN
DsIsBeingBackSynced();

NTSTATUS
LsapDsReadSubnetObj(
    IN PDSNAME SubnetObjName,
    OUT PLSAP_SUBNET_INFO_ENTRY SubnetInfoEntry
    )
/*++

Routine Description:

    This function will read the specified subnet object and fill in the entry.

Arguments:

    SubnetObjName - DsName of the subnet object

    SubnetInfoEntry - Subnet Information to return

Returns:

    STATUS_SUCCESS - Success

    STATUS_INVALID_PARAMETER - A bad InformationClass level was encountered

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed

--*/
{
    NTSTATUS Status;
    ULONG i;
    PDSNAME DsName;

    //
    // Build the list of attribute IDs we need based on the information
    // class
    //
    ATTR SubnetAttrVals[] = {
        {ATT_SITE_OBJECT, {0, NULL} },
        };

    ATTRBLOCK   ReadBlock, ReturnedBlock = { 0 };


    WCHAR   RdnBuffer[MAX_RDN_SIZE + 1];
    ULONG   RdnLen;
    ATTRTYP RdnType;

    LsapEnterFunc( "LsapDsReadSubnetObj" );

    //
    // The subnet name is the RDN of the subnet object itself.
    //
    // Return it to the caller.
    //

    Status = LsapDsMapDsReturnToStatus( GetRDNInfoExternal(
                                                    SubnetObjName,
                                                    RdnBuffer,
                                                    &RdnLen,
                                                    &RdnType ) );

    if ( NT_SUCCESS( Status ) ) {

        LSAPDS_ALLOC_AND_COPY_STRING_TO_UNICODE_ON_SUCCESS(
            Status,
            &SubnetInfoEntry->SubnetName,
            RdnBuffer,
            RdnLen*sizeof(WCHAR) );

    }

    //
    // Read the required attributes from the subnet object
    //

    if ( NT_SUCCESS( Status ) ) {
        ReadBlock.attrCount = sizeof(SubnetAttrVals) / sizeof(ATTR);
        ReadBlock.pAttr = SubnetAttrVals;

        Status = LsapDsReadByDsName( SubnetObjName,
                                     0,
                                     &ReadBlock,
                                     &ReturnedBlock );
        //
        // Allow for the case where the SiteObject attribute doesn't exist.
        //

        if ( Status == STATUS_NOT_FOUND ) {
            ReturnedBlock.attrCount = 0;
            Status = STATUS_SUCCESS;
        }
    }


    //
    // Now, marshal them...
    //
    if ( NT_SUCCESS( Status ) ) {

        for ( i = 0;
              i < ReturnedBlock.attrCount && NT_SUCCESS( Status );
              i++) {

            switch ( ReturnedBlock.pAttr[i].attrTyp ) {
            case ATT_SITE_OBJECT:

                // Attribute is single valued, but ...
                if ( ReturnedBlock.pAttr[i].AttrVal.valCount >= 1 ) {

                    DsName = LSAP_DS_GET_DS_ATTRIBUTE_AS_DSNAME( &ReturnedBlock.pAttr[i] );

                    //
                    // The subnet name is the RDN of the subnet object itself.
                    //
                    // Return it to the caller.
                    //

                    Status = LsapDsMapDsReturnToStatus( GetRDNInfoExternal(
                                                                    DsName,
                                                                    RdnBuffer,
                                                                    &RdnLen,
                                                                    &RdnType ) );

                    if ( NT_SUCCESS( Status ) ) {

                        LSAPDS_ALLOC_AND_COPY_STRING_TO_UNICODE_ON_SUCCESS(
                            Status,
                            &SubnetInfoEntry->SiteName,
                            RdnBuffer,
                            RdnLen*sizeof(WCHAR) );

                    }

                }
                break;

            default:

                Status = STATUS_INVALID_PARAMETER;
                break;

            }
        }

    }

    LsapExitFunc( "LsapDsReadSubnetObj", Status );

    return( Status );
}

NTSTATUS
LsapDsReadSiteObj(
    IN PDSNAME SiteObjName,
    OUT PLSAP_SITE_INFO_ENTRY SiteInfoEntry
    )
/*++

Routine Description:

    This function will read the specified site object and fill in the entry.

Arguments:

    SiteObjName - DsName of the site object

    SitesInfoEntry - Site Information to return

Returns:

    STATUS_SUCCESS - Success

    STATUS_INVALID_PARAMETER - A bad InformationClass level was encountered

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed

--*/
{
    NTSTATUS Status;

    WCHAR   RdnBuffer[MAX_RDN_SIZE + 1];
    ULONG   RdnLen;
    ATTRTYP RdnType;

    LsapEnterFunc( "LsapDsReadSiteObj" );

    //
    // The site name is the RDN of the site object itself.
    //
    // Return it to the caller.
    //

    Status = LsapDsMapDsReturnToStatus( GetRDNInfoExternal(
                                                    SiteObjName,
                                                    RdnBuffer,
                                                    &RdnLen,
                                                    &RdnType ) );

    if ( NT_SUCCESS( Status ) ) {

        LSAPDS_ALLOC_AND_COPY_STRING_TO_UNICODE_ON_SUCCESS(
            Status,
            &SiteInfoEntry->SiteName,
            RdnBuffer,
            RdnLen*sizeof(WCHAR) );

    }

    LsapExitFunc( "LsapDsReadSiteObj", Status );

    return( Status );
}

NTSTATUS
LsaIGetSiteName(
    OUT PLSAP_SITENAME_INFO *SiteNameInformation
    )
/*++

Routine Description:

    This routine returns the GUID of this DSA and the SiteName of the
    site this DSA is in.

Arguments:

    SiteNameInformation - Returns a pointer to the site name information.
        Buffer should be freed using LsaIFree_LSAP_SITENAME_INFO;

Returns:

    STATUS_SUCCESS - Success

    STATUS_INVALID_DOMAIN_STATE - The Ds is not installed or running at the time of the call

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed

--*/

{
    NTSTATUS Status;
    BINDARG BindArg;
    BINDRES *BindRes;
    PLSAP_SITENAME_INFO SiteNameInfo = NULL;
    PDSNAME SiteDsName = NULL;
    BOOLEAN CloseTransaction = FALSE;
    ULONG DsaOptions = 0;

    //
    // The list of attributes we need from the DSA object
    //
    ATTR DsaAttrVals[] = {
        {ATT_OPTIONS, {0, NULL} },
        };

    ATTRBLOCK   ReadBlock, ReturnedBlock;


    WCHAR   RdnBuffer[MAX_RDN_SIZE + 1];
    ULONG   RdnLen;
    ATTRTYP RdnType;
    ULONG i;

    LsarpReturnCheckSetup();

    LsapEnterFunc( "LsaIGetSiteName" );

    //
    // Make sure the DS is installed
    //
    if ( !LsaDsStateInfo.UseDs ) {
        LsapExitFunc( "LsaIGetSiteName", STATUS_INVALID_DOMAIN_STATE );
        return STATUS_INVALID_DOMAIN_STATE;
    }

    //
    //  See if we already have a transaction going
    //
    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                            LSAP_DB_DS_OP_TRANSACTION,
                                        NullObject,
                                        &CloseTransaction );

    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    //
    // Get the DSA object's DSNAME.
    //

    RtlZeroMemory( &BindArg, sizeof(BindArg) );
    Status = LsapDsMapDsReturnToStatus( DirBind( &BindArg,
                                                 &BindRes ));
    LsapDsContinueTransaction();

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }



    //
    // Read the required attributes from the DSA object
    //

    ReadBlock.attrCount = sizeof(DsaAttrVals) / sizeof(ATTR);
    ReadBlock.pAttr = DsaAttrVals;

    Status = LsapDsReadByDsName( BindRes->pCredents,
                                 LSAPDS_READ_NO_LOCK,
                                 &ReadBlock,
                                 &ReturnedBlock );

    if ( Status == STATUS_UNSUCCESSFUL ) {

        Status = STATUS_NOT_FOUND;
    }

    //
    // If the options attribute exists,
    //  get its value.
    //
    if ( Status != STATUS_NOT_FOUND ) {
        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }


        //
        // Get the attributes from the DSA object
        //

        for ( i = 0;
              i < ReturnedBlock.attrCount && NT_SUCCESS( Status );
              i++) {


            //
            // Handle the DSA Options attributes.
            //
            switch ( ReturnedBlock.pAttr[i].attrTyp ) {
            case ATT_OPTIONS:

                // Attribute is single valued, but ...
                if ( ReturnedBlock.pAttr[i].AttrVal.valCount >= 1 ) {
                    DsaOptions = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &ReturnedBlock.pAttr[ i ] );
                }
                break;

            default:

                Status = STATUS_INVALID_PARAMETER;
                break;

            }
        }
    }



    //
    // Compute the name of the site this DSA is in.
    //  (Simply trim three names off the DSA's DSNAME )
    //

    SiteDsName = LsapAllocateLsaHeap( BindRes->pCredents->structLen );

    if ( SiteDsName == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if ( TrimDSNameBy( BindRes->pCredents, 3, SiteDsName ) != 0 ) {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }


    //
    // The site name is the RDN of the site object.
    //

    Status = LsapDsMapDsReturnToStatus( GetRDNInfoExternal(
                                                    SiteDsName,
                                                    RdnBuffer,
                                                    &RdnLen,
                                                    &RdnType ) );

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }


    //
    // Allocate a buffer to return to the caller.
    //

    SiteNameInfo = LsapAllocateLsaHeap( sizeof(LSAP_SITENAME_INFO) );

    if ( SiteNameInfo == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Fill it in.
    //

    LSAPDS_ALLOC_AND_COPY_STRING_TO_UNICODE_ON_SUCCESS(
        Status,
        &SiteNameInfo->SiteName,
        RdnBuffer,
        RdnLen*sizeof(WCHAR) );

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    SiteNameInfo->DsaGuid = BindRes->pCredents->Guid;
    SiteNameInfo->DsaOptions = DsaOptions;


    Status = STATUS_SUCCESS;

    //
    // Free locally used resources
    //
Cleanup:
    //
    // Destruction of the thread state will delete the memory alloced by the SearchNonUnique call
    //
    LsapDsDeleteAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                     LSAP_DB_DS_OP_TRANSACTION,
                                 NullObject,
                                 CloseTransaction );

    if ( SiteDsName != NULL ) {
        LsapFreeLsaHeap( SiteDsName );
    }

    if ( !NT_SUCCESS( Status ) ) {
        LsaIFree_LSAP_SITENAME_INFO( SiteNameInfo );
    } else {
        *SiteNameInformation = SiteNameInfo;
    }

    LsarpReturnPrologue();

    LsapExitFunc( "LsaIGetSiteName", Status );

    return( Status );
}

NTSTATUS
LsaIQuerySiteInfo(
    OUT PLSAP_SITE_INFO *SiteInformation
    )
/*++

Routine Description:

    This routine enumerates all of the sites objects and returns their names.

Arguments:

    SiteInformation - Returns a pointer to the site information.
        Buffer should be freed using LsaIFree_LSAP_SITE_INFO;

Returns:

    STATUS_SUCCESS - Success

    STATUS_INVALID_DOMAIN_STATE - The Ds is not installed or running at the time of the call

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed

--*/

{
    NTSTATUS  Status;
    ULONG DsNameLen;
    ULONG DsNameSize;
    PDSNAME DsSiteContainer = NULL;
    PDSNAME  *DsNames = NULL;
    ULONG Items;
    ULONG i;
    ATTRBLOCK *ReadAttrs;
    BOOLEAN CloseTransaction = FALSE;
    PLSAP_SITE_INFO SiteInfo = NULL;
    BOOLEAN TsActive = FALSE;

    ULONG Size;
    ULONG ClassId;

    //
    // Attributes we want to look for
    //
    ATTRVAL SiteAttVals[] = {
    { sizeof(ULONG), (PUCHAR)&ClassId},
    };

    ATTR SiteAttrs[] = {
        { ATT_OBJECT_CLASS, {1, &SiteAttVals[0] } },
        };

    LsarpReturnCheckSetup();

    ClassId = CLASS_SITE;

    //
    // Make sure the DS is installed
    //
    if ( !LsaDsStateInfo.UseDs ) {
        return STATUS_INVALID_DOMAIN_STATE;
    }

    LsapEnterFunc( "LsaIQuerySiteInfo" );

    //
    // Build the name of the Site container.
    //
    // DSNameSizeFromLen doesn't want the trailing NULL that we'll give it by using
    // the sizeof operators.  It evens out, though, since we don't bother adding in the
    // comma seperator that should be there as well.
    //

    DsNameLen = wcslen( LsaDsStateInfo.DsConfigurationContainer->StringName ) +
                wcslen( LSAP_DS_SITES_CONTAINER ) + 1;
    DsNameSize = DSNameSizeFromLen( DsNameLen );

    DsSiteContainer = LsapAllocateLsaHeap( DsNameSize );

    if ( DsSiteContainer == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    } else {

        DsSiteContainer->structLen = DsNameSize;
        DsSiteContainer->NameLen = DsNameLen;

        swprintf( DsSiteContainer->StringName,
                  L"%ws,%ws",
                  LSAP_DS_SITES_CONTAINER,
                  LsaDsStateInfo.DsConfigurationContainer->StringName );

    }



    //
    //  See if we already have a transaction going
    //
    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                            LSAP_DB_DS_OP_TRANSACTION,
                                        NullObject,
                                        &CloseTransaction );

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }
    TsActive = TRUE;;



    //
    // Search for the site objects
    //
    // Site objects must be directly in the sites container.
    //

    Status = LsapDsSearchNonUnique( LSAPDS_SEARCH_LEVEL | LSAPDS_OP_NO_TRANS,
                                    DsSiteContainer,
                                    SiteAttrs,
                                    sizeof(SiteAttrs)/sizeof(SiteAttrs[0]),
                                    &DsNames,
                                    &Items );

    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        Items = 0;
        Status = STATUS_SUCCESS;
        DsNames = NULL;
    }
    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }


    //
    // Allocate a list of attribute blocks big enough to hold them all
    //

    Size = sizeof( LSAP_SITE_INFO ) +
           Items * sizeof( LSAP_SITE_INFO_ENTRY );

    SiteInfo = LsapAllocateLsaHeap( Size );

    if ( SiteInfo == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory( SiteInfo, Size );
    SiteInfo->SiteCount = Items;

    //
    // Read each of the enumerated site objects
    //
    for ( i = 0; i < Items; i++ ) {

        Status = LsapDsReadSiteObj( DsNames[ i ] ,
                                      &SiteInfo->Sites[i] );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }
    }

    Status = STATUS_SUCCESS;

    //
    // Free locally used resources
    //
Cleanup:
    //
    // Destruction of the thread state will delete the memory alloced by the SearchNonUnique call
    //
    if ( TsActive ) {
        LsapDsDeleteAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                         LSAP_DB_DS_OP_TRANSACTION,
                                     NullObject,
                                     CloseTransaction );
    }

    if ( DsSiteContainer != NULL ) {
        LsapFreeLsaHeap( DsSiteContainer );
    }

    if ( DsNames != NULL ) {
        LsapFreeLsaHeap( DsNames );
    }

    if ( !NT_SUCCESS( Status ) ) {
        LsaIFree_LSAP_SITE_INFO( SiteInfo );
    } else {
        *SiteInformation = SiteInfo;
    }

    LsarpReturnPrologue();
    LsapExitFunc( "LsaIQuerySiteInfo", Status );

    return( Status );
}


VOID
LsaIFree_LSAP_SITE_INFO(
    IN PLSAP_SITE_INFO SiteInfo
    )
/*++

Routine Description:

    This routine free the LSAP_SITE_INFO strcture returned from
    LsaIQuerySiteInfo.

Arguments:

    SiteInformation - Specifies a pointer to the site information.

Returns:

    None.

--*/
{
    ULONG i;
    if ( SiteInfo != NULL ) {

        for ( i=0; i<SiteInfo->SiteCount; i++) {
            if ( SiteInfo->Sites[i].SiteName.Buffer != NULL ) {
                LsapFreeLsaHeap( SiteInfo->Sites[i].SiteName.Buffer );
            }
        }

        LsapFreeLsaHeap( SiteInfo );
    }
}


NTSTATUS
LsaIQuerySubnetInfo(
    OUT PLSAP_SUBNET_INFO *SubnetInformation
    )
/*++

Routine Description:

    This routine enumerates all of the subnet objects returns their names
    and the names of the sites they are in.

Arguments:

    SubnetInformation - Returns a pointer to the subnet information.
        Buffer should be freed using LsaIFree_LSAP_SUBNET_INFO;

Returns:

    STATUS_SUCCESS - Success

    STATUS_INVALID_DOMAIN_STATE - The Ds is not installed or running at the time of the call

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed

--*/

{
    NTSTATUS  Status;
    ULONG DsNameLen;
    ULONG DsNameSize;
    PDSNAME DsSubnetContainer = NULL;
    PDSNAME DsSiteContainer = NULL;
    PDSNAME  *DsNames = NULL;
    ULONG Items;
    ULONG i;
    ATTRBLOCK *ReadAttrs;
    BOOLEAN CloseTransaction = FALSE;
    BOOLEAN TsActive = FALSE;
    PLSAP_SUBNET_INFO SubnetInfo = NULL;

    ULONG Size;
    ULONG ClassId;

    //
    // Attributes we want to look for
    //
    ATTRVAL SubnetAttVals[] = {
    { sizeof(ULONG), (PUCHAR)&ClassId},
    };

    ATTR SubnetAttrs[] = {
        { ATT_OBJECT_CLASS, {1, &SubnetAttVals[0] } },
        };

    LsarpReturnCheckSetup();

    ClassId = CLASS_SUBNET;

    //
    // Make sure the DS is installed
    //
    if ( !LsaDsStateInfo.UseDs ) {
        return STATUS_INVALID_DOMAIN_STATE;
    }

    LsapEnterFunc( "LsaIQuerySubnetInfo" );

    //
    // Build the name of the Subnet container.
    //
    // DSNameSizeFromLen doesn't want the trailing NULL that we'll give it by using
    // the sizeof operators.  It evens out, though, since we don't bother adding in the
    // comma seperator that should be there as well.
    //

    DsNameLen = wcslen( LsaDsStateInfo.DsConfigurationContainer->StringName ) +
                wcslen( LSAP_DS_SUBNET_CONTAINER ) + 1;
    DsNameSize = DSNameSizeFromLen( DsNameLen );

    DsSubnetContainer = LsapAllocateLsaHeap( DsNameSize );

    if ( DsSubnetContainer == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    } else {

        DsSubnetContainer->structLen = DsNameSize;
        DsSubnetContainer->NameLen = DsNameLen;

        swprintf( DsSubnetContainer->StringName,
                  L"%ws,%ws",
                  LSAP_DS_SUBNET_CONTAINER,
                  LsaDsStateInfo.DsConfigurationContainer->StringName );

    }


    //
    //  See if we already have a transaction going
    //
    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                            LSAP_DB_DS_OP_TRANSACTION,
                                        NullObject,
                                        &CloseTransaction );

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }
    TsActive = TRUE;


    //
    // Search for the subnet objects
    //
    // Subnet objects must be directly in the subnet container.
    //
    Status = LsapDsSearchNonUnique( LSAPDS_SEARCH_LEVEL | LSAPDS_OP_NO_TRANS,
                                   DsSubnetContainer,
                                   SubnetAttrs,
                                   sizeof(SubnetAttrs)/sizeof(SubnetAttrs[0]),
                                   &DsNames,
                                   &Items
                                   );

    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        Items = 0;
        Status = STATUS_SUCCESS;
        DsNames = NULL;
    }
    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }


    //
    // Allocate a list of attribute blocks big enough to hold them all
    //

    Size = sizeof( LSAP_SUBNET_INFO ) +
           Items * sizeof( LSAP_SUBNET_INFO_ENTRY );

    SubnetInfo = LsapAllocateLsaHeap( Size );

    if ( SubnetInfo == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory( SubnetInfo, Size );
    SubnetInfo->SubnetCount = Items;

    //
    // Read each of the enumerated subnet objects
    //
    for ( i = 0; i < Items; i++ ) {

        Status = LsapDsReadSubnetObj( DsNames[ i ] ,
                                      &SubnetInfo->Subnets[i] );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }
    }

    if ( DsNames != NULL ) {
        LsapFreeLsaHeap( DsNames );
        DsNames = NULL;
    }


    //
    // Determine the number of site objects.
    //
    // The caller wants to be able to special case the single site case in
    // for enterprises that's aren't interested in subnet objects.
    //

    {

        //
        // Build the name of the Site container.
        //
        // DSNameSizeFromLen doesn't want the trailing NULL that we'll give it by using
        // the sizeof operators.  It evens out, though, since we don't bother adding in the
        // comma seperator that should be there as well.
        //

        DsNameLen = wcslen( LsaDsStateInfo.DsConfigurationContainer->StringName ) +
                    wcslen( LSAP_DS_SITES_CONTAINER ) + 1;
        DsNameSize = DSNameSizeFromLen( DsNameLen );

        DsSiteContainer = LsapAllocateLsaHeap( DsNameSize );

        if ( DsSiteContainer == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;

        } else {

            DsSiteContainer->structLen = DsNameSize;
            DsSiteContainer->NameLen = DsNameLen;

            swprintf( DsSiteContainer->StringName,
                      L"%ws,%ws",
                      LSAP_DS_SITES_CONTAINER,
                      LsaDsStateInfo.DsConfigurationContainer->StringName );

        }


        //
        // Search for the site objects
        //
        // Site objects must be directly in the sites container.
        //
        ClassId = CLASS_SITE;

        Status = LsapDsSearchNonUnique( LSAPDS_SEARCH_LEVEL | LSAPDS_OP_NO_TRANS,
                                        DsSiteContainer,
                                        SubnetAttrs,
                                        sizeof(SubnetAttrs)/sizeof(SubnetAttrs[0]),
                                        &DsNames,
                                        &Items );

        if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
            Items = 0;
            Status = STATUS_SUCCESS;
            DsNames = NULL;
        }
        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }

        //
        // Simply tell the caller the number of sites
        //

        SubnetInfo->SiteCount = Items;
    }
    Status = STATUS_SUCCESS;

    //
    // Free locally used resources
    //
Cleanup:
    //
    // Destruction of the thread state will delete the memory alloced by the SearchNonUnique call
    //
    if ( TsActive ) {
        LsapDsDeleteAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                         LSAP_DB_DS_OP_TRANSACTION,
                                     NullObject,
                                     CloseTransaction );
    }

    if ( DsSubnetContainer != NULL ) {
        LsapFreeLsaHeap( DsSubnetContainer );
    }

    if ( DsSiteContainer != NULL ) {
        LsapFreeLsaHeap( DsSiteContainer );
    }

    if ( DsNames != NULL ) {
        LsapFreeLsaHeap( DsNames );
    }

    if ( !NT_SUCCESS( Status ) ) {
        LsaIFree_LSAP_SUBNET_INFO( SubnetInfo );
    } else {
        *SubnetInformation = SubnetInfo;
    }

    LsarpReturnPrologue();
    LsapExitFunc( "LsaIQuerySubnetInfo", Status );

    return( Status );
}

VOID
LsaIFree_LSAP_SUBNET_INFO(
    IN PLSAP_SUBNET_INFO SubnetInfo
    )
/*++

Routine Description:

    This routine free the LSAP_SUBNET_INFO strcture returned from
    LsaIQuerySubnetInfo.

Arguments:

    SubnetInformation - Specifies a pointer to the subnet information.

Returns:

    None.

--*/
{
    ULONG i;
    if ( SubnetInfo != NULL ) {

        for ( i=0; i<SubnetInfo->SubnetCount; i++) {
            if ( SubnetInfo->Subnets[i].SubnetName.Buffer != NULL ) {
                LsapFreeLsaHeap( SubnetInfo->Subnets[i].SubnetName.Buffer );
            }
            if ( SubnetInfo->Subnets[i].SiteName.Buffer != NULL ) {
                LsapFreeLsaHeap( SubnetInfo->Subnets[i].SiteName.Buffer );
            }
        }

        LsapFreeLsaHeap( SubnetInfo );
    }
}

VOID
LsaIFree_LSAP_SITENAME_INFO(
    IN PLSAP_SITENAME_INFO SiteNameInfo
    )
/*++

Routine Description:

    This routine frees the LSAP_SITENAME_INFO strcture returned from
    LsaIGetSiteName.

Arguments:

    SitenameInfo - Specifies a pointer to the sitename information.

Returns:

    None.

--*/
{
    ULONG i;
    if ( SiteNameInfo != NULL ) {

        if ( SiteNameInfo->SiteName.Buffer != NULL ) {
            LsapFreeLsaHeap( SiteNameInfo->SiteName.Buffer );
        }
        LsapFreeLsaHeap( SiteNameInfo );
    }
}

BOOLEAN
LsaIIsDsPaused(
    VOID
    )
/*++

Routine Description:

    This routine determines DS wants us to avoid advertising it.

    The only current reason is if the DS is backsyncing after a restore.

Arguments:

    None

Returns:

    TRUE: The DS is paused.
    FALSE: The DS is not paused

--*/
{
    //
    // Simply return TRUE if the DS is backsyncing.
    //
    if ( SampUsingDsData() ) {

        return DsIsBeingBackSynced();
    }

    return FALSE;
}


NTSTATUS
LsaISetClientDnsHostName(
    IN PWSTR ClientName,
    IN PWSTR ClientDnsHostName OPTIONAL,
    IN POSVERSIONINFOEXW OsVersionInfo OPTIONAL,
    IN PWSTR OsName OPTIONAL,
    OUT PWSTR *OldDnsHostName OPTIONAL
    )
/*++

Routine Description:

    This routine will update the DnsHostName on the specified client object if it is
    different from the one alread on the object

Arguments:

    ClientName - Name of the client

    DnsHostName - Dns host name that should be on the client
        If not specified, the Dns Host name attribute will be removed from the object.
        However, if OldDnsHostName is specified, this parameter will be completely
        ignored.

    OsVersionInfo - Version Info of the client
        If not specified, the version attributes will be removed from the object.

    OsName - Operation System name of the client
        If not specified, the operating system name will be removed from the object.

    OldDnsHostName - If specified, this parameter will returns a pointer to the
        current DNS Host Name on the computer object.
        A NULL pointer is returned if there is no current DNS Host Name.
        This buffer should be freed using MIDL_user_free.

Returns:

    STATUS_SUCCESS - Success

    STATUS_OBJECT_NAME_NOT_FOUND - No such client was found

--*/
{
    NTSTATUS Status;
    NTSTATUS SavedStatus = STATUS_SUCCESS;
    PDSNAME ServerPath;
    PDSNAME *MachinePaths = NULL;
    ULONG MachinePathCount;
    ULONG MachinePathIndex;
    ATTRBLOCK AttrBlock, Results, Results2, Results3;

    PBYTE AllocatedBuffer = NULL;
    PWSTR SamName;
    ULONG SamNameSize;
    PWSTR OsVersion;
    ULONG OsVersionSize;

    ATTRVAL ReplaceVals[ LsapDsMachineClientSetAttrsCount ];
    ATTR ReplaceAttributes[ LsapDsMachineClientSetAttrsCount ];
    ATTRBLOCK ReplaceAttrBlock;
    ATTR LocalSamAccountAttr;

    ATTRVAL RemoveVals[ LsapDsMachineClientSetAttrsCount ];
    ATTR RemoveAttributes[ LsapDsMachineClientSetAttrsCount ];
    ATTRBLOCK RemoveAttrBlock;

    BOOLEAN CloseTransaction = FALSE;
    BOOLEAN TsActive = FALSE;

    PWSTR CurrentServerDnsHostName;
    ULONG CurrentServerDnsHostNameLength;
    PWSTR CurrentComputerDnsHostName = NULL;
    ULONG CurrentComputerDnsHostNameLength = 0;
    ULONG i;

    struct _AttributesToUpdate {
        PWSTR CurrentValue;
        ULONG CurrentValueLength;
        PWSTR NewValue;
    } AttributesToUpdate[LsapDsMachineClientSetAttrsCount];

//
// The indices below must match the order of the element of LsapDsMachineClientSetAttrs
//
#define ATU_HOST_INDEX                   0
#define ATU_OS_INDEX                     1
#define ATU_OS_VERSION_INDEX             2
#define ATU_OS_SERVICE_PACK_INDEX        3
#define ATU_SERVICE_PRINCIPAL_NAME_INDEX 4

    LsapEnterFunc( "LsaISetClientDnsHostName" );

    //
    // Initialization
    //

    if ( ARGUMENT_PRESENT( OldDnsHostName )) {
        *OldDnsHostName = NULL;
    }
    RtlZeroMemory( &AttributesToUpdate, sizeof(AttributesToUpdate) );

    //
    // If we haven't initalized the Ds names, we might as well bail
    //
    if ( !LsaDsStateInfo.DsRoot ) {

        return( STATUS_UNSUCCESSFUL );
    }

    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                            LSAP_DB_DS_OP_TRANSACTION,
                                        NullObject,
                                        &CloseTransaction );

    if ( !NT_SUCCESS( Status ) ) {
        goto SetDnsHostNameEnd;
    }
    TsActive = TRUE;


    //
    // Allocate a buffer for all of the temporary storage for this routine
    //

    SamNameSize = (wcslen( ClientName ) + 2) * sizeof(WCHAR);
    OsVersionSize = (32+1+32+2+32+2) * sizeof(WCHAR);

    AllocatedBuffer = LsapAllocateLsaHeap( SamNameSize +
                                           OsVersionSize );


    if ( AllocatedBuffer == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SetDnsHostNameEnd;
    }

    SamName = (PWSTR)(AllocatedBuffer);
    OsVersion = (PWSTR)(SamName + SamNameSize);


    //
    // Compute the new value of all of the attributes to set.
    //

    AttributesToUpdate[ATU_OS_INDEX].NewValue = OsName;
    if ( OsVersionInfo != NULL ) {

        AttributesToUpdate[ATU_OS_VERSION_INDEX].NewValue = OsVersion;
        if ( OsVersionInfo->dwBuildNumber == 0 ) {
            swprintf( AttributesToUpdate[ATU_OS_VERSION_INDEX].NewValue,
                      L"%ld.%ld",
                      OsVersionInfo->dwMajorVersion,
                      OsVersionInfo->dwMinorVersion );
        } else {
            swprintf( AttributesToUpdate[ATU_OS_VERSION_INDEX].NewValue,
                      L"%ld.%ld (%ld)",
                      OsVersionInfo->dwMajorVersion,
                      OsVersionInfo->dwMinorVersion,
                      OsVersionInfo->dwBuildNumber );
        }

        if ( OsVersionInfo->szCSDVersion[0] != L'\0' ) {
            AttributesToUpdate[ATU_OS_SERVICE_PACK_INDEX].NewValue = OsVersionInfo->szCSDVersion;
        }
    }

    //
    // Only update the DnsHostName if the client isn't going to
    //
    if ( !ARGUMENT_PRESENT( OldDnsHostName )) {
        AttributesToUpdate[ATU_HOST_INDEX].NewValue = ClientDnsHostName;
    }

    //
    // Find the objects whose computer name is the one we were given...
    //

    swprintf( SamName, L"%ws$", ClientName );

    RtlCopyMemory( &LocalSamAccountAttr, &LsapDsAttrs[LsapDsAttrSamAccountName], sizeof( ATTR ) );
    LSAP_DS_SET_DS_ATTRIBUTE_STRING( &LocalSamAccountAttr, SamName );

    Status = LsapDsSearchNonUnique( LSAPDS_OP_NO_TRANS,
                                    LsaDsStateInfo.DsRoot,
                                    &LocalSamAccountAttr,
                                    1,
                                    &MachinePaths,
                                    &MachinePathCount );

    if ( !NT_SUCCESS( Status ) ) {
        goto SetDnsHostNameEnd;
    }

    //
    // Process each of the objects by that name
    //

    for ( MachinePathIndex=0; MachinePathIndex<MachinePathCount; MachinePathIndex++ ) {
        PDSNAME MachinePath;

        MachinePath = MachinePaths[MachinePathIndex];


        //
        // Read the current "Client Set" attributes name from the machine object
        //
        AttrBlock.attrCount = LsapDsMachineClientSetAttrsCount;
        AttrBlock.pAttr = LsapDsMachineClientSetAttrs;

        Status = LsapDsReadByDsName( MachinePath,
                                     0,
                                     &AttrBlock,
                                     &Results );

        if ( Status == STATUS_NOT_FOUND ) {
            Results.attrCount = 0;
            Status = STATUS_SUCCESS;
        }

        if ( !NT_SUCCESS( Status ) ) {
            if ( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
            }
            continue;
        }


        //
        // Loop through the each attribute returned from the DS
        //
        for ( i = 0; i < Results.attrCount; i++ ) {
            ULONG j;

            //
            // Loop through the list of attributes we understand
            //
            for ( j=0; j<LsapDsMachineClientSetAttrsCount; j++ ) {


                if ( Results.pAttr[i].attrTyp == LsapDsMachineClientSetAttrs[j].attrTyp ) {


                    // Attribute is single valued, but ...
                    if ( Results.pAttr[i].AttrVal.valCount >= 1 ) {
                        //
                        //
                        AttributesToUpdate[j].CurrentValue =
                            LSAP_DS_GET_DS_ATTRIBUTE_AS_PWSTR(&Results.pAttr[ i ] );
                        // length in count of characters.
                        AttributesToUpdate[j].CurrentValueLength =
                            LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( &Results.pAttr[ i ] ) / sizeof( WCHAR );

                        //
                        // If this is the DnsHostName attribute,
                        //  and the caller doesn't want us to set it,
                        //  simply remember the current value.
                        //

                        if ( Results.pAttr[i].attrTyp == ATT_DNS_HOST_NAME &&
                             ARGUMENT_PRESENT( OldDnsHostName )) {

                            if ( CurrentComputerDnsHostName == NULL &&
                                 AttributesToUpdate[j].CurrentValueLength != 0 ) {

                                CurrentComputerDnsHostName = MIDL_user_allocate( AttributesToUpdate[j].CurrentValueLength * sizeof(WCHAR) + sizeof(WCHAR) );
                                if ( CurrentComputerDnsHostName == NULL ) {
                                    if ( SavedStatus == STATUS_SUCCESS ) {
                                        SavedStatus = STATUS_INSUFFICIENT_RESOURCES;
                                    }
                                } else {
                                    CurrentComputerDnsHostNameLength = AttributesToUpdate[j].CurrentValueLength;
                                    RtlCopyMemory( CurrentComputerDnsHostName,
                                                   AttributesToUpdate[j].CurrentValue,
                                                   AttributesToUpdate[j].CurrentValueLength * sizeof(WCHAR) );
                                    CurrentComputerDnsHostName[CurrentComputerDnsHostNameLength] = L'\0';
                                }

                            }

                            //
                            // Don't change the value on the computer object.
                            //

                            AttributesToUpdate[j].CurrentValue = NULL;
                            AttributesToUpdate[j].CurrentValueLength = 0;

                        }

                        //
                        // If this is the ServerPrincipalName attribute, we are
                        //  prepared to remove it for NT3.5 and NT4 clients.
                        //  However, don't touch this attribute if there is any
                        //  doubt about the OS version that the client runs.
                        //

                        if ( Results.pAttr[i].attrTyp == ATT_SERVICE_PRINCIPAL_NAME &&

                             (OsVersionInfo == NULL ||
                              (OsVersionInfo->dwMajorVersion != 3 &&
                               OsVersionInfo->dwMajorVersion != 4)) ){

                            AttributesToUpdate[j].CurrentValue = NULL;
                            AttributesToUpdate[j].CurrentValueLength = 0;
                        }

                    }
                    break;
                }

            }

            //
            // If the DS returned an attribute we didn't query,
            //

            if ( j >= LsapDsMachineClientSetAttrsCount ) {
                if ( SavedStatus == STATUS_SUCCESS ) {
                    SavedStatus = STATUS_INVALID_PARAMETER;
                }
            }
        }


        //
        // Loop through each attribute of interest deciding to
        //  remove it or replace it.
        //

        RemoveAttrBlock.attrCount = 0;
        RemoveAttrBlock.pAttr = RemoveAttributes;
        ReplaceAttrBlock.attrCount = 0;
        ReplaceAttrBlock.pAttr = ReplaceAttributes;

        for ( i=0; i<LsapDsMachineClientSetAttrsCount; i++ ) {


            //
            // Write out the new name if it is different that the old name.
            //
            // Difference is defined as:
            //   A current name is present and is different from the one we're being asked to write
            //   There is no current name and there is a new name
            //   There is a current name and there is no new name (delete the current name)
            //
            if (( AttributesToUpdate[i].NewValue && AttributesToUpdate[i].CurrentValue &&
                 (AttributesToUpdate[i].CurrentValueLength !=  wcslen( AttributesToUpdate[i].NewValue )  ||
                  _wcsnicmp( AttributesToUpdate[i].NewValue,
                             AttributesToUpdate[i].CurrentValue,
                             AttributesToUpdate[i].CurrentValueLength))) ||
                ( AttributesToUpdate[i].CurrentValue == NULL && AttributesToUpdate[i].NewValue != NULL) ||
                ( AttributesToUpdate[i].CurrentValue != NULL && AttributesToUpdate[i].NewValue == NULL ) ) {
                ULONG attrIndex;

                //
                // If the new attribute is NULL,
                //  remove the attribute from the DS
                //

                if ( AttributesToUpdate[i].NewValue == NULL ) {
                    RemoveAttributes[ RemoveAttrBlock.attrCount ].attrTyp =
                        LsapDsMachineClientSetAttrs[i].attrTyp;
                    RemoveAttributes[ RemoveAttrBlock.attrCount ].AttrVal.valCount = 1;
                    RemoveAttributes[ RemoveAttrBlock.attrCount ].AttrVal.pAVal =
                        &RemoveVals[ RemoveAttrBlock.attrCount ];

                    RtlZeroMemory( &RemoveVals[ RemoveAttrBlock.attrCount ],
                                   sizeof( RemoveVals[ RemoveAttrBlock.attrCount ] ));

                    RemoveAttrBlock.attrCount ++;

                //
                // If the new attribute is not NULL,
                //  replace the attribute in the DS
                //

                } else {
                    ReplaceAttributes[ ReplaceAttrBlock.attrCount ].attrTyp =
                        LsapDsMachineClientSetAttrs[i].attrTyp;
                    ReplaceAttributes[ ReplaceAttrBlock.attrCount ].AttrVal.valCount = 1;
                    ReplaceAttributes[ ReplaceAttrBlock.attrCount ].AttrVal.pAVal =
                        &ReplaceVals[ ReplaceAttrBlock.attrCount ];

                    RtlZeroMemory( &ReplaceVals[ ReplaceAttrBlock.attrCount ],
                                   sizeof( ReplaceVals[ ReplaceAttrBlock.attrCount ] ));

                    LSAP_DS_SET_DS_ATTRIBUTE_STRING(
                        &ReplaceAttributes[ ReplaceAttrBlock.attrCount ],
                        AttributesToUpdate[i].NewValue );

                    ReplaceAttrBlock.attrCount ++;
                }
            }
        }

        //
        // If there are any attributes to replace,
        //  do it now.
        //

        if ( ReplaceAttrBlock.attrCount != 0 ) {

            Status = LsapDsWriteByDsName( MachinePath,
                                          LSAPDS_REPLACE_ATTRIBUTE,
                                          &ReplaceAttrBlock );
            if ( !NT_SUCCESS( Status ) ) {

                LsapDsDebugOut(( DEB_ERROR,
                                 "Replace of attributes to %ws failed with 0x%lx\n",
                                 SamName,
                                 Status ));

            }
        }

        //
        // If there are any attributes to remove,
        //  do it now.
        //

        if ( RemoveAttrBlock.attrCount != 0 ) {

            Status = LsapDsWriteByDsName( MachinePath,
                                          LSAPDS_REMOVE_ATTRIBUTE,
                                          &RemoveAttrBlock );
            if ( !NT_SUCCESS( Status ) ) {

                LsapDsDebugOut(( DEB_ERROR,
                                 "Remove of attributes to %ws failed with 0x%lx\n",
                                 SamName,
                                 Status ));

            }
        }


        //
        // ASSERT: We're done with the machine object
        //
        // Get the name of the Server this computer is linked to, if any.
        //

        AttrBlock.attrCount = LsapDsServerReferenceCountBl;
        AttrBlock.pAttr = LsapDsServerReferenceBl;

        Status = LsapDsReadByDsName( MachinePath,
                                    0,
                                    &AttrBlock,
                                    &Results3 );

        if ( !NT_SUCCESS( Status ) ) {
            if ( Status != STATUS_NOT_FOUND ) {
                if ( SavedStatus == STATUS_SUCCESS ) {
                    SavedStatus = Status;
                }
            } else {
                Status = STATUS_SUCCESS;
            }
            continue;
        }

        if ( Results3.attrCount == 0 ) {
            continue;
        }

        ServerPath = LSAP_DS_GET_DS_ATTRIBUTE_AS_DSNAME( &Results3.pAttr[ 0 ] );
        CurrentServerDnsHostName = NULL;
        CurrentServerDnsHostNameLength = 0;

        //
        // Read the current host name from the server object
        //  No point in doing the read if we're doing a delete
        //
        if ( CurrentComputerDnsHostName != NULL ) {

            //
            // Read the current host name from the server object
            //
            AttrBlock.attrCount = LsapDsMachineDnsHostCount;
            AttrBlock.pAttr = LsapDsMachineDnsHost;

            Status = LsapDsReadByDsName(ServerPath,
                                        0,
                                        &AttrBlock,
                                        &Results2 );

            if ( Status == STATUS_NOT_FOUND ) {
                Results2.attrCount = 0;
                Status = STATUS_SUCCESS;
            }

            if ( !NT_SUCCESS( Status ) ) {
                if ( SavedStatus == STATUS_SUCCESS ) {
                    SavedStatus = Status;
                }
                continue;
            }

            if( Results2.attrCount == 1) {
                CurrentServerDnsHostName = LSAP_DS_GET_DS_ATTRIBUTE_AS_PWSTR(&Results2.pAttr[ 0 ] );
                // length in count of characters.
                CurrentServerDnsHostNameLength =
                    LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( &Results2.pAttr[ 0 ] ) / sizeof( WCHAR );
            }
        }


        //
        // Write out the new name if it is different that the old name.

        // Difference is defined as:
        //   A current name is present and is different from the one we're being asked to write
        //   There is no current name and there is a new name
        //   There is a current name and there is no new name (delete the current name)
        //
        if ( (CurrentComputerDnsHostName &&
              CurrentServerDnsHostName &&
              (CurrentServerDnsHostNameLength != CurrentComputerDnsHostNameLength  ||
               _wcsnicmp( CurrentComputerDnsHostName, CurrentServerDnsHostName, CurrentServerDnsHostNameLength))) ||
             ( CurrentServerDnsHostName == NULL && CurrentComputerDnsHostName != NULL ) ||
             ( CurrentComputerDnsHostName == NULL ) ) {

            ATTRVAL WriteVals[ 1 ];
            ATTR WriteAttributes[ 1 ];

            RtlZeroMemory( &WriteVals, sizeof( ATTRVAL ) );

            WriteAttributes[ 0 ].attrTyp = LsapDsAttributeIds[ LsapDsAttrMachineDns ];
            WriteAttributes[ 0 ].AttrVal.valCount = 1;
            WriteAttributes[ 0 ].AttrVal.pAVal = &WriteVals[ 0 ];

            if ( CurrentComputerDnsHostName ) {
                LSAP_DS_SET_DS_ATTRIBUTE_STRING( &WriteAttributes[ 0 ], CurrentComputerDnsHostName );
            }

            AttrBlock.attrCount = 1;
            AttrBlock.pAttr = WriteAttributes;

            Status = LsapDsWriteByDsName(ServerPath,
                                         CurrentComputerDnsHostName ?
                                            LSAPDS_REPLACE_ATTRIBUTE :
                                            LSAPDS_REMOVE_ATTRIBUTE,
                                         &AttrBlock );

            if ( !NT_SUCCESS( Status ) ) {

                if ( CurrentComputerDnsHostName ) {

                    LsapDsDebugOut(( DEB_ERROR,
                                     "Write of Dns domain name %ws on server object failed with 0x%lx\n",
                                     CurrentComputerDnsHostName,
                                     Status ));

                } else {

                    LsapDsDebugOut(( DEB_ERROR,
                                     "Removal of Dns domain name from server object failed with 0x%lx\n",
                                     Status ));

                }

            }
        }
    }




SetDnsHostNameEnd:
    Status = Status == STATUS_SUCCESS ? SavedStatus : Status;

    if ( NT_SUCCESS(Status) ) {
        if ( ARGUMENT_PRESENT( OldDnsHostName )) {
            *OldDnsHostName = CurrentComputerDnsHostName;
            CurrentComputerDnsHostName = NULL;
        }
    }

    if ( CurrentComputerDnsHostName != NULL ) {
        MIDL_user_free( CurrentComputerDnsHostName );
    }
    if ( MachinePaths != NULL ) {
        LsapFreeLsaHeap( MachinePaths );
    }

    if ( AllocatedBuffer != NULL ) {
        LsapFreeLsaHeap( AllocatedBuffer );
    }


    if ( TsActive ) {
        LsapDsDeleteAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                         LSAP_DB_DS_OP_TRANSACTION,
                                     NullObject,
                                     CloseTransaction );
    }
    LsapExitFunc( "LsaISetClientDnsHostName", Status );

    return Status;

}


NTSTATUS
LsaIQueryUpnSuffixes(
    OUT PLSAP_UPN_SUFFIXES *UpnSuffixes
    )
/*++

Routine Description:

    This routine enumerates all of the configured UPN and SPN suffixes

Arguments:

    UpnSuffixes - Returns a pointer to the UPN Suffixes
        Buffer should be freed using LsaIFree_LSAP_UPN_SUFFIXES

Returns:

    STATUS_SUCCESS - Success

    STATUS_INVALID_DOMAIN_STATE - The Ds is not installed or running at the time of the call

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed

--*/

{
    NTSTATUS Status;
    BOOLEAN CloseTransaction = FALSE;

    ULONG i;
    ULONG j;

    PDSNAME DsName;
    BOOLEAN TsActive = FALSE;
    PLSAP_UPN_SUFFIXES Names = NULL;

    ULONG NameCount;
    ULONG NameIndex;

    //
    // Build the list of attribute IDs we need based on the information
    // class
    //
    ATTR UpnSuffixesAttrVals[] = {
        {ATT_UPN_SUFFIXES, {0, NULL} },
        {ATT_MS_DS_SPN_SUFFIXES, {0, NULL} },
        };

    ATTRBLOCK   ReadBlock, ReturnedBlock = { 0 };


    // WCHAR   RdnBuffer[MAX_RDN_SIZE + 1];
    // ULONG   RdnLen;
    // ATTRTYP RdnType;

    LsarpReturnCheckSetup();

    LsapEnterFunc( "LsaIQueryUpnSuffixes" );


    //
    // Make sure the DS is installed
    //
    if ( !LsaDsStateInfo.UseDs ) {
        Status = STATUS_INVALID_DOMAIN_STATE;
        goto Cleanup;
    }

    //
    //  See if we already have a transaction going
    //
    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                            LSAP_DB_DS_OP_TRANSACTION,
                                        NullObject,
                                        &CloseTransaction );

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }
    TsActive = TRUE;;

    //
    // Read the required attributes from the parititions container object
    //

    ReadBlock.attrCount = sizeof(UpnSuffixesAttrVals) / sizeof(ATTR);
    ReadBlock.pAttr = UpnSuffixesAttrVals;

    Status = LsapDsReadByDsName( LsaDsStateInfo.DsPartitionsContainer,
                                 0,
                                 &ReadBlock,
                                 &ReturnedBlock );

    //
    // Allow for the case where the Partitions container doesn't exist.
    //

    if ( Status == STATUS_NOT_FOUND ) {
        ReturnedBlock.attrCount = 0;
        Status = STATUS_SUCCESS;
    }

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }


    //
    // Determine the number of suffixes to return
    //

    NameCount = 0;
    for ( i = 0;
          i < ReturnedBlock.attrCount;
          i++) {

        switch ( ReturnedBlock.pAttr[i].attrTyp ) {
        case ATT_UPN_SUFFIXES:
        case ATT_MS_DS_SPN_SUFFIXES:


            NameCount += ReturnedBlock.pAttr[i].AttrVal.valCount;
            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;

        }
    }

    //
    // Allocate a block to return to the caller
    //

    Names = LsapAllocateLsaHeap( sizeof(LSAP_UPN_SUFFIXES) +
                                 NameCount * sizeof(UNICODE_STRING) );

    if ( Names == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }



    //
    // Return the suffixes.
    //

    NameIndex = 0;
    for ( i = 0;
          i < ReturnedBlock.attrCount;
          i++) {

        switch ( ReturnedBlock.pAttr[i].attrTyp ) {
        case ATT_UPN_SUFFIXES:
        case ATT_MS_DS_SPN_SUFFIXES:

            for ( j = 0; j < ReturnedBlock.pAttr[i].AttrVal.valCount; j++ ) {

                Status = STATUS_SUCCESS;
                LSAPDS_ALLOC_AND_COPY_STRING_TO_UNICODE_ON_SUCCESS(
                        Status,
                        &Names->Suffixes[NameIndex],
                        ReturnedBlock.pAttr[i].AttrVal.pAVal[ j ].pVal,
                        ReturnedBlock.pAttr[i].AttrVal.pAVal[ j ].valLen );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }

                NameIndex++;
            }

            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;

        }
    }

    ASSERT( NameCount == NameIndex );
    Names->SuffixCount = NameIndex;

    Status = STATUS_SUCCESS;



    //
    // Free locally used resources
    //
Cleanup:
    //
    // Destruction of the thread state will delete the memory alloced by the SearchNonUnique call
    //
    if ( TsActive ) {
       LsapDsDeleteAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                         LSAP_DB_DS_OP_TRANSACTION,
                                     NullObject,
                                     CloseTransaction );
    }

    if ( !NT_SUCCESS( Status ) ) {
        LsaIFree_LSAP_UPN_SUFFIXES( Names );
    } else {
        *UpnSuffixes = Names;
    }

    LsarpReturnPrologue();

    LsapExitFunc( "LsaIQueryUpnSuffixes", Status );

    return( Status );
}

VOID
LsaIFree_LSAP_UPN_SUFFIXES(
    IN PLSAP_UPN_SUFFIXES UpnSuffixes
    )
/*++

Routine Description:

    This routine free the LSAP_SUBNET_INFO strcture returned from
    LsaIQuerySubnetInfo.

Arguments:

    SubnetInformation - Specifies a pointer to the subnet information.

Returns:

    None.

--*/
{
    ULONG i;
    if ( UpnSuffixes != NULL ) {

        for ( i=0; i<UpnSuffixes->SuffixCount; i++) {
            if ( UpnSuffixes->Suffixes[i].Buffer != NULL ) {
                LsapFreeLsaHeap( UpnSuffixes->Suffixes[i].Buffer );
            }
        }

        LsapFreeLsaHeap( UpnSuffixes );
    }
}

VOID
NTAPI
LsaINotifyNetlogonParametersChangeW(
    IN LSAP_NETLOGON_PARAMETER Parameter,
    IN DWORD dwType,
    IN PWSTR lpData,
    IN DWORD cbData
    )
/*++

Routine Description:

    A way for Netlogon to notify LSA of changes to the values under its
    'Parameters' key that Lsa cares about

Parameters:

    Parameter       the value that has changed
    dwType          type of value
    lpData          pointer to the data
    cbData          number of bytes in the lpData buffer

Returns:

    Nothing

--*/
{
    ASSERT( Parameter == LsaEmulateNT4 );
    ASSERT( dwType == REG_DWORD );
    ASSERT( lpData );
    ASSERT( cbData );

    if ( Parameter == LsaEmulateNT4 ) {
    	
        LsapDbState.EmulateNT4 = ( *( DWORD * )lpData != 0 );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dsp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dsp.h

Abstract:

    Private macros/definitions/prototypes for implementing a portion of the LSA store
    in the DS

Author:

    Mac McLain          (MacM)       Jan 17, 1997

Environment:

    User Mode

Revision History:

--*/

#ifndef __DSP_H__
#define __DSP_H__

#include <filtypes.h>
#include <attids.h>
#include <dsattrs.h>

#ifndef PDSNAME
typedef DSNAME *PDSNAME;
#endif

#ifndef PATTR
typedef ATTR   *PATTR;
#endif

#ifndef PGUID
typedef GUID *PGUID;
#endif

extern PWSTR   LsapDsDomainRelativeContainers[];
extern USHORT  LsapDsDomainRelativeContainersLen[];

#define LSADSP_MAX_ATTRS_ON_CREATE  3

#define LSAPDSP_ACCOUNT_GET_PRIVILEGE           0x00000001
#define LSAPDSP_ACCOUNT_GET_ACCOUNT             0x00000002

#define TENMEG                                  10485760

//
// Retuns the string name embedded in a DSNAME structure
//
#define LsapDsNameFromDsName(pdsname)                                   \
    (pdsname) == NULL ? NULL : (pdsname)->StringName

//
// Returns the length of the string name embedded in a DSNAME structure
//
#define LsapDsNameLenFromDsName(pdsname)                                \
    ((pdsname) == NULL ? 0 : (pdsname)->NameLen)

//
// Returns the length of a unicode string buffer without the trailing NULL
//
#define LsapDsGetUnicodeStringLenNoNull(punicode)                       \
(((PWSTR)(punicode)->Buffer)[(punicode)->Length / sizeof(WCHAR) - 1] == UNICODE_NULL ?   \
        (punicode)->Length - sizeof(WCHAR) :                                            \
        (punicode)->Length)

#define LsapDsGetSelfRelativeUnicodeStringLenNoNull(punicode)                            \
(((PWSTR)((PBYTE)(punicode) + sizeof(UNICODE_STRING_SR)))[(punicode)->Length / sizeof(WCHAR) - 1] == UNICODE_NULL ?   \
        (punicode)->Length - sizeof(WCHAR) :                                            \
        (punicode)->Length)

#define LsapDsIsWriteDs( objhandle )                                                             \
  ((((LSAP_DB_HANDLE)(objhandle))->fWriteDs &&                                                   \
   (((LSAP_DB_HANDLE)(objhandle))->ObjectTypeId == TrustedDomainObject ||                        \
    ((LSAP_DB_HANDLE)(objhandle))->ObjectTypeId == SecretObject)) ? TRUE : FALSE )

#define LsapDsSetHandleWriteDs( objhandle ) ((LSAP_DB_HANDLE)(objhandle))->fWriteDs = TRUE

#define LsapDsWriteDs ( LsaDsStateInfo.UseDs )

#define LsapDsIsUplevelTrust( trustlevel )  (trustlevel == TRUST_TYPE_UPLEVEL)

#define LSAPDS_ALLOC_AND_COPY_STRING_TO_UNICODE_ON_SUCCESS( status, dest, src, len )\
if ( NT_SUCCESS( status ) ) {                                               \
                                                                            \
    (dest)->MaximumLength = (USHORT)len + sizeof(WCHAR);                    \
    (dest)->Buffer = LsapAllocateLsaHeap( (dest)->MaximumLength );          \
                                                                            \
    if ( (dest)->Buffer == NULL ) {                                         \
                                                                            \
        status = STATUS_INSUFFICIENT_RESOURCES;                             \
                                                                            \
    } else {                                                                \
                                                                            \
        (dest)->Length = (dest)->MaximumLength - sizeof( WCHAR );           \
        RtlCopyMemory( (dest)->Buffer, (src), (dest)->Length );             \
        ((WCHAR*)((dest)->Buffer))[(len)/sizeof(WCHAR)] = L'\0';            \
    }                                                                       \
}

#define LSAPDS_ALLOC_AND_COPY_UNICODE_STRING_ON_SUCCESS( status, _dest_, _src_ )    \
if ( NT_SUCCESS( status ) ) {                                                       \
                                                                                    \
    ( _dest_ )->MaximumLength = ( _src_ )->MaximumLength;                           \
    ( _dest_ )->Buffer = LsapAllocateLsaHeap( (_dest_ )->MaximumLength );           \
                                                                                    \
    if ( ( _dest_ )->Buffer == NULL ) {                                             \
                                                                                    \
        status = STATUS_INSUFFICIENT_RESOURCES;                                     \
                                                                                    \
    } else {                                                                        \
                                                                                    \
        RtlZeroMemory(( _dest_ )->Buffer, ( _dest_ )->MaximumLength );              \
        ( _dest_ )->Length = ( _src_ )->Length;                                     \
        RtlCopyMemory( ( _dest_ )->Buffer, ( _src_ )->Buffer, ( _dest_ )->Length ); \
    }                                                                               \
}


#define LSAPDS_ALLOC_AND_COPY_SID_ON_SUCCESS( status, dest, sid )           \
if ( NT_SUCCESS( status ) ) {                                               \
                                                                            \
    (dest) = LsapAllocateLsaHeap( RtlLengthSid( sid ) );                    \
    if ( (dest) == NULL ) {                                                 \
                                                                            \
        status = STATUS_INSUFFICIENT_RESOURCES;                             \
                                                                            \
    } else {                                                                \
                                                                            \
        RtlCopyMemory( (dest), (sid), RtlLengthSid( sid ) );                \
    }                                                                       \
}

#define LSAPDS_COPY_GUID_ON_SUCCESS( status, dest, src )                    \
if ( NT_SUCCESS( status ) ) { RtlCopyMemory((dest), (src), sizeof( GUID ) ); }


#define LsapDsReturnSuccessIfNoDs                   \
if ( !LsapDsWriteDs ) {                             \
                                                    \
    return( STATUS_SUCCESS );                       \
}

BOOL
SampExistsDsTransaction(
    void
    );

//
// Determines whether a bit is on or not
//
#define FLAG_ON(flags,bit)        ((flags) & (bit))

#define LsapDsLengthAppendRdnLength( dsname, length )           \
DSNameSizeFromLen( ( LsapDsNameLenFromDsName( dsname ) + 5 + ( ( ( length ) / sizeof( WCHAR ) * 2 ) ) ) )


#define LsapDsLengthAppendRdn( dsname, newrdn )                 \
    LsapDsLengthAppenRdnLength( wcslen( newrdn ) * sizeof( WCHAR ) )

#define LsapDsSetDsaFlags( flag )           \
SampSetDsa( flag );                         \
// SampSetLsa( flag );


#define LsapDsInitializeAttrBlock( attrblock, attrs, count )            \
(attrblock)->attrCount = count;                                         \
(attrblock)->pAttr = attrs;

#define LSAP_DS_PARTITIONS_CONTAINER    L"Partitions"
#define LSAP_DS_SYSTEM_CONTAINER        L"System"
#define LSAP_DS_KNOWN_SIDS_CONTAINER    L"WellKnown Security Principals"
#define LSAP_DS_SAM_BUILTIN_CONTAINER   L"Builtin"
#define LSAP_DS_TRUSTED_DOMAIN          L"trustedDomain"
#define LSAP_DS_SECRET                  L"secret"

#define LSAP_DS_SITES_CONTAINER         L"CN=Sites"
#define LSAP_DS_SUBNET_CONTAINER        L"CN=Subnets," LSAP_DS_SITES_CONTAINER
#define LSAP_DS_PATH_SEP            L','
#define LSAP_DS_PATH_SEP_AS_STRING  L","
#define LSAP_DS_CONTAINER_PREFIX    L"CN="
#define LSAP_DS_DEFAULT_LOCAL_POLICY    L"Default Local Policy"
#define LSAP_DS_DEFAULT_DOMAIN_POLICY   L"Default Domain Policy"
#define LSAP_DS_SECRET_POSTFIX      L" Secret"
#define LSAP_DS_SECRET_POSTFIX_LEN  ((sizeof(LSAP_DS_SECRET_POSTFIX)/sizeof(WCHAR))-1)
#define LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX    L"G$$"
#define LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_SIZE           \
                             (sizeof( LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX ) - sizeof( WCHAR ) )
#define LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_LENGTH         \
                             (LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_SIZE/sizeof(WCHAR))

typedef enum _LSAP_DSOBJ_TYPE {

    LsapDsObjUnknown,
    LsapDsObjDomainPolicy,
    LsapDsObjLocalPolicy,
    LsapDsObjTrustedDomain,
    LsapDsObjGlobalSecret,
    LsapDsObjDomainXRef

} LSAP_DSOBJ_TYPE, *PLSAP_DSOBJ_TYPE;


#define LSAP_DS_INIT_ATTR(attr, type, cnt, vals)                            \
attr.attrTyp          = type;                                               \
attr.AttrVal.valCount = cnt;                                                \
attr.AttrVal.pAVal    = vals;

//
// General flags to be used for all operations
//
#define LSAPDS_OP_NO_LOCK       0x00000001
#define LSAPDS_OP_NO_TRANS      0x00000002

//
// Flags to use for search
//
#define LSAPDS_SEARCH_ROOT      0x00008000
#define LSAPDS_SEARCH_ALL_NCS   0x00010000
#define LSAPDS_SEARCH_LEVEL     0x00020000
#define LSAPDS_SEARCH_TREE      0x00040000
#define LSAPDS_SEARCH_OR        0x00100000

#define LSAPDS_SEARCH_FLAGS     0x00168000

//
// Flags to use when looking up the domain xref object
//
#define LSAPDS_XREF_FLAT        0x00000001
#define LSAPDS_XREF_ALLOW_FAIL  0x00000002

//
// Flags to use for Write
//
#define LSAPDS_ADD_ATTRIBUTE        AT_CHOICE_ADD_ATT
#define LSAPDS_REMOVE_ATTRIBUTE     AT_CHOICE_REMOVE_ATT
#define LSAPDS_ADD_VALUES           AT_CHOICE_ADD_VALUES
#define LSAPDS_REMOVE_VALUES        AT_CHOICE_REMOVE_VALUES
#define LSAPDS_REPLACE_ATTRIBUTE    AT_CHOICE_REPLACE_ATT

#define LSAPDS_WRITE_TYPES      0x00000FFF
#define LSAPDS_REPL_CHANGE_URGENTLY 0x00002000
#define LSAPDS_USE_PERMISSIVE_WRITE 0x00001000


//
// Flags to use for Read
//
#define LSAPDS_READ_NO_LOCK         LSAPDS_OP_NO_LOCK
#define LSAPDS_READ_DELETED         0x00002000
#define LSAPDS_READ_RETURN_NOT_FOUND    0x10000000

//
// Flags to use for Create
//
#define LSAPDS_CREATE_TRUSTED       0x00002000

//
// Flags used for looking up sids
//
#define LSAPDS_LOOKUP_FOR_READ      0x00000001
#define LSAPDS_LOOKUP_ONLY          0x00000002
#define LSAPDS_LOOKUP_CREATE_LOCAL  0x00000004

//
// Flags used when opening an account object
//
#define LSAPDS_ACCOUNT_NON_EXISTANT 0x00000000

NTSTATUS
LsapDsMapDsReturnToStatus (
    ULONG DsStatus
    );

NTSTATUS
LsapDsMapDsReturnToStatusEx (
    IN COMMRES *pComRes
    );

VOID
LsapDsInitializeStdCommArg (
    IN  COMMARG    *pCommArg,
    IN  ULONG       Flags
    );

NTSTATUS
LsapDsCopyAttrBlock(
    OUT ATTRBLOCK **Dest,
    IN ATTRBLOCK Src
    );

VOID
LsapDsFreeAttrBlock(
    IN ATTRBLOCK *AttrBlock
    );

NTSTATUS
LsapAllocAndInitializeDsNameFromUnicode(
    IN  LSAP_DSOBJ_TYPE         DsObjType,
    IN  PLSA_UNICODE_STRING     pObjectName,
    OUT PDSNAME                *pDsName
    );

NTSTATUS
LsapDsSearchUnique(
    IN  ULONG       Flags,
    IN  PDSNAME     pContainer,
    IN  PATTR       pAttrsToMatch,
    IN  ULONG       cAttrs,
    OUT PDSNAME    *ppFoundName
    );

NTSTATUS
LsapDsSearchNonUnique(
    IN  ULONG       Flags,
    IN  PDSNAME     pContainer,
    IN  PATTR       pAttrToMatch,
    IN  ULONG       Attrs,
    OUT PDSNAME   **pppFoundNames,
    OUT PULONG      pcNames
    );

NTSTATUS
LsapDsFindUnique(
    IN ULONG Flags,
    IN PDSNAME NCName OPTIONAL,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN ATTRVAL *Attribute,
    IN ATTRTYP AttId,
    OUT PDSNAME *FoundObject
    );

NTSTATUS
LsapDsCreateAndSetObject(
    IN  LSAP_DSOBJ_TYPE         DsObjType,
    IN  PLSA_UNICODE_STRING     pObjectName,
    IN  ULONG                   Flags,
    IN  ULONG                   cItems,
    IN  ATTRTYP                *pAttrTypeList,
    IN  ATTRVAL                *pAttrValList
    );

NTSTATUS
LsapDsCreateObjectDs(
    IN LSAP_DSOBJ_TYPE DsObjType,
    IN PDSNAME ObjectName,
    IN ULONG Flags,
    IN ATTRBLOCK *AttrBlock
    );



NTSTATUS
LsapDsRead (
    IN  PUNICODE_STRING pObject,
    IN  ULONG fFlags,
    IN  ATTRBLOCK *pAttributesToRead,
    OUT ATTRBLOCK *pAttributeValues
    );

NTSTATUS
LsapDsReadByDsName (
    IN  PDSNAME DsName,
    IN  ULONG fFlags,
    IN  ATTRBLOCK *pAttributesToRead,
    OUT ATTRBLOCK *pAttributeValues
    );


NTSTATUS
LsapDsRemove (
    IN  PDSNAME     pObject
    );

NTSTATUS
LsapDsWrite(
    IN  PUNICODE_STRING pObject,
    IN  ULONG           Flags,
    IN  ATTRBLOCK       *Attributes
    );

NTSTATUS
LsapDsWriteByDsName(
    IN  PDSNAME DsName,
    IN  ULONG Flags,
    IN  ATTRBLOCK *Attributes
    );


NTSTATUS
LsapDsLsaAttributeToDsAttribute(
    IN  PLSAP_DB_ATTRIBUTE  LsaAttribute,
    OUT PATTR               Attr
    );

NTSTATUS
LsapDsDsAttributeToLsaAttribute(
    IN  ATTRVAL             *AttVal,
    OUT PLSAP_DB_ATTRIBUTE   LsaAttribute
    );

NTSTATUS
LsapDsIsSecretDsTrustedDomain(
    IN PUNICODE_STRING SecretName,
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ULONG Options,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TDObjHandle,
    OUT BOOLEAN *IsTrustedDomainSecret
    );

NTSTATUS
LsapDsIsHandleDsObjectTypeHandle(
    IN LSAP_DB_HANDLE Handle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectType,
    OUT BOOLEAN *IsObjectHandle
    );


#define LsapDsIsTransactionOpen() ( FALSE  )


#define LsapDsIsHandleDsHandle( handle )                                        \
(LsaDsStateInfo.UseDs && ((LSAP_DB_HANDLE) (handle))->PhysicalNameDs.Length != 0 )
#define LsapDsIsFunctionTableValid() LsaDsStateInfo.FunctionTableInitialized


NTSTATUS
LsapDsTrustedDomainSidToLogicalName(
    IN PSID Sid,
    OUT PUNICODE_STRING LogicalNameU
    );

NTSTATUS
LsapDsInitAllocAsNeededEx(
    IN ULONG Options,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    OUT PBOOLEAN Reset
    );

VOID
LsapDsDeleteAllocAsNeededEx(
    IN ULONG Options,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN BOOLEAN Reset
    );

VOID
LsapDsDeleteAllocAsNeededEx2(
    IN ULONG Options,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN BOOLEAN Reset,
    IN BOOLEAN RollbackTransaction
    );

NTSTATUS
LsapDsCauseTransactionToCommitOrAbort (
    IN BOOLEAN  Commit
    );

NTSTATUS
LsapDsBuildObjectPathByType(
    IN LSAP_DSOBJ_TYPE ObjType,
    PUNICODE_STRING ObjectComponent,
    PUNICODE_STRING ObjectPath
    );

NTSTATUS
LsapDsGetTrustedDomainParentObjectReference(
    IN PUNICODE_STRING TrusteeName,
    IN ULONG TrustType,
    IN ULONG SearchFlags,
    OUT PDSNAME *DsName
    );

NTSTATUS
LsapDsSetParentXRefObjReference(
    IN PDSNAME ParentXRef,
    IN ULONG TrustAttributes
    );

NTSTATUS
LsapDsGetListOfSystemContainerItems(
    IN ULONG ClassId,
    OUT PULONG  Items,
    OUT PDSNAME **DsNames
    );

//
// Enumeration flags defined in dbp.h
//
NTSTATUS
LsapDsEnumerateTrustedDomainsEx(
    IN PLSA_ENUMERATION_HANDLE EnumerationContext,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_TRUSTED_DOMAIN_INFO *TrustedDomainInformation,
    IN ULONG PreferedMaximumLength,
    IN OUT PULONG CountReturned,
    IN ULONG EnumerationFlags
    );

NTSTATUS
LsapDsGetTrustedDomainInfoEx(
    IN PDSNAME  ObjectPath,
    IN ULONG ReadOptions,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation,
    OUT PULONG Size OPTIONAL
    );

NTSTATUS
LsapDsBuildAuthInfoAttribute(
    IN LSAPR_HANDLE Handle,
    IN PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF NewAuthInfo,
    IN PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF PreviousAuthInfo,
    OUT PBYTE *Buffer,
    OUT PULONG Len
    );


NTSTATUS
LsapDsBuildAuthInfoFromAttribute(
    IN LSAPR_HANDLE Handle,
    IN PBYTE Buffer,
    IN ULONG Len,
    OUT PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF NewAuthInfo
    );

NTSTATUS
LsapDecryptAuthDataWithSessionKey(
    IN PLSAP_CR_CIPHER_KEY SessionKey,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL AuthInformationInternal,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthInfo
    );

VOID
LsapDsFreeUnmarshaledAuthInfo(
    IN ULONG Items,
    IN PLSAPR_AUTH_INFORMATION AuthInfo
    );

VOID
LsapDsFreeUnmarshalAuthInfoHalf(
    IN PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF AuthInfo
    );


NTSTATUS
LsapDsGetSecretOnTrustedDomainObject(
    IN LSAP_DB_HANDLE TrustedDomainHandle,
    IN OPTIONAL PLSAP_CR_CIPHER_KEY SessionKey OPTIONAL,
    OUT PLSAP_CR_CIPHER_VALUE *CipherCurrent OPTIONAL,
    OUT PLSAP_CR_CIPHER_VALUE *CipherOld OPTIONAL,
    OUT PLARGE_INTEGER CurrentValueSetTime OPTIONAL,
    OUT PLARGE_INTEGER OldValueSetTime OPTIONAL
    );


NTSTATUS
LsapDsSetSecretOnTrustedDomainObject(
    IN LSAP_DB_HANDLE TrustedDomainHandle,
    IN ULONG AuthDataType,
    IN PLSAP_CR_CLEAR_VALUE ClearCurrent,
    IN PLSAP_CR_CLEAR_VALUE ClearOld,
    IN PLARGE_INTEGER CurrentValueSetTime
    );

NTSTATUS
LsapDsAuthDataOnTrustedDomainObject(
    IN LSAP_DB_HANDLE TrustedDomainHandle,
    IN BOOLEAN Incoming,
    IN ULONG AuthDataType,
    IN PLSAP_CR_CLEAR_VALUE ClearCurrent,
    IN PLSAP_CR_CLEAR_VALUE ClearOld,
    IN PLARGE_INTEGER CurrentValueSetTime
    );

NTSTATUS
LsapDsEnumerateTrustedDomainsAsSecrets(
    IN OUT PLSAP_DB_NAME_ENUMERATION_BUFFER DbEnumerationBuffer
    );

NTSTATUS
LsapDsEnumerateSecrets(
    IN OUT PLSAP_DB_NAME_ENUMERATION_BUFFER EnumerationBuffer
    );

NTSTATUS
LsapDbOpenObjectDs(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN PDSNAME DsName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Options,
    OUT PLSAPR_HANDLE ObjectHandle
    );

NTSTATUS
LsapSceNotify(
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid OPTIONAL
    );

NTSTATUS
LsapNetNotifyDelta (
    IN SECURITY_DB_TYPE DbType,
    IN LARGE_INTEGER SerialNumber,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PSID ObjectSid,
    IN PUNICODE_STRING ObjectName,
    IN DWORD ReplicateImmediately,
    IN PSAM_DELTA_DATA MemberId
    );


NTSTATUS
LsapDsAccountGetAttIdsForSid(
    IN PDSNAME DsName,
    IN PSID AccoutSid,
    IN ULONG AccountType,
    OUT PULONG *AttributeList,
    OUT PULONG AttributeCount
    );

NTSTATUS
LsapDsAccountChangePrivileges(
    IN LSAPR_HANDLE AccountHandle,
    IN LSAP_DB_CHANGE_PRIVILEGE_MODE ChangeMode,
    IN BOOLEAN AllPrivileges,
    IN OPTIONAL PPRIVILEGE_SET Privileges
    );

NTSTATUS
LsapDsAccountGetPrivileges(
    IN LSAPR_HANDLE AccountHandle,
    OUT PPRIVILEGE_SET *Privileges
    );

NTSTATUS
LsapDsAccountGetAccountAccess(
    IN LSAPR_HANDLE AccountHandle,
    OUT PULONG AccountAccess
    );

NTSTATUS
LsapDsAccountSetAccountAccess(
    IN LSAPR_HANDLE AccountHandle,
    IN ULONG AccountAccess
    );

NTSTATUS
LsapDsAccountEnumerateAccounts(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength
    );

NTSTATUS
LsapDsCopyDsNameLsa(
    OUT PDSNAME *Dest,
    IN PDSNAME Source
    );

NTSTATUS
LsapDsAccountUpgradeRegistryToDs(
    VOID
    );

NTSTATUS
LsapDsDomainUpgradeRegistryToDs(
    IN BOOLEAN DeleteOldValues
    );

NTSTATUS
LsapDsSecretUpgradeRegistryToDs(
    IN BOOLEAN DeleteOldValues
    );

NTSTATUS
LsapDsDomainUpgradeInterdomainTrustAccountsToDs(
    VOID
    );

NTSTATUS
LsapDsAccountEnumerateAccounts(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength
    );

NTSTATUS
LsapDsCreateInterdomainTrustAccount(
    IN LSAPR_HANDLE TrustedDomainObject
    );

NTSTATUS
LsapDsDeleteInterdomainTrustAccount(
    IN LSAPR_HANDLE TrustedDomainObject
    );

NTSTATUS
LsapDsCreateInterdomainTrustAccountByDsName(
    IN PDSNAME TrustedDomainPath,
    IN PUNICODE_STRING FlatName
    );

NTSTATUS
LsapDsInterdomainTrustAccountToObject(
    IN PUNICODE_STRING AccountName
    );


NTSTATUS
LsapDsGetDefaultSecurityDescriptorForObjectType(
    IN LSAP_DSOBJ_TYPE ObjType,
    IN ULONG Options,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor,
    OUT PULONG SecDescSize
    );

NTSTATUS
LsapDsSetTrustedDomainAuthByType(
    IN PDSNAME TrustedDomainObject,
    IN BOOLEAN Incoming,
    IN ULONG AuthDataType,
    IN PUNICODE_STRING Current,
    IN PUNICODE_STRING Old,
    IN PLARGE_INTEGER CurrentValueSetTime
    );

NTSTATUS
LsapDsFixupTrustedDomainObjectOnRestart(
    VOID
    );

NTSTATUS
LsapDsFindObjectForSid(
    IN PSID Sid,
    IN ULONG  Options,
    OUT PDSNAME *SidObject
    );

NTSTATUS
LsapDsOpenAccountObject(
    IN PSID Sid,
    IN ULONG Options,
    OUT PDSNAME *Account
    );

VOID
LsapDsContinueTransaction(
    VOID
    );


NTSTATUS
LsapBuildForestTrustInfoLists(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLIST_ENTRY TrustList
    );

VOID
LsapDsForestFreeTrustBlobList(
    IN PLIST_ENTRY TrustList
    );

NTSTATUS
LsapDsTrustedDomainObjectNameForDomain(
    IN PUNICODE_STRING TrustedDomainName,
    IN BOOLEAN NameAsFlatName,
    OUT PDSNAME *DsObjectName
    );

BOOLEAN
LsapNullUuid(
    IN const UUID *pUuid
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dstrust.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dstrust.c

Abstract:

    Implementation of a variety of TrustedDomain features that interface
    soley with the DS

Author:

    Mac McLain          (MacM)       Jan 17, 1997

Environment:

    User Mode

Revision History:

--*/
#include <lsapch2.h>
#include <dbp.h>
#include <lmcons.h>
#include <align.h>
#include <rc4.h>

//
// Local function prototypes
//

NTSTATUS
LsapDsUnmarshalAuthInfoHalf(
    IN LSAPR_HANDLE ObjectHandle,
    IN BOOLEAN ReturnOnlyFirstAuthInfo,
    IN BOOLEAN AllowEmptyPreviousInfo,
    IN PBYTE Buffer,
    IN ULONG Length,
    IN OUT PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF AuthInfo
    );

VOID
LsapDsFreeUnmarshaledAuthInfo(
    IN ULONG Items,
    IN PLSAPR_AUTH_INFORMATION AuthInfo
    );

NTSTATUS
LsapDsFindAuthTypeInAuthInfo(
    IN  ULONG AuthType,
    IN  PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthInfo,
    IN  BOOLEAN Incoming,
    IN  BOOLEAN AddIfNotFound,
    OUT BOOLEAN *Added,
    OUT PULONG AuthTypeIndex
    );

//
// Macros to help with copying over the domain information
//
#define LSAPDS_SET_AUTH_INFO( dest, time, type, length, data )              \
RtlCopyMemory( &(dest)->LastUpdateTime, time, sizeof( LARGE_INTEGER ) );    \
(dest)->AuthType = type;                                                    \
(dest)->AuthInfoLength = length;                                            \
(dest)->AuthInfo = data;



NTSTATUS
LsapDsGetListOfSystemContainerItems(
    IN ULONG ClassId,
    OUT PULONG  Items,
    OUT PDSNAME **DsNames
    )
/*++

Routine Description:

    This function obtain a list of DsNames of all indicated class types in the system container
    in the Ds

    NOTE: This function uses a single operation DS transaction only

Arguments:

    ClassId - Class types to find

    Items - Where the number of items is returned

    DsNames - Where the list of DsNames is returned

Returns:

    STATUS_SUCCESS - Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDSNAME CategoryName = NULL;
    ATTRVAL AttrVal;

    ATTR Attr = {
        ATT_OBJECT_CATEGORY, { 1, &AttrVal }
        };

    LsapEnterFunc( "LsapDsGetListOfSystemContainerItems" );


    *Items = 0;


    //
    // We need to map object class to object category, because apparently object_class is no
    // longer indexed.
    //
    switch ( ClassId ) {
    case CLASS_TRUSTED_DOMAIN:

        CategoryName = LsaDsStateInfo.SystemContainerItems.TrustedDomainObject;
        break;

    case CLASS_SECRET:

        CategoryName = LsaDsStateInfo.SystemContainerItems.SecretObject;
        break;

    default:

        Status = STATUS_NONE_MAPPED;
        break;

    }

    if ( NT_SUCCESS( Status ) ) {

        LSAP_DS_SET_DS_ATTRIBUTE_DSNAME( &Attr, CategoryName );
        Status = LsapDsSearchNonUnique( LSAPDS_OP_NO_TRANS,
                                        LsaDsStateInfo.DsSystemContainer,
                                        &Attr,
                                        1,
                                        DsNames,
                                        Items );

    }

    LsapExitFunc( "LsapDsGetListOfSystemContainerItems", Status );

    return( Status );
}



NTSTATUS
LsapDsEnumerateTrustedDomainsEx(
    PLSA_ENUMERATION_HANDLE EnumerationContext,
    TRUSTED_INFORMATION_CLASS InformationClass,
    PLSAPR_TRUSTED_DOMAIN_INFO *TrustedDomainInformation,
    ULONG PreferedMaximumLength,
    PULONG CountReturned,
    IN ULONG EnumerationFlags
    )
/*++

Routine Description:

    This function enumerate all of the trusted domains in a Ds, returning the
    requested info level of information.

Arguments:

    EnumerationContext - Context of new or ongoing enumeration

    InformationClass - Level of information being requested
        Must be TrustedDomainInformationEx or TrustedDomainInformatinBasic

    TrustedDomainInformation - Where the enumerated information is returned

    PreferedMaximumLength -  Rough upper size limit of buffer to return

    CountReturned - Where the count of the number of items in the list is returned

    EnumerationFlags -- Controls how the enumeration is done

Returns:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed

    STATUS_NO_MORE_ENTRIES - All of the appropriate entries have been enumerated

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDSNAME *DsNames = NULL;
    ULONG Items = 0, BuffSize, Read, Index = 0, Skip, i = 0;
    PLSAPR_TRUSTED_DOMAIN_INFO TDInfo = NULL;
    LSAPR_TRUSTED_DOMAIN_INFORMATION_EX ExInfo;
    PBYTE Buffer = NULL;
    ULONG Size = 0;
    ULONG Direction = 0, Type = 0, Attributes = 0;

    LsapEnterFunc( "LsapDsEnumerateTrustedDomainsEx" );

    ASSERT( InformationClass == TrustedDomainInformationEx ||
            InformationClass == TrustedDomainInformationBasic ||
            InformationClass == TrustedDomainFullInformation ||
            InformationClass == TrustedDomainFullInformation2Internal );

    switch ( InformationClass ) {
    case TrustedDomainInformationBasic:

        Size = sizeof( LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC );
        break;

    case TrustedDomainInformationEx:

        Size = sizeof( LSAPR_TRUSTED_DOMAIN_INFORMATION_EX );
        break;

    case TrustedDomainFullInformation:

        Size = sizeof( LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION );
        break;

    case TrustedDomainFullInformation2Internal:

        Size = sizeof( LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 );
        break;

    default:

        return( STATUS_INVALID_PARAMETER );
    }

    Skip = (ULONG)*EnumerationContext;

    LsapDbAcquireLockEx( TrustedDomainObject,
                         LSAP_DB_READ_ONLY_TRANSACTION );

    //
    // First, enumerate all of the trusted domains
    //

    Status = LsapDsGetListOfSystemContainerItems( CLASS_TRUSTED_DOMAIN,
                                                  &Items,
                                                  &DsNames );

    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

        Status = STATUS_NO_MORE_ENTRIES;
        *TrustedDomainInformation = NULL;
        *CountReturned = 0;

    }

    if ( NT_SUCCESS( Status ) ) {

        //
        // See if we've already enumerated all of our items...
        //
        if ( Items <= (ULONG)*EnumerationContext) {

            Status = STATUS_NO_MORE_ENTRIES;
            *TrustedDomainInformation = NULL;
            *CountReturned = 0;

        } else {

            TDInfo = MIDL_user_allocate( ( Items - Skip ) * Size );

            if( TDInfo == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                Buffer = ( PBYTE )TDInfo;
            }
        }

    }


    //
    // Now, we'll start getting the information from each of the objects
    //
    if ( NT_SUCCESS( Status ) ) {

        BuffSize = 0;
        Index = 0;
        i = 0;

        while ( TRUE ) {

            Status = LsapDsGetTrustedDomainInfoEx( DsNames[ Index + Skip ],
                                                   LSAPDS_READ_NO_LOCK,
                                                   InformationClass,
                                                   ( PLSAPR_TRUSTED_DOMAIN_INFO )Buffer,
                                                   &Read );

            //
            // See if we need to do any masking...
            //
            if ( NT_SUCCESS( Status ) && EnumerationFlags != LSAP_DB_ENUMERATE_NO_OPTIONS ) {

                if ( FLAG_ON( EnumerationFlags, LSAP_DB_ENUMERATE_AS_NT4 ) ) {

                    if ( InformationClass == TrustedDomainInformationEx ||
                         InformationClass == TrustedDomainFullInformation ) {

                        Direction =
                              ( ( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX )Buffer )->TrustDirection;
                        Type = ( ( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX )Buffer )->TrustType;
                        Attributes =
                             ( ( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX )Buffer )->TrustAttributes;

                    } else {

                        //
                        // We'll re-read the full info, and if it doesn't match our criteria,
                        // we'll ignore it.  Our critera state that the it must be outgoing,
                        // uplevel or downlevel, and not have the UPLEVEL only attribute set
                        //
                        Status = LsapDsGetTrustedDomainInfoEx( DsNames[ Index + Skip ],
                                                               LSAPDS_READ_NO_LOCK,
                                                               TrustedDomainInformationEx,
                                                               (PLSAPR_TRUSTED_DOMAIN_INFO)&ExInfo,
                                                               NULL );

                        if ( Status == STATUS_SUCCESS ) {

                            Direction = ExInfo.TrustDirection;
                            Type = ExInfo.TrustType;
                            Attributes = ExInfo.TrustAttributes;
                            _fgu__LSAPR_TRUSTED_DOMAIN_INFO( (PLSAPR_TRUSTED_DOMAIN_INFO)&ExInfo,
                                                             TrustedDomainInformationEx );

                        }

                    }

                    if ( NT_SUCCESS( Status ) ) {

                        if ( !FLAG_ON( Direction, TRUST_DIRECTION_OUTBOUND ) ||
                             !( Type == TRUST_TYPE_DOWNLEVEL ||
                                Type == TRUST_TYPE_UPLEVEL ) ||
                             FLAG_ON( Attributes, TRUST_ATTRIBUTE_UPLEVEL_ONLY ) ) {

                            //
                            // This one doesn't match, so we'll basically drop it on the
                            // floor
                            //
                            _fgu__LSAPR_TRUSTED_DOMAIN_INFO( (PLSAPR_TRUSTED_DOMAIN_INFO)Buffer,
                                                             InformationClass );

                            LsapDsDebugOut(( DEB_TRACE,
                                             "Trust object %ws doesn't match: D:0x%lx T:0x%lx A:0x%lx\n",
                                             LsapDsNameFromDsName( DsNames[ Index + Skip ] ),
                                             Direction,
                                             Type,
                                             Attributes ));
                            Status = STATUS_OBJECT_NAME_NOT_FOUND;
                        }

                    }

                }
            }

            if ( NT_SUCCESS( Status ) ) {

                Index++;
                i++;

                BuffSize += Read;

                if ( (Index + Skip) >= Items ) {

                    break;

                }

                if ( (BuffSize >= PreferedMaximumLength) ) {

                    break;
                }

                Buffer += Size;

            } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

                Index++;

                //
                // We'll have to pretend this item doesn't exist if we get back no information...
                //
                Status = STATUS_SUCCESS;
                LsapDsDebugOut(( DEB_TRACE,
                                 "Trust object %ws being dropped. %lu current items\n",
                                 LsapDsNameFromDsName( DsNames[ Index + Skip ] ),
                                 Items ));

            } else {

                break;

            }

            if ( (Index + Skip) >= Items ) {

                break;
            }
        }
    }


    //
    // Return the information on success
    //
    if ( NT_SUCCESS( Status ) ) {

        *(PULONG)EnumerationContext += Index;

        if ( i == 0 ) {

            Status = STATUS_NO_MORE_ENTRIES;
            *TrustedDomainInformation = NULL;
            *CountReturned = 0;

            MIDL_user_free( TDInfo );

        } else {

            *TrustedDomainInformation = TDInfo;
            *CountReturned = i;

            Status = STATUS_MORE_ENTRIES;
        }
    }

    //
    // Free any allocated memory we no longer need
    //
    if ( DsNames != NULL ) {

        LsapFreeLsaHeap( DsNames );
    }

    if ( !NT_SUCCESS( Status ) && Status != STATUS_NO_MORE_ENTRIES ) {

        MIDL_user_free( TDInfo );
    }

    LsapDbReleaseLockEx( TrustedDomainObject,
                         LSAP_DB_READ_ONLY_TRANSACTION );

    LsapExitFunc( "LsapDsEnumerateTrustedDomainsEx", Status );

    return( Status );
}



NTSTATUS
LsapDsGetTrustedDomainInfoEx(
    IN PDSNAME ObjectPath,
    IN ULONG ReadOptions,
    TRUSTED_INFORMATION_CLASS InformationClass,
    PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation,
    OUT PULONG Size OPTIONAL
    )
/*++

Routine Description:

    This function will read the requested level of information off the specified trusted
    domain object

Arguments:

    ObjectPath - DsName of the trusted domain object

    InformationClass - Level of information being requested

    TrustedDomainInformation - Where the information is returned

    Size - OPTIONAL size of the information buffer is returned here.

Returns:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed

    STATUS_INVALID_PARAMETER - A bad InformationClass was given

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    ATTRBLOCK   ReadBlock, ReturnedBlock;
    ULONG Items = 0, i, RetSize = 0;
    ATTR DomainOrgTreeAttrVals[] = {
        {0, {0, NULL} },
        {0, {0, NULL} },
        {0, {0, NULL} },
        {0, {0, NULL} },
        {0, {0, NULL} },
        {0, {0, NULL} },
        {0, {0, NULL} },
        {0, {0, NULL} }
        };

    //
    // List of returned parameters
    //
    UNICODE_STRING Name, FlatName;
    ULONG Offset = 0, Direction = 0, Type = 0, Attributes = 0;
    PSID Sid = NULL;
    PBYTE Incoming = NULL, Outgoing = NULL;
    ULONG IncomingSize = 0, OutgoingSize = 0;
    ULONG ForestTrustLength = 0;
    PBYTE ForestTrustInfo = NULL;

    //
    // Different info types
    //
    // PLSAPR_TRUSTED_DOMAIN_NAME_INFO NameInfo;
    // PTRUSTED_POSIX_OFFSET_INFO PosixOffset;
    // PLSAPR_TRUSTED_PASSWORD_INFO PasswordInfo;
    PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX DomainInfoEx;
    PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC DomainInfoBasic;
    PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthInfo;
    PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION FullInfo;
    PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 FullInfo2;

    LsapEnterFunc( "LsapDsGetTrustedDomainInfoEx" );

    RtlZeroMemory( &FlatName, sizeof( UNICODE_STRING ) );
    RtlZeroMemory( &Name, sizeof( UNICODE_STRING ) );

    switch ( InformationClass ) {

    case TrustedDomainAuthInformation:  // FALL THROUGH
#ifdef notdef
    case TrustedPasswordInformation:
#endif // notdef

        DomainOrgTreeAttrVals[ 0 ].attrTyp = ATT_TRUST_AUTH_INCOMING;
        DomainOrgTreeAttrVals[ 1 ].attrTyp = ATT_TRUST_AUTH_OUTGOING;
        Items = 2;

        break;

    case TrustedDomainInformationBasic:

        DomainOrgTreeAttrVals[ 0 ].attrTyp = ATT_FLAT_NAME;
        DomainOrgTreeAttrVals[ 1 ].attrTyp = ATT_SECURITY_IDENTIFIER;
        Items = 2;

        break;

    case TrustedDomainInformationEx:

        DomainOrgTreeAttrVals[ 0 ].attrTyp = ATT_TRUST_PARTNER;
        DomainOrgTreeAttrVals[ 1 ].attrTyp = ATT_FLAT_NAME;
        DomainOrgTreeAttrVals[ 2 ].attrTyp = ATT_SECURITY_IDENTIFIER;
        DomainOrgTreeAttrVals[ 3 ].attrTyp = ATT_TRUST_DIRECTION;
        DomainOrgTreeAttrVals[ 4 ].attrTyp = ATT_TRUST_TYPE;
        DomainOrgTreeAttrVals[ 5 ].attrTyp = ATT_TRUST_ATTRIBUTES;
        Items = 6;

        break;

#ifdef notdef // These info levels are never used so don't waste code space
    case TrustedDomainNameInformation:

        DomainOrgTreeAttrVals[ 0 ].attrTyp = ATT_TRUST_PARTNER;
        Items = 1;
        break;

    case TrustedPosixOffsetInformation:

        DomainOrgTreeAttrVals[ 0 ].attrTyp = ATT_TRUST_POSIX_OFFSET;
        Items = 1;
        break;
#endif notdef

    case TrustedDomainFullInformation:

        DomainOrgTreeAttrVals[ 0 ].attrTyp = ATT_TRUST_PARTNER;
        DomainOrgTreeAttrVals[ 1 ].attrTyp = ATT_FLAT_NAME;
        DomainOrgTreeAttrVals[ 2 ].attrTyp = ATT_SECURITY_IDENTIFIER;
        DomainOrgTreeAttrVals[ 3 ].attrTyp = ATT_TRUST_DIRECTION;
        DomainOrgTreeAttrVals[ 4 ].attrTyp = ATT_TRUST_TYPE;
        DomainOrgTreeAttrVals[ 5 ].attrTyp = ATT_TRUST_ATTRIBUTES;
        DomainOrgTreeAttrVals[ 6 ].attrTyp = ATT_TRUST_POSIX_OFFSET;
        // No caller currently needs auth information.
        // DomainOrgTreeAttrVals[ 7 ].attrTyp = ATT_TRUST_AUTH_INCOMING;
        // DomainOrgTreeAttrVals[ 8 ].attrTyp = ATT_TRUST_AUTH_OUTGOING;
        // Items = 9;
        Items = 7;

        break;

    case TrustedDomainFullInformation2Internal:

        DomainOrgTreeAttrVals[ 0 ].attrTyp = ATT_TRUST_PARTNER;
        DomainOrgTreeAttrVals[ 1 ].attrTyp = ATT_FLAT_NAME;
        DomainOrgTreeAttrVals[ 2 ].attrTyp = ATT_SECURITY_IDENTIFIER;
        DomainOrgTreeAttrVals[ 3 ].attrTyp = ATT_TRUST_DIRECTION;
        DomainOrgTreeAttrVals[ 4 ].attrTyp = ATT_TRUST_TYPE;
        DomainOrgTreeAttrVals[ 5 ].attrTyp = ATT_TRUST_ATTRIBUTES;
        DomainOrgTreeAttrVals[ 6 ].attrTyp = ATT_TRUST_POSIX_OFFSET;
        DomainOrgTreeAttrVals[ 7 ].attrTyp = ATT_MS_DS_TRUST_FOREST_TRUST_INFO;
        Items = 8;
        // No caller currently needs auth information.
        // DomainOrgTreeAttrVals[ 8 ].attrTyp = ATT_TRUST_AUTH_INCOMING;
        // DomainOrgTreeAttrVals[ 9 ].attrTyp = ATT_TRUST_AUTH_OUTGOING;
        // Items = 10;

        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;

    }

    //
    // Now, read all of the attributes we care about
    //
    if ( NT_SUCCESS( Status ) ) {

        ReadBlock.attrCount = Items;
        ReadBlock.pAttr = DomainOrgTreeAttrVals;

        Status = LsapDsReadByDsName( ObjectPath,
                                     ReadOptions,
                                     &ReadBlock,
                                     &ReturnedBlock );

        //
        // If that succeeded, then return the proper information
        //
        if ( NT_SUCCESS( Status ) ) {

            if ( Items != ReturnedBlock.attrCount ) {

                LsapDsDebugOut(( DEB_WARN,
                                 "LsapDsGetTrustedDomainInfoEx: Expected %lu attributes, got %lu\n",
                                 Items,
                                 ReturnedBlock.attrCount ));

            }

            for ( i = 0; i < ReturnedBlock.attrCount && NT_SUCCESS( Status ); i++) {

                switch ( ReturnedBlock.pAttr[i].attrTyp ) {


                case ATT_TRUST_PARTNER:
                    Name.Buffer = MIDL_user_allocate(
                                ReturnedBlock.pAttr[i].AttrVal.pAVal->valLen + sizeof( WCHAR ) );
                    if ( Name.Buffer == NULL ) {

                        Status = STATUS_INSUFFICIENT_RESOURCES;

                    } else {

                        RtlZeroMemory( Name.Buffer,
                                       ReturnedBlock.pAttr[i].AttrVal.pAVal->valLen + sizeof(WCHAR) );

                        RtlCopyMemory( Name.Buffer,
                                       ReturnedBlock.pAttr[i].AttrVal.pAVal->pVal,
                                       ReturnedBlock.pAttr[i].AttrVal.pAVal->valLen );

                        Name.Length = (USHORT)ReturnedBlock.pAttr[i].AttrVal.pAVal->valLen;
                        Name.MaximumLength = Name.Length + sizeof( WCHAR );

                    }
                    break;

                case ATT_FLAT_NAME:
                    FlatName.Buffer = MIDL_user_allocate(
                                ReturnedBlock.pAttr[i].AttrVal.pAVal->valLen + sizeof( WCHAR ) );
                    if ( FlatName.Buffer == NULL ) {

                        Status = STATUS_INSUFFICIENT_RESOURCES;

                    } else {

                        RtlZeroMemory( FlatName.Buffer,
                                       ReturnedBlock.pAttr[i].AttrVal.pAVal->valLen + sizeof(WCHAR) );

                        RtlCopyMemory( FlatName.Buffer,
                                       ReturnedBlock.pAttr[i].AttrVal.pAVal->pVal,
                                       ReturnedBlock.pAttr[i].AttrVal.pAVal->valLen );

                        FlatName.Length = (USHORT)ReturnedBlock.pAttr[i].AttrVal.pAVal->valLen;
                        FlatName.MaximumLength = FlatName.Length + sizeof( WCHAR );

                    }
                    break;

                case ATT_SECURITY_IDENTIFIER:
                    Sid = MIDL_user_allocate( ReturnedBlock.pAttr[i].AttrVal.pAVal->valLen );

                    if ( Sid == NULL ) {

                        Status = STATUS_INSUFFICIENT_RESOURCES;

                    } else {

                        RtlCopyMemory( Sid, ReturnedBlock.pAttr[i].AttrVal.pAVal->pVal,
                                       ReturnedBlock.pAttr[i].AttrVal.pAVal->valLen );

                        ASSERT( RtlValidSid( Sid ) );

                    }
                    break;

                case ATT_TRUST_DIRECTION:
                    Direction = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &ReturnedBlock.pAttr[i] );
                    break;

                case ATT_TRUST_TYPE:
                    Type = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &ReturnedBlock.pAttr[i] );
                    break;

                case ATT_TRUST_ATTRIBUTES:
                    Attributes = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &ReturnedBlock.pAttr[i] );
                    break;

                case ATT_TRUST_POSIX_OFFSET:
                    Offset = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &ReturnedBlock.pAttr[i] );
                    break;

                case ATT_TRUST_AUTH_INCOMING:
                    Incoming = ReturnedBlock.pAttr[i].AttrVal.pAVal->pVal;
                    IncomingSize = ReturnedBlock.pAttr[i].AttrVal.pAVal->valLen;
                    break;

                case ATT_TRUST_AUTH_OUTGOING:
                    Outgoing = ReturnedBlock.pAttr[i].AttrVal.pAVal->pVal;
                    OutgoingSize = ReturnedBlock.pAttr[i].AttrVal.pAVal->valLen;
                    break;

                case ATT_MS_DS_TRUST_FOREST_TRUST_INFO:
                    ForestTrustLength = ReturnedBlock.pAttr[i].AttrVal.pAVal->valLen;

                    if ( ForestTrustLength > 0 ) {

                        ForestTrustInfo = ( PBYTE )MIDL_user_allocate( ForestTrustLength );

                        if ( ForestTrustInfo == NULL ) {

                            Status = STATUS_INSUFFICIENT_RESOURCES;

                        } else {

                            RtlCopyMemory(
                                ForestTrustInfo,
                                ReturnedBlock.pAttr[i].AttrVal.pAVal->pVal,
                                ForestTrustLength
                                );
                        }
                    }
                    break;

                default:
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }
            }

        } else if ( Status == STATUS_NOT_FOUND ) {

            //
            // We map the NOT_FOUND error code to OBJECT_NAME_NOT_FOUND, so we don't end up
            // returning an unexpected error code to the outside world
            //
            if ( !FLAG_ON( ReadOptions, LSAPDS_READ_RETURN_NOT_FOUND ) ) {

                Status = STATUS_OBJECT_NAME_NOT_FOUND;
            }
        }


        //
        // Now, simply assemble everything, and return it...  Also, compute the size while
        // we're at it...
        //
        if ( NT_SUCCESS( Status ) ) {

            RetSize = 0;

            switch ( InformationClass ) {
#ifdef notdef
            case TrustedDomainNameInformation:


                NameInfo = (PLSAPR_TRUSTED_DOMAIN_NAME_INFO)TrustedDomainInformation;
                RtlZeroMemory( NameInfo, sizeof( NameInfo ) );
                NameInfo->Name.MaximumLength = Name.MaximumLength;
                RtlCopyUnicodeString( (UNICODE_STRING *)&NameInfo->Name, &Name );
                RetSize += sizeof(PLSAPR_TRUSTED_DOMAIN_NAME_INFO) + Name.MaximumLength;
                break;

            case TrustedControllersInformation:

                Status = STATUS_NOT_IMPLEMENTED;
                break;

            case TrustedPosixOffsetInformation:

                PosixOffset = (PTRUSTED_POSIX_OFFSET_INFO)TrustedDomainInformation;
                RtlZeroMemory( PosixOffset, sizeof( PosixOffset ) );
                PosixOffset->Offset = Offset;
                RetSize += sizeof( PTRUSTED_POSIX_OFFSET_INFO );
                break;
#endif // notdef

            case TrustedDomainAuthInformation:

                AuthInfo = (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION)TrustedDomainInformation;
                RtlZeroMemory( AuthInfo, sizeof( AuthInfo ) );

                Status = LsapDsUnmarshalAuthInfoHalf(
                             NULL,
                             FALSE,
                             FALSE,
                             Incoming,
                             IncomingSize,
                             LsapDsAuthHalfFromAuthInfo( AuthInfo, TRUE ) );

                if ( NT_SUCCESS( Status ) ) {

                    Status = LsapDsUnmarshalAuthInfoHalf(
                                NULL,
                                FALSE,
                                FALSE,
                                Outgoing,
                                OutgoingSize,
                                LsapDsAuthHalfFromAuthInfo( AuthInfo, FALSE ) );

                    if ( !NT_SUCCESS( Status ) ) {

                        LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( AuthInfo, TRUE ) );
                    }
                }

                break;

#ifdef notdef
            case TrustedPasswordInformation:

                Status = STATUS_NOT_IMPLEMENTED;

                break;
#endif // notdef

            case TrustedDomainInformationBasic:

                DomainInfoBasic =
                            ( PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC )TrustedDomainInformation;
                RtlZeroMemory( DomainInfoBasic, sizeof( DomainInfoBasic ) );
                RetSize += sizeof( PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC );

                RetSize += FlatName.MaximumLength;
                RtlCopyMemory( &DomainInfoBasic->Name, &FlatName, sizeof( UNICODE_STRING ) );
                DomainInfoBasic->Sid = Sid;
                if ( Sid ) {

                    RetSize += RtlLengthSid( Sid );

                }

                break;

            case TrustedDomainFullInformation2Internal:

                FullInfo2 = ( PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 )TrustedDomainInformation;
                RtlZeroMemory( FullInfo2, sizeof( LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 ));

                RtlCopyMemory( &FullInfo2->Information.Name, &Name, sizeof( UNICODE_STRING ));
                RtlCopyMemory( &FullInfo2->Information.FlatName, &FlatName, sizeof( UNICODE_STRING ));
                FullInfo2->Information.Sid = Sid;
                FullInfo2->Information.TrustType = Type;
                FullInfo2->Information.TrustAttributes = Attributes;
                FullInfo2->Information.TrustDirection = Direction;
                FullInfo2->Information.ForestTrustInfo = ForestTrustInfo;
                FullInfo2->Information.ForestTrustLength = ForestTrustLength;
                FullInfo2->PosixOffset.Offset = Offset;
                RetSize += Name.MaximumLength +
                           FlatName.MaximumLength +
                           ( Sid ? RtlLengthSid( Sid ) : 0 ) +
                           6 * sizeof( ULONG ) +
                           ForestTrustLength;
                break;

            case TrustedDomainFullInformation:

                FullInfo = ( PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION )TrustedDomainInformation;
                RtlZeroMemory( FullInfo, sizeof(FullInfo) );

                FullInfo->PosixOffset.Offset = Offset;
                RetSize += sizeof(ULONG);
                /* Drop through */

            case TrustedDomainInformationEx:

                DomainInfoEx = ( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX )TrustedDomainInformation;
                RtlZeroMemory( DomainInfoEx, sizeof( DomainInfoEx ) );
                RetSize += sizeof( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX );

                RetSize += Name.MaximumLength;
                RtlCopyMemory( &DomainInfoEx->Name, &Name, sizeof( UNICODE_STRING ) );
                RetSize += FlatName.MaximumLength;
                RtlCopyMemory( &DomainInfoEx->FlatName, &FlatName, sizeof( UNICODE_STRING ) );
                DomainInfoEx->Sid = Sid;
                if ( Sid ) {

                    RetSize += RtlLengthSid( Sid );

                }

                DomainInfoEx->TrustType = Type;
                DomainInfoEx->TrustAttributes = Attributes;
                DomainInfoEx->TrustDirection = Direction;
                RetSize += 3 * sizeof( ULONG );


                break;


            }


        }
    }

    if ( !NT_SUCCESS( Status ) ) {

        MIDL_user_free( ForestTrustInfo );
        MIDL_user_free( Name.Buffer );
        MIDL_user_free( Sid );

    } else if ( Size != NULL ) {

        *Size = RetSize;

    }

    LsapExitFunc( "LsapDsGetTrustedDomainInfoEx", Status );

    return( Status );
}




NTSTATUS
LsapDsUnMarshalAuthInfoForReturn(
    IN ULONG Items,
    IN PBYTE Buffer OPTIONAL,
    IN ULONG Length,
    OUT PLSAPR_AUTH_INFORMATION *RetAuthInfo
    )
/*++

Routine Description:

    This function will unmarshal an authinfo list

Arguments:

    Infos - Number of authinfos in Buffer

    Buffer - Buffer to unmarshal from.

    Length - Length (in bytes) of Buffer.

    RetAuthInfo - AuthenticationInformation to fill in.
        Free by calling LsapDsFreeUnmarshaledAuthInfo then MIDL_user_free.

Returns:

    STATUS_SUCCESS -- Success

    STATUS_INSUFFICIENT_RESOURCES -- A memory allocation failed

    STATUS_INTERNAL_DB_CORRUPTION -- Buffer is corrupt

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;
    ULONG ArraySize;
    PLSAPR_AUTH_INFORMATION AuthInfo;
    PBYTE BufferEnd = Buffer + Length;

    LsapEnterFunc( "LsapDsUnMarshalAuthInfoForReturn" );

    //
    // If there is no input auth info,
    //   we're done.
    //
    *RetAuthInfo = NULL;
    if ( Buffer == NULL || Length == 0 ) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Determine the size of the authinfo array.
    //

    if ( Items > 0xFFFFFFFF/sizeof(LSAPR_AUTH_INFORMATION) ) {
        Status = STATUS_INTERNAL_DB_CORRUPTION;
        LsapExitFunc( "LsapDsUnMarshalAuthInfoForReturn", Status );
        return Status;
    }
    ArraySize = Items * sizeof(LSAPR_AUTH_INFORMATION);

    //
    // Allocate a buffer for the authinfo array.
    //

    *RetAuthInfo = MIDL_user_allocate( ArraySize );

    if ( *RetAuthInfo == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    AuthInfo = *RetAuthInfo;

    RtlZeroMemory( AuthInfo, ArraySize );

    //
    // Copy each authinfo
    //

    for (i = 0; i < Items ; i++ ) {

        if ( Buffer+sizeof(LARGE_INTEGER)+sizeof(ULONG)+sizeof(ULONG) > BufferEnd ) {
            Status = STATUS_INTERNAL_DB_CORRUPTION;
            goto Cleanup;
        }

        RtlCopyMemory( &(AuthInfo[ i ].LastUpdateTime), Buffer, sizeof( LARGE_INTEGER ) );
        Buffer += sizeof( LARGE_INTEGER );

        AuthInfo[ i ].AuthType = *(PULONG)Buffer;
        Buffer += sizeof ( ULONG );

        AuthInfo[i].AuthInfoLength = *(PULONG)Buffer;
        Buffer += sizeof ( ULONG );

        if ( AuthInfo[ i ]. AuthInfoLength == 0 ) {

            AuthInfo[i].AuthInfo = NULL;

        } else {

            if ( AuthInfo[ i ]. AuthInfoLength > Length ||
                 Buffer + AuthInfo[ i ]. AuthInfoLength > BufferEnd ) {
                Status = STATUS_INTERNAL_DB_CORRUPTION;
                goto Cleanup;
            }

            AuthInfo[i].AuthInfo = MIDL_user_allocate( AuthInfo[i].AuthInfoLength );

            if ( AuthInfo[ i ].AuthInfo == NULL ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory( AuthInfo[ i ].AuthInfo, Buffer, AuthInfo[i].AuthInfoLength );

            Buffer += ROUND_UP_COUNT(AuthInfo[ i ].AuthInfoLength,
                                  ALIGN_DWORD);
        }
    }

    Status = STATUS_SUCCESS;

Cleanup:
    if ( !NT_SUCCESS(Status) ) {
        if ( *RetAuthInfo != NULL ) {
            LsapDsFreeUnmarshaledAuthInfo( Items, *RetAuthInfo );
            MIDL_user_free( *RetAuthInfo );
            *RetAuthInfo = NULL;
        }
    }
    LsapExitFunc( "LsapDsUnMarshalAuthInfoForReturn", Status );

    return( Status );
}



NTSTATUS
LsapDsBuildAuthInfoFromAttribute(
    IN LSAPR_HANDLE Handle,
    IN PBYTE Buffer,
    IN ULONG Len,
    OUT PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF NewAuthInfo
    )
/*++

Routine Description:

    This function builds an authentication information structure from a marshaled blob

Arguments:

    Handle - Handle to the trusted domain object which holds this information

    Incoming - Building incoming or outgoing authinfo

    Buffer - Marshaled buffer

    Len - Length of the buffer

    NewAuthInfo - AuthenticationInformation structure to fill in
        Free this buffer by calling LsapDsFreeUnmarshalAuthInfoHalf or by letting
            the RPC server side stub free it.

Returns:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Items = 0;
    PBYTE Current, Prev;
    PLSAPR_AUTH_INFORMATION CurrentAuth = NULL;
    PLSAPR_AUTH_INFORMATION PrevAuth = NULL;

    LsapEnterFunc( "LsapDsBuildAuthInfoFromAttribute" );

    if ( Buffer == NULL || ( Len == sizeof(ULONG) && *Buffer == 0 ) ) {

        NewAuthInfo->AuthInfos = 0;
        NewAuthInfo->AuthenticationInformation = NULL;
        NewAuthInfo->PreviousAuthenticationInformation = NULL;

    } else {

        Status = LsapDsUnmarshalAuthInfoHalf( Handle,
                                              TRUE,
                                              FALSE,
                                              Buffer,
                                              Len,
                                              NewAuthInfo );
    }

    LsapExitFunc( "LsapDsBuildAuthInfoFromAttribute", Status );
    return( Status );
}



NTSTATUS
LsapDsUnmarshalAuthInfoHalf(
    IN LSAPR_HANDLE ObjectHandle,
    IN BOOLEAN ReturnOnlyFirstAuthInfo,
    IN BOOLEAN AllowEmptyPreviousInfo,
    IN PBYTE Buffer,
    IN ULONG Length,
    OUT PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF AuthInfo
    )
/*++

Routine Description:

    This function will take a marshaled authinfo structure, decrypt it using the Lsa key,
    unmarshal it, and optionally reencrypt it with the session key

Arguments:

    ObjectHandle - Handle to the trusted domain object which holds this information

    ReturnOnlyFirstAuthInfo - Pass TRUE if only the first element of the auth info
        array is to be returned.

    AllowEmptyPreviousInfo - Pass TRUE if it is OK to return NULL as the previuos
        AuthInfo.  Otherwise, the current auth info will be duplicated.

    Buffer - Marshaled buffer

    Length - Length of the buffer

    AuthInfo - Unmarshaled AuthInfo goes here.
        Free this buffer by calling LsapDsFreeUnmarshalAuthInfoHalf or by letting
            the RPC server side stub free it.


Returns:

    STATUS_SUCCESS - Success


--*/
{
    NTSTATUS Status;
    ULONG Items;

    PBYTE Auth, Prev;
    ULONG AuthLen, PrevLen;
    PBYTE Where;

    LsapEnterFunc( "LsapDsUnmarshalAuthInfoHalf" );

    //
    // Make sure we don't have the plug
    //
    RtlZeroMemory( AuthInfo, sizeof( LSAPR_TRUST_DOMAIN_AUTH_INFO_HALF ) );
    if ( ( Length == 0 || Length == sizeof( ULONG ) )  &&
         ( Buffer == NULL || *( PULONG )Buffer == 0 ) ) {

        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // The format of the buffer is:
    //
    // [Info count][OffsetCurrent][OffsetPrevious] and then some number of the following:
    // [UpdateTime(LargeInteger)][AuthType][AuthInfoLen][data (sizeis(AuthInfoLen) ]
    //
    Where = Buffer;
    Items = *(PULONG)Where;
    Where += sizeof(ULONG );

    if ( (*(PULONG)Where) > Length ) {
        Status = STATUS_INTERNAL_DB_CORRUPTION;
        goto Cleanup;
    }
    Auth = Buffer + *(PULONG)Where;
    Where += sizeof(ULONG );

    if ( (*(PULONG)Where) > Length ) {
        Status = STATUS_INTERNAL_DB_CORRUPTION;
        goto Cleanup;
    }
    Prev = Buffer + *(PULONG)Where;

    AuthLen = (ULONG)(Prev - Auth);

    PrevLen = (ULONG)((Buffer + Length) - Prev);

    AuthInfo->AuthInfos = Items;

    //
    // There is a bug in the idl definition of LSAPR_TRUST_DOMAIN_AUTH_INFO_HALF
    //  At most, one AuthInfo can be returned.  So, for out of process clients,
    //  don't return more than one.
    //

    if ( ReturnOnlyFirstAuthInfo &&
         ObjectHandle &&
         !((LSAP_DB_HANDLE)ObjectHandle)->Trusted &&
         AuthInfo->AuthInfos > 1 ) {
        AuthInfo->AuthInfos = 1;
    }

    //
    // If we have no previous info, return the current info as previous.
    //

    if ( !AllowEmptyPreviousInfo && PrevLen == 0 && AuthLen > 0 ) {

        PrevLen = AuthLen;
        Prev = Auth;
        if ( ObjectHandle ) {

            LsapDsDebugOut(( DEB_ERROR,
                             "No PREVIOUS auth info.  Returning current for %wZ\n",
                              &( ( LSAP_DB_HANDLE )ObjectHandle )->PhysicalNameDs ));
        }
    }

    //
    // Do the actual unmarshalling
    //

    Status = LsapDsUnMarshalAuthInfoForReturn( AuthInfo->AuthInfos,
                                               Auth,
                                               AuthLen,
                                               &AuthInfo->AuthenticationInformation );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsapDsUnMarshalAuthInfoForReturn(
                     AuthInfo->AuthInfos,
                     Prev,
                     PrevLen,
                     &AuthInfo->PreviousAuthenticationInformation );
    }


    //
    // If something failed, clean up after ourselves
    //
Cleanup:
    if ( !NT_SUCCESS( Status ) ) {
        LsapDsFreeUnmarshalAuthInfoHalf( AuthInfo );
        AuthInfo->AuthInfos = 0;
        AuthInfo->PreviousAuthenticationInformation = NULL;
        AuthInfo->AuthenticationInformation = NULL;
    }

    LsapExitFunc( "LsapDsUnmarshalAuthInfoHalf", Status );
    return( Status );
}




VOID
LsapDsFreeUnmarshaledAuthInfo(
    IN ULONG Items,
    IN PLSAPR_AUTH_INFORMATION AuthInfo
    )
/*++

Routine Description:

    This function will free an authinfo struct allocated during unmarshalling

Arguments:

    Items - Number of items in the list

    AuthInfo - AuthenticationInformation to free

Returns:

    VOID

--*/
{
    ULONG i;
    if ( AuthInfo != NULL ) {
        for ( i = 0; i < Items; i++) {
            MIDL_user_free( AuthInfo[ i ].AuthInfo );
        }
    }

}



NTSTATUS
LsapDsBuildAuthInfoAttribute(
    IN LSAPR_HANDLE Handle,
    IN PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF NewAuthInfo,
    IN PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF PreviousAuthInfo,
    OUT PBYTE *Buffer,
    OUT PULONG Len
    )
/*++

Routine Description:

    This function will take an AuthInfo, merge it with the old AuthInfo, convert it into
    a writable blob

Arguments:

    Handle - Handle to open trusted domain object

    NewAuthInfo - AuthInfo to set on the object

    PreviousAuthInfo - AuthInfo that currently exists on the object

    Buffer - Where to return the allocated buffer

    Len - Where to return the buffer length

Returns:

    STATUS_SUCCESS - Success

    STATUS_UNSUCCESSFUL - Client coming in is trusted.

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed.

--*/
{
    NTSTATUS Status;
    PLSAP_CR_CIPHER_VALUE Encrypted;
    PLSAPR_AUTH_INFORMATION Prev = NULL;
    LSAPR_TRUST_DOMAIN_AUTH_INFO_HALF SetAuthHalf;
    ULONG i,j;

    LsapEnterFunc( "LsapDsBuildAuthInfoAttribute" );

    if ( NewAuthInfo == NULL ) {

        *Buffer = NULL;
        *Len = 0;

        Status = STATUS_SUCCESS;
        LsapExitFunc( "LsapDsBuildAuthInfoAttribute", Status );
        return Status;
    }

    //
    // Always use the new authentication info passed by the caller
    //

    SetAuthHalf.AuthInfos = NewAuthInfo->AuthInfos;
    SetAuthHalf.AuthenticationInformation = NewAuthInfo->AuthenticationInformation;

    //
    // If the caller passed in explicit Previous Authentication info,
    //  use it.
    //

    if ( NewAuthInfo->PreviousAuthenticationInformation != NULL ) {

        SetAuthHalf.PreviousAuthenticationInformation = NewAuthInfo->PreviousAuthenticationInformation;

        //
        // Verify that the AuthTypes in this array are in the same order as
        // the new auth info.
        //

        for( i = 0; i < SetAuthHalf.AuthInfos; i++ ) {

            if ( ( SetAuthHalf.AuthenticationInformation[i].AuthType !=
                   SetAuthHalf.PreviousAuthenticationInformation[i].AuthType ) &&
                 ( SetAuthHalf.PreviousAuthenticationInformation[i].AuthType !=
                   TRUST_AUTH_TYPE_NONE ) &&
                 ( SetAuthHalf.AuthenticationInformation[i].AuthType !=
                   TRUST_AUTH_TYPE_NONE ) ) {
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

    //
    // If the caller didn't pass explicit Previous Authentication info,
    //  compute it.

    } else {

        //
        // Default the Previous Authentication info to the new authentication info
        //  explicitly passed by the caller.
        //
        // This copy of the Authentication info has all of the AuthTypes in the
        //  right order.
        //
        // If none of the current auth info can be merged in,
        //  we'll simply end up with the previous auth info equaling the
        //  new auth info.
        //

        SetAuthHalf.PreviousAuthenticationInformation = SetAuthHalf.AuthenticationInformation;

        //
        // If there was Auth info on the object before,
        //  try to use as much auth info from the object as we can.
        //
        // That is, if the caller just passes a new auth info data,
        //  the "current" auth info data on the object is now the previuos auth info.
        //  The only gotcha is that the new auth info data might have totally
        //  different AuthTypes.  So, we grab only that portion of the current
        //  auth info data that matches the AuthTypes from the new auth info.
        //
        if ( PreviousAuthInfo != NULL ) {


            //
            // Allocate a buffer to do the merge into.
            //

            Prev = LsapAllocateLsaHeap( sizeof( LSAPR_AUTH_INFORMATION) * NewAuthInfo->AuthInfos );

            if ( Prev == NULL ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }


            //
            // Initialize the buffer to simply be a copy of the new auth info.
            //

            RtlCopyMemory( Prev,
                           SetAuthHalf.PreviousAuthenticationInformation,
                           SetAuthHalf.AuthInfos * sizeof( LSAPR_AUTH_INFORMATION) );

            SetAuthHalf.PreviousAuthenticationInformation = Prev;


            //
            // Loop through each of these entries ...
            //

            for( i = 0; i < SetAuthHalf.AuthInfos; i++ ) {

                //
                // ... finding the corresponding entry in the old list.
                //
                for ( j = 0; j < PreviousAuthInfo->AuthInfos; j++) {

                    if ( SetAuthHalf.PreviousAuthenticationInformation[i].AuthType ==
                         PreviousAuthInfo->AuthenticationInformation[j].AuthType ) {

                        //
                        // If the entry used to exist on the object,
                        //  use that entry rather than the default.
                        //
                        // Note, we don't need to copy the actual auth data here.
                        //  We just copy the structure that points to the data.
                        //

                        SetAuthHalf.PreviousAuthenticationInformation[i] =
                             PreviousAuthInfo->AuthenticationInformation[j];
                        break;

                    }
                }

            }

        }
    }




    //
    // Marshall the resultant auth info.
    //

    Status = LsapDsMarshalAuthInfoHalf( &SetAuthHalf, Len, Buffer );



    //
    // Free any memory we may have allocated
    //
Cleanup:
    if ( Prev ) {
        LsapFreeLsaHeap( Prev );
    }

    LsapExitFunc( "LsapDsBuildAuthInfoAttribute", Status );
    return( Status );
}




NTSTATUS
LsapDsFindAuthTypeInAuthInfo(
    IN  ULONG AuthType,
    IN  PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthInfo,
    IN  BOOLEAN Incoming,
    IN  BOOLEAN AddIfNotFound,
    OUT BOOLEAN *Added,
    OUT PULONG AuthTypeIndex
    )
/*++

Routine Description:

    This function will find the index of the first auth blob it finds of the given type.
    Optionally, if the entry is not found, a new node can be allocated and added to the lsit

Arguments:

    AuthType - AuthType to find

    AuthInfo - Auth info to search

    Incoming - Search incoming or outgoing

    AddIfNotFound - If TRUE, the entry is added to the end of the list

    AutyTypeIndex - Where the index is returned

Returns:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed.

    STATUS_NOT_FOUND - The object wasn't found

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Items, Index = 0xFFFFFFFF, i;
    PLSAPR_AUTH_INFORMATION SearchList, SearchPrev;
    PLSAPR_AUTH_INFORMATION Current = NULL, Previous = NULL;

    *Added = FALSE;

    if ( Incoming ) {

        Items = AuthInfo->IncomingAuthInfos;
        SearchList = AuthInfo->IncomingAuthenticationInformation;
        SearchPrev = AuthInfo->IncomingPreviousAuthenticationInformation;

    } else {

        Items = AuthInfo->OutgoingAuthInfos;
        SearchList = AuthInfo->OutgoingAuthenticationInformation;
        SearchPrev = AuthInfo->OutgoingPreviousAuthenticationInformation;

    }

    //
    // Now, find the index of the entry in the auth list
    //
    for ( i = 0; i < Items ; i++ ) {

        if ( SearchList[ i ].AuthType == AuthType) {
            Index = i;
            break;
        }
    }

    if ( Index == 0xFFFFFFFF ) {

        if ( !AddIfNotFound ) {

            Status = STATUS_NOT_FOUND;

        } else {

            //
            // We'll have to add it, since it doesn't currently exist.
            //
            Current = LsapAllocateLsaHeap( sizeof( LSAPR_AUTH_INFORMATION ) * ( Items + 1 ) );

            if ( Current != NULL ) {

                Previous = LsapAllocateLsaHeap( sizeof( LSAPR_AUTH_INFORMATION ) * ( Items + 1 ) );
            }

            if ( Current == NULL || Previous == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                Index = Items;
                RtlCopyMemory( Current, SearchList,
                               sizeof( LSAPR_AUTH_INFORMATION ) * Items );

                if ( SearchPrev ) {

                    RtlCopyMemory( Previous, SearchPrev,
                                   sizeof( LSAPR_AUTH_INFORMATION ) * Items );

                }
                Items++;
                *Added = TRUE;
            }

            if ( Incoming ) {

                AuthInfo->IncomingAuthInfos = Items;
                AuthInfo->IncomingAuthenticationInformation = Current;
                AuthInfo->IncomingPreviousAuthenticationInformation = Previous;

            } else {

                AuthInfo->OutgoingAuthInfos = Items;
                AuthInfo->OutgoingAuthenticationInformation = Current;
                AuthInfo->OutgoingPreviousAuthenticationInformation = Previous;

            }

        }
    }


    if ( NT_SUCCESS( Status ) ) {

        *AuthTypeIndex = Index;
    }

    if ( !*Added ) {

        LsapFreeLsaHeap( Previous );
        LsapFreeLsaHeap( Current );
    }

    return( Status );
}


NTSTATUS
LsapDsSetSecretOnTrustedDomainObject(
    IN LSAP_DB_HANDLE TrustedDomainHandle,
    IN ULONG AuthDataType,
    IN PLSAP_CR_CLEAR_VALUE ClearCurrent,
    IN PLSAP_CR_CLEAR_VALUE ClearOld,
    IN PLARGE_INTEGER CurrentValueSetTime
    )
/*++

Routine Description:

    This function perform the equvialent of setting the values on a secret that corresponds
    to a trusted domain object.

Arguments:

    TrustedDomainHandle - Handle to trusted domain object

    ClearCurrent - New secret value

    ClearOld - Old secret value

Returns:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed.

--*/
{

    //
    // Use a common routine that supports both incoming and outgoing trust.
    //

    return LsapDsAuthDataOnTrustedDomainObject(
                        TrustedDomainHandle,
                        FALSE,      // Set the outgoing trust
                        AuthDataType,
                        ClearCurrent,
                        ClearOld,
                        CurrentValueSetTime );

}



NTSTATUS
LsapDsAuthDataOnTrustedDomainObject(
    IN LSAP_DB_HANDLE TrustedDomainHandle,
    IN BOOLEAN Incoming,
    IN ULONG AuthDataType,
    IN PLSAP_CR_CLEAR_VALUE ClearCurrent,
    IN PLSAP_CR_CLEAR_VALUE ClearOld,
    IN PLARGE_INTEGER CurrentValueSetTime
    )
/*++

Routine Description:

    This function perform the equvialent of setting the values on a secret that corresponds
    to a trusted domain object.

Arguments:

    TrustedDomainHandle - Handle to trusted domain object

    Incoming -- Whether to set the incoming or going data

    AuthDataType -- Type of the auth data being set

    ClearCurrent - New secret value

    ClearOld - Old secret value

    CurrentValueSetTime -- Time of the set.

Returns:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthInfo = { 0 };
    ULONG Index, Options = 0;
    PDSNAME DsName;
    BOOLEAN Added = FALSE ;
    BOOLEAN CloseTransaction;
    PLSA_AUTH_INFORMATION NewIncoming = NULL, NewPrevious = NULL;

    LsapEnterFunc( "LsapDsAuthDataOnTrustedDomainObject" );

    if ( AuthDataType != TRUST_AUTH_TYPE_CLEAR && AuthDataType != TRUST_AUTH_TYPE_NT4OWF ) {

        Status = STATUS_INVALID_PARAMETER;
        LsapExitFunc( "LsapDsAuthDataOnTrustedDomainObject", Status );
        return( Status );
    }

    //
    //  See if we already have a transaction going
    //
    //  If we don't already have a transaction in progress,
    //  the transaction completion won't cause a netlogon notification.
    //

    LsapAssertDsTransactionOpen();

    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_DS_OP_TRANSACTION |
                                            LSAP_DB_READ_ONLY_TRANSACTION,
                                        TrustedDomainObject,
                                        &CloseTransaction );

    if ( !NT_SUCCESS( Status ) ) {

        LsapExitFunc( "LsapDsAuthDataOnTrustedDomainObject", Status );
        return( Status );
    }

    Status = LsapAllocAndInitializeDsNameFromUnicode(
                 LsapDsObjTrustedDomain,
                 &TrustedDomainHandle->PhysicalNameDs,
                 &DsName
                 );

    if ( NT_SUCCESS( Status ) ) {

        RtlZeroMemory( &AuthInfo, sizeof( LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION ) );

        Status = LsapDsGetTrustedDomainInfoEx( DsName,
                                               LSAPDS_READ_NO_LOCK,
                                               TrustedDomainAuthInformation,
                                               (PLSAPR_TRUSTED_DOMAIN_INFO)&AuthInfo,
                                               NULL );

        if ( NT_SUCCESS( Status ) ||
             Status == STATUS_NOT_FOUND ||
             Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

            BOOLEAN MustFreeClearOld = FALSE;

            //
            // Now, find the index of the CLEAR entry in the correct auth list
            //
            Status = LsapDsFindAuthTypeInAuthInfo( AuthDataType,
                                                   &AuthInfo,
                                                   Incoming,
                                                   TRUE,
                                                   &Added,
                                                   &Index );

            if ( NT_SUCCESS( Status ) ) {

                if ( ClearCurrent == NULL ) {

                    if ( Incoming ) {

                        RtlZeroMemory( &AuthInfo.IncomingAuthenticationInformation[ Index ],
                                       sizeof( LSAPR_AUTH_INFORMATION ) );

                    } else {

                        RtlZeroMemory( &AuthInfo.OutgoingAuthenticationInformation[ Index ],
                                       sizeof( LSAPR_AUTH_INFORMATION ) );

                    }

                } else {

                    LSAPDS_SET_AUTH_INFO(
                        Incoming ?
                            &AuthInfo.IncomingAuthenticationInformation[ Index ] :
                            &AuthInfo.OutgoingAuthenticationInformation[ Index ],
                        CurrentValueSetTime,
                        AuthDataType,
                        ClearCurrent->Length,
                        ClearCurrent->Buffer );
                }

                //
                // LsaDbSetSecret expects the old password
                // to be set to the previous current password
                //

                if ( ClearOld == NULL ) {

                    BOOLEAN SavedTrusted;

                    //
                    // We may not have access, so go as trusted.
                    // Password comes back in the clear.
                    //

                    SavedTrusted = TrustedDomainHandle->Trusted;
                    TrustedDomainHandle->Trusted = TRUE;

                    Status = LsarQuerySecret(
                                 TrustedDomainHandle,
                                 &(PLSAPR_CR_CIPHER_VALUE)ClearOld,
                                 NULL,
                                 NULL,
                                 NULL);

                    TrustedDomainHandle->Trusted = SavedTrusted;

                    if ( !NT_SUCCESS( Status ) && ClearOld) {

                        LsapCrFreeMemoryValue( ClearOld );
                        ClearOld = NULL;

                    } else {

                        MustFreeClearOld = TRUE;
                    }

                    Status = STATUS_SUCCESS;

                    //
                    // Failure to obtain old value should not stop us, as the worst
                    // thing that could happen is it won't be set, and that's not fatal
                    //
                }

                if ( ClearOld == NULL ) {

                    if ( Incoming ) {

                        RtlZeroMemory( &AuthInfo.IncomingPreviousAuthenticationInformation[ Index ],
                                       sizeof( LSAPR_AUTH_INFORMATION ) );

                    } else {

                        RtlZeroMemory( &AuthInfo.OutgoingPreviousAuthenticationInformation[ Index ],
                                       sizeof( LSAPR_AUTH_INFORMATION ) );

                    }

                } else {

                    LSAPDS_SET_AUTH_INFO(
                        Incoming ?
                            &AuthInfo.IncomingPreviousAuthenticationInformation[ Index ] :
                            &AuthInfo.OutgoingPreviousAuthenticationInformation[ Index ],
                        CurrentValueSetTime,
                        AuthDataType,
                        ClearOld->Length,
                        ClearOld->Buffer );
                }
            }

            //
            // Finally, set it
            //
            if ( NT_SUCCESS (Status ) ) {

                //
                // Since we already have the db locked, we'll fool the set routine into
                // thinking we're a trusted client and have therefore locked the database
                //
                if ( !Incoming ) {
                    Options = TrustedDomainHandle->Options;
                    TrustedDomainHandle->Options |= LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET;
                }

                Status = LsarSetInformationTrustedDomain( TrustedDomainHandle,
                                                          TrustedDomainAuthInformation,
                                                          (PLSAPR_TRUSTED_DOMAIN_INFO)&AuthInfo );

                if ( !Incoming ) {
                    TrustedDomainHandle->Options = Options;
                }

            }

            if ( MustFreeClearOld ) {

                LsapCrFreeMemoryValue( ClearOld );
                ClearOld = NULL;
            }
        }

        LsapDsFree( DsName );
    }

    if ( Added ) {

        if ( Incoming ) {

            LsapFreeLsaHeap( AuthInfo.IncomingAuthenticationInformation );
            LsapFreeLsaHeap( AuthInfo.IncomingPreviousAuthenticationInformation );

        } else {

            LsapFreeLsaHeap( AuthInfo.OutgoingAuthenticationInformation );
            LsapFreeLsaHeap( AuthInfo.OutgoingPreviousAuthenticationInformation );

        }

    }

    //
    // Destruction of the thread state will delete any allocated Ds memory
    //

    LsapDsDeleteAllocAsNeededEx( LSAP_DB_DS_OP_TRANSACTION |
                                    LSAP_DB_READ_ONLY_TRANSACTION,
                                 TrustedDomainObject,
                                 CloseTransaction );

    LsapExitFunc( "LsapDsAuthDataOnTrustedDomainObject", Status );
    return( Status );
}




NTSTATUS
LsapDsGetSecretOnTrustedDomainObject(
    IN LSAP_DB_HANDLE TrustedDomainHandle,
    IN OPTIONAL PLSAP_CR_CIPHER_KEY SessionKey OPTIONAL,
    OUT PLSAP_CR_CIPHER_VALUE *CipherCurrent OPTIONAL,
    OUT PLSAP_CR_CIPHER_VALUE *CipherOld OPTIONAL,
    OUT PLARGE_INTEGER CurrentValueSetTime OPTIONAL,
    OUT PLARGE_INTEGER OldValueSetTime OPTIONAL
    )
/*++

Routine Description:

    This function perform the equvialent of getting the values on a secret that corresponds
    to a trusted domain object.

Arguments:

    TrustedDomainHandle - Handle to trusted domain object

    SessionKey - Optional SessionKey to use for encrypting the values

    CipherCurrent - Where to return the current value

    CipherOld - Where to return previous current value

    CurrValueSetTime - Where to return the current set time

    OldValueSetTime - Where to return the old set time

Returns:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed.

    STATUS_NOT_FOUND - No such auth data exists

    STATUS_INVALID_PARAMETER - No information was requested

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthInfo;
    ULONG Index;
    PDSNAME DsName;
    BOOLEAN Added;
    BOOLEAN CloseTransaction;
    LSAP_CR_CLEAR_VALUE ClearValue;

    if ( !ARGUMENT_PRESENT( CipherCurrent ) && !ARGUMENT_PRESENT( CipherOld ) &&
         !ARGUMENT_PRESENT( CurrentValueSetTime) && !ARGUMENT_PRESENT( OldValueSetTime ) ) {

         return( STATUS_INVALID_PARAMETER );
    }

    LsapEnterFunc( "LsapDsGetSecretOnTrustedDomainObject" );

    //
    //  See if we already have a transaction going
    //
    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_DS_OP_TRANSACTION |
                                            LSAP_DB_READ_ONLY_TRANSACTION,
                                        TrustedDomainObject,
                                        &CloseTransaction );

    if ( !NT_SUCCESS( Status ) ) {

        LsapExitFunc( "LsapDsGetSecretOnTrustedDomainObject", Status );
        return( Status );
    }

    Status = LsapAllocAndInitializeDsNameFromUnicode(
                 LsapDsObjTrustedDomain,
                 &TrustedDomainHandle->PhysicalNameDs,
                 &DsName
                 );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsapDsGetTrustedDomainInfoEx( DsName,
                                               LSAPDS_READ_RETURN_NOT_FOUND,
                                               TrustedDomainAuthInformation,
                                               (PLSAPR_TRUSTED_DOMAIN_INFO)&AuthInfo,
                                               NULL );

        if ( NT_SUCCESS( Status ) ) {

            //
            // Now, find the index of the CLEAR entry in the outgoing auth list
            //
            Status = LsapDsFindAuthTypeInAuthInfo( TRUST_AUTH_TYPE_CLEAR,
                                                   &AuthInfo,
                                                   FALSE,
                                                   FALSE,
                                                   &Added,
                                                   &Index );

            if ( NT_SUCCESS( Status ) ) {

                if ( ARGUMENT_PRESENT( CipherCurrent ) ) {

                    ClearValue.Length =
                               AuthInfo.OutgoingAuthenticationInformation[ Index ].AuthInfoLength;
                    ClearValue.MaximumLength =  ClearValue.Length;
                    ClearValue.Buffer = AuthInfo.OutgoingAuthenticationInformation[ Index ].AuthInfo;

                    if ( !LsapValidateLsaCipherValue( &ClearValue ) ) {

                        Status = STATUS_INVALID_PARAMETER;

                    } else if ( SessionKey != NULL ) {

                        Status = LsapCrEncryptValue ( &ClearValue, SessionKey, CipherCurrent );

                    } else {

                        *CipherCurrent = MIDL_user_allocate( sizeof( LSAP_CR_CIPHER_VALUE ) +
                                            ClearValue.Length );

                        if ( *CipherCurrent == NULL ) {

                            Status = STATUS_INSUFFICIENT_RESOURCES;

                        } else {

                            (*CipherCurrent)->Length = ClearValue.Length;
                            (*CipherCurrent)->MaximumLength = ClearValue.Length;
                            (*CipherCurrent)->Buffer = (PBYTE)(*CipherCurrent) +
                                                                 sizeof( LSAP_CR_CIPHER_VALUE );
                            RtlCopyMemory( (*CipherCurrent)->Buffer,
                                           ClearValue.Buffer,
                                           ClearValue.Length );
                        }
                    }

                }

                if ( NT_SUCCESS( Status ) &&
                     ARGUMENT_PRESENT( CipherOld ) )  {

                    ClearValue.Length =
                        AuthInfo.OutgoingPreviousAuthenticationInformation[ Index ].AuthInfoLength;
                    ClearValue.MaximumLength =  ClearValue.Length;
                    ClearValue.Buffer =
                            AuthInfo.OutgoingPreviousAuthenticationInformation[ Index ].AuthInfo;

                    if ( !LsapValidateLsaCipherValue( &ClearValue ) ) {

                        Status = STATUS_INVALID_PARAMETER;

                    } else if ( SessionKey != NULL ) {

                        Status = LsapCrEncryptValue ( &ClearValue, SessionKey, CipherOld );

                    } else {

                        *CipherOld = MIDL_user_allocate( sizeof( LSAP_CR_CIPHER_VALUE ) +
                                                            ClearValue.Length );

                        if ( *CipherOld == NULL ) {

                            Status = STATUS_INSUFFICIENT_RESOURCES;

                        } else {

                            (*CipherOld)->Length = ClearValue.Length;
                            (*CipherOld)->MaximumLength = ClearValue.Length;
                            (*CipherOld)->Buffer = (PBYTE)(*CipherOld) +
                                                                 sizeof( LSAP_CR_CIPHER_VALUE );
                            RtlCopyMemory( (*CipherOld)->Buffer,
                                           ClearValue.Buffer,
                                           ClearValue.Length );
                        }

                    }

                    if ( !NT_SUCCESS( Status ) && ARGUMENT_PRESENT( CipherCurrent ) ) {

                        LsapCrFreeMemoryValue( CipherCurrent );
                    }
                }

                if ( NT_SUCCESS( Status ) && ARGUMENT_PRESENT( CurrentValueSetTime ) ) {

                    RtlCopyMemory( CurrentValueSetTime,
                                   &AuthInfo.OutgoingAuthenticationInformation[ Index ].
                                                                                   LastUpdateTime,
                                   sizeof( LARGE_INTEGER ) );

                }

                if ( NT_SUCCESS( Status ) &&
                     ARGUMENT_PRESENT( OldValueSetTime )  ) {

                    RtlCopyMemory( OldValueSetTime,
                                   &AuthInfo.OutgoingPreviousAuthenticationInformation[ Index ].
                                                                                   LastUpdateTime,
                                   sizeof( LARGE_INTEGER ) );

                }
            }

            LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &AuthInfo, TRUE ) );
            LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &AuthInfo, FALSE ) );

        }

        if ( Status == STATUS_NOT_FOUND ) {

            if ( ARGUMENT_PRESENT( CipherCurrent ) ) {

                *CipherCurrent = NULL;
            }

            if ( ARGUMENT_PRESENT( CipherOld ) ) {

                *CipherOld = NULL;
            }

            if ( ARGUMENT_PRESENT( CurrentValueSetTime ) ) {

                RtlZeroMemory( CurrentValueSetTime, sizeof( LARGE_INTEGER ) );
            }


            if ( ARGUMENT_PRESENT( OldValueSetTime ) ) {

                RtlZeroMemory( CurrentValueSetTime, sizeof( LARGE_INTEGER ) );
            }

            Status = STATUS_SUCCESS;
        }

        LsapDsFree( DsName );
    }

    //
    // Destruction of the thread state will delete any allocated Ds memory
    //
    LsapDsDeleteAllocAsNeededEx( LSAP_DB_DS_OP_TRANSACTION |
                                     LSAP_DB_READ_ONLY_TRANSACTION,
                                 TrustedDomainObject,
                                 CloseTransaction );

    LsapExitFunc( "LsapDsGetSecretOnTrustedDomainObject", Status );
    return( Status );
}



NTSTATUS
LsapDsEnumerateTrustedDomainsAsSecrets(
    IN OUT PLSAP_DB_NAME_ENUMERATION_BUFFER EnumerationBuffer
    )
/*++

Routine Description:

    This function returns a list of trusted domain objects as if they were secret objects

Arguments:

    EnumerationBuffer - Where the enumerated information is returned


Returns:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSA_ENUMERATION_HANDLE EnumContext = 0;
    LSAPR_TRUSTED_ENUM_BUFFER EnumBuffer;
    PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TDInfoEx;
    LSAPR_HANDLE TDHandle;
    PUNICODE_STRING Names = NULL;
    PBYTE Buffer;
    ULONG i;

    //
    // Just return if the Ds isn't running
    //
    if (!LsapDsWriteDs ) {

        RtlZeroMemory( EnumerationBuffer, sizeof( LSAP_DB_NAME_ENUMERATION_BUFFER ) );
        return( Status );
    }


    Status = LsarEnumerateTrustedDomains( LsapPolicyHandle,
                                          &EnumContext,
                                          &EnumBuffer,
                                          TENMEG );


    if ( NT_SUCCESS( Status ) ) {

        Names = MIDL_user_allocate( EnumBuffer.EntriesRead * sizeof( UNICODE_STRING ) );

        if( Names == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            for ( i = 0; i < EnumBuffer.EntriesRead; i++ ) {

                Status = LsapDbOpenTrustedDomain( LsapPolicyHandle,
                                                  EnumBuffer.Information[ i ].Sid,
                                                  MAXIMUM_ALLOWED,
                                                  &TDHandle,
                                                  LSAP_DB_TRUSTED );

                if ( NT_SUCCESS( Status ) ) {

                    Status = LsarQueryInfoTrustedDomain( TDHandle,
                                                         TrustedDomainInformationEx,
                                                         (PLSAPR_TRUSTED_DOMAIN_INFO *)&TDInfoEx );

                    LsapCloseHandle( &TDHandle, Status );

                    //
                    // Allocate a buffer to hold the name. The sizeof below accounts for our
                    // terminating NULL
                    //
                    if ( NT_SUCCESS( Status ) ) {
                         if ( FLAG_ON( TDInfoEx->TrustDirection, TRUST_DIRECTION_OUTBOUND )  ) {

                            Buffer = MIDL_user_allocate( TDInfoEx->FlatName.Length +
                                                     sizeof( LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX ) );

                            if ( Buffer == NULL ) {

                                Status = STATUS_INSUFFICIENT_RESOURCES;
                                LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO( TrustedDomainInformationEx,
                                                                (PLSAPR_TRUSTED_DOMAIN_INFO)TDInfoEx );

                                break;

                            } else {

                                RtlCopyMemory( Buffer, LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX,
                                               sizeof( LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX ) );
                                RtlCopyMemory( Buffer +
                                                    sizeof( LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX ) -
                                                                                        sizeof(WCHAR),
                                               TDInfoEx->FlatName.Buffer,
                                               TDInfoEx->FlatName.Length + sizeof( WCHAR ) );

                                RtlInitUnicodeString( &Names[ i ], (PWSTR)Buffer );


                            }
                        }

                        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO( TrustedDomainInformationEx,
                                                            (PLSAPR_TRUSTED_DOMAIN_INFO)TDInfoEx );

                    }
                }
            }
        }

        LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER ( &EnumBuffer );
        EnumerationBuffer->Names = Names;
        EnumerationBuffer->EntriesRead = EnumBuffer.EntriesRead;


    } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

        RtlZeroMemory( EnumerationBuffer, sizeof( LSAP_DB_NAME_ENUMERATION_BUFFER ) );
        Status = STATUS_SUCCESS;
    }

    LsapExitFunc( "LsapDsEnumerateTrustedDomainsAsSecrets", Status );
    return( Status );
}




BOOLEAN
LsapDsIsNtStatusResourceError(
    NTSTATUS NtStatus
    )
{

    switch ( NtStatus )
    {
        case STATUS_NO_MEMORY:
        case STATUS_INSUFFICIENT_RESOURCES:
        case STATUS_DISK_FULL:

            return TRUE;

        default:

            return FALSE;
    }
}

NTSTATUS
LsapDeleteUpgradedTrustedDomain(
    IN HANDLE LsaPolicyHandle,
    IN PSID   DomainSid
)
/*++

Routine Description:

    This routine deletes the trusted domain pointed to by DomainSid.

    This routine is only meant to be called during an upgrade from nt4 to nt5

Arguments:

    LsaPolicyHandle - a valid policy handle

    DomainSid -- domain to delete

Return Values:

    STATUS_SUCCESS   -- Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE TDHandle = 0;

    Status = LsapDbOpenTrustedDomain( LsaPolicyHandle,
                                      DomainSid,
                                      MAXIMUM_ALLOWED,
                                      &TDHandle,
                                      LSAP_DB_TRUSTED );
    if ( NT_SUCCESS( Status ) ) {

        Status = LsapRegOpenTransaction();

        if ( NT_SUCCESS( Status ) ) {

            Status = LsapDbDeleteObject( TDHandle );

            if ( NT_SUCCESS( Status ) ) {

                Status = LsapRegApplyTransaction();
            }
        } else {

            // Close handle?
        }
    }

    return Status;

}

NTSTATUS
LsapDsDomainUpgradeRegistryToDs(
    IN BOOLEAN DeleteOnly
    )
/*++

Routine Description:

    This routine will move the remaining registry based trusted domains into the Ds

    NOTE: It is assumed that the database is locked before calling this routine

Arguments:

    DeleteOldValues -- If TRUE, the registry values are deleted following the upgade.

Return Values:

    STATUS_SUCCESS   -- Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSA_ENUMERATION_HANDLE EnumContext = 0;
    LSAPR_TRUSTED_ENUM_BUFFER EnumBuffer;
    PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TDInfoEx = { 0 };
    LSAPR_HANDLE TDHandle;

    ULONG i;

    if (  !LsapDsWriteDs
       && !DeleteOnly ) {

        return( STATUS_SUCCESS );
    }

    LsapEnterFunc( "LsapDsDomainUpgradeRegistryToDs" );


    ( ( LSAP_DB_HANDLE )LsapPolicyHandle )->Options |= LSAP_DB_HANDLE_UPGRADE;

    //
    // First, enumerate all of the registry based trusted domains
    //
    while ( NT_SUCCESS( Status ) ) {

        LsaDsStateInfo.UseDs = FALSE;
        LsapDbMakeCacheInvalid( TrustedDomainObject );
        Status = LsarEnumerateTrustedDomains( LsapPolicyHandle,
                                              &EnumContext,
                                              &EnumBuffer,
                                              TENMEG );

        LsaDsStateInfo.UseDs = TRUE;
        LsapDbMakeCacheValid( TrustedDomainObject );

        if ( Status == STATUS_SUCCESS || Status == STATUS_MORE_ENTRIES ) {

            for ( i = 0; i < EnumBuffer.EntriesRead && NT_SUCCESS( Status ) ; i++ ) {

                //
                // Get the information from the registry for this sid...
                //
                LsaDsStateInfo.UseDs = FALSE;

                if ( DeleteOnly ) {

                    Status = LsapDeleteUpgradedTrustedDomain( LsapPolicyHandle,
                                                              EnumBuffer.Information[ i ].Sid );

                    if ( !NT_SUCCESS( Status ) ) {

                        LsapDsDebugOut(( DEB_UPGRADE,
                                         "Failed to delete trust object (0x%x)\n",
                                         Status ));

                        Status = STATUS_SUCCESS;
                    }

                    continue;

                }

                Status = LsapDbOpenTrustedDomain( LsapPolicyHandle,
                                                  EnumBuffer.Information[ i ].Sid,
                                                  MAXIMUM_ALLOWED,
                                                  &TDHandle,
                                                  LSAP_DB_TRUSTED );

                if ( NT_SUCCESS( Status ) ) {

                    Status = LsarQueryInfoTrustedDomain( TDHandle,
                                                         TrustedDomainInformationEx,
                                                         (PLSAPR_TRUSTED_DOMAIN_INFO *)&TDInfoEx );

                    LsapCloseHandle( &TDHandle, Status);
                }

                LsaDsStateInfo.UseDs = TRUE;

                //
                // Now, if that worked, write it out to the Ds
                //
                if ( NT_SUCCESS( Status ) ) {

                    Status = LsapCreateTrustedDomain2(
                                LsapPolicyHandle,
                                ( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX )TDInfoEx,
                                NULL,
                                MAXIMUM_ALLOWED,
                                &TDHandle );

                    if ( NT_SUCCESS( Status ) ) {

                        LsapCloseHandle( &TDHandle, STATUS_SUCCESS );

                        LsapDsDebugOut(( DEB_UPGRADE,
                                         "Moved trusted domain %wZ to Ds\n",
                                         &TDInfoEx->Name ));
                    }

                    if ( Status == STATUS_OBJECT_NAME_COLLISION ) {

                        Status = STATUS_SUCCESS;
                    }

                    LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO( TrustedDomainInformationEx,
                                                        (PLSAPR_TRUSTED_DOMAIN_INFO)TDInfoEx );
                }


                if (!NT_SUCCESS(Status))
                {
                    if (!LsapDsIsNtStatusResourceError(Status))
                    {
                        SpmpReportEventU(
                            EVENTLOG_ERROR_TYPE,
                            LSA_TRUST_UPGRADE_ERROR,
                            0,
                            sizeof( ULONG ),
                            &Status,
                            1,
                            &EnumBuffer.Information[i].Name
                            );

                        //
                        // Continue on all errors excepting resource errors
                        //

                        Status = STATUS_SUCCESS;
                    }
                    else
                    {
                        //
                        // Break out of the loop and terminate the status
                        //

                        break;
                    }
                }
            }

            LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER ( &EnumBuffer );
        }
    }

    if ( Status == STATUS_NO_MORE_ENTRIES ) {

        Status = STATUS_SUCCESS;
    }

    ( ( LSAP_DB_HANDLE )LsapPolicyHandle )->Options &= ~LSAP_DB_HANDLE_UPGRADE;

    LsapExitFunc( "LsapDsDomainUpgradeRegistryToDs", Status );
    return( Status );
}


NTSTATUS
LsapDsCreateSetITAForTrustInfo(
    IN PUNICODE_STRING AccountName,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthInfo
    )
/*++

Routine Description:

    This function creates/sets a SAM interdomain trust account for an NT5 style trust object,
    given the trust information

Arguments:

    AccountName - Name of the account to create/set

    AuthInfo - AuthInfo for the trust object

Return Values:

    STATUS_SUCCESS   -- Success

    STATUS_UNSUCCESSFUL -- The Sam domain handle has not been opened.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SAM_HANDLE AccountHandle = NULL ;
    ULONG Access, Rid, i;
    USER_ALL_INFORMATION UserAllInfo;
    SAMPR_USER_INTERNAL1_INFORMATION UserInternalInfo1;
    PVOID SamData = NULL;
    ULONG SamInfoLevel = 0;
    BOOLEAN SetPassword = FALSE;
    UNICODE_STRING Account;
    WCHAR AccountNameBuffer[ UNLEN + 2 ];

    LsapEnterFunc( "LsapDsCreateSetITAForTrustInfo" );

    if ( AccountName->Length > UNLEN * sizeof( WCHAR ) ) {

        LsapDsDebugOut(( DEB_ERROR,
                         "LsapDsCreateSetITAForTrustInfo: Name too long: %wZ\n",
                         AccountName ));
        Status = STATUS_OBJECT_NAME_INVALID;
        LsapExitFunc( "LsapDsCreateSetITAForTrustInfo", Status );
    }

    Status = LsapOpenSam();
    if ( !NT_SUCCESS( Status )  ) {

        LsapDsDebugOut(( DEB_ERROR,
                         "LsapDsCreateSetITAForTrustInfo: Sam not opened\n"));

        LsapExitFunc( "LsapDsCreateSetITAForTrustInfo", Status );
        return( Status );
    }

    if ( NT_SUCCESS( Status ) ) {

        //
        // Find the clear password, if it exists
        //
        for ( i = 0; i < AuthInfo->IncomingAuthInfos; i++ ) {

            if ( AuthInfo->IncomingAuthenticationInformation[ i ].AuthType == TRUST_AUTH_TYPE_CLEAR) {

                RtlZeroMemory( &UserAllInfo, sizeof( USER_ALL_INFORMATION ) );
                UserAllInfo.NtPassword.Buffer =
                    (PUSHORT)( AuthInfo-> IncomingAuthenticationInformation[ i ].AuthInfo );
                UserAllInfo.NtPassword.Length =
                    (USHORT)( AuthInfo-> IncomingAuthenticationInformation[ i ].AuthInfoLength );
                UserAllInfo.NtPassword.MaximumLength = UserAllInfo.NtPassword.Length;
                UserAllInfo.NtPasswordPresent = TRUE;
                UserAllInfo.WhichFields = USER_ALL_NTPASSWORDPRESENT | USER_ALL_USERACCOUNTCONTROL;
                UserAllInfo.UserAccountControl = USER_INTERDOMAIN_TRUST_ACCOUNT | USER_PASSWORD_NOT_REQUIRED;
                SetPassword = TRUE;

                SamData = &UserAllInfo;
                SamInfoLevel = UserAllInformation;
                break;
            }
        }

        //
        // Find the OWF password, if we are supposed to use it,
        // and we haven't already used the cleartext one
        //

        if ( SetPassword == FALSE ) {

            for ( i = 0; i < AuthInfo->IncomingAuthInfos; i++ ) {

                if ( AuthInfo->IncomingAuthenticationInformation[ i ].AuthType == TRUST_AUTH_TYPE_NT4OWF ) {

                    RtlZeroMemory( &UserInternalInfo1, sizeof( SAMPR_USER_INTERNAL1_INFORMATION ) );

                    RtlCopyMemory( &UserInternalInfo1.EncryptedNtOwfPassword,
                                   AuthInfo->IncomingAuthenticationInformation[ i ].AuthInfo,
                                   ENCRYPTED_LM_OWF_PASSWORD_LENGTH );
                    UserInternalInfo1.NtPasswordPresent = TRUE;
                    SamData = &UserInternalInfo1;
                    SamInfoLevel = UserInternal1Information;
                    SetPassword = TRUE;
                    break;
                }
            }
        }
    }


    LsapSaveDsThreadState();

    //
    // Create the user
    //
    if ( NT_SUCCESS( Status ) ) {

        RtlZeroMemory( &AccountNameBuffer, sizeof( AccountNameBuffer ) );
        RtlCopyMemory( AccountNameBuffer, AccountName->Buffer, AccountName->Length );
        *( PWSTR )( ( ( PBYTE )AccountNameBuffer ) + AccountName->Length ) = L'$';

        RtlInitUnicodeString( &Account, AccountNameBuffer );

        Status = LsaOpenSamUser( ( PSECURITY_STRING )&Account,
                                 SecNameSamCompatible,
                                 NULL,
                                 FALSE,
                                 0,
                                 &AccountHandle );

        if ( Status == STATUS_NO_SUCH_USER ||
             Status == STATUS_NONE_MAPPED ) {

            Status = SamrCreateUser2InDomain( LsapAccountDomainHandle,
                                              ( PRPC_UNICODE_STRING )&Account,
                                              USER_INTERDOMAIN_TRUST_ACCOUNT,
                                              MAXIMUM_ALLOWED,
                                              &AccountHandle,
                                              &Access,
                                              &Rid );

            if ( !NT_SUCCESS( Status )) {

                LsapDsDebugOut(( DEB_ERROR,
                                 "SamrCreateUser2InDomain on %wZ failed with 0x%lx\n",
                                 &Account,
                                 Status));
            }

        } else if ( !NT_SUCCESS( Status ) ) {

            LsapDsDebugOut(( DEB_ERROR,
                             "LsaOpenSamUser on %wZ failed with 0x%lx\n",
                             &Account,
                             Status));
        }

        //
        // Set the password
        //
        if ( NT_SUCCESS( Status ) ) {

            if ( SetPassword )
            {
                Status = SamrSetInformationUser( AccountHandle,
                                                 SamInfoLevel,
                                                 SamData );
            }

            SamrCloseHandle( &AccountHandle );

        } else {

            //
            // It's ok if the object already exists...
            //
            if ( Status == STATUS_USER_EXISTS ) {

                Status = STATUS_SUCCESS;
            }
        }
    }

    LsapRestoreDsThreadState( );


    LsapExitFunc( "LsapDsCreateSetITAForTrustInfo", Status );
    return( Status );
}


NTSTATUS
LsapDsCreateInterdomainTrustAccount(
    IN LSAPR_HANDLE TrustedDomain
    )
/*++

Routine Description:

    This function creates a SAM interdomain trust account for an NT5 style trust object

Arguments:

    TrustedDomain - Handle to the newly created trusted domain object

Return Values:

    STATUS_SUCCESS   -- Success

    STATUS_UNSUCCESSFUL -- The Sam domain handle has not been opened.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTRUSTED_DOMAIN_FULL_INFORMATION FullInfo = NULL;
    BOOLEAN SavedTrusted;
    LSAP_DB_HANDLE InternalTdoHandle = (LSAP_DB_HANDLE) TrustedDomain;

    LsapEnterFunc( "LsapDsCreateInterdomainTrustAccount" );


    //
    // If this is the case of an NT4 upgrade in progress then bail
    //

    if (LsaDsStateInfo.Nt4UpgradeInProgress)
    {
        return (STATUS_SUCCESS);
    }

    if (LsapProductSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED)
    {
        return STATUS_NOT_SUPPORTED_ON_SBS;
    }


    Status = LsapOpenSam();
    if ( !NT_SUCCESS( Status )  ) {

        LsapDsDebugOut(( DEB_ERROR,
                         "CreateInterdomainTrustAccount: Sam not opened\n"));

        LsapExitFunc( "LsapDsCreateInterdomainTrustAccount", Status );
        return( Status );
    }

    //
    // First, find the domain.  We'll need to get the full info on it
    //

    // Do this operation as trusted since it is an internal operation and the
    //  handle might not grant access to do this operation.
    //

    SavedTrusted =  InternalTdoHandle->Trusted;
    InternalTdoHandle->Trusted = TRUE;

    Status = LsarQueryInfoTrustedDomain( TrustedDomain,
                                         TrustedDomainFullInformation,
                                         (PLSAPR_TRUSTED_DOMAIN_INFO *)&FullInfo );

    InternalTdoHandle->Trusted = SavedTrusted;

    if ( NT_SUCCESS( Status ) ) {

        Status = LsapDsCreateSetITAForTrustInfo( &FullInfo->Information.FlatName,
                                                 &FullInfo->AuthInformation );
    }

    //
    // Free our info
    //
    if ( FullInfo != NULL ) {

        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO( TrustedDomainFullInformation,
                                            ( PLSAPR_TRUSTED_DOMAIN_INFO )FullInfo );
    }

    LsapExitFunc( "LsapDsCreateInterdomainTrustAccount", Status );
    return( Status );
}



NTSTATUS
LsapDsCreateInterdomainTrustAccountByDsName(
    IN PDSNAME TrustedDomainPath,
    IN PUNICODE_STRING FlatName
    )
/*++

Routine Description:

    This function creates a SAM interdomain trust account for an NT5 style trust object

Arguments:

    DomainName -- Name of the newly added domain

    AccountPassword -- Auth data set on the trust account

Return Values:

    STATUS_SUCCESS   -- Success

    STATUS_UNSUCCESSFUL -- The Sam domain handle has not been opened.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    TRUSTED_DOMAIN_AUTH_INFORMATION AuthInfo;

    LsapEnterFunc( "LsapDsCreateInterdomainTrustAccountByDsName" );


    Status = LsapOpenSam();
    if ( !NT_SUCCESS( Status )  ) {

        LsapDsDebugOut(( DEB_ERROR,
                         "CreateInterdomainTrustAccount: Sam not opened\n"));

        LsapExitFunc( "LsapDsCreateInterdomainTrustAccountByDsName", Status );
        return( Status );
    }


    //
    // Get the auth data
    //
    RtlZeroMemory( &AuthInfo, sizeof( AuthInfo ) );
    Status = LsapDsGetTrustedDomainInfoEx( TrustedDomainPath,
                                           0,
                                           TrustedDomainAuthInformation,
                                           ( PLSAPR_TRUSTED_DOMAIN_INFO )&AuthInfo,
                                           NULL );


    if ( NT_SUCCESS( Status ) ) {

        Status = LsapDsCreateSetITAForTrustInfo( FlatName,
                                                 ( PTRUSTED_DOMAIN_AUTH_INFORMATION )&AuthInfo );
    }



    //
    // Free our info
    //
    LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &AuthInfo, TRUE ) );
    LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &AuthInfo, FALSE ) );

    LsapExitFunc( "LsapDsCreateInterdomainTrustAccountByDsName", Status );
    return( Status );
}



NTSTATUS
LsapDsDeleteInterdomainTrustAccount(
    IN LSAPR_HANDLE TrustedDomainObject
    )
/*++

Routine Description:

    This function deletes a SAM interdomain trust account for an NT5 style trust object

Arguments:

    TrustedDomainObject -- Handle to the trusted domain object

    AccountPassword -- Auth data set on the trust account

Return Values:

    STATUS_SUCCESS   -- Success

    STATUS_UNSUCCESSFUL -- The Sam domain handle has not been opened.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SAM_HANDLE AccountHandle;
    LSAP_DB_HANDLE InternalTdoHandle = (LSAP_DB_HANDLE) TrustedDomainObject;
    PTRUSTED_DOMAIN_INFORMATION_EX ExInfo = NULL;
    UNICODE_STRING Account;
    WCHAR AccountName[ UNLEN + 2 ], *Accnt = AccountName;
    BOOLEAN SavedTrusted;


    LsapEnterFunc( "LsapDsDeleteInterdomainTrustAccount" );

    Status = LsapOpenSam();
    if ( !NT_SUCCESS( Status )  ) {

        LsapDsDebugOut(( DEB_ERROR,
                         "LsapDsDeleteInterdomainTrustAccount: Sam not opened\n"));

        LsapExitFunc( "LsapDsDeleteInterdomainTrustAccount", Status );
        return( Status );
    }

    //
    // First, find the domain.  We'll need to get the full info on it
    //
    // Do this operation as trusted since it is an internal operation and the
    //  handle might not grant access to do this operation.
    //

    SavedTrusted =  InternalTdoHandle->Trusted;
    InternalTdoHandle->Trusted = TRUE;
    Status = LsarQueryInfoTrustedDomain( TrustedDomainObject,
                                         TrustedDomainInformationEx,
                                         (PLSAPR_TRUSTED_DOMAIN_INFO *)&ExInfo );
    InternalTdoHandle->Trusted = SavedTrusted;


    //
    // Delete the user
    //
    // First, create the name to look for
    //
    if ( NT_SUCCESS( Status ) ) {

        RtlZeroMemory( &AccountName, sizeof( AccountName ) );

        if ( ExInfo->FlatName.MaximumLength >= sizeof( AccountName ) - sizeof( WCHAR ) ) {

            Accnt = LsapAllocateLsaHeap( ExInfo->FlatName.MaximumLength +
                                                            sizeof( WCHAR ) + sizeof( WCHAR ) );

            if ( Accnt == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if ( NT_SUCCESS( Status ) ) {

            RtlCopyMemory( Accnt, ExInfo->FlatName.Buffer, ExInfo->FlatName.MaximumLength );
            *( PWSTR )( ( ( PBYTE) Accnt ) + ExInfo->FlatName.Length ) = L'$';

            RtlInitUnicodeString( &Account, Accnt );

            //
            // We can't call into sam with an active thread state
            //
            LsapSaveDsThreadState();

            //
            // Open the user.  If the user doesn't exist, it's not an error
            //
            Status = LsaOpenSamUser( ( PSECURITY_STRING )&Account,
                                     SecNameSamCompatible,
                                     NULL,
                                     FALSE,
                                     0,
                                     &AccountHandle );
            if ( NT_SUCCESS( Status ) ) {

                //
                // Now, delete it
                //
                Status = SamrDeleteUser( &AccountHandle );

                if ( !NT_SUCCESS( Status ) ) {

                    LsapDsDebugOut(( DEB_ERROR,
                                     "Failed to delete user %wZ: 0x%lx\n",
                                     &Account,
                                     Status ));

                    SpmpReportEventU(
                        EVENTLOG_WARNING_TYPE,
                        LSAEVENT_ITA_NOT_DELETED,
                        0,
                        sizeof( ULONG ),
                        &Status,
                        1,
                        &ExInfo->Name
                        );

                    SamrCloseHandle( &AccountHandle );
                }

            } else if ( Status == STATUS_NONE_MAPPED ) {

                Status = STATUS_SUCCESS;
            }

            if ( Accnt != AccountName ) {

                LsapFreeLsaHeap( Accnt );
            }

            LsapRestoreDsThreadState();

        }
    }

    //
    // Free our info
    //
    if ( ExInfo != NULL ) {

        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO( TrustedDomainInformationEx,
                                            ( PLSAPR_TRUSTED_DOMAIN_INFO )ExInfo );
    }

    LsapExitFunc( "LsapDsDeleteInterdomainTrustAccount", Status );

    return( Status );
}



NTSTATUS
LsapDsDomainUpgradeInterdomainTrustAccountsToDs(
    VOID
    )
/*++

Routine Description:

    This routine will create the appropriate part of the trust object if an interdomain
    trust account by that name is found


    NOTE: It is assumed that the database is locked before calling this routine

Arguments:

    VOID

Return Values:

    STATUS_SUCCESS   -- Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SAM_ENUMERATE_HANDLE  SamEnum = 0;
    SAMPR_HANDLE UserHandle;
    PSAMPR_ENUMERATION_BUFFER RidEnum = NULL;
    PSAMPR_USER_INTERNAL1_INFORMATION UserInfo1 = NULL;
    PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION FullInfo = NULL;
    LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION NewFullInfo;
    LSAPR_AUTH_INFORMATION NewIncomingAuthInfo;
    LSAPR_HANDLE TrustedDomain = NULL;
    NT_OWF_PASSWORD EmptyPassword;
    UNICODE_STRING EmptyString;
    ULONG SamCount = 0;
    PVOID CurrentState;
    ULONG i;

    if ( !LsapDsWriteDs ) {

        return( STATUS_SUCCESS );
    }

    LsapEnterFunc( "LsapDsDomainUpgradeInterdomainTrustAccountsToDs" );


    ( ( LSAP_DB_HANDLE )LsapPolicyHandle )->Options |= LSAP_DB_HANDLE_UPGRADE;

    LsapSaveDsThreadState();

    Status = LsapOpenSam();
    if ( !NT_SUCCESS( Status )  ) {

            LsapDsDebugOut(( DEB_ERROR,
                             "LsapDsDomainUpgradeInterdomainTrustAccountsToDs: Sam not opened\n"));

    } else {

        Status = SamIEnumerateInterdomainTrustAccountsForUpgrade(
                                             &SamEnum,
                                             &RidEnum,
                                             0xFFFFFFFF,
                                             &SamCount );

        if ( !NT_SUCCESS( Status ) ) {

            LsapDsDebugOut(( DEB_FIXUP,
                             "SamEnumerateUsersInDomain failed with 0x%lx\n",
                             Status ));
        } else {

            LsapDsDebugOut(( DEB_FIXUP,
                             "SamEnumerateUsersInDomain returned %lu accounts\n",
                             SamCount ));

        }

    }

    LsapRestoreDsThreadState();

    //
    // Now, we'll process them all.  If the domain already exists, we'll simply set it's
    // information appropriately.  Otherwise, we'll create it.
    //
    for ( i = 0; NT_SUCCESS( Status ) && i < RidEnum->EntriesRead; i++ ) {

        UCHAR NtOwfPassword[NT_OWF_PASSWORD_LENGTH];
        UCHAR LmOwfPassword[LM_OWF_PASSWORD_LENGTH];
        BOOLEAN NtPasswordPresent = FALSE;
        BOOLEAN LmPasswordPresent = FALSE;

        //
        // Burn the trailing '$' from the account name
        //
        RidEnum->Buffer[ i ].Name.Length -= sizeof( WCHAR );

        //
        // Save Thread state before calling into SAM
        //

        LsapSaveDsThreadState();

        //
        // Next, we'll need to read the current nt4 owf from the account
        //
        Status = SamIGetInterdomainTrustAccountPasswordsForUpgrade(
                               RidEnum->Buffer[ i ].RelativeId, // RID of the account
                               NtOwfPassword,
                               &NtPasswordPresent,
                               LmOwfPassword,
                               &LmPasswordPresent
                               );

        //
        // Restore the thread state after the SAM call
        //

        LsapRestoreDsThreadState();



        //
        // Now, we've got the user info. We'll get the domain information, and
        // set it on the trust object (or alternately create it if it doesn't exist)
        //
        if ( NT_SUCCESS( Status ) ) {

            //
            // Build the new AUTHINFO
            //
            GetSystemTimeAsFileTime( (LPFILETIME) &NewIncomingAuthInfo.LastUpdateTime );
            NewIncomingAuthInfo.AuthType = TRUST_AUTH_TYPE_NT4OWF;
            NewIncomingAuthInfo.AuthInfoLength = NT_OWF_PASSWORD_LENGTH;
            if ( NtPasswordPresent ) {

                NewIncomingAuthInfo.AuthInfo = NtOwfPassword;

            } else {

                RtlInitUnicodeString( &EmptyString, L"" );

                Status = RtlCalculateNtOwfPassword( ( PNT_PASSWORD )&EmptyString,
                                                    &EmptyPassword );

                if ( NT_SUCCESS( Status ) ) {

                    NewIncomingAuthInfo.AuthInfo = ( PUCHAR )&EmptyPassword;

                }
            }

            Status = LsapDbOpenTrustedDomainByName(
                         NULL, // use global policy handle
                         ( PUNICODE_STRING )&RidEnum->Buffer[ i ].Name,
                         &TrustedDomain,
                         MAXIMUM_ALLOWED,
                         LSAP_DB_START_TRANSACTION,
                         TRUE );    // Trusted


            if ( NT_SUCCESS( Status ) ) {

                Status = LsarQueryInfoTrustedDomain( TrustedDomain,
                                                     TrustedDomainFullInformation,
                                                     (PLSAPR_TRUSTED_DOMAIN_INFO *) &FullInfo );

                if ( NT_SUCCESS( Status ) ) {

                    //
                    // Add our new information in
                    //
                    if ( !FLAG_ON( FullInfo->Information.TrustDirection, TRUST_DIRECTION_INBOUND ) ) {

                        FullInfo->Information.TrustDirection |= TRUST_DIRECTION_INBOUND;


                        FullInfo->AuthInformation.IncomingAuthInfos = 1;
                        FullInfo->AuthInformation.IncomingAuthenticationInformation =
                                                                              &NewIncomingAuthInfo;
                        FullInfo->AuthInformation.IncomingPreviousAuthenticationInformation = NULL;

                        Status = LsarSetInformationTrustedDomain(
                                     TrustedDomain,
                                     TrustedDomainFullInformation,
                                     ( PLSAPR_TRUSTED_DOMAIN_INFO ) FullInfo );

                        //
                        // NULL out the IncomingAuthenticationInformation variable, as that
                        // is a stack buffer and we do not want to free it.
                        //

                        FullInfo->AuthInformation.IncomingAuthInfos = 0;
                        FullInfo->AuthInformation.IncomingAuthenticationInformation = NULL;

                        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO(
                            TrustedDomainFullInformation,
                            (PLSAPR_TRUSTED_DOMAIN_INFO) FullInfo );
                    }

                }

            } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

                //
                // We'll have to create it...
                //
                RtlZeroMemory( &NewFullInfo, sizeof( NewFullInfo ) );

                RtlCopyMemory( &NewFullInfo.Information.Name,
                               &RidEnum->Buffer[ i ].Name,
                               sizeof( LSAPR_UNICODE_STRING ) );

                RtlCopyMemory( &NewFullInfo.Information.FlatName,
                               &RidEnum->Buffer[ i ].Name,
                               sizeof( LSAPR_UNICODE_STRING ) );

                NewFullInfo.Information.TrustDirection = TRUST_DIRECTION_INBOUND;
                NewFullInfo.Information.TrustType = TRUST_TYPE_DOWNLEVEL;


                NewFullInfo.AuthInformation.IncomingAuthInfos = 1;
                NewFullInfo.AuthInformation.IncomingAuthenticationInformation =
                                                                        &NewIncomingAuthInfo;
                NewFullInfo.AuthInformation.IncomingPreviousAuthenticationInformation = NULL;

                Status = LsapCreateTrustedDomain2( LsapPolicyHandle,
                                                   &NewFullInfo.Information,
                                                   &NewFullInfo.AuthInformation,
                                                   MAXIMUM_ALLOWED,
                                                   &TrustedDomain );
            }

        }

        if ( TrustedDomain != NULL ) {

            LsapCloseHandle( &TrustedDomain, Status );
        }

        if ( UserInfo1 ) {

            SamIFree_SAMPR_USER_INFO_BUFFER( ( PSAMPR_USER_INFO_BUFFER )UserInfo1,
                                             UserInternal1Information );

            UserInfo1 = NULL;
        }


        if (!NT_SUCCESS(Status))
        {
            if (!LsapDsIsNtStatusResourceError(Status))
            {
                //
                // Log an event log message indicating the failure
                //

                SpmpReportEventU(
                    EVENTLOG_ERROR_TYPE,
                    LSA_ITA_UPGRADE_ERROR,
                    0,
                    sizeof( ULONG ),
                    &Status,
                    1,
                    &RidEnum->Buffer[i].Name
                    );

                //
                // Continue on all errors excepting resource errors
                //

                Status = STATUS_SUCCESS;
            }
            else
            {
                //
                // Break out of the loop and terminate the upgrade
                //

                break;
            }
        }

    }

    //
    // We're done with the sam enumeration
    //
    if ( RidEnum ) {

        SamFreeMemory( RidEnum );

    }


    ( ( LSAP_DB_HANDLE )LsapPolicyHandle )->Options &= ~LSAP_DB_HANDLE_UPGRADE;

    LsapExitFunc( "LsapDsDomainUpgradeInterdomainTrustAccountsToDs", Status );
    return( Status );
}



VOID
LsapDsFreeUnmarshalAuthInfoHalf(
    IN PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF AuthInfo
    )
/*++

Routine Description:

    This routine will free the memory allocated by LsapDsUnMarshalAuthInfoForReturn

Arguments:

    VOID

Return Values:

    VOID

--*/
{
    if ( !AuthInfo ) {

        return;
    }

    LsapDsFreeUnmarshaledAuthInfo( AuthInfo->AuthInfos,
                                   AuthInfo->AuthenticationInformation );
    LsapDsFreeUnmarshaledAuthInfo( AuthInfo->AuthInfos,
                                   AuthInfo->PreviousAuthenticationInformation );

    MIDL_user_free( AuthInfo->AuthenticationInformation );
    AuthInfo->AuthenticationInformation = NULL;

    MIDL_user_free( AuthInfo->PreviousAuthenticationInformation );
    AuthInfo->PreviousAuthenticationInformation = NULL;

    return;
}


NTSTATUS
LsapDecryptAuthDataWithSessionKey(
    IN PLSAP_CR_CIPHER_KEY SessionKey,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL AuthInformationInternal,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthInfo
    )
/*++

Routine Description:

    This routine decrypts the auth info as passed to us on an RPC call.

Arguments:

    SessionKey - Session key to decrypt with.

    AuthInformationInternal -  Pointer to the encrypted auth info.

    AuthInfo - Buffer to return the authentication information into.
        Free the buffer using:
        LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( AuthInfo, TRUE ) );
        LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( AuthInfo, FALSE ) );


Return Value:

--*/
{
    NTSTATUS Status;

    struct RC4_KEYSTRUCT Rc4Key;
    ULONG OverheadSize = LSAP_ENCRYPTED_AUTH_DATA_FILL + sizeof(ULONG) + sizeof(ULONG);
    ULONG MessageSize;
    PUCHAR Where;

    ULONG IncomingAuthInfoSize = 0;
    PUCHAR IncomingAuthInfo = NULL;
    ULONG OutgoingAuthInfoSize = 0;
    PUCHAR OutgoingAuthInfo = NULL;

    //
    // Initialization.
    //

    RtlZeroMemory( AuthInfo, sizeof(*AuthInfo) );

    if ( SessionKey == NULL ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Ensure the auth data is big enough.
    //
    // Here's the format of the decrypted buffer:
    //  512 random bytes
    //  The Outgoing auth info buffer.
    //  The Incoming auth info buffer.
    //  The length of the outgoing auth info buffer.
    //  The length of the incoming auth info buffer.
    //

    MessageSize = AuthInformationInternal->AuthBlob.AuthSize;
    if ( MessageSize < OverheadSize ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    MessageSize -= OverheadSize;

    //
    // Decrypt the auth info
    //

    rc4_key(
        &Rc4Key,
        SessionKey->Length,
        SessionKey->Buffer );

    rc4( &Rc4Key,
         AuthInformationInternal->AuthBlob.AuthSize,
         AuthInformationInternal->AuthBlob.AuthBlob );

    //
    // Sanity check the decrypted data.
    //

    Where = AuthInformationInternal->AuthBlob.AuthBlob +
            AuthInformationInternal->AuthBlob.AuthSize -
            sizeof(ULONG);
    RtlCopyMemory( &IncomingAuthInfoSize, Where, sizeof(ULONG));
    Where -= sizeof(ULONG);

    if ( IncomingAuthInfoSize > MessageSize ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    MessageSize -= IncomingAuthInfoSize;

    RtlCopyMemory( &OutgoingAuthInfoSize, Where, sizeof(ULONG));

    if ( OutgoingAuthInfoSize != MessageSize ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Where -= IncomingAuthInfoSize;
    IncomingAuthInfo = Where;

    Where -= OutgoingAuthInfoSize;
    OutgoingAuthInfo = Where;

    //
    // Unmarshal the auth info.
    //

    Status = LsapDsUnmarshalAuthInfoHalf(
                 NULL,
                 FALSE,
                 TRUE,
                 IncomingAuthInfo,
                 IncomingAuthInfoSize,
                 LsapDsAuthHalfFromAuthInfo( AuthInfo, TRUE ) );

    if ( !NT_SUCCESS(Status)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status = LsapDsUnmarshalAuthInfoHalf(
                 NULL,
                 FALSE,
                 TRUE,
                 OutgoingAuthInfo,
                 OutgoingAuthInfoSize,
                 LsapDsAuthHalfFromAuthInfo( AuthInfo, FALSE ) );

    if ( !NT_SUCCESS(Status)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


Cleanup:
    if ( !NT_SUCCESS(Status)) {
        LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( AuthInfo, TRUE ) );
        LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( AuthInfo, FALSE ) );
    }
    return Status;

}



UUID LsapNullUuidValue = {0,0,0,{0,0,0,0,0,0,0,0}};

// Return TRUE if the ptr to the UUID is NULL, or the uuid is all zeroes

BOOLEAN LsapNullUuid (const UUID *pUuid)
{
    if (!pUuid) {
        return TRUE;
    }

    if (memcmp (pUuid, &LsapNullUuidValue, sizeof (UUID))) {
        return FALSE;
    }
    return TRUE;
}

NTSTATUS
LsapDsTrustedDomainObjectNameForDomain(
    IN PUNICODE_STRING TrustedDomainName,
    IN BOOLEAN NameAsFlatName,
    OUT PDSNAME *DsObjectName
    )
/*++

Routine Description:

    This routine will find the DS object name associated with the given domain name.  The
    domain name can be either the flat name or the dns name, depending on the given flags

Arguments:

    TrustedDomainName - Name of the domain to find the object name for

    NameAsFlatName - If TRUE, assume that the input name is the flat name.  Otherwise, it's
                     the Dns domain name

    DsObjectName - Where the path to the object is returned.  Freed via LsapFreeLsaHeap

Return Values:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRVAL AttrVal;
    LSAPR_TRUST_INFORMATION InputTrustInformation;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;

    LsapEnterFunc( "LsapDsTrustedDomainObjectNameForDomain" );
    //
    // Lookup the object in the trusted domain cache. Currently this is
    // for duplicate detection and reconciliation. Later we can extend
    // the cache to always keep the guid of the object in the DS. This way
    // this will be a useful performance optimization
    //

    //
    // Acquire the Read Lock for the Trusted Domain List
    //

    Status = LsapDbAcquireReadLockTrustedDomainList();

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    RtlCopyMemory(&InputTrustInformation.Name,TrustedDomainName,sizeof(UNICODE_STRING));
    InputTrustInformation.Sid = NULL;

    Status = LsapDbLookupEntryTrustedDomainList(
                 &InputTrustInformation,
                 &TrustEntry
                 );

    if ((STATUS_SUCCESS==Status) && (!LsapNullUuid(&TrustEntry->ObjectGuidInDs)))
    {
        GUID ObjectGuid;

        //
        // Duplicate detection filled in a GUID. use that
        //


        RtlCopyMemory(&ObjectGuid, &TrustEntry->ObjectGuidInDs,sizeof(GUID));
        AttrVal.valLen = sizeof(GUID);
        AttrVal.pVal = ( PUCHAR )&ObjectGuid;

        LsapDbReleaseLockTrustedDomainList();

        Status = LsapDsFindUnique( 0,
                               NULL,    // Default naming context
                               TrustedDomainObject,
                               &AttrVal,
                               ATT_OBJECT_GUID,
                               DsObjectName );



    }
    else
    {

        LsapDbReleaseLockTrustedDomainList();


        AttrVal.valLen = TrustedDomainName->Length;
        AttrVal.pVal = ( PUCHAR )TrustedDomainName->Buffer;
        Status = LsapDsFindUnique( 0,
                                   NULL,    // Default naming context
                                   TrustedDomainObject,
                                   &AttrVal,
                                   NameAsFlatName ?
                                        LsapDsAttributeIds[ LsapDsAttrTrustPartnerFlat ] :
                                        LsapDsAttributeIds[ LsapDsAttrTrustPartner ],
                                   DsObjectName );
    }




Cleanup:
    LsapExitFunc( "LsapDsTrustedDomainObjectNameForDomain", Status );
    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\lsawrap.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsawrap.c

Abstract:

    LSA - Database - wrapper APIs for secret, trusted domain, and account
        objects.

    NOTE:  This module should remain as portable code that is independent
           of the implementation of the LSA Database.  As such, it is
           permitted to use only the exported LSA Database interfaces
           contained in db.h and NOT the private implementation
           dependent functions in dbp.h.

Author:

    Mike Swift      (MikeSw)      December 12, 1994

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"
#include <lmcons.h>     // required by logonmsv.h
#include <logonmsv.h>   // SSI_SECRET_PREFIX...


//
// This structure holds the user right to system access mapping
//

typedef struct _LSAP_DB_RIGHT_AND_ACCESS {
    UNICODE_STRING UserRight;
    ULONG SystemAccess;
} LSAP_DB_RIGHT_AND_ACCESS, *PLSAP_DB_RIGHT_AND_ACCESS;

#define LSAP_DB_SYSTEM_ACCESS_TYPES 10

LSAP_DB_RIGHT_AND_ACCESS LsapDbRightAndAccess[LSAP_DB_SYSTEM_ACCESS_TYPES];

PSECURITY_DESCRIPTOR UserRightSD;

UNICODE_STRING UserRightTypeName;

GENERIC_MAPPING UserRightGenericMapping;



NTSTATUS
LsapDbInitializeRights(
    )
{
/*++

Routine Description:

    Initializes global data for the new APIs handling user rights

Arguments:

    None

Return Value:
    STATUS_INSUFFICIENT_MEMORY - not enough memory to initialize the
        data structures.

--*/

    SECURITY_DESCRIPTOR AbsoluteDescriptor;
    ULONG DaclLength;
    NTSTATUS Status;
    PACL Dacl = NULL;
    HANDLE LsaProcessTokenHandle = NULL;

    //
    // Interactive logons
    //

    RtlInitUnicodeString(
        &LsapDbRightAndAccess[0].UserRight,
        SE_INTERACTIVE_LOGON_NAME
        );
    LsapDbRightAndAccess[0].SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON;

    //
    // network logons
    //

    RtlInitUnicodeString(
        &LsapDbRightAndAccess[1].UserRight,
        SE_NETWORK_LOGON_NAME
        );
    LsapDbRightAndAccess[1].SystemAccess = SECURITY_ACCESS_NETWORK_LOGON;

    //
    // SERVICE logons
    //

    RtlInitUnicodeString(
        &LsapDbRightAndAccess[2].UserRight,
        SE_SERVICE_LOGON_NAME
        );
    LsapDbRightAndAccess[2].SystemAccess = SECURITY_ACCESS_SERVICE_LOGON;

    //
    // BATCH logons
    //

    RtlInitUnicodeString(
        &LsapDbRightAndAccess[3].UserRight,
        SE_BATCH_LOGON_NAME
        );
    LsapDbRightAndAccess[3].SystemAccess = SECURITY_ACCESS_BATCH_LOGON;

    //
    // Deny Interactive logons
    //

    RtlInitUnicodeString(
        &LsapDbRightAndAccess[4].UserRight,
        SE_DENY_INTERACTIVE_LOGON_NAME
        );
    LsapDbRightAndAccess[4].SystemAccess = SECURITY_ACCESS_DENY_INTERACTIVE_LOGON;

    //
    // Deny network logons
    //

    RtlInitUnicodeString(
        &LsapDbRightAndAccess[5].UserRight,
        SE_DENY_NETWORK_LOGON_NAME
        );
    LsapDbRightAndAccess[5].SystemAccess = SECURITY_ACCESS_DENY_NETWORK_LOGON;

    //
    // Deny service logons
    //

    RtlInitUnicodeString(
        &LsapDbRightAndAccess[6].UserRight,
        SE_DENY_SERVICE_LOGON_NAME
        );
    LsapDbRightAndAccess[6].SystemAccess = SECURITY_ACCESS_DENY_SERVICE_LOGON;

    //
    // Deny batch logons
    //

    RtlInitUnicodeString(
        &LsapDbRightAndAccess[7].UserRight,
        SE_DENY_BATCH_LOGON_NAME
        );
    LsapDbRightAndAccess[7].SystemAccess = SECURITY_ACCESS_DENY_BATCH_LOGON;

    //
    // Remote Interactive logons
    //

    RtlInitUnicodeString(
        &LsapDbRightAndAccess[8].UserRight,
        SE_REMOTE_INTERACTIVE_LOGON_NAME
        );
    LsapDbRightAndAccess[8].SystemAccess = SECURITY_ACCESS_REMOTE_INTERACTIVE_LOGON ;

    //
    // Deny remote Interactive logons
    //

    RtlInitUnicodeString(
        &LsapDbRightAndAccess[9].UserRight,
        SE_DENY_REMOTE_INTERACTIVE_LOGON_NAME
        );
    LsapDbRightAndAccess[9].SystemAccess = SECURITY_ACCESS_DENY_REMOTE_INTERACTIVE_LOGON ;


    //
    // Create the security descriptor for the rights pseudo-object
    //

    //
    // The ACL looks like this:
    //
    //  Admins - PRIVILEGE_VIEW | PRIVILEGE_ADJUST
    //

    Status = RtlCreateSecurityDescriptor(
                &AbsoluteDescriptor,
                SECURITY_DESCRIPTOR_REVISION
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    DaclLength = sizeof(ACL) -
                 sizeof(ULONG) +                // for dummy in structure
                 sizeof(ACCESS_ALLOWED_ACE) +
                 RtlLengthSid(LsapAliasAdminsSid);

    Dacl = (PACL)  LsapAllocateLsaHeap(DaclLength);
    if (Dacl == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = RtlCreateAcl(
                Dacl,
                DaclLength,
                ACL_REVISION
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Now add the access allowed ace for Admins.  They are granted
    // PRIVILEGE_VIEW and PRIVILEGE_ADJUST access. For now,
    // PRIVILEGE_ADJUST is unused (since you can't add accounts to a
    // privilege).
    //
    // ********* NOTE *************
    //
    // If real privilege objects are ever implemented, this should be moved
    // to dbinit.c where the other LSA objects are created, and added to
    // the table of real LSA objects.
    //

    Status = RtlAddAccessAllowedAce(
                Dacl,
                ACL_REVISION,
                PRIVILEGE_VIEW | PRIVILEGE_ADJUST,
                LsapAliasAdminsSid
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = RtlSetOwnerSecurityDescriptor(
                &AbsoluteDescriptor,
                LsapAliasAdminsSid,
                FALSE               // owner not defaulted
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = RtlSetDaclSecurityDescriptor(
                &AbsoluteDescriptor,
                TRUE,               // DACL present
                Dacl,
                FALSE               // DACL defaulted
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    UserRightGenericMapping.GenericRead = PRIVILEGE_VIEW | STANDARD_RIGHTS_READ;
    UserRightGenericMapping.GenericWrite = PRIVILEGE_ADJUST | STANDARD_RIGHTS_WRITE;
    UserRightGenericMapping.GenericExecute = STANDARD_RIGHTS_EXECUTE;
    UserRightGenericMapping.GenericAll = PRIVILEGE_ALL;

    //
    // Now open the Lsa process's token with appropriate access (token is
    // needed to create the security object).
    //

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_QUERY,
                 &LsaProcessTokenHandle
                 );

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    Status = RtlNewSecurityObject(
                NULL,
                &AbsoluteDescriptor,
                &UserRightSD,
                FALSE,                  // not directory object
                LsaProcessTokenHandle,
                &UserRightGenericMapping
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &UserRightTypeName,
        L"UserRightObject"
        );

Cleanup:
    if (Dacl != NULL) {
        LsapFreeLsaHeap(Dacl);
    }
    if (LsaProcessTokenHandle != NULL) {
        NtClose(LsaProcessTokenHandle);
    }

    return(Status);

}




NTSTATUS
LsapDbFindNextSidWithRight(
    IN LSAPR_HANDLE ContainerHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    IN OPTIONAL PLUID Privilege,
    IN OPTIONAL PULONG SystemAccess,
    OUT PLSAPR_SID *NextSid
    )

/*++

Routine Description:

    This function finds the next Sid of object of a given type within a
    container object.  The given object type must be one where objects
    have Sids.  The Sids returned can be used on subsequent open calls to
    access the objects. The Account

Arguments:

    ContainerHandle - Handle to container object.

    EnumerationContext - Pointer to a variable containing the index of
        the object to be found.  A zero value indicates that the first
        object is to be found.

    Privilege - If present, determines what privilge the account must have.

    SystemAccess - If present, determines what kind of system access the
        account must have.

    NextSid - Receives a pointer to the next Sid found.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - Invalid ContainerHandle specified

        STATUS_NO_MORE_ENTRIES - Warning that no more entries exist.
--*/

{
    NTSTATUS Status, SecondaryStatus;
    ULONG SidKeyValueLength = 0;
    ULONG RightKeyValueLength = 0;
    UNICODE_STRING SubKeyNameU;
    UNICODE_STRING SidKeyNameU;
    UNICODE_STRING RightKeyNameU;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ContDirKeyHandle = NULL;
    HANDLE SidKeyHandle = NULL;
    HANDLE RightKeyHandle = NULL;
    PSID ObjectSid = NULL;
    PPRIVILEGE_SET ObjectPrivileges = NULL;
    PULONG ObjectAccess = NULL;
    PBYTE ObjectRights = NULL;
    ULONG Index;
    BOOLEAN ValidSid = FALSE;

    //
    // Zero pointers for cleanup routine
    //
    SubKeyNameU.Buffer = NULL;
    SidKeyNameU.Buffer = NULL;
    RightKeyNameU.Buffer = NULL;

    //
    // Setup object attributes for opening the appropriate Containing
    // Directory.  Since we're looking for Account objects,
    // the containing Directory is "Accounts".  The Unicode strings for
    // containing Directories are set up during Lsa Initialization.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &LsapDbContDirs[AccountObject],
        OBJ_CASE_INSENSITIVE,
        ((LSAP_DB_HANDLE) ContainerHandle)->KeyHandle,
        NULL
        );

    Status = RtlpNtOpenKey(
                 &ContDirKeyHandle,
                 KEY_READ,
                 &ObjectAttributes,
                 0
                 );

    if (!NT_SUCCESS(Status)) {

        ContDirKeyHandle = NULL;  // For error processing
        goto FindNextError;
    }

    //
    // Initialize the Unicode String in which the next object's Logical Name
    // will be returned.  The Logical Name of an object equals its Registry
    // Key relative to its Containing Directory, and is also equal to
    // the Relative Id of the object represented in character form as an
    // 8-digit number with leading zeros.
    //
    // NOTE: The size of buffer allocated for the Logical Name must be
    // calculated dynamically when the Registry supports long names, because
    // it is possible that the Logical Name of an object will be equal to a
    // character representation of the full Sid, not just the Relative Id
    // part.
    //

    SubKeyNameU.MaximumLength = (USHORT) LSAP_DB_LOGICAL_NAME_MAX_LENGTH;
    SubKeyNameU.Length = 0;
    SubKeyNameU.Buffer = LsapAllocateLsaHeap(SubKeyNameU.MaximumLength);

    if (SubKeyNameU.Buffer == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FindNextError;
    }

    //
    // Now enumerate the next subkey.
    //

    Status = RtlpNtEnumerateSubKey(
                 ContDirKeyHandle,
                 &SubKeyNameU,
                 *EnumerationContext,
                 NULL
                 );

    if (!NT_SUCCESS(Status)) {

        goto FindNextError;
    }

    //
    // If a right was passed in, check for that right
    //

    if ((Privilege != NULL) || (SystemAccess != NULL)){

        ASSERT(((Privilege == NULL) && (SystemAccess != NULL)) ||
               ((SystemAccess == NULL) && (Privilege != NULL)));

        //
        // Construct a path to the Privilgs attribute of the object relative to
        // the containing directory.  This path has the form
        //
        // <Object Logical Name>"\Privilgs"
        //
        // The Logical Name of the object has just been returned by the
        // above call to RtlpNtEnumerateSubKey.
        //

        if (Privilege != NULL) {
            Status = LsapDbJoinSubPaths(
                        &SubKeyNameU,
                        &LsapDbNames[Privilgs],
                        &RightKeyNameU
                        );
        } else {
            Status = LsapDbJoinSubPaths(
                        &SubKeyNameU,
                        &LsapDbNames[ActSysAc],
                        &RightKeyNameU
                        );

        }

        if (!NT_SUCCESS(Status)) {

            goto FindNextError;
        }

        //
        // Setup object attributes for opening the privilege or access attribute
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &RightKeyNameU,
            OBJ_CASE_INSENSITIVE,
            ContDirKeyHandle,
            NULL
            );

        //
        // Open the Sid attribute
        //

        Status = RtlpNtOpenKey(
                     &RightKeyHandle,
                     KEY_READ,
                     &ObjectAttributes,
                     0
                     );

        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
                Status = STATUS_NOT_ALL_ASSIGNED;
                (*EnumerationContext)++;
            }

            SidKeyHandle = NULL;
            goto FindNextError;
        }

        //
        // Now query the size of the buffer required to read the Sid
        // attribute's value.
        //

        RightKeyValueLength = 0;

        Status = RtlpNtQueryValueKey(
                     RightKeyHandle,
                     NULL,
                     NULL,
                     &RightKeyValueLength,
                     NULL
                     );

        //
        // We expect buffer overflow to be returned from a query buffer size
        // call.
        //

        if (Status == STATUS_BUFFER_OVERFLOW) {

            Status = STATUS_SUCCESS;

        } else {

            goto FindNextError;
        }

        //
        // Allocate memory for reading the Privileges attribute.
        //

        ObjectRights = MIDL_user_allocate(RightKeyValueLength);

        if (ObjectRights == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FindNextError;
        }

        //
        // Supplied buffer is large enough to hold the SubKey's value.
        // Query the value.
        //

        Status = RtlpNtQueryValueKey(
                     RightKeyHandle,
                     NULL,
                     ObjectRights,
                     &RightKeyValueLength,
                     NULL
                     );

        if (!NT_SUCCESS(Status)) {

            goto FindNextError;
        }

        //
        // Check for the system access or privilege specified
        //

        if (Privilege != NULL) {

            ObjectPrivileges = (PPRIVILEGE_SET) ObjectRights;

            for (Index = 0; Index < ObjectPrivileges->PrivilegeCount ; Index++) {
                if (RtlEqualLuid(&ObjectPrivileges->Privilege[Index].Luid, Privilege)) {
                    ValidSid = TRUE;
                    break;
                }
            }
        } else if (SystemAccess != NULL) {
            ObjectAccess = (PULONG) ObjectRights;

            if (((*ObjectAccess) & (*SystemAccess)) != 0) {
                ValidSid = TRUE;
            }
        }

        //
        // If this sid didn't meet the criteria, return now.  Make sure
        // to bump up the context so we don't try this sid again.
        //

        if (!ValidSid) {
            Status = STATUS_NOT_ALL_ASSIGNED;
            (*EnumerationContext)++;
            goto FindNextFinish;
        }

    }   // privilege != NULL || systemaccess != NULL

    //
    // Construct a path to the Sid attribute of the object relative to
    // the containing directory.  This path has the form
    //
    // <Object Logical Name>"\Sid"
    //
    // The Logical Name of the object has just been returned by the
    // above call to RtlpNtEnumerateSubKey.
    //

    Status = LsapDbJoinSubPaths(
                 &SubKeyNameU,
                 &LsapDbNames[Sid],
                 &SidKeyNameU
                 );

    if (!NT_SUCCESS(Status)) {

        goto FindNextError;
    }

    //
    // Setup object attributes for opening the Sid attribute
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &SidKeyNameU,
        OBJ_CASE_INSENSITIVE,
        ContDirKeyHandle,
        NULL
        );

    //
    // Open the Sid attribute
    //

    Status = RtlpNtOpenKey(
                 &SidKeyHandle,
                 KEY_READ,
                 &ObjectAttributes,
                 0
                 );

    if (!NT_SUCCESS(Status)) {

        SidKeyHandle = NULL;
        goto FindNextError;
    }

    //
    // Now query the size of the buffer required to read the Sid
    // attribute's value.
    //

    SidKeyValueLength = 0;

    Status = RtlpNtQueryValueKey(
                 SidKeyHandle,
                 NULL,
                 NULL,
                 &SidKeyValueLength,
                 NULL
                 );

    //
    // We expect buffer overflow to be returned from a query buffer size
    // call.
    //

    if (Status == STATUS_BUFFER_OVERFLOW) {

        Status = STATUS_SUCCESS;

    } else {

        goto FindNextError;
    }

    //
    // Allocate memory for reading the Sid attribute.
    //

    ObjectSid = MIDL_user_allocate(SidKeyValueLength);

    if (ObjectSid == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FindNextError;
    }

    //
    // Supplied buffer is large enough to hold the SubKey's value.
    // Query the value.
    //

    Status = RtlpNtQueryValueKey(
                 SidKeyHandle,
                 NULL,
                 ObjectSid,
                 &SidKeyValueLength,
                 NULL
                 );

    if (!NT_SUCCESS(Status)) {

        goto FindNextError;
    }

    (*EnumerationContext)++;

    //
    // Return the Sid.
    //

    *NextSid = ObjectSid;

FindNextFinish:

    //
    // Cleanup the rights check
    //

    if (RightKeyHandle != NULL) {

        SecondaryStatus = NtClose(RightKeyHandle);

#if DBG

        if (!NT_SUCCESS(SecondaryStatus)) {

            DbgPrint("LsapDbFindNextSid: NtClose failed 0x%lx\n", Status);
        }

#endif // DBG


    }

    if (ObjectRights != NULL) {
        MIDL_user_free(ObjectRights);
    }

    //
    // If necessary, close the Sid key handle
    //

    if (SidKeyHandle != NULL) {

        SecondaryStatus = NtClose(SidKeyHandle);

#if DBG

        if (!NT_SUCCESS(SecondaryStatus)) {

            DbgPrint("LsapDbFindNextSid: NtClose failed 0x%lx\n", Status);
        }

#endif // DBG

    }

    //
    // If necessary, close the containing directory handle
    //

    if (ContDirKeyHandle != NULL) {

        SecondaryStatus = NtClose(ContDirKeyHandle);

#if DBG
        if (!NT_SUCCESS(SecondaryStatus)) {

            DbgPrint(
                "LsapDbFindNextSid: NtClose failed 0x%lx\n",
                Status
                );
        }

#endif // DBG

    }

    //
    // If necessary, free the Unicode String buffer allocated by
    // LsapDbJoinSubPaths for the Registry key name of the Sid attribute
    // relative to the containing directory Registry key.
    //

    if (SidKeyNameU.Buffer != NULL) {

        RtlFreeUnicodeString( &SidKeyNameU );
    }

    //
    // If necessary, free the Unicode String buffer allocated for
    // Registry key name of the object relative to its containing
    // directory.
    //

    if (SubKeyNameU.Buffer != NULL) {

        LsapFreeLsaHeap( SubKeyNameU.Buffer );
    }

    if ( RightKeyNameU.Buffer != NULL) {
        LsapFreeLsaHeap( RightKeyNameU.Buffer );
    }

    return(Status);

FindNextError:

    //
    // If necessary, free the memory allocated for the object's Sid.
    //

    if (ObjectSid != NULL) {

        MIDL_user_free(ObjectSid);
        *NextSid = NULL;
    }

    goto FindNextFinish;
}



NTSTATUS
LsapDbEnumerateSidsWithRight(
    IN LSAPR_HANDLE ContainerHandle,
    IN OPTIONAL PLUID Privilege,
    IN OPTIONAL PULONG SystemAccess,
    OUT PLSAP_DB_SID_ENUMERATION_BUFFER DbEnumerationBuffer
    )

/*++

Routine Description:

    This function enumerates Sids of objects of a given type within a container
    object.  Since there may be more information than can be returned in a
    single call of the routine, multiple calls can be made to get all of the
    information.  To support this feature, the caller is provided with a
    handle that can be used across calls.  On the initial call,
    EnumerationContext should point to a variable that has been initialized
    to 0.

Arguments:

    ContainerHandle -  Handle to a container object.

    Privilege - If present, specifies what privilege the account must have.

    SystemAccess - If present, specifies what access type the account must
        have.  This cannot be present with Privilege.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    DbEnumerationBuffer - Receives a pointer to a structure that will receive
        the count of entries returned in an enumeration information array, and
        a pointer to the array.  Currently, the only information returned is
        the object Sids.  These Sids may be used together with object type to
        open the objects and obtain any further information available.


    CountReturned - Pointer to variable which will receive a count of the
        entries returned.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if no objects have been enumerated because the
            EnumerationContext value passed in is too high.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_ENUMERATION_ELEMENT LastElement;
    PLSAP_DB_ENUMERATION_ELEMENT FirstElement, NextElement = NULL, FreeElement;
    PSID *Sids = NULL;
    BOOLEAN PreferedMaximumReached = FALSE;
    ULONG EntriesRead;
    ULONG Index, EnumerationIndex;
    BOOLEAN TrustedClient = ((LSAP_DB_HANDLE) ContainerHandle)->Trusted;

    LastElement.Next = NULL;
    FirstElement = &LastElement;

    //
    // If no enumeration buffer provided, return an error.
    //


    if ( !ARGUMENT_PRESENT(DbEnumerationBuffer)  ) {

        return(STATUS_INVALID_PARAMETER);
    }


    //
    // Enumerate objects, stopping when the length of data to be returned
    // reaches or exceeds the Prefered Maximum Length, or reaches the
    // absolute maximum allowed for LSA object enumerations.  We allow
    // the last object enumerated to bring the total amount of data to
    // be returned beyond the Prefered Maximum Length, but not beyond the
    // absolute maximum length.
    //

    EnumerationIndex = 0;

    for (EntriesRead = 0;;) {

        //
        // Allocate memory for next enumeration element (if we haven't
        // already).  Set the Sid field to NULL for cleanup purposes.
        //

        if (NextElement == NULL ) {
            NextElement = MIDL_user_allocate(sizeof (LSAP_DB_ENUMERATION_ELEMENT));

            if (NextElement == NULL) {

                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
        }

        NextElement->Sid = NULL;

        //
        // Find the next object's Sid, and fill in its object information.
        // Note that memory will be allocated via MIDL_user_allocate
        // and must be freed when no longer required.
        //
        Status = LsapDbFindNextSidWithRight (
                     ContainerHandle,
                     &EnumerationIndex,
                     Privilege,
                     SystemAccess,
                     (PLSAPR_SID *) &NextElement->Sid );

        //
        // Stop the enumeration if any error or warning occurs.  Note
        // that the warning STATUS_NO_MORE_ENTRIES will be returned when
        // we've gone beyond the last index.
        //

        if (Status != STATUS_SUCCESS) {

            //
            // If it failed because it was missing the privilege, continue
            //

            if (Status == STATUS_NOT_ALL_ASSIGNED) {
                continue;
            }

            //
            // Since NextElement is not on the list, it will not get
            // freed at the end so we must free it here.
            //

            MIDL_user_free( NextElement );
            break;
        }


        //
        // Link the object just found to the front of the enumeration list
        //

        NextElement->Next = FirstElement;
        FirstElement = NextElement;
        NextElement = NULL;
        EntriesRead++;
    }

    //
    // If an error other than STATUS_NO_MORE_ENTRIES occurred, return it.
    // If STATUS_NO_MORE_ENTRIES was returned, we have enumerated all of the
    // entries.  In this case, return STATUS_SUCCESS if we enumerated at
    // least one entry, otherwise propagate STATUS_NO_MORE_ENTRIES back to
    // the caller.
    //

    if (!NT_SUCCESS(Status)) {

        if (Status != STATUS_NO_MORE_ENTRIES) {

            goto EnumerateSidsError;
        }

        if (EntriesRead == 0) {

            goto EnumerateSidsError;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // Some entries were read, allocate an information buffer for returning
    // them.
    //

    Sids = (PSID *) MIDL_user_allocate( sizeof (PSID) * EntriesRead );

    if (Sids == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto EnumerateSidsError;
    }

    //
    // Memory was successfully allocated for the return buffer.
    // Copy in the enumerated Sids.
    //

    for (NextElement = FirstElement, Index = 0;
        NextElement != &LastElement;
        NextElement = NextElement->Next, Index++) {

        ASSERT(Index < EntriesRead);

        Sids[Index] = NextElement->Sid;
    }

EnumerateSidsFinish:

    //
    // Free the enumeration element structures (if any).
    //

    for (NextElement = FirstElement; NextElement != &LastElement;) {

        //
        // If an error has occurred, dispose of memory allocated
        // for any Sids.
        //

        if (!(NT_SUCCESS(Status) || (Status == STATUS_NO_MORE_ENTRIES))) {

            if (NextElement->Sid != NULL) {

                MIDL_user_free(NextElement->Sid);
            }
        }

        //
        // Free the memory allocated for the enumeration element.
        //

        FreeElement = NextElement;
        NextElement = NextElement->Next;

        MIDL_user_free(FreeElement);
    }

    //
    // Fill in return enumeration structure (0 and NULL in error case).
    //

    DbEnumerationBuffer->EntriesRead = EntriesRead;
    DbEnumerationBuffer->Sids = Sids;

    return(Status);

EnumerateSidsError:

    //
    // If necessary, free memory allocated for returning the Sids.
    //

    if (Sids != NULL) {

        MIDL_user_free( Sids );
        Sids = NULL;
    }

    goto EnumerateSidsFinish;
}


NTSTATUS
LsarEnumerateAccountsWithUserRight(
    IN LSAPR_HANDLE PolicyHandle,
    IN OPTIONAL PLSAPR_UNICODE_STRING UserRight,
    OUT PLSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaEnumerateAccountsWithUserRight API.

    The LsaEnumerateAccounts API returns information about the accounts
    in the target system's Lsa Database.  This call requires
    POLICY_VIEW_LOCAL_INFORMATION access to the Policy object.  Since this call
    accesses the privileges of an account, you must have PRIVILEGE_VIEW
    access to the pseudo-privilege object.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    UserRight - Name of the right that the account must have.

    EnumerationBuffer - Pointer to an enumeration structure that will receive
        a count of the accounts enumerated on this call and a pointer to
        an array of entries containing information for each enumerated
        account.


Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if no objects are enumerated because the
            EnumerationContext value passed in is too high.
--*/

{
    NTSTATUS Status;
    LSAP_DB_SID_ENUMERATION_BUFFER DbEnumerationBuffer;
    ULONG MaxLength;
    ULONG Index;
    ULONG SystemAccess = 0;
    LUID PrivilegeValue;
    PLUID Privilege = NULL;
    PULONG Access = NULL;
    ACCESS_MASK GrantedAccess;
    NTSTATUS AccessStatus;
    BOOLEAN GenerateOnClose;


    LsarpReturnCheckSetup();

    //
    // If no Enumeration Structure or index is provided or we got a badly formatted argument,
    // return an error.
    //

    if ( !ARGUMENT_PRESENT(EnumerationBuffer) || !LsapValidateLsaUnicodeString( UserRight ) ) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Initialize the internal Lsa Database Enumeration Buffer, and
    // the provided Enumeration Buffer to NULL.
    //

    DbEnumerationBuffer.EntriesRead = 0;
    DbEnumerationBuffer.Sids = NULL;
    EnumerationBuffer->EntriesRead = 0;
    EnumerationBuffer->Information = NULL;

    //
    // Acquire the Lsa Database lock.  Verify that the connection handle is
    // valid, is of the expected type and has all of the desired accesses
    // granted.  Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_VIEW_LOCAL_INFORMATION,
                 PolicyObject,
                 AccountObject,
                 LSAP_DB_LOCK
                 );

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Impersonate the caller
    //

    Status = I_RpcMapWin32Status(RpcImpersonateClient(0));
    if (!NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Do an access check on with the UserRight security descriptor.
    //

    Status = NtAccessCheckAndAuditAlarm(
                &LsapState.SubsystemName,
                PolicyHandle,
                &UserRightTypeName,
                &UserRightTypeName,
                UserRightSD,
                PRIVILEGE_VIEW,
                &UserRightGenericMapping,
                FALSE,
                &GrantedAccess,
                &AccessStatus,
                &GenerateOnClose
                );

    (VOID) RpcRevertToSelf();

    //
    // Check both error codes
    //

    if (!NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    Status = AccessStatus;
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // If a right was specified, translate it to a privilege or a
    // system access type.
    //


    if (UserRight != NULL && UserRight->Buffer != NULL ) {

        //
        // Convert the user right string into a privilege or a system
        // access flag.
        //

        for (Index = 0; Index < LSAP_DB_SYSTEM_ACCESS_TYPES; Index++ ) {

            if (RtlEqualUnicodeString(
                    &LsapDbRightAndAccess[Index].UserRight,
                    (PUNICODE_STRING) UserRight,
                    TRUE ) ) { // case insensitive

                SystemAccess = LsapDbRightAndAccess[Index].SystemAccess;
                Access = &SystemAccess;
                break;
            }
        }

        //
        // If system access is zero, try looking up the privilege name.
        //

        if (Access == NULL) {
            Status = LsarLookupPrivilegeValue(
                        PolicyHandle,
                        (PLSAPR_UNICODE_STRING) UserRight,
                        &PrivilegeValue
                        );
            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }
            Privilege = &PrivilegeValue;
        }


    }

    //
    // Call general Sid enumeration routine.
    //

    Status = LsapDbEnumerateSidsWithRight(
                 PolicyHandle,
                 Privilege,
                 Access,
                 &DbEnumerationBuffer
                 );

    //
    // Copy the enumerated information to the output.  We can use the
    // information actually returned by LsapDbEnumerateSids because it
    // happens to be in exactly the correct form.
    //

    EnumerationBuffer->EntriesRead = DbEnumerationBuffer.EntriesRead;
    EnumerationBuffer->Information =
        (PLSAPR_ACCOUNT_INFORMATION) DbEnumerationBuffer.Sids;


Cleanup:

    Status = LsapDbDereferenceObject(
                 &PolicyHandle,
                 PolicyObject,
                 AccountObject,
                 LSAP_DB_LOCK,
                 (SECURITY_DB_DELTA_TYPE) 0,
                 Status
                 );

    LsarpReturnPrologue();

    return(Status);

}


NTSTATUS
LsarEnumerateAccountRights(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID AccountSid,
    OUT PLSAPR_USER_RIGHT_SET UserRights
    )

/*++

Routine Description:

    Returns all the rights of an account.  This is done by gathering the
    privileges and system access of an account and translating that into
    an array of strings.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall.  This API requires
        no special access.

    AccountSid - Sid of account to open.

    UserRights - receives an array of user rights for the account


Return Value:

    STATUS_ACCESS_DENIED - the caller did not have sufficient access to
        return the privileges or system access of the account.

    STATUS_OBJECT_NAME_NOT_FOUND - the specified account did not exist.

    STATUS_INSUFFICIENT_RESOURCES - not enough memory to process the
        request.

--*/

{
    NTSTATUS Status;
    LSAPR_HANDLE AccountHandle = NULL;
    PLSAPR_PRIVILEGE_SET PrivilegeSet = NULL;

    ULONG SystemAccess;
    ULONG UserRightCount = 0;
    ULONG UserRightIndex;
    ULONG PrivilegeIndex;
    PUNICODE_STRING UserRightArray = NULL;
    PUNICODE_STRING TempString;

    LsarpReturnCheckSetup();

    //
    // Open the account for ACCOUNT_VIEW access
    //

    Status = LsarOpenAccount(
                PolicyHandle,
                AccountSid,
                ACCOUNT_VIEW,
                &AccountHandle
                );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    //
    // Get the system access flags
    //

    Status = LsarGetSystemAccessAccount(
                AccountHandle,
                &SystemAccess
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Get the privilege information
    //


    Status = LsarEnumeratePrivilegesAccount(
                AccountHandle,
                &PrivilegeSet
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Repackage the privileges and system access as user rights
    //

    UserRightCount = 0;

    for (PrivilegeIndex = 0;
        PrivilegeIndex < LSAP_DB_SYSTEM_ACCESS_TYPES;
        PrivilegeIndex++ ) {

        if ((SystemAccess & LsapDbRightAndAccess[PrivilegeIndex].SystemAccess) != 0 ) {
            UserRightCount++;
        }
    }

    UserRightCount += PrivilegeSet->PrivilegeCount;

    //
    // If there were no rights, say that and cleanup.
    //

    if (UserRightCount == 0) {

        UserRights->Entries = 0;
        UserRights->UserRights = NULL;
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    UserRightArray = (PUNICODE_STRING)
                        MIDL_user_allocate(UserRightCount * sizeof(LSAPR_UNICODE_STRING));

    if (UserRightArray == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Zero this in case we have to clean it up partially.
    //

    RtlZeroMemory(
        UserRightArray,
        UserRightCount * sizeof(LSAPR_UNICODE_STRING)
        );

    UserRightIndex = 0;
    for (PrivilegeIndex = 0;
        PrivilegeIndex < PrivilegeSet->PrivilegeCount ;
        PrivilegeIndex++ ) {

        TempString = NULL;
        Status = LsarLookupPrivilegeName(
                    PolicyHandle,
                    (PLUID) &PrivilegeSet->Privilege[PrivilegeIndex].Luid,
                    (PLSAPR_UNICODE_STRING *) &TempString
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // The name that came back was allocated in two parts, the buffer
        // and the string.  Copy the buffer pointer to the return array
        // and free the string structure.
        //

        UserRightArray[UserRightIndex++] = * TempString;
        MIDL_user_free(TempString);


    }

    //
    // Copy in the system access rights
    for (PrivilegeIndex = 0;
        PrivilegeIndex < LSAP_DB_SYSTEM_ACCESS_TYPES;
        PrivilegeIndex++ ) {

        if ((SystemAccess & LsapDbRightAndAccess[PrivilegeIndex].SystemAccess) != 0 ) {

            //
            // Allocate a new string and copy the access name into it.
            //

            UserRightArray[UserRightIndex] = LsapDbRightAndAccess[PrivilegeIndex].UserRight;
            UserRightArray[UserRightIndex].Buffer = (LPWSTR)
                    MIDL_user_allocate(LsapDbRightAndAccess[PrivilegeIndex].UserRight.MaximumLength);

            if (UserRightArray[UserRightIndex].Buffer == NULL ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyUnicodeString(
                (PUNICODE_STRING) &UserRightArray[UserRightIndex],
                &LsapDbRightAndAccess[PrivilegeIndex].UserRight
                );

            UserRightIndex++;
        }
    }
    ASSERT(UserRightCount == UserRightIndex);

    UserRights->Entries = UserRightCount;
    UserRights->UserRights = (PLSAPR_UNICODE_STRING) UserRightArray;

    Status = STATUS_SUCCESS;


Cleanup:

    //
    // Cleanup the system rights if we failed
    //


    if (!NT_SUCCESS(Status)) {

        if (UserRightArray != NULL) {

            for (UserRightIndex = 0;
                UserRightIndex < UserRightCount ;
                UserRightIndex++) {

                if (UserRightArray[UserRightIndex].Buffer != NULL) {

                    MIDL_user_free(UserRightArray[UserRightIndex].Buffer);
                }
            }
        }
    }

    if (AccountHandle != NULL) {
        LsapCloseHandle(&AccountHandle, Status);
    }
    if (PrivilegeSet != NULL) {
        MIDL_user_free(PrivilegeSet);
    }

    LsarpReturnPrologue();

    return(Status);
}

NTSTATUS
LsapDbConvertRightsToPrivileges(
    IN PLSAPR_HANDLE PolicyHandle,
    IN PLSAPR_USER_RIGHT_SET UserRights,
    OUT PLSAPR_PRIVILEGE_SET * PrivilegeSet,
    OUT PULONG SystemAccess
    )

/*++

Routine Description:

    Converts an array of user right strings into a privilege set and a
    system access flag.

Arguments:

    UserRights - Contains an array of strings and a count of those strings.

    PrivilegeSet - receives a privilege set of those rights corresponding
        to privilges, allocated with MIDL_user_allocate.

    SystemAccess - receives the access flags specified by the user rights

Return Value:

    STATUS_NO_SUCH_PRIVILEGE - the user right could not be converted into
        a privilege or an access type.

    STATUS_INSUFFICIENT_RESOURCES - there was not enough memory to translate
        the rights to privileges.

--*/

{
    ULONG PrivilegeCount;
    PLSAPR_PRIVILEGE_SET Privileges = NULL;
    ULONG Access = 0;
    ULONG PrivilegeSetSize;
    ULONG PrivilegeIndex = 0;
    ULONG RightIndex;
    ULONG AccessIndex;
    NTSTATUS Status;

    PrivilegeSetSize = sizeof(LSAPR_PRIVILEGE_SET) +
                        (UserRights->Entries-1) * sizeof(LUID_AND_ATTRIBUTES);


    Privileges = (PLSAPR_PRIVILEGE_SET) MIDL_user_allocate(PrivilegeSetSize);
    if (Privileges == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    for (RightIndex = 0;
        RightIndex < UserRights->Entries;
        RightIndex++ ) {

        //
        // First try to map the right as a privilege
        //

        if (NT_SUCCESS(LsarLookupPrivilegeValue(
                        PolicyHandle,
                        (PLSAPR_UNICODE_STRING) &UserRights->UserRights[RightIndex],
                        (PLUID) &Privileges->Privilege[PrivilegeIndex].Luid))) {
            Privileges->Privilege[PrivilegeIndex].Attributes = 0;
            PrivilegeIndex++;
        } else {

            //
            // Try to map it to a system access type
            //

            for (AccessIndex = 0;
                AccessIndex < LSAP_DB_SYSTEM_ACCESS_TYPES;
                AccessIndex++ ) {

                if (RtlEqualUnicodeString(
                        &LsapDbRightAndAccess[AccessIndex].UserRight,
                        (PUNICODE_STRING) &UserRights->UserRights[RightIndex],
                        FALSE) ) { // case sensistive

                    Access |= LsapDbRightAndAccess[AccessIndex].SystemAccess;
                    break;
                }
            }
            if (AccessIndex == LSAP_DB_SYSTEM_ACCESS_TYPES) {
                Status = STATUS_NO_SUCH_PRIVILEGE;
                goto Cleanup;
            }

        }
    }
    Privileges->PrivilegeCount = PrivilegeIndex;
    *PrivilegeSet = Privileges;
    *SystemAccess = Access;
    Status = STATUS_SUCCESS;

Cleanup:
    if (!NT_SUCCESS(Status)) {
        if (Privileges != NULL) {
            MIDL_user_free(Privileges);
        }
    }
    return(Status);

}

NTSTATUS
LsarAddAccountRights(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID AccountSid,
    IN PLSAPR_USER_RIGHT_SET UserRights
    )
/*++

Routine Description:

    Adds rights to the account specified by the account sid.  If the account
    does not exist, it creates the account.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.  The handle must have
        POLICY_CREATE_ACCOUNT access if this is the first call for this
        AccountSid.

    AccountSid - Sid of account to add rights to

    UserRights - Array of unicode strings naming rights to add to the
        account.

Return Value:
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to process the request

    STATUS_INVALID_PARAMTER - one of the parameters was not present

    STATUS_NO_SUCH_PRIVILEGE - One of the user rights was invalid

    STATUS_ACCESS_DENIED - the caller does not have sufficient access to the
        account to add privileges.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAPR_HANDLE AccountHandle = NULL;
    PLSAPR_PRIVILEGE_SET PrivilegeSet = NULL;
    ULONG SystemAccess = 0;
    ULONG OldSystemAccess = 0 ;
    BOOLEAN ChangedAccess = FALSE;
    LSAP_DB_HANDLE InternalHandle = ( LSAP_DB_HANDLE )PolicyHandle;
    BOOLEAN ScePolicyLocked = FALSE;

    LsarpReturnCheckSetup();

    //
    // Make sure we have all the arguments we need
    //

    if (!ARGUMENT_PRESENT(UserRights)) {

        return(STATUS_INVALID_PARAMETER);
    }

    if (!ARGUMENT_PRESENT(AccountSid)) {

        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Do not grab the SCE policy lock for handles opened as SCE policy handles
    //

    if ( !InternalHandle->SceHandle ) {

        RtlEnterCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );
        if ( LsapDbState.ScePolicyLock.NumberOfWaitingShared > MAX_SCE_WAITING_SHARED ) {

            Status = STATUS_TOO_MANY_THREADS;
        }
        RtlLeaveCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );

        if ( !NT_SUCCESS( Status )) {

            goto Cleanup;
        }

        WaitForSingleObject( LsapDbState.SceSyncEvent, INFINITE );
        RtlAcquireResourceShared( &LsapDbState.ScePolicyLock, TRUE );
        ASSERT( !g_ScePolicyLocked );
        ScePolicyLocked = TRUE;
    }

    //
    // Open the account for ACCOUNT_VIEW access
    //

    Status = LsarOpenAccount(
                PolicyHandle,
                AccountSid,
                ACCOUNT_ADJUST_PRIVILEGES | ACCOUNT_ADJUST_SYSTEM_ACCESS | ACCOUNT_VIEW,
                &AccountHandle
                );
    //
    // If the account did not exist, try to create it.
    //

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        Status = LsarCreateAccount(
                    PolicyHandle,
                    AccountSid,
                    ACCOUNT_ADJUST_PRIVILEGES | ACCOUNT_ADJUST_SYSTEM_ACCESS | ACCOUNT_VIEW,
                    &AccountHandle
                    );

    }

    if ( NT_SUCCESS(Status)) {

        Status = LsapDbConvertRightsToPrivileges(
                     PolicyHandle,
                     UserRights,
                     &PrivilegeSet,
                     &SystemAccess
                     );
    }

    if (!NT_SUCCESS(Status) ) {

        goto Cleanup;
    }

    //
    // If system access was changed, add it
    //

    if (SystemAccess != 0) {
        Status = LsarGetSystemAccessAccount(
                    AccountHandle,
                    &OldSystemAccess
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        if ( SystemAccess != OldSystemAccess ) {

            SystemAccess = SystemAccess | OldSystemAccess;

            Status = LsapSetSystemAccessAccount(
                         AccountHandle,
                         SystemAccess,
                         FALSE
                         );

            if ( !NT_SUCCESS( Status )) {

                goto Cleanup;
            }

            ChangedAccess = TRUE;
        }
    }

    //
    // If privileges were changed, add them.
    //

    if (PrivilegeSet->PrivilegeCount != 0) {

        Status = LsapAddPrivilegesToAccount(
                    AccountHandle,
                    PrivilegeSet,
                    FALSE
                    );
    }

Cleanup:

    //
    // NOTE: we do NOT generate an SCE notification here, because
    //       one would already be sent through LsapSetSystemAccessAccount
    //       or LsapAddPrivilegesToAccount
    //

    //
    // If we didn't make both changes, unroll the one we did
    //

    if (!NT_SUCCESS(Status) && ChangedAccess) {

        //
        // Ignore the error code since this is a last-ditch effort
        //

        (void) LsapSetSystemAccessAccount(
                    AccountHandle,
                    OldSystemAccess,
                    FALSE
                    );

    }

    if (PrivilegeSet != NULL) {
        MIDL_user_free(PrivilegeSet);
    }

    if (AccountHandle != NULL) {
        LsapCloseHandle(&AccountHandle, Status);
    }

    if ( ScePolicyLocked ) {

        RtlReleaseResource( &LsapDbState.ScePolicyLock );
    }

    LsarpReturnPrologue();

    return(Status);

}

NTSTATUS
LsarRemoveAccountRights(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID AccountSid,
    IN BOOLEAN AllRights,
    IN PLSAPR_USER_RIGHT_SET UserRights
    )
/*++

Routine Description:

    Removes rights to the account specified by the account sid.  If the
    AllRights flag is set or if all the rights are removed, the account
    is deleted.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call

    AccountSid - Sid of account to remove rights from

    AllRights - if TRUE, the account will be deleted

    UserRights - Array of unicode strings naming rights to remove from the
        account.

Return Value:
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to process the request

    STATUS_INVALID_PARAMTER - one of the parameters was not present

    STATUS_NO_SUCH_PRIVILEGE - One of the user rights was invalid

    STATUS_ACCESS_DENIED - the caller does not have sufficient access to the
        account to add privileges.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAPR_HANDLE AccountHandle = NULL;
    PLSAPR_PRIVILEGE_SET PrivilegeSet = NULL;
    ULONG SystemAccess;
    ULONG OldSystemAccess = 0;
    BOOLEAN ChangedAccess = FALSE;
    PLSAPR_PRIVILEGE_SET FinalPrivilegeSet = NULL;
    LSAP_DB_HANDLE InternalHandle = ( LSAP_DB_HANDLE )PolicyHandle;
    BOOLEAN ScePolicyLocked = FALSE;

    LsarpReturnCheckSetup();

    //
    // Do not grab the SCE policy lock for handles opened as SCE policy handles
    //

    if ( !InternalHandle->SceHandle ) {

        RtlEnterCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );
        if ( LsapDbState.ScePolicyLock.NumberOfWaitingShared > MAX_SCE_WAITING_SHARED ) {

            Status = STATUS_TOO_MANY_THREADS;
        }
        RtlLeaveCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );

        if ( !NT_SUCCESS( Status )) {

            goto Cleanup;
        }

        WaitForSingleObject( LsapDbState.SceSyncEvent, INFINITE );
        RtlAcquireResourceShared( &LsapDbState.ScePolicyLock, TRUE );
        ASSERT( !g_ScePolicyLocked );
        ScePolicyLocked = TRUE;
    }

    //
    // Open the account for ACCOUNT_VIEW access
    //

    Status = LsarOpenAccount(
                PolicyHandle,
                AccountSid,
                ACCOUNT_ADJUST_PRIVILEGES |
                ACCOUNT_ADJUST_SYSTEM_ACCESS |
                ACCOUNT_VIEW |
                DELETE,
                &AccountHandle
                );
    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }


    //
    // Convert the rights to privileges only if they don't want all
    // rights removed.  In that case, we don't care.
    //

    if (AllRights == FALSE) {
        Status = LsapDbConvertRightsToPrivileges(
                    PolicyHandle,
                    UserRights,
                    &PrivilegeSet,
                    &SystemAccess
                    );
        if (!NT_SUCCESS(Status) ) {
            goto Cleanup;
        }
    } else {
        Status = LsapDeleteObject(
                    &AccountHandle,
                    FALSE
                    );

        ASSERT( AccountHandle == NULL );

        goto Cleanup;
    }

    //
    // If system access was changed, add it
    //

    Status = LsarGetSystemAccessAccount(
                AccountHandle,
                &OldSystemAccess
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // After this block of code, SystemAccess should contain the final
    // access for the account.
    //

    if (SystemAccess != 0) {

        SystemAccess = OldSystemAccess & ~SystemAccess;

        Status = LsapSetSystemAccessAccount(
                    AccountHandle,
                    SystemAccess,
                    FALSE
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }
        ChangedAccess = TRUE;
    } else {

        SystemAccess = OldSystemAccess;
    }

    //
    // If privileges were changed, add them.
    //

    if (AllRights || PrivilegeSet->PrivilegeCount != 0) {

        Status = LsapRemovePrivilegesFromAccount(
                    AccountHandle,
                    FALSE,          // don't remove all rights
                    PrivilegeSet,
                    FALSE
                    );

    }

    //
    // Check to see if all the privileges have been removed - if so,
    // and system access is 0, delete the account.
    //

    Status = LsarEnumeratePrivilegesAccount(
                AccountHandle,
                &FinalPrivilegeSet
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    if ((FinalPrivilegeSet->PrivilegeCount == 0) &&
         (SystemAccess == 0)) {

        //
        // The account has no privileges or system access - delete it.
        //

        Status = LsapDeleteObject(
                    &AccountHandle,
                    FALSE
                    );

        ASSERT( AccountHandle == NULL );
    }

Cleanup:

    MIDL_user_free( FinalPrivilegeSet );

    //
    // NOTE: we do NOT generate an SCE notification here, because
    //       one would already be sent through LsapSetSystemAccessAccount,
    //       LsapAddPrivilegesToAccount or LsapDeleteObject
    //

    //
    // If we didn't make both changes, unroll the one we did
    //

    if ( !NT_SUCCESS( Status ) && ChangedAccess ) {

        NTSTATUS LocalStatus = STATUS_SUCCESS;

        if ( AccountHandle == NULL ) {

            //
            // We probably failed to delete the object, so reopen
            // the handle and attempt to restore the old account rights
            //

            LocalStatus = LsarOpenAccount(
                              PolicyHandle,
                              AccountSid,
                              ACCOUNT_ADJUST_PRIVILEGES |
                                 ACCOUNT_ADJUST_SYSTEM_ACCESS |
                                 ACCOUNT_VIEW,
                              &AccountHandle
                              );
        }

        if ( NT_SUCCESS( LocalStatus )) {

            //
            // Ignore the error code since this is a last-ditch effort
            //

            (void) LsapSetSystemAccessAccount(
                        AccountHandle,
                        OldSystemAccess,
                        FALSE
                        );
        }
    }

    if (PrivilegeSet != NULL) {
        MIDL_user_free(PrivilegeSet);
    }

    if (AccountHandle != NULL) {
        LsapCloseHandle(&AccountHandle, Status);
    }

    if ( ScePolicyLocked ) {

        RtlReleaseResource( &LsapDbState.ScePolicyLock );
    }

    LsarpReturnPrologue();

    return(Status);

}

NTSTATUS
LsarQueryTrustedDomainInfo(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID TrustedDomainSid,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PLSAPR_TRUSTED_DOMAIN_INFO * TrustedDomainInformation
    )
/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaQueryInfoTrustedDomain API.

    The LsaQueryInfoTrustedDomain API obtains information from a
    TrustedDomain object.  The caller must have access appropriate to the
    information being requested (see InformationClass parameter).  It also
    may query the secret object (for the TrustedDomainPasswordInformation
    class).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainSid - Sid of domain to query.

    InformationClass - Specifies the information to be returned.

    Buffer - Receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/
{

    LSAPR_HANDLE DomainHandle = NULL;
    LSAPR_HANDLE SecretHandle = NULL;
    NTSTATUS Status;
    PLSAPR_TRUSTED_DOMAIN_INFO DomainInfo = NULL;
    PLSAPR_TRUSTED_PASSWORD_INFO PasswordInfo = NULL;
    TRUSTED_INFORMATION_CLASS ClassToUse;
    ULONG DesiredAccess;
    BOOLEAN QueryPassword = FALSE;
    UNICODE_STRING SecretName;
    PLSAPR_CR_CIPHER_VALUE Password = NULL;
    PLSAPR_CR_CIPHER_VALUE OldPassword = NULL;

    LsarpReturnCheckSetup();

    SecretName.Buffer = NULL;

    ClassToUse = InformationClass;
    switch(InformationClass) {

    case TrustedPasswordInformation:
        QueryPassword = TRUE;
        ClassToUse = TrustedDomainNameInformation;
        break;

    case TrustedControllersInformation:
        //
        // This info class is obsolete
        //
        return(STATUS_NOT_IMPLEMENTED);

    }

    //
    // Validate the Information Class and determine the access required to
    // query this Trusted Domain Information Class.
    //

    Status = LsapDbVerifyInfoQueryTrustedDomain(
                 ClassToUse,
                 FALSE,
                 &DesiredAccess
                 );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    Status = LsarOpenTrustedDomain(
                PolicyHandle,
                TrustedDomainSid,
                DesiredAccess,
                &DomainHandle
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    Status = LsarQueryInfoTrustedDomain(
                DomainHandle,
                ClassToUse,
                &DomainInfo
                );

    //
    // If the info we wanted was what we queried, cleanup now.
    //

    if (!QueryPassword) {
        if (NT_SUCCESS(Status)) {
            *TrustedDomainInformation = DomainInfo;
            DomainInfo = NULL;
        }
        goto Cleanup;
    }

    //
    // Build the secret name for the domain.
    //


    //
    // Build the secret name
    //

    SecretName.Length = DomainInfo->TrustedDomainNameInfo.Name.Length;
    SecretName.Length += (LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_LENGTH) * sizeof(WCHAR);
    SecretName.MaximumLength = SecretName.Length + sizeof(WCHAR);

    SecretName.Buffer = (LPWSTR) MIDL_user_allocate(SecretName.MaximumLength);
    if (SecretName.Buffer == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyMemory(
        SecretName.Buffer,
        LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX,
        LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_LENGTH * sizeof(WCHAR)
        );
    RtlCopyMemory(
        SecretName.Buffer + LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_LENGTH,
        DomainInfo->TrustedDomainNameInfo.Name.Buffer,
        DomainInfo->TrustedDomainNameInfo.Name.MaximumLength
        );

    //
    // Free the domain info so we can re-use it lower down
    //

    LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO(
        TrustedDomainNameInformation,
        DomainInfo
        );
    DomainInfo = NULL;

    //
    // Now try to open the secret
    //

    Status = LsarOpenSecret(
                PolicyHandle,
                (PLSAPR_UNICODE_STRING) &SecretName,
                SECRET_QUERY_VALUE,
                &SecretHandle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsarQuerySecret(
                SecretHandle,
                &Password,
                NULL,
                &OldPassword,
                NULL
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Build a new domain info with the secret information
    //

    DomainInfo = (PLSAPR_TRUSTED_DOMAIN_INFO)
        MIDL_user_allocate(sizeof(LSAPR_TRUSTED_DOMAIN_INFO));

    if (DomainInfo == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    DomainInfo->TrustedPasswordInfo.Password = Password;
    DomainInfo->TrustedPasswordInfo.OldPassword = OldPassword;

    Password = NULL;

    OldPassword = NULL;

    *TrustedDomainInformation = DomainInfo;
    DomainInfo = NULL;
    Status = STATUS_SUCCESS;



Cleanup:
    if (SecretName.Buffer != NULL) {
        MIDL_user_free(SecretName.Buffer);
    }

    if (DomainHandle != NULL) {
        LsapCloseHandle(&DomainHandle, Status);
    }

    if (SecretHandle != NULL) {
        LsapCloseHandle(&SecretHandle, Status);
    }

    if (DomainInfo != NULL) {
        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO(
            ClassToUse,
            DomainInfo
            );

    }
    if (Password != NULL) {
        LsaIFree_LSAPR_CR_CIPHER_VALUE(Password);
    }
    if (OldPassword != NULL) {
        LsaIFree_LSAPR_CR_CIPHER_VALUE(OldPassword);
    }

    LsarpReturnPrologue();

    return(Status);
}

NTSTATUS
LsarSetTrustedDomainInfo(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID TrustedDomainSid,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaSetInfoTrustedDomain API.

    The LsaSetInformationTrustedDomain API modifies information in the Trusted
    Domain Object and in the Secret Object.  The caller must have access
    appropriate to the information to be changed in the Policy Object, see
    the InformationClass parameter.

    If the domain does not yet exist and the information class is
    TrustedDomainNameInformation, then the domain is created.  If the
    domain exists and the class is TrustedDomainNameInformation, an
    error is returned.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    TrustedDomainSid - Sid of domain to modify.

    InformationClass - Specifies the type of information being changed.
        The information types and accesses required to change them are as
        follows:

        TrustedDomainNameInformation      POLICY_TRUST_ADMIN
        TrustedPosixOffsetInformation     none
        TrustedPasswordInformation        POLICY_CREATE_SECRET
        TrustedDomainNameInformationEx    POLICY_TRUST_ADMIN

    Buffer - Points to a structure containing the information appropriate
        to the InformationClass parameter.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        Others TBS
--*/
{
    LSAPR_HANDLE DomainHandle = NULL;
    LSAPR_HANDLE SecretHandle = NULL;
    PLSAPR_TRUSTED_DOMAIN_INFO DomainInfo = NULL;
    PTRUSTED_DOMAIN_FULL_INFORMATION CurrentTrustedDomainFullInfo = NULL;
    UNICODE_STRING SecretName;
    NTSTATUS Status = STATUS_SUCCESS;

    LsarpReturnCheckSetup();

    SecretName.Buffer = NULL;

    //
    // If the class is domain name, try to create the domain since you
    // can't change the name of an existing domain.
    //

    if (InformationClass == TrustedDomainNameInformation) {

        LSAPR_TRUST_INFORMATION TrustInformation;

        //
        // Try to create the domain if we have the name information
        //

        TrustInformation.Name = TrustedDomainInformation->TrustedDomainNameInfo.Name;
        TrustInformation.Sid = TrustedDomainSid;

        Status = LsarCreateTrustedDomain(
                    PolicyHandle,
                    &TrustInformation,
                    0,  // desired access
                    &DomainHandle
                    );

        //
        // Grab a copy of the current information on the object for auditing
        // purposes if auditing is enabled.
        //

        if ( NT_SUCCESS( Status ) &&
             LsapAdtAuditingPolicyChanges()) {

            BOOLEAN SavedTrusted;

            SavedTrusted = ((LSAP_DB_HANDLE) DomainHandle)->Trusted;

            ((LSAP_DB_HANDLE) DomainHandle)->Trusted = TRUE;

            Status = LsarQueryInfoTrustedDomain( DomainHandle,
                                                 TrustedDomainFullInformation,
                                                 (PLSAPR_TRUSTED_DOMAIN_INFO *)
                                                 &CurrentTrustedDomainFullInfo );

            ((LSAP_DB_HANDLE) DomainHandle)->Trusted = SavedTrusted;

            if ( !NT_SUCCESS( Status ) ) {

                goto Cleanup;
            }
        }

        goto Cleanup;
    }

    if ( InformationClass == TrustedDomainInformationEx ) {

        //
        // Create the domain trusted doman
        // First, try to open the domain.  If it fails, we'll create it
        //
        Status = LsarOpenTrustedDomain( PolicyHandle,
                                        TrustedDomainSid,
                                        0,
                                        &DomainHandle );

        if ( Status == STATUS_OBJECT_PATH_NOT_FOUND ) {

            Status = LsapCreateTrustedDomain2(
                        PolicyHandle,
                        (PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX)TrustedDomainInformation,
                        NULL,
                        0, // Desired access
                        &DomainHandle
                        );

        } else if ( NT_SUCCESS( Status ) ) {

            Status = LsarSetInformationTrustedDomain( DomainHandle,
                                                      InformationClass,
                                                      TrustedDomainInformation );
        }

        goto Cleanup;
    }

    if (InformationClass == TrustedPosixOffsetInformation) {

        //
        // For posix information, we just do the normal set information
        //

        Status = LsarOpenTrustedDomain(
                    PolicyHandle,
                    TrustedDomainSid,
                    TRUSTED_SET_POSIX,
                    &DomainHandle
                    );

        if (!NT_SUCCESS(Status)) {

            goto Cleanup;
        }

        Status = LsarSetInformationTrustedDomain(
                    DomainHandle,
                    InformationClass,
                    TrustedDomainInformation
                    );

        goto Cleanup;
    }

    if (InformationClass != TrustedPasswordInformation) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // For posix information, we just do the normal set information
    //

    Status = LsarOpenTrustedDomain(
                PolicyHandle,
                TrustedDomainSid,
                TRUSTED_QUERY_DOMAIN_NAME,
                &DomainHandle
                );

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    //
    // Query the name of the domain so we know what secret to set
    //

    Status = LsarQueryInfoTrustedDomain(
                DomainHandle,
                TrustedDomainNameInformation,
                &DomainInfo
                );

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    //
    // Build the secret name
    //

    SecretName.Length = DomainInfo->TrustedDomainNameInfo.Name.Length;
    SecretName.Length += (LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_LENGTH) * sizeof(WCHAR);
    SecretName.MaximumLength = SecretName.Length + sizeof(WCHAR);

    SecretName.Buffer = (LPWSTR) MIDL_user_allocate(SecretName.MaximumLength);
    if (SecretName.Buffer == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyMemory(
        SecretName.Buffer,
        LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX,
        LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_LENGTH * sizeof(WCHAR)
        );

    RtlCopyMemory(
        SecretName.Buffer + LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_LENGTH,
        DomainInfo->TrustedDomainNameInfo.Name.Buffer,
        DomainInfo->TrustedDomainNameInfo.Name.MaximumLength
        );

    //
    // Open the secret.  If that fails, try to create it.
    //

    Status = LsarOpenSecret(
                PolicyHandle,
                (PLSAPR_UNICODE_STRING) &SecretName,
                SECRET_SET_VALUE,
                &SecretHandle
                );

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

        Status = LsarCreateSecret(
                    PolicyHandle,
                    (PLSAPR_UNICODE_STRING) &SecretName,
                    SECRET_SET_VALUE,
                    &SecretHandle
                    );
    }

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    Status = LsarSetSecret(
                SecretHandle,
                TrustedDomainInformation->TrustedPasswordInfo.Password,
                TrustedDomainInformation->TrustedPasswordInfo.OldPassword
                );

Cleanup:

    if (NT_SUCCESS(Status)) {

        //
        // TrustedDomainInformationEx and TrustedPosixOffsetInformation
        // are audited in LsarSetInformationTrustedDomain.
        //

        //
        // ISSUE-2000/08/09-kumarp : audit TrustedPasswordInformation change?
        // 

        if ((InformationClass == TrustedDomainNameInformation) &&
            LsapAdtAuditingPolicyChanges()) {

            //
            // generate the audit.
            // since TrustedDomainNameInformation changes only the name,
            // don't bother passing the trust type, direction, attributes
            // just pass 0, 0, 0 for them
            //

            (void) LsapAdtTrustedDomainMod(
                       EVENTLOG_AUDIT_SUCCESS,
                       CurrentTrustedDomainFullInfo->Information.Sid,

                       (PUNICODE_STRING) &DomainInfo->TrustedDomainNameInfo.Name,
                       0, 0, 0, // trust type, direction, attributes

                       (PUNICODE_STRING) &TrustedDomainInformation->TrustedDomainNameInfo.Name,
                       0, 0, 0  // trust type, direction, attributes
                       );
        }
    }

    if ( CurrentTrustedDomainFullInfo != NULL ) {

        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO(
            TrustedDomainFullInformation,
            (PLSAPR_TRUSTED_DOMAIN_INFO) CurrentTrustedDomainFullInfo );
    }

    if (SecretName.Buffer != NULL) {

        MIDL_user_free(SecretName.Buffer);
    }

    if (DomainInfo != NULL) {

        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO(
            TrustedDomainNameInformation,
            DomainInfo
            );
    }

    if (DomainHandle != NULL) {

        LsapCloseHandle(&DomainHandle, Status);
    }

    if (SecretHandle != NULL) {

        LsapCloseHandle(&SecretHandle, Status);
    }

    LsarpReturnPrologue();

    return(Status);
}

NTSTATUS
LsarDeleteTrustedDomain(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID TrustedDomainSid
    )

/*++

Routine Description:

    This routine deletes a trusted domain and the associated secret.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainSid - Sid of domain to delete

Return Value:

    STATUS_ACCESS_DENIED - caller has insufficient access to delete
        the requested domain.

    STATUS_OBJECT_NAME_NOT_FOUND - The requested domain does not exist.

--*/

{
    LSAPR_HANDLE DomainHandle = NULL;
    LSAPR_HANDLE SecretHandle = NULL;
    UNICODE_STRING SecretName;
    PLSAPR_TRUSTED_DOMAIN_INFO DomainInfo = NULL;
    NTSTATUS Status;

    LsarpReturnCheckSetup();


    SecretName.Buffer = NULL;

    //
    // Open the domain so we can find its name (to delete the secret)
    // and then delete it.
    //


    Status = LsarOpenTrustedDomain(
                PolicyHandle,
                TrustedDomainSid,
                TRUSTED_QUERY_DOMAIN_NAME | DELETE,
                &DomainHandle
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Query the domain name so we can delete the secret
    //

    Status = LsarQueryInfoTrustedDomain(
                DomainHandle,
                TrustedDomainNameInformation,
                &DomainInfo
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Build the secret name
    //

    SecretName.Length = DomainInfo->TrustedDomainNameInfo.Name.Length;
    SecretName.Length += (LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_LENGTH) * sizeof(WCHAR);
    SecretName.MaximumLength = SecretName.Length + sizeof(WCHAR);

    SecretName.Buffer = (LPWSTR) MIDL_user_allocate(SecretName.MaximumLength);
    if (SecretName.Buffer == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyMemory(
        SecretName.Buffer,
        LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX,
        LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_LENGTH * sizeof(WCHAR)
        );
    RtlCopyMemory(
        SecretName.Buffer + LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_LENGTH,
        DomainInfo->TrustedDomainNameInfo.Name.Buffer,
        DomainInfo->TrustedDomainNameInfo.Name.MaximumLength
        );

    //
    // Delete the domain
    //

    Status = LsarDeleteObject(&DomainHandle);
    if (Status != STATUS_SUCCESS) {
        goto Cleanup;
    }
    //
    // Since we successfully deleted the secret, set it to zero so we don't
    // try to close it later.
    //

    DomainHandle = NULL;

    //
    // Now try to open the secret and delete it.
    //

    Status = LsarOpenSecret(
                PolicyHandle,
                (PLSAPR_UNICODE_STRING) &SecretName,
                DELETE,
                &SecretHandle
                );

    if (!NT_SUCCESS(Status)) {

        //
        // If the secret does not exist, that just means that the password
        // was never set.
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            Status = STATUS_SUCCESS;
        }
        goto Cleanup;
    }

    Status = LsarDeleteObject(&SecretHandle);

    //
    // If we successfully deleted the secret, set it to zero so we don't
    // try to close it later.
    //

    if (NT_SUCCESS(Status)) {
        SecretHandle = NULL;
    }


Cleanup:
    if (SecretHandle != NULL) {
        LsapCloseHandle(&SecretHandle, Status);
    }

    if (DomainHandle != NULL) {
        LsapCloseHandle(&DomainHandle, Status);
    }

    if (DomainInfo != NULL) {
        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO(
            TrustedDomainNameInformation,
            DomainInfo
            );
    }
    if (SecretName.Buffer != NULL) {
        MIDL_user_free(SecretName.Buffer);
    }

    LsarpReturnPrologue();

    return(Status);

}

NTSTATUS
LsarStorePrivateData(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING KeyName,
    IN OPTIONAL PLSAPR_CR_CIPHER_VALUE EncryptedData
    )
/*++

Routine Description:

    This routine stores a secret under the name KeyName.  If the password
    is not present, the secret is deleted

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall.  If this is the
        first call, it requres POLICY_CREATE_SECRET access.

    KeyName - Name to store the secret under.

    EncryptedData - private data encrypted with session key.

Return Value:

    STATUS_ACCESS_DENIED - caller has insufficient privilege to set
        the workstation password.

    STATUS_INVALID_PARAMETER - A badly formatted KeyName parameter was given

--*/

{
    LSAPR_HANDLE SecretHandle = NULL;
    NTSTATUS Status;
    ULONG DesiredAccess;
    BOOLEAN DeletePassword = FALSE;

    LsarpReturnCheckSetup();

    //
    // Validate the input buffer
    //
    if ( !LsapValidateLsaUnicodeString( KeyName ) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT(EncryptedData)) {
        DesiredAccess = SECRET_SET_VALUE;
    } else {
        DesiredAccess = DELETE;
        DeletePassword = TRUE;
    }


    Status = LsarOpenSecret(
                PolicyHandle,
                KeyName,
                DesiredAccess,
                &SecretHandle
                );

    //
    // If the secret didn't exist, and we aren't trying to delete it, create it.
    //

    if ((Status == STATUS_OBJECT_NAME_NOT_FOUND) &&
        (!DeletePassword)) {
        Status = LsarCreateSecret(
                    PolicyHandle,
                    KeyName,
                    SECRET_SET_VALUE,
                    &SecretHandle
                    );

    }

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    if (DeletePassword) {
        Status = LsarDeleteObject(&SecretHandle);

        //
        // If we succeeded, zero the handle so we don't try to close
        // it later.
        //

        if (NT_SUCCESS(Status)) {
            SecretHandle = NULL;
        }

    } else {

        Status = LsarSetSecret(
                    SecretHandle,
                    EncryptedData,
                    NULL
                    );

    }

Cleanup:
    if (SecretHandle != NULL ) {
        LsapCloseHandle(&SecretHandle, Status);
    }

    LsarpReturnPrologue();

    return(Status);
}

NTSTATUS
LsarRetrievePrivateData(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING KeyName,
    IN OUT PLSAPR_CR_CIPHER_VALUE *EncryptedData
    )
/*++

Routine Description:

    This routine returns the workstation password stored in the
    KeyName  secret.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall

    KeyName - Name of secret to retrieve

    EncryptedData - Receives data encrypted with session key


Return Value:

    STATUS_ACCESS_DENIED - caller has insufficient access to get the
        workstation password.

    STATUS_OBJECT_NAME_NOT_FOUND - there is no workstation password.

    STATUS_INVALID_PARAMETER - A badly formmated KeyName was given

--*/

{
    LSAPR_HANDLE SecretHandle = NULL;
    NTSTATUS Status;

    LsarpReturnCheckSetup();

    //
    // Validate the input buffer
    //
    if ( !LsapValidateLsaUnicodeString( KeyName ) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status = LsarOpenSecret(
                PolicyHandle,
                KeyName,
                SECRET_QUERY_VALUE,
                &SecretHandle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsarQuerySecret(
                SecretHandle,
                EncryptedData,
                NULL,
                NULL,
                NULL
                );

Cleanup:
    if (SecretHandle != NULL ) {
        LsapCloseHandle(&SecretHandle, Status);
    }

    LsarpReturnPrologue();

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\forest.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    forest.c

Abstract:

    Implementation of a variety of TrustedDomain features for supporting forests

Author:

    Mac McLain          (MacM)       Feb 17, 1998

Environment:

    User Mode

Revision History:

--*/
#include <lsapch2.h>
#include <dbp.h>
#include <lmcons.h>

VOID
LsapDsForestFreeTrustBlob(
    IN PLSAPDS_FOREST_TRUST_BLOB TrustBlob
    )
/*++

Routine Description:

    This function will free an individual trust blob.  This blob is used in transition from
    reading the into from the DS and assembling the outgoing list

Arguments:

    TrustBlob - Trust blob to free

Returns:

    VOID

--*/
{

    LsapFreeLsaHeap( TrustBlob->DomainName.Buffer );
    LsapFreeLsaHeap( TrustBlob->FlatName.Buffer );
    LsapFreeLsaHeap( TrustBlob->DomainSid );

}

VOID
LsapDsForestFreeTrustBlobList(
    IN PLIST_ENTRY TrustList
    )
/*++

Routine Description:

    This function will free a list of trust blobs

Arguments:

    TrustList - Trust list to free

Returns:

    VOID

--*/
{
    PLSAPDS_FOREST_TRUST_BLOB Current;
    PLIST_ENTRY ListEntry, NextEntry;

    ListEntry = TrustList->Flink;

    //
    // Process all of the entries
    //
    while ( ListEntry != TrustList ) {

        Current = CONTAINING_RECORD( ListEntry,
                                     LSAPDS_FOREST_TRUST_BLOB,
                                     Next );


        NextEntry = ListEntry->Flink;

        RemoveEntryList( ListEntry );

        LsapDsForestFreeTrustBlob( Current );
        LsapFreeLsaHeap( Current );

        ListEntry = NextEntry;

    }
}


NTSTATUS
LsapDsForestBuildTrustEntryForAttrBlock(
    IN PUNICODE_STRING EnterpriseDnsName,
    IN ATTRBLOCK *AttrBlock,
    OUT PLSAPDS_FOREST_TRUST_BLOB *TrustInfo
    )
/*++

Routine Description:

    This function will take the contents of a single ATTRBLOCK returned via the search
    info a trust blob.  This blob is then used to create the trust tree.

    The initialize trust blob should be freed with LsapDsForestFreeTrustBlob

Arguments:

    EnterpriseDnsName - Dns domain name of the root of the enterprise.  This is what
        denotes the trust root

    AttrBlock - ATTRBLOCK to return

    TrustInfo - Trust info to initialize

Returns:

    STATUS_SUCCESS - Success

    STATUS_INVALID_PARAMETER - An invalid attribute id was encountered

    STATUS_INSUFFICIENT_MEMORY - A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i, j;
    PDSNAME DsName;
    PLSAPDS_FOREST_TRUST_BLOB TrustBlob;

    TrustBlob = ( PLSAPDS_FOREST_TRUST_BLOB )LsapAllocateLsaHeap(
                                                            sizeof( LSAPDS_FOREST_TRUST_BLOB ) );

    if ( TrustBlob == NULL ) {

        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    RtlZeroMemory( TrustBlob, sizeof( LSAPDS_FOREST_TRUST_BLOB ) );

    for ( i = 0; i < AttrBlock->attrCount && NT_SUCCESS( Status ); i++ ) {

        //
        // Initialize this so we can tell later on whether or not we have any root trusts or
        // a parent
        //
        DsName = NULL;
        switch ( AttrBlock->pAttr[ i ].attrTyp ) {
        case ATT_ROOT_TRUST:
            TrustBlob->TreeRoot = TRUE;
            break;

        case ATT_TRUST_PARENT:

            DsName = ( PDSNAME )AttrBlock->pAttr[i].AttrVal.pAVal->pVal;
            LSAPDS_COPY_GUID_ON_SUCCESS( Status,
                                         &TrustBlob->Parent,
                                         &DsName->Guid );
            TrustBlob->ParentTrust = TRUE;

            break;

        case ATT_OBJECT_GUID:

            LSAPDS_COPY_GUID_ON_SUCCESS(
                    Status,
                    &TrustBlob->ObjectGuid,
                    AttrBlock->pAttr[i].AttrVal.pAVal->pVal );
            break;

        case ATT_DNS_ROOT:
            LSAPDS_ALLOC_AND_COPY_STRING_TO_UNICODE_ON_SUCCESS(
                Status,
                &TrustBlob->DomainName,
                AttrBlock->pAttr[i].AttrVal.pAVal->pVal,
                AttrBlock->pAttr[i].AttrVal.pAVal->valLen );
            break;

        case ATT_NETBIOS_NAME:
            LSAPDS_ALLOC_AND_COPY_STRING_TO_UNICODE_ON_SUCCESS(
                Status,
                &TrustBlob->FlatName,
                AttrBlock->pAttr[i].AttrVal.pAVal->pVal,
                AttrBlock->pAttr[i].AttrVal.pAVal->valLen );
            break;

        case ATT_NC_NAME:

            DsName = ( PDSNAME )AttrBlock->pAttr[i].AttrVal.pAVal->pVal;

            if ( DsName->SidLen > 0 ) {

                LSAPDS_ALLOC_AND_COPY_SID_ON_SUCCESS( Status,
                                                      TrustBlob->DomainSid,
                                                      &( DsName->Sid ) );
            }

            RtlCopyMemory( &TrustBlob->DomainGuid,
                           &DsName->Guid,
                           sizeof( GUID ) );
            TrustBlob->DomainGuidSet = TRUE;

            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
            LsapDsDebugOut(( DEB_ERROR,
                             "LsapDsForestBuildTrustEntryForAttrBlock: Invalid attribute type %lu\n",
                             AttrBlock->pAttr[ i ].attrTyp ));
            break;

        }


    }


    //
    // If we think we have a root object, we'll need to verify it.
    //
    if ( NT_SUCCESS( Status )) {

        if ( RtlEqualUnicodeString( EnterpriseDnsName, &TrustBlob->DomainName, TRUE ) ) {

            // The root should not be a child of anything
            ASSERT(!TrustBlob->ParentTrust);
            TrustBlob->ForestRoot = TRUE;
            TrustBlob->TreeRoot = FALSE;
        }
    }

    //
    // If something failed, clean up
    //
    if ( NT_SUCCESS( Status ) ) {

        *TrustInfo = TrustBlob;

    } else {

        LsapDsForestFreeTrustBlob( TrustBlob );

        LsapFreeLsaHeap( TrustBlob );

    }

    return( Status );

}



NTSTATUS
LsapDsForestSearchXRefs(
    IN PUNICODE_STRING EnterpriseDnsName,
    IN PLIST_ENTRY TrustList,
    OUT PAGED_RESULT **ContinuationBlob
    )
/*++

Routine Description:

    This function will perform a single paged search for domain cross ref objects.  The
    information returned from this single search is returned in a copied list of trust blobs.
    This is necessary to prevent performing multiple searches on the same thread state, thereby
    potentially consuming large quantities of memory.  A thread state is created and destroyed
    for each iteration.

Arguments:

    EnterpriseDnsName - Dns domain name of the enterprise

    TrustList - Points to the head of a list where the trust blobs will be returned.
        The trust blob representing the root of the forest is returned at the head of this list.  The remaining entries are unordered.

    ContinuationBlob - This is the PAGED_RESULTS continuation blob passed to the search
        for multiple passes

Returns:

    STATUS_SUCCESS - Success

    STATUS_INVALID_PARAMETER - An invalid attribute id was encountered

    STATUS_INSUFFICIENT_MEMORY - A memory allocation failed

    STATUS_NO_MORE_ENTRIES - All of the entries have been returned.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SEARCHARG SearchArg;
    FILTER Filters[ 2 ], RootFilter;
    ENTINFSEL EntInfSel;
    ENTINFLIST *EntInfList;
    ULONG ClassId, FlagValue, i;
    SEARCHRES *SearchRes = NULL;
    PLSAPDS_FOREST_TRUST_BLOB TrustBlob;
    BOOLEAN CloseTransaction = FALSE;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDsForestSearchXRefs\n" ));

    RtlZeroMemory( &SearchArg, sizeof( SEARCHARG ) );

    //
    //  See if we already have a transaction going
    //
    // If one already exists, we'll use the existing transaction and not
    //  delete the thread state at the end.
    //

    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                            LSAP_DB_DS_OP_TRANSACTION,
                                        NullObject,
                                        &CloseTransaction );

    if ( NT_SUCCESS( Status ) ) {

        //
        // Build the filter.  The thing to search on is the flag and the class id.
        //
        ClassId = CLASS_CROSS_REF;
        FlagValue = (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN);

        RtlZeroMemory( Filters, sizeof (Filters) );
        RtlZeroMemory( &RootFilter, sizeof (RootFilter) );

        Filters[ 0 ].pNextFilter = &Filters[ 1 ];
        Filters[ 0 ].choice = FILTER_CHOICE_ITEM;
        Filters[ 0 ].FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        Filters[ 0 ].FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
        Filters[ 0 ].FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof( ULONG );
        Filters[ 0 ].FilterTypes.Item.FilTypes.ava.Value.pVal = ( PUCHAR )&ClassId;

        Filters[ 1 ].pNextFilter = NULL;
        Filters[ 1 ].choice = FILTER_CHOICE_ITEM;
        Filters[ 1 ].FilterTypes.Item.choice = FI_CHOICE_BIT_AND;
        Filters[ 1 ].FilterTypes.Item.FilTypes.ava.type = ATT_SYSTEM_FLAGS;
        Filters[ 1 ].FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof( ULONG );
        Filters[ 1 ].FilterTypes.Item.FilTypes.ava.Value.pVal = ( PUCHAR )&FlagValue;

        RootFilter.choice = FILTER_CHOICE_AND;
        RootFilter.FilterTypes.And.count = ( USHORT )( sizeof( Filters ) / sizeof( FILTER ) );
        RootFilter.FilterTypes.And.pFirstFilter = Filters;

        SearchArg.pObject = LsaDsStateInfo.DsPartitionsContainer;
        SearchArg.choice = SE_CHOICE_IMMED_CHLDRN;
        SearchArg.bOneNC = TRUE;
        SearchArg.pFilter = &RootFilter;
        SearchArg.searchAliases = FALSE;
        SearchArg.pSelection = &EntInfSel;

        //
        // Build the list of attributes to return
        //
        EntInfSel.attSel = EN_ATTSET_LIST;
        EntInfSel.AttrTypBlock.attrCount = LsapDsForestInfoSearchAttributeCount;
        EntInfSel.AttrTypBlock.pAttr = LsapDsForestInfoSearchAttributes;
        EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

        //
        // Build the Commarg structure
        //
        LsapDsInitializeStdCommArg( &( SearchArg.CommArg ), 0 );

        if ( *ContinuationBlob ) {

            RtlCopyMemory( &SearchArg.CommArg.PagedResult,
                           *ContinuationBlob,
                           sizeof( PAGED_RESULT ) );

        } else {

            SearchArg.CommArg.PagedResult.fPresent = TRUE;
        }

        SearchArg.CommArg.ulSizeLimit = LSAPDS_FOREST_MAX_SEARCH_ITEMS;

        LsapDsSetDsaFlags( TRUE );

        //
        // Do the search
        //
        DirSearch( &SearchArg, &SearchRes );
        LsapDsContinueTransaction();

        if ( SearchRes ) {

            Status = LsapDsMapDsReturnToStatusEx( &SearchRes->CommRes );

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Save off the continuation blob
        //
        if ( NT_SUCCESS( Status ) ) {

            if ( *ContinuationBlob ) {

                LsapFreeLsaHeap( *ContinuationBlob );
                *ContinuationBlob = NULL;
            }

            if ( SearchRes->PagedResult.fPresent ) {


                *ContinuationBlob = LsapAllocateLsaHeap(
                                        sizeof( PAGED_RESULT ) +
                                        SearchRes->PagedResult.pRestart->structLen +
                                        sizeof( RESTART ) );

                if ( *ContinuationBlob == NULL ) {

                    Status = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    ( *ContinuationBlob )->fPresent =  SearchRes->PagedResult.fPresent;
                    ( *ContinuationBlob )->pRestart = ( PRESTART ) ( ( PBYTE )*ContinuationBlob +
                                                                        sizeof( PAGED_RESULT ) );
                    RtlCopyMemory( ( *ContinuationBlob )->pRestart,
                                   SearchRes->PagedResult.pRestart,
                                   SearchRes->PagedResult.pRestart->structLen );
                }
            }
        }

        //
        // Now, save off all of the information returned from the search
        //
        if ( NT_SUCCESS( Status ) ) {

            EntInfList = &SearchRes->FirstEntInf;
            for ( i = 0; i < SearchRes->count && NT_SUCCESS( Status ); i++) {

                Status = LsapDsForestBuildTrustEntryForAttrBlock(
                             EnterpriseDnsName,
                             &EntInfList->Entinf.AttrBlock,
                             &TrustBlob );

                EntInfList = EntInfList->pNextEntInf;

                if ( NT_SUCCESS( Status ) ) {

                    if ( TrustBlob->ForestRoot ) {

                        InsertHeadList( TrustList,
                                        &TrustBlob->Next );

                    } else if ((TrustBlob->ParentTrust )
                                || (TrustBlob->TreeRoot)) {

                        InsertTailList( TrustList,
                                        &TrustBlob->Next );
                    }
                    else
                    {
                        //
                        // Simply do not return the entry. This
                        // occurs sometimes at install time when all
                        // the information has not yet replicated out
                        //


                        LsapDsForestFreeTrustBlob( TrustBlob );

                        LsapFreeLsaHeap( TrustBlob );
                    }
                }

            }
        }

        //
        // See if we should indicate that there are no more entries
        //
        if ( NT_SUCCESS( Status ) &&
             ( SearchRes->count == 0 || !SearchRes->PagedResult.fPresent ) ) {

            Status = STATUS_NO_MORE_ENTRIES;
        }

        //
        // By destroying the thread state, the allocated memory is freed as well.  This is
        // required to keep the heap from becoming bloated
        //
        LsapDsDeleteAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                         LSAP_DB_DS_OP_TRANSACTION,
                                     NullObject,
                                     CloseTransaction );
    }

    LsapDsDebugOut(( DEB_FTRACE, "LsapDsForestSearchXRefs: 0x%lx\n", Status ));
    return( Status );
}




VOID
LsapDsForestFreeChild(
    IN PLSAPR_TREE_TRUST_INFO ChildNode
    )
/*++

Routine Description:

    Free all buffers pointed to by a Tree Trust Info structure.

Arguments:

    ForestTrustInfo - Info to be deleted

Returns:

    VOID

--*/
{
    ULONG i;

    for ( i = 0; i < ChildNode->Children; i++ ) {

        LsapDsForestFreeChild( &ChildNode->ChildDomains[ i ] );
    }

    LsapFreeLsaHeap( ChildNode->ChildDomains );
    LsapFreeLsaHeap( ChildNode->DnsDomainName.Buffer );
    LsapFreeLsaHeap( ChildNode->FlatName.Buffer );
    LsapFreeLsaHeap( ChildNode->DomainSid );

}


VOID
LsaIFreeForestTrustInfo(
    IN PLSAPR_FOREST_TRUST_INFO ForestTrustInfo
    )
/*++

Routine Description:

    This function will free the information obtained via a LsaIQueryForestTrustInfo call

Arguments:

    ForestTrustInfo - Info to be deleted

Returns:

    VOID

--*/
{
    ULONG i, j;
    LsapDsDebugOut(( DEB_FTRACE, "LsaIFreeForestTrustInfo\n" ));

    if ( ForestTrustInfo == NULL ) {

        return;
    }

    //
    // Free all the information in the structure...
    //

    LsapDsForestFreeChild( &ForestTrustInfo->RootTrust );


    //
    // Then free the structure itself.
    //

    LsapFreeLsaHeap( ForestTrustInfo );

    LsapDsDebugOut(( DEB_FTRACE, "LsaIFreeForestTrustInfo returned\n" ));
    return;
}



NTSTATUS
LsapBuildForestTrustInfoLists(
    IN LSAPR_HANDLE PolicyHandle OPTIONAL,
    IN PLIST_ENTRY TrustList
    )
/*++

Routine Description:

    This function returns a linked list of all the cross ref objects on the system.

Arguments:

    PolicyHandle - Handle to use for the operation.
        If NULL, LsapPolicyHandle will be used.

    TrustList - Points to the head of a list where the trust blobs will be returned.
        The trust blob representing the root of the forest is returned at the head of this list.  The remaining entries are unordered.

Returns:

    Misc status codes.

--*/
{
    NTSTATUS  Status = STATUS_SUCCESS;
    PAGED_RESULT *ContinuationBlob = NULL;
    PPOLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfo = NULL;

    LsapDsDebugOut(( DEB_FTRACE, "LsapBuildForestTrustInfoLists\n" ));

    //
    // Make sure the DS is installed
    //
    if ( LsaDsStateInfo.DsPartitionsContainer == NULL ) {

        return( STATUS_INVALID_DOMAIN_STATE );
    }

    //
    // Get the current Dns domain information
    //
    Status = LsapDbQueryInformationPolicy( PolicyHandle ? PolicyHandle : LsapPolicyHandle,
                                           PolicyDnsDomainInformation,
                                           ( PLSAPR_POLICY_INFORMATION * )&PolicyDnsDomainInfo );

    if ( NT_SUCCESS( Status ) ) {
        //
        // A DS transaction is not required, nor is a lock to be held for this routine
        //

        //
        // Build the list of all the trust objects
        //
        while ( NT_SUCCESS( Status )  ) {

            Status = LsapDsForestSearchXRefs( ( PUNICODE_STRING )&PolicyDnsDomainInfo->DnsForestName,
                                              TrustList,
                                              &ContinuationBlob );

            if ( Status == STATUS_NO_MORE_ENTRIES ) {

                Status = STATUS_SUCCESS;
                break;
            }
        }

        if ( Status == STATUS_NO_MORE_ENTRIES ) {

            Status = STATUS_SUCCESS;
        }

        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           ( PLSAPR_POLICY_INFORMATION )PolicyDnsDomainInfo );

    }

    LsapExitFunc( "LsapBuildForestTrustInfoLists", Status );

    return( Status );
}


NTSTATUS
LsapDsForestProcessTrustBlob(
    IN PLSAPDS_FOREST_TRUST_BLOB ParentTrustBlob,
    OUT PLSAPR_TREE_TRUST_INFO ParentNode,
    IN PLIST_ENTRY TrustList,
    IN PLIST_ENTRY UsedList,
    IN PUNICODE_STRING CurrentDnsDomainName,
    IN OUT PLSAPR_TREE_TRUST_INFO *ParentReference
    )
/*++

Routine Description:

    This routine fills in the trust info for all the children of a particular cross ref object.

Arguments:

    ParentTrustBlob - Specifies the TrustBlob representing a parent cross ref object
        ParentTrustBlob is expected to be on TrustList.  Upon return, it will be on UsedList.

    ParentNode - Specifies the node to be filled in with the information from ParentTrustBlob.
        The Children are filled in, too.

        This buffer should be free by calling LsapDsForestFreeChild.

    TrustList - Pointer to the head of a linked list of all (remaining) cross ref objects.

    UsedList - Pointer to the head of a linked list of all cross ref object that have already been
        processed.

        Entries in the UsedList have several fields cleared as the pointed to memory is copied to ParentNode.

    CurrentDnsDomainName - Dns domain name of the domain this code is running on

    ParentReference - Returns the address of the structure that is the parent of
        CurrentDnsDomainName

        This reference should not be freed.  It is simply a pointer to one of the entries returned
        in ParentNode.

Returns:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed

--*/

{
    NTSTATUS Status;
    LIST_ENTRY ChildList;
    ULONG i, Children = 0;
    PLIST_ENTRY NextEntry, ChildEntry;
    PLSAPDS_FOREST_TRUST_BLOB Current;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDsForestFindChildrenForChildren\n" ));

    //
    // Initialization.
    //

    InitializeListHead( &ChildList );

    //
    // Fill in the ParentNode
    //

    // Clear it so the caller has a clean deallocation model
    RtlZeroMemory( ParentNode, sizeof(*ParentNode) );

    // Just copy the pointer to save memory allocation
    ParentNode->DnsDomainName = ParentTrustBlob->DomainName;
    ParentTrustBlob->DomainName.Buffer = NULL;

    ParentNode->FlatName = ParentTrustBlob->FlatName;
    ParentTrustBlob->FlatName.Buffer = NULL;

    if ( ParentTrustBlob->TreeRoot || ParentTrustBlob->ForestRoot ) {
        ParentNode->Flags |= LSAI_FOREST_ROOT_TRUST;
    }

    if ( ParentTrustBlob->DomainGuidSet ) {
        ParentNode->DomainGuid = ParentTrustBlob->DomainGuid;
        ParentNode->Flags |= LSAI_FOREST_DOMAIN_GUID_PRESENT;
    }

    ParentNode->DomainSid = ParentTrustBlob->DomainSid;
    ParentTrustBlob->DomainSid = NULL;

    //
    // Move this entry to the UsedList to prevent us from stumbling across this entry again
    //

    RemoveEntryList( &ParentTrustBlob->Next );
    InsertTailList( UsedList, &ParentTrustBlob->Next );


    //
    // Build a list of children of this parent
    //

    NextEntry = TrustList->Flink;

    while ( NextEntry != TrustList ) {

        Current = CONTAINING_RECORD( NextEntry,
                                     LSAPDS_FOREST_TRUST_BLOB,
                                     Next );

        ChildEntry = NextEntry;
        NextEntry = NextEntry->Flink;

        //
        // All nodes that think we are their parent are our children.
        //  Plus all tree roots are the children of the forest root.
        //
        if ( RtlCompareMemory( &ParentTrustBlob->ObjectGuid,
                               &Current->Parent,
                               sizeof( GUID ) ) == sizeof( GUID ) ||
             ( ParentTrustBlob->ForestRoot && Current->TreeRoot ) ) {

            Children++;
            RemoveEntryList( ChildEntry );

            InsertTailList( &ChildList,
                             ChildEntry );

        }

    }

    //
    // Handle the children
    //

    if ( Children != 0 ) {

        //
        // Allocate an array large enough for the children
        //
        ParentNode->ChildDomains = ( PLSAPR_TREE_TRUST_INFO )LsapAllocateLsaHeap(
                                                    Children * sizeof( LSAPR_TREE_TRUST_INFO ) );

        if ( ParentNode->ChildDomains == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        ParentNode->Children = Children;
        RtlZeroMemory( ParentNode->ChildDomains,
                       Children * sizeof( LSAPR_TREE_TRUST_INFO ) );



        //
        // Process each child
        //

        ChildEntry = ChildList.Flink;
        for ( i = 0; i < Children; i++ ) {

            Current = CONTAINING_RECORD( ChildEntry,
                                         LSAPDS_FOREST_TRUST_BLOB,
                                         Next );
            ChildEntry = ChildEntry->Flink;

            //
            // If the child we're currently processing is for the domain we're running on,
            //  then the ParentNode is that of the parent of this domain.
            //

            if ( !*ParentReference &&
                 RtlEqualUnicodeString( &Current->DomainName,
                                        CurrentDnsDomainName,
                                        TRUE ) ) {

                *ParentReference = ParentNode;
            }


            //
            // Process the node
            //

            Status = LsapDsForestProcessTrustBlob(
                                Current,                         // Trust blob to process
                                &ParentNode->ChildDomains[ i ],  // Slot for it
                                TrustList,
                                UsedList,
                                CurrentDnsDomainName,
                                ParentReference );

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }

        }

    }

    Status = STATUS_SUCCESS;

Cleanup:

    //
    // Put any dangling child entries onto the used list
    //

    while ( ChildList.Flink != &ChildList ) {

        ChildEntry = ChildList.Flink;

        RemoveEntryList( ChildEntry );
        InsertTailList( UsedList, ChildEntry );
    }

    LsapDsDebugOut(( DEB_FTRACE, "LsapDsForestFindChildrenForChildren returned 0x%lx\n", Status ));

    return( Status );
}



NTSTATUS
LsapDsBuildForestTrustInfo(
    OUT PLSAPR_FOREST_TRUST_INFO ForestTrustInfo,
    IN PLIST_ENTRY TrustList,
    IN PUNICODE_STRING CurrentDnsDomainName
    )
/*++

Routine Description:

    Convert the TrustList linear list of cross ref objects into a tree shape.

Arguments:
    ForestTrustInfo -

Returns:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed

--*/

{
    NTSTATUS Status;
    PLSAPDS_FOREST_TRUST_BLOB Current;
    LIST_ENTRY UsedList;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDsForestBuildRootTrusts\n" ));

    //
    // Initialization
    //

    RtlZeroMemory( ForestTrustInfo, sizeof(*ForestTrustInfo) );
    InitializeListHead( &UsedList );

    //
    // There must be at least one entry
    //

    if ( TrustList->Flink == TrustList ) {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Cleanup;
    }


    //
    // The first entry on the list is the root of the tree.
    //

    Current = CONTAINING_RECORD( TrustList->Flink,
                                 LSAPDS_FOREST_TRUST_BLOB,
                                 Next );

    //
    // Process the entry
    //

    Status = LsapDsForestProcessTrustBlob(
                        Current,
                        &ForestTrustInfo->RootTrust,
                        TrustList,
                        &UsedList,
                        CurrentDnsDomainName,
                        &ForestTrustInfo->ParentDomainReference );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    // In theory, Trust list should be empty now


Cleanup:

    //
    // Merge the used list onto the front of the TrustList
    //

    if ( !IsListEmpty( &UsedList ) ) {
        PLIST_ENTRY TrustFront;
        TrustFront = TrustList->Flink;

        // Link head of used list onto head of trust list
        TrustList->Flink = UsedList.Flink;
        UsedList.Flink->Blink = TrustList;

        // List previous head of trustlist onto tail of root list
        UsedList.Blink->Flink = TrustFront;
        TrustFront->Blink = UsedList.Blink;

        InitializeListHead( &UsedList );

    }

    LsapDsDebugOut(( DEB_FTRACE, "LsapDsForestBuildRootTrusts returned 0x%lx\n", Status ));

    return( Status );
}



NTSTATUS
NTAPI
LsaIQueryForestTrustInfo(
    IN LSAPR_HANDLE PolicyHandle,
    OUT PLSAPR_FOREST_TRUST_INFO *ForestTrustInfo
    )
/*++

Routine Description:

    Will enumerate all of the domains in an organization and return them as
    a list.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    ForestTrustInfo - Where the computed trust info tree is returned.  Must be freed with
        LsaIFreeForestTrustInfo

Returns:

    STATUS_SUCCESS - Success

    STATUS_INVALID_DOMAIN_STATE - The Ds is not installed or running at the time of the call

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed

--*/

{
    NTSTATUS  Status = STATUS_SUCCESS;
    LIST_ENTRY TrustList;
    PAGED_RESULT *ContinuationBlob = NULL;
    PPOLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfo = NULL;

    LsapDsDebugOut(( DEB_FTRACE, "LsaIQueryForestTrustInfo\n" ));

    *ForestTrustInfo = NULL;

    //
    // Make sure the DS is installed
    //
    if ( LsaDsStateInfo.DsPartitionsContainer == NULL ) {

        return( STATUS_INVALID_DOMAIN_STATE );
    }

    InitializeListHead( &TrustList );


    //
    // Get the current Dns domain information
    //
    Status = LsapDbQueryInformationPolicy(
                 LsapPolicyHandle,
                 PolicyDnsDomainInformation,
                 ( PLSAPR_POLICY_INFORMATION * )&PolicyDnsDomainInfo );

    if ( NT_SUCCESS( Status ) ) {
        //
        // A DS transaction is not required, nor is a lock to be held for this routine
        //

        //
        // Build the list of all the trust objects
        //
        while ( NT_SUCCESS( Status )  ) {

            Status = LsapDsForestSearchXRefs( ( PUNICODE_STRING )&PolicyDnsDomainInfo->DnsForestName,
                                              &TrustList,
                                              &ContinuationBlob );

            if ( Status == STATUS_NO_MORE_ENTRIES ) {

                Status = STATUS_SUCCESS;
                break;
            }
        }

        //
        // Now, if we have all of the trusts, build the enterprise info
        //
        if ( NT_SUCCESS( Status ) ) {

            *ForestTrustInfo = ( PLSAPR_FOREST_TRUST_INFO )LsapAllocateLsaHeap(
                                                                sizeof( LSAPR_FOREST_TRUST_INFO ) );
            if ( *ForestTrustInfo == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                RtlZeroMemory( *ForestTrustInfo, sizeof( LSAPR_FOREST_TRUST_INFO ) );

                //
                // Fill in the ForestTrustInfo.
                //
                Status = LsapDsBuildForestTrustInfo( *ForestTrustInfo,
                                                     &TrustList,
                                                     &PolicyDnsDomainInfo->DnsDomainName );

            }
        }

        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           ( PLSAPR_POLICY_INFORMATION )PolicyDnsDomainInfo );

    }

    //
    // Delete the trust lists
    //
    LsapDsForestFreeTrustBlobList( &TrustList );

    if ( ContinuationBlob != NULL ) {
        LsapFreeLsaHeap( ContinuationBlob );
    }


    if (!NT_SUCCESS(Status))
    {
        //
        // Cleanup on Failure
        //
        if (NULL!=(*ForestTrustInfo))
        {
           LsaIFreeForestTrustInfo(*ForestTrustInfo);
           *ForestTrustInfo = NULL;
        }
    }
    LsapDsDebugOut(( DEB_FTRACE, "LsaIQueryForestTrustInfo returned 0x%lx\n", Status ));

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\lsads.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    lsads.c

Abstract:

    Implemntation of the LSA/Ds interface and support routines

Author:

    Mac McLain          (MacM)       Jan 17, 1997

Environment:

    User Mode

Revision History:

--*/
#include <lsapch2.h>
#include <dbp.h>
#include <sertlp.h>
#ifdef DS_LOOKUP
#include <dslookup.h>
#endif
#include <align.h>
#include <windns.h>
#include <alloca.h>

#if DBG

    DEFINE_DEBUG2(LsaDs);

    DEBUG_KEY   LsaDsDebugKeys[] = {{DEB_ERROR,         "Error"},
                                    {DEB_WARN,          "Warn"},
                                    {DEB_TRACE,         "Trace"},
                                    {DEB_UPGRADE,       "Upgrade"},
                                    {DEB_POLICY,        "Policy"},
                                    {DEB_REPL,          "WRepl"},
                                    {DEB_FIXUP,         "Fixup"},
                                    {DEB_NOTIFY,        "Notify"},
                                    {DEB_DSNOTIFY,      "DsNotify"},
                                    {DEB_FTRACE,        "FTrace"},
                                    {DEB_LOOKUP,        "Lookup"},
                                    {DEB_HANDLE,        "Handle"},
                                    {DEB_FTINFO,        "FtInfo"},
                                    {0,                 NULL}};

HANDLE g_hDebugWait = NULL;
HANDLE g_hDebugParamEvent = NULL;
HKEY g_hDebugParamKey = NULL;

extern DWORD LsaDsInfoLevel;

void
LsaDsGetDebugRegParams(
    IN HKEY ParamKey
    )
/*++

    Routine Description:

                Gets the debug paramaters from the registry
                Sets LsaDsInfolevel for debug spew

    Arguments:  HKEY to HKLM/System/CCS/Control/LSA

--*/
{

    DWORD cbType, tmpInfoLevel = LsaDsInfoLevel, cbSize = sizeof(DWORD);
    DWORD dwErr;

    dwErr = RegQueryValueExW(
        ParamKey,
        L"LsaDsInfoLevel",
        NULL,
        &cbType,
        (LPBYTE)&tmpInfoLevel,
        &cbSize
        );

    if (dwErr != ERROR_SUCCESS) {

        if (dwErr ==  ERROR_FILE_NOT_FOUND) {

            // no registry value is present, don't want info
            // so reset to defaults

            LsaDsInfoLevel = DEB_ERROR;

        } else {

            DebugLog((DEB_WARN, "Failed to query DebugLevel: 0x%x\n", dwErr));
        }
    }

    LsaDsInfoLevel = tmpInfoLevel;

    dwErr = RegQueryValueExW(
                ParamKey,
                L"LogToFile",
                NULL,
                &cbType,
                (LPBYTE)&tmpInfoLevel,
                &cbSize
                );

    if (dwErr == ERROR_SUCCESS) {

       LsaDsSetLoggingOption((BOOL) tmpInfoLevel);

    } else if (dwErr == ERROR_FILE_NOT_FOUND) {

       LsaDsSetLoggingOption(FALSE);
    }

    return;
}


VOID
LsaDsWatchDebugParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus
    )
/*++

    Routine Description:

                Sets RegNotifyChangeKeyValue() on param key, initializes
                debug level, then utilizes thread pool to wait on
                changes to this registry key.  Enables dynamic debug
                level changes, as this function will also be callback
                if registry key modified.

    Arguments:  pCtxt is actually a HANDLE to an event.  This event
                will be triggered when key is modified.

--*/
{
    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;

    if (NULL == g_hDebugParamKey) { // first time we've been called.

        lRes = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   L"System\\CurrentControlSet\\Control\\Lsa",
                   0,
                   KEY_READ,
                   &g_hDebugParamKey
                   );

        if (ERROR_SUCCESS != lRes) {

            DebugLog((DEB_WARN,"Failed to open LSA debug parameters key: 0x%x\n", lRes));
            goto Reregister;
        }
    }

    if (NULL != g_hDebugWait) {

        Status = RtlDeregisterWait(g_hDebugWait);

        if (!NT_SUCCESS(Status)) {

            DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
            goto Reregister;
        }
    }

    lRes = RegNotifyChangeKeyValue(
               g_hDebugParamKey,
               FALSE,
               REG_NOTIFY_CHANGE_LAST_SET,
               (HANDLE) pCtxt,
               TRUE
               );

    if (ERROR_SUCCESS != lRes) {

        DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
        // we're tanked now. No further notifications, so get this one
    }

    LsaDsGetDebugRegParams(g_hDebugParamKey);

Reregister:

    Status = RtlRegisterWait(
                 &g_hDebugWait,
                 (HANDLE) pCtxt,
                 LsaDsWatchDebugParamKey,
                 (HANDLE) pCtxt,
                 INFINITE,
                 WT_EXECUTEINPERSISTENTIOTHREAD |
                    WT_EXECUTEONLYONCE
                 );
}


VOID
LsapDsDebugInitialize()
{
    LsaDsInitDebug( LsaDsDebugKeys );

    g_hDebugParamEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if ( NULL == g_hDebugParamEvent ) {

        DebugLog((DEB_WARN, "CreateEvent for g_hDebugParamEvent failed - 0x%x\n", GetLastError()));

    } else {

        LsaDsWatchDebugParamKey( g_hDebugParamEvent, FALSE );
    }
}

#else // !DBG

VOID
LsapDsDebugInitialize()
{
}

#endif

//
// extern definitions.
//
DWORD LsapDsThreadState;        // Defined in lsads.h, referenced in spinit.c

ULONG
LsapClassIdFromObjType(
    IN LSAP_DB_OBJECT_TYPE_ID  DsObjType
    );





PVOID
LsapDsAlloc(
    IN  DWORD   dwLen
    )
/*++

Routine Description:

    This function is the allocator for the LSA DS functions

Arguments:

    dwLen - Number of bytes to allocate

Return Value:

    Pointer to allocated memory on success or NULL on failure

--*/
{
    PLSADS_PER_THREAD_INFO CurrentThreadInfo;

    //
    // If there's no DS thread state,
    //  we shouldn't be here.
    //

    if ( !THQuery()) {
        ASSERT( THQuery() );
        return NULL;
    }

    //
    // Otherwise simply allocate from the DS thread state.
    //
    return( THAlloc( dwLen ) );
}



VOID
LsapDsFree(
    IN  PVOID   pvMemory
    )
/*++

Routine Description:

    This function frees memory allocated by LsapDsAlloc

Arguments:

    pvMemory -- memory to free

Return Value:

    VOID

--*/
{
    ASSERT( THQuery() );

    if ( THQuery() ) {

        THFree( pvMemory );
    }

}



NTSTATUS
LsapDsInitializeDsStateInfo(
    IN  LSADS_INIT_STATE    DsInitState
    )
/*++

Routine Description:

    This routine will initialize the global DS State information that is used
    to contol the behavior of all of the lsa operations

Arguments:

    DsInitState -- State the DS booted off of

Return Value:

    STATUS_SUCCES       --  Success

    STATUS_NO_MEMORY    --  A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSADS_INIT_STATE CalledInitState = DsInitState;

    if ( LsapDsDsSetup == DsInitState ) {

        //
        // At the time of modification, it is difficult to tell what
        // ramifications running with an init state of LsapDsDsSetup
        // will have since it is untested. So, let's be safe and translate
        // LsapDsDsSetup to LsapDsDs, which is a known state to
        // be in.
        //

        DsInitState = LsapDsDs;

    }

    LsaDsInitState = DsInitState ;

    if ( DsInitState != LsapDsDs ) {

        //
        // Use the dummy functions
        //

        LsaDsStateInfo.DsFuncTable.pOpenTransaction  = LsapDsOpenTransactionDummy;
        LsaDsStateInfo.DsFuncTable.pApplyTransaction = LsapDsApplyTransactionDummy;
        LsaDsStateInfo.DsFuncTable.pAbortTransaction = LsapDsAbortTransactionDummy;

    } else if ( !LsaDsStateInfo.DsInitializedAndRunning ) {

        Status = LsaISamIndicatedDsStarted( FALSE );
    }

    //
    // Initialize the domain and default policy object references
    //
    if ( NT_SUCCESS( Status ) &&
         LsapDsWriteDs &&
         CalledInitState != LsapDsDsSetup ) {

        //
        // Fixup our trusted domain objects, if necessary
        //

        Status = LsapDsFixupTrustedDomainObjectOnRestart();
    }

#if DBG
    if ( NT_SUCCESS( Status ) ) {

        LsapDsDebugOut(( 0, "LsapDsInitializeDsStateInfo succeeded\n", Status ));

    } else if ( LsapProductType == NtProductLanManNt ) {

        LsapDsDebugOut(( DEB_ERROR, "LsapDsInitializeDsStateInfo failed: 0x%lx\n", Status ));
    }
#endif

    return( Status );
}


NTSTATUS
LsapDsUnitializeDsStateInfo(
    VOID
    )
/*++

Routine Description:

    This routine will undo what the initialization did.  Only valid for the setup case

Arguments:

    None

Return Value:

    STATUS_SUCCES       --  Success

--*/
{
    LsaDsStateInfo.UseDs = FALSE;
    LsapDsIsRunning = FALSE;
    LsaDsStateInfo.WriteLocal  = TRUE;

    //
    // Go back to using the dummy functions
    //

    LsaDsStateInfo.DsFuncTable.pOpenTransaction  = LsapDsOpenTransactionDummy;
    LsaDsStateInfo.DsFuncTable.pApplyTransaction = LsapDsApplyTransactionDummy;
    LsaDsStateInfo.DsFuncTable.pAbortTransaction = LsapDsAbortTransactionDummy;

    LsaDsStateInfo.DsInitializedAndRunning = FALSE;

    return( STATUS_SUCCESS );
}


NTSTATUS
LsapDsMapDsReturnToStatus (
    ULONG DsStatus
    )
/*++

Routine Description:

    Maps a DS error to NTSTATUS

Arguments:

    DsStatus -   DsStatus to map

Return Values:

    STATUS_SUCCESS  -   Ds call succeeded
    STATUS_UNSUCCESSFUL - Ds call failed

--*/
{

    NTSTATUS Status;

    switch ( DsStatus )
    {
    case 0L:
        Status = STATUS_SUCCESS;
        break;

    default:
        Status = STATUS_UNSUCCESSFUL;
        LsapDsDebugOut(( DEB_TRACE, "DS Error %lu mapped to NT Status 0x%lx\n",
                         DsStatus, Status ));
        break;
    }

    return( Status );
}


NTSTATUS
LsapDsMapDsReturnToStatusEx (
    IN COMMRES *pComRes
    )
/*++

Routine Description:

    Maps a DS error to NTSTATUS

Arguments:

    DsStatus -   DsStatus to map

Return Values:

    STATUS_SUCCESS  -   Ds call succeeded
    STATUS_UNSUCCESSFUL - Ds call failed

--*/
{

    NTSTATUS Status = STATUS_UNSUCCESSFUL;


    switch ( pComRes->errCode ) {

    case 0:
        Status = STATUS_SUCCESS;
        break;

    case attributeError:
        switch ( pComRes->pErrInfo->AtrErr.FirstProblem.intprob.problem ) {

        case PR_PROBLEM_NO_ATTRIBUTE_OR_VAL:
            Status = STATUS_NOT_FOUND;
            break;

        case PR_PROBLEM_INVALID_ATT_SYNTAX:
        case PR_PROBLEM_UNDEFINED_ATT_TYPE:
        case PR_PROBLEM_CONSTRAINT_ATT_TYPE:
            Status = STATUS_DATA_ERROR;
            break;

        case PR_PROBLEM_ATT_OR_VALUE_EXISTS:
            Status = STATUS_OBJECT_NAME_COLLISION;
            break;
        }
        break;

    case nameError:
        switch ( pComRes->pErrInfo->NamErr.problem ) {

        case NA_PROBLEM_NO_OBJECT:
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            break;

        case NA_PROBLEM_BAD_ATT_SYNTAX:
        case NA_PROBLEM_BAD_NAME:
            Status = STATUS_OBJECT_NAME_INVALID;
            break;

        }
        break;

    case updError:
        switch ( pComRes->pErrInfo->UpdErr.problem ) {
        case UP_PROBLEM_ENTRY_EXISTS:
            Status = STATUS_OBJECT_NAME_COLLISION;
            break;

        case UP_PROBLEM_NAME_VIOLATION:
            Status = STATUS_OBJECT_NAME_INVALID;
            break;

        }
        break;

    case securityError:
        switch ( pComRes->pErrInfo->SecErr.problem ) {

        case SE_PROBLEM_INSUFF_ACCESS_RIGHTS:
            Status = STATUS_ACCESS_DENIED;
            break;

        }
        break;

    case serviceError:
        switch ( pComRes->pErrInfo->SvcErr.problem ) {
        case  SV_PROBLEM_BUSY:
            Status = STATUS_DEVICE_BUSY;
            break;
        }


    }

    THClearErrors();
    return( Status );
}


VOID
LsapDsInitializeStdCommArg (
    IN  COMMARG    *pCommArg,
    IN  ULONG       Flags
    )
/*++

Routine Description:

    Initialized a COMMARG structue with a standard set of options used by LsapDs routines

Arguments:

    pCommArg - Pointer to the COMMARG structure to be initialized

Return Values:
    None

--*/
{
    /* Get the default values... */
    InitCommarg(pCommArg);

    /* ...and override some of them */
    pCommArg->Svccntl.DerefAliasFlag          = DA_NEVER;
    pCommArg->Svccntl.fUnicodeSupport         = TRUE;
    pCommArg->Svccntl.localScope              = TRUE;
    pCommArg->Svccntl.SecurityDescriptorFlags = 0;
    pCommArg->ulSizeLimit                     = 0x20000;

    if ( FLAG_ON( Flags, LSAPDS_USE_PERMISSIVE_WRITE ) ) {

        pCommArg->Svccntl.fPermissiveModify = TRUE;
    }

    if ( FLAG_ON( Flags, LSAPDS_READ_DELETED ) ) {

        pCommArg->Svccntl.makeDeletionsAvail = TRUE;
    }
}




ULONG
LsapClassIdFromObjType(
    IN LSAP_DB_OBJECT_TYPE_ID ObjType
    )
/*++

Routine Description:

    Maps from an LSA object type to a DS Class ID

Arguments:

    DsObjType - Type of the object

Return Values:
    ClassID of object type on success
    0xFFFFFFFF on failure

--*/
{
    ULONG ClassId = 0xFFFFFFFF;

    switch ( ObjType ) {

    case TrustedDomainObject:
        ClassId = LsapDsClassIds[ LsapDsClassTrustedDomain ];
        break;

    case SecretObject:
        ClassId = LsapDsClassIds[ LsapDsClassSecret ];
        break;

    }

    return( ClassId );
}

NTSTATUS
LsapAllocAndInitializeDsNameFromUnicode(
    IN  LSAP_DSOBJ_TYPE         DsObjType,
    IN  PLSA_UNICODE_STRING     pObjectName,
    OUT PDSNAME                *pDsName
    )
/*++

Routine Description:

    This function constructs a DSNAME structure and optional RDN for the
    stated object.

Arguments:

    DsObjType -- Type of the object to be created.

    pObjectName -- Name of the object to be created.

    pObjectPath -- Root path under which to create the object

    pDsName -- Where the DS Name structure is returned.  Free via LsapDsFree

Return Value:

    STATUS_SUCCESS  --  Success

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;

    DWORD       dwLen;
    DWORD       dwNameLen = 0;

    if (pObjectName == NULL ) {

        return( STATUS_INVALID_PARAMETER );
    }

    if ( NT_SUCCESS( Status) ) {

        //
        // Determine our length...
        //
        dwNameLen = LsapDsGetUnicodeStringLenNoNull( pObjectName ) / sizeof(WCHAR);

        dwLen = DSNameSizeFromLen( dwNameLen );

        //
        // Now, allocate it...
        //
        *pDsName = LsapDsAlloc( dwLen );

        if ( *pDsName == NULL ) {

            Status = STATUS_NO_MEMORY;

        } else {

            (*pDsName)->structLen = dwLen;

            //
            // Length doesn't include trailing NULL
            //
            (*pDsName)->NameLen = dwNameLen;

            RtlCopyMemory( (*pDsName)->StringName, pObjectName->Buffer, pObjectName->Length );

        }
    }

    return(Status);

}


NTSTATUS
LsapDsCopyDsNameLsa(
    OUT PDSNAME *Dest,
    IN PDSNAME Source
    )
/*++

Routine Description:

    This function copies one

Arguments:

    DsObjType -- Type of the object to be created.

    pObjectName -- Name of the object to be created.

    Flags -- Flags to control the various actions of the create

    cItems -- Number of attributes to set

    pAttrTypeList -- List of attribute types

    pAttrValList -- List of attribute values

Return Value:

    STATUS_SUCCESS  --  Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if ( Source == NULL ) {

        *Dest = NULL;

    } else {

        *Dest = LsapAllocateLsaHeap( Source->structLen );

        if ( *Dest == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            RtlCopyMemory( *Dest, Source, Source->structLen );
        }
    }

    return( Status );
}



NTSTATUS
LsapDsCreateAndSetObject(
    IN  LSAP_DSOBJ_TYPE         DsObjType,
    IN  PLSA_UNICODE_STRING     pObjectName,
    IN  ULONG                   Flags,
    IN  ULONG                   cItems,
    IN  ATTRTYP                *pAttrTypeList,
    IN  ATTRVAL                *pAttrValList
    )
/*++

Routine Description:

    This function creates the specified DS object and sets the given
    attributes on the object

Arguments:

    DsObjType -- Type of the object to be created.

    pObjectName -- Name of the object to be created.

    Flags -- Flags to control the various actions of the create

    cItems -- Number of attributes to set

    pAttrTypeList -- List of attribute types

    pAttrValList -- List of attribute values

Return Value:

    STATUS_SUCCESS  --  Success

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    PDSNAME     pDSName;
    ADDARG      AddArg;
    ADDRES     *AddRes = NULL;
    ATTR       *pAddResAttributes;
    ATTRBLOCK   AddResAttrBlock;
    ULONG       i;

    LsapEnterFunc( "LsapDsCreateAndSetObject" );

    ASSERT( pObjectName != NULL );

    RtlZeroMemory( &AddArg, sizeof( ADDARG ) );

    //
    // Build the DSName
    //
    Status = LsapAllocAndInitializeDsNameFromUnicode( DsObjType, pObjectName, &pDSName );

    if ( NT_SUCCESS( Status ) ) {

        //
        // Initialize our memory for our structures.
        //
        pAddResAttributes = LsapDsAlloc( sizeof(ATTR) * cItems );

        if ( pAddResAttributes == NULL ) {

            Status = STATUS_NO_MEMORY;

        } else {

            for ( i = 0 ; i < cItems ; i++ ) {

                LSAP_DS_INIT_ATTR( pAddResAttributes[i], pAttrTypeList[i], 1, &(pAttrValList[i]) );

            }

            AddResAttrBlock.attrCount = cItems;
            AddResAttrBlock.pAttr     = pAddResAttributes;

            AddArg.pObject      = pDSName;
            AddArg.AttrBlock    = AddResAttrBlock;
            LsapDsInitializeStdCommArg( &(AddArg.CommArg), 0 );
        }

        //
        // Now, do the create
        //
        if ( NT_SUCCESS( Status ) ) {

            //
            // Turn off fDSA flag. This is to force the core DS to perform
            // the access ck. Only the core DS has the knowledge to consider
            // the security descriptor on the logical parent in the DS. Do
            // not turn of the fDSA flag if this is an upgrade ( theoritically
            // for trusted clients too ). fDSA for Ds is analogous to trusted
            // client in LSA.
            //

            if ( !FLAG_ON( Flags, LSAPDS_CREATE_TRUSTED ) ) {

                LsapDsSetDsaFlags( FALSE );

            }

            DirAddEntry( &AddArg, &AddRes );


            if ( AddRes ) {

                Status = LsapDsMapDsReturnToStatusEx( &AddRes->CommRes );

            } else {

                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

            LsapDsContinueTransaction();

            if ( !FLAG_ON( Flags, LSAPDS_CREATE_TRUSTED ) ) {

                LsapDsSetDsaFlags( TRUE );

            }

            LsapDsDebugOut(( DEB_TRACE, "DirAddEntry on %wZ returned 0x%lx\n",
                             pObjectName,  Status ));
        }

        LsapDsFree(pDSName);

    } else {

        LsapDsDebugOut(( DEB_TRACE,
                         "LsapAllocAndInitializeDsNameFromUnicode on %wZ returned 0x%lx\n",
                         pObjectName, Status ));
    }


    LsapExitFunc( "LsapDsCreateAndSetObject", Status );
    return( Status );
}



NTSTATUS
LsapDsCreateObjectDs(
    IN LSAP_DSOBJ_TYPE DsObjType,
    IN PDSNAME ObjectName,
    IN ULONG Flags,
    IN ATTRBLOCK *AttrBlock
    )
/*++

Routine Description:

    This function creates the specified DS object and sets the given
    attributes on the object

Arguments:

    DsObjType -- Type of the object to be created.

    ObjectName -- Dsname of the object to be created.

    Flags -- Flags to control the various actions of the create

    Attrs -- Optional list of attributes to set on the object

Return Value:

    STATUS_SUCCESS  --  Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ADDARG AddArg;
    ADDRES *AddRes = NULL;

    LsapEnterFunc( "LsapDsCreateObjectDs" );

    RtlZeroMemory( &AddArg, sizeof (ADDARG ) );
    AddArg.pObject = ObjectName;
    RtlCopyMemory( &AddArg.AttrBlock, AttrBlock, sizeof( ATTRBLOCK ) );
    LsapDsInitializeStdCommArg( &AddArg.CommArg, 0 );


    if ( !FLAG_ON( Flags, LSAPDS_CREATE_TRUSTED ) ) {

        LsapDsSetDsaFlags( FALSE );

    }

    //
    // Do the add
    //
    DirAddEntry( &AddArg, &AddRes );

    if ( AddRes ) {

        Status = LsapDsMapDsReturnToStatusEx( &AddRes->CommRes );

    } else {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    LsapDsContinueTransaction();

    if ( !FLAG_ON( Flags, LSAPDS_CREATE_TRUSTED ) ) {

        LsapDsSetDsaFlags( TRUE );

    }

    LsapDsDebugOut(( DEB_TRACE, "DirAddEntry on %ws returned 0x%lx\n",
                     LsapDsNameFromDsName( ObjectName ),  Status ));

    LsapExitFunc( "LsapDsCreateObjectDs", Status );
    return( Status );
}





NTSTATUS
LsapDsRemove (
    IN  PDSNAME     pObject
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    REMOVEARG   Remove;
    REMOVERES  *RemoveRes = NULL;

    RtlZeroMemory( &Remove, sizeof( REMOVEARG ) );

    //
    // Initialize the commarg struct
    //
    LsapDsInitializeStdCommArg( &Remove.CommArg, 0 );
    Remove.pObject = pObject;

    //
    // Do the call
    //
    DirRemoveEntry( &Remove, &RemoveRes );

    if ( RemoveRes ) {

        Status = LsapDsMapDsReturnToStatusEx( &RemoveRes->CommRes );

    } else {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    LsapDsContinueTransaction();



    return( Status );
}




NTSTATUS
LsapDsRead (
    IN  PUNICODE_STRING pObject,
    IN  ULONG               fFlags,
    IN  ATTRBLOCK          *pAttributesToRead,
    OUT ATTRBLOCK          *pAttributeValues
    )
/*++

Routine Description:

    This function reads the specified attributes from the given object of the
    specified type.  It servers as the primary interface between the LSA and the
    DS for reading a property/object

Arguments:

    pObject - DSNAME of the object

    fFlags - Read flags

    ObjType - Type of LSA object to be read

    pReadAttributes - Attributes to be read

    pAttributeValues - Value of the attributes that were read.


Return Value:

    STATUS_SUCCESS - Success

--*/

{
    NTSTATUS    Status;
    PDSNAME     DsName = NULL;

    Status = STATUS_SUCCESS;

    //
    // By the time we get here, everything should be valid...
    //
    ASSERT( pObject != NULL );
    ASSERT( pAttributesToRead != NULL && pAttributesToRead->attrCount > 0 );
    ASSERT( pAttributeValues != NULL );

    //
    // Build the DSName
    //
    Status = LsapAllocAndInitializeDsNameFromUnicode(
                 LsapDsObjUnknown,
                 pObject,
                 &DsName
                 );


    if ( NT_SUCCESS( Status ) ) {


        Status = LsapDsReadByDsName( DsName,
                                     fFlags,
                                     pAttributesToRead,
                                     pAttributeValues );

        LsapDsFree( DsName );
    }

    return( Status );
}


NTSTATUS
LsapDsReadByDsName(
    IN  PDSNAME DsName,
    IN  ULONG Flags,
    IN  ATTRBLOCK *pAttributesToRead,
    OUT ATTRBLOCK *pAttributeValues
    )
/*++

Routine Description:

    This function reads the specified attributes from the given object of the
    specified type.  It servers as the primary interface between the LSA and the
    DS for reading a property/object

Arguments:

    DsName - DSNAME of the object

    Flags - Read flags

    ObjType - Type of LSA object to be read

    pReadAttributes - Attributes to be read

    pAttributeValues - Value of the attributes that were read.


Return Value:

    STATUS_SUCCESS - Success

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS, Status2;
    ENTINFSEL   EntryInf;
    READARG     ReadArg;
    READRES    *ReadRes = NULL;
    ULONG       i;

    //
    // By the time we get here, everything should be valid...
    //
    ASSERT( DsName != NULL );
    ASSERT( pAttributesToRead != NULL && pAttributesToRead->attrCount > 0 );
    ASSERT( pAttributeValues != NULL );


    ASSERT( THQuery() );

    if ( !THQuery() ) {

        return( STATUS_RXACT_INVALID_STATE );
    }


    //
    // Initialize the ENTINFSEL structure
    //
    EntryInf.attSel     = EN_ATTSET_LIST;
    EntryInf.infoTypes  = EN_INFOTYPES_TYPES_VALS;


    //
    // Initialize the READARG structure
    //
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    ReadArg.pObject     = DsName;
    ReadArg.pSel        = &EntryInf;

    //
    // Initialize the commarg struct
    //
    LsapDsInitializeStdCommArg( &ReadArg.CommArg, Flags );

    EntryInf.AttrTypBlock.pAttr = LsapDsAlloc( pAttributesToRead->attrCount * sizeof(ATTR ) );

    if ( EntryInf.AttrTypBlock.pAttr == NULL ) {

        Status = STATUS_NO_MEMORY;

    } else {

        EntryInf.AttrTypBlock.attrCount = pAttributesToRead->attrCount;

        for ( i = 0 ; i < pAttributesToRead->attrCount ; i++ ) {

            EntryInf.AttrTypBlock.pAttr[i].attrTyp = pAttributesToRead->pAttr[i].attrTyp;
            EntryInf.AttrTypBlock.pAttr[i].AttrVal.valCount =
                                            pAttributesToRead->pAttr[i].AttrVal.valCount;
            EntryInf.AttrTypBlock.pAttr[i].AttrVal.pAVal =
                                            pAttributesToRead->pAttr[i].AttrVal.pAVal;
            EntryInf.attSel = EN_ATTSET_LIST;
            EntryInf.infoTypes = EN_INFOTYPES_TYPES_VALS;
        }

    }


    //
    // Do the call
    //
    if ( NT_SUCCESS( Status ) ) {

        DirRead( &ReadArg, &ReadRes );

        if ( ReadRes ) {

            Status = LsapDsMapDsReturnToStatusEx( &ReadRes->CommRes );

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        LsapDsContinueTransaction();
    }

    //
    // Now, build the attr block going back
    //
    if ( NT_SUCCESS( Status ) ) {

        pAttributeValues->attrCount = ReadRes->entry.AttrBlock.attrCount;
        pAttributeValues->pAttr     = ReadRes->entry.AttrBlock.pAttr;

    }

    return( Status );
}




NTSTATUS
LsapDsWrite(
    IN  PUNICODE_STRING pObject,
    IN  ULONG           Flags,
    IN  ATTRBLOCK       *Attributes
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    MODIFYARG    Modify;
    MODIFYRES   *ModifyRes;
    ATTRMODLIST *AttrMod = NULL;
    INT          i;
    PDSNAME      DsName;


    ASSERT( pObject );
    ASSERT( Attributes->pAttr );
    ASSERT( Flags != 0 );

    RtlZeroMemory( &Modify, sizeof( MODIFYARG ) );

    //
    // Build the DSName
    //
    Status = LsapAllocAndInitializeDsNameFromUnicode(
                 LsapDsObjUnknown,
                 pObject,
                 &DsName
                 );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsapDsWriteByDsName( DsName,
                                      Flags,
                                      Attributes
                                      );

        LsapDsFree( DsName );

    }

    return( Status );
}


NTSTATUS
LsapDsWriteByDsName(
    IN  PDSNAME DsName,
    IN  ULONG  Flags,
    IN  ATTRBLOCK *Attributes
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    MODIFYARG    Modify;
    MODIFYRES   *ModifyRes = NULL;
    ATTRMODLIST *AttrMod = NULL;
    INT          i, AttrModIndex = 0;


    ASSERT( DsName );
    ASSERT( Attributes );
    ASSERT( Attributes->pAttr );

    RtlZeroMemory( &Modify, sizeof( MODIFYARG ) );

    //
    // If there are no attributes, simply return success.  Otherwise, DirModifyEntry will
    // av.
    //
    if ( Attributes->attrCount == 0 ) {

        return( Status );
    }

    //
    // Initialize the AttrMod structure
    //
    if ( Attributes->attrCount > 1 ) {

        AttrMod = LsapDsAlloc( sizeof(ATTRMODLIST) * ( Attributes->attrCount - 1 ) );

        if ( AttrMod == NULL ) {

            Status = STATUS_NO_MEMORY;

        } else {

            //
            // Copy the attrs into the ATTRMODLIST
            //
            for ( i = 0; i < (INT)Attributes->attrCount - 1 ; i++) {

                AttrMod[i].pNextMod = &AttrMod[i + 1];
                AttrMod[i].choice   = (USHORT)( Flags & LSAPDS_WRITE_TYPES );

                RtlCopyMemory( &AttrMod[i].AttrInf,
                               &Attributes->pAttr[i + 1],
                               sizeof( ATTR ) );

            }


            AttrMod[i - 1].pNextMod = NULL;
        }
    }


    if ( NT_SUCCESS( Status ) ) {

        //
        // Set the root node...
        //
        Modify.FirstMod.pNextMod = AttrMod;
        Modify.FirstMod.choice   = (USHORT)( Flags & LSAPDS_WRITE_TYPES );

        RtlCopyMemory( &Modify.FirstMod.AttrInf,
                       &Attributes->pAttr[0],
                       sizeof( ATTR ) );

        //
        // Setup the MODIFYARG structure
        //
        Modify.pObject = DsName;
        Modify.count = (USHORT)Attributes->attrCount;

        LsapDsInitializeStdCommArg( &Modify.CommArg, Flags );

        if ( FlagOn( Flags, LSAPDS_REPL_CHANGE_URGENTLY ) ) {

            Modify.CommArg.Svccntl.fUrgentReplication = TRUE;
        }


        //
        // Make the call
        //
        DirModifyEntry( &Modify, &ModifyRes );

        if ( ModifyRes ) {

            Status = LsapDsMapDsReturnToStatusEx( &ModifyRes->CommRes );

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        LsapDsContinueTransaction();

        LsapDsFree( AttrMod );
    }

    return( Status );
}



NTSTATUS
LsapDsLsaAttributeToDsAttribute(
    IN  PLSAP_DB_ATTRIBUTE  LsaAttribute,
    OUT PATTR               Attr
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Length = 0, Value;
    PDSNAME DsName;
    PLARGE_INTEGER LargeInt;


    if ( LsaAttribute->AttribType == LsapDbAttribDsNameAsUnicode ) {

        if ( LsaAttribute->AttributeValue != NULL &&
                ( ( PUNICODE_STRING )LsaAttribute->AttributeValue )->Length != 0 ) {

            Length = DSNameSizeFromLen( LsapDsGetUnicodeStringLenNoNull(
                                        (PUNICODE_STRING)LsaAttribute->AttributeValue) / sizeof( WCHAR ) );
        } else {

            return( STATUS_INVALID_PARAMETER );
        }
    } else if ( LsaAttribute->AttribType == LsapDbAttribIntervalAsULong ) {

        Length = sizeof( LARGE_INTEGER );

    } else if ( LsaAttribute->AttribType == LsapDbAttribUShortAsULong ) {

        Length = sizeof( ULONG );
    }

    Attr->attrTyp  = LsaAttribute->DsAttId;
    Attr->AttrVal.valCount = 1;

    Attr->AttrVal.pAVal = LsapDsAlloc( Length + sizeof( ATTRVAL ) );

    if ( Attr->AttrVal.pAVal == NULL ) {

        Status = STATUS_NO_MEMORY;

    } else {

        switch ( LsaAttribute->AttribType ) {
        case LsapDbAttribUnicode:

            //
            // These unicode strings are self relative.  Note that we have to write them out
            // without a trailing NULL!
            //
            Attr->AttrVal.pAVal->valLen =
                    LsapDsGetSelfRelativeUnicodeStringLenNoNull(
                                                (PUNICODE_STRING_SR)LsaAttribute->AttributeValue);
            Attr->AttrVal.pAVal->pVal = LsaAttribute->AttributeValue;
            Attr->AttrVal.pAVal->pVal += sizeof(UNICODE_STRING_SR);

            break;

        case LsapDbAttribMultiUnicode:
            Status = STATUS_NOT_IMPLEMENTED;
            break;

        case LsapDbAttribGuid:  // Fall through
        case LsapDbAttribTime:  // Fall through
        case LsapDbAttribSid:   // Fall through
        case LsapDbAttribDsName:// Fall through
        case LsapDbAttribPByte: // Fall through

            Attr->AttrVal.pAVal->valLen = LsaAttribute->AttributeValueLength;
            Attr->AttrVal.pAVal->pVal = LsaAttribute->AttributeValue;
            break;

        case LsapDbAttribULong:
            Attr->AttrVal.pAVal->valLen = sizeof(ULONG);
            Attr->AttrVal.pAVal->pVal = LsaAttribute->AttributeValue;
            break;

        case LsapDbAttribUShortAsULong:
            Attr->AttrVal.pAVal->valLen = sizeof(ULONG);
            Attr->AttrVal.pAVal->pVal = ( ( PBYTE ) Attr->AttrVal.pAVal ) + sizeof( ATTRVAL );

            Value = *( PULONG )LsaAttribute->AttributeValue;
            Value &= 0xFFFF;

            RtlCopyMemory( Attr->AttrVal.pAVal->pVal,
                           &Value,
                           sizeof( ULONG ) );
            break;

        case LsapDbAttribDsNameAsUnicode:

            DsName = (PDSNAME)( ( ( PBYTE ) Attr->AttrVal.pAVal ) + sizeof( ATTRVAL ) );
            DsName->structLen = Length;
            DsName->NameLen = LsapDsGetUnicodeStringLenNoNull(
                               (PUNICODE_STRING)LsaAttribute->AttributeValue) / sizeof( WCHAR );

            RtlCopyMemory( DsName->StringName,
                           ((PUNICODE_STRING)LsaAttribute->AttributeValue)->Buffer,
                           (DsName->NameLen + 1 ) * sizeof ( WCHAR ) );

            Attr->AttrVal.pAVal->pVal = (PUCHAR)DsName;
            Attr->AttrVal.pAVal->valLen = DsName->structLen;
            break;

        case LsapDbAttribIntervalAsULong:

            LargeInt = ( PLARGE_INTEGER )( ( ( PBYTE ) Attr->AttrVal.pAVal ) + sizeof( ATTRVAL ) );
            *LargeInt = RtlConvertUlongToLargeInteger( *( PULONG )LsaAttribute->AttributeValue );
            Attr->AttrVal.pAVal->pVal = (PUCHAR)LargeInt;
            Attr->AttrVal.pAVal->valLen = sizeof( LARGE_INTEGER );
            break;

        default:
            ASSERT(FALSE);
            break;
        }

    }


    return( Status );
}

NTSTATUS
LsapDsDsAttributeToLsaAttribute(
    IN  ATTRVAL             *AttVal,
    OUT PLSAP_DB_ATTRIBUTE   LsaAttribute
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Len, CopyLen;
    PUNICODE_STRING_SR UnicodeStringSr;
    PBYTE Buff, DsBuff;

    //
    // If we were supplied a buffer in the LSA attribute, copy it over
    //
    if ( LsaAttribute->AttributeValue != NULL && LsaAttribute->AttributeValueLength != 0 ) {

        if ( AttVal->valLen > LsaAttribute->AttributeValueLength ) {

            Status = STATUS_BUFFER_OVERFLOW;

        } else {

            RtlCopyMemory( LsaAttribute->AttributeValue, AttVal->pVal,
                           AttVal->valLen );

            LsaAttribute->AttributeValueLength = AttVal->valLen;
        }

        LsaAttribute->MemoryAllocated = FALSE;
        return( Status ) ;
    }

    //
    // Allocate a new buffer using LSA heap, and then copy it over...
    //
    Len = AttVal->valLen;
    CopyLen = AttVal->valLen;
    DsBuff = AttVal->pVal;

    if ( LsaAttribute->AttribType == LsapDbAttribUnicode ) {

        Len += sizeof( UNICODE_STRING_SR ) + sizeof( WCHAR );

    } else if ( LsaAttribute->AttribType == LsapDbAttribDsNameAsUnicode ) {

        Len = ( LsapDsNameLenFromDsName( (PDSNAME)(AttVal->pVal) ) + 1 ) * sizeof( WCHAR ) +
               sizeof( UNICODE_STRING );

        CopyLen = 0;
        DsBuff = (PBYTE)((PDSNAME)AttVal->pVal)->StringName;

    } else if ( LsaAttribute->AttribType == LsapDbAttribIntervalAsULong ) {

        Len = sizeof( ULONG );
        CopyLen = sizeof( ULONG );
        DsBuff = DsBuff;

    } else if ( Len == 0 ) {

        Buff = NULL;
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Buff = MIDL_user_allocate( Len );

    if ( Buff == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Exit;

    } else if (LsaAttribute->AttribType != LsapDbAttribUnicode &&
               LsaAttribute->AttribType != LsapDbAttribDsNameAsUnicode) {

        RtlCopyMemory( Buff, DsBuff, CopyLen );
    }

    switch ( LsaAttribute->AttribType ) {

    case LsapDbAttribUnicode:
        //
        // Make the string self relative
        //
        UnicodeStringSr = (PUNICODE_STRING_SR)Buff;
        RtlCopyMemory( Buff + sizeof(UNICODE_STRING_SR), DsBuff, AttVal->valLen );
        UnicodeStringSr->Length = (USHORT)AttVal->valLen;
        UnicodeStringSr->MaximumLength = UnicodeStringSr->Length + sizeof( WCHAR );
        UnicodeStringSr->Offset = sizeof(UNICODE_STRING_SR);
        ((PWSTR)(Buff+sizeof(UNICODE_STRING_SR)))[UnicodeStringSr->Length / sizeof(WCHAR)] = UNICODE_NULL;

        LsaAttribute->AttributeValue = Buff;
        LsaAttribute->AttributeValueLength = AttVal->valLen + sizeof( UNICODE_STRING_SR );
        break;

    case LsapDbAttribDsNameAsUnicode:
        //
        // Make the string self relative
        //
        UnicodeStringSr = (PUNICODE_STRING_SR)Buff;
        RtlCopyMemory( Buff + sizeof(UNICODE_STRING_SR), DsBuff,
                       LsapDsNameLenFromDsName( (PDSNAME)(AttVal->pVal) ) * sizeof( WCHAR ) );

        UnicodeStringSr->Length =
                   (USHORT)LsapDsNameLenFromDsName( (PDSNAME)(AttVal->pVal) ) * sizeof( WCHAR );
        UnicodeStringSr->MaximumLength = UnicodeStringSr->Length + sizeof( WCHAR );
        UnicodeStringSr->Offset = sizeof(UNICODE_STRING_SR);
        ((PWSTR)(Buff+sizeof(UNICODE_STRING_SR)))[UnicodeStringSr->Length / sizeof(WCHAR)] = UNICODE_NULL;

        LsaAttribute->AttributeValue = Buff;
        LsaAttribute->AttributeValueLength =
                        UnicodeStringSr->MaximumLength + sizeof( UNICODE_STRING_SR );
        break;

    case LsapDbAttribMultiUnicode:
        Status = STATUS_NOT_IMPLEMENTED;
        break;

    case LsapDbAttribSecDesc:
        LsaAttribute->AttributeValue = Buff;
        LsaAttribute->AttributeValueLength = AttVal->valLen;
        break;

    case LsapDbAttribGuid:
        Status = LsapDbMakeGuidAttribute( (GUID *)Buff,
                                          LsaAttribute->AttributeName,
                                          LsaAttribute );

        break;

    case LsapDbAttribSid:
        Status = LsapDbMakeSidAttribute( (PSID)Buff,
                                         LsaAttribute->AttributeName,
                                         LsaAttribute );


        break;

    case LsapDbAttribPByte:  // FALL THROUGH
    case LsapDbAttribULong:  // FALL THROUGH
    case LsapDbAttribUShortAsULong: // FALL THROUGH
    case LsapDbAttribTime:
        Status = LsapDbMakePByteAttributeDs( Buff,
                                             AttVal->valLen,
                                             LsaAttribute->AttribType,
                                             LsaAttribute->AttributeName,
                                             LsaAttribute );
        break;

    case LsapDbAttribIntervalAsULong:

        LsaAttribute->AttributeValue = Buff;
        LsaAttribute->AttributeValueLength = sizeof( ULONG );
        break;

    default:

        LsapDsDebugOut(( DEB_ERROR,
                         "Unexpected attribute type: %lu\n",
                         LsaAttribute->AttribType ));

        Status = STATUS_INVALID_PARAMETER;
        break;


    }

Exit:

    if ( NT_SUCCESS(Status) ) {
        LsaAttribute->MemoryAllocated = TRUE;
    } else {
        MIDL_user_free( Buff );
        LsaAttribute->AttributeValue = NULL;
        LsaAttribute->AttributeValueLength = 0;
        LsaAttribute->MemoryAllocated = FALSE;
    }

    return( Status );
}


NTSTATUS
LsapDsSearchMultiple(
    IN  ULONG       Flags,
    IN  PDSNAME     pContainer,
    IN  PATTR       pAttrsToMatch,
    IN  ULONG       cAttrs,
    OUT SEARCHRES **SearchRes
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SEARCHARG   SearchArg;
    FILTER      *Filters, RootFilter;
    ENTINFSEL   EntInfSel;
    ULONG       i;

    RtlZeroMemory( &SearchArg, sizeof( SEARCHARG ) );

    //
    //  Make sure we already have a transaction going
    //
    ASSERT( THQuery() );

    //
    // Build the filters
    //
    Filters = LsapDsAlloc(cAttrs * sizeof(FILTER) );

    if ( Filters == NULL ) {

        Status = STATUS_NO_MEMORY;

    } else {

        for ( i = 0; i < cAttrs; i++ ) {

            Filters[i].pNextFilter = &Filters[i + 1];
            Filters[i].choice                                     = FILTER_CHOICE_ITEM;
            Filters[i].FilterTypes.Item.choice                    = FI_CHOICE_EQUALITY;
            Filters[i].FilterTypes.Item.FilTypes.ava.type         = pAttrsToMatch[i].attrTyp;
            Filters[i].FilterTypes.Item.FilTypes.ava.Value.valLen =
                                                        pAttrsToMatch[i].AttrVal.pAVal->valLen;
            Filters[i].FilterTypes.Item.FilTypes.ava.Value.pVal =
                                                        pAttrsToMatch[i].AttrVal.pAVal->pVal;
        }

        if ( NT_SUCCESS( Status ) ) {

            //
            // Fill in the filter
            //
            Filters[cAttrs - 1].pNextFilter = NULL;

            if ( cAttrs > 1 ) {

                RtlZeroMemory( &RootFilter, sizeof (RootFilter));

                RootFilter.pNextFilter = NULL;

                if ( FLAG_ON( Flags, LSAPDS_SEARCH_OR ) ) {

                    RootFilter.choice = FILTER_CHOICE_OR;
                    RootFilter.FilterTypes.Or.count = (USHORT)cAttrs;
                    RootFilter.FilterTypes.Or.pFirstFilter = Filters;

                } else {

                    RootFilter.choice = FILTER_CHOICE_AND;
                    RootFilter.FilterTypes.And.count = (USHORT)cAttrs;
                    RootFilter.FilterTypes.And.pFirstFilter = Filters;

                }

                SearchArg.pFilter  = &RootFilter;

            } else {

                SearchArg.pFilter = Filters;
            }

            //
            // Fill in the search argument
            //
            SearchArg.pObject = pContainer;

            if ( ( Flags & LSAPDS_SEARCH_FLAGS ) == 0 || FLAG_ON( Flags, LSAPDS_SEARCH_TREE ) ) {

                SearchArg.choice = SE_CHOICE_WHOLE_SUBTREE;

            } else if ( FLAG_ON( Flags, LSAPDS_SEARCH_LEVEL ) ) {

                SearchArg.choice = SE_CHOICE_IMMED_CHLDRN;

            } else if ( FLAG_ON( Flags, LSAPDS_SEARCH_ROOT ) ) {

                SearchArg.choice = SE_CHOICE_BASE_ONLY;

            } else {

                Status = STATUS_INVALID_PARAMETER;
            }

            if ( NT_SUCCESS( Status ) ) {

                SearchArg.searchAliases = FALSE;
                SearchArg.pSelection    = &EntInfSel;
                SearchArg.bOneNC        = FLAG_ON(Flags, LSAPDS_SEARCH_ALL_NCS) ?
                                                        FALSE : TRUE;

                EntInfSel.attSel                 = EN_ATTSET_LIST;
                EntInfSel.AttrTypBlock.attrCount = 0;
                EntInfSel.AttrTypBlock.pAttr     = NULL;
                EntInfSel.infoTypes              = EN_INFOTYPES_TYPES_ONLY;

                //
                // Build the Commarg structure
                //
                LsapDsInitializeStdCommArg( &( SearchArg.CommArg ), 0 );

                //
                // Make the call
                //
                *SearchRes = NULL;
                DirSearch( &SearchArg, SearchRes );

                if ( *SearchRes ) {

                    Status = LsapDsMapDsReturnToStatusEx( &(*SearchRes)->CommRes );

                } else {

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                LsapDsContinueTransaction();
            }
        }

    }

    return( Status ) ;
}


NTSTATUS
LsapDsSearchUnique(
    IN  ULONG       Flags,
    IN  PDSNAME     pContainer,
    IN  PATTR       pAttrsToMatch,
    IN  ULONG       cAttrs,
    OUT PDSNAME    *ppFoundName
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    BOOLEAN     CloseTransaction;
    SEARCHRES  *SearchRes;
    ULONG       i;

    //
    // Check the parameters for validity
    //
    ASSERT( pAttrsToMatch );
    ASSERT( pAttrsToMatch->AttrVal.pAVal );
    ASSERT( pContainer );
    ASSERT( ppFoundName );


    //
    //  See if we already have a transaction going
    //
    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                            LSAP_DB_NO_LOCK |
                                            LSAP_DB_DS_OP_TRANSACTION,
                                        NullObject,
                                        &CloseTransaction );

    if ( !NT_SUCCESS( Status ) ) {

        return( Status );
    }


    //
    // Do the search
    //
    Status = LsapDsSearchMultiple( Flags,
                                   pContainer,
                                   pAttrsToMatch,
                                   cAttrs,
                                   &SearchRes );

    if ( NT_SUCCESS( Status ) ) {


        //
        // See if we found the object
        //
        if ( SearchRes->count == 0 ) {

            Status = STATUS_OBJECT_NAME_NOT_FOUND;

        } else if ( SearchRes->count == 1 ) {

           //
           // Copy the name
           //
           *ppFoundName = LsapAllocateLsaHeap(
                              SearchRes->FirstEntInf.Entinf.pName->structLen );

           if ( *ppFoundName == NULL ) {

                Status = STATUS_NO_MEMORY;

           } else {

                RtlCopyMemory( *ppFoundName,
                               SearchRes->FirstEntInf.Entinf.pName,
                               SearchRes->FirstEntInf.Entinf.pName->structLen );

           }



        } else {

           //
           // More than one object was found!
           //
           Status = STATUS_OBJECT_NAME_COLLISION;

        }
    }


    //
    // Destruction of the thread state will delete any memory allocated via the DS
    //
    LsapDsDeleteAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                     LSAP_DB_NO_LOCK |
                                     LSAP_DB_DS_OP_TRANSACTION,
                                 NullObject,
                                 CloseTransaction );

    return( Status );

}




NTSTATUS
LsapDsFindUnique(
    IN ULONG Flags,
    IN PDSNAME NCName OPTIONAL,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN ATTRVAL *Attribute,
    IN ATTRTYP AttId,
    OUT PDSNAME *FoundObject
    )
/*++

Routine Description:

    This function will find the object with the given attribute.  The attribute must be indexed.

Arguments:

    Flags - Flags to control the operation of the find

    NCName - DSNAME of the naming context under which to look
        If not specified, the default NCNAME is used.

    ObjectTypeId - ObjectType represented by DSNAME.
        The corresponding lock will be locked.
        If the ObjectType isn't known, pass AllObject to grab all locks.

    Attribute - Attribute to be matched

    AttrTyp - Attribute id of the attribute

    FoundObject - Where the object's dsname is returned, if it is found

Return Value:

    STATUS_SUCCESS - Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    FINDARG FindArg;
    FINDRES *FindRes;
    BOOLEAN CloseTransaction = FALSE;
    LsapEnterFunc( "LsapDsFindUnique ");

    //
    //  See if we already have a transaction going
    //
    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                            LSAP_DB_DS_OP_TRANSACTION,
                                        ObjectTypeId,
                                        &CloseTransaction );

    if ( !NT_SUCCESS( Status ) ) {

        LsapExitFunc( "LsapDsFindUnique", Status );
        return( Status );
    }

    //
    // Do the initialization
    //
    RtlZeroMemory(&FindArg,sizeof(FINDARG));
    if ( NCName == NULL ) {
        FindArg.hDomain = LsaDsStateInfo.DsDomainHandle;
    } else {

        FindArg.hDomain = DirGetDomainHandle( NCName );

        if (0==FindArg.hDomain)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        LsapDsContinueTransaction();
    }

    FindArg.AttId = AttId;
    RtlCopyMemory( &FindArg.AttrVal,
                   Attribute,
                   sizeof( ATTRVAL ) );
    LsapDsInitializeStdCommArg( &( FindArg.CommArg ), 0 );

    DirFindEntry( &FindArg, &FindRes );

    if ( FindRes ) {

        Status = LsapDsMapDsReturnToStatusEx( &(FindRes->CommRes ) );

    } else {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( NT_SUCCESS( Status ) ) {

        //
        // Copy the return value using the lsa allocator
        //
        Status = LsapDsCopyDsNameLsa( FoundObject,
                                      FindRes->pObject );

    }

    LsapDsContinueTransaction();

Error:

    //
    // Destruction of the thread state will delete any memory allocated via the DS
    //
    LsapDsDeleteAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                     LSAP_DB_DS_OP_TRANSACTION,
                                 ObjectTypeId,
                                 CloseTransaction );

    LsapExitFunc( "LsapDsFindUnqiue", Status );
    return( Status );
}



NTSTATUS
LsapDsIsSecretDsTrustedDomain(
    IN PUNICODE_STRING SecretName,
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation OPTIONAL,
    IN ULONG Options,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TDObjHandle OPTIONAL,
    OUT BOOLEAN *IsTrustedDomainSecret
    )
/*++

Routine Description:

    This function will determine if the indicated secret is the global secret for a trust object.

Arguments:

    SecretName - Name of secret to check

    ObjectInformation - LsaDb information on the object
        Need not be specified if no TDObjHandle is to be returned.

    Options - Options to use for the access
        Need not be specified if no TDObjHandle is to be returned.

    DesiredAccess - Access to open the object with
        Need not be specified if no TDObjHandle is to be returned.

    TDObjHandle - Where the object handle is returned
        If not specified, no handle is returned.

    IsTrustedDomainSecret - A TRUE is returned here if this secret is indeed a trusted domain
                            secret.

Return Value:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PWSTR   pwszSecretName;
    UNICODE_STRING TdoName;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustedDomainListEntry;
    BOOLEAN AcquiredTrustedDomainListReadLock = FALSE;

    LsapEnterFunc( "LsapDsIsSecretDsTrustedDomain" );

    *IsTrustedDomainSecret = FALSE;

    LsapDsReturnSuccessIfNoDs

    if ( LsaDsStateInfo.DsInitializedAndRunning == FALSE ) {

        LsapDsDebugOut((DEB_ERROR,
                        "LsapDsIsSecretDsTrustedDomain: Object %wZ, Ds is not started\n ",
                        SecretName ));

        goto Cleanup;
    }

    //
    // Convert the secret name to a TDO name.
    //
    if ( SecretName->Length <= (LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_LENGTH * sizeof(WCHAR)) ) {
        goto Cleanup;
    }

    pwszSecretName = SecretName->Buffer + LSAP_DS_TRUSTED_DOMAIN_SECRET_PREFIX_LENGTH;

    LsapDsDebugOut((DEB_TRACE, "Matching secret %ws to trusted domain\n ", pwszSecretName ));
    RtlInitUnicodeString( &TdoName, pwszSecretName );

    //
    // Acquire the Read Lock for the Trusted Domain List
    //

    Status = LsapDbAcquireReadLockTrustedDomainList();

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    AcquiredTrustedDomainListReadLock = TRUE;

    //
    // Verify that the Trusted Domain List is marked as valid.
    //


    if (!LsapDbIsValidTrustedDomainList()) {
        Status = STATUS_INVALID_SERVER_STATE;
        goto Cleanup;
    }

    //
    // Lookup the name in the TDL
    //

    Status = LsapDbLookupNameTrustedDomainListEx(
                        (PLSAPR_UNICODE_STRING)&TdoName,
                        &TrustedDomainListEntry );

    if ( !NT_SUCCESS(Status)) {
        //
        // Not a trusted domain.
        //
        if ( Status == STATUS_NO_SUCH_DOMAIN ) {
            Status = STATUS_SUCCESS;
        }
        goto Cleanup;
    }

    //
    // See if this TDO is also a secret.
    //
    if ( FLAG_ON( TrustedDomainListEntry->TrustInfoEx.TrustDirection, TRUST_DIRECTION_OUTBOUND )  ) {
        *IsTrustedDomainSecret = TRUE;
    }


    //
    // If the caller wants a handle,
    //  return one.
    //
    if ( TDObjHandle ) {
        LSAP_DB_OBJECT_INFORMATION NewObjInfo;
        RtlCopyMemory( &NewObjInfo, ObjectInformation, sizeof( LSAP_DB_OBJECT_INFORMATION ) );
        NewObjInfo.ObjectTypeId = TrustedDomainObject;

        NewObjInfo.ObjectAttributes.ObjectName = &TdoName;

        Status = LsapDbOpenObject( &NewObjInfo,
                                   DesiredAccess,
                                   Options | LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET,
                                   TDObjHandle );

    }

Cleanup:
    if ( AcquiredTrustedDomainListReadLock ) {
        LsapDbReleaseLockTrustedDomainList();
    }
    LsapExitFunc( "LsapDsIsSecretDsTrustedDomain", Status );

    return( Status );
 }


NTSTATUS
LsapDsIsHandleDsObjectTypeHandle(
    IN LSAP_DB_HANDLE Handle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectType,
    OUT BOOLEAN *IsObjectHandle
    )
/*++

Routine Description:

    Determines if the object handle refers to an object of the specified type or not

Arguments:

    Handle - Handle to verify

    ObjectType - Type of object to verify

    IsObjectHandle - If TRUE, the handle refers to an object of that type

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTR     NameAttr;
    ATTRVAL  NameVal;
    ATTRBLOCK   NameBlock, ReturnBlock;
    PDSNAME  SearchName = NULL;
    BOOLEAN  CloseTransaction = FALSE;
    ULONG ReadVal, Class;
    BOOLEAN TsAllocated = FALSE;

    *IsObjectHandle = FALSE;

    LsapDsReturnSuccessIfNoDs;

    if ( !LsapDsIsHandleDsHandle( Handle ) ) {

        return( STATUS_SUCCESS );
    }

    if ( LsaDsStateInfo.DsInitializedAndRunning == FALSE ) {

        LsapDsDebugOut((DEB_TRACE,
                        "LsapDsIsHandleDsObjectTypeHandle: Object %wZ, Ds is not started\n ",
                        &Handle->LogicalNameU ));

        return( Status );
    }


    Class = LsapClassIdFromObjType( ObjectType );
    if ( Class == 0xFFFFFFFF ) {

        Status = STATUS_INVALID_PARAMETER;
    }

    //
    // Special case the situation where we're looking for a secret object but we were given a
    // trusted domain object handle
    //
    if ( ObjectType == TrustedDomainObject  &&
         ((LSAP_DB_HANDLE)Handle)->ObjectTypeId == TrustedDomainObject &&
         FLAG_ON( ((LSAP_DB_HANDLE)Handle)->Options, LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET ) ) {

         *IsObjectHandle = TRUE;
         return( STATUS_SUCCESS );
    }

    if ( ObjectType == TrustedDomainObject &&
         ((LSAP_DB_HANDLE)Handle)->ObjectTypeId == SecretObject &&
         FLAG_ON( ((LSAP_DB_HANDLE)Handle)->Options, LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET ) ) {

         *IsObjectHandle = FALSE;
         return( STATUS_SUCCESS );
    }

    if ( NT_SUCCESS( Status ) ) {

        //
        // We can't lock any locks because the caller already has some locks locked.
        //  So locking an object type specific lock might violate the locking order.
        //
        // Locking any lock doesn't help anyway.  An object can disappear out
        //  from under us due to replication or immediately after we drop the lock.
        //

        ASSERT( LsapQueryThreadInfo() );

        Status = LsapDsInitAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                                LSAP_DB_NO_LOCK |
                                                LSAP_DB_DS_OP_TRANSACTION,
                                            ObjectType,
                                            &CloseTransaction );

        if ( NT_SUCCESS( Status ) ) {
            TsAllocated = TRUE;

            Status = LsapAllocAndInitializeDsNameFromUnicode(
                         LsapDsObjUnknown,
                         (PLSA_UNICODE_STRING)&Handle->PhysicalNameDs,
                         &SearchName );

        }

    }

    if ( NT_SUCCESS( Status ) ) {

        //
        // Check for the existence of the object
        //
        NameAttr.attrTyp          = ATT_OBJECT_CLASS;
        NameAttr.AttrVal.valCount = 1;
        NameAttr.AttrVal.pAVal    = &NameVal;


        NameVal.valLen = SearchName->structLen;
        NameVal.pVal   = (PBYTE)SearchName;

        NameBlock.attrCount = 1;
        NameBlock.pAttr = &NameAttr;

        Status = LsapDsRead( &Handle->PhysicalNameDs,
                             LSAPDS_READ_NO_LOCK,
                             &NameBlock,
                             &ReturnBlock);


        if ( NT_SUCCESS( Status ) ) {

            ReadVal = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( ReturnBlock.pAttr );

            if ( ReadVal == Class ) {

                *IsObjectHandle = TRUE;
            }
        }

        LsapDsFree( SearchName );

    }

    //
    // If the object exists and we're looking for a global secret of the same name, then
    //
    if ( TsAllocated ) {
        LsapDsDeleteAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                         LSAP_DB_NO_LOCK |
                                         LSAP_DB_DS_OP_TRANSACTION,
                                     ObjectType,
                                     CloseTransaction );
    }

    return( Status );
}







NTSTATUS
LsapDsCauseTransactionToCommitOrAbort (
    IN BOOLEAN  Commit
    )
/*++

Routine Description:


Arguments:


Return Value:

    STATUS_SUCCESS - Success

--*/

{
    NTSTATUS    Status;

    ATTR   Attr;
    ENTINFSEL   EntryInf;
    READARG     ReadArg;
    READRES    *ReadRes = NULL;


    //
    // Initialize the structures
    //

    RtlZeroMemory(&Attr, sizeof(ATTR));
    Attr.attrTyp = ATT_OBJECT_CLASS;


    RtlZeroMemory(&EntryInf, sizeof(ENTINFSEL));
    EntryInf.attSel = EN_ATTSET_LIST;
    EntryInf.AttrTypBlock.attrCount = 1;
    EntryInf.AttrTypBlock.pAttr = &Attr;
    EntryInf.infoTypes = EN_INFOTYPES_TYPES_VALS;


    RtlZeroMemory(&ReadArg, sizeof(READARG));
    ReadArg.pSel        = &EntryInf;

    //
    // Initialize the commarg struct
    //
    LsapDsInitializeStdCommArg( &ReadArg.CommArg, 0 );


    //
    // If there is no transaction, just exit
    //
    if ( !THQuery() ) {

        return( STATUS_SUCCESS );
    }

    if ( !SampExistsDsTransaction() ) {

        LsapDsDebugOut(( DEB_ERROR,
                         "LsapDsCauseTransactionToCommitOrAbort invoked with no active DS "
                         "transaction\n" ));
        return( STATUS_SUCCESS );
    }

    //
    // Clear any errors in the thread state
    //

    THClearErrors();

    DirTransactControl( TRANSACT_DONT_BEGIN_END );

    ReadArg.pObject = LsaDsStateInfo.DsRoot;

    if ( Commit == FALSE ) {

        Attr.attrTyp = 0xFFFFFFFF;

    } else  {

        Attr.attrTyp = ATT_OBJECT_CLASS;

    }

    DirRead( &ReadArg, &ReadRes );

    if ( ReadRes ) {

        Status = LsapDsMapDsReturnToStatusEx( &ReadRes->CommRes );

    } else {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    DirTransactControl( TRANSACT_BEGIN_END );

    return( Status );
}




NTSTATUS
LsapDsSearchNonUnique(
    IN  ULONG       Flags,
    IN  PDSNAME     pContainer,
    IN  PATTR       pAttrsToMatch,
    IN  ULONG       Attrs,
    OUT PDSNAME   **pppFoundNames,
    OUT PULONG      pcNames
    )
/*++

Routine Description:

    This routine will search the specified container(s) in the DS for the object
    whose attributes are matched with pAttrToMatch.  The returned DSNAME structures are allocated
    via LSA memory allocators.  The returned list should be freed via a single call to
    LsapFreeLsaHeap


Arguments:

    DsInitState -- State the DS booted off of

Return Value:

    STATUS_SUCCES       --  Success

    STATUS_NO_MEMORY    --  A memory allocation failed

    STATUS_OBJECT_NAME_NOT_FOUND -- The object did not exist

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    BOOLEAN     CloseTransaction;
    ULONG       OutputLen, i;
    PBYTE       Buff;
    SEARCHRES  *SearchRes;
    ENTINFLIST *EntInfList;

    //
    // Check the parameters for validity
    //
    ASSERT( pAttrsToMatch );
    ASSERT( pContainer );
    ASSERT( pppFoundNames );
    ASSERT( pcNames );


    //
    //  See if we already have a transaction going
    //
    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                            LSAP_DB_DS_OP_TRANSACTION |
                                            LSAP_DB_NO_LOCK,
                                        PolicyObject,
                                        &CloseTransaction );

    if ( !NT_SUCCESS( Status ) ) {

        return(